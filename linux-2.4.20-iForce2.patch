diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/Documentation/input/ff.txt linux-modified/Documentation/input/ff.txt
--- linux-vanilla/Documentation/input/ff.txt	Thu Sep 13 00:34:06 2001
+++ linux-modified/Documentation/input/ff.txt	Mon Jan  6 16:48:20 2003
@@ -1,6 +1,7 @@
 Force feedback for Linux.
 By Johann Deneux <deneux@ifrance.com> on 2001/04/22.
-
+You may redistribute this file. Please remember to include shape.fig and
+interactive.fig as well.
 ----------------------------------------------------------------------------
 
 0. Introduction
@@ -38,13 +39,10 @@
 
 You then need to insert the modules into the following order:
 % modprobe joydev
-% modprobe serport
+% modprobe serport		# Only for serial
 % modprobe iforce
 % modprobe evdev
 % ./inputattach -ifor $2 &	# Only for serial
-For convenience, you may use the shell script named "ff" available from
-the cvs tree of the Linux Console Project at sourceforge. You can also
-retrieve it from http://www.esil.univ-mrs.fr/~jdeneux/projects/ff/.
 If you are using USB, you don't need the inputattach step.
 
 Please check that you have all the /dev/input entries needed:
@@ -68,7 +66,7 @@
 2.1 Does it work ?
 ~~~~~~~~~~~~~~~~~~
 There is an utility called fftest that will allow you to test the driver.
-% fftest /dev/eventXX
+% fftest /dev/input/eventXX
 
 3. Instructions to the developper
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -81,22 +79,30 @@
 #include <linux/input.h>
 #include <sys/ioctl.h>
 
+unsigned long features[1 + FF_MAX/sizeof(unsigned long)];
 int ioctl(int file_descriptor, int request, unsigned long *features);
 
-"request" must be EVIOCGBIT(EV_FF, sizeof(unsigned long))
+"request" must be EVIOCGBIT(EV_FF, size of features array in bytes )
 
 Returns the features supported by the device. features is a bitfield with the
 following bits:
-- FF_X		has an X axis (should allways be the case)
-- FF_Y		has an Y axis (usually not the case for wheels)
+- FF_X		has an X axis (usually joysticks)
+- FF_Y		has an Y axis (usually joysticks)
+- FF_WHEEL	has a wheel (usually sterring wheels)
 - FF_CONSTANT	can render constant force effects
-- FF_PERIODIC	can render periodic effects (sine, ramp, square...)
+- FF_PERIODIC	can render periodic effects (sine, triangle, square...)
+- FF_RAMP       can render ramp effects
 - FF_SPRING	can simulate the presence of a spring
-- FF_FRICTION	can simulate friction (aka drag, damper effect...)
+- FF_FRICTION	can simulate friction 
+- FF_DAMPER	can simulate damper effects
 - FF_RUMBLE	rumble effects (normally the only effect supported by rumble
 		pads)
-- 8 bits from FF_N_EFFECTS_0 containing the number of effects that can be
-		simultaneously played.
+- FF_INERTIA    can simulate inertia
+
+
+int ioctl(int fd, EVIOCGEFFECTS, int *n);
+
+Returns the number of effects the device can keep in its memory.
 
 3.2 Uploading effects to the device
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -112,7 +118,11 @@
 The content of effect may be modified. In particular, its field "id" is set
 to the unique id assigned by the driver. This data is required for performing
 some operations (removing an effect, controlling the playback).
-See <linux/input.h> for a description of the ff_effect stuct.
+This if field must be set to -1 by the user in order to tell the driver to
+allocate a new effect.
+See <linux/input.h> for a description of the ff_effect stuct. You should also
+find help in a few sketches, contained in files shape.fig and interactive.fig.
+You need xfig to visualize these files.
 
 3.3 Removing an effect from the device
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -187,8 +197,31 @@
 
 3.7 Dynamic update of an effect
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-This consists in changing some parameters of an effect while it's playing. The
-driver currently does not support that. You still have the brute-force method,
-which consists in erasing the effect and uploading the updated version. It
-actually works pretty well. You don't need to stop-and-start the effect.
+Proceed as if you wanted to upload a new effect, except that instead of
+setting the id field to -1, you set it to the wanted effect id.
+Normally, the effect is not stopped and restarted. However, depending on the
+type of device, not all paramaters can be dynamically updated. For example,
+the direction of an effect cannot be updated with iforce devices. In this
+case, the driver stops the effect, up-load it, and restart it.
+
+
+3.8 Information about the status of effects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Every time the status of an effect is changed, an event is sent. The values
+and meanings of the fields of the event are as follows:
+struct input_event {
+/* When the status of the effect changed */
+	struct timeval time;
+
+/* Set to EV_FF_STATUS */
+	unsigned short type;
+
+/* Contains the id of the effect */
+	unsigned short code;
+
+/* Indicates the status */
+	unsigned int value;
+};
 
+FF_STATUS_STOPPED	The effect stopped playing
+FF_STATUS_PLAYING	The effect started to play
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/Documentation/input/interactive.fig linux-modified/Documentation/input/interactive.fig
--- linux-vanilla/Documentation/input/interactive.fig	Thu Jan  1 02:00:00 1970
+++ linux-modified/Documentation/input/interactive.fig	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,42 @@
+#FIG 3.2
+Landscape
+Center
+Inches
+Letter  
+100.00
+Single
+-2
+1200 2
+2 1 0 2 0 7 50 0 -1 6.000 0 0 -1 0 0 6
+	 1200 3600 1800 3600 2400 4800 3000 4800 4200 5700 4800 5700
+2 2 0 1 0 7 50 0 -1 4.000 0 0 -1 0 0 5
+	 1200 3150 4800 3150 4800 6300 1200 6300 1200 3150
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 1200 4800 4800 4800
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 4
+	 2400 4800 2400 6525 1950 7125 1950 7800
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 4
+	 3000 4800 3000 6525 3600 7125 3600 7800
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 0 1 3
+	0 0 1.00 60.00 120.00
+	 3825 5400 4125 5100 5400 5100
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 0 1 3
+	0 0 1.00 60.00 120.00
+	 2100 4200 2400 3900 5400 3900
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 4800 5700 5400 5700
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 1800 3600 5400 3600
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 0 1 3
+	0 0 1.00 60.00 120.00
+	 2700 4800 2700 4425 5400 4425
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 1950 7800 3600 7800
+4 1 0 50 0 0 12 0.0000 4 135 810 2775 7725 Dead band\001
+4 0 0 50 0 0 12 0.0000 4 180 1155 5400 5700 right saturation\001
+4 0 0 50 0 0 12 0.0000 4 135 1065 5400 3600 left saturation\001
+4 0 0 50 0 0 12 0.0000 4 180 2505 5400 3900 left coeff ( positive in that case )\001
+4 0 0 50 0 0 12 0.0000 4 180 2640 5475 5100 right coeff ( negative in that case )\001
+4 0 0 50 0 0 12 0.0000 4 105 480 5400 4425 center\001
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/Documentation/input/joystick.txt linux-modified/Documentation/input/joystick.txt
--- linux-vanilla/Documentation/input/joystick.txt	Thu Sep 13 00:34:06 2001
+++ linux-modified/Documentation/input/joystick.txt	Mon Jan  6 16:48:20 2003
@@ -1,7 +1,7 @@
 		       Linux Joystick driver v2.0.0
-	       (c) 1996-2000 Vojtech Pavlik <vojtech@suse.cz>
+	       (c) 1996-2000 Vojtech Pavlik <vojtech@ucw.cz>
 			     Sponsored by SuSE
-	   $Id$
+	   $Id$
 ----------------------------------------------------------------------------
 
 0. Disclaimer
@@ -21,8 +21,8 @@
 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 
   Should you need to contact me, the author, you can do so either by e-mail
-- mail your message to <vojtech@suse.cz>, or by paper mail: Vojtech Pavlik,
-Ucitelska 1576, Prague 8, 182 00 Czech Republic
+- mail your message to <vojtech@ucw.cz>, or by paper mail: Vojtech Pavlik,
+Simunkova 1594, Prague 8, 182 00 Czech Republic
 
   For your convenience, the GNU General Public License version 2 is included
 in the package: See the file COPYING.
@@ -111,7 +111,7 @@
 	alias tty-ldisc-2 serport
 	alias char-major-13 input
 	above input joydev ns558 analog
-	options analog js=gameport
+	options analog js=gamepad
 
 2.5 Verifying that it works
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -503,15 +503,16 @@
 
 3.21 I-Force devices 
 ~~~~~~~~~~~~~~~~~~~~
-  All I-Force devices are supported by the iforce.c module. This includes:
+  All I-Force devices are supported by the iforce.o module. This includes:
 
 * AVB Mag Turbo Force
 * AVB Top Shot Pegasus
+* AVB Top Shot Force Feedback Racing Wheel
 * Logitech WingMan Force
-* Logitech WingMan Force 3D
 * Logitech WingMan Force Wheel 
-* Logitech WingMan Strike Force 3D
 * Guillemot Race Leader Force Feedback
+* Guillemot Force Feedback Racing Wheel
+* Thrustmaster Motor Sport GT
 
   To use it, you need to attach the serial port to the driver using the
 
@@ -524,6 +525,10 @@
 isn't needed.
 
   The I-Force driver now supports force feedback via the event interface.
+
+  Please note that Logitech WingMan *3D devices are _not_ supported by this
+module, rather by hid. Force feedback is not supported for those devices.
+Logitech gamepads are also hid devices.
 
 3.22 Gravis Stinger gamepad 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/Documentation/input/shape.fig linux-modified/Documentation/input/shape.fig
--- linux-vanilla/Documentation/input/shape.fig	Thu Jan  1 02:00:00 1970
+++ linux-modified/Documentation/input/shape.fig	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,65 @@
+#FIG 3.2
+Landscape
+Center
+Inches
+Letter  
+100.00
+Single
+-2
+1200 2
+2 1 0 2 0 7 50 0 -1 0.000 0 0 -1 0 0 6
+	 4200 3600 4200 3075 4950 2325 7425 2325 8250 3150 8250 3600
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 4200 3675 4200 5400
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 8250 3675 8250 5400
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 3675 3600 8700 3600
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 8775 3600 10200 3600
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 8325 3150 9075 3150
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 7500 2325 10200 2325
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 3600 3600 3000 3600
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 4125 3075 3000 3075
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 4200 5400 8175 5400
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 10125 2325 10125 3600
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 3000 3150 3000 3600
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 9075 3150 9075 3600
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 4950 2325 4950 1200
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 2
+	 7425 2325 7425 1200
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 4
+	 4200 3075 4200 2400 3600 1800 3600 1200
+2 1 1 1 0 7 50 0 -1 4.000 0 0 -1 0 0 4
+	 8250 3150 8250 2475 8775 1950 8775 1200
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 3600 1275 4950 1275
+2 1 0 1 0 7 50 0 -1 4.000 0 0 -1 1 1 2
+	0 0 1.00 60.00 120.00
+	0 0 1.00 60.00 120.00
+	 7425 1275 8700 1275
+4 1 0 50 0 0 12 0.0000 4 135 1140 6075 5325 Effect duration\001
+4 0 0 50 0 0 12 0.0000 4 180 1305 10200 3000 Effect magnitude\001
+4 0 0 50 0 0 12 0.0000 4 135 780 9150 3450 Fade level\001
+4 1 0 50 0 0 12 0.0000 4 180 1035 4275 1200 Attack length\001
+4 1 0 50 0 0 12 0.0000 4 180 885 8175 1200 Fade length\001
+4 2 0 50 0 0 12 0.0000 4 135 930 2925 3375 Attack level\001
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/Config.in linux-modified/drivers/char/joystick/Config.in
--- linux-vanilla/drivers/char/joystick/Config.in	Fri Nov 29 01:53:12 2002
+++ linux-modified/drivers/char/joystick/Config.in	Mon Jan  6 16:48:20 2003
@@ -32,8 +32,7 @@
    dep_tristate '  InterAct digital joysticks and gamepads' CONFIG_INPUT_INTERACT $CONFIG_INPUT $CONFIG_INPUT_GAMEPORT
    dep_tristate '  ThrustMaster DirectConnect joysticks and gamepads' CONFIG_INPUT_TMDC $CONFIG_INPUT $CONFIG_INPUT_GAMEPORT
    dep_tristate '  Microsoft SideWinder digital joysticks and gamepads' CONFIG_INPUT_SIDEWINDER $CONFIG_INPUT $CONFIG_INPUT_GAMEPORT
-   dep_tristate '  I-Force USB joysticks and wheels' CONFIG_INPUT_IFORCE_USB $CONFIG_INPUT $CONFIG_USB
-   dep_tristate '  I-Force Serial joysticks and wheels' CONFIG_INPUT_IFORCE_232 $CONFIG_INPUT $CONFIG_INPUT_SERIO
+   source drivers/char/joystick/iforce/Config.in
    dep_tristate '  Logitech WingMan Warrior joystick' CONFIG_INPUT_WARRIOR $CONFIG_INPUT $CONFIG_INPUT_SERIO
    dep_tristate '  LogiCad3d Magellan/SpaceMouse 6dof controller' CONFIG_INPUT_MAGELLAN $CONFIG_INPUT $CONFIG_INPUT_SERIO
    dep_tristate '  SpaceTec SpaceOrb/Avenger 6dof controller' CONFIG_INPUT_SPACEORB $CONFIG_INPUT $CONFIG_INPUT_SERIO
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/Makefile linux-modified/drivers/char/joystick/Makefile
--- linux-vanilla/drivers/char/joystick/Makefile	Fri Nov 29 01:53:12 2002
+++ linux-modified/drivers/char/joystick/Makefile	Mon Jan  6 16:54:09 2003
@@ -8,19 +8,6 @@
 
 export-objs	:= serio.o gameport.o pcigame.o
 
-# I-Force may need both USB and RS-232
-
-ifeq ($(CONFIG_INPUT_IFORCE_232),m)
-	ifeq ($(CONFIG_INPUT_IFORCE_USB),y)
-		CONFIG_INPUT_IFORCE_USB := m
-	endif
-endif
-ifeq ($(CONFIG_INPUT_IFORCE_USB),m)
-	ifeq ($(CONFIG_INPUT_IFORCE_232),y)
-		CONFIG_INPUT_IFORCE_232 := m
-	endif
-endif
-
 # Object file lists.
 
 obj-y	:=
@@ -46,8 +33,6 @@
 obj-$(CONFIG_INPUT_SPACEORB)	+= spaceorb.o
 obj-$(CONFIG_INPUT_SPACEBALL)	+= spaceball.o
 obj-$(CONFIG_INPUT_STINGER)	+= stinger.o
-obj-$(CONFIG_INPUT_IFORCE_232)	+= iforce.o
-obj-$(CONFIG_INPUT_IFORCE_USB)	+= iforce.o
 
 obj-$(CONFIG_INPUT_ANALOG)	+= analog.o
 obj-$(CONFIG_INPUT_A3D)		+= a3d.o
@@ -64,6 +49,8 @@
 obj-$(CONFIG_INPUT_TURBOGRAFX)	+= turbografx.o
 
 obj-$(CONFIG_INPUT_AMIJOY)	+= amijoy.o
+
+subdir-$(CONFIG_JOYSTICK_IFORCE)	+= iforce
 
 # The global Rules.make.
 
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/a3d.c linux-modified/drivers/char/joystick/a3d.c
--- linux-vanilla/drivers/char/joystick/a3d.c	Sat Aug  3 02:39:43 2002
+++ linux-modified/drivers/char/joystick/a3d.c	Mon Jan  6 16:48:20 2003
@@ -347,8 +347,8 @@
 	a3d->dev.idversion = 0x0100;
 
 	input_register_device(&a3d->dev);
-	printk(KERN_INFO "input%d: %s on gameport%d.0\n",
-		a3d->dev.number, a3d_names[a3d->mode], gameport->number);
+	printk(KERN_INFO "input: %s on gameport%d.0\n",
+	       a3d_names[a3d->mode], gameport->number);
 
 	return;
 fail2:	gameport_close(gameport);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/adi.c linux-modified/drivers/char/joystick/adi.c
--- linux-vanilla/drivers/char/joystick/adi.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/adi.c	Mon Jan  6 16:48:20 2003
@@ -514,8 +514,8 @@
 		if (port->adi[i].length > 0) {
 			adi_init_center(port->adi + i);
 			input_register_device(&port->adi[i].dev);
-			printk(KERN_INFO "input%d: %s [%s] on gameport%d.%d\n",
-				port->adi[i].dev.number, port->adi[i].name, port->adi[i].cname, gameport->number, i);
+			printk(KERN_INFO "input: %s [%s] on gameport%d.%d\n",
+				port->adi[i].name, port->adi[i].cname, gameport->number, i);
 		}
 }
 
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/analog.c linux-modified/drivers/char/joystick/analog.c
--- linux-vanilla/drivers/char/joystick/analog.c	Fri Nov 29 01:53:12 2002
+++ linux-modified/drivers/char/joystick/analog.c	Mon Jan  6 16:48:20 2003
@@ -490,8 +490,8 @@
 
 	input_register_device(&analog->dev);
 
-	printk(KERN_INFO "input%d: %s at gameport%d.%d",
-		analog->dev.number, analog->name, port->gameport->number, index);
+	printk(KERN_INFO "input: %s at gameport%d.%d",
+		analog->name, port->gameport->number, index);
 
 	if (port->cooked)
 		printk(" [ADC port]\n");
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/cobra.c linux-modified/drivers/char/joystick/cobra.c
--- linux-vanilla/drivers/char/joystick/cobra.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/cobra.c	Mon Jan  6 16:48:20 2003
@@ -208,8 +208,8 @@
 			cobra->dev[i].absmin[ABS_Y] = -1; cobra->dev[i].absmax[ABS_Y] = 1;
 
 			input_register_device(cobra->dev + i);
-			printk(KERN_INFO "input%d: %s on gameport%d.%d\n",
-				cobra->dev[i].number, cobra_name, gameport->number, i);
+			printk(KERN_INFO "input: %s on gameport%d.%d\n",
+				cobra_name, gameport->number, i);
 		}
 
 
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/db9.c linux-modified/drivers/char/joystick/db9.c
--- linux-vanilla/drivers/char/joystick/db9.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/db9.c	Mon Jan  6 16:48:20 2003
@@ -362,8 +362,8 @@
 		db9->dev[i].absmin[ABS_Y] = -1; db9->dev[i].absmax[ABS_Y] = 1;
 
 		input_register_device(db9->dev + i);
-		printk(KERN_INFO "input%d: %s on %s\n",
-			db9->dev[i].number, db9_name[db9->mode], db9->pd->port->name);
+		printk(KERN_INFO "input: %s on %s\n",
+			db9_name[db9->mode], db9->pd->port->name);
 	}
 
 	return db9;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/gamecon.c linux-modified/drivers/char/joystick/gamecon.c
--- linux-vanilla/drivers/char/joystick/gamecon.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/gamecon.c	Mon Jan  6 16:48:20 2003
@@ -608,7 +608,7 @@
 	for (i = 0; i < 5; i++) 
 		if (gc->pads[0] & gc_status_bit[i]) {
 			input_register_device(gc->dev + i);
-			printk(KERN_INFO "input%d: %s on %s\n", gc->dev[i].number, gc->dev[i].name, gc->pd->port->name);
+			printk(KERN_INFO "input: %s on %s\n", gc->dev[i].name, gc->pd->port->name);
 		}
 
 	return gc;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/gf2k.c linux-modified/drivers/char/joystick/gf2k.c
--- linux-vanilla/drivers/char/joystick/gf2k.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/gf2k.c	Mon Jan  6 16:48:20 2003
@@ -323,8 +323,8 @@
 	}
 
 	input_register_device(&gf2k->dev);
-	printk(KERN_INFO "input%d: %s on gameport%d.0\n",
-		gf2k->dev.number, gf2k_names[gf2k->id], gameport->number);
+	printk(KERN_INFO "input: %s on gameport%d.0\n",
+		gf2k_names[gf2k->id], gameport->number);
 
 	return;
 fail2:	gameport_close(gameport);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/grip.c linux-modified/drivers/char/joystick/grip.c
--- linux-vanilla/drivers/char/joystick/grip.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/grip.c	Mon Jan  6 16:48:20 2003
@@ -382,8 +382,8 @@
 
 			input_register_device(grip->dev + i);
 
-			printk(KERN_INFO "input%d: %s on gameport%d.%d\n",
-				grip->dev[i].number, grip_name[grip->mode[i]], gameport->number, i);
+			printk(KERN_INFO "input: %s on gameport%d.%d\n",
+				grip_name[grip->mode[i]], gameport->number, i);
 		}
 
 	return;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/Config.help linux-modified/drivers/char/joystick/iforce/Config.help
--- linux-vanilla/drivers/char/joystick/iforce/Config.help	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/Config.help	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,21 @@
+CONFIG_JOYSTICK_IFORCE
+  Say Y here if you have an I-Force joystick or steering wheel
+
+  You also must choose at least one of the two options below.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called iforce.o. If you want to compile it as a
+  module, say M here and read <file:Documentation/modules.txt>.
+
+CONFIG_JOYSTICK_IFORCE_USB
+  Say Y here if you have an I-Force joystick or steering wheel
+  connected to your USB port. 
+
+CONFIG_JOYSTICK_IFORCE_232
+  Say Y here if you have an I-Force joystick or steering wheel
+  connected to your serial (COM) port.
+
+  You will need an additional utility called inputattach, see
+  Documentation/input/joystick.txt and ff.txt.
+
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/Config.in linux-modified/drivers/char/joystick/iforce/Config.in
--- linux-vanilla/drivers/char/joystick/iforce/Config.in	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/Config.in	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,14 @@
+#
+# I-Force driver configuration
+#
+
+dep_tristate 'I-Force devices' CONFIG_JOYSTICK_IFORCE $CONFIG_INPUT $CONFIG_INPUT_JOYSTICK
+
+if [ "$CONFIG_JOYSTICK_IFORCE" = "m" -o "$CONFIG_JOYSTICK_IFORCE" = "y" ]; then
+	if [ "$CONFIG_JOYSTICK_IFORCE" = "m" -o "$CONFIG_USB" = "y" ]; then
+		dep_mbool '  I-Force USB joysticks and wheels' CONFIG_JOYSTICK_IFORCE_USB $CONFIG_USB
+	fi
+	if [ "$CONFIG_JOYSTICK_IFORCE" = "m" -o "$CONFIG_INPUT_SERIO" = "y" ]; then
+		dep_mbool '  I-Force Serial joysticks and wheels' CONFIG_JOYSTICK_IFORCE_232 $CONFIG_INPUT_SERIO
+	fi
+fi
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/Makefile linux-modified/drivers/char/joystick/iforce/Makefile
--- linux-vanilla/drivers/char/joystick/iforce/Makefile	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/Makefile	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,30 @@
+#
+# Makefile for the I-Force driver
+#
+# By Johann Deneux <deneux@ifrance.com>
+#
+
+# Goal definition
+list-multi	:= iforce.o
+iforce-objs	:= iforce-ff.o iforce-main.o iforce-packets.o
+
+obj-$(CONFIG_JOYSTICK_IFORCE)	+= iforce.o 
+
+ifeq ($(CONFIG_JOYSTICK_IFORCE_232),y)
+	iforce-objs += iforce-serio.o 
+endif
+
+ifeq ($(CONFIG_JOYSTICK_IFORCE_USB),y)
+	iforce-objs += iforce-usb.o 
+endif
+
+EXTRA_CFLAGS = -Werror-implicit-function-declaration
+
+# The global Rules.make.
+
+include $(TOPDIR)/Rules.make
+
+# Additional rules
+iforce.o: $(iforce-objs)
+	$(LD) -r -o $@ $(iforce-objs)
+
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce-ff.c linux-modified/drivers/char/joystick/iforce/iforce-ff.c
--- linux-vanilla/drivers/char/joystick/iforce/iforce-ff.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce-ff.c	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,544 @@
+/*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2002 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001-2002 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+/*
+ * Set the magnitude of a constant force effect
+ * Return error code
+ *
+ * Note: caller must ensure exclusive access to device
+ */
+
+static int make_magnitude_modifier(struct iforce* iforce,
+	struct resource* mod_chunk, int no_alloc, __s16 level)
+{
+	unsigned char data[3];
+
+	if (!no_alloc) {
+		down(&iforce->mem_mutex);
+		if (allocate_resource(&(iforce->device_memory), mod_chunk, 2,
+			iforce->device_memory.start, iforce->device_memory.end, 2L,
+			NULL, NULL)) {
+			up(&iforce->mem_mutex);
+			return -ENOMEM;
+		}
+		up(&iforce->mem_mutex);
+	}
+
+	data[0] = LO(mod_chunk->start);
+	data[1] = HI(mod_chunk->start);
+	data[2] = HIFIX80(level);
+
+	iforce_send_packet(iforce, FF_CMD_MAGNITUDE, data);
+
+//	iforce_dump_packet("magnitude: ", FF_CMD_MAGNITUDE, data);
+	return 0;
+}
+
+/*
+ * Upload the component of an effect dealing with the period, phase and magnitude
+ */
+
+static int make_period_modifier(struct iforce* iforce,
+	struct resource* mod_chunk, int no_alloc,
+	__s16 magnitude, __s16 offset, u16 period, u16 phase)
+{
+	unsigned char data[7];
+
+	period = TIME_SCALE(period);
+
+	if (!no_alloc) {
+		down(&iforce->mem_mutex);
+		if (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0c,
+			iforce->device_memory.start, iforce->device_memory.end, 2L,
+			NULL, NULL)) {
+			up(&iforce->mem_mutex);
+			return -ENOMEM;
+		}
+		up(&iforce->mem_mutex);
+	}
+
+	data[0] = LO(mod_chunk->start);
+	data[1] = HI(mod_chunk->start);
+
+	data[2] = HIFIX80(magnitude);
+	data[3] = HIFIX80(offset);
+	data[4] = HI(phase);
+
+	data[5] = LO(period);
+	data[6] = HI(period);
+
+	iforce_send_packet(iforce, FF_CMD_PERIOD, data);
+
+	return 0;
+}
+
+/*
+ * Uploads the part of an effect setting the envelope of the force
+ */
+
+static int make_envelope_modifier(struct iforce* iforce,
+	struct resource* mod_chunk, int no_alloc,
+	u16 attack_duration, __s16 initial_level,
+	u16 fade_duration, __s16 final_level)
+{
+	unsigned char data[8];
+
+	attack_duration = TIME_SCALE(attack_duration);
+	fade_duration = TIME_SCALE(fade_duration);
+
+	if (!no_alloc) {
+		down(&iforce->mem_mutex);
+		if (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0e,
+			iforce->device_memory.start, iforce->device_memory.end, 2L,
+			NULL, NULL)) {
+			up(&iforce->mem_mutex);
+			return -ENOMEM;
+		}
+		up(&iforce->mem_mutex);
+	}
+
+	data[0] = LO(mod_chunk->start);
+	data[1] = HI(mod_chunk->start);
+
+	data[2] = LO(attack_duration);
+	data[3] = HI(attack_duration);
+	data[4] = HI(initial_level);
+
+	data[5] = LO(fade_duration);
+	data[6] = HI(fade_duration);
+	data[7] = HI(final_level);
+
+	iforce_send_packet(iforce, FF_CMD_ENVELOPE, data);
+
+	return 0;
+}
+
+/*
+ * Component of spring, friction, inertia... effects
+ */
+
+static int make_condition_modifier(struct iforce* iforce,
+	struct resource* mod_chunk, int no_alloc,
+	__u16 rsat, __u16 lsat, __s16 rk, __s16 lk, u16 db, __s16 center)
+{
+	unsigned char data[10];
+
+	if (!no_alloc) {
+		down(&iforce->mem_mutex);
+		if (allocate_resource(&(iforce->device_memory), mod_chunk, 8,
+			iforce->device_memory.start, iforce->device_memory.end, 2L,
+			NULL, NULL)) {
+			up(&iforce->mem_mutex);
+			return -ENOMEM;
+		}
+		up(&iforce->mem_mutex);
+	}
+
+	data[0] = LO(mod_chunk->start);
+	data[1] = HI(mod_chunk->start);
+
+	data[2] = (100*rk)>>15;	/* Dangerous: the sign is extended by gcc on plateforms providing an arith shift */
+	data[3] = (100*lk)>>15; /* This code is incorrect on cpus lacking arith shift */
+
+	center = (500*center)>>15;
+	data[4] = LO(center);
+	data[5] = HI(center);
+
+	db = (1000*db)>>16;
+	data[6] = LO(db);
+	data[7] = HI(db);
+
+	data[8] = (100*rsat)>>16;
+	data[9] = (100*lsat)>>16;
+
+	iforce_send_packet(iforce, FF_CMD_CONDITION, data);
+//	iforce_dump_packet("condition", FF_CMD_CONDITION, data);
+
+	return 0;
+}
+
+static unsigned char find_button(struct iforce *iforce, signed short button)
+{
+	int i;
+	for (i = 1; iforce->type->btn[i] >= 0; i++)
+		if (iforce->type->btn[i] == button)
+			return i + 1;
+	return 0;
+}
+
+/*
+ * Analyse the changes in an effect, and tell if we need to send an condition 
+ * parameter packet
+ */
+static int need_condition_modifier(struct iforce* iforce, struct ff_effect* new)
+{
+	int id = new->id;
+	struct ff_effect* old = &iforce->core_effects[id].effect;
+	int ret=0;
+	int i;
+
+	if (new->type != FF_SPRING && new->type != FF_FRICTION) {
+		printk(KERN_WARNING "iforce.c: bad effect type in need_condition_modifier\n");
+		return FALSE;
+	}
+
+	for(i=0; i<2; i++) {
+		ret |= old->u.condition[i].right_saturation != new->u.condition[i].right_saturation
+			|| old->u.condition[i].left_saturation != new->u.condition[i].left_saturation
+			|| old->u.condition[i].right_coeff != new->u.condition[i].right_coeff
+			|| old->u.condition[i].left_coeff != new->u.condition[i].left_coeff
+			|| old->u.condition[i].deadband != new->u.condition[i].deadband
+			|| old->u.condition[i].center != new->u.condition[i].center;
+	}
+	return ret;
+}
+
+/*
+ * Analyse the changes in an effect, and tell if we need to send a magnitude
+ * parameter packet
+ */
+static int need_magnitude_modifier(struct iforce* iforce, struct ff_effect* effect)
+{
+	int id = effect->id;
+	struct ff_effect* old = &iforce->core_effects[id].effect;
+
+	if (effect->type != FF_CONSTANT) {
+		printk(KERN_WARNING "iforce.c: bad effect type in need_envelope_modifier\n");
+		return FALSE;
+	}
+
+	return (old->u.constant.level != effect->u.constant.level);
+}
+
+/*
+ * Analyse the changes in an effect, and tell if we need to send an envelope
+ * parameter packet
+ */
+static int need_envelope_modifier(struct iforce* iforce, struct ff_effect* effect)
+{
+	int id = effect->id;
+	struct ff_effect* old = &iforce->core_effects[id].effect;
+
+	switch (effect->type) {
+	case FF_CONSTANT:
+		if (old->u.constant.envelope.attack_length != effect->u.constant.envelope.attack_length
+		|| old->u.constant.envelope.attack_level != effect->u.constant.envelope.attack_level
+		|| old->u.constant.envelope.fade_length != effect->u.constant.envelope.fade_length
+		|| old->u.constant.envelope.fade_level != effect->u.constant.envelope.fade_level)
+			return TRUE;
+		break;
+
+	case FF_PERIODIC:
+		if (old->u.periodic.envelope.attack_length != effect->u.periodic.envelope.attack_length
+		|| old->u.periodic.envelope.attack_level != effect->u.periodic.envelope.attack_level
+		|| old->u.periodic.envelope.fade_length != effect->u.periodic.envelope.fade_length
+		|| old->u.periodic.envelope.fade_level != effect->u.periodic.envelope.fade_level)
+			return TRUE;
+		break;
+
+	default:
+		printk(KERN_WARNING "iforce.c: bad effect type in need_envelope_modifier\n");
+	}
+
+	return FALSE;
+}
+
+/*
+ * Analyse the changes in an effect, and tell if we need to send a periodic
+ * parameter effect
+ */
+static int need_period_modifier(struct iforce* iforce, struct ff_effect* new)
+{
+	int id = new->id;
+	struct ff_effect* old = &iforce->core_effects[id].effect;
+
+	if (new->type != FF_PERIODIC) {
+		printk(KERN_WARNING "iforce.c: bad effect type in need_periodic_modifier\n");
+		return FALSE;
+	}
+
+	return (old->u.periodic.period != new->u.periodic.period
+		|| old->u.periodic.magnitude != new->u.periodic.magnitude
+		|| old->u.periodic.offset != new->u.periodic.offset
+		|| old->u.periodic.phase != new->u.periodic.phase);
+}
+
+/*
+ * Analyse the changes in an effect, and tell if we need to send an effect
+ * packet
+ */
+static int need_core(struct iforce* iforce, struct ff_effect* new)
+{
+	int id = new->id;
+	struct ff_effect* old = &iforce->core_effects[id].effect;
+
+	if (old->direction != new->direction
+		|| old->trigger.button != new->trigger.button
+		|| old->trigger.interval != new->trigger.interval
+		|| old->replay.length != new->replay.length
+		|| old->replay.delay != new->replay.delay)
+		return TRUE;
+
+	return FALSE;
+}
+/*
+ * Send the part common to all effects to the device
+ */
+static int make_core(struct iforce* iforce, u16 id, u16 mod_id1, u16 mod_id2,
+	u8 effect_type, u8 axes, u16 duration, u16 delay, u16 button,
+	u16 interval, u16 direction)
+{
+	unsigned char data[14];
+
+	duration = TIME_SCALE(duration);
+	delay    = TIME_SCALE(delay);
+	interval = TIME_SCALE(interval);
+
+	data[0]  = LO(id);
+	data[1]  = effect_type;
+	data[2]  = LO(axes) | find_button(iforce, button);
+
+	if (!duration) duration = 0xFFFF;
+	data[3]  = LO(duration);
+	data[4]  = HI(duration);
+
+	data[5]  = HI(direction);
+
+	data[6]  = LO(interval);
+	data[7]  = HI(interval);
+
+	data[8]  = LO(mod_id1);
+	data[9]  = HI(mod_id1);
+	data[10] = LO(mod_id2);
+	data[11] = HI(mod_id2);
+
+	data[12] = LO(delay);
+	data[13] = HI(delay);
+
+	/* Stop effect */
+/*	iforce_control_playback(iforce, id, 0);*/
+
+	iforce_send_packet(iforce, FF_CMD_EFFECT, data);
+
+	/* If needed, restart effect */
+	if (test_bit(FF_CORE_SHOULD_PLAY, iforce->core_effects[id].flags)) {
+		/* BUG: perhaps we should replay n times, instead of 1. But we do not know n */
+		iforce_control_playback(iforce, id, 1);
+	}
+
+	return 0;
+}
+
+/*
+ * Upload a periodic effect to the device
+ * See also iforce_upload_constant.
+ */
+int iforce_upload_periodic(struct iforce* iforce, struct ff_effect* effect, int is_update)
+{
+	u8 wave_code;
+	int core_id = effect->id;
+	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
+	struct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);
+	struct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);
+	int param1_err = 1;
+	int param2_err = 1;
+	int core_err = 0;
+
+	if (!is_update || need_period_modifier(iforce, effect)) {
+		param1_err = make_period_modifier(iforce, mod1_chunk, 
+			is_update,
+			effect->u.periodic.magnitude, effect->u.periodic.offset,
+			effect->u.periodic.period, effect->u.periodic.phase);
+		if (param1_err) return param1_err;
+		set_bit(FF_MOD1_IS_USED, core_effect->flags);
+	}
+
+	if (!is_update || need_envelope_modifier(iforce, effect)) {
+		param2_err = make_envelope_modifier(iforce, mod2_chunk,
+			is_update,
+			effect->u.periodic.envelope.attack_length,
+			effect->u.periodic.envelope.attack_level,
+			effect->u.periodic.envelope.fade_length,
+			effect->u.periodic.envelope.fade_level);
+		if (param2_err) return param2_err;
+		set_bit(FF_MOD2_IS_USED, core_effect->flags);
+	}
+
+	switch (effect->u.periodic.waveform) {
+		case FF_SQUARE:		wave_code = 0x20; break;
+		case FF_TRIANGLE:	wave_code = 0x21; break;
+		case FF_SINE:		wave_code = 0x22; break;
+		case FF_SAW_UP:		wave_code = 0x23; break;
+		case FF_SAW_DOWN:	wave_code = 0x24; break;
+		default:		wave_code = 0x20; break;
+	}
+
+	if (!is_update || need_core(iforce, effect)) {
+		core_err = make_core(iforce, effect->id,
+			mod1_chunk->start,
+			mod2_chunk->start,
+			wave_code,
+			0x20,
+			effect->replay.length,
+			effect->replay.delay,
+			effect->trigger.button,
+			effect->trigger.interval,
+			effect->direction);
+	}
+
+	/* If one of the parameter creation failed, we already returned an
+	 * error code.
+	 * If the core creation failed, we return its error code.
+	 * Else: if one parameter at least was created, we return 0
+	 *       else we return 1;
+	 */
+	return core_err < 0 ? core_err : (param1_err && param2_err);
+}
+
+/*
+ * Upload a constant force effect
+ * Return value:
+ *  <0 Error code
+ *  0 Ok, effect created or updated
+ *  1 effect did not change since last upload, and no packet was therefore sent
+ */
+int iforce_upload_constant(struct iforce* iforce, struct ff_effect* effect, int is_update)
+{
+	int core_id = effect->id;
+	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
+	struct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);
+	struct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);
+	int param1_err = 1;
+	int param2_err = 1;
+	int core_err = 0;
+
+	if (!is_update || need_magnitude_modifier(iforce, effect)) {
+		param1_err = make_magnitude_modifier(iforce, mod1_chunk,
+			is_update,
+			effect->u.constant.level);
+		if (param1_err) return param1_err;
+		set_bit(FF_MOD1_IS_USED, core_effect->flags);
+	}
+
+	if (!is_update || need_envelope_modifier(iforce, effect)) {
+		param2_err = make_envelope_modifier(iforce, mod2_chunk,
+			is_update,
+			effect->u.constant.envelope.attack_length,
+			effect->u.constant.envelope.attack_level,
+			effect->u.constant.envelope.fade_length,
+			effect->u.constant.envelope.fade_level);
+		if (param2_err) return param2_err;
+		set_bit(FF_MOD2_IS_USED, core_effect->flags);
+	}
+
+	if (!is_update || need_core(iforce, effect)) {
+		core_err = make_core(iforce, effect->id,
+			mod1_chunk->start,
+			mod2_chunk->start,
+			0x00,
+			0x20,
+			effect->replay.length,
+			effect->replay.delay,
+			effect->trigger.button,
+			effect->trigger.interval,
+			effect->direction);
+	}
+
+	/* If one of the parameter creation failed, we already returned an
+	 * error code.
+	 * If the core creation failed, we return its error code.
+	 * Else: if one parameter at least was created, we return 0
+	 *       else we return 1;
+	 */
+	return core_err < 0 ? core_err : (param1_err && param2_err);
+}
+
+/*
+ * Upload an condition effect. Those are for example friction, inertia, springs...
+ */
+int iforce_upload_condition(struct iforce* iforce, struct ff_effect* effect, int is_update)
+{
+	int core_id = effect->id;
+	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
+	struct resource* mod1_chunk = &(core_effect->mod1_chunk);
+	struct resource* mod2_chunk = &(core_effect->mod2_chunk);
+	u8 type;
+	int param_err = 1;
+	int core_err = 0;
+
+	switch (effect->type) {
+		case FF_SPRING:		type = 0x40; break;
+		case FF_DAMPER:		type = 0x41; break;
+		default: return -1;
+	}
+
+	if (!is_update || need_condition_modifier(iforce, effect)) {
+		param_err = make_condition_modifier(iforce, mod1_chunk,
+			is_update,
+			effect->u.condition[0].right_saturation,
+			effect->u.condition[0].left_saturation,
+			effect->u.condition[0].right_coeff,
+			effect->u.condition[0].left_coeff,
+			effect->u.condition[0].deadband,
+			effect->u.condition[0].center);
+		if (param_err) return param_err;
+		set_bit(FF_MOD1_IS_USED, core_effect->flags);
+
+		param_err = make_condition_modifier(iforce, mod2_chunk,
+			is_update,
+			effect->u.condition[1].right_saturation,
+			effect->u.condition[1].left_saturation,
+			effect->u.condition[1].right_coeff,
+			effect->u.condition[1].left_coeff,
+			effect->u.condition[1].deadband,
+			effect->u.condition[1].center);
+		if (param_err) return param_err;
+		set_bit(FF_MOD2_IS_USED, core_effect->flags);
+
+	}
+
+	if (!is_update || need_core(iforce, effect)) {
+		core_err = make_core(iforce, effect->id,
+			mod1_chunk->start, mod2_chunk->start,
+			type, 0xc0,
+			effect->replay.length, effect->replay.delay,
+			effect->trigger.button, effect->trigger.interval,
+			effect->direction);
+	}
+
+	/* If the parameter creation failed, we already returned an
+	 * error code.
+	 * If the core creation failed, we return its error code.
+	 * Else: if a parameter  was created, we return 0
+	 *       else we return 1;
+	 */
+	return core_err < 0 ? core_err : param_err;
+}
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce-main.c linux-modified/drivers/char/joystick/iforce/iforce-main.c
--- linux-vanilla/drivers/char/joystick/iforce/iforce-main.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce-main.c	Wed Feb 26 20:36:04 2003
@@ -0,0 +1,562 @@
+/*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2002 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001-2002 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>, Johann Deneux <deneux@ifrance.com>");
+MODULE_DESCRIPTION("USB/RS232 I-Force joysticks and wheels driver");
+MODULE_LICENSE("GPL");
+
+#define  USB_VENDOR_ID_SAITEK 0x06a3
+#define  USB_PRODUCT_ID_CYBORGFORCE 0xff12
+		
+
+static signed short btn_joystick[] =
+{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,
+  BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_A, BTN_B, BTN_C, -1 };
+
+static signed short btn_avb_pegasus[] =
+{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,
+  BTN_BASE2, BTN_BASE3, BTN_BASE4, -1 };
+
+static signed short btn_wheel[] =
+{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,
+  BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_A, BTN_B, BTN_C, -1 };
+
+static signed short btn_avb_tw[] =
+{ BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE,
+  BTN_BASE2, BTN_BASE3, BTN_BASE4, -1 };
+
+static signed short btn_avb_wheel[] =
+{ BTN_GEAR_DOWN, BTN_GEAR_UP, BTN_BASE, BTN_BASE2, BTN_BASE3,
+  BTN_BASE4, BTN_BASE5, BTN_BASE6, -1 };
+
+static signed short abs_joystick[] =
+{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, -1 };
+
+static signed short abs_avb_pegasus[] =
+{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER, ABS_HAT0X, ABS_HAT0Y,
+  ABS_HAT1X, ABS_HAT1Y, -1 };
+
+static signed short abs_wheel[] =
+{ ABS_WHEEL, ABS_GAS, ABS_BRAKE, ABS_HAT0X, ABS_HAT0Y, -1 };
+
+static signed short btn_saitek_joystick[] = 
+{ BTN_TRIGGER, BTN_TOP2, BTN_THUMB,BTN_THUMB2, BTN_TOP,
+	BTN_BASE, BTN_BASE2, BTN_BASE4, BTN_BASE3, -1 };
+
+static signed short abs_saitek_joystick[] = 
+{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER,ABS_HAT0X, ABS_HAT0Y, -1 };
+
+
+
+static signed short ff_iforce[] =
+{ FF_PERIODIC, FF_CONSTANT, FF_SPRING, FF_DAMPER,
+  FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP, FF_SAW_DOWN, FF_GAIN,
+  FF_AUTOCENTER, -1 };
+
+static struct iforce_device iforce_device[] = {
+	{ 0x044f, 0xa01c, "Thrustmaster Motor Sport GT",		btn_wheel, abs_wheel, ff_iforce },
+	{ 0x046d, 0xc281, "Logitech WingMan Force",			btn_joystick, abs_joystick, ff_iforce },
+	{ 0x046d, 0xc291, "Logitech WingMan Formula Force",		btn_wheel, abs_wheel, ff_iforce },
+	{ 0x05ef, 0x020a, "AVB Top Shot Pegasus",			btn_avb_pegasus, abs_avb_pegasus, ff_iforce },
+	{ 0x05ef, 0x8884, "AVB Mag Turbo Force",			btn_avb_wheel, abs_wheel, ff_iforce },
+	{ 0x05ef, 0x8888, "AVB Top Shot Force Feedback Racing Wheel",	btn_avb_tw, abs_wheel, ff_iforce }, //?
+	{ 0x061c, 0xc084, "ACT LABS Force RS",                          btn_wheel, abs_wheel, ff_iforce }, //?
+	{ 0x06f8, 0x0001, "Guillemot Race Leader Force Feedback",	btn_wheel, abs_wheel, ff_iforce }, //?
+	{ 0x06f8, 0x0004, "Guillemot Force Feedback Racing Wheel",	btn_wheel, abs_wheel, ff_iforce }, //?
+	{ 0x06a3, 0xff12, "Saitek Cyborgforce",                  	btn_saitek_joystick, abs_saitek_joystick, ff_iforce },
+	{ 0x0000, 0x0000, "Unknown I-Force Device [%04x:%04x]",		btn_joystick, abs_joystick, ff_iforce }
+};
+
+
+
+static int iforce_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	struct iforce* iforce = (struct iforce*)(dev->private);
+	unsigned char data[3];
+
+	if (type != EV_FF)
+		return -1;
+
+	switch (code) {
+
+		case FF_GAIN:
+
+			data[0] = value >> 9;
+			iforce_send_packet(iforce, FF_CMD_GAIN, data);
+
+			return 0;
+
+		case FF_AUTOCENTER:
+
+			data[0] = 0x03;
+			data[1] = value >> 9;
+			iforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);
+
+			data[0] = 0x04;
+			data[1] = 0x01;
+			iforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);
+
+			return 0;
+
+		default: /* Play or stop an effect */
+
+			if (value > 0) {
+				set_bit(FF_CORE_SHOULD_PLAY, iforce->core_effects[code].flags);
+			}
+			else {
+				clear_bit(FF_CORE_SHOULD_PLAY, iforce->core_effects[code].flags);
+			}
+
+			iforce_control_playback(iforce, code, value);
+			return 0;
+	}
+
+	return -1;
+}
+
+/*
+ * Function called when an ioctl is performed on the event dev entry.
+ * It uploads an effect to the device
+ */
+static int iforce_upload_effect(struct input_dev *dev, struct ff_effect *effect)
+{
+	struct iforce* iforce = (struct iforce*)(dev->private);
+	int id;
+	int ret;
+	int is_update;
+
+/* Check this effect type is supported by this device */
+	if (!test_bit(effect->type, iforce->dev.ffbit))
+		return -EINVAL;
+
+/*
+ * If we want to create a new effect, get a free id
+ */
+	if (effect->id == -1) {
+
+		for (id=0; id < FF_EFFECTS_MAX; ++id)
+			if (!test_and_set_bit(FF_CORE_IS_USED, iforce->core_effects[id].flags)) break;
+
+		if ( id == FF_EFFECTS_MAX || id >= iforce->dev.ff_effects_max)
+			return -ENOMEM;
+
+		effect->id = id;
+		iforce->core_effects[id].owner = current->pid;
+		iforce->core_effects[id].flags[0] = (1<<FF_CORE_IS_USED);	/* Only IS_USED bit must be set */
+
+		is_update = FALSE;
+	}
+	else {
+		/* We want to update an effect */
+		/* Parameter type cannot be updated */
+		if (effect->type != iforce->core_effects[effect->id].effect.type)
+			return -EINVAL;
+
+		/* Check the effect is not already being updated */
+		if (test_bit(FF_CORE_UPDATE, iforce->core_effects[effect->id].flags)) {
+			return -EAGAIN;
+		}
+
+		is_update = TRUE;
+	}
+
+/*
+ * Upload the effect
+ */
+	switch (effect->type) {
+
+		case FF_PERIODIC:
+			ret = iforce_upload_periodic(iforce, effect, is_update);
+			break;
+
+		case FF_CONSTANT:
+			ret = iforce_upload_constant(iforce, effect, is_update);
+			break;
+
+		case FF_SPRING:
+		case FF_DAMPER:
+			ret = iforce_upload_condition(iforce, effect, is_update);
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	if (ret == 0) {
+		/* A packet was sent, forbid new updates until we are notified
+		 * that the packet was updated
+		 */
+		set_bit(FF_CORE_UPDATE, iforce->core_effects[effect->id].flags);
+	}
+	iforce->core_effects[effect->id].effect = *effect;
+	return ret;
+}
+
+/*
+ * Erases an effect: it frees the effect id and mark as unused the memory
+ * allocated for the parameters
+ */
+static int iforce_erase_effect(struct input_dev *dev, int effect_id)
+{
+	struct iforce* iforce = (struct iforce*)(dev->private);
+	int err = 0;
+	struct iforce_core_effect* core_effect;
+
+	if (effect_id < 0 || effect_id >= FF_EFFECTS_MAX)
+		return -EINVAL;
+
+	core_effect = iforce->core_effects + effect_id;
+
+	if (test_bit(FF_MOD1_IS_USED, core_effect->flags))
+		err = release_resource(&(iforce->core_effects[effect_id].mod1_chunk));
+
+	if (!err && test_bit(FF_MOD2_IS_USED, core_effect->flags))
+		err = release_resource(&(iforce->core_effects[effect_id].mod2_chunk));
+
+	/*TODO: remember to change that if more FF_MOD* bits are added */
+	core_effect->flags[0] = 0;
+
+	return err;
+}
+
+static int iforce_open(struct input_dev *dev)
+{
+	struct iforce *iforce = dev->private;
+
+	switch (iforce->bus) {
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+		case IFORCE_USB:
+			iforce->irq->dev = iforce->usbdev;
+			if (usb_submit_urb(iforce->irq))
+				return -EIO;
+			break;
+#endif
+	}
+
+	/* Enable force feedback */
+	iforce_send_packet(iforce, FF_CMD_ENABLE, "\004");
+
+	return 0;
+}
+
+static int iforce_flush(struct input_dev *dev, struct file *file)
+{
+	struct iforce *iforce = dev->private;
+	int i;
+
+	/* Erase all effects this process owns */
+	for (i=0; i<dev->ff_effects_max; ++i) {
+
+		if (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags) &&
+			current->pid == iforce->core_effects[i].owner) {
+			
+			/* Stop effect */
+			input_report_ff(dev, i, 0);
+
+			/* Free ressources assigned to effect */
+			if (iforce_erase_effect(dev, i)) {
+				printk(KERN_WARNING "iforce_flush: erase effect %d failed\n", i);
+			}
+		}
+
+	}
+	return 0;
+}
+
+static void iforce_release(struct input_dev *dev)
+{
+	struct iforce *iforce = dev->private;
+	int i;
+
+	/* Check: no effect should be present in memory */
+	for (i=0; i<dev->ff_effects_max; ++i) {
+		if (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags))
+			break;
+	}
+	if (i<dev->ff_effects_max) {
+		printk(KERN_WARNING "iforce_release: Device still owns effects\n");
+	}
+
+	/* Disable force feedback playback */
+	iforce_send_packet(iforce, FF_CMD_ENABLE, "\001");
+
+	switch (iforce->bus) {
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+		case IFORCE_USB:
+			usb_unlink_urb(iforce->irq);
+
+			/* The device was unplugged before the file
+			 * was released */
+			if (iforce->usbdev == NULL) {
+				iforce_delete_device(iforce);
+				kfree(iforce);
+			}
+		break;
+#endif
+	}
+}
+
+void iforce_delete_device(struct iforce *iforce)
+{
+	switch (iforce->bus) {
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+	case IFORCE_USB:
+		iforce_usb_delete(iforce);
+		break;
+#endif
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+	case IFORCE_232:
+		//TODO: Wait for the last packets to be sent
+		break;
+#endif
+	}
+}
+
+int iforce_init_device(struct iforce *iforce)
+{
+	unsigned char c[] = "CEOV";
+	int i;
+
+	init_waitqueue_head(&iforce->wait);
+	spin_lock_init(&iforce->xmit_lock);
+	init_MUTEX(&iforce->mem_mutex);
+	iforce->xmit.buf = iforce->xmit_data;
+
+	iforce->dev.ff_effects_max = 10;
+
+/*
+ * Input device fields.
+ */
+
+	iforce->dev.idbus = BUS_USB;
+	iforce->dev.private = iforce;
+	iforce->dev.name = "Unknown I-Force device";
+	iforce->dev.open = iforce_open;
+	iforce->dev.close = iforce_release;
+	iforce->dev.flush = iforce_flush;
+	iforce->dev.event = iforce_input_event;
+	iforce->dev.upload_effect = iforce_upload_effect;
+	iforce->dev.erase_effect = iforce_erase_effect;
+
+/*
+ * On-device memory allocation.
+ */
+
+	iforce->device_memory.name = "I-Force device effect memory";
+	iforce->device_memory.start = 0;
+	iforce->device_memory.end = 200;
+	iforce->device_memory.flags = IORESOURCE_MEM;
+	iforce->device_memory.parent = NULL;
+	iforce->device_memory.child = NULL;
+	iforce->device_memory.sibling = NULL;
+
+/*
+ * Wait until device ready - until it sends its first response.
+ */
+
+	for (i = 0; i < 20; i++)
+		if (!iforce_get_id_packet(iforce, "O"))
+			break;
+
+	if (i == 20) { /* 5 seconds */
+		printk(KERN_ERR "iforce-main.c: Timeout waiting for response from device.\n");
+		return -1;
+	}
+
+/*
+ * Get device info.
+ */
+
+	if (!iforce_get_id_packet(iforce, "M"))
+		iforce->dev.idvendor = (iforce->edata[2] << 8) | iforce->edata[1];
+	else
+		printk(KERN_WARNING "iforce-main.c: Device does not respond to id packet M\n");
+
+	if (!iforce_get_id_packet(iforce, "P"))
+		iforce->dev.idproduct = (iforce->edata[2] << 8) | iforce->edata[1];
+	else
+		printk(KERN_WARNING "iforce-main.c: Device does not respond to id packet P\n");
+
+	if (!iforce_get_id_packet(iforce, "B"))
+		iforce->device_memory.end = (iforce->edata[2] << 8) | iforce->edata[1];
+	else
+		printk(KERN_WARNING "iforce-main.c: Device does not respond to id packet B\n");
+
+	if (!iforce_get_id_packet(iforce, "N"))
+		iforce->dev.ff_effects_max = iforce->edata[1];
+	else
+		printk(KERN_WARNING "iforce-main.c: Device does not respond to id packet N\n");
+
+	/* Check if the device can store more effects than the driver can really handle */
+	if (iforce->dev.ff_effects_max > FF_EFFECTS_MAX) {
+		printk(KERN_WARNING "input??: Device can handle %d effects, but N_EFFECTS_MAX is set to %d in iforce.h\n",
+			iforce->dev.ff_effects_max, FF_EFFECTS_MAX);
+		iforce->dev.ff_effects_max = FF_EFFECTS_MAX;
+	}
+
+/*
+ * Display additional info.
+ */
+
+	for (i = 0; c[i]; i++)
+		if (!iforce_get_id_packet(iforce, c + i))
+			iforce_dump_packet("info", iforce->ecmd, iforce->edata);
+
+/*
+ * Disable spring, enable force feedback.
+ * FIXME: We should use iforce_set_autocenter() et al here.
+ */
+
+	iforce_send_packet(iforce, FF_CMD_AUTOCENTER, "\004\000");
+
+/*
+ * Find appropriate device entry
+ */
+
+	for (i = 0; iforce_device[i].idvendor; i++)
+		if (iforce_device[i].idvendor == iforce->dev.idvendor &&
+		    iforce_device[i].idproduct == iforce->dev.idproduct)
+			break;
+
+	iforce->type = iforce_device + i;
+	iforce->dev.name = iforce->type->name;
+
+/*
+ * Set input device bitfields and ranges.
+ */
+
+	iforce->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS) | BIT(EV_FF) | BIT(EV_FF_STATUS);
+
+	for (i = 0; iforce->type->btn[i] >= 0; i++) {
+		signed short t = iforce->type->btn[i];
+		set_bit(t, iforce->dev.keybit);
+	}
+	set_bit(BTN_DEAD, iforce->dev.keybit);
+
+	for (i = 0; iforce->type->abs[i] >= 0; i++) {
+
+		signed short t = iforce->type->abs[i];
+		set_bit(t, iforce->dev.absbit);
+
+		switch (t) {
+
+			case ABS_X:
+			case ABS_Y:
+			case ABS_WHEEL:
+			  if (iforce->dev.idvendor == USB_VENDOR_ID_SAITEK && iforce->dev.idproduct == USB_PRODUCT_ID_CYBORGFORCE)
+			    {
+			      iforce->dev.absmax[t] =  0x1000;
+			      iforce->dev.absmin[t] = 0;
+			    }
+			  else {
+			    iforce->dev.absmax[t] =  1920;
+			    iforce->dev.absmin[t] = -1920;
+			  }
+			  iforce->dev.absflat[t] = 128;
+			  iforce->dev.absfuzz[t] = 16;
+			  set_bit(t, iforce->dev.ffbit);
+			  break;
+
+			case ABS_THROTTLE:
+			case ABS_GAS:
+			case ABS_BRAKE:
+
+				iforce->dev.absmax[t] = 255;
+				iforce->dev.absmin[t] = 0;
+				break;
+
+			case ABS_RUDDER:
+			  if (iforce->dev.idvendor == USB_VENDOR_ID_SAITEK && iforce->dev.idproduct == USB_PRODUCT_ID_CYBORGFORCE)
+			    {
+				iforce->dev.absmax[t] = 255;
+				iforce->dev.absmin[t] = 0;
+				iforce->dev.absflat[t] = 10;
+				iforce->dev.absfuzz[t] = 4;
+
+			    }
+			  else
+			    {
+			      iforce->dev.absmax[t] = 127;
+			      iforce->dev.absmin[t] = -128;
+				
+			    }
+			  break;
+
+			case ABS_HAT0X:
+			case ABS_HAT0Y:
+		        case ABS_HAT1X:
+		        case ABS_HAT1Y:
+				iforce->dev.absmax[t] =  1;
+				iforce->dev.absmin[t] = -1;
+				break;
+		}
+	}
+
+	for (i = 0; iforce->type->ff[i] >= 0; i++)
+		set_bit(iforce->type->ff[i], iforce->dev.ffbit);
+
+/*
+ * Register input device.
+ */
+
+	input_register_device(&iforce->dev);
+
+	printk(KERN_DEBUG "iforce->dev.open = %p\n", iforce->dev.open);
+
+	printk(KERN_INFO "input: %s [%d effects, %ld bytes memory]\n",
+		iforce->dev.name, iforce->dev.ff_effects_max,
+		iforce->device_memory.end);
+
+	return 0;
+}
+
+static int __init iforce_init(void)
+{
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+	usb_register(&iforce_usb_driver);
+#endif
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+	serio_register_device(&iforce_serio_dev);
+#endif
+	return 0;
+}
+
+static void __exit iforce_exit(void)
+{
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+	usb_deregister(&iforce_usb_driver);
+#endif
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+	serio_unregister_device(&iforce_serio_dev);
+#endif
+}
+
+module_init(iforce_init);
+module_exit(iforce_exit);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce-packets.c linux-modified/drivers/char/joystick/iforce/iforce-packets.c
--- linux-vanilla/drivers/char/joystick/iforce/iforce-packets.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce-packets.c	Mon Feb 17 21:28:41 2003
@@ -0,0 +1,320 @@
+/*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2002 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001-2002 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+static struct {
+	__s32 x;
+	__s32 y;
+} iforce_hat_to_axis[16] = {{ 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+
+
+void iforce_dump_packet(char *msg, u16 cmd, unsigned char *data)
+{
+	int i;
+
+	printk(KERN_DEBUG "iforce.c: %s ( cmd = %04x, data = ", msg, cmd);
+	for (i = 0; i < LO(cmd); i++)
+		printk("%02x ", data[i]);
+	printk(")\n");
+}
+
+/*
+ * Send a packet of bytes to the device
+ */
+int iforce_send_packet(struct iforce *iforce, u16 cmd, unsigned char* data)
+{
+	/* Copy data to buffer */
+	int n = LO(cmd);
+	int c;
+	int empty;
+	int head, tail;
+	unsigned long flags;
+			
+/*
+ * Update head and tail of xmit buffer
+ */
+	spin_lock_irqsave(&iforce->xmit_lock, flags);
+
+	head = iforce->xmit.head;
+	tail = iforce->xmit.tail;
+
+	if (CIRC_SPACE(head, tail, XMIT_SIZE) < n+2) {
+		printk(KERN_WARNING "iforce.c: not enough space in xmit buffer to send new packet\n");
+		spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+		return -1;
+	}
+
+	empty = head == tail;
+	XMIT_INC(iforce->xmit.head, n+2);
+
+/*
+ * Store packet in xmit buffer
+ */
+	iforce->xmit.buf[head] = HI(cmd);
+	XMIT_INC(head, 1);
+	iforce->xmit.buf[head] = LO(cmd);
+	XMIT_INC(head, 1);
+
+	c = CIRC_SPACE_TO_END(head, tail, XMIT_SIZE);
+	if (n < c) c=n;
+
+	memcpy(&iforce->xmit.buf[head],
+	       data,
+	       c);
+	if (n != c) {
+		memcpy(&iforce->xmit.buf[0],
+		       data + c,
+		       n - c);
+	}
+	XMIT_INC(head, n);
+
+	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+/*
+ * If necessary, start the transmission
+ */
+	switch (iforce->bus) {
+
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+		case IFORCE_232:
+		if (empty)
+			iforce_serial_xmit(iforce);
+		break;
+#endif
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+		case IFORCE_USB: 
+
+		if (iforce->usbdev && empty &&
+			!test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags)) {
+
+			iforce_usb_xmit(iforce);
+		}
+		break;
+#endif
+	}
+	return 0;
+}
+
+/* Start or stop an effect */
+int iforce_control_playback(struct iforce* iforce, u16 id, unsigned int value)
+{
+	unsigned char data[3];
+
+//printk(KERN_DEBUG "iforce-packets.c: control_playback %d %d\n", id, value);
+
+	data[0] = LO(id);
+	data[1] = (value > 0) ? ((value > 1) ? 0x41 : 0x01) : 0;
+	data[2] = LO(value);
+	return iforce_send_packet(iforce, FF_CMD_PLAY, data);
+}
+
+/* Mark an effect that was being updated as ready. That means it can be updated
+ * again */
+static int mark_core_as_ready(struct iforce *iforce, unsigned short addr)
+{
+	int i;
+	for (i=0; i<iforce->dev.ff_effects_max; ++i) {
+		if (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags) &&
+		    (iforce->core_effects[i].mod1_chunk.start == addr ||
+		     iforce->core_effects[i].mod2_chunk.start == addr)) {
+			clear_bit(FF_CORE_UPDATE, iforce->core_effects[i].flags);
+			return 0;
+		}
+	}
+	printk(KERN_WARNING "iforce-packets.c: unused effect %04x updated !!!\n", addr);
+	return -1;
+}
+
+void iforce_process_packet(struct iforce *iforce, u16 cmd, unsigned char *data)
+{
+	struct input_dev *dev = &iforce->dev;
+	int i;
+	static int being_used = 0;
+
+	if (being_used)
+		printk(KERN_WARNING "iforce-packets.c: re-entrant call to iforce_process %d\n", being_used);
+	being_used++;
+
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+	if (HI(iforce->expect_packet) == HI(cmd)) {
+		iforce->expect_packet = 0;
+		iforce->ecmd = cmd;
+		memcpy(iforce->edata, data, IFORCE_MAX_LENGTH);
+		if (waitqueue_active(&iforce->wait))
+			wake_up(&iforce->wait);
+	}
+#endif
+
+	if (!iforce->type) {
+		being_used--;
+		return;
+	}
+
+	switch (HI(cmd)) {
+
+	case 0x01:	/* joystick position data */
+	case 0x03:	/* wheel position data */
+	case 0x06:      /*saitek cyborgforve data */
+	                if (HI(cmd) == 6) {
+			        input_report_abs(dev, ABS_X, (__s16) (((__s16)data[1] << 8) | data[0]));
+				input_report_abs(dev, ABS_Y, (__s16) (((__s16)data[3] << 8) | data[2]));
+				input_report_abs(dev, ABS_THROTTLE, 255 - data[4]);
+				input_report_abs(dev, ABS_RUDDER, 255 - data[7]); 
+			}
+	                else if (HI(cmd) == 1) {
+				input_report_abs(dev, ABS_X, (__s16) (((__s16)data[1] << 8) | data[0]));
+				input_report_abs(dev, ABS_Y, (__s16) (((__s16)data[3] << 8) | data[2]));
+				input_report_abs(dev, ABS_THROTTLE, 255 - data[4]);
+				if (LO(cmd) >= 8 && test_bit(ABS_RUDDER ,dev->absbit))
+					input_report_abs(dev, ABS_RUDDER, (__s8)data[7]);
+			} else {
+				input_report_abs(dev, ABS_WHEEL, (__s16) (((__s16)data[1] << 8) | data[0]));
+				input_report_abs(dev, ABS_GAS,   255 - data[2]);
+				input_report_abs(dev, ABS_BRAKE, 255 - data[3]);
+			}
+
+			input_report_abs(dev, ABS_HAT0X, iforce_hat_to_axis[data[6] >> 4].x);
+			input_report_abs(dev, ABS_HAT0Y, iforce_hat_to_axis[data[6] >> 4].y);
+
+			for (i = 0; iforce->type->btn[i] >= 0; i++)
+				input_report_key(dev, iforce->type->btn[i], data[(i >> 3) + 5] & (1 << (i & 7)));
+
+			/* If there are untouched bits left, interpret them as the second hat */
+			if (i <= 8) {
+				int btns = data[6];
+				if (test_bit(ABS_HAT1X, dev->absbit)) {
+					if (btns & 8) input_report_abs(dev, ABS_HAT1X, -1);
+					else if (btns & 2) input_report_abs(dev, ABS_HAT1X, 1);
+					else input_report_abs(dev, ABS_HAT1X, 0);
+				}
+				if (test_bit(ABS_HAT1Y, dev->absbit)) {
+					if (btns & 1) input_report_abs(dev, ABS_HAT1Y, -1);
+					else if (btns & 4) input_report_abs(dev, ABS_HAT1Y, 1);
+					else input_report_abs(dev, ABS_HAT1Y, 0);
+				}
+			}
+
+			break;
+
+		case 0x02:	/* status report */
+			input_report_key(dev, BTN_DEAD, data[0] & 0x02);
+
+			/* Check if an effect was just started or stopped */
+			i = data[1] & 0x7f;
+			if (data[1] & 0x80) {
+				if (!test_and_set_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {
+				/* Report play event */
+				input_report_ff_status(dev, i, FF_STATUS_PLAYING);
+				}
+			}
+			else if (test_and_clear_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {
+				/* Report stop event */
+				input_report_ff_status(dev, i, FF_STATUS_STOPPED);
+			}
+			if (LO(cmd) > 3) {
+				int j;
+				for (j=3; j<LO(cmd); j+=2) {
+					mark_core_as_ready(iforce, data[j] | (data[j+1]<<8));
+				}
+			}
+			break;
+	}
+	being_used--;
+}
+
+int iforce_get_id_packet(struct iforce *iforce, char *packet)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int timeout = HZ; /* 1 second */
+
+	switch (iforce->bus) {
+
+	case IFORCE_USB:
+
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+		iforce->dr.bRequest = packet[0];
+		iforce->ctrl->dev = iforce->usbdev;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&iforce->wait, &wait);
+
+		if (usb_submit_urb(iforce->ctrl)) {
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&iforce->wait, &wait);
+			return -1;
+		}
+
+		while (timeout && iforce->ctrl->status == -EINPROGRESS)
+			timeout = schedule_timeout(timeout);
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&iforce->wait, &wait);
+
+		if (!timeout) {
+			usb_unlink_urb(iforce->ctrl);
+			return -1;
+		}
+#else
+		printk(KERN_ERR "iforce_get_id_packet: iforce->bus = USB!\n");
+#endif
+		break;
+
+	case IFORCE_232:
+
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+		iforce->expect_packet = FF_CMD_QUERY;
+		iforce_send_packet(iforce, FF_CMD_QUERY, packet);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&iforce->wait, &wait);
+
+		while (timeout && iforce->expect_packet)
+			timeout = schedule_timeout(timeout);
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&iforce->wait, &wait);
+
+		if (!timeout) {
+			iforce->expect_packet = 0;
+			return -1;
+		}
+#else
+		printk(KERN_ERR "iforce_get_id_packet: iforce->bus = SERIO!\n");
+#endif
+		break;
+
+	default:
+		printk(KERN_ERR "iforce_get_id_packet: iforce->bus = %d\n",
+		       iforce->bus);
+		break;
+	}
+
+	return -(iforce->edata[0] != packet[0]);
+}
+
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce-serio.c linux-modified/drivers/char/joystick/iforce/iforce-serio.c
--- linux-vanilla/drivers/char/joystick/iforce/iforce-serio.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce-serio.c	Mon Jan  6 16:48:20 2003
@@ -0,0 +1,166 @@
+/*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+void iforce_serial_xmit(struct iforce *iforce)
+{
+	unsigned char cs;
+	int i;
+	unsigned long flags;
+
+	if (test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags)) {
+		set_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags);
+		return;
+	}
+
+	spin_lock_irqsave(&iforce->xmit_lock, flags);
+
+again:
+	if (iforce->xmit.head == iforce->xmit.tail) {
+		clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
+		spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+		return;
+	}
+
+	cs = 0x2b;
+
+	serio_write(iforce->serio, 0x2b);
+
+	serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+	cs ^= iforce->xmit.buf[iforce->xmit.tail];
+	XMIT_INC(iforce->xmit.tail, 1);
+
+	for (i=iforce->xmit.buf[iforce->xmit.tail]; i >= 0; --i) {
+		serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+		cs ^= iforce->xmit.buf[iforce->xmit.tail];
+		XMIT_INC(iforce->xmit.tail, 1);
+	}
+	
+	serio_write(iforce->serio, cs);
+
+	if (test_and_clear_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags))
+		goto again;
+
+	clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
+
+	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+}
+
+static void iforce_serio_write_wakeup(struct serio *serio)
+{
+	iforce_serial_xmit((struct iforce *)serio->private);
+}
+
+static void iforce_serio_irq(struct serio *serio, unsigned char data, unsigned int flags)
+{
+	struct iforce* iforce = serio->private;
+
+	if (!iforce->pkt) {
+		if (data != 0x2b) {
+			return;
+		}
+		iforce->pkt = 1;
+		return;
+	}
+
+	if (!iforce->id) {
+		if (data > 3 && data != 0xff) {
+			iforce->pkt = 0;
+			return;
+		}
+		iforce->id = data;
+		return;
+	}
+
+	if (!iforce->len) {
+		if (data > IFORCE_MAX_LENGTH) {
+			iforce->pkt = 0;
+			iforce->id = 0;
+			return;
+		}
+		iforce->len = data;
+		return;
+	}
+
+	if (iforce->idx < iforce->len) {
+		iforce->csum += iforce->data[iforce->idx++] = data;
+		return;
+	}
+
+	if (iforce->idx == iforce->len) {
+		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data);
+		iforce->pkt = 0;
+		iforce->id  = 0;
+		iforce->len = 0;
+		iforce->idx = 0;
+		iforce->csum = 0;
+	}
+}
+
+static void iforce_serio_connect(struct serio *serio, struct serio_dev *dev)
+{
+	struct iforce *iforce;
+	if (serio->type != (SERIO_RS232 | SERIO_IFORCE))
+		return;
+
+	if (!(iforce = kmalloc(sizeof(struct iforce), GFP_KERNEL))) return;
+	memset(iforce, 0, sizeof(struct iforce));
+
+	iforce->bus = IFORCE_232;
+	iforce->serio = serio;
+	serio->private = iforce;
+
+	if (serio_open(serio, dev)) {
+		kfree(iforce);
+		return;
+	}
+
+	if (iforce_init_device(iforce)) {
+		serio_close(serio);
+		kfree(iforce);
+		return;
+	}
+}
+
+static void iforce_serio_disconnect(struct serio *serio)
+{
+	struct iforce* iforce = serio->private;
+
+	input_unregister_device(&iforce->dev);
+	serio_close(serio);
+	kfree(iforce);
+}
+
+struct serio_dev iforce_serio_dev = {
+	write_wakeup:	iforce_serio_write_wakeup,
+	interrupt:	iforce_serio_irq,
+	connect:	iforce_serio_connect,
+	disconnect:	iforce_serio_disconnect,
+};
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce-usb.c linux-modified/drivers/char/joystick/iforce/iforce-usb.c
--- linux-vanilla/drivers/char/joystick/iforce/iforce-usb.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce-usb.c	Mon Feb 17 21:28:41 2003
@@ -0,0 +1,211 @@
+ /*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2002 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001-2002 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+void iforce_usb_xmit(struct iforce *iforce)
+{
+	int n, c;
+	unsigned long flags;
+
+	spin_lock_irqsave(&iforce->xmit_lock, flags);
+
+	if (iforce->xmit.head == iforce->xmit.tail) {
+		clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
+		spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+		return;
+	}
+
+	((char *)iforce->out->transfer_buffer)[0] = iforce->xmit.buf[iforce->xmit.tail];
+	XMIT_INC(iforce->xmit.tail, 1);
+	n = iforce->xmit.buf[iforce->xmit.tail];
+	XMIT_INC(iforce->xmit.tail, 1);
+
+	iforce->out->transfer_buffer_length = n + 1;
+	iforce->out->dev = iforce->usbdev;
+
+	/* Copy rest of data then */
+	c = CIRC_CNT_TO_END(iforce->xmit.head, iforce->xmit.tail, XMIT_SIZE);
+	if (n < c) c=n;
+
+	memcpy(iforce->out->transfer_buffer + 1,
+	       &iforce->xmit.buf[iforce->xmit.tail],
+	       c);
+	if (n != c) {
+		memcpy(iforce->out->transfer_buffer + 1 + c,
+		       &iforce->xmit.buf[0],
+		       n-c);
+	}
+	XMIT_INC(iforce->xmit.tail, n);
+
+	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+
+	if ( (n=usb_submit_urb(iforce->out)) ) {
+		printk(KERN_WARNING "iforce.c: iforce_usb_xmit: usb_submit_urb failed %d\n", n);
+	}
+}
+
+static void iforce_usb_irq(struct urb *urb)
+{
+	struct iforce *iforce = urb->context;
+	if (urb->status) return;
+	iforce_process_packet(iforce,
+		(iforce->data[0] << 8) | (urb->actual_length - 1), iforce->data + 1);
+}
+
+static void iforce_usb_out(struct urb *urb)
+{
+	struct iforce *iforce = urb->context;
+
+	if (urb->status) {
+		printk(KERN_DEBUG "iforce_usb_out: urb->status %d, exiting", urb->status);
+		return;
+	}
+
+	iforce_usb_xmit(iforce);
+
+	if (waitqueue_active(&iforce->wait))
+		wake_up(&iforce->wait);
+}
+
+static void iforce_usb_ctrl(struct urb *urb)
+{
+	struct iforce *iforce = urb->context;
+	if (urb->status) return;
+	iforce->ecmd = 0xff00 | urb->actual_length;
+	if (waitqueue_active(&iforce->wait))
+		wake_up(&iforce->wait);
+}
+
+static void *iforce_usb_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	struct usb_endpoint_descriptor *epirq, *epout;
+	struct iforce *iforce;
+
+	epirq = dev->config[0].interface[ifnum].altsetting[0].endpoint + 0;
+	epout = dev->config[0].interface[ifnum].altsetting[0].endpoint + 1;
+
+	if (!(iforce = kmalloc(sizeof(struct iforce) + 32, GFP_KERNEL)))
+		goto fail;
+
+	memset(iforce, 0, sizeof(struct iforce));
+
+	if (!(iforce->irq = usb_alloc_urb(0))) {
+		goto fail;
+	}
+
+	if (!(iforce->out = usb_alloc_urb(0))) {
+		goto fail;
+	}
+
+	if (!(iforce->ctrl = usb_alloc_urb(0))) {
+		goto fail;
+	}
+
+	iforce->bus = IFORCE_USB;
+	iforce->usbdev = dev;
+
+	iforce->dr.bRequestType = USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_INTERFACE;
+	iforce->dr.wIndex = 0;
+	iforce->dr.wLength = 16;
+
+	usb_fill_int_urb(iforce->irq, dev, usb_rcvintpipe(dev, epirq->bEndpointAddress),
+			iforce->data, 16, iforce_usb_irq, iforce, epirq->bInterval);
+
+	usb_fill_bulk_urb(iforce->out, dev, usb_sndbulkpipe(dev, epout->bEndpointAddress),
+			iforce + 1, 32, iforce_usb_out, iforce);
+
+	usb_fill_control_urb(iforce->ctrl, dev, usb_rcvctrlpipe(dev, 0),
+			(void*) &iforce->dr, iforce->edata, 16, iforce_usb_ctrl, iforce);
+
+	if (iforce_init_device(iforce)) goto fail;
+
+	return iforce;
+
+fail:
+	if (iforce) {
+		if (iforce->irq) usb_free_urb(iforce->irq);
+		if (iforce->out) usb_free_urb(iforce->out);
+		if (iforce->ctrl) usb_free_urb(iforce->ctrl);
+		kfree(iforce);
+	}
+
+	return NULL;
+}
+
+/* Called by iforce_delete() */
+void iforce_usb_delete(struct iforce* iforce)
+{
+	usb_unlink_urb(iforce->irq);
+	usb_unlink_urb(iforce->out);
+	usb_unlink_urb(iforce->ctrl);
+
+	usb_free_urb(iforce->irq);
+	usb_free_urb(iforce->out);
+	usb_free_urb(iforce->ctrl);
+}
+
+static void iforce_usb_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct iforce *iforce = ptr;
+	int open = iforce->dev.handle->open;
+
+	iforce->usbdev = NULL;
+	input_unregister_device(&iforce->dev);
+
+	if (!open) {
+		iforce_delete_device(iforce);
+		kfree(iforce);
+	}
+}
+
+static struct usb_device_id iforce_usb_ids [] = {
+	{ USB_DEVICE(0x044f, 0xa01c) },		/* Thrustmaster Motor Sport GT */
+	{ USB_DEVICE(0x046d, 0xc281) },		/* Logitech WingMan Force */
+	{ USB_DEVICE(0x046d, 0xc291) },		/* Logitech WingMan Formula Force */
+	{ USB_DEVICE(0x05ef, 0x020a) },		/* AVB Top Shot Pegasus */
+	{ USB_DEVICE(0x05ef, 0x8884) },		/* AVB Mag Turbo Force */
+	{ USB_DEVICE(0x05ef, 0x8888) },		/* AVB Top Shot FFB Racing Wheel */
+	{ USB_DEVICE(0x061c, 0xc084) },         /* ACT LABS Force RS */
+	{ USB_DEVICE(0x06f8, 0x0001) },		/* Guillemot Race Leader Force Feedback */
+	{ USB_DEVICE(0x06f8, 0x0004) },		/* Guillemot Force Feedback Racing Wheel */
+	{ USB_DEVICE(0x06a3, 0xff12) },         /* Saitek Cyborgforce 3d */
+	{ }					/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, iforce_usb_ids);
+
+struct usb_driver iforce_usb_driver = {
+//	owner:		THIS_MODULE,
+	name:		"iforce",
+	probe:		iforce_usb_probe,
+	disconnect:	iforce_usb_disconnect,
+	id_table:	iforce_usb_ids,
+};
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce/iforce.h linux-modified/drivers/char/joystick/iforce/iforce.h
--- linux-vanilla/drivers/char/joystick/iforce/iforce.h	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/char/joystick/iforce/iforce.h	Sun Mar  9 16:58:46 2003
@@ -0,0 +1,184 @@
+/*
+ * $Id$
+ *
+ *  Copyright (c) 2000-2002 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001-2002 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <linux/serio.h>
+#include <linux/config.h>
+#include <linux/circ_buf.h>
+#include <asm/semaphore.h>
+
+/* FF: This module provides arbitrary resource management routines.
+ * I use it to manage the device's memory.
+ * Despite the name of this module, I am *not* going to access the ioports.
+ */
+#include <linux/ioport.h>
+
+#define IFORCE_MAX_LENGTH	16
+
+#define IFORCE_232	1
+#define IFORCE_USB	2
+
+#define FALSE 0
+#define TRUE 1
+
+#define FF_EFFECTS_MAX	32
+
+/* Each force feedback effect is made of one core effect, which can be
+ * associated to at most to effect modifiers
+ */
+#define FF_MOD1_IS_USED		0
+#define FF_MOD2_IS_USED		1
+#define FF_CORE_IS_USED		2
+#define FF_CORE_IS_PLAYED	3	/* Effect is currently being played */
+#define FF_CORE_SHOULD_PLAY	4	/* User wants the effect to be played */
+#define FF_CORE_UPDATE		5	/* Effect is being updated */
+#define FF_MODCORE_MAX		5
+
+struct iforce_core_effect {
+	/* Information about where modifiers are stored in the device's memory */
+	struct resource mod1_chunk;
+	struct resource mod2_chunk;
+	unsigned long flags[NBITS(FF_MODCORE_MAX)];
+	pid_t owner;
+	/* Used to keep track of parameters of an effect. They are needed
+	 * to know what parts of an effect changed in an update operation.
+	 * We try to send only parameter packets if possible, as sending
+	 * effect parameter requires the effect to be stoped and restarted
+	 */
+	struct ff_effect effect;
+};
+
+#define FF_CMD_EFFECT		0x010e
+#define FF_CMD_ENVELOPE		0x0208
+#define FF_CMD_MAGNITUDE	0x0303
+#define FF_CMD_PERIOD		0x0407
+#define FF_CMD_CONDITION	0x050a
+
+#define FF_CMD_AUTOCENTER	0x4002
+#define FF_CMD_PLAY		0x4103
+#define FF_CMD_ENABLE		0x4201
+#define FF_CMD_GAIN		0x4301
+
+#define FF_CMD_QUERY		0xff01
+
+/* Buffer for async write */
+#define XMIT_SIZE		256
+#define XMIT_INC(var, n)	(var)+=n; (var)&= XMIT_SIZE -1
+/* iforce::xmit_flags */
+#define IFORCE_XMIT_RUNNING	0
+#define IFORCE_XMIT_AGAIN	1
+
+struct iforce_device {
+	u16 idvendor;
+	u16 idproduct;
+	char *name;
+	signed short *btn;
+	signed short *abs;
+	signed short *ff;
+};
+
+struct iforce {
+	struct input_dev dev;		/* Input device interface */
+	struct iforce_device *type;
+	int bus;
+
+	unsigned char data[IFORCE_MAX_LENGTH];
+	unsigned char edata[IFORCE_MAX_LENGTH];
+	u16 ecmd;
+	u16 expect_packet;
+
+#ifdef CONFIG_JOYSTICK_IFORCE_232
+	struct serio *serio;		/* RS232 transfer */
+	int idx, pkt, len, id;
+	unsigned char csum;
+#endif
+#ifdef CONFIG_JOYSTICK_IFORCE_USB
+	struct usb_device *usbdev;	/* USB transfer */
+	struct urb *irq, *out, *ctrl;
+	struct usb_ctrlrequest dr;
+#endif
+	spinlock_t xmit_lock;
+	/* Buffer used for asynchronous sending of bytes to the device */
+	struct circ_buf xmit;
+	unsigned char xmit_data[XMIT_SIZE];
+	long xmit_flags[1];
+	
+					/* Force Feedback */
+	wait_queue_head_t wait;
+	struct resource device_memory;
+	struct iforce_core_effect core_effects[FF_EFFECTS_MAX];
+	struct semaphore mem_mutex;
+};
+
+/* Get hi and low bytes of a 16-bits int */
+#define HI(a)	((unsigned char)((a) >> 8))
+#define LO(a)	((unsigned char)((a) & 0xff))
+
+/* For many parameters, it seems that 0x80 is a special value that should
+ * be avoided. Instead, we replace this value by 0x7f
+ */
+#define HIFIX80(a) ((unsigned char)(((a)<0? (a)+255 : (a))>>8))
+
+/* Encode a time value */
+#define TIME_SCALE(a)	(a)
+
+
+/* Public functions */
+/* iforce-serio.c */
+void iforce_serial_xmit(struct iforce *iforce);
+
+/* iforce-usb.c */
+void iforce_usb_xmit(struct iforce *iforce);
+void iforce_usb_delete(struct iforce *iforce);
+
+/* iforce-main.c */
+int iforce_init_device(struct iforce *iforce);
+void iforce_delete_device(struct iforce *iforce);
+
+/* iforce-packets.c */
+int iforce_control_playback(struct iforce*, u16 id, unsigned int);
+void iforce_process_packet(struct iforce *iforce, u16 cmd, unsigned char *data);
+int iforce_send_packet(struct iforce *iforce, u16 cmd, unsigned char* data);
+void iforce_dump_packet(char *msg, u16 cmd, unsigned char *data) ;
+int iforce_get_id_packet(struct iforce *iforce, char *packet);
+
+/* iforce-ff.c */
+int iforce_upload_periodic(struct iforce*, struct ff_effect*, int is_update);
+int iforce_upload_constant(struct iforce*, struct ff_effect*, int is_update);
+int iforce_upload_condition(struct iforce*, struct ff_effect*, int is_update);
+
+/* Public variables */
+extern struct serio_dev iforce_serio_dev;
+extern struct usb_driver iforce_usb_driver;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/iforce.c linux-modified/drivers/char/joystick/iforce.c
--- linux-vanilla/drivers/char/joystick/iforce.c	Mon Feb  3 20:32:38 2003
+++ linux-modified/drivers/char/joystick/iforce.c	Thu Jan  1 02:00:00 1970
@@ -1,1199 +0,0 @@
-/*
- * $Id$
- *
- *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@suse.cz>
- *  Copyright (c) 2001 Johann Deneux <deneux@ifrance.com>
- *
- *  USB/RS232 I-Force joysticks and wheels.
- *
- *  Sponsored by SuSE
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/input.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/usb.h>
-#include <linux/serio.h>
-#include <linux/config.h>
-
-/* FF: This module provides arbitrary resource management routines.
- * I use it to manage the device's memory.
- * Despite the name of this module, I am *not* going to access the ioports.
- */
-#include <linux/ioport.h>
-
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>, Johann Deneux <deneux@ifrance.com>");
-MODULE_DESCRIPTION("USB/RS232 I-Force joysticks and wheels driver");
-MODULE_LICENSE("GPL");
-
-#define IFORCE_MAX_LENGTH	16
-
-#if defined(CONFIG_INPUT_IFORCE_232) || defined(CONFIG_INPUT_IFORCE_232_MODULE)
-#define IFORCE_232	1
-#endif
-#if defined(CONFIG_INPUT_IFORCE_USB) || defined(CONFIG_INPUT_IFORCE_USB_MODULE)
-#define IFORCE_USB	2
-#endif
-
-#define FF_EFFECTS_MAX	32
-
-/* Each force feedback effect is made of one core effect, which can be
- * associated to at most to effect modifiers
- */
-#define FF_MOD1_IS_USED		0
-#define FF_MOD2_IS_USED		1
-#define FF_CORE_IS_USED		2
-#define FF_CORE_IS_PLAYED	3
-#define FF_MODCORE_MAX		3
-
-struct iforce_core_effect {
-	/* Information about where modifiers are stored in the device's memory */
-	struct resource mod1_chunk;
-	struct resource mod2_chunk;
-	unsigned long flags[NBITS(FF_MODCORE_MAX)];
-};
-
-#define FF_CMD_EFFECT		0x010e
-#define FF_CMD_SHAPE		0x0208
-#define FF_CMD_MAGNITUDE	0x0303
-#define FF_CMD_PERIOD		0x0407
-#define FF_CMD_INTERACT		0x050a
-
-#define FF_CMD_AUTOCENTER	0x4002
-#define FF_CMD_PLAY		0x4103
-#define FF_CMD_ENABLE		0x4201
-#define FF_CMD_GAIN		0x4301
-
-#define FF_CMD_QUERY		0xff01
-
-static signed short btn_joystick[] = { BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,
-	BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_A, BTN_B, BTN_C, BTN_DEAD, -1 };
-static signed short btn_wheel[] =    { BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,
-	BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_A, BTN_B, BTN_C, -1 };
-static signed short abs_joystick[] = { ABS_X, ABS_Y, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, -1 };
-static signed short abs_wheel[] =    { ABS_WHEEL, ABS_GAS, ABS_BRAKE, ABS_HAT0X, ABS_HAT0Y, -1 };
-static signed short ff_iforce[] =    { FF_PERIODIC, FF_CONSTANT, FF_SPRING, FF_FRICTION,
-	FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP, FF_SAW_DOWN, FF_GAIN, FF_AUTOCENTER, -1 };
-
-static struct iforce_device {
-	u16 idvendor;
-	u16 idproduct;
-	char *name;
-	signed short *btn;
-	signed short *abs;
-	signed short *ff;
-} iforce_device[] = {
-	{ 0x046d, 0xc281, "Logitech WingMan Force",			btn_joystick, abs_joystick, ff_iforce },
-	{ 0x046d, 0xc291, "Logitech WingMan Formula Force",		btn_wheel, abs_wheel, ff_iforce },
-	{ 0x05ef, 0x020a, "AVB Top Shot Pegasus",			btn_joystick, abs_joystick, ff_iforce },
-	{ 0x05ef, 0x8884, "AVB Mag Turbo Force",			btn_wheel, abs_wheel, ff_iforce },
-	{ 0x06f8, 0x0001, "Guillemot Race Leader Force Feedback",	btn_wheel, abs_wheel, ff_iforce },
-	{ 0x0000, 0x0000, "Unknown I-Force Device [%04x:%04x]",		btn_joystick, abs_joystick, ff_iforce }
-};
-
-struct iforce {
-	struct input_dev dev;		/* Input device interface */
-	struct iforce_device *type;
-	char name[64];
-	int open;
-	int bus;
-
-	unsigned char data[IFORCE_MAX_LENGTH];
-	unsigned char edata[IFORCE_MAX_LENGTH];
-	u16 ecmd;
-	u16 expect_packet;
-
-#ifdef IFORCE_232
-	struct serio *serio;		/* RS232 transfer */
-	int idx, pkt, len, id;
-	unsigned char csum;
-#endif
-#ifdef IFORCE_USB
-	struct usb_device *usbdev;	/* USB transfer */
-	struct urb irq, out, ctrl;
-	struct usb_ctrlrequest dr;
-#endif
-					/* Force Feedback */
-	wait_queue_head_t wait;
-	struct resource device_memory;
-	struct iforce_core_effect core_effects[FF_EFFECTS_MAX];
-};
-
-static struct {
-	__s32 x;
-	__s32 y;
-} iforce_hat_to_axis[16] = {{ 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
-
-/* Get hi and low bytes of a 16-bits int */
-#define HI(a)	((unsigned char)((a) >> 8))
-#define LO(a)	((unsigned char)((a) & 0xff))
-
-/* Encode a time value */
-#define TIME_SCALE(a)	((a) == 0xffff ? 0xffff : (a) * 1000 / 256)
-
-static void dump_packet(char *msg, u16 cmd, unsigned char *data)
-{
-	int i;
-
-	printk(KERN_DEBUG "iforce.c: %s ( cmd = %04x, data = ", msg, cmd);
-	for (i = 0; i < LO(cmd); i++)
-		printk("%02x ", data[i]);
-	printk(")\n");
-}
-
-/*
- * Send a packet of bytes to the device
- */
-static void send_packet(struct iforce *iforce, u16 cmd, unsigned char* data)
-{
-	switch (iforce->bus) {
-
-#ifdef IFORCE_232
-		case IFORCE_232: {
-
-			int i;
-			unsigned char csum = 0x2b ^ HI(cmd) ^ LO(cmd);
-
-			serio_write(iforce->serio, 0x2b);
-			serio_write(iforce->serio, HI(cmd));
-			serio_write(iforce->serio, LO(cmd));
-
-			for (i = 0; i < LO(cmd); i++) {
-				serio_write(iforce->serio, data[i]);
-				csum = csum ^ data[i];
-			}
-
-			serio_write(iforce->serio, csum);
-			return;
-		}
-#endif
-#ifdef IFORCE_USB
-		case IFORCE_USB: {
-
-			DECLARE_WAITQUEUE(wait, current);
-			int timeout = HZ; /* 1 second */
-
-			memcpy(iforce->out.transfer_buffer + 1, data, LO(cmd));
-			((char*)iforce->out.transfer_buffer)[0] = HI(cmd);
-			iforce->out.transfer_buffer_length = LO(cmd) + 2;
-			iforce->out.dev = iforce->usbdev;
-
-			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&iforce->wait, &wait);
-
-			if (usb_submit_urb(&iforce->out)) {
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&iforce->wait, &wait);
-				return;
-			}
-
-			while (timeout && iforce->out.status == -EINPROGRESS)
-				timeout = schedule_timeout(timeout);
-
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&iforce->wait, &wait);
-
-			if (!timeout)
-				usb_unlink_urb(&iforce->out);
-
-			return;
-		}
-#endif
-	}
-}
-
-static void iforce_process_packet(struct iforce *iforce, u16 cmd, unsigned char *data)
-{
-	struct input_dev *dev = &iforce->dev;
-	int i;
-
-#ifdef IFORCE_232
-	if (HI(iforce->expect_packet) == HI(cmd)) {
-		iforce->expect_packet = 0;
-		iforce->ecmd = cmd;
-		memcpy(iforce->edata, data, IFORCE_MAX_LENGTH);
-		if (waitqueue_active(&iforce->wait))
-			wake_up(&iforce->wait);
-	}
-#endif
-
-	if (!iforce->type)
-		return;
-
-	switch (HI(cmd)) {
-
-		case 0x01:	/* joystick position data */
-		case 0x03:	/* wheel position data */
-
-			if (HI(cmd) == 1) {
-				input_report_abs(dev, ABS_X, (__s16) (((__s16)data[1] << 8) | data[0]));
-				input_report_abs(dev, ABS_Y, (__s16) (((__s16)data[3] << 8) | data[2]));
-				input_report_abs(dev, ABS_THROTTLE, 255 - data[4]);
-			} else {
-				input_report_abs(dev, ABS_WHEEL, (__s16) (((__s16)data[1] << 8) | data[0]));
-				input_report_abs(dev, ABS_GAS,   255 - data[2]);
-				input_report_abs(dev, ABS_BRAKE, 255 - data[3]);
-			}
-
-			input_report_abs(dev, ABS_HAT0X, iforce_hat_to_axis[data[6] >> 4].x);
-			input_report_abs(dev, ABS_HAT0Y, iforce_hat_to_axis[data[6] >> 4].y);
-
-			for (i = 0; iforce->type->btn[i] >= 0; i++)
-				input_report_key(dev, iforce->type->btn[i], data[(i >> 3) + 5] & (1 << (i & 7)));
-
-			break;
-
-		case 0x02:	/* status report */
-
-			input_report_key(dev, BTN_DEAD, data[0] & 0x02);
-			break;
-	}
-}
-
-static int get_id_packet(struct iforce *iforce, char *packet)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	int timeout = HZ; /* 1 second */
-
-	switch (iforce->bus) {
-
-#ifdef IFORCE_USB
-		case IFORCE_USB:
-
-			iforce->dr.bRequest = packet[0];
-			iforce->ctrl.dev = iforce->usbdev;
-
-			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&iforce->wait, &wait);
-
-			if (usb_submit_urb(&iforce->ctrl)) {
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&iforce->wait, &wait);
-				return -1;
-			}
-
-			while (timeout && iforce->ctrl.status == -EINPROGRESS)
-				timeout = schedule_timeout(timeout);
-
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&iforce->wait, &wait);
-
-			if (!timeout) {
-				usb_unlink_urb(&iforce->ctrl);
-				return -1;
-			}
-
-			break;
-#endif
-#ifdef IFORCE_232
-		case IFORCE_232:
-
-			iforce->expect_packet = FF_CMD_QUERY;
-			send_packet(iforce, FF_CMD_QUERY, packet);
-
-			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&iforce->wait, &wait);
-
-			while (timeout && iforce->expect_packet)
-				timeout = schedule_timeout(timeout);
-
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&iforce->wait, &wait);
-
-			if (!timeout) {
-				iforce->expect_packet = 0;
-				return -1;
-			}
-
-			break;
-#endif
-	}
-
-	return -(iforce->edata[0] != packet[0]);
-}
-
-static int iforce_open(struct input_dev *dev)
-{
-	struct iforce *iforce = dev->private;
-
-	switch (iforce->bus) {
-#ifdef IFORCE_USB
-		case IFORCE_USB:
-			if (iforce->open++)
-				break;
-			iforce->irq.dev = iforce->usbdev;
-			if (usb_submit_urb(&iforce->irq))
-					return -EIO;
-			break;
-#endif
-	}
-	return 0;
-}
-
-static void iforce_close(struct input_dev *dev)
-{
-	struct iforce *iforce = dev->private;
-
-	switch (iforce->bus) {
-#ifdef IFORCE_USB
-		case IFORCE_USB:
-			if (!--iforce->open)
-				usb_unlink_urb(&iforce->irq);
-			break;
-#endif
-	}
-}
-
-/*
- * Start or stop playing an effect
- */
-
-static int iforce_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
-{
-	struct iforce* iforce = (struct iforce*)(dev->private);
-	unsigned char data[3];
-
-	printk(KERN_DEBUG "iforce.c: input_event(type = %d, code = %d, value = %d)\n", type, code, value);
-
-	if (type != EV_FF)
-		return -1;
-
-	switch (code) {
-
-		case FF_GAIN:
-
-			data[0] = value >> 9;
-			send_packet(iforce, FF_CMD_GAIN, data);
-
-			return 0;
-
-		case FF_AUTOCENTER:
-
-			data[0] = 0x03;
-			data[1] = value >> 9;
-			send_packet(iforce, FF_CMD_AUTOCENTER, data);
-
-			data[0] = 0x04;
-			data[1] = 0x01;
-			send_packet(iforce, FF_CMD_AUTOCENTER, data);
-
-			return 0;
-
-		default: /* Play an effect */
-
-			if (code >= iforce->dev.ff_effects_max)
-				return -1;
-
-			data[0] = LO(code);
-			data[1] = (value > 0) ? ((value > 1) ? 0x41 : 0x01) : 0;
-			data[2] = LO(value);
-			send_packet(iforce, FF_CMD_PLAY, data);
-
-			return 0;
-	}
-
-	return -1;
-}
-
-/*
- * Set the magnitude of a constant force effect
- * Return error code
- *
- * Note: caller must ensure exclusive access to device
- */
-
-static int make_magnitude_modifier(struct iforce* iforce,
-	struct resource* mod_chunk, __s16 level)
-{
-	unsigned char data[3];
-
-	if (allocate_resource(&(iforce->device_memory), mod_chunk, 2,
-		iforce->device_memory.start, iforce->device_memory.end, 2L,
-		NULL, NULL)) {
-		return -ENOMEM;
-	}
-
-	data[0] = LO(mod_chunk->start);
-	data[1] = HI(mod_chunk->start);
-	data[2] = HI(level);
-
-	send_packet(iforce, FF_CMD_MAGNITUDE, data);
-
-	return 0;
-}
-
-/*
- * Upload the component of an effect dealing with the period, phase and magnitude
- */
-
-static int make_period_modifier(struct iforce* iforce, struct resource* mod_chunk,
-	__s16 magnitude, __s16 offset, u16 period, u16 phase)
-{
-	unsigned char data[7];
-
-	period = TIME_SCALE(period);
-
-	if (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0c,
-		iforce->device_memory.start, iforce->device_memory.end, 2L,
-		NULL, NULL)) {
-		return -ENOMEM;
-	}
-
-	data[0] = LO(mod_chunk->start);
-	data[1] = HI(mod_chunk->start);
-
-	data[2] = HI(magnitude);
-	data[3] = HI(offset);
-	data[4] = HI(phase);
-
-	data[5] = LO(period);
-	data[6] = HI(period);
-
-	send_packet(iforce, FF_CMD_PERIOD, data);
-
-	return 0;
-}
-
-/*
- * Uploads the part of an effect setting the shape of the force
- */
-
-static int make_shape_modifier(struct iforce* iforce, struct resource* mod_chunk,
-	u16 attack_duration, __s16 initial_level,
-	u16 fade_duration, __s16 final_level)
-{
-	unsigned char data[8];
-
-	attack_duration = TIME_SCALE(attack_duration);
-	fade_duration = TIME_SCALE(fade_duration);
-
-	if (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0e,
-		iforce->device_memory.start, iforce->device_memory.end, 2L,
-		NULL, NULL)) {
-		return -ENOMEM;
-	}
-
-	data[0] = LO(mod_chunk->start);
-	data[1] = HI(mod_chunk->start);
-
-	data[2] = LO(attack_duration);
-	data[3] = HI(attack_duration);
-	data[4] = HI(initial_level);
-
-	data[5] = LO(fade_duration);
-	data[6] = HI(fade_duration);
-	data[7] = HI(final_level);
-
-	send_packet(iforce, FF_CMD_SHAPE, data);
-
-	return 0;
-}
-
-/*
- * Component of spring, friction, inertia... effects
- */
-
-static int make_interactive_modifier(struct iforce* iforce,
-	struct resource* mod_chunk,
-	__s16 rsat, __s16 lsat, __s16 rk, __s16 lk, u16 db, __s16 center)
-{
-	unsigned char data[10];
-
-	if (allocate_resource(&(iforce->device_memory), mod_chunk, 8,
-		iforce->device_memory.start, iforce->device_memory.end, 2L,
-		NULL, NULL)) {
-		return -ENOMEM;
-	}
-
-	data[0] = LO(mod_chunk->start);
-	data[1] = HI(mod_chunk->start);
-
-	data[2] = HI(rk);
-	data[3] = HI(lk);
-
-	data[4] = LO(center);
-	data[5] = HI(center);
-
-	data[6] = LO(db);
-	data[7] = HI(db);
-
-	data[8] = HI(rsat);
-	data[9] = HI(lsat);
-
-	send_packet(iforce, FF_CMD_INTERACT, data);
-
-	return 0;
-}
-
-static unsigned char find_button(struct iforce *iforce, signed short button)
-{
-	int i;
-	for (i = 1; iforce->type->btn[i] >= 0; i++)
-		if (iforce->type->btn[i] == button)
-			return i + 1;
-	return 0;
-}
-
-/*
- * Send the part common to all effects to the device
- */
-
-static int make_core(struct iforce* iforce, u16 id, u16 mod_id1, u16 mod_id2,
-	u8 effect_type, u8 axes, u16 duration, u16 delay, u16 button,
-	u16 interval, u16 direction)
-{
-	unsigned char data[14];
-
-	duration = TIME_SCALE(duration);
-	delay    = TIME_SCALE(delay);
-	interval = TIME_SCALE(interval);
-
-	data[0]  = LO(id);
-	data[1]  = effect_type;
-	data[2]  = LO(axes) | find_button(iforce, button);
-
-	data[3]  = LO(duration);
-	data[4]  = HI(duration);
-
-	data[5]  = HI(direction);
-
-	data[6]  = LO(interval);
-	data[7]  = HI(interval);
-
-	data[8]  = LO(mod_id1);
-	data[9]  = HI(mod_id1);
-	data[10] = LO(mod_id2);
-	data[11] = HI(mod_id2);
-
-	data[12] = LO(delay);
-	data[13] = HI(delay);
-
-	send_packet(iforce, FF_CMD_EFFECT, data);
-
-	return 0;
-}
-
-/*
- * Upload a periodic effect to the device
- */
-
-static int iforce_upload_periodic(struct iforce* iforce, struct ff_effect* effect)
-{
-	u8 wave_code;
-	int core_id = effect->id;
-	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
-	struct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);
-	struct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);
-	int err = 0;
-
-	err = make_period_modifier(iforce, mod1_chunk,
-		effect->u.periodic.magnitude, effect->u.periodic.offset,
-		effect->u.periodic.period, effect->u.periodic.phase);
-	if (err) return err;
-	set_bit(FF_MOD1_IS_USED, core_effect->flags);
-
-	err = make_shape_modifier(iforce, mod2_chunk,
-		effect->u.periodic.shape.attack_length,
-		effect->u.periodic.shape.attack_level,
-		effect->u.periodic.shape.fade_length,
-		effect->u.periodic.shape.fade_level);
-	if (err) return err;
-	set_bit(FF_MOD2_IS_USED, core_effect->flags);
-
-	switch (effect->u.periodic.waveform) {
-		case FF_SQUARE:		wave_code = 0x20; break;
-		case FF_TRIANGLE:	wave_code = 0x21; break;
-		case FF_SINE:		wave_code = 0x22; break;
-		case FF_SAW_UP:		wave_code = 0x23; break;
-		case FF_SAW_DOWN:	wave_code = 0x24; break;
-		default:		wave_code = 0x20; break;
-	}
-
-	err = make_core(iforce, effect->id,
-		mod1_chunk->start,
-		mod2_chunk->start,
-		wave_code,
-		0x20,
-		effect->replay.length,
-		effect->replay.delay,
-		effect->trigger.button,
-		effect->trigger.interval,
-		effect->u.periodic.direction);
-
-	return err;
-}
-
-/*
- * Upload a constant force effect
- */
-static int iforce_upload_constant(struct iforce* iforce, struct ff_effect* effect)
-{
-	int core_id = effect->id;
-	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
-	struct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);
-	struct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);
-	int err = 0;
-
-	printk(KERN_DEBUG "iforce.c: make constant effect\n");
-
-	err = make_magnitude_modifier(iforce, mod1_chunk, effect->u.constant.level);
-	if (err) return err;
-	set_bit(FF_MOD1_IS_USED, core_effect->flags);
-
-	err = make_shape_modifier(iforce, mod2_chunk,
-		effect->u.constant.shape.attack_length,
-		effect->u.constant.shape.attack_level,
-		effect->u.constant.shape.fade_length,
-		effect->u.constant.shape.fade_level);
-	if (err) return err;
-	set_bit(FF_MOD2_IS_USED, core_effect->flags);
-
-	err = make_core(iforce, effect->id,
-		mod1_chunk->start,
-		mod2_chunk->start,
-		0x00,
-		0x20,
-		effect->replay.length,
-		effect->replay.delay,
-		effect->trigger.button,
-		effect->trigger.interval,
-		effect->u.constant.direction);
-
-	return err;
-}
-
-/*
- * Upload an interactive effect. Those are for example friction, inertia, springs...
- */
-static int iforce_upload_interactive(struct iforce* iforce, struct ff_effect* effect)
-{
-	int core_id = effect->id;
-	struct iforce_core_effect* core_effect = iforce->core_effects + core_id;
-	struct resource* mod_chunk = &(core_effect->mod1_chunk);
-	u8 type, axes;
-	u16 mod1, mod2, direction;
-	int err = 0;
-
-	printk(KERN_DEBUG "iforce.c: make interactive effect\n");
-
-	switch (effect->type) {
-		case FF_SPRING:		type = 0x40; break;
-		case FF_FRICTION:	type = 0x41; break;
-		default: return -1;
-	}
-
-	err = make_interactive_modifier(iforce, mod_chunk,
-		effect->u.interactive.right_saturation,
-		effect->u.interactive.left_saturation,
-		effect->u.interactive.right_coeff,
-		effect->u.interactive.left_coeff,
-		effect->u.interactive.deadband,
-		effect->u.interactive.center);
-	if (err) return err;
-	set_bit(FF_MOD1_IS_USED, core_effect->flags);
-
-	switch ((test_bit(ABS_X, &effect->u.interactive.axis) ||
-		test_bit(ABS_WHEEL, &effect->u.interactive.axis)) |
-		(!!test_bit(ABS_Y, &effect->u.interactive.axis) << 1)) {
-
-		case 0: /* Only one axis, choose orientation */
-			mod1 = mod_chunk->start;
-			mod2 = 0xffff;
-			direction = effect->u.interactive.direction;
-			axes = 0x20;
-			break;
-
-		case 1:	/* Only X axis */
-			mod1 = mod_chunk->start;
-			mod2 = 0xffff;
-			direction = 0x5a00;
-			axes = 0x40;
-			break;
-
-		case 2: /* Only Y axis */
-			mod1 = 0xffff;
-			mod2 = mod_chunk->start;
-			direction = 0xb400;
-			axes = 0x80;
-			break;
-
-		case 3:	/* Both X and Y axes */
-			/* TODO: same setting for both axes is not mandatory */
-			mod1 = mod_chunk->start;
-			mod2 = mod_chunk->start;
-			direction = 0x6000;
-			axes = 0xc0;
-			break;
-
-		default:
-			return -1;
-	}
-
-	err = make_core(iforce, effect->id,
-		mod1, mod2,
-		type, axes,
-		effect->replay.length, effect->replay.delay,
-		effect->trigger.button, effect->trigger.interval,
-		direction);
-
-	return err;
-}
-
-/*
- * Function called when an ioctl is performed on the event dev entry.
- * It uploads an effect to the device
- */
-static int iforce_upload_effect(struct input_dev *dev, struct ff_effect *effect)
-{
-	struct iforce* iforce = (struct iforce*)(dev->private);
-	int id;
-
-	printk(KERN_DEBUG "iforce.c: upload effect\n");
-
-/*
- * Get a free id
- */
-
-	for (id=0; id < FF_EFFECTS_MAX; ++id)
-		if (!test_bit(FF_CORE_IS_USED, iforce->core_effects[id].flags)) break;
-
-	if ( id == FF_EFFECTS_MAX || id >= iforce->dev.ff_effects_max)
-		return -ENOMEM;
-
-	effect->id = id;
-	set_bit(FF_CORE_IS_USED, iforce->core_effects[id].flags);
-
-/*
- * Upload the effect
- */
-
-	switch (effect->type) {
-
-		case FF_PERIODIC:
-			return iforce_upload_periodic(iforce, effect);
-
-		case FF_CONSTANT:
-			return iforce_upload_constant(iforce, effect);
-
-		case FF_SPRING:
-		case FF_FRICTION:
-			return iforce_upload_interactive(iforce, effect);
-
-		default:
-			return -1;
-	}
-}
-
-/*
- * Erases an effect: it frees the effect id and mark as unused the memory
- * allocated for the parameters
- */
-static int iforce_erase_effect(struct input_dev *dev, int effect_id)
-{
-	struct iforce* iforce = (struct iforce*)(dev->private);
-	int err = 0;
-	struct iforce_core_effect* core_effect;
-
-	printk(KERN_DEBUG "iforce.c: erase effect %d\n", effect_id);
-
-	if (effect_id < 0 || effect_id >= FF_EFFECTS_MAX)
-		return -EINVAL;
-
-	core_effect = iforce->core_effects + effect_id;
-
-	if (test_bit(FF_MOD1_IS_USED, core_effect->flags))
-		err = release_resource(&(iforce->core_effects[effect_id].mod1_chunk));
-
-	if (!err && test_bit(FF_MOD2_IS_USED, core_effect->flags))
-		err = release_resource(&(iforce->core_effects[effect_id].mod2_chunk));
-
-	/*TODO: remember to change that if more FF_MOD* bits are added */
-	core_effect->flags[0] = 0;
-
-	return err;
-}
-static int iforce_init_device(struct iforce *iforce)
-{
-	unsigned char c[] = "CEOV";
-	int i;
-
-	init_waitqueue_head(&iforce->wait);
-	iforce->dev.ff_effects_max = 10;
-
-/*
- * Input device fields.
- */
-
-	iforce->dev.idbus = BUS_USB;
-	iforce->dev.private = iforce;
-	iforce->dev.name = iforce->name;
-	iforce->dev.open = iforce_open;
-	iforce->dev.close = iforce_close;
-	iforce->dev.event = iforce_input_event;
-	iforce->dev.upload_effect = iforce_upload_effect;
-	iforce->dev.erase_effect = iforce_erase_effect;
-
-/*
- * On-device memory allocation.
- */
-
-	iforce->device_memory.name = "I-Force device effect memory";
-	iforce->device_memory.start = 0;
-	iforce->device_memory.end = 200;
-	iforce->device_memory.flags = IORESOURCE_MEM;
-	iforce->device_memory.parent = NULL;
-	iforce->device_memory.child = NULL;
-	iforce->device_memory.sibling = NULL;
-
-/*
- * Wait until device ready - until it sends its first response.
- */
-
-	for (i = 0; i < 20; i++)
-		if (!get_id_packet(iforce, "O"))
-			break;
-
-	if (i == 20) { /* 5 seconds */
-		printk(KERN_ERR "iforce.c: Timeout waiting for response from device.\n");
-		iforce_close(&iforce->dev);
-		return -1;
-	}
-
-/*
- * Get device info.
- */
-
-	if (!get_id_packet(iforce, "M"))
-		iforce->dev.idvendor = (iforce->edata[2] << 8) | iforce->edata[1];
-	if (!get_id_packet(iforce, "P"))
-		iforce->dev.idproduct = (iforce->edata[2] << 8) | iforce->edata[1];
-	if (!get_id_packet(iforce, "B"))
-		iforce->device_memory.end = (iforce->edata[2] << 8) | iforce->edata[1];
-	if (!get_id_packet(iforce, "N"))
-		iforce->dev.ff_effects_max = iforce->edata[1];
-
-/*
- * Display additional info.
- */
-
-	for (i = 0; c[i]; i++)
-		if (!get_id_packet(iforce, c + i))
-			dump_packet("info", iforce->ecmd, iforce->edata);
-
-/*
- * Disable spring, enable force feedback.
- * FIXME: We should use iforce_set_autocenter() et al here.
- */
-
-	send_packet(iforce, FF_CMD_AUTOCENTER, "\004\000");
-	send_packet(iforce, FF_CMD_ENABLE, "\004");
-
-/*
- * Find appropriate device entry
- */
-
-	for (i = 0; iforce_device[i].idvendor; i++)
-		if (iforce_device[i].idvendor == iforce->dev.idvendor &&
-		    iforce_device[i].idproduct == iforce->dev.idproduct)
-			break;
-
-	iforce->type = iforce_device + i;
-
-	sprintf(iforce->name, iforce->type->name,
-		iforce->dev.idproduct, iforce->dev.idvendor);
-
-/*
- * Set input device bitfields and ranges.
- */
-
-	iforce->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS) | BIT(EV_FF);
-
-	for (i = 0; iforce->type->btn[i] >= 0; i++) {
-		signed short t = iforce->type->btn[i];
-		set_bit(t, iforce->dev.keybit);
-		if (t != BTN_DEAD)
-			set_bit(FF_BTN(t), iforce->dev.ffbit);
-	}
-
-	for (i = 0; iforce->type->abs[i] >= 0; i++) {
-
-		signed short t = iforce->type->abs[i];
-		set_bit(t, iforce->dev.absbit);
-
-		switch (t) {
-
-			case ABS_X:
-			case ABS_Y:
-			case ABS_WHEEL:
-
-				iforce->dev.absmax[t] =  1920;
-				iforce->dev.absmin[t] = -1920;
-				iforce->dev.absflat[t] = 128;
-				iforce->dev.absfuzz[t] = 16;
-
-				set_bit(FF_ABS(t), iforce->dev.ffbit);
-				break;
-
-			case ABS_THROTTLE:
-			case ABS_GAS:
-			case ABS_BRAKE:
-
-				iforce->dev.absmax[t] = 255;
-				iforce->dev.absmin[t] = 0;
-				break;
-
-			case ABS_HAT0X:
-			case ABS_HAT0Y:
-				iforce->dev.absmax[t] =  1;
-				iforce->dev.absmin[t] = -1;
-				break;
-		}
-	}
-
-	for (i = 0; iforce->type->ff[i] >= 0; i++)
-		set_bit(iforce->type->ff[i], iforce->dev.ffbit);
-
-/*
- * Register input device.
- */
-
-	input_register_device(&iforce->dev);
-
-	return 0;
-}
-
-#ifdef IFORCE_USB
-
-static void iforce_usb_irq(struct urb *urb)
-{
-	struct iforce *iforce = urb->context;
-	if (urb->status) return;
-	iforce_process_packet(iforce,
-		(iforce->data[0] << 8) | (urb->actual_length - 1), iforce->data + 1);
-}
-
-static void iforce_usb_out(struct urb *urb)
-{
-	struct iforce *iforce = urb->context;
-	if (urb->status) return;
-	if (waitqueue_active(&iforce->wait))
-		wake_up(&iforce->wait);
-}
-
-static void iforce_usb_ctrl(struct urb *urb)
-{
-	struct iforce *iforce = urb->context;
-	if (urb->status) return;
-	iforce->ecmd = 0xff00 | urb->actual_length;
-	if (waitqueue_active(&iforce->wait))
-		wake_up(&iforce->wait);
-}
-
-static void *iforce_usb_probe(struct usb_device *dev, unsigned int ifnum,
-				const struct usb_device_id *id)
-{
-	struct usb_endpoint_descriptor *epirq, *epout;
-	struct iforce *iforce;
-
-	epirq = dev->config[0].interface[ifnum].altsetting[0].endpoint + 0;
-	epout = dev->config[0].interface[ifnum].altsetting[0].endpoint + 1;
-
-	if (!(iforce = kmalloc(sizeof(struct iforce) + 32, GFP_KERNEL))) return NULL;
-	memset(iforce, 0, sizeof(struct iforce));
-
-	iforce->bus = IFORCE_USB;
-	iforce->usbdev = dev;
-
-	iforce->dr.bRequestType = USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_INTERFACE;
-	iforce->dr.wIndex = 0;
-	iforce->dr.wLength = 16;
-
-	FILL_INT_URB(&iforce->irq, dev, usb_rcvintpipe(dev, epirq->bEndpointAddress),
-			iforce->data, 16, iforce_usb_irq, iforce, epirq->bInterval);
-
-	FILL_BULK_URB(&iforce->out, dev, usb_sndbulkpipe(dev, epout->bEndpointAddress),
-			iforce + 1, 32, iforce_usb_out, iforce);
-
-	FILL_CONTROL_URB(&iforce->ctrl, dev, usb_rcvctrlpipe(dev, 0),
-			(void*) &iforce->dr, iforce->edata, 16, iforce_usb_ctrl, iforce);
-
-	if (iforce_init_device(iforce)) {
-		kfree(iforce);
-		return NULL;
-	}
-
-	printk(KERN_INFO "input%d: %s [%d effects, %ld bytes memory] on usb%d:%d.%d\n",
-		iforce->dev.number, iforce->dev.name, iforce->dev.ff_effects_max,
-		iforce->device_memory.end, dev->bus->busnum, dev->devnum, ifnum);
-
-	return iforce;
-}
-
-static void iforce_usb_disconnect(struct usb_device *dev, void *ptr)
-{
-	struct iforce *iforce = ptr;
-	usb_unlink_urb(&iforce->irq);
-	input_unregister_device(&iforce->dev);
-	kfree(iforce);
-}
-
-static struct usb_device_id iforce_usb_ids [] = {
-	{ USB_DEVICE(0x046d, 0xc281) },		/* Logitech WingMan Force */
-	{ USB_DEVICE(0x046d, 0xc291) },		/* Logitech WingMan Formula Force */
-	{ USB_DEVICE(0x05ef, 0x020a) },		/* AVB Top Shot Pegasus */
-	{ USB_DEVICE(0x05ef, 0x8884) },		/* AVB Mag Turbo Force */
-	{ USB_DEVICE(0x06f8, 0x0001) },		/* Guillemot Race Leader Force Feedback */
-	{ }					/* Terminating entry */
-};
-
-MODULE_DEVICE_TABLE (usb, iforce_usb_ids);
-
-static struct usb_driver iforce_usb_driver = {
-	name:		"iforce",
-	probe:		iforce_usb_probe,
-	disconnect:	iforce_usb_disconnect,
-	id_table:	iforce_usb_ids,
-};
-
-#endif
-
-#ifdef IFORCE_232
-
-static void iforce_serio_irq(struct serio *serio, unsigned char data, unsigned int flags)
-{
-	struct iforce* iforce = serio->private;
-
-	if (!iforce->pkt) {
-		if (data != 0x2b) {
-			return;
-		}
-		iforce->pkt = 1;
-		return;
-	}
-
-	if (!iforce->id) {
-		if (data > 3 && data != 0xff) {
-			iforce->pkt = 0;
-			return;
-		}
-		iforce->id = data;
-		return;
-	}
-
-	if (!iforce->len) {
-		if (data > IFORCE_MAX_LENGTH) {
-			iforce->pkt = 0;
-			iforce->id = 0;
-			return;
-		}
-		iforce->len = data;
-		return;
-	}
-
-	if (iforce->idx < iforce->len) {
-		iforce->csum += iforce->data[iforce->idx++] = data;
-		return;
-	}
-
-	if (iforce->idx == iforce->len) {
-		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data);
-		iforce->pkt = 0;
-		iforce->id  = 0;
-		iforce->len = 0;
-		iforce->idx = 0;
-		iforce->csum = 0;
-	}
-}
-
-static void iforce_serio_connect(struct serio *serio, struct serio_dev *dev)
-{
-	struct iforce *iforce;
-	if (serio->type != (SERIO_RS232 | SERIO_IFORCE))
-		return;
-
-	if (!(iforce = kmalloc(sizeof(struct iforce), GFP_KERNEL))) return;
-	memset(iforce, 0, sizeof(struct iforce));
-
-	iforce->bus = IFORCE_232;
-	iforce->serio = serio;
-	serio->private = iforce;
-
-	if (serio_open(serio, dev)) {
-		kfree(iforce);
-		return;
-	}
-
-	if (iforce_init_device(iforce)) {
-		serio_close(serio);
-		kfree(iforce);
-		return;
-	}
-
-	printk(KERN_INFO "input%d: %s [%d effects, %ld bytes memory] on serio%d\n",
-		iforce->dev.number, iforce->dev.name, iforce->dev.ff_effects_max,
-		iforce->device_memory.end, serio->number);
-}
-
-static void iforce_serio_disconnect(struct serio *serio)
-{
-	struct iforce* iforce = serio->private;
-
-	input_unregister_device(&iforce->dev);
-	serio_close(serio);
-	kfree(iforce);
-}
-
-static struct serio_dev iforce_serio_dev = {
-	interrupt:	iforce_serio_irq,
-	connect:	iforce_serio_connect,
-	disconnect:	iforce_serio_disconnect,
-};
-
-#endif
-
-static int __init iforce_init(void)
-{
-#ifdef IFORCE_USB
-	usb_register(&iforce_usb_driver);
-#endif
-#ifdef IFORCE_232
-	serio_register_device(&iforce_serio_dev);
-#endif
-	return 0;
-}
-
-static void __exit iforce_exit(void)
-{
-#ifdef IFORCE_USB
-	usb_deregister(&iforce_usb_driver);
-#endif
-#ifdef IFORCE_232
-	serio_unregister_device(&iforce_serio_dev);
-#endif
-}
-
-module_init(iforce_init);
-module_exit(iforce_exit);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/interact.c linux-modified/drivers/char/joystick/interact.c
--- linux-vanilla/drivers/char/joystick/interact.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/interact.c	Mon Jan  6 16:48:20 2003
@@ -270,8 +270,8 @@
 		set_bit(t, interact->dev.keybit);
 
 	input_register_device(&interact->dev);
-	printk(KERN_INFO "input%d: %s on gameport%d.0\n",
-		interact->dev.number, interact_type[interact->type].name, gameport->number);
+	printk(KERN_INFO "input: %s on gameport%d.0\n",
+		interact_type[interact->type].name, gameport->number);
 
 	return;
 fail2:	gameport_close(gameport);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/magellan.c linux-modified/drivers/char/joystick/magellan.c
--- linux-vanilla/drivers/char/joystick/magellan.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/magellan.c	Mon Jan  6 16:48:20 2003
@@ -178,7 +178,7 @@
 
 	input_register_device(&magellan->dev);
 
-	printk(KERN_INFO "input%d: %s on serio%d\n", magellan->dev.number, magellan_name, serio->number);
+	printk(KERN_INFO "input: %s on serio %s\n", magellan_name, serio->name);
 }
 
 /*
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/serio.c linux-modified/drivers/char/joystick/serio.c
--- linux-vanilla/drivers/char/joystick/serio.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/serio.c	Mon Jan  6 16:48:20 2003
@@ -1,9 +1,7 @@
 /*
- * $Id$
+ * $Id$
  *
- *  Copyright (c) 1999-2000 Vojtech Pavlik
- *
- *  Sponsored by SuSE
+ *  Copyright (c) 1999-2001 Vojtech Pavlik
  */
 
 /*
@@ -27,14 +25,16 @@
  * 
  * Should you need to contact me, the author, you can do so either by
  * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <linux/stddef.h>
 #include <linux/module.h>
 #include <linux/serio.h>
+#include <linux/errno.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Serio abstraction core");
 MODULE_LICENSE("GPL");
 
 EXPORT_SYMBOL(serio_register_port);
@@ -47,7 +47,6 @@
 
 static struct serio *serio_list;
 static struct serio_dev *serio_dev;
-static int serio_number;
 
 static void serio_find_dev(struct serio *serio)
 {
@@ -69,7 +68,6 @@
 
 void serio_register_port(struct serio *serio)
 {
-	serio->number = serio_number++;
 	serio->next = serio_list;	
 	serio_list = serio;
 	serio_find_dev(serio);
@@ -84,8 +82,6 @@
 
 	if (serio->dev && serio->dev->disconnect)
 		serio->dev->disconnect(serio);
-
-	serio_number--;
 }
 
 void serio_register_device(struct serio_dev *dev)
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/serport.c linux-modified/drivers/char/joystick/serport.c
--- linux-vanilla/drivers/char/joystick/serport.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/serport.c	Mon Jan  6 16:48:20 2003
@@ -1,9 +1,7 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2001 Vojtech Pavlik
- *
- *  Sponsored by SuSE
  */
 
 /*
@@ -28,7 +26,7 @@
  * 
  *  Should you need to contact me, the author, you can do so either by
  * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <asm/uaccess.h>
@@ -39,12 +37,19 @@
 #include <linux/serio.h>
 #include <linux/tty.h>
 
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Input device TTY line discipline");
+MODULE_LICENSE("GPL");
+
 struct serport {
 	struct tty_struct *tty;
 	wait_queue_head_t wait;
 	struct serio serio;
+	char phys[32];
 };
 
+char serport_name[] = "Serial port";
+
 /*
  * Callback functions from the serio code.
  */
@@ -75,6 +80,8 @@
 static int serport_ldisc_open(struct tty_struct *tty)
 {
 	struct serport *serport;
+	char ttyname[64];
+	int i;
 
 	MOD_INC_USE_COUNT;
 
@@ -85,9 +92,19 @@
 
 	memset(serport, 0, sizeof(struct serport));
 
+	set_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
 	serport->tty = tty;
 	tty->disc_data = serport;
 
+	strcpy(ttyname, tty->driver.name);
+	for (i = 0; ttyname[i] != 0 && ttyname[i] != '/'; i++);
+	ttyname[i] = 0;
+
+	sprintf(serport->phys, "%s%d/serio0", ttyname, MINOR(tty->device) - tty->driver.minor_start);
+
+	serport->serio.name = serport_name;
+	serport->serio.phys = serport->phys;
+
 	serport->serio.type = SERIO_RS232;
 	serport->serio.write = serport_serio_write;
 	serport->serio.open = serport_serio_open;
@@ -156,14 +173,14 @@
 
 	serio_register_port(&serport->serio);
 
-	printk(KERN_INFO "serio%d: Serial port %s\n", serport->serio.number, name);
+	printk(KERN_INFO "serio: Serial port %s\n", name);
 
 	add_wait_queue(&serport->wait, &wait);
-	current->state = TASK_INTERRUPTIBLE;
+	set_current_state(TASK_INTERRUPTIBLE);
 
 	while(serport->serio.type && !signal_pending(current)) schedule();
 
-	current->state = TASK_RUNNING;
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&serport->wait, &wait);
 
 	serio_unregister_port(&serport->serio);
@@ -187,6 +204,14 @@
 	return -EINVAL;
 }
 
+static void serport_ldisc_write_wakeup(struct tty_struct * tty)
+{
+	struct serport *sp = (struct serport *) tty->disc_data;
+
+	serio_dev_write_wakeup(&sp->serio);
+
+}
+
 /*
  * The line discipline structure.
  */
@@ -199,6 +224,7 @@
 	ioctl:		serport_ldisc_ioctl,
 	receive_buf:	serport_ldisc_receive,
 	receive_room:	serport_ldisc_room,
+	write_wakeup:	serport_ldisc_write_wakeup
 };
 
 /*
@@ -222,5 +248,3 @@
 
 module_init(serport_init);
 module_exit(serport_exit);
-
-MODULE_LICENSE("GPL");
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/sidewinder.c linux-modified/drivers/char/joystick/sidewinder.c
--- linux-vanilla/drivers/char/joystick/sidewinder.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/sidewinder.c	Mon Jan  6 16:48:20 2003
@@ -719,8 +719,8 @@
 			set_bit(code, sw->dev[i].keybit);
 
 		input_register_device(sw->dev + i);
-		printk(KERN_INFO "input%d: %s%s on gameport%d.%d [%d-bit id %d data %d]\n",
-			sw->dev[i].number, sw->name, comment, gameport->number, i, m, l, k);
+		printk(KERN_INFO "input: %s%s on gameport%d.%d [%d-bit id %d data %d]\n",
+			sw->name, comment, gameport->number, i, m, l, k);
 	}
 
 	return;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/spaceball.c linux-modified/drivers/char/joystick/spaceball.c
--- linux-vanilla/drivers/char/joystick/spaceball.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/spaceball.c	Mon Jan  6 16:48:20 2003
@@ -81,8 +81,8 @@
 		case '@':					/* Reset packet */
 			spaceball->data[spaceball->idx - 1] = 0;
 			for (i = 1; i < spaceball->idx && spaceball->data[i] == ' '; i++);
-			printk(KERN_INFO "input%d: %s [%s] on serio%d\n",
-				spaceball->dev.number, spaceball_name, spaceball->data + i, spaceball->serio->number);
+			printk(KERN_INFO "input: %s [%s] on serio %s\n",
+				spaceball_name, spaceball->data + i, spaceball->serio->name);
 			break;
 
 		case 'D':					/* Ball data */
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/spaceorb.c linux-modified/drivers/char/joystick/spaceorb.c
--- linux-vanilla/drivers/char/joystick/spaceorb.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/spaceorb.c	Mon Jan  6 16:48:20 2003
@@ -88,8 +88,8 @@
 		case 'R':				/* Reset packet */
 			spaceorb->data[spaceorb->idx - 1] = 0;
 			for (i = 1; i < spaceorb->idx && spaceorb->data[i] == ' '; i++);
-			printk(KERN_INFO "input%d: %s [%s] on serio%d\n",
-				 spaceorb->dev.number, spaceorb_name, spaceorb->data + i, spaceorb->serio->number);
+			printk(KERN_INFO "input: %s [%s] on serio %s\n",
+				 spaceorb_name, spaceorb->data + i, spaceorb->serio->name);
 			break;
 
 		case 'D':				/* Ball + button data */
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/stinger.c linux-modified/drivers/char/joystick/stinger.c
--- linux-vanilla/drivers/char/joystick/stinger.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/stinger.c	Mon Jan  6 16:48:20 2003
@@ -168,7 +168,7 @@
 
 	input_register_device(&stinger->dev);
 
-	printk(KERN_INFO "input%d: %s on serio%d\n", stinger->dev.number, stinger_name, serio->number);
+	printk(KERN_INFO "input: %s on serio %s\n", stinger_name, serio->name);
 }
 
 /*
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/tmdc.c linux-modified/drivers/char/joystick/tmdc.c
--- linux-vanilla/drivers/char/joystick/tmdc.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/tmdc.c	Mon Jan  6 16:48:20 2003
@@ -336,8 +336,8 @@
 			}
 
 			input_register_device(tmdc->dev + j);
-			printk(KERN_INFO "input%d: %s on gameport%d.%d\n",
-				tmdc->dev[j].number, tmdc->name[j], gameport->number, j);
+			printk(KERN_INFO "input: %s on gameport%d.%d\n",
+				tmdc->name[j], gameport->number, j);
 		}
 
 	return;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/turbografx.c linux-modified/drivers/char/joystick/turbografx.c
--- linux-vanilla/drivers/char/joystick/turbografx.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/turbografx.c	Mon Jan  6 16:48:20 2003
@@ -190,8 +190,8 @@
 			tgfx->dev[i].absmin[ABS_Y] = -1; tgfx->dev[i].absmax[ABS_Y] = 1;
 
 			input_register_device(tgfx->dev + i);
-			printk(KERN_INFO "input%d: %d-button Multisystem joystick on %s\n",
-				tgfx->dev[i].number, config[i+1], tgfx->pd->port->name);
+			printk(KERN_INFO "input: %d-button Multisystem joystick on %s\n",
+				config[i+1], tgfx->pd->port->name);
 		}
 
         if (!tgfx->sticks) {
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/char/joystick/warrior.c linux-modified/drivers/char/joystick/warrior.c
--- linux-vanilla/drivers/char/joystick/warrior.c	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/char/joystick/warrior.c	Mon Jan  6 16:48:20 2003
@@ -180,7 +180,7 @@
 
 	input_register_device(&warrior->dev);
 
-	printk(KERN_INFO "input%d: Logitech WingMan Warrior on serio%d\n", warrior->dev.number, serio->number);
+	printk(KERN_INFO "input: Logitech WingMan Warrior on serio %s\n", serio->name);
 }
 
 /*
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/input/evdev.c linux-modified/drivers/input/evdev.c
--- linux-vanilla/drivers/input/evdev.c	Mon Feb 25 21:37:58 2002
+++ linux-modified/drivers/input/evdev.c	Mon Jan  6 16:48:20 2003
@@ -1,11 +1,9 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2001 Vojtech Pavlik
  *
  *  Event char devices, giving access to raw input device events.
- *
- *  Sponsored by SuSE
  */
 
 /*
@@ -24,8 +22,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #define EVDEV_MINOR_BASE	64
@@ -43,6 +41,7 @@
 	int exist;
 	int open;
 	int minor;
+	char name[16];
 	struct input_handle handle;
 	wait_queue_head_t wait;
 	devfs_handle_t devfs;
@@ -89,12 +88,20 @@
 	return retval < 0 ? retval : 0;
 }
 
+static int evdev_flush(struct file * file)
+{
+	struct evdev_list *list = (struct evdev_list*)file->private_data;
+	
+	if (!list->evdev->exist) return -ENODEV;
+
+	return input_flush_device(&list->evdev->handle, file);
+}
+
 static int evdev_release(struct inode * inode, struct file * file)
 {
 	struct evdev_list *list = file->private_data;
 	struct evdev_list **listptr;
 
-	lock_kernel();
 	listptr = &list->evdev->list;
 	evdev_fasync(-1, file, 0);
 
@@ -113,8 +120,7 @@
 	}
 
 	kfree(list);
-	unlock_kernel();
-
+	
 	return 0;
 }
 
@@ -122,10 +128,16 @@
 {
 	struct evdev_list *list;
 	int i = MINOR(inode->i_rdev) - EVDEV_MINOR_BASE;
+	int accept_err;
 
 	if (i >= EVDEV_MINORS || !evdev_table[i])
 		return -ENODEV;
 
+	/* Ask the driver if he wishes to accept the open() */
+	if ((accept_err = input_accept_process(&(evdev_table[i]->handle), file))) {
+		return accept_err;
+	}
+
 	if (!(list = kmalloc(sizeof(struct evdev_list), GFP_KERNEL)))
 		return -ENOMEM;
 	memset(list, 0, sizeof(struct evdev_list));
@@ -149,6 +161,8 @@
 	struct input_event event;
 	int retval = 0;
 
+	if (!list->evdev->exist) return -ENODEV;
+
 	while (retval < count) {
 
 		if (copy_from_user(&event, buffer + retval, sizeof(struct input_event)))
@@ -169,7 +183,7 @@
 	if (list->head == list->tail) {
 
 		add_wait_queue(&list->evdev->wait, &wait);
-		current->state = TASK_INTERRUPTIBLE;
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		while (list->head == list->tail) {
 
@@ -189,7 +203,7 @@
 			schedule();
 		}
 
-		current->state = TASK_RUNNING;
+		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&list->evdev->wait, &wait);
 	}
 
@@ -221,7 +235,9 @@
 	struct evdev_list *list = file->private_data;
 	struct evdev *evdev = list->evdev;
 	struct input_dev *dev = evdev->handle.dev;
-	int retval;
+	int retval, t, u;
+
+	if (!evdev->exist) return -ENODEV;
 
 	switch (cmd) {
 
@@ -234,6 +250,40 @@
 			if ((retval = put_user(dev->idproduct, ((short *) arg) + 2))) return retval;
 			if ((retval = put_user(dev->idversion, ((short *) arg) + 3))) return retval;
 			return 0;
+		
+		case EVIOCGREP:
+			if ((retval = put_user(dev->rep[0], ((int *) arg) + 0))) return retval;
+			if ((retval = put_user(dev->rep[1], ((int *) arg) + 1))) return retval;
+			return 0;
+
+		case EVIOCSREP:
+			if ((retval = get_user(dev->rep[0], ((int *) arg) + 0))) return retval;
+			if ((retval = get_user(dev->rep[1], ((int *) arg) + 1))) return retval;
+			return 0;
+
+		case EVIOCGKEYCODE:
+			if ((retval = get_user(t, ((int *) arg) + 0))) return retval;
+			if (t < 0 || t > dev->keycodemax) return -EINVAL;
+			switch (dev->keycodesize) {
+				case 1: u = *(u8*)(dev->keycode + t); break;
+				case 2: u = *(u16*)(dev->keycode + t * 2); break;
+				case 4: u = *(u32*)(dev->keycode + t * 4); break;
+				default: return -EINVAL;
+			}
+			if ((retval = put_user(u, ((int *) arg) + 1))) return retval;
+			return 0;
+
+		case EVIOCSKEYCODE:
+			if ((retval = get_user(t, ((int *) arg) + 0))) return retval;
+			if (t < 0 || t > dev->keycodemax) return -EINVAL;
+			if ((retval = get_user(u, ((int *) arg) + 1))) return retval;
+			switch (dev->keycodesize) {
+				case 1: *(u8*)(dev->keycode + t) = u; break;
+				case 2: *(u16*)(dev->keycode + t * 2) = u; break;
+				case 4: *(u32*)(dev->keycode + t * 4) = u; break;
+				default: return -EINVAL;
+			}
+			return 0;
 
 		case EVIOCSFF:
 			if (dev->upload_effect) {
@@ -282,22 +332,55 @@
 					default: return -EINVAL;
 				}
 				len = NBITS(len) * sizeof(long);
-				if (len > _IOC_SIZE(cmd)) {
-					printk(KERN_WARNING "evdev.c: Truncating bitfield length from %d to %d\n",
-						len, _IOC_SIZE(cmd));
-					len = _IOC_SIZE(cmd);
-				}
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
 				return copy_to_user((char *) arg, bits, len) ? -EFAULT : len;
 			}
 
+			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGKEY(0))) {
+				int len;
+				len = NBITS(KEY_MAX) * sizeof(long);
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				return copy_to_user((char *) arg, dev->key, len) ? -EFAULT : len;
+			}
+
+			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGLED(0))) {
+				int len;
+				len = NBITS(LED_MAX) * sizeof(long);
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				return copy_to_user((char *) arg, dev->led, len) ? -EFAULT : len;
+			}
+
+			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGSND(0))) {
+				int len;
+				len = NBITS(SND_MAX) * sizeof(long);
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				return copy_to_user((char *) arg, dev->snd, len) ? -EFAULT : len;
+			}
+
 			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGNAME(0))) {
 				int len;
-				if (!dev->name) return 0;
+				if (!dev->name) return -ENOENT;
 				len = strlen(dev->name) + 1;
 				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
 				return copy_to_user((char *) arg, dev->name, len) ? -EFAULT : len;
 			}
 
+			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGPHYS(0))) {
+				int len;
+				if (!dev->phys) return -ENOENT;
+				len = strlen(dev->phys) + 1;
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				return copy_to_user((char *) arg, dev->phys, len) ? -EFAULT : len;
+			}
+
+			if (_IOC_NR(cmd) == _IOC_NR(EVIOCGUNIQ(0))) {
+				int len;
+				if (!dev->uniq) return -ENOENT;
+				len = strlen(dev->uniq) + 1;
+				if (len > _IOC_SIZE(cmd)) len = _IOC_SIZE(cmd);
+				return copy_to_user((char *) arg, dev->uniq, len) ? -EFAULT : len;
+			}
+
 			if ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCGABS(0))) {
 
 				int t = _IOC_NR(cmd) & ABS_MAX;
@@ -323,9 +406,10 @@
 	release:	evdev_release,
 	ioctl:		evdev_ioctl,
 	fasync:		evdev_fasync,
+	flush:		evdev_flush
 };
 
-static struct input_handle *evdev_connect(struct input_handler *handler, struct input_dev *dev)
+static struct input_handle *evdev_connect(struct input_handler *handler, struct input_dev *dev, struct input_device_id *id)
 {
 	struct evdev *evdev;
 	int minor;
@@ -344,16 +428,17 @@
 
 	evdev->minor = minor;
 	evdev_table[minor] = evdev;
+	
+	sprintf(evdev->name, "event%d", minor);
 
 	evdev->handle.dev = dev;
+	evdev->handle.name = evdev->name;
 	evdev->handle.handler = handler;
 	evdev->handle.private = evdev;
 
-	evdev->exist = 1;
-
 	evdev->devfs = input_register_minor("event%d", minor, EVDEV_MINOR_BASE);
 
-//	printk(KERN_INFO "event%d: Event device for input%d\n", minor, dev->number);
+	evdev->exist = 1;
 
 	return &evdev->handle;
 }
@@ -374,12 +459,21 @@
 	}
 }
 
+static struct input_device_id evdev_ids[] = {
+	{ driver_info: 1 },	/* Matches all devices */
+	{ },			/* Terminating zero entry */
+};
+
+MODULE_DEVICE_TABLE(input, evdev_ids);
+
 static struct input_handler evdev_handler = {
 	event:		evdev_event,
 	connect:	evdev_connect,
 	disconnect:	evdev_disconnect,
 	fops:		&evdev_fops,
 	minor:		EVDEV_MINOR_BASE,
+	name:		"evdev",
+	id_table:	evdev_ids,
 };
 
 static int __init evdev_init(void)
@@ -396,7 +490,6 @@
 module_init(evdev_init);
 module_exit(evdev_exit);
 
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
-MODULE_DESCRIPTION("Event character device driver");
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Input driver event char devices");
 MODULE_LICENSE("GPL");
-
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/input/input.c linux-modified/drivers/input/input.c
--- linux-vanilla/drivers/input/input.c	Mon Jan  6 15:58:02 2003
+++ linux-modified/drivers/input/input.c	Mon Jan  6 16:48:20 2003
@@ -1,11 +1,9 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2001 Vojtech Pavlik
  *
- *  The input layer module itself
- *
- *  Sponsored by SuSE
+ *  The input core
  */
 
 /*
@@ -24,8 +22,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  * 
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <linux/init.h>
@@ -34,12 +32,16 @@
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/random.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+#include <linux/kmod.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
 
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
-MODULE_DESCRIPTION("Input layer module");
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Input core");
 MODULE_LICENSE("GPL");
 
-
 EXPORT_SYMBOL(input_register_device);
 EXPORT_SYMBOL(input_unregister_device);
 EXPORT_SYMBOL(input_register_handler);
@@ -48,6 +50,8 @@
 EXPORT_SYMBOL(input_unregister_minor);
 EXPORT_SYMBOL(input_open_device);
 EXPORT_SYMBOL(input_close_device);
+EXPORT_SYMBOL(input_accept_process);
+EXPORT_SYMBOL(input_flush_device);
 EXPORT_SYMBOL(input_event);
 
 #define INPUT_MAJOR	13
@@ -57,20 +61,32 @@
 static struct input_handler *input_handler;
 static struct input_handler *input_table[8];
 static devfs_handle_t input_devfs_handle;
-static int input_number;
-static long input_devices[NBITS(INPUT_DEVICES)];
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_bus_input_dir;
+DECLARE_WAIT_QUEUE_HEAD(input_devices_poll_wait);
+static int input_devices_state;
+#endif
 
 void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
 	struct input_handle *handle = dev->handle;
 
 /*
+ * Wake up the device if it is sleeping.
+ */
+	if (dev->pm_dev)
+		pm_access(dev->pm_dev);
+
+/*
  * Filter non-events, and bad input values out.
  */
 
 	if (type > EV_MAX || !test_bit(type, dev->evbit))
 		return;
 
+	add_mouse_randomness((type << 4) ^ code ^ (code >> 4) ^ value);
+
 	switch (type) {
 
 		case EV_KEY:
@@ -187,16 +203,36 @@
 	mod_timer(&dev->timer, jiffies + dev->rep[REP_PERIOD]);
 }
 
+int input_accept_process(struct input_handle *handle, struct file *file)
+{
+	if (handle->dev->accept)
+		return handle->dev->accept(handle->dev, file);
+
+	return 0;
+}
+
 int input_open_device(struct input_handle *handle)
 {
+	if (handle->dev->pm_dev)
+		pm_access(handle->dev->pm_dev);
 	handle->open++;
 	if (handle->dev->open)
 		return handle->dev->open(handle->dev);
 	return 0;
 }
 
+int input_flush_device(struct input_handle* handle, struct file* file)
+{
+	if (handle->dev->flush)
+		return handle->dev->flush(handle->dev, file);
+
+	return 0;
+}
+
 void input_close_device(struct input_handle *handle)
 {
+	if (handle->dev->pm_dev)
+		pm_dev_idle(handle->dev->pm_dev);
 	if (handle->dev->close)
 		handle->dev->close(handle->dev);
 	handle->open--;
@@ -210,25 +246,197 @@
 	handle->handler->handle = handle;
 }
 
+/**
+ *     input_find_and_remove - Find and remove node
+ *
+ *     @type:          data type
+ *     @initval:       initial value
+ *     @targ:          node to find
+ *     @next:          next node in the list
+ *
+ *     Searches the linked list for the target node @targ. If the node
+ *     is found, it is removed from the list.
+ *
+ *     If the node is not found, the end of the list will be hit,
+ *     indicating that it wasn't in the list to begin with.
+ *
+ *     Returns nothing.
+ */
+#define input_find_and_remove(type, initval, targ, next)		\
+	do {								\
+		type **ptr;						\
+		for (ptr = &initval; *ptr; ptr = &((*ptr)->next))	\
+			if (*ptr == targ) break;			\
+		if (*ptr) *ptr = (*ptr)->next;				\
+	} while (0)
+
 static void input_unlink_handle(struct input_handle *handle)
 {
-	struct input_handle **handleptr;
+	input_find_and_remove(struct input_handle, handle->dev->handle, handle, dnext);
+        input_find_and_remove(struct input_handle, handle->handler->handle, handle, hnext);
+}
+
+#define MATCH_BIT(bit, max) \
+		for (i = 0; i < NBITS(max); i++) \
+			if ((id->bit[i] & dev->bit[i]) != id->bit[i]) \
+				break; \
+		if (i != NBITS(max)) \
+			continue;
+
+static struct input_device_id *input_match_device(struct input_device_id *id, struct input_dev *dev)
+{
+	int i;
+
+	for (; id->flags || id->driver_info; id++) {
+
+		if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
+			if (id->idbus != dev->idbus)
+				continue;
 
-	handleptr = &handle->dev->handle;
-	while (*handleptr && (*handleptr != handle))
-		handleptr = &((*handleptr)->dnext);
-	*handleptr = (*handleptr)->dnext;
-
-	handleptr = &handle->handler->handle;
-	while (*handleptr && (*handleptr != handle))
-		handleptr = &((*handleptr)->hnext);
-	*handleptr = (*handleptr)->hnext;
+		if (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)
+			if (id->idvendor != dev->idvendor)
+				continue;
+	
+		if (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)
+			if (id->idproduct != dev->idproduct)
+				continue;
+		
+		if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
+			if (id->idversion != dev->idversion)
+				continue;
+
+		MATCH_BIT(evbit,  EV_MAX);
+		MATCH_BIT(keybit, KEY_MAX);
+		MATCH_BIT(relbit, REL_MAX);
+		MATCH_BIT(absbit, ABS_MAX);
+		MATCH_BIT(mscbit, MSC_MAX);
+		MATCH_BIT(ledbit, LED_MAX);
+		MATCH_BIT(sndbit, SND_MAX);
+		MATCH_BIT(ffbit,  FF_MAX);
+
+		return id;
+	}
+
+	return NULL;
 }
 
+/*
+ * Input hotplugging interface - loading event handlers based on
+ * device bitfields.
+ */
+
+#ifdef CONFIG_HOTPLUG
+
+/*
+ * Input hotplugging invokes what /proc/sys/kernel/hotplug says
+ * (normally /sbin/hotplug) when input devices get added or removed.
+ *
+ * This invokes a user mode policy agent, typically helping to load driver
+ * or other modules, configure the device, and more.  Drivers can provide
+ * a MODULE_DEVICE_TABLE to help with module loading subtasks.
+ *
+ */
+
+#define SPRINTF_BIT_A(bit, name, max) \
+	do { \
+		envp[i++] = scratch; \
+		scratch += sprintf(scratch, name); \
+		for (j = NBITS(max) - 1; j >= 0; j--) \
+			if (dev->bit[j]) break; \
+		for (; j >= 0; j--) \
+			scratch += sprintf(scratch, "%lx ", dev->bit[j]); \
+		scratch++; \
+	} while (0)
+
+#define SPRINTF_BIT_A2(bit, name, max, ev) \
+	do { \
+		if (test_bit(ev, dev->evbit)) \
+			SPRINTF_BIT_A(bit, name, max); \
+	} while (0)
+
+static void input_call_hotplug(char *verb, struct input_dev *dev)
+{
+	char *argv[3], **envp, *buf, *scratch;
+	int i = 0, j, value;
+
+	if (!hotplug_path[0]) {
+		printk(KERN_ERR "input.c: calling hotplug a hotplug agent defined\n");
+		return;
+	}
+	if (in_interrupt()) {
+		printk(KERN_ERR "input.c: calling hotplug from interrupt\n");
+		return; 
+	}
+	if (!current->fs->root) {
+		printk(KERN_WARNING "input.c: calling hotplug without valid filesystem\n");
+		return; 
+	}
+	if (!(envp = (char **) kmalloc(20 * sizeof(char *), GFP_KERNEL))) {
+		printk(KERN_ERR "input.c: not enough memory allocating hotplug environment\n");
+		return;
+	}
+	if (!(buf = kmalloc(1024, GFP_KERNEL))) {
+		kfree (envp);
+		printk(KERN_ERR "input.c: not enough memory allocating hotplug environment\n");
+		return;
+	}
+
+	argv[0] = hotplug_path;
+	argv[1] = "input";
+	argv[2] = 0;
+
+	envp[i++] = "HOME=/";
+	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+	scratch = buf;
+
+	envp[i++] = scratch;
+	scratch += sprintf(scratch, "ACTION=%s", verb) + 1;
+
+	envp[i++] = scratch;
+	scratch += sprintf(scratch, "PRODUCT=%x/%x/%x/%x",
+		dev->idbus, dev->idvendor, dev->idproduct, dev->idversion) + 1; 
+	
+	if (dev->name) {
+		envp[i++] = scratch;
+		scratch += sprintf(scratch, "NAME=%s", dev->name) + 1; 
+	}
+
+	if (dev->phys) {
+		envp[i++] = scratch;
+		scratch += sprintf(scratch, "PHYS=%s", dev->phys) + 1; 
+	}	
+
+	SPRINTF_BIT_A(evbit, "EV=", EV_MAX);
+	SPRINTF_BIT_A2(keybit, "KEY=", KEY_MAX, EV_KEY);
+	SPRINTF_BIT_A2(relbit, "REL=", REL_MAX, EV_REL);
+	SPRINTF_BIT_A2(absbit, "ABS=", ABS_MAX, EV_ABS);
+	SPRINTF_BIT_A2(mscbit, "MSC=", MSC_MAX, EV_MSC);
+	SPRINTF_BIT_A2(ledbit, "LED=", LED_MAX, EV_LED);
+	SPRINTF_BIT_A2(sndbit, "SND=", SND_MAX, EV_SND);
+	SPRINTF_BIT_A2(ffbit,  "FF=",  FF_MAX, EV_FF);
+
+	envp[i++] = 0;
+
+	printk(KERN_DEBUG "input.c: calling %s %s [%s %s %s %s %s]\n",
+		argv[0], argv[1], envp[0], envp[1], envp[2], envp[3], envp[4]);
+
+	value = call_usermodehelper(argv [0], argv, envp);
+
+	kfree(buf);
+	kfree(envp);
+
+	if (value != 0)
+		printk(KERN_WARNING "input.c: hotplug returned %d\n", value);
+}
+
+#endif
+
 void input_register_device(struct input_dev *dev)
 {
 	struct input_handler *handler = input_handler;
 	struct input_handle *handle;
+	struct input_device_id *id;
 
 /*
  * Initialize repeat timer to default values.
@@ -244,35 +452,70 @@
  * Add the device.
  */
 
-	if (input_number >= INPUT_DEVICES) {
-		printk(KERN_WARNING "input: ran out of input device numbers!\n");
-		dev->number = input_number;
-	} else {
-		dev->number = find_first_zero_bit(input_devices, INPUT_DEVICES);
-		set_bit(dev->number, input_devices);
-	}
-		
 	dev->next = input_dev;	
 	input_dev = dev;
-	input_number++;
 
 /*
  * Notify handlers.
  */
 
 	while (handler) {
-		if ((handle = handler->connect(handler, dev)))
-			input_link_handle(handle);
+		if ((id = input_match_device(handler->id_table, dev)))
+			if ((handle = handler->connect(handler, dev, id)))
+				input_link_handle(handle);
 		handler = handler->next;
 	}
+
+/*
+ * Notify the hotplug agent.
+ */
+
+#ifdef CONFIG_HOTPLUG
+	input_call_hotplug("add", dev);
+#endif
+
+/*
+ * Notify /proc.
+ */
+
+#ifdef CONFIG_PROC_FS
+	input_devices_state++;
+	wake_up(&input_devices_poll_wait);
+#endif
+}
+
+#define DUMP_ARRAY(n, array) \
+printk(KERN_DEBUG " ");\
+for (i=0; i<NBITS(n); ++i)\
+  printk("%0X ", array[i]);\
+printk("\n");
+
+void dump_id_table(struct input_device_id* id)
+{
+	int i;
+
+	printk(KERN_DEBUG "flags = %0X\n", id->flags);
+	if (id->flags & INPUT_DEVICE_ID_MATCH_EVBIT) {
+		DUMP_ARRAY(NBITS(EV_MAX), id->evbit);
+	}
+	if (id->flags & INPUT_DEVICE_ID_MATCH_KEYBIT) {
+		DUMP_ARRAY(NBITS(KEY_MAX), id->keybit);
+	}
 }
 
 void input_unregister_device(struct input_dev *dev)
 {
 	struct input_handle *handle = dev->handle;
-	struct input_dev **devptr = &input_dev;
 	struct input_handle *dnext;
 
+	if (!dev) return;
+
+/*
+ * Turn off power management for the device.
+ */
+	if (dev->pm_dev)
+		pm_unregister(dev->pm_dev);
+
 /*
  * Kill any pending repeat timers.
  */
@@ -291,23 +534,35 @@
 	}
 
 /*
- * Remove the device.
+ * Notify the hotplug agent.
  */
 
-	while (*devptr && (*devptr != dev))
-		devptr = &((*devptr)->next);
-	*devptr = (*devptr)->next;
+#ifdef CONFIG_HOTPLUG
+	input_call_hotplug("remove", dev);
+#endif
+
+/*
+ * Remove the device.
+ */
+	input_find_and_remove(struct input_dev, input_dev, dev, next);
 
-	input_number--;
+/*
+ * Notify /proc.
+ */
 
-	if (dev->number < INPUT_DEVICES)
-		clear_bit(dev->number, input_devices);
+#ifdef CONFIG_PROC_FS
+	input_devices_state++;
+	wake_up(&input_devices_poll_wait);
+#endif
 }
 
 void input_register_handler(struct input_handler *handler)
 {
 	struct input_dev *dev = input_dev;
 	struct input_handle *handle;
+	struct input_device_id *id;
+
+	if (!handler) return;
 
 /*
  * Add minors if needed.
@@ -326,17 +581,27 @@
 /*
  * Notify it about all existing devices.
  */
+//	dump_id_table(handler->id_table);
 
 	while (dev) {
-		if ((handle = handler->connect(handler, dev)))
-			input_link_handle(handle);
+		if ((id = input_match_device(handler->id_table, dev)))
+			if ((handle = handler->connect(handler, dev, id)))
+				input_link_handle(handle);
 		dev = dev->next;
 	}
+
+/*
+ * Notify /proc.
+ */
+
+#ifdef CONFIG_PROC_FS
+	input_devices_state++;
+	wake_up(&input_devices_poll_wait);
+#endif
 }
 
 void input_unregister_handler(struct input_handler *handler)
 {
-	struct input_handler **handlerptr = &input_handler;
 	struct input_handle *handle = handler->handle;
 	struct input_handle *hnext;
 
@@ -354,18 +619,23 @@
 /*
  * Remove it.
  */
-
-	while (*handlerptr && (*handlerptr != handler))
-		handlerptr = &((*handlerptr)->next);
-
-	*handlerptr = (*handlerptr)->next;
+	input_find_and_remove(struct input_handler, input_handler, handler,
+				next);
 
 /*
  * Remove minors.
  */
-
 	if (handler->fops != NULL)
 		input_table[handler->minor >> 5] = NULL;
+
+/*
+ * Notify /proc.
+ */
+
+#ifdef CONFIG_PROC_FS
+	input_devices_state++;
+	wake_up(&input_devices_poll_wait);
+#endif
 }
 
 static int input_open_file(struct inode *inode, struct file *file)
@@ -389,9 +659,7 @@
 	old_fops = file->f_op;
 	file->f_op = new_fops;
 
-	lock_kernel();
 	err = new_fops->open(inode, file);
-	unlock_kernel();
 
 	if (err) {
 		fops_put(file->f_op);
@@ -419,18 +687,164 @@
 	devfs_unregister(handle);
 }
 
+/*
+ * ProcFS interface for the input drivers.
+ */
+
+#ifdef CONFIG_PROC_FS
+
+#define SPRINTF_BIT_B(bit, name, max) \
+	do { \
+		len += sprintf(buf + len, "B: %s", name); \
+		for (i = NBITS(max) - 1; i >= 0; i--) \
+			if (dev->bit[i]) break; \
+		for (; i >= 0; i--) \
+			len += sprintf(buf + len, "%lx ", dev->bit[i]); \
+		len += sprintf(buf + len, "\n"); \
+	} while (0)
+
+#define SPRINTF_BIT_B2(bit, name, max, ev) \
+	do { \
+		if (test_bit(ev, dev->evbit)) \
+			SPRINTF_BIT_B(bit, name, max); \
+	} while (0)
+
+
+static unsigned int input_devices_poll(struct file *file, poll_table *wait)
+{
+	int state = input_devices_state;
+	poll_wait(file, &input_devices_poll_wait, wait);
+	if (state != input_devices_state)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static int input_devices_read(char *buf, char **start, off_t pos, int count, int *eof, void *data)
+{
+	struct input_dev *dev = input_dev;
+	struct input_handle *handle;
+
+	off_t at = 0;
+	int i, len, cnt = 0;
+
+	while (dev) {
+
+		len = sprintf(buf, "I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\n",
+			dev->idbus, dev->idvendor, dev->idproduct, dev->idversion);
+
+		len += sprintf(buf + len, "N: Name=\"%s\"\n", dev->name ? dev->name : "");
+		len += sprintf(buf + len, "P: Phys=%s\n", dev->phys ? dev->phys : "");
+		len += sprintf(buf + len, "D: Drivers=");
+
+		handle = dev->handle;
+
+		while (handle) {
+			len += sprintf(buf + len, "%s ", handle->name);
+			handle = handle->dnext;
+		}
+
+		len += sprintf(buf + len, "\n");
+
+		SPRINTF_BIT_B(evbit, "EV=", EV_MAX);
+		SPRINTF_BIT_B2(keybit, "KEY=", KEY_MAX, EV_KEY);
+		SPRINTF_BIT_B2(relbit, "REL=", REL_MAX, EV_REL);
+		SPRINTF_BIT_B2(absbit, "ABS=", ABS_MAX, EV_ABS);
+		SPRINTF_BIT_B2(mscbit, "MSC=", MSC_MAX, EV_MSC);
+		SPRINTF_BIT_B2(ledbit, "LED=", LED_MAX, EV_LED);
+		SPRINTF_BIT_B2(sndbit, "SND=", SND_MAX, EV_SND);
+		SPRINTF_BIT_B2(ffbit,  "FF=",  FF_MAX, EV_FF);
+
+		len += sprintf(buf + len, "\n");
+
+		at += len;
+
+		if (at >= pos) {
+			if (!*start) {
+				*start = buf + (pos - (at - len));
+				cnt = at - pos;
+			} else  cnt += len;
+			buf += len;
+			if (cnt >= count)
+				break;
+		}
+
+		dev = dev->next;
+	}
+
+	if (!dev) *eof = 1;
+
+	return (count > cnt) ? cnt : count;
+}
+
+static int input_handlers_read(char *buf, char **start, off_t pos, int count, int *eof, void *data)
+{
+	struct input_handler *handler = input_handler;
+
+	off_t at = 0;
+	int len = 0, cnt = 0;
+	int i = 0;
+
+	while (handler) {
+
+		if (handler->fops)
+			len = sprintf(buf, "N: Number=%d Name=%s Minor=%d\n",
+				i++, handler->name, handler->minor);
+		else
+			len = sprintf(buf, "N: Number=%d Name=%s\n",
+				i++, handler->name);
+
+		at += len;
+
+		if (at >= pos) {
+			if (!*start) {
+				*start = buf + (pos - (at - len));
+				cnt = at - pos;
+			} else  cnt += len;
+			buf += len;
+			if (cnt >= count)
+				break;
+		}
+
+		handler = handler->next;
+	}
+
+	if (!handler) *eof = 1;
+
+	return (count > cnt) ? cnt : count;
+}
+
+#endif
+
 static int __init input_init(void)
 {
+	struct proc_dir_entry *entry;
+
+#ifdef CONFIG_PROC_FS
+	proc_bus_input_dir = proc_mkdir("input", proc_bus);
+	proc_bus_input_dir->owner = THIS_MODULE;
+	entry = create_proc_read_entry("devices", 0, proc_bus_input_dir, input_devices_read, NULL);
+	entry->owner = THIS_MODULE;
+	entry->proc_fops->poll = input_devices_poll;
+	entry = create_proc_read_entry("handlers", 0, proc_bus_input_dir, input_handlers_read, NULL);
+	entry->owner = THIS_MODULE;
+#endif
 	if (devfs_register_chrdev(INPUT_MAJOR, "input", &input_fops)) {
 		printk(KERN_ERR "input: unable to register char major %d", INPUT_MAJOR);
 		return -EBUSY;
 	}
+
 	input_devfs_handle = devfs_mk_dir(NULL, "input", NULL);
+
 	return 0;
 }
 
 static void __exit input_exit(void)
 {
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("devices", proc_bus_input_dir);
+	remove_proc_entry("handlers", proc_bus_input_dir);
+	remove_proc_entry("input", proc_bus);
+#endif
 	devfs_unregister(input_devfs_handle);
         if (devfs_unregister_chrdev(INPUT_MAJOR, "input"))
                 printk(KERN_ERR "input: can't unregister char major %d", INPUT_MAJOR);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/input/joydev.c linux-modified/drivers/input/joydev.c
--- linux-vanilla/drivers/input/joydev.c	Mon Feb  3 20:47:45 2003
+++ linux-modified/drivers/input/joydev.c	Tue Feb  4 21:26:33 2003
@@ -1,12 +1,10 @@
 /*
- * $Id$
+ * $Id$
  *
- *  Copyright (c) 1999-2000 Vojtech Pavlik 
+ *  Copyright (c) 1999-2001 Vojtech Pavlik 
  *  Copyright (c) 1999 Colin Van Dyke 
  *
  *  Joystick device driver for the input driver suite.
- *
- *  Sponsored by SuSE and Intel
  */
 
 /*
@@ -25,8 +23,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  * 
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <asm/io.h>
@@ -46,6 +44,11 @@
 #include <linux/init.h>
 #include <linux/smp_lock.h>
 
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Joystick device interfaces");
+MODULE_SUPPORTED_DEVICE("input/js");
+MODULE_LICENSE("GPL");
+
 #define JOYDEV_MINOR_BASE	0
 #define JOYDEV_MINORS		32
 #define JOYDEV_BUFFER_SIZE	64
@@ -56,6 +59,7 @@
 	int exist;
 	int open;
 	int minor;
+	char name[16];
 	struct input_handle handle;
 	wait_queue_head_t wait;
 	devfs_handle_t devfs;
@@ -84,11 +88,6 @@
 
 static struct joydev *joydev_table[JOYDEV_MINORS];
 
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
-MODULE_DESCRIPTION("Joystick device driver");
-MODULE_LICENSE("GPL");
-MODULE_SUPPORTED_DEVICE("input/js");
-
 static int joydev_correct(int value, struct js_corr *corr)
 {
 	switch (corr->type) {
@@ -167,7 +166,6 @@
 	struct joydev_list *list = file->private_data;
 	struct joydev_list **listptr;
 
-	lock_kernel();
 	listptr = &list->joydev->list;
 	joydev_fasync(-1, file, 0);
 
@@ -186,7 +184,6 @@
 	}
 
 	kfree(list);
-	unlock_kernel();
 
 	return 0;
 }
@@ -254,10 +251,15 @@
 	if (list->head == list->tail && list->startup == joydev->nabs + joydev->nkey) {
 
 		add_wait_queue(&list->joydev->wait, &wait);
-		current->state = TASK_INTERRUPTIBLE;
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		while (list->head == list->tail) {
 
+			if (!joydev->exist) {
+				retval = -ENODEV;
+				break;
+			}
+
 			if (file->f_flags & O_NONBLOCK) {
 				retval = -EAGAIN;
 				break;
@@ -270,7 +272,7 @@
 			schedule();
 		}
 
-		current->state = TASK_RUNNING;
+		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&list->joydev->wait, &wait);
 	}
 
@@ -329,6 +331,8 @@
 	struct input_dev *dev = joydev->handle.dev;
 	int i;
 
+	if (!joydev->exist) return -ENODEV;
+
 	switch (cmd) {
 
 		case JS_SET_CAL:
@@ -410,16 +414,11 @@
 	fasync:		joydev_fasync,
 };
 
-static struct input_handle *joydev_connect(struct input_handler *handler, struct input_dev *dev)
+static struct input_handle *joydev_connect(struct input_handler *handler, struct input_dev *dev, struct input_device_id *id)
 {
 	struct joydev *joydev;
 	int i, j, t, minor;
 
-	if (!(test_bit(EV_KEY, dev->evbit) && test_bit(EV_ABS, dev->evbit) &&
-	     (test_bit(ABS_X, dev->absbit) || test_bit(ABS_Y, dev->absbit)) &&
-	     (test_bit(BTN_TRIGGER, dev->keybit) || test_bit(BTN_A, dev->keybit)
-		|| test_bit(BTN_1, dev->keybit)))) return NULL; 
-
 	for (minor = 0; minor < JOYDEV_MINORS && joydev_table[minor]; minor++);
 	if (minor == JOYDEV_MINORS) {
 		printk(KERN_ERR "joydev: no more free joydev devices\n");
@@ -435,12 +434,13 @@
 	joydev->minor = minor;
 	joydev_table[minor] = joydev;
 
+	sprintf(joydev->name, "js%d", minor);
+
 	joydev->handle.dev = dev;
+	joydev->handle.name = joydev->name;
 	joydev->handle.handler = handler;
 	joydev->handle.private = joydev;
 
-	joydev->exist = 1;
-
 	for (i = 0; i < ABS_MAX; i++)
 		if (test_bit(i, dev->absbit)) {
 			joydev->absmap[i] = joydev->nabs;
@@ -484,6 +484,8 @@
 
 //	printk(KERN_INFO "js%d: Joystick device for input%d\n", minor, dev->number);
 
+	joydev->exist = 1;
+
 	return &joydev->handle;
 }
 
@@ -502,12 +504,35 @@
 	}
 }
 
+static struct input_device_id joydev_ids[] = {
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_ABSBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_ABS) },
+		absbit: { BIT(ABS_X) },
+	},
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_ABSBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_ABS) },
+		absbit: { BIT(ABS_WHEEL) },
+	},
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_ABSBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_ABS) },
+		absbit: { BIT(ABS_THROTTLE) },
+	},
+	{ }, 	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(input, joydev_ids);
+
 static struct input_handler joydev_handler = {
 	event:		joydev_event,
 	connect:	joydev_connect,
 	disconnect:	joydev_disconnect,
 	fops:		&joydev_fops,
 	minor:		JOYDEV_MINOR_BASE,
+	name:		"joydev",
+	id_table:	joydev_ids,
 };
 
 static int __init joydev_init(void)
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/input/keybdev.c linux-modified/drivers/input/keybdev.c
--- linux-vanilla/drivers/input/keybdev.c	Thu Oct 11 18:14:32 2001
+++ linux-modified/drivers/input/keybdev.c	Mon Jan  6 16:48:20 2003
@@ -177,20 +177,11 @@
 	tasklet_schedule(&keyboard_tasklet);
 }
 
-static struct input_handle *keybdev_connect(struct input_handler *handler, struct input_dev *dev)
+static struct input_handle *keybdev_connect(struct input_handler *handler, struct input_dev *dev, struct input_device_id* id)
 {
 	struct input_handle *handle;
 	int i;
 
-	if (!test_bit(EV_KEY, dev->evbit))
-		return NULL;
-
-	for (i = KEY_RESERVED; i < BTN_MISC; i++)
-		if (test_bit(i, dev->keybit)) break;
-
-	if (i == BTN_MISC)
- 		return NULL;
-
 	if (!(handle = kmalloc(sizeof(struct input_handle), GFP_KERNEL)))
 		return NULL;
 	memset(handle, 0, sizeof(struct input_handle));
@@ -212,10 +203,25 @@
 	kfree(handle);
 }
 	
+static struct input_device_id keybdev_ids[] = {
+	/* If it's got an "esc" key, it's a keyboard */
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_REL) },
+		keybit: { BIT(KEY_ESC) },
+	},
+	  
+	{ }, 	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(input, keybdev_ids);
+	
 static struct input_handler keybdev_handler = {
 	event:		keybdev_event,
 	connect:	keybdev_connect,
 	disconnect:	keybdev_disconnect,
+	name:		"keybdev",
+	id_table:	keybdev_ids,
 };
 
 static int __init keybdev_init(void)
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/input/mousedev.c linux-modified/drivers/input/mousedev.c
--- linux-vanilla/drivers/input/mousedev.c	Sun Sep 30 21:26:05 2001
+++ linux-modified/drivers/input/mousedev.c	Mon Jan  6 16:48:20 2003
@@ -1,11 +1,9 @@
 /*
- * $Id$
+ * $Id$
  *
- *  Copyright (c) 1999-2000 Vojtech Pavlik
+ *  Copyright (c) 1999-2001 Vojtech Pavlik
  *
- *  Input driver to ImExPS/2 device driver module.
- *
- *  Sponsored by SuSE
+ *  Input driver to ExplorerPS/2 device driver module.
  */
 
 /*
@@ -24,8 +22,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  * 
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #define MOUSEDEV_MINOR_BASE 	32
@@ -41,6 +39,10 @@
 #include <linux/smp_lock.h>
 #include <linux/random.h>
 
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
+MODULE_DESCRIPTION("Mouse (ExplorerPS/2) device interfaces");
+MODULE_LICENSE("GPL");
+
 #ifndef CONFIG_INPUT_MOUSEDEV_SCREEN_X
 #define CONFIG_INPUT_MOUSEDEV_SCREEN_X	1024
 #endif
@@ -52,6 +54,7 @@
 	int exist;
 	int open;
 	int minor;
+	char name[16];
 	wait_queue_head_t wait;
 	struct mousedev_list *list;
 	struct input_handle handle;
@@ -89,8 +92,6 @@
 	struct mousedev_list *list;
 	int index, size;
 
-	add_mouse_randomness((type << 4) ^ code ^ (code >> 4) ^ value);
-
 	while (*mousedev) {
 		list = (*mousedev)->list;
 		while (list) {
@@ -101,13 +102,23 @@
 					switch (code) {
 						case ABS_X:	
 							size = handle->dev->absmax[ABS_X] - handle->dev->absmin[ABS_X];
-							list->dx += (value * xres - list->oldx) / size;
-							list->oldx += list->dx * size;
+							if (size != 0) {
+								list->dx += (value * xres - list->oldx) / size;
+								list->oldx += list->dx * size;
+							} else {
+								list->dx += value - list->oldx;
+								list->oldx += list->dx;
+							}
 							break;
 						case ABS_Y:
 							size = handle->dev->absmax[ABS_Y] - handle->dev->absmin[ABS_Y];
-							list->dy -= (value * yres - list->oldy) / size;
-							list->oldy -= list->dy * size;
+							if (size != 0) {
+								list->dy -= (value * yres - list->oldy) / size;
+								list->oldy -= list->dy * size;
+							} else {
+								list->dy -= value - list->oldy;
+								list->oldy -= list->dy;
+							}
 							break;
 					}
 					break;
@@ -170,7 +181,6 @@
 	struct mousedev_list *list = file->private_data;
 	struct mousedev_list **listptr;
 
-	lock_kernel();
 	listptr = &list->mousedev->list;
 	mousedev_fasync(-1, file, 0);
 
@@ -208,7 +218,6 @@
 	}
 	
 	kfree(list);
-	unlock_kernel();
 
 	return 0;
 }
@@ -216,7 +225,14 @@
 static int mousedev_open(struct inode * inode, struct file * file)
 {
 	struct mousedev_list *list;
-	int i = MINOR(inode->i_rdev) - MOUSEDEV_MINOR_BASE;
+	int i;
+
+#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
+	if (major(inode->i_rdev) == MISC_MAJOR))
+		i = MOUSEDEV_MIX;
+	else
+#endif
+		i = MINOR(inode->i_rdev) - MOUSEDEV_MINOR_BASE;
 
 	if (i >= MOUSEDEV_MINORS || !mousedev_table[i])
 		return -ENODEV;
@@ -346,7 +362,7 @@
 	if (!list->ready && !list->buffer) {
 
 		add_wait_queue(&list->mousedev->wait, &wait);
-		current->state = TASK_INTERRUPTIBLE;
+		set_current_state(TASK_INTERRUPTIBLE);
 
 		while (!list->ready) {
 
@@ -362,7 +378,7 @@
 			schedule();
 		}
 
-		current->state = TASK_RUNNING;
+		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&list->mousedev->wait, &wait);
 	}
 
@@ -403,19 +419,11 @@
 	fasync:		mousedev_fasync,
 };
 
-static struct input_handle *mousedev_connect(struct input_handler *handler, struct input_dev *dev)
+static struct input_handle *mousedev_connect(struct input_handler *handler, struct input_dev *dev, struct input_device_id *id)
 {
 	struct mousedev *mousedev;
 	int minor = 0;
 
-	if (!test_bit(EV_KEY, dev->evbit) ||
-	   (!test_bit(BTN_LEFT, dev->keybit) && !test_bit(BTN_TOUCH, dev->keybit)))
-		return NULL;
-
-	if ((!test_bit(EV_REL, dev->evbit) || !test_bit(REL_X, dev->relbit)) &&
-	    (!test_bit(EV_ABS, dev->evbit) || !test_bit(ABS_X, dev->absbit)))
-		return NULL;
-
 	for (minor = 0; minor < MOUSEDEV_MINORS && mousedev_table[minor]; minor++);
 	if (minor == MOUSEDEV_MINORS) {
 		printk(KERN_ERR "mousedev: no more free mousedev devices\n");
@@ -427,11 +435,12 @@
 	memset(mousedev, 0, sizeof(struct mousedev));
 	init_waitqueue_head(&mousedev->wait);
 
-	mousedev->exist = 1;
 	mousedev->minor = minor;
 	mousedev_table[minor] = mousedev;
+	sprintf(mousedev->name, "mouse%d", minor);
 
 	mousedev->handle.dev = dev;
+	mousedev->handle.name = mousedev->name;
 	mousedev->handle.handler = handler;
 	mousedev->handle.private = mousedev;
 
@@ -440,7 +449,7 @@
 	if (mousedev_mix.open)
 		input_open_device(&mousedev->handle);
 
-//	printk(KERN_INFO "mouse%d: PS/2 mouse device for input%d\n", minor, dev->number);
+	mousedev->exist = 1;
 
 	return &mousedev->handle;
 }
@@ -461,6 +470,26 @@
 		kfree(mousedev);
 	}
 }
+
+static struct input_device_id mousedev_ids[] = {
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT | INPUT_DEVICE_ID_MATCH_RELBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_REL) },
+		keybit: { [LONG(BTN_LEFT)] = BIT(BTN_LEFT) },
+		relbit: { BIT(REL_X) | BIT(REL_Y) },
+	},	/* A mouse like device, at least one button, two relative axes */
+
+	{
+		flags: INPUT_DEVICE_ID_MATCH_EVBIT | INPUT_DEVICE_ID_MATCH_KEYBIT | INPUT_DEVICE_ID_MATCH_ABSBIT,
+		evbit: { BIT(EV_KEY) | BIT(EV_ABS) },
+		keybit: { [LONG(BTN_TOUCH)] = BIT(BTN_TOUCH) },
+		absbit: { BIT(ABS_X) | BIT(ABS_Y) },
+	},	/* A tablet like device, at least touch detection, two absolute axes */
+
+	{ }, 	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(input, mousedev_ids);
 	
 static struct input_handler mousedev_handler = {
 	event:		mousedev_event,
@@ -468,7 +497,15 @@
 	disconnect:	mousedev_disconnect,
 	fops:		&mousedev_fops,
 	minor:		MOUSEDEV_MINOR_BASE,
+	name:		"mousedev",
+	id_table:	mousedev_ids,
+};
+
+#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
+static struct miscdevice psaux_mouse = {
+	PSMOUSE_MINOR, "psaux", &mousedev_fops
 };
+#endif
 
 static int __init mousedev_init(void)
 {
@@ -480,6 +517,9 @@
 	mousedev_mix.exist = 1;
 	mousedev_mix.minor = MOUSEDEV_MIX;
 	mousedev_mix.devfs = input_register_minor("mice", MOUSEDEV_MIX, MOUSEDEV_MINOR_BASE);
+#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
+	misc_register(&psaux_mouse)
+#endif
 
 	printk(KERN_INFO "mice: PS/2 mouse device common for all mice\n");
 
@@ -488,16 +528,15 @@
 
 static void __exit mousedev_exit(void)
 {
+#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
+	misc_deregister(&psaux_mouse)
+#endif
 	input_unregister_minor(mousedev_mix.devfs);
 	input_unregister_handler(&mousedev_handler);
 }
 
 module_init(mousedev_init);
 module_exit(mousedev_exit);
-
-MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
-MODULE_DESCRIPTION("Input driver to PS/2 or ImPS/2 device driver");
-MODULE_LICENSE("GPL");
 
 MODULE_PARM(xres, "i");
 MODULE_PARM_DESC(xres, "Horizontal screen resolution");
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/Config.in linux-modified/drivers/usb/Config.in
--- linux-vanilla/drivers/usb/Config.in	Mon Jan  6 15:58:08 2003
+++ linux-modified/drivers/usb/Config.in	Mon Jan  6 16:48:20 2003
@@ -62,6 +62,8 @@
    fi
       dep_mbool '    HID input layer support' CONFIG_USB_HIDINPUT $CONFIG_INPUT $CONFIG_USB_HID
       dep_mbool '    /dev/hiddev raw HID device support' CONFIG_USB_HIDDEV $CONFIG_USB_HID
+      dep_mbool '    Force feedback support (EXPERIMENTAL)' CONFIG_HID_FF $CONFIG_USB_HID $CONFIG_EXPERIMENTAL
+      dep_mbool '       Logitech WingMan 3D devices (EXPERIMENTAL)' CONFIG_LOGITECH_FF $CONFIG_HID_FF $CONFIG_EXPERIMENTAL 
    if [ "$CONFIG_USB_HID" != "y" ]; then
       dep_tristate '  USB HIDBP Keyboard (basic) support' CONFIG_USB_KBD $CONFIG_USB $CONFIG_INPUT
       dep_tristate '  USB HIDBP Mouse (basic) support' CONFIG_USB_MOUSE $CONFIG_USB $CONFIG_INPUT
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/Makefile linux-modified/drivers/usb/Makefile
--- linux-vanilla/drivers/usb/Makefile	Mon Jan  6 15:58:08 2003
+++ linux-modified/drivers/usb/Makefile	Mon Jan  6 16:48:20 2003
@@ -34,6 +34,14 @@
 	hid-objs	+= hid-input.o
 endif
 
+ifeq ($(CONFIG_HID_FF),y)
+	hid-objs	+= hid-ff.o
+endif
+
+ifeq ($(CONFIG_LOGITECH_FF),y)
+	hid-objs	+= hid-lgff.o
+endif
+
 # Object file lists.
 
 obj-y	:=
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/fixp-arith.h linux-modified/drivers/usb/fixp-arith.h
--- linux-vanilla/drivers/usb/fixp-arith.h	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/usb/fixp-arith.h	Sun Mar  9 17:01:24 2003
@@ -0,0 +1,100 @@
+#ifndef _FIXP_ARITH_H
+#define _FIXP_ARITH_H
+
+/*
+ * $$
+ *
+ * Simplistic fixed-point arithmetics.
+ * Hmm, I'm probably duplicating some code :(
+ *
+ * Copyright (c) 2002 Johann Deneux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so by
+ * e-mail - mail your message to <deneux@ifrance.com>
+ */
+
+#include <linux/types.h>
+
+// The type representing fixed-point values
+typedef s16 fixp_t;
+
+#define FRAC_N 8
+#define FRAC_MASK ((1<<FRAC_N)-1)
+
+// Not to be used directly. Use fixp_{cos,sin}
+fixp_t cos_table[45] = {
+	0x0100,	0x00FF,	0x00FF,	0x00FE,	0x00FD,	0x00FC,	0x00FA,	0x00F8,
+	0x00F6,	0x00F3,	0x00F0,	0x00ED,	0x00E9,	0x00E6,	0x00E2,	0x00DD,
+	0x00D9,	0x00D4,	0x00CF,	0x00C9,	0x00C4,	0x00BE,	0x00B8,	0x00B1,
+	0x00AB,	0x00A4,	0x009D,	0x0096,	0x008F,	0x0087,	0x0080,	0x0078,
+	0x0070,	0x0068,	0x005F,	0x0057,	0x004F,	0x0046,	0x003D,	0x0035,
+	0x002C,	0x0023,	0x001A,	0x0011,	0x0008
+};
+
+
+/* a: 123 -> 123.0 */
+inline fixp_t fixp_new(s16 a)
+{
+	return a<<FRAC_N;
+}
+
+/* a: 0xFFFF -> -1.0
+      0x8000 -> 1.0
+      0x0000 -> 0.0
+*/
+inline fixp_t fixp_new16(s16 a)
+{
+	return ((s32)a)>>(16-FRAC_N);
+}
+
+inline int fixp_toint(fixp_t x)
+{
+	return x>>FRAC_N;
+}
+
+inline fixp_t fixp_cos(unsigned int degrees)
+{
+	int quadrant = (degrees / 90) & 3;
+	unsigned int i = degrees % 90;
+
+	if (quadrant == 1 || quadrant == 3) {
+		i = 89 - i;
+	}
+
+	i >>= 1;
+
+	return (quadrant == 1 || quadrant == 2)? -cos_table[i] : cos_table[i];
+}
+
+inline fixp_t fixp_sin(unsigned int degrees)
+{
+	return -fixp_cos(degrees + 90);
+}
+
+inline fixp_t fixp_mult(fixp_t a, fixp_t b)
+{
+	return ((s32)(a*b))>>FRAC_N;
+}
+
+inline fixp_t fixp_div(fixp_t a, fixp_t b)
+{
+	return (a/b)<<FRAC_N;
+}
+
+#endif
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid-core.c linux-modified/drivers/usb/hid-core.c
--- linux-vanilla/drivers/usb/hid-core.c	Mon Jan  6 15:58:08 2003
+++ linux-modified/drivers/usb/hid-core.c	Mon Jan 13 23:41:59 2003
@@ -1,12 +1,10 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999 Andreas Gal
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *
  *  USB HID support for Linux
- *
- *  Sponsored by SuSE
  */
 
 /*
@@ -25,8 +23,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <linux/module.h>
@@ -47,15 +45,19 @@
 #include <linux/usb.h>
 
 #include "hid.h"
+#ifdef CONFIG_USB_HIDDEV
 #include <linux/hiddev.h>
+#endif
+
 
 /*
  * Version Information
  */
 
-#define DRIVER_VERSION "v1.8.1"
-#define DRIVER_AUTHOR "Andreas Gal, Vojtech Pavlik <vojtech@suse.cz>"
-#define DRIVER_DESC "USB HID support drivers"
+#define DRIVER_VERSION "v1.31"
+#define DRIVER_AUTHOR "Andreas Gal, Vojtech Pavlik <vojtech@ucw.cz>"
+#define DRIVER_DESC "USB HID core driver"
+#define DRIVER_LICENSE "GPL"
 
 static char *hid_types[] = {"Device", "Pointer", "Mouse", "Device", "Joystick",
 				"Gamepad", "Keyboard", "Keypad", "Multi-Axis Controller"};
@@ -206,7 +208,6 @@
 		dbg("logical range invalid %d %d", parser->global.logical_minimum, parser->global.logical_maximum);
 		return -1;
 	}
-
 	usages = parser->local.usage_index;
 
 	offset = report->size;
@@ -322,7 +323,7 @@
 			return 0;
 
 		case HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:
-			parser->global.unit_exponent = item_udata(item);
+			parser->global.unit_exponent = item_sdata(item);
 			return 0;
 
 		case HID_GLOBAL_ITEM_TAG_UNIT:
@@ -507,8 +508,6 @@
 
 	for (n = 0; n < report->maxfield; n++)
 		kfree(report->field[n]);
-	if (report->data)
-		kfree(report->data);
 	kfree(report);
 }
 
@@ -520,6 +519,10 @@
 {
 	unsigned i,j;
 
+#ifdef CONFIG_HID_FF
+	hid_ff_exit(device);
+#endif
+
 	for (i = 0; i < HID_REPORT_TYPES; i++) {
 		struct hid_report_enum *report_enum = device->report_enum + i;
 
@@ -537,60 +540,64 @@
  * items, though they are not used yet.
  */
 
-static __u8 *fetch_item(__u8 *start, __u8 *end, struct hid_item *item)
+static u8 *fetch_item(__u8 *start, __u8 *end, struct hid_item *item)
 {
-	if ((end - start) > 0) {
+	u8 b;
 
-		__u8 b = *start++;
-		item->type = (b >> 2) & 3;
-		item->tag  = (b >> 4) & 15;
+	if ((end - start) <= 0)
+		return NULL;
 
-		if (item->tag == HID_ITEM_TAG_LONG) {
+	b = *start++;
 
-			item->format = HID_ITEM_FORMAT_LONG;
+	item->type = (b >> 2) & 3;
+	item->tag  = (b >> 4) & 15;
 
-			if ((end - start) >= 2) {
+	if (item->tag == HID_ITEM_TAG_LONG) {
 
-				item->size = *start++;
-				item->tag  = *start++;
+		item->format = HID_ITEM_FORMAT_LONG;
 
-				if ((end - start) >= item->size) {
-					item->data.longdata = start;
-					start += item->size;
-					return start;
-				}
-			}
-		} else {
+		if ((end - start) < 2)
+			return NULL;
 
-			item->format = HID_ITEM_FORMAT_SHORT;
-			item->size = b & 3;
-			switch (item->size) {
-
-				case 0:
-					return start;
-
-				case 1:
-					if ((end - start) >= 1) {
-						item->data.u8 = *start++;
-						return start;
-					}
-					break;
-
-				case 2:
-					if ((end - start) >= 2) {
-						item->data.u16 = le16_to_cpu( get_unaligned(((__u16*)start)++));
-						return start;
-					}
-
-				case 3:
-					item->size++;
-					if ((end - start) >= 4) {
-						item->data.u32 = le32_to_cpu( get_unaligned(((__u32*)start)++));
-						return start;
-					}
-			}
-		}
+		item->size = *start++;
+		item->tag  = *start++;
+
+		if ((end - start) < item->size) 
+			return NULL;
+
+		item->data.longdata = start;
+		start += item->size;
+		return start;
+	} 
+
+	item->format = HID_ITEM_FORMAT_SHORT;
+	item->size = b & 3;
+
+	switch (item->size) {
+
+		case 0:
+			return start;
+
+		case 1:
+			if ((end - start) < 1)
+				return NULL;
+			item->data.u8 = *start++;
+			return start;
+
+		case 2:
+			if ((end - start) < 2) 
+				return NULL;
+			item->data.u16 = le16_to_cpu(get_unaligned(((__u16*)start)++));
+			return start;
+
+		case 3:
+			item->size++;
+			if ((end - start) < 4)
+				return NULL;
+			item->data.u32 = le32_to_cpu(get_unaligned(((__u32*)start)++));
+			return start;
 	}
+
 	return NULL;
 }
 
@@ -637,12 +644,14 @@
 
 	end = start + size;
 	while ((start = fetch_item(start, end, &item)) != 0) {
+
 		if (item.format != HID_ITEM_FORMAT_SHORT) {
 			dbg("unexpected long global item");
 			hid_free_device(device);
 			kfree(parser);
 			return NULL;
 		}
+
 		if (dispatch_type[item.type](parser, &item)) {
 			dbg("item %u %u %u %u parsing failed\n",
 				item.format, (unsigned)item.size, (unsigned)item.type, (unsigned)item.tag);
@@ -735,11 +744,24 @@
 	hid_dump_input(usage, value);
 	if (hid->claimed & HID_CLAIMED_INPUT)
 		hidinput_hid_event(hid, field, usage, value);
-	if (hid->claimed & HID_CLAIMED_HIDDEV)
-		hiddev_hid_event(hid, usage->hid, value);
+#ifdef CONFIG_USB_HIDDEV
+	if (hid->claimed & HID_CLAIMED_HIDDEV) {
+		struct hiddev_usage_ref uref;
+		unsigned type = field->report_type;
+		uref.report_type =
+			(type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :
+			((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :
+			 ((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE:0));
+		uref.report_id = field->report->id;
+		uref.field_index = field->index;
+		uref.usage_index = (usage - field->usage);
+		uref.usage_code = usage->hid;
+		uref.value = value;
+		hiddev_hid_event(hid, &uref);
+	}
+#endif
 }
 
-
 /*
  * Analyse a received field, and fetch the data from it. The field
  * content is stored for next report processing (we do differential
@@ -794,9 +816,12 @@
 	memcpy(field->value, value, count * sizeof(__s32));
 }
 
-static int hid_input_report(int type, u8 *data, int len, struct hid_device *hid)
+static int hid_input_report(int type, struct urb *urb)
 {
+	struct hid_device *hid = urb->context;
 	struct hid_report_enum *report_enum = hid->report_enum + type;
+	u8 *data = urb->transfer_buffer;
+	int len = urb->actual_length;
 	struct hid_report *report;
 	int n, size;
 
@@ -815,95 +840,46 @@
 		len--;
 	}
 
-	if (!(report = report_enum->report_id_hash[n])) {
-		dbg("undefined report_id %d received", n);
-#ifdef DEBUG
-			printk(KERN_DEBUG __FILE__ ": report (size %u) = ", len);
-			for (n = 0; n < len; n++)
-				printk(" %02x", data[n]);
-			printk("\n");
+#ifdef DEBUG_DATA
+	{
+		int i;
+		printk(KERN_DEBUG __FILE__ ": report %d (size %u) = ", n, len);
+		for (i = 0; i < n; i++)
+			printk(" %02x", data[i]);
+		printk("\n");
+	}
 #endif
 
+	if (!(report = report_enum->report_id_hash[n])) {
+		dbg("undefined report_id %d received", n);
 		return -1;
 	}
 
 	size = ((report->size - 1) >> 3) + 1;
 
 	if (len < size) {
-
-		if (size <= 8) {
-			dbg("report %d is too short, (%d < %d)", report->id, len, size);
-			return -1;
-		}
-
-		/*
-		 * Some low-speed devices have large reports and maxpacketsize 8.
-		 * We buffer the data in that case and parse it when we got it all.
-		 * Works only for unnumbered reports. Doesn't make sense for numbered
-		 * reports anyway - then they don't need to be large.
-		 */
-
-		if (!report->data)
-			if (!(report->data = kmalloc(size, GFP_ATOMIC))) {
-				dbg("couldn't allocate report buffer");
-				return -1;
-			}
-
-		if (report->idx + len > size) {
-			dbg("report data buffer overflow");
-			report->idx = 0;
-			return -1;
-		}
-
-		memcpy(report->data + report->idx, data, len);
-		report->idx += len;
-
-		if (report->idx < size)
-			return 0;
-
-		data = report->data;
+		dbg("report %d is too short, (%d < %d)", report->id, len, size);
+		return -1;
 	}
 
 	for (n = 0; n < report->maxfield; n++)
 		hid_input_field(hid, report->field[n], data);
 
-	report->idx = 0;
 	return 0;
 }
 
 /*
- * Interrupt input handler.
+ * Input interrupt completion handler.
  */
 
-static void hid_irq(struct urb *urb)
+static void hid_irq_in(struct urb *urb)
 {
 	if (urb->status) {
-		dbg("nonzero status in irq %d", urb->status);
+		dbg("nonzero status in input irq %d", urb->status);
 		return;
 	}
 
-	hid_input_report(HID_INPUT_REPORT, urb->transfer_buffer, urb->actual_length, urb->context);
-}
-
-/*
- * hid_read_report() reads in report values without waiting for an irq urb.
- */
-
-void hid_read_report(struct hid_device *hid, struct hid_report *report)
-{
-	int len = ((report->size - 1) >> 3) + 1 + hid->report_enum[report->type].numbered;
-	u8 data[len];
-	int read;
-
-	if (hid->quirks & HID_QUIRK_NOGET)
-		return;
-
-	if ((read = usb_get_report(hid->dev, hid->ifnum, report->type + 1, report->id, data, len)) != len) {
-		dbg("reading report type %d id %d failed len %d read %d", report->type + 1, report->id, len, read);
-		return;
-	}
-
-	hid_input_report(report->type, data, len, hid);
+	hid_input_report(HID_INPUT_REPORT, urb);
 }
 
 /*
@@ -949,7 +925,8 @@
 	hid_dump_input(field->usage + offset, value);
 
 	if (offset >= field->report_count) {
-		dbg("offset exceeds report_count");
+		dbg("offset (%d) exceeds report_count (%d)", offset, field->report_count);
+		hid_dump_field(field, 8);
 		return -1;
 	}
 	if (field->logical_minimum < 0) {
@@ -958,11 +935,6 @@
 			return -1;
 		}
 	}
-	if (   (value > field->logical_maximum)
-	    || (value < field->logical_minimum)) {
-		dbg("value %d is invalid", value);
-		return -1;
-	}
 	field->value[offset] = value;
 	return 0;
 }
@@ -986,14 +958,54 @@
 	return -1;
 }
 
+/*
+ * Find a report with a specified HID usage.
+ */
+
+int hid_find_report_by_usage(struct hid_device *hid, __u32 wanted_usage, struct hid_report **report, int type)
+{
+	struct hid_report_enum *report_enum = hid->report_enum + type;
+	struct list_head *list = report_enum->report_list.next;
+	int i, j;
+
+	while (list != &report_enum->report_list) {
+		*report = (struct hid_report *) list;
+		list = list->next;
+		for (i = 0; i < (*report)->maxfield; i++) {
+			struct hid_field *field = (*report)->field[i];
+			for (j = 0; j < field->maxusage; j++)
+				if (field->logical == wanted_usage)
+					return j;
+		}
+	}
+	return -1;
+}
+
+int hid_find_field_in_report(struct hid_report *report, __u32 wanted_usage, struct hid_field **field)
+{
+	int i, j;
+
+	for (i = 0; i < report->maxfield; i++) {
+		*field = report->field[i];
+		for (j = 0; j < (*field)->maxusage; j++)
+			if ((*field)->usage[j].hid == wanted_usage)
+				return j;
+	}
+
+	return -1;
+}
+
 static int hid_submit_out(struct hid_device *hid)
 {
-	hid->urbout.transfer_buffer_length = le16_to_cpup(&hid->out[hid->outtail].dr.wLength);
-	hid->urbout.transfer_buffer = hid->out[hid->outtail].buffer;
-	hid->urbout.setup_packet = (void *) &(hid->out[hid->outtail].dr);
-	hid->urbout.dev = hid->dev;
+	struct hid_report *report;
 
-	if (usb_submit_urb(&hid->urbout)) {
+	report = hid->out[hid->outtail];
+
+	hid_output_report(report, hid->outbuf);
+	hid->urbout->transfer_buffer_length = ((report->size - 1) >> 3) + 1;
+	hid->urbout->dev = hid->dev;
+
+	if (usb_submit_urb(hid->urbout)) {
 		err("usb_submit_urb(out) failed");
 		return -1;
 	}
@@ -1001,33 +1013,168 @@
 	return 0;
 }
 
+static int hid_submit_ctrl(struct hid_device *hid)
+{
+	struct hid_report *report;
+	unsigned char dir;
+
+	report = hid->ctrl[hid->ctrltail].report;
+	dir = hid->ctrl[hid->ctrltail].dir;
+
+	if (dir == USB_DIR_OUT)
+		hid_output_report(report, hid->ctrlbuf);
+
+	hid->urbctrl->transfer_buffer_length = ((report->size - 1) >> 3) + 1 + ((report->id > 0) && (dir != USB_DIR_OUT));
+	hid->urbctrl->pipe = (dir == USB_DIR_OUT) ?  usb_sndctrlpipe(hid->dev, 0) : usb_rcvctrlpipe(hid->dev, 0);
+	hid->urbctrl->dev = hid->dev;
+
+	hid->dr.bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;
+	hid->dr.bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT : HID_REQ_GET_REPORT;
+	hid->dr.wValue = ((report->type + 1) << 8) | report->id;
+	hid->dr.wIndex = cpu_to_le16(hid->ifnum);
+	hid->dr.wLength = cpu_to_le16(hid->urbctrl->transfer_buffer_length);
+
+	if (usb_submit_urb(hid->urbctrl)) {
+		err("usb_submit_urb(ctrl) failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Output interrupt completion handler.
+ */
+
+static void hid_irq_out(struct urb *urb)
+{
+	struct hid_device *hid = urb->context;
+	unsigned long flags;
+
+	if (urb->status)
+		warn("output irq status %d received", urb->status);
+
+	spin_lock_irqsave(&hid->outlock, flags);
+
+	hid->outtail = (hid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);
+
+	if (hid->outhead != hid->outtail) {
+		hid_submit_out(hid);
+		spin_unlock_irqrestore(&hid->outlock, flags);
+		return;
+	}
+
+	clear_bit(HID_OUT_RUNNING, &hid->iofl);
+
+	spin_unlock_irqrestore(&hid->outlock, flags);
+
+	wake_up(&hid->wait);
+}
+
+/*
+ * Control pipe completion handler.
+ */
+
 static void hid_ctrl(struct urb *urb)
 {
 	struct hid_device *hid = urb->context;
+	unsigned long flags;
 
 	if (urb->status)
 		warn("ctrl urb status %d received", urb->status);
 
-	hid->outtail = (hid->outtail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
+	spin_lock_irqsave(&hid->ctrllock, flags);
 
-	if (hid->outhead != hid->outtail)
-		hid_submit_out(hid);
+	if (hid->ctrl[hid->ctrltail].dir == USB_DIR_IN) 
+		hid_input_report(hid->ctrl[hid->ctrltail].report->type, urb);
+
+	hid->ctrltail = (hid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
+
+	if (hid->ctrlhead != hid->ctrltail) {
+		hid_submit_ctrl(hid);
+		spin_unlock_irqrestore(&hid->ctrllock, flags);
+		return;
+	}
+
+	clear_bit(HID_CTRL_RUNNING, &hid->iofl);
+
+	spin_unlock_irqrestore(&hid->ctrllock, flags);
+
+	wake_up(&hid->wait);
 }
 
-void hid_write_report(struct hid_device *hid, struct hid_report *report)
+void hid_submit_report(struct hid_device *hid, struct hid_report *report, unsigned char dir)
 {
-	hid_output_report(report, hid->out[hid->outhead].buffer);
+	int head;
+	unsigned long flags;
 
-	hid->out[hid->outhead].dr.wValue = cpu_to_le16(0x200 | report->id);
-	hid->out[hid->outhead].dr.wLength = cpu_to_le16((report->size + 7) >> 3);
+	if (hid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {
 
-	hid->outhead = (hid->outhead + 1) & (HID_CONTROL_FIFO_SIZE - 1);
+		spin_lock_irqsave(&hid->outlock, flags);
 
-	if (hid->outhead == hid->outtail)
-		hid->outtail = (hid->outtail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
+		if ((head = (hid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == hid->outtail) {
+			spin_unlock_irqrestore(&hid->outlock, flags);
+			warn("output queue full");
+			return;
+		}
 
-	if (hid->urbout.status != -EINPROGRESS)
-		hid_submit_out(hid);
+		hid->out[hid->outhead] = report;
+		hid->outhead = head;
+
+		if (!test_and_set_bit(HID_OUT_RUNNING, &hid->iofl))
+			hid_submit_out(hid);
+
+		spin_unlock_irqrestore(&hid->outlock, flags);
+		return;
+	}
+
+	spin_lock_irqsave(&hid->ctrllock, flags);
+
+	if ((head = (hid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == hid->ctrltail) {
+		spin_unlock_irqrestore(&hid->ctrllock, flags);
+		warn("control queue full");
+		return;
+	}
+
+	hid->ctrl[hid->ctrlhead].report = report;
+	hid->ctrl[hid->ctrlhead].dir = dir;
+	hid->ctrlhead = head;
+
+	if (!test_and_set_bit(HID_CTRL_RUNNING, &hid->iofl))
+		hid_submit_ctrl(hid);
+
+	spin_unlock_irqrestore(&hid->ctrllock, flags);
+}
+
+int hid_wait_io(struct hid_device *hid)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int timeout = 10*HZ;
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&hid->wait, &wait);
+
+	while (timeout && (test_bit(HID_CTRL_RUNNING, &hid->iofl) ||
+			   test_bit(HID_OUT_RUNNING, &hid->iofl)))
+		timeout = schedule_timeout(timeout);
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&hid->wait, &wait);
+
+	if (!timeout) {
+		dbg("timeout waiting for ctrl or out queue to clear");
+		return -1;
+	}
+
+	return 0;
+}
+#define USB_CTRL_GET_TIMEOUT 5
+static int hid_get_class_descriptor(struct usb_device *dev, int ifnum,
+		unsigned char type, void *buf, int size)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+		USB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,
+		(type << 8), ifnum, buf, size, HZ * USB_CTRL_GET_TIMEOUT);
 }
 
 int hid_open(struct hid_device *hid)
@@ -1035,9 +1182,9 @@
 	if (hid->open++)
 		return 0;
 
-	hid->urb.dev = hid->dev;
+	hid->urbin->dev = hid->dev;
 
-	if (usb_submit_urb(&hid->urb))
+	if (usb_submit_urb(hid->urbin))
 		return -EIO;
 
 	return 0;
@@ -1046,81 +1193,83 @@
 void hid_close(struct hid_device *hid)
 {
 	if (!--hid->open)
-		usb_unlink_urb(&hid->urb);
+		usb_unlink_urb(hid->urbin);
 }
 
 /*
- * Initialize all readable reports
+ * Initialize all reports
  */
+#define USB_CTRL_SET_TIMEOUT 5
 void hid_init_reports(struct hid_device *hid)
 {
-	int i;
-	struct hid_report *report;
 	struct hid_report_enum *report_enum;
+	struct hid_report *report;
 	struct list_head *list;
+	int len;
+	int err, ret;
 
-	for (i = 0; i < HID_REPORT_TYPES; i++) {
-		if (i == HID_FEATURE_REPORT || i == HID_INPUT_REPORT) {
-			report_enum = hid->report_enum + i;
-			list = report_enum->report_list.next;
-			while (list != &report_enum->report_list) {
-				report = (struct hid_report *) list;
-				hid_read_report(hid, report);
-				usb_set_idle(hid->dev, hid->ifnum, 0, report->id);
-				list = list->next;
-			}
-		}
+	report_enum = hid->report_enum + HID_INPUT_REPORT;
+	list = report_enum->report_list.next;
+	while (list != &report_enum->report_list) {
+		report = (struct hid_report *) list;
+		hid_submit_report(hid, report, USB_DIR_IN);
+		list = list->next;
+	}
+
+	report_enum = hid->report_enum + HID_FEATURE_REPORT;
+	list = report_enum->report_list.next;
+	while (list != &report_enum->report_list) {
+		report = (struct hid_report *) list;
+		hid_submit_report(hid, report, USB_DIR_IN);
+		list = list->next;
+	}
+
+	err = 0;
+	while ((ret = hid_wait_io(hid))) {
+		err |= ret;
+		if (test_bit(HID_CTRL_RUNNING, &hid->iofl))
+			usb_unlink_urb(hid->urbctrl);
+		if (test_bit(HID_OUT_RUNNING, &hid->iofl))
+			usb_unlink_urb(hid->urbout);
+	}
+
+	if (err)
+		warn("timeout initializing reports\n");
+
+	report_enum = hid->report_enum + HID_INPUT_REPORT;
+	list = report_enum->report_list.next;
+	while (list != &report_enum->report_list) {
+		report = (struct hid_report *) list;
+		len = ((report->size - 1) >> 3) + 1 + report_enum->numbered;
+		if (len > hid->urbin->transfer_buffer_length)
+			hid->urbin->transfer_buffer_length = len < HID_BUFFER_SIZE ? len : HID_BUFFER_SIZE;
+		usb_control_msg(hid->dev, usb_sndctrlpipe(hid->dev, 0),
+			0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE, report->id,
+			hid->ifnum, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+		list = list->next;
 	}
 }
 
 #define USB_VENDOR_ID_WACOM		0x056a
-#define USB_DEVICE_ID_WACOM_PENPARTNER	0x0000
 #define USB_DEVICE_ID_WACOM_GRAPHIRE	0x0010
 #define USB_DEVICE_ID_WACOM_INTUOS	0x0020
-#define USB_DEVICE_ID_WACOM_PL		0x0030
-#define USB_DEVICE_ID_WACOM_INTUOS2	0x0041
-
-#define USB_VENDOR_ID_ATEN		0x0557
-#define USB_DEVICE_ID_ATEN_UC100KM	0x2004
-#define USB_DEVICE_ID_ATEN_CS124U	0x2202
-#define USB_DEVICE_ID_ATEN_2PORTKVM	0x2204
-#define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
 
 #define USB_VENDOR_ID_GRIFFIN		0x077d
-#define USB_DEVICE_ID_POWERMATE		0x0410 /* Griffin PowerMate */
-#define USB_DEVICE_ID_SOUNDKNOB		0x04AA /* Griffin SoundKnob */
+#define USB_DEVICE_ID_POWERMATE		0x0410
+#define USB_DEVICE_ID_SOUNDKNOB		0x04AA
 
 struct hid_blacklist {
 	__u16 idVendor;
 	__u16 idProduct;
-	unsigned quirks;
 } hid_blacklist[] = {
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PENPARTNER, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE + 1, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE + 2, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 1, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 2, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 3, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 4, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL + 1, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL + 2, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL + 3, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL + 4, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_PL + 5, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS2, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS2 + 1, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS2 + 2, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS2 + 3, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS2 + 4, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_UC100KM, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS124U, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVM, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE, HID_QUIRK_IGNORE },
-	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB, HID_QUIRK_IGNORE },
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE },
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS },
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 1},
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 2},
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 3},
+	{ USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS + 4},
+	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE },
+	{ USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB },
 	{ 0, 0 }
 };
 
@@ -1129,26 +1278,23 @@
 	struct usb_interface_descriptor *interface = dev->actconfig->interface[ifnum].altsetting + 0;
 	struct hid_descriptor *hdesc;
 	struct hid_device *hid;
-	unsigned quirks = 0, rsize = 0;
+	unsigned rsize = 0;
+	u8 *rdesc;
 	char *buf;
 	int n;
 
 	for (n = 0; hid_blacklist[n].idVendor; n++)
 		if ((hid_blacklist[n].idVendor == dev->descriptor.idVendor) &&
-			(hid_blacklist[n].idProduct == dev->descriptor.idProduct))
-				quirks = hid_blacklist[n].quirks;
-
-	if (quirks & HID_QUIRK_IGNORE)
-		return NULL;
+			(hid_blacklist[n].idProduct == dev->descriptor.idProduct)) return NULL;
 
-	if (usb_get_extra_descriptor(interface, USB_DT_HID, &hdesc) && ((!interface->bNumEndpoints) ||
-		usb_get_extra_descriptor(&interface->endpoint[0], USB_DT_HID, &hdesc))) {
+	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) && ((!interface->bNumEndpoints) ||
+		usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
 			dbg("class descriptor not present\n");
 			return NULL;
 	}
 
 	for (n = 0; n < hdesc->bNumDescriptors; n++)
-		if (hdesc->desc[n].bDescriptorType == USB_DT_REPORT)
+		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
 
 	if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {
@@ -1156,118 +1302,158 @@
 		return NULL;
 	}
 
-	{
-		__u8 rdesc[rsize];
+	if (!(rdesc = kmalloc(rsize, GFP_KERNEL))) {
+		dbg("couldn't allocate rdesc memory");
+		return NULL;
+	}
 
-		if ((n = usb_get_class_descriptor(dev, interface->bInterfaceNumber, USB_DT_REPORT, 0, rdesc, rsize)) < 0) {
-			dbg("reading report descriptor failed");
-			return NULL;
-		}
+	if ((n = hid_get_class_descriptor(dev, interface->bInterfaceNumber, HID_DT_REPORT, rdesc, rsize)) < 0) {
+		dbg("reading report descriptor failed");
+		kfree(rdesc);
+		return NULL;
+	}
 
 #ifdef DEBUG_DATA
-		printk(KERN_DEBUG __FILE__ ": report descriptor (size %u, read %d) = ", rsize, n);
-		for (n = 0; n < rsize; n++)
-			printk(" %02x", (unsigned) rdesc[n]);
-		printk("\n");
+	printk(KERN_DEBUG __FILE__ ": report descriptor (size %u, read %d) = ", rsize, n);
+	for (n = 0; n < rsize; n++)
+		printk(" %02x", (unsigned) rdesc[n]);
+	printk("\n");
 #endif
 
-		if (!(hid = hid_parse_report(rdesc, rsize))) {
-			dbg("parsing report descriptor failed");
-			return NULL;
-		}
+	if (!(hid = hid_parse_report(rdesc, rsize))) {
+		dbg("parsing report descriptor failed");
+		kfree(rdesc);
+		return NULL;
 	}
 
-	hid->quirks = quirks;
+	kfree(rdesc);
 
 	for (n = 0; n < interface->bNumEndpoints; n++) {
 
 		struct usb_endpoint_descriptor *endpoint = &interface->endpoint[n];
-		int pipe, maxp;
+		int pipe;
 
 		if ((endpoint->bmAttributes & 3) != 3)		/* Not an interrupt endpoint */
 			continue;
 
-		if (!(endpoint->bEndpointAddress & 0x80))	/* Not an input endpoint */
-			continue;
-
-		pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
-		maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
-
-		FILL_INT_URB(&hid->urb, dev, pipe, hid->buffer, maxp > 32 ? 32 : maxp, hid_irq, hid, endpoint->bInterval);
-
-		break;
+		if (endpoint->bEndpointAddress & USB_DIR_IN) {
+			if (hid->urbin)
+				continue;
+			if (!(hid->urbin = usb_alloc_urb(0)))
+				goto fail;
+			pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
+			FILL_INT_URB(hid->urbin, dev, pipe, hid->inbuf, 0, hid_irq_in, hid, endpoint->bInterval);
+		} else {
+			if (hid->urbout)
+				continue;
+			if (!(hid->urbout = usb_alloc_urb(0)))
+				goto fail;
+			pipe = usb_sndbulkpipe(dev, endpoint->bEndpointAddress);
+			FILL_BULK_URB(hid->urbout, dev, pipe, hid->outbuf, 0, hid_irq_out, hid);
+			hid->urbout->transfer_flags |= USB_ASYNC_UNLINK;
+		}
 	}
 
-	if (n == interface->bNumEndpoints) {
-		dbg("couldn't find an input interrupt endpoint");
-		hid_free_device(hid);
-		return NULL;
+	if (!hid->urbin) {
+		err("couldn't find an input interrupt endpoint");
+		goto fail;
 	}
 
+	init_waitqueue_head(&hid->wait);
+	
+	hid->outlock = SPIN_LOCK_UNLOCKED;
+	hid->ctrllock = SPIN_LOCK_UNLOCKED;
+
 	hid->version = hdesc->bcdHID;
 	hid->country = hdesc->bCountryCode;
 	hid->dev = dev;
 	hid->ifnum = interface->bInterfaceNumber;
 
-	for (n = 0; n < HID_CONTROL_FIFO_SIZE; n++) {
-		hid->out[n].dr.bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;
-		hid->out[n].dr.bRequest = USB_REQ_SET_REPORT;
-		hid->out[n].dr.wIndex = cpu_to_le16(hid->ifnum);
-	}
-
 	hid->name[0] = 0;
 
-	if (!(buf = kmalloc(63, GFP_KERNEL)))
-		return NULL;
+	if (!(buf = kmalloc(64, GFP_KERNEL)))
+		goto fail;
 
-	if (usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0) {
+	if (usb_string(dev, dev->descriptor.iManufacturer, buf, 64) > 0) {
 		strcat(hid->name, buf);
-		if (usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		if (usb_string(dev, dev->descriptor.iProduct, buf, 64) > 0)
 			sprintf(hid->name, "%s %s", hid->name, buf);
 	} else
 		sprintf(hid->name, "%04x:%04x", dev->descriptor.idVendor, dev->descriptor.idProduct);
 
-	kfree(buf);
+	usb_make_path(dev, buf, 63);
+	sprintf(hid->phys, "%s/input%d", buf, ifnum);
 
-	FILL_CONTROL_URB(&hid->urbout, dev, usb_sndctrlpipe(dev, 0),
-		(void*) &hid->out[0].dr, hid->out[0].buffer, 1, hid_ctrl, hid);
+	if (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)
+		hid->uniq[0] = 0;
 
-/*
- * Some devices don't like this and crash. I don't know of any devices
- * needing this, so it is disabled for now.
- */
+	kfree(buf);
 
-#if 0
-	if (interface->bInterfaceSubClass == 1)
-		usb_set_protocol(dev, hid->ifnum, 1);
-#endif
+	hid->urbctrl = usb_alloc_urb(0);
+	FILL_CONTROL_URB(hid->urbctrl, dev, 0, (void*) &hid->dr, hid->ctrlbuf, 1, hid_ctrl, hid);
+	hid->urbctrl->transfer_flags |= USB_ASYNC_UNLINK;
 
 	return hid;
+
+fail:
+	hid_free_device(hid);
+	if (hid->urbin) usb_free_urb(hid->urbin);
+	if (hid->urbout) usb_free_urb(hid->urbout);
+	if (hid->urbctrl) usb_free_urb(hid->urbctrl);
+
+	return NULL;
 }
 
 static void* hid_probe(struct usb_device *dev, unsigned int ifnum,
 		       const struct usb_device_id *id)
 {
 	struct hid_device *hid;
+	char path[64];
 	int i;
 	char *c;
 
 	dbg("HID probe called for ifnum %d", ifnum);
 
-	if (!(hid = usb_hid_configure(dev, ifnum)))
+	if (!(hid = usb_hid_configure(dev, ifnum))) {
+		err("usb_hid_configure failed");
 		return NULL;
+	}
 
 	hid_init_reports(hid);
 	hid_dump_device(hid);
 
+#ifdef CONFIG_HID_FF
+	switch (hid_ff_init(hid)) {
+	case 0:
+		break;
+
+	case -ENOSYS:
+		info("No force feedback support for this hid device");
+		break;
+
+	default:
+		err("hid_ff_init failed");
+		hid_free_device(hid);
+		return NULL;
+	}
+#endif
+
 	if (!hidinput_connect(hid))
 		hid->claimed |= HID_CLAIMED_INPUT;
+#ifdef CONFIG_USB_HIDDEV
 	if (!hiddev_connect(hid))
 		hid->claimed |= HID_CLAIMED_HIDDEV;
+#endif
+
+	if (!hid->claimed) {
+		hid_free_device(hid);
+		return NULL;
+	}
+
 	printk(KERN_INFO);
 
 	if (hid->claimed & HID_CLAIMED_INPUT)
-		printk("input%d", hid->input.number);
+		printk("input");
 	if (hid->claimed == (HID_CLAIMED_INPUT | HID_CLAIMED_HIDDEV))
 		printk(",");
 	if (hid->claimed & HID_CLAIMED_HIDDEV)
@@ -1280,9 +1466,10 @@
 			break;
 		}
 
-	printk(": USB HID v%x.%02x %s [%s] on usb%d:%d.%d\n",
-		hid->version >> 8, hid->version & 0xff, c, hid->name,
-		dev->bus->busnum, dev->devnum, ifnum);
+	usb_make_path(dev, path, 63);
+
+	printk(": USB HID v%x.%02x %s [%s] on %s\n",
+		hid->version >> 8, hid->version & 0xff, c, hid->name, path);
 
 	return hid;
 }
@@ -1291,12 +1478,22 @@
 {
 	struct hid_device *hid = ptr;
 
-	dbg("cleanup called");
-	usb_unlink_urb(&hid->urb);
+	usb_unlink_urb(hid->urbin);
+	usb_unlink_urb(hid->urbout);
+	usb_unlink_urb(hid->urbctrl);
+
 	if (hid->claimed & HID_CLAIMED_INPUT)
 		hidinput_disconnect(hid);
+#ifdef CONFIG_USB_HIDDEV
 	if (hid->claimed & HID_CLAIMED_HIDDEV)
 		hiddev_disconnect(hid);
+#endif
+
+	usb_free_urb(hid->urbin);
+	usb_free_urb(hid->urbctrl);
+	if (hid->urbout)
+		usb_free_urb(hid->urbout);
+
 	hid_free_device(hid);
 }
 
@@ -1317,23 +1514,26 @@
 
 static int __init hid_init(void)
 {
+#ifdef CONFIG_USB_HIDDEV
 	hiddev_init();
+#endif
 	usb_register(&hid_driver);
-	info(DRIVER_VERSION " " DRIVER_AUTHOR);
-	info(DRIVER_DESC);
+	info(DRIVER_VERSION ":" DRIVER_DESC);
 
 	return 0;
 }
 
 static void __exit hid_exit(void)
 {
+#ifdef CONFIG_USB_HIDDEV
 	hiddev_exit();
+#endif
 	usb_deregister(&hid_driver);
 }
 
 module_init(hid_init);
 module_exit(hid_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
-MODULE_LICENSE("GPL");
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid-debug.h linux-modified/drivers/usb/hid-debug.h
--- linux-vanilla/drivers/usb/hid-debug.h	Thu Sep 13 00:34:06 2001
+++ linux-modified/drivers/usb/hid-debug.h	Mon Jan  6 16:48:21 2003
@@ -1,12 +1,10 @@
 /*
- * $Id$
+ * $Id$
  *
  *  (c) 1999 Andreas Gal		<gal@cs.uni-magdeburg.de>
- *  (c) 2000-2001 Vojtech Pavlik	<vojtech@suse.cz>
+ *  (c) 2000-2001 Vojtech Pavlik	<vojtech@ucw.cz>
  *
  *  Some debug stuff for the HID parser.
- *
- *  Sponsored by SuSE
  */
 
 /*
@@ -25,8 +23,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 struct hid_usage_entry {
@@ -36,6 +34,7 @@
 };
 
 static struct hid_usage_entry hid_usage_table[] = {
+  {  0,      0, "Undefined" },
   {  1,      0, "GenericDesktop" },
     {0, 0x01, "Pointer"},
     {0, 0x02, "Mouse"},
@@ -87,6 +86,7 @@
   {  7, 0, "Keyboard" },
   {  8, 0, "LED" },
   {  9, 0, "Button" },
+  { 10, 0, "Ordinal" },
   { 12, 0, "Hotkey" },
   { 13, 0, "Digitizers" },
     {0, 0x01, "Digitizer"},
@@ -112,6 +112,112 @@
     {0, 0x45, "Eraser"},
     {0, 0x46, "TabletPick"},
   { 15, 0, "PhysicalInterfaceDevice" },
+    {0, 0x00, "Undefined"},
+    {0, 0x01, "Physical_Interface_Device"},
+      {0, 0x20, "Normal"},
+    {0, 0x21, "Set_Effect_Report"},
+      {0, 0x22, "Effect_Block_Index"},
+      {0, 0x23, "Parameter_Block_Offset"},
+      {0, 0x24, "ROM_Flag"},
+      {0, 0x25, "Effect_Type"},
+        {0, 0x26, "ET_Constant_Force"},
+        {0, 0x27, "ET_Ramp"},
+        {0, 0x28, "ET_Custom_Force_Data"},
+        {0, 0x30, "ET_Square"},
+        {0, 0x31, "ET_Sine"},
+        {0, 0x32, "ET_Triangle"},
+        {0, 0x33, "ET_Sawtooth_Up"},
+        {0, 0x34, "ET_Sawtooth_Down"},
+        {0, 0x40, "ET_Spring"},
+        {0, 0x41, "ET_Damper"},
+        {0, 0x42, "ET_Inertia"},
+        {0, 0x43, "ET_Friction"},
+      {0, 0x50, "Duration"},
+      {0, 0x51, "Sample_Period"},
+      {0, 0x52, "Gain"},
+      {0, 0x53, "Trigger_Button"},
+      {0, 0x54, "Trigger_Repeat_Interval"},
+      {0, 0x55, "Axes_Enable"},
+        {0, 0x56, "Direction_Enable"},
+      {0, 0x57, "Direction"},
+      {0, 0x58, "Type_Specific_Block_Offset"},
+        {0, 0x59, "Block_Type"},
+        {0, 0x5A, "Set_Envelope_Report"},
+          {0, 0x5B, "Attack_Level"},
+          {0, 0x5C, "Attack_Time"},
+          {0, 0x5D, "Fade_Level"},
+          {0, 0x5E, "Fade_Time"},
+        {0, 0x5F, "Set_Condition_Report"},
+        {0, 0x60, "CP_Offset"},
+        {0, 0x61, "Positive_Coefficient"},
+        {0, 0x62, "Negative_Coefficient"},
+        {0, 0x63, "Positive_Saturation"},
+        {0, 0x64, "Negative_Saturation"},
+        {0, 0x65, "Dead_Band"},
+      {0, 0x66, "Download_Force_Sample"},
+      {0, 0x67, "Isoch_Custom_Force_Enable"},
+      {0, 0x68, "Custom_Force_Data_Report"},
+        {0, 0x69, "Custom_Force_Data"},
+        {0, 0x6A, "Custom_Force_Vendor_Defined_Data"},
+      {0, 0x6B, "Set_Custom_Force_Report"},
+        {0, 0x6C, "Custom_Force_Data_Offset"},
+        {0, 0x6D, "Sample_Count"},
+      {0, 0x6E, "Set_Periodic_Report"},
+        {0, 0x6F, "Offset"},
+        {0, 0x70, "Magnitude"},
+        {0, 0x71, "Phase"},
+        {0, 0x72, "Period"},
+      {0, 0x73, "Set_Constant_Force_Report"},
+        {0, 0x74, "Set_Ramp_Force_Report"},
+        {0, 0x75, "Ramp_Start"},
+        {0, 0x76, "Ramp_End"},
+      {0, 0x77, "Effect_Operation_Report"},
+        {0, 0x78, "Effect_Operation"},
+          {0, 0x79, "Op_Effect_Start"},
+          {0, 0x7A, "Op_Effect_Start_Solo"},
+          {0, 0x7B, "Op_Effect_Stop"},
+          {0, 0x7C, "Loop_Count"},
+      {0, 0x7D, "Device_Gain_Report"},
+        {0, 0x7E, "Device_Gain"},
+    {0, 0x7F, "PID_Pool_Report"},
+      {0, 0x80, "RAM_Pool_Size"},
+      {0, 0x81, "ROM_Pool_Size"},
+      {0, 0x82, "ROM_Effect_Block_Count"},
+      {0, 0x83, "Simultaneous_Effects_Max"},
+      {0, 0x84, "Pool_Alignment"},
+    {0, 0x85, "PID_Pool_Move_Report"},
+      {0, 0x86, "Move_Source"},
+      {0, 0x87, "Move_Destination"},
+      {0, 0x88, "Move_Length"},
+    {0, 0x89, "PID_Block_Load_Report"},
+      {0, 0x8B, "Block_Load_Status"},
+      {0, 0x8C, "Block_Load_Success"},
+      {0, 0x8D, "Block_Load_Full"},
+      {0, 0x8E, "Block_Load_Error"},
+      {0, 0x8F, "Block_Handle"},
+      {0, 0x90, "PID_Block_Free_Report"},
+      {0, 0x91, "Type_Specific_Block_Handle"},
+    {0, 0x92, "PID_State_Report"},
+      {0, 0x94, "Effect_Playing"},
+      {0, 0x95, "PID_Device_Control_Report"},
+        {0, 0x96, "PID_Device_Control"},
+        {0, 0x97, "DC_Enable_Actuators"},
+        {0, 0x98, "DC_Disable_Actuators"},
+        {0, 0x99, "DC_Stop_All_Effects"},
+        {0, 0x9A, "DC_Device_Reset"},
+        {0, 0x9B, "DC_Device_Pause"},
+        {0, 0x9C, "DC_Device_Continue"},
+      {0, 0x9F, "Device_Paused"},
+      {0, 0xA0, "Actuators_Enabled"},
+      {0, 0xA4, "Safety_Switch"},
+      {0, 0xA5, "Actuator_Override_Switch"},
+      {0, 0xA6, "Actuator_Power"},
+    {0, 0xA7, "Start_Delay"},
+    {0, 0xA8, "Parameter_Block_Size"},
+    {0, 0xA9, "Device_Managed_Pool"},
+    {0, 0xAA, "Shared_Parameter_Blocks"},
+    {0, 0xAB, "Create_New_Effect_Report"},
+    {0, 0xAC, "RAM_Pool_Available"},
   { 0, 0, NULL }
 };
 
@@ -176,7 +282,50 @@
 		tab(n); printk("Unit Exponent(%d)\n", field->unit_exponent);
 	}
 	if (field->unit) {
-		tab(n); printk("Unit(%u)\n", field->unit);
+		char *systems[5] = { "None", "SI Linear", "SI Rotation", "English Linear", "English Rotation" };
+		char *units[5][8] = {
+			{ "None", "None", "None", "None", "None", "None", "None", "None" },
+			{ "None", "Centimeter", "Gram", "Seconds", "Kelvin",     "Ampere", "Candela", "None" },
+			{ "None", "Radians",    "Gram", "Seconds", "Kelvin",     "Ampere", "Candela", "None" },
+			{ "None", "Inch",       "Slug", "Seconds", "Fahrenheit", "Ampere", "Candela", "None" },
+			{ "None", "Degrees",    "Slug", "Seconds", "Fahrenheit", "Ampere", "Candela", "None" }
+		};
+
+		int i;
+		int sys;
+                __u32 data = field->unit;
+
+		/* First nibble tells us which system we're in. */
+		sys = data & 0xf;
+		data >>= 4;
+
+		if(sys > 4) {
+			tab(n); printk("Unit(Invalid)\n");
+		}
+		else {
+			int earlier_unit = 0;
+
+			tab(n); printk("Unit(%s : ", systems[sys]);
+
+			for (i=1 ; i<sizeof(__u32)*2 ; i++) {
+				char nibble = data & 0xf;
+				data >>= 4;
+				if (nibble != 0) {
+					if(earlier_unit++ > 0)
+						printk("*");
+					printk("%s", units[sys][i]);
+					if(nibble != 1) {
+						/* This is a _signed_ nibble(!) */
+	
+						int val = nibble & 0x7;
+						if(nibble & 0x08)
+							val = -((0x7 & ~val) +1);
+						printk("^%d", val);
+					}
+				}
+			}
+			printk(")\n");
+		}
 	}
 	tab(n); printk("Report Size(%u)\n", field->report_size);
 	tab(n); printk("Report Count(%u)\n", field->report_count);
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid-ff.c linux-modified/drivers/usb/hid-ff.c
--- linux-vanilla/drivers/usb/hid-ff.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/usb/hid-ff.c	Mon Jan  6 16:48:21 2003
@@ -0,0 +1,69 @@
+/*
+ *  Force feedback support for hid devices.
+ *  Not all hid devices use the same protocol. For example, some use PID,
+ *  other use their own proprietary procotol.
+ *
+ *  Copyright (c) 2002 Johann Deneux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so by
+ * e-mail - mail your message to <deneux@ifrance.com>
+ */
+
+#include <linux/input.h>
+
+#define DEBUG
+#include <linux/usb.h>
+
+#include "hid.h"
+
+/* Drivers' initializing functions */
+extern int hid_lgff_init(struct hid_device* hid);
+extern int hid_pid_init(struct hid_device* hid);
+
+/* Each hid force feedback driver must provide an init function.
+   It must return 1 if the driver does not handle this device,
+   0 if it could and the initialization itself went smoothly,
+   <0 if the driver should have been able to handle the device, but failed
+*/
+static int (*inits[])(struct hid_device*) = {
+#ifdef CONFIG_LOGITECH_FF
+	hid_lgff_init,
+#endif
+#ifdef CONFIG_HID_PID
+	hid_pid_init,
+#endif
+	NULL
+};
+
+int hid_ff_init(struct hid_device* hid)
+{
+	int i;
+	int status;
+
+	for (i=0; inits[i]; ++i) {
+		switch (status = inits[i](hid)) {
+		case 0: return 0;  // Device handled and init ok
+		case 1: break;     // Device not handled
+		default: return status; // Device handled, init failed
+		}
+	}
+
+	dbg("hid_ff_init could not find initializer");
+	return -ENOSYS;
+}
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid-input.c linux-modified/drivers/usb/hid-input.c
--- linux-vanilla/drivers/usb/hid-input.c	Sun Nov 11 20:09:37 2001
+++ linux-modified/drivers/usb/hid-input.c	Mon Jan  6 16:48:21 2003
@@ -1,11 +1,9 @@
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *
- *  USB HID to Linux Input mapping module
- *
- *  Sponsored by SuSE
+ *  USB HID to Linux Input mapping
  */
 
 /*
@@ -24,13 +22,12 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/input.h>
 #include <linux/usb.h>
@@ -61,12 +58,13 @@
 static struct {
 	__s32 x;
 	__s32 y;
-}  hid_hat_to_axis[] = {{0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+}  hid_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
 
 static void hidinput_configure_usage(struct hid_device *device, struct hid_field *field, struct hid_usage *usage)
 {
 	struct input_dev *input = &device->input;
 	int max;
+	int is_abs = 0;
 	unsigned long *bit;
 
 	switch (usage->hid & HID_USAGE_PAGE) {
@@ -198,6 +196,7 @@
 
 		case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
 
+			set_bit(EV_REP, input->evbit);
 			switch (usage->hid & HID_USAGE) {
 				case 0x000: usage->code = 0; break;
 				case 0x034: usage->code = KEY_SLEEP;		break;
@@ -205,14 +204,21 @@
 				case 0x08a: usage->code = KEY_WWW;		break;
 				case 0x095: usage->code = KEY_HELP;		break;
 
+				case 0x0b0: usage->code = KEY_PLAY;		break;
+				case 0x0b1: usage->code = KEY_PAUSE;		break;
+				case 0x0b2: usage->code = KEY_RECORD;		break;
+				case 0x0b3: usage->code = KEY_FASTFORWARD;	break;
 				case 0x0b4: usage->code = KEY_REWIND;		break;
 				case 0x0b5: usage->code = KEY_NEXTSONG;		break;
 				case 0x0b6: usage->code = KEY_PREVIOUSSONG;	break;
 				case 0x0b7: usage->code = KEY_STOPCD;		break;
 				case 0x0b8: usage->code = KEY_EJECTCD;		break;
 				case 0x0cd: usage->code = KEY_PLAYPAUSE;	break;
-
+			        case 0x0e0: is_abs = 1;
+					    usage->code = ABS_VOLUME;
+					    break;
 				case 0x0e2: usage->code = KEY_MUTE;		break;
+				case 0x0e5: usage->code = KEY_BASSBOOST;	break;
 				case 0x0e9: usage->code = KEY_VOLUMEUP;		break;
 				case 0x0ea: usage->code = KEY_VOLUMEDOWN;	break;
 
@@ -220,7 +226,6 @@
 				case 0x18a: usage->code = KEY_MAIL;		break;
 				case 0x192: usage->code = KEY_CALC;		break;
 				case 0x194: usage->code = KEY_FILE;		break;
-
 				case 0x21a: usage->code = KEY_UNDO;		break;
 				case 0x21b: usage->code = KEY_COPY;		break;
 				case 0x21c: usage->code = KEY_CUT;		break;
@@ -235,6 +240,34 @@
 				case 0x22a: usage->code = KEY_BOOKMARKS;	break;
 
 				default:    usage->code = KEY_UNKNOWN;		break;
+			}
+
+			if (is_abs) {
+			        usage->type = EV_ABS; bit = input->absbit; max = ABS_MAX;
+			} else  {
+				usage->type = EV_KEY; bit = input->keybit; max = KEY_MAX;
+			}
+			break;
+
+		case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
+
+			set_bit(EV_REP, input->evbit);
+			switch (usage->hid & HID_USAGE) {
+			        case 0x021: usage->code = KEY_PRINT;            break;
+				case 0x070: usage->code = KEY_HP;		break;
+				case 0x071: usage->code = KEY_CAMERA;		break;
+				case 0x072: usage->code = KEY_SOUND;		break;
+				case 0x073: usage->code = KEY_QUESTION;		break;
+
+				case 0x080: usage->code = KEY_EMAIL;		break;
+				case 0x081: usage->code = KEY_CHAT;		break;
+				case 0x082: usage->code = KEY_SEARCH;		break;
+				case 0x083: usage->code = KEY_CONNECT;	        break;
+				case 0x084: usage->code = KEY_FINANCE;		break;
+				case 0x085: usage->code = KEY_SPORT;		break;
+				case 0x086: usage->code = KEY_SHOP;	        break;
+
+				default:    usage->code = KEY_UNKNOWN;		break;
 
 			}
 
@@ -344,16 +377,28 @@
 static int hidinput_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
 	struct hid_device *hid = dev->private;
-	struct hid_field *field = NULL;
-	int offset;
 
-	if ((offset = hid_find_field(hid, type, code, &field)) == -1) {
-		warn("event field not found");
-		return -1;
+	warn("hid input event");
+
+#ifdef CONFIG_HID_FF
+	if (type == EV_FF) {
+		return hid_ff_event(hid, dev, type, code, value);
 	}
+#else
+	if (0) {}
+#endif		
+	else {
+		struct hid_field *field = NULL;
+		int offset;
+
+		if ((offset = hid_find_field(hid, type, code, &field)) == -1) {
+			warn("event field not found");
+			return -1;
+		}
 
-	hid_set_field(field, offset, value);
-	hid_write_report(hid, field->report);
+		hid_set_field(field, offset, value);
+		hid_submit_report(hid, field->report, USB_DIR_OUT);
+	}
 
 	return 0;
 }
@@ -361,12 +406,22 @@
 static int hidinput_open(struct input_dev *dev)
 {
 	struct hid_device *hid = dev->private;
+/*
+#ifdef CONFIG_HID_FF
+	hid_ff_open(hid);
+#endif
+*/
 	return hid_open(hid);
 }
 
 static void hidinput_close(struct input_dev *dev)
 {
 	struct hid_device *hid = dev->private;
+/*
+#ifdef CONFIG_HID_FF
+	hid_ff_close(hid);
+#endif
+*/
 	hid_close(hid);
 }
 
@@ -395,8 +450,9 @@
 	hid->input.event = hidinput_input_event;
 	hid->input.open = hidinput_open;
 	hid->input.close = hidinput_close;
-
 	hid->input.name = hid->name;
+	hid->input.phys = hid->phys;
+	hid->input.uniq = hid->uniq;
 	hid->input.idbus = BUS_USB;
 	hid->input.idvendor = dev->descriptor.idVendor;
 	hid->input.idproduct = dev->descriptor.idProduct;
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid-lgff.c linux-modified/drivers/usb/hid-lgff.c
--- linux-vanilla/drivers/usb/hid-lgff.c	Thu Jan  1 02:00:00 1970
+++ linux-modified/drivers/usb/hid-lgff.c	Sun Mar  9 18:03:20 2003
@@ -0,0 +1,588 @@
+/*
+ * Force feedback support for hid-compliant for some of the devices from
+ * Logitech, namely:
+ * - WingMan Cordless RumblePad
+ * - WingMan Force 3D
+ * - WingMan Strike Force 3D
+ * Other possibly supported devices:
+ * Apparently *not* supported:
+ * - WingMan Formula Force GP
+ * - WingMan RumblePad (ie the non-cordless one)
+ *
+ *  Copyright (c) 2002 Johann Deneux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so by
+ * e-mail - mail your message to <deneux@ifrance.com>
+ */
+
+/* TODO:
+   Support periodic, custom and condition effects.
+   Support gain setting + default spring.
+*/
+
+#include <linux/input.h>
+#include <linux/sched.h>
+
+#define DEBUG
+#include <linux/usb.h>
+
+#include <linux/circ_buf.h>
+
+#include "hid.h"
+#include "fixp-arith.h"
+
+
+/* Periodicity of the update */
+#define PERIOD (HZ/10)
+
+#define RUN_AT(t) (jiffies + (t))
+
+/* Effect status */
+#define EFFECT_STARTED 0     /* Effect is going to play after some time
+				(ff_replay.delay) */
+#define EFFECT_PLAYING 1     /* Effect is being played */
+#define EFFECT_USED    2
+
+// For lgff_device::flags
+#define DEVICE_CLOSING 0     /* The driver is being unitialised */
+
+#define LGFF_EFFECTS 8
+
+struct device_type {
+	u16 idVendor;
+	u16 idProduct;
+	signed short *ff;
+};
+
+struct lgff_effect {
+	pid_t owner;
+
+	struct ff_effect effect;
+
+	unsigned long flags[1];
+	unsigned int count;          /* Number of times left to play */
+	unsigned long started_at;    /* When the effect started to play */
+};
+
+struct lgff_device {
+	struct hid_device* hid;
+
+	struct hid_report* constant;
+	struct hid_report* rumble;
+	struct hid_report* condition;
+
+	struct lgff_effect effects[LGFF_EFFECTS];
+	spinlock_t lock;             /* device-level lock. Having locks on
+					a per-effect basis could be nice, but
+					isn't really necessary */
+
+	unsigned long flags[1];      /* Contains various information about the
+				        state of the driver for this device */	
+
+	struct timer_list timer;
+};
+
+/* Callbacks */
+static void hid_lgff_exit(struct hid_device* hid);
+static int hid_lgff_event(struct hid_device *hid, struct input_dev *input,
+			  unsigned int type, unsigned int code, int value);
+static int hid_lgff_flush(struct input_dev *input, struct file *file);
+static int hid_lgff_upload_effect(struct input_dev *input,
+				  struct ff_effect *effect);
+static int hid_lgff_erase(struct input_dev *input, int id);
+
+/* Local functions */
+static void hid_lgff_input_init(struct hid_device* hid);
+static void hid_lgff_timer(unsigned long timer_data);
+static struct hid_report* hid_lgff_duplicate_report(struct hid_report*);
+static void hid_lgff_delete_report(struct hid_report*);
+
+static signed short ff_rumble[] = {
+	FF_RUMBLE,
+	-1
+};
+
+static signed short ff_joystick[] = {
+	FF_CONSTANT,
+	ABS_X,
+	ABS_Y,
+	-1
+};
+
+static struct device_type devices[] = {
+	{0x046d, 0xc211, ff_rumble},
+	{0x046d, 0xc283, ff_joystick},
+	{0x046d, 0xc285, ff_joystick},
+	{0x0000, 0x0000, ff_joystick}
+};
+
+int hid_lgff_init(struct hid_device* hid)
+{
+	struct lgff_device *private;
+	struct hid_report* report;
+	struct hid_field* field;
+
+	switch (hid->dev->descriptor.idVendor) {
+	case 0x46d: // Logitech
+		switch (hid->dev->descriptor.idProduct) {
+		/* Supported devices */
+		case 0xc211: // Cordless rumblepad
+		case 0xc283: // Force 3D
+		case 0xc285: // Strike Force 3D
+			break;
+		/* Unsupported or unknown devices */
+		default: return 1;
+		} 
+		break;
+
+	case 0x6a3: // Saitek
+		switch (hid->dev->descriptor.idProduct) {
+		case 0xff12: // Cyborg 3D Force
+			break;
+		default: return 1;
+		}
+		break;
+
+	default: return 1;
+	}
+
+	/* Find the report to use */
+	if (list_empty(&hid->report_enum[HID_OUTPUT_REPORT].report_list)) {
+		err("No output report found");
+		return -1;
+	}
+	/* Check that the report looks ok */
+	report = (struct hid_report*)hid->report_enum[HID_OUTPUT_REPORT].report_list.next;
+	if (!report) {
+		err("NULL output report");
+		return -1;
+	}
+	field = report->field[0];
+	if (!field) {
+		err("NULL field");
+		return -1;
+	}
+
+	private = kmalloc(sizeof(struct lgff_device), GFP_KERNEL);
+	if (!private) return -1;
+	memset(private, 0, sizeof(struct lgff_device));
+	hid->ff_private = private;
+
+	/* Input init */
+	hid_lgff_input_init(hid);
+
+
+	private->constant = hid_lgff_duplicate_report(report);
+	if (!private->constant) {
+		kfree(private);
+		return -1;
+	}
+	private->constant->field[0]->value[0] = 0x51;
+	private->constant->field[0]->value[1] = 0x08;
+	private->constant->field[0]->value[2] = 0x7f;
+	private->constant->field[0]->value[3] = 0x7f;
+
+	private->rumble = hid_lgff_duplicate_report(report);
+	if (!private->rumble) {
+		hid_lgff_delete_report(private->constant);
+		kfree(private);
+		return -1;
+	}
+	private->rumble->field[0]->value[0] = 0x03;
+	private->rumble->field[0]->value[1] = 0x42;
+
+
+	private->condition = hid_lgff_duplicate_report(report);
+	if (!private->condition) {
+		hid_lgff_delete_report(private->rumble);
+		hid_lgff_delete_report(private->constant);
+		kfree(private);
+		return -1;
+	}
+
+	private->hid = hid;
+
+	spin_lock_init(&private->lock);
+	init_timer(&private->timer);
+	private->timer.data = (unsigned long)private;
+	private->timer.function = hid_lgff_timer;
+
+	/* Event and exit callbacks */
+	hid->ff_exit = hid_lgff_exit;
+	hid->ff_event = hid_lgff_event;
+
+	/* Start the update task */
+	private->timer.expires = RUN_AT(PERIOD);
+	add_timer(&private->timer);  /*TODO: only run the timer when at least
+				       one effect is playing */
+
+	printk(KERN_INFO "Force feedback for Logitech force feedback devices by Johann Deneux <deneux@ifrance.com>\n");
+
+	return 0;
+}
+
+static struct hid_report* hid_lgff_duplicate_report(struct hid_report* report)
+{
+	struct hid_report* ret;
+
+	ret = kmalloc(sizeof(struct lgff_device), GFP_KERNEL);
+	if (!ret) return NULL;
+	*ret = *report;
+
+	ret->field[0] = kmalloc(sizeof(struct hid_field), GFP_KERNEL);
+	if (!ret->field[0]) {
+		kfree(ret);
+		return NULL;
+	}
+	*ret->field[0] = *report->field[0];
+
+	ret->field[0]->value = kmalloc(sizeof(s32[8]), GFP_KERNEL);
+	if (!ret->field[0]->value) {
+		kfree(ret->field[0]);
+		kfree(ret);
+		return NULL;
+	}
+	memset(ret->field[0]->value, 0, sizeof(s32[8]));	
+
+	return ret;
+}
+
+static void hid_lgff_delete_report(struct hid_report* report)
+{
+	if (report) {
+		kfree(report->field[0]->value);
+		kfree(report->field[0]);
+		kfree(report);
+	}
+}
+
+static void hid_lgff_input_init(struct hid_device* hid)
+{
+	struct device_type* dev = devices;
+	signed short* ff;
+	u16 idVendor = hid->dev->descriptor.idVendor;
+	u16 idProduct = hid->dev->descriptor.idProduct;
+
+	while (dev->idVendor && (idVendor != dev->idVendor || idProduct != dev->idProduct))
+		dev++;
+
+	ff = dev->ff;
+
+	while (*ff >= 0) {
+		set_bit(*ff, hid->input.ffbit);
+		++ff;
+	}
+
+	hid->input.upload_effect = hid_lgff_upload_effect;
+	hid->input.flush = hid_lgff_flush;
+
+	set_bit(EV_FF, hid->input.evbit);
+	hid->input.ff_effects_max = LGFF_EFFECTS;
+}
+
+static void hid_lgff_exit(struct hid_device* hid)
+{
+	struct lgff_device *lgff = hid->ff_private;
+
+	set_bit(DEVICE_CLOSING, lgff->flags);
+	del_timer_sync(&lgff->timer);
+
+	hid_lgff_delete_report(lgff->condition);
+	hid_lgff_delete_report(lgff->rumble);
+	hid_lgff_delete_report(lgff->constant);
+
+	kfree(lgff);
+}
+
+static int hid_lgff_event(struct hid_device *hid, struct input_dev* input,
+			  unsigned int type, unsigned int code, int value)
+{
+	struct lgff_device *lgff = hid->ff_private;
+	struct lgff_effect *effect = lgff->effects + code;
+	unsigned long flags;
+
+	if (type != EV_FF)                     return -EINVAL;
+	if (value < 0)                         return -EINVAL;
+
+	spin_lock_irqsave(&lgff->lock, flags);
+	
+	if (value > 0) {
+		if (test_bit(EFFECT_STARTED, effect->flags)) {
+			spin_unlock_irqrestore(&lgff->lock, flags);
+			return -EBUSY;
+		}
+		if (test_bit(EFFECT_PLAYING, effect->flags)) {
+			spin_unlock_irqrestore(&lgff->lock, flags);
+			return -EBUSY;
+		}
+
+		effect->count = value;
+
+		if (effect->effect.replay.delay) {
+			set_bit(EFFECT_STARTED, effect->flags);
+		} else {
+			set_bit(EFFECT_PLAYING, effect->flags);
+		}
+		effect->started_at = jiffies;
+	}
+	else { /* value == 0 */
+		clear_bit(EFFECT_STARTED, effect->flags);
+		clear_bit(EFFECT_PLAYING, effect->flags);
+	}
+
+	spin_unlock_irqrestore(&lgff->lock, flags);
+
+	return 0;
+
+}
+
+/* Erase all effects this process owns */
+static int hid_lgff_flush(struct input_dev *dev, struct file *file)
+{
+	struct hid_device *hid = dev->private;
+	struct lgff_device *lgff = hid->ff_private;
+	int i;
+
+	for (i=0; i<dev->ff_effects_max; ++i) {
+
+		/*NOTE: no need to lock here. The only times EFFECT_USED is
+		  modified is when effects are uploaded or when an effect is
+		  erased. But a process cannot close its dev/input/eventX fd
+		  and perform ioctls on the same fd all at the same time */
+		if ( current->pid == lgff->effects[i].owner
+		     && test_bit(EFFECT_USED, lgff->effects[i].flags)) {
+			
+			if (hid_lgff_erase(dev, i))
+				warn("erase effect %d failed", i);
+		}
+
+	}
+
+	return 0;
+}
+
+static int hid_lgff_erase(struct input_dev *dev, int id)
+{
+	struct hid_device *hid = dev->private;
+	struct lgff_device *lgff = hid->ff_private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lgff->lock, flags);
+	lgff->effects[id].flags[0] = 0;
+	spin_unlock_irqrestore(&lgff->lock, flags);
+
+	return 0;
+}
+
+static int hid_lgff_upload_effect(struct input_dev* input,
+				  struct ff_effect* effect)
+{
+	struct hid_device *hid = input->private;
+	struct lgff_device *lgff = hid->ff_private;
+	struct lgff_effect new;
+	int id;
+	unsigned long flags;
+	
+	dbg("ioctl rumble");
+
+	if (!test_bit(effect->type, input->ffbit)) return -EINVAL;
+
+	spin_lock_irqsave(&lgff->lock, flags);
+
+	if (effect->id == -1) {
+		int i;
+
+		for (i=0; i<LGFF_EFFECTS && test_bit(EFFECT_USED, lgff->effects[i].flags); ++i);
+		if (i >= LGFF_EFFECTS) {
+			spin_unlock_irqrestore(&lgff->lock, flags);
+			return -ENOSPC;
+		}
+
+		effect->id = i;
+		lgff->effects[i].owner = current->pid;
+		lgff->effects[i].flags[0] = 0;
+		set_bit(EFFECT_USED, lgff->effects[i].flags);
+	}
+
+	id = effect->id;
+	new = lgff->effects[id];
+
+	new.effect = *effect;
+
+	if (test_bit(EFFECT_STARTED, lgff->effects[id].flags)
+	    || test_bit(EFFECT_STARTED, lgff->effects[id].flags)) {
+
+		/* Changing replay parameters is not allowed (for the time
+		   being) */
+		if (new.effect.replay.delay != lgff->effects[id].effect.replay.delay
+		    || new.effect.replay.length != lgff->effects[id].effect.replay.length) {
+			spin_unlock_irqrestore(&lgff->lock, flags);
+			return -ENOSYS;
+		}
+
+		lgff->effects[id] = new;
+
+	} else {
+		lgff->effects[id] = new;
+	}
+
+	spin_unlock_irqrestore(&lgff->lock, flags);
+	return 0;
+}
+
+static void hid_lgff_compute_constant(struct lgff_effect *effect,
+				      int *x, int *y)
+{
+	int level;
+	unsigned long now = jiffies;
+	int degrees;
+
+	// During attack ?
+	if (effect->effect.u.constant.envelope.attack_length &&
+	    !time_after(now,
+			effect->started_at
+			+ (effect->effect.u.constant.envelope.attack_length + effect->effect.replay.delay)*HZ/1000)) {
+		level = effect->effect.u.constant.level
+			- effect->effect.u.constant.envelope.attack_level;
+		//TODO compute incrementally, to save mults and divs
+		level *= now - effect->started_at - effect->effect.replay.delay;
+		level /= effect->effect.u.constant.envelope.attack_length;
+//		dbg("During attack");
+	}
+	// During fade ?
+	else if (effect->effect.replay.length &&
+		 effect->effect.u.constant.envelope.fade_length &&
+		 time_after(now,
+			    effect->started_at
+			    + (effect->effect.replay.delay + effect->effect.replay.length) * HZ/1000)) {
+		level = effect->effect.u.constant.envelope.fade_level
+			- effect->effect.u.constant.level;
+		//TODO compute incrementally, to save mults and divs
+		level *= now - (effect->started_at + effect->effect.replay.delay + effect->effect.replay.length - effect->effect.u.constant.envelope.fade_length) ;
+		level /= effect->effect.u.constant.envelope.fade_length;		
+//		dbg("During fade");
+	}
+	else {
+		level = effect->effect.u.constant.level;
+//		dbg("During middle");
+	}
+//	dbg("level = %d", level);
+
+	degrees = effect->effect.direction * 360 >> 16;
+	*x += fixp_mult(fixp_sin(degrees),
+			level);
+	*y += fixp_mult(-fixp_cos(degrees),
+			level);
+}
+
+static void hid_lgff_timer(unsigned long timer_data)
+{
+	struct lgff_device *lgff = (struct lgff_device*)timer_data;
+	struct hid_device *hid = lgff->hid;
+	unsigned long flags;
+	int x=0x7fff, y=0x7fff;   // Coordinates of constant effects
+	unsigned int left = 0, right = 0;   // Rumbling
+	int i;
+
+	spin_lock_irqsave(&lgff->lock, flags);
+
+ 	for (i=0; i<LGFF_EFFECTS; ++i) {
+		struct lgff_effect* effect = lgff->effects +i;
+
+		if (test_bit(EFFECT_PLAYING, effect->flags)) {
+
+			switch (effect->effect.type) {
+			case FF_CONSTANT:
+				hid_lgff_compute_constant(effect, &x, &y);
+				break;
+			case FF_RUMBLE:
+				right += effect->effect.u.rumble.strong_magnitude;
+				left += effect->effect.u.rumble.weak_magnitude;
+				break;
+			};
+
+			/* One run of the effect is finished playing */
+			if (effect->effect.replay.length &&
+			    time_after(jiffies,
+					effect->started_at
+					+ effect->effect.replay.delay*HZ/1000
+					+ effect->effect.replay.length*HZ/1000)) {
+				dbg("Finished playing once %d", i);
+				if (--effect->count <= 0) {
+					dbg("Stopped %d", i);
+					clear_bit(EFFECT_PLAYING, effect->flags);
+				}
+				else {
+					dbg("Start again %d", i);
+					if (effect->effect.replay.length != 0) {
+						clear_bit(EFFECT_PLAYING, effect->flags);
+						set_bit(EFFECT_STARTED, effect->flags);
+					}
+					effect->started_at = jiffies;
+				}
+			}
+
+		} else if (test_bit(EFFECT_STARTED, lgff->effects[i].flags)) {
+			/* Check if we should start playing the effect */
+			if (time_after(jiffies,
+					lgff->effects[i].started_at
+					+ lgff->effects[i].effect.replay.delay*HZ/1000)) {
+				dbg("Now playing %d", i);
+				clear_bit(EFFECT_STARTED, lgff->effects[i].flags);
+				set_bit(EFFECT_PLAYING, lgff->effects[i].flags);
+			}
+		}
+ 	}
+
+	x >>= 8;
+	y >>= 8;
+
+#define CLAMP(x) if (x < 0) x = 0; if (x > 0xff) x = 0xff
+
+	// Clamp values
+	CLAMP(x);
+	CLAMP(y);
+	CLAMP(left);
+	CLAMP(right);
+
+#undef CLAMP
+
+	if (x != lgff->constant->field[0]->value[2]
+	    || y != lgff->constant->field[0]->value[3]) {
+		lgff->constant->field[0]->value[2] = x;
+		lgff->constant->field[0]->value[3] = y;
+		dbg("(x,y)=(%04x, %04x)", x, y);
+		hid_submit_report(hid, lgff->constant, USB_DIR_OUT);
+	}
+
+	if (left != lgff->rumble->field[0]->value[3]
+	    || right != lgff->rumble->field[0]->value[4]) {
+		lgff->rumble->field[0]->value[3] = left;
+		lgff->rumble->field[0]->value[4] = right;
+		dbg("(left,right)=(%04x, %04x)", left, right);
+		hid_submit_report(hid, lgff->rumble, USB_DIR_OUT);
+	}
+
+	if (!test_bit(DEVICE_CLOSING, lgff->flags)) {
+		lgff->timer.expires = RUN_AT(PERIOD);
+		add_timer(&lgff->timer);
+	}
+
+ 	spin_unlock_irqrestore(&lgff->lock, flags);
+}
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hid.h linux-modified/drivers/usb/hid.h
--- linux-vanilla/drivers/usb/hid.h	Fri Nov 29 01:53:14 2002
+++ linux-modified/drivers/usb/hid.h	Sun Mar  9 17:01:16 2003
@@ -2,12 +2,10 @@
 #define __HID_H
 
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999 Andreas Gal
  *  Copyright (c) 2000-2001 Vojtech Pavlik
- *
- *  Sponsored by SuSE
  */
 
 /*
@@ -26,8 +24,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include <linux/types.h>
@@ -41,6 +39,25 @@
 #define USB_INTERFACE_CLASS_HID		3
 
 /*
+ * HID class requests
+ */
+
+#define HID_REQ_GET_REPORT		0x01
+#define HID_REQ_GET_IDLE		0x02
+#define HID_REQ_GET_PROTOCOL		0x03
+#define HID_REQ_SET_REPORT		0x09
+#define HID_REQ_SET_IDLE		0x0A
+#define HID_REQ_SET_PROTOCOL		0x0B
+
+/*
+ * HID class descriptor types
+ */
+
+#define HID_DT_HID			(USB_TYPE_CLASS | 0x01)
+#define HID_DT_REPORT			(USB_TYPE_CLASS | 0x02)
+#define HID_DT_PHYSICAL			(USB_TYPE_CLASS | 0x03)
+
+/*
  * We parse each description item into this structure. Short items data
  * values are expanded to 32-bit signed int, long items contain a pointer
  * into the data area.
@@ -158,9 +175,11 @@
 #define HID_UP_KEYBOARD 	0x00070000
 #define HID_UP_LED 		0x00080000
 #define HID_UP_BUTTON 		0x00090000
+#define HID_UP_ORDINAL 		0x000a0000
 #define HID_UP_CONSUMER		0x000c0000
 #define HID_UP_DIGITIZER 	0x000d0000
 #define HID_UP_PID 		0x000f0000
+#define HID_UP_HPVENDOR         0xff7f0000
 
 #define HID_USAGE		0x0000ffff
 
@@ -199,7 +218,7 @@
 	__s32    logical_maximum;
 	__s32    physical_minimum;
 	__s32    physical_maximum;
-	unsigned unit_exponent;
+	__s32    unit_exponent;
 	unsigned unit;
 	unsigned report_id;
 	unsigned report_size;
@@ -256,9 +275,10 @@
 	__s32     logical_maximum;
 	__s32     physical_minimum;
 	__s32     physical_maximum;
-	unsigned  unit_exponent;
+	__s32     unit_exponent;
 	unsigned  unit;
 	struct hid_report *report;	/* associated report */
+	unsigned index;			/* index into report->field[] */
 };
 
 #define HID_MAX_FIELDS 64
@@ -270,8 +290,6 @@
 	struct hid_field *field[HID_MAX_FIELDS];	/* fields of the report */
 	unsigned maxfield;				/* maximum valid field index */
 	unsigned size;					/* size of the report (bits) */
-	unsigned idx;					/* where we're in data */
-	unsigned char *data;				/* data for multi-packet reports */
 	struct hid_device *device;			/* associated device */
 };
 
@@ -284,16 +302,20 @@
 #define HID_REPORT_TYPES 3
 
 #define HID_BUFFER_SIZE		32
-#define HID_CONTROL_FIFO_SIZE	8
+#define HID_CONTROL_FIFO_SIZE	64
+#define HID_OUTPUT_FIFO_SIZE	64
 
 struct hid_control_fifo {
-	struct usb_ctrlrequest dr;
-	char buffer[HID_BUFFER_SIZE];
+	unsigned char dir;
+	struct hid_report *report;
 };
 
 #define HID_CLAIMED_INPUT	1
 #define HID_CLAIMED_HIDDEV	2
 
+#define HID_CTRL_RUNNING	1
+#define HID_OUT_RUNNING		2
+
 struct hid_device {							/* device report descriptor */
 	 __u8 *rdesc;
 	unsigned rsize;
@@ -306,12 +328,23 @@
 	struct usb_device *dev;						/* USB device */
 	int ifnum;							/* USB interface number */
 
-	struct urb urb;							/* USB URB structure */
-	char buffer[HID_BUFFER_SIZE];					/* Rx buffer */
+	unsigned long iofl;						/* I/O flags (CTRL_RUNNING, OUT_RUNNING) */
 
-	struct urb urbout;						/* Output URB */
-	struct hid_control_fifo out[HID_CONTROL_FIFO_SIZE];		/* Transmit buffer */
-	unsigned char outhead, outtail;					/* Tx buffer head & tail */
+	struct urb *urbin;						/* Input URB */
+	char inbuf[HID_BUFFER_SIZE];					/* Input buffer */
+
+	struct urb *urbctrl;						/* Control URB */
+	struct usb_ctrlrequest dr;							/* Control request struct */
+	struct hid_control_fifo ctrl[HID_CONTROL_FIFO_SIZE];		/* Control fifo */
+	unsigned char ctrlhead, ctrltail;				/* Control fifo head & tail */
+	char ctrlbuf[HID_BUFFER_SIZE];					/* Control buffer */
+	spinlock_t ctrllock;						/* Control fifo spinlock */
+
+	struct urb *urbout;						/* Output URB */
+	struct hid_report *out[HID_CONTROL_FIFO_SIZE];			/* Output pipe fifo */
+	unsigned char outhead, outtail;					/* Output pipe fifo head & tail */
+	char outbuf[HID_BUFFER_SIZE];					/* Output buffer */
+	spinlock_t outlock;						/* Output fifo spinlock */
 
 	unsigned claimed;						/* Claimed by hidinput, hiddev? */	
 	unsigned quirks;						/* Various quirks the device can pull on us */
@@ -320,8 +353,17 @@
 	void *hiddev;							/* The hiddev structure */
 	int minor;							/* Hiddev minor number */
 
+	wait_queue_head_t wait;						/* For sleeping */
+
 	int open;							/* is the device open by anyone? */
 	char name[128];							/* Device name */
+	char phys[64];							/* Device physical location */
+	char uniq[64];							/* Device unique identifier (serial #) */
+
+	void *ff_private;                                               /* Private data for the force-feedback driver */
+	void (*ff_exit)(struct hid_device*);                            /* Called by hid_exit_ff(hid) */
+	int (*ff_event)(struct hid_device *hid, struct input_dev *input,
+			unsigned int type, unsigned int code, int value);
 };
 
 #define HID_GLOBAL_STACK_SIZE 4
@@ -352,32 +394,44 @@
 	struct hid_class_descriptor desc[1];
 } __attribute__ ((packed));
 
+void hidinput_hid_event(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
+int hidinput_connect(struct hid_device *);
+void hidinput_disconnect(struct hid_device *);
 
 #ifdef DEBUG
 #include "hid-debug.h"
 #else
 #define hid_dump_input(a,b)	do { } while (0)
 #define hid_dump_device(c)	do { } while (0)
+#define hid_dump_field(a,b)	do { } while (0)
 #endif
 
 #endif
 
-#ifdef CONFIG_USB_HIDINPUT
-#define IS_INPUT_APPLICATION(a) (((a >= 0x00010000) && (a <= 0x00010008)) || (a == 0x00010080) || ( a == 0x000c0001))
-extern void hidinput_hid_event(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
-extern int hidinput_connect(struct hid_device *);
-extern void hidinput_disconnect(struct hid_device *);
-#else
-#define IS_INPUT_APPLICATION(a) (0)
-static inline void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value) { }
-static inline int hidinput_connect(struct hid_device *hid) { return -ENODEV; }
-static inline void hidinput_disconnect(struct hid_device *hid) { }
-#endif
+/* Applications from HID Usage Tables 4/8/99 Version 1.1 */
+/* We ignore a few input applications that are not widely used */
+#define IS_INPUT_APPLICATION(a) (((a >= 0x00010000) && (a <= 0x00010008)) || ( a == 0x00010080) || ( a == 0x000c0001))
 
 int hid_open(struct hid_device *);
 void hid_close(struct hid_device *);
 int hid_find_field(struct hid_device *, unsigned int, unsigned int, struct hid_field **);
 int hid_set_field(struct hid_field *, unsigned, __s32);
-void hid_write_report(struct hid_device *, struct hid_report *);
-void hid_read_report(struct hid_device *, struct hid_report *);
+void hid_submit_report(struct hid_device *, struct hid_report *, unsigned char dir);
 void hid_init_reports(struct hid_device *hid);
+
+
+#ifdef CONFIG_HID_FF
+
+int hid_ff_init(struct hid_device *hid);
+static inline void hid_ff_exit(struct hid_device *hid)
+{
+	if (hid->ff_exit) hid->ff_exit(hid);
+}
+
+static inline int hid_ff_event(struct hid_device *hid, struct input_dev *input,
+			unsigned int type, unsigned int code, int value)
+{
+	if (hid->ff_event) return hid->ff_event(hid, input, type, code, value);
+	return -ENOSYS;
+}
+#endif
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/hiddev.c linux-modified/drivers/usb/hiddev.c
--- linux-vanilla/drivers/usb/hiddev.c	Sun Oct 21 04:13:11 2001
+++ linux-modified/drivers/usb/hiddev.c	Mon Jan  6 16:48:21 2003
@@ -50,9 +50,10 @@
 };
 
 struct hiddev_list {
-	struct hiddev_event buffer[HIDDEV_BUFFER_SIZE];
+	struct hiddev_usage_ref buffer[HIDDEV_BUFFER_SIZE];
 	int head;
 	int tail;
+	unsigned flags;
 	struct fasync_struct *fasync;
 	struct hiddev *hiddev;
 	struct hiddev_list *next;
@@ -146,17 +147,19 @@
  * This is where hid.c calls into hiddev to pass an event that occurred over
  * the interrupt pipe
  */
-void hiddev_hid_event(struct hid_device *hid, unsigned int usage, int value)
+void hiddev_hid_event(struct hid_device *hid, struct hiddev_usage_ref *uref)
 {
 	struct hiddev *hiddev = hid->hiddev;
 	struct hiddev_list *list = hiddev->list;
 
 	while (list) {
-		list->buffer[list->head].hid = usage;
-		list->buffer[list->head].value = value;
-		list->head = (list->head + 1) & (HIDDEV_BUFFER_SIZE - 1);
-
-		kill_fasync(&list->fasync, SIGIO, POLL_IN);
+		if (uref->field_index != HID_FIELD_INDEX_NONE ||
+		    (list->flags & HIDDEV_FLAG_REPORT) != 0) {
+			list->buffer[list->head] = *uref;
+			list->head = (list->head + 1) & 
+				(HIDDEV_BUFFER_SIZE - 1);
+			kill_fasync(&list->fasync, SIGIO, POLL_IN);
+		}
 
 		list = list->next;
 	}
@@ -193,7 +196,6 @@
 	struct hiddev_list *list = file->private_data;
 	struct hiddev_list **listptr;
 
-	lock_kernel();
 	listptr = &list->hiddev->list;
 	hiddev_fasync(-1, file, 0);
 
@@ -209,7 +211,6 @@
 	}
 
 	kfree(list);
-	unlock_kernel();
 
 	return 0;
 }
@@ -220,7 +221,7 @@
 static int hiddev_open(struct inode * inode, struct file * file) {
 	struct hiddev_list *list;
 
-	int i = MINOR(inode->i_rdev) - HIDDEV_MINOR_BASE;
+	int i = minor(inode->i_rdev) - HIDDEV_MINOR_BASE;
 
 	if (i >= HIDDEV_MINORS || !hiddev_table[i])
 		return -ENODEV;
@@ -259,43 +260,67 @@
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct hiddev_list *list = file->private_data;
+	int event_size;
 	int retval = 0;
 
-	if (list->head == list->tail) {
-
-		add_wait_queue(&list->hiddev->wait, &wait);
-		set_current_state(TASK_INTERRUPTIBLE);
+	event_size = ((list->flags & HIDDEV_FLAG_UREF) != 0) ?
+		sizeof(struct hiddev_usage_ref) : sizeof(struct hiddev_event);
 
-		while (list->head == list->tail) {
+	if (count < event_size) return 0;
 
-			if (file->f_flags & O_NONBLOCK) {
-				retval = -EAGAIN;
-				break;
-			}
-			if (signal_pending(current)) {
-				retval = -ERESTARTSYS;
-				break;
-			}
-			if (!list->hiddev->exist) {
-				retval = -EIO;
-				break;
+	while (retval == 0) {
+		if (list->head == list->tail) {
+			add_wait_queue(&list->hiddev->wait, &wait);
+			set_current_state(TASK_INTERRUPTIBLE);
+			
+			while (list->head == list->tail) {
+				if (file->f_flags & O_NONBLOCK) {
+					retval = -EAGAIN;
+					break;
+				}
+				if (signal_pending(current)) {
+					retval = -ERESTARTSYS;
+					break;
+				}
+				if (!list->hiddev->exist) {
+					retval = -EIO;
+					break;
+				}
+				
+				schedule();
 			}
 
-			schedule();
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&list->hiddev->wait, &wait);
 		}
 
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&list->hiddev->wait, &wait);
-	}
+		if (retval)
+			return retval;
 
-	if (retval)
-		return retval;
 
-	while (list->head != list->tail && retval + sizeof(struct hiddev_event) <= count) {
-		if (copy_to_user(buffer + retval, list->buffer + list->tail,
-				 sizeof(struct hiddev_event))) return -EFAULT;
-		list->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);
-		retval += sizeof(struct hiddev_event);
+		while (list->head != list->tail && 
+		       retval + event_size <= count) {
+			if ((list->flags & HIDDEV_FLAG_UREF) == 0) {
+				if (list->buffer[list->tail].field_index !=
+				    HID_FIELD_INDEX_NONE) {
+					struct hiddev_event event;
+					event.hid = list->buffer[list->tail].usage_code;
+					event.value = list->buffer[list->tail].value;
+					if (copy_to_user(buffer + retval, &event, sizeof(struct hiddev_event)))
+						return -EFAULT;
+					retval += sizeof(struct hiddev_event);
+				}
+			} else {
+				if (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE ||
+				    (list->flags & HIDDEV_FLAG_REPORT) != 0) {
+					if (copy_to_user(buffer + retval, list->buffer + list->tail, sizeof(struct hiddev_usage_ref)))
+						return -EFAULT;
+					retval += sizeof(struct hiddev_usage_ref);
+				}
+			}
+			list->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);
+		}
+
 	}
 
 	return retval;
@@ -360,6 +385,25 @@
 		return copy_to_user((void *) arg, &dinfo, sizeof(dinfo));
 	}
 
+	case HIDIOCGFLAG:
+		return put_user(list->flags, (int *) arg);
+
+	case HIDIOCSFLAG:
+		{
+			int newflags;
+			if (get_user(newflags, (int *) arg))
+				return -EFAULT;
+
+			if ((newflags & ~HIDDEV_FLAGS) != 0 ||
+			    ((newflags & HIDDEV_FLAG_REPORT) != 0 &&
+			     (newflags & HIDDEV_FLAG_UREF) == 0))
+				return -EINVAL;
+
+			list->flags = newflags;
+
+			return 0;
+		}
+
 	case HIDIOCGSTRING:
 		{
 			int idx, len;
@@ -402,7 +446,7 @@
 		if ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)
 			return -EINVAL;
 
-		hid_read_report(hid, report);
+		hid_submit_report(hid, report, USB_DIR_IN);
 
 		return 0;
 
@@ -416,7 +460,7 @@
 		if ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)
 			return -EINVAL;
 
-		hid_write_report(hid, report);
+		hid_submit_report(hid, report, USB_DIR_OUT);
 
 		return 0;
 
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/usb-ohci.c linux-modified/drivers/usb/usb-ohci.c
--- linux-vanilla/drivers/usb/usb-ohci.c	Fri Nov 29 01:53:15 2002
+++ linux-modified/drivers/usb/usb-ohci.c	Mon Jan  6 16:48:21 2003
@@ -74,7 +74,7 @@
 #include <asm/unaligned.h>
 
 #define OHCI_USE_NPS		// force NoPowerSwitching mode
-// #define OHCI_VERBOSE_DEBUG	/* not always helpful */
+#undef OHCI_VERBOSE_DEBUG	/* not always helpful */
 
 #include "usb-ohci.h"
 
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/usbkbd.c linux-modified/drivers/usb/usbkbd.c
--- linux-vanilla/drivers/usb/usbkbd.c	Fri Nov 29 01:53:15 2002
+++ linux-modified/drivers/usb/usbkbd.c	Mon Jan  6 16:48:21 2003
@@ -250,8 +250,8 @@
 			
 	input_register_device(&kbd->dev);
 
-	printk(KERN_INFO "input%d: %s on usb%d:%d.%d\n",
-		 kbd->dev.number, kbd->name, dev->bus->busnum, dev->devnum, ifnum);
+	printk(KERN_INFO "input: %s on usb%d:%d.%d\n",
+		 kbd->name, dev->bus->busnum, dev->devnum, ifnum);
 
 	return kbd;
 }
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/usbmouse.c linux-modified/drivers/usb/usbmouse.c
--- linux-vanilla/drivers/usb/usbmouse.c	Sat Aug  3 02:39:45 2002
+++ linux-modified/drivers/usb/usbmouse.c	Mon Jan  6 16:48:21 2003
@@ -166,8 +166,8 @@
 
 	input_register_device(&mouse->dev);
 
-	printk(KERN_INFO "input%d: %s on usb%d:%d.%d\n",
-		 mouse->dev.number, mouse->name, dev->bus->busnum, dev->devnum, ifnum);
+	printk(KERN_INFO "input: %s on usb%d:%d.%d\n",
+		 mouse->name, dev->bus->busnum, dev->devnum, ifnum);
 
 	return mouse;
 }
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/drivers/usb/wacom.c linux-modified/drivers/usb/wacom.c
--- linux-vanilla/drivers/usb/wacom.c	Fri Nov 29 01:53:15 2002
+++ linux-modified/drivers/usb/wacom.c	Mon Jan  6 16:48:21 2003
@@ -491,8 +491,8 @@
 	usb_set_report(dev, ifnum, 3, 5, rep_data, 0);
 	usb_set_report(dev, ifnum, 3, 6, rep_data, 0);
 	
-	printk(KERN_INFO "input%d: %s on usb%d:%d.%d\n",
-	       wacom->dev.number, wacom->features->name, dev->bus->busnum, dev->devnum, ifnum);
+	printk(KERN_INFO "input: %s on usb%d:%d.%d\n",
+	       wacom->features->name, dev->bus->busnum, dev->devnum, ifnum);
 
 	return wacom;
 }
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/include/linux/hiddev.h linux-modified/include/linux/hiddev.h
--- linux-vanilla/include/linux/hiddev.h	Fri Nov 29 01:53:15 2002
+++ linux-modified/include/linux/hiddev.h	Sun Mar  9 17:01:16 2003
@@ -2,7 +2,7 @@
 #define _HIDDEV_H
 
 /*
- * $Id$
+ * $Id$
  *
  *  Copyright (c) 1999-2000 Vojtech Pavlik
  *
@@ -25,8 +25,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  * 
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 /*
@@ -119,12 +119,17 @@
 	__s32 value;
 };
 
+/* FIELD_INDEX_NONE is returned in read() data from the kernel when flags
+ * is set to (HIDDEV_FLAG_UREF | HIDDEV_FLAG_REPORT) and a new report has
+ * been sent by the device 
+ */
+#define HID_FIELD_INDEX_NONE 0xffffffff
 
 /*
  * Protocol version.
  */
 
-#define HID_VERSION		0x010002
+#define HID_VERSION		0x010003
 
 /*
  * IOCTLs (0x00 - 0x7f)
@@ -138,11 +143,20 @@
 #define HIDIOCGNAME(len)	_IOC(_IOC_READ, 'H', 0x06, len)
 #define HIDIOCGREPORT		_IOW('H', 0x07, struct hiddev_report_info)
 #define HIDIOCSREPORT		_IOW('H', 0x08, struct hiddev_report_info)
-#define HIDIOCGREPORTINFO       _IOWR('H', 0x09, struct hiddev_report_info)
-#define HIDIOCGFIELDINFO        _IOWR('H', 0x0A, struct hiddev_field_info)
-#define HIDIOCGUSAGE            _IOWR('H', 0x0B, struct hiddev_usage_ref)
-#define HIDIOCSUSAGE            _IOW('H', 0x0C, struct hiddev_usage_ref)
-#define HIDIOCGUCODE            _IOWR('H', 0x0D, struct hiddev_usage_ref)
+#define HIDIOCGREPORTINFO	_IOWR('H', 0x09, struct hiddev_report_info)
+#define HIDIOCGFIELDINFO	_IOWR('H', 0x0A, struct hiddev_field_info)
+#define HIDIOCGUSAGE		_IOWR('H', 0x0B, struct hiddev_usage_ref)
+#define HIDIOCSUSAGE		_IOW('H', 0x0C, struct hiddev_usage_ref)
+#define HIDIOCGUCODE		_IOWR('H', 0x0D, struct hiddev_usage_ref)
+#define HIDIOCGFLAG		_IOR('H', 0x0E, int)
+#define HIDIOCSFLAG		_IOW('H', 0x0F, int)
+
+/* 
+ * Flags to be used in HIDIOCSFLAG
+ */
+#define HIDDEV_FLAG_UREF	0x1
+#define HIDDEV_FLAG_REPORT	0x2
+#define HIDDEV_FLAGS		0x3
 
 /* To traverse the input report descriptor info for a HID device, perform the 
  * following:
@@ -179,13 +193,13 @@
 #ifdef CONFIG_USB_HIDDEV
 int hiddev_connect(struct hid_device *);
 void hiddev_disconnect(struct hid_device *);
-void hiddev_hid_event(struct hid_device *, unsigned int usage, int value);
+void hiddev_hid_event(struct hid_device *, struct hiddev_usage_ref *ref);
 int __init hiddev_init(void);
 void __exit hiddev_exit(void);
 #else
 static inline int hiddev_connect(struct hid_device *hid) { return -1; }
 static inline void hiddev_disconnect(struct hid_device *hid) { }
-static inline void hiddev_hid_event(struct hid_device *hid, unsigned int usage, int value) { }
+static inline void hiddev_hid_event(struct hid_device *, struct hiddev_usage_ref *ref) { }
 static inline int hiddev_init(void) { return 0; }
 static inline void hiddev_exit(void) { }
 #endif
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/include/linux/input.h linux-modified/include/linux/input.h
--- linux-vanilla/include/linux/input.h	Sun Jan 26 16:09:49 2003
+++ linux-modified/include/linux/input.h	Sun Mar  9 16:58:14 2003
@@ -2,11 +2,9 @@
 #define _INPUT_H
 
 /*
- * $Id$
+ * $Id$
  *
- *  Copyright (c) 1999-2000 Vojtech Pavlik
- *
- *  Sponsored by SuSE
+ *  Copyright (c) 1999-2001 Vojtech Pavlik
  */
 
 /*
@@ -17,7 +15,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -25,8 +23,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #ifdef __KERNEL__
@@ -64,17 +62,20 @@
 #define EVIOCSREP		_IOW('E', 0x03, int[2])			/* get repeat settings */
 #define EVIOCGKEYCODE		_IOR('E', 0x04, int[2])			/* get keycode */
 #define EVIOCSKEYCODE		_IOW('E', 0x04, int[2])			/* set keycode */
-#define EVIOCGKEY		_IOR('E', 0x05, int[2])			/* get key value */
+
 #define EVIOCGNAME(len)		_IOC(_IOC_READ, 'E', 0x06, len)		/* get device name */
-#define EVIOCGBUS		_IOR('E', 0x07, short[4])		/* get bus address */
+#define EVIOCGPHYS(len)		_IOC(_IOC_READ, 'E', 0x07, len)		/* get physical location */
+#define EVIOCGUNIQ(len)		_IOC(_IOC_READ, 'E', 0x08, len)		/* get unique identifier */
+
+#define EVIOCGKEY(len)		_IOC(_IOC_READ, 'E', 0x18, len)		/* get global keystate */
+#define EVIOCGLED(len)		_IOC(_IOC_READ, 'E', 0x19, len)		/* get all LEDs */
+#define EVIOCGSND(len)		_IOC(_IOC_READ, 'E', 0x1a, len)		/* get all sounds status */
 
 #define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, 'E', 0x20 + ev, len)	/* get event bits */
 #define EVIOCGABS(abs)		_IOR('E', 0x40 + abs, int[5])		/* get abs value/limits */
 
 #define EVIOCSFF		_IOC(_IOC_WRITE, 'E', 0x80, sizeof(struct ff_effect))	/* send a force effect to a force feedback device */
 #define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
-#define EVIOCSGAIN		_IOW('E', 0x82, unsigned short)		/* Set overall gain */
-#define EVIOCSAUTOCENTER	_IOW('E', 0x83, unsigned short)		/* Enable or disable auto-centering */
 #define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
 
 /*
@@ -90,6 +91,8 @@
 #define EV_SND			0x12
 #define EV_REP			0x14
 #define EV_FF			0x15
+#define EV_PWR			0x16
+#define EV_FF_STATUS		0x17
 #define EV_MAX			0x1f
 
 /*
@@ -304,8 +307,27 @@
 #define KEY_PROG4		203
 #define KEY_SUSPEND		205
 #define KEY_CLOSE		206
+#define KEY_PLAY		207
+#define KEY_FASTFORWARD		208
+#define KEY_BASSBOOST		209
+#define KEY_PRINT		210
+#define KEY_HP			211
+#define KEY_CAMERA		212
+#define KEY_SOUND		213
+#define KEY_QUESTION		214
+#define KEY_EMAIL		215
+#define KEY_CHAT		216
+#define KEY_SEARCH		217
+#define KEY_CONNECT		218
+#define KEY_FINANCE		219
+#define KEY_SPORT		220
+#define KEY_SHOP		221
+#define KEY_ALTERASE		222
+#define KEY_CANCEL		223
+#define KEY_BRIGHTNESSDOWN	224
+#define KEY_BRIGHTNESSUP	225
 
-#define KEY_UNKNOWN		220
+#define KEY_UNKNOWN		240
 
 #define KEY_BRIGHTNESSDOWN	224
 #define KEY_BRIGHTNESSUP	225
@@ -376,6 +398,10 @@
 #define BTN_STYLUS		0x14b
 #define BTN_STYLUS2		0x14c
 
+#define BTN_WHEEL		0x150
+#define BTN_GEAR_DOWN		0x150
+#define BTN_GEAR_UP		0x151
+
 #define KEY_MAX			0x1ff
 
 /*
@@ -419,7 +445,8 @@
 #define ABS_TILT_X		0x1a
 #define ABS_TILT_Y		0x1b
 #define ABS_MISC		0x1c
-#define ABS_MAX			0x1f
+#define ABS_VOLUME		0x20
+#define ABS_MAX			0x3f
 
 /*
  * Misc events
@@ -485,67 +512,89 @@
 #define BUS_I2C			0x18
 
 /*
+ * Values describing the status of an effect
+ */
+#define FF_STATUS_STOPPED	0x00
+#define FF_STATUS_PLAYING	0x01
+#define FF_STATUS_MAX		0x01
+
+/*
  * Structures used in ioctls to upload effects to a device
  * The first structures are not passed directly by using ioctls.
  * They are sub-structures of the actually sent structure (called ff_effect)
  */
 
 struct ff_replay {
-	__u16 length;		/* Duration of an effect */
+	__u16 length;		/* Duration of an effect in ms.
+				   All other times are also expressed in ms.
+				   0 means "play for ever" */
 	__u16 delay;		/* Time to wait before to start playing an effect */
 };
 
 struct ff_trigger {
 	__u16 button;		/* Number of button triggering an effect */
-	__u16 interval;		/* Time to wait before an effect can be re-triggered */
+	__u16 interval;		/* Time to wait before an effect can be re-triggered (ms) */
 };
 
-struct ff_shape {
-	__u16 attack_length;	/* Duration of attack */
-	__s16 attack_level;	/* Level at beginning of attack */
-	__u16 fade_length;	/* Duration of fade */
-	__s16 fade_level;	/* Level at end of fade */
+struct ff_envelope {
+	__u16 attack_length;	/* Duration of attack (ms) */
+	__u16 attack_level;	/* Level at beginning of attack */
+	__u16 fade_length;	/* Duration of fade (ms) */
+	__u16 fade_level;	/* Level at end of fade */
 };
 
 /* FF_CONSTANT */
 struct ff_constant_effect {
-	__s16 level;		/* Strength of effect */
-	__u16 direction;	/* Direction of effect (see periodic effects) */
-	struct ff_shape shape;
+	__s16 level;		/* Strength of effect. Negative values are OK */
+	struct ff_envelope envelope;
 };
 
-/* FF_SPRING of FF_FRICTION */
-struct ff_interactive_effect {
-/* Axis along which effect must be created. If null, the field named direction
- * is used
- * It is a bit array (ie to enable axes X and Y, use BIT(ABS_X) | BIT(ABS_Y)
- */
-	__u16 axis;
-	__u16 direction;
+/* FF_RAMP */
+struct ff_ramp_effect {
+	__s16 start_level;
+	__s16 end_level;
+	struct ff_envelope envelope;
+};
 
-	__s16 right_saturation; /* Max level when joystick is on the right */
-	__s16 left_saturation;  /* Max level when joystick in on the left */
+/* FF_SPRING of FF_FRICTION */
+struct ff_condition_effect {
+	__u16 right_saturation; /* Max level when joystick is on the right */
+	__u16 left_saturation;  /* Max level when joystick in on the left */
 
 	__s16 right_coeff;	/* Indicates how fast the force grows when the
 				   joystick moves to the right */
 	__s16 left_coeff;	/* Same for left side */
 
 	__u16 deadband;		/* Size of area where no force is produced */
-	__s16 center;		/* Position of dead dead zone */
+	__s16 center;		/* Position of dead zone */
 
 };
 
 /* FF_PERIODIC */
 struct ff_periodic_effect {
 	__u16 waveform;		/* Kind of wave (sine, square...) */
-	__u16 period;
+	__u16 period;		/* in ms */
 	__s16 magnitude;	/* Peak value */
 	__s16 offset;		/* Mean value of wave (roughly) */
 	__u16 phase;		/* 'Horizontal' shift */
-	__u16 direction;	/* Direction. 0 deg -> 0x0000
-					     90 deg -> 0x4000 */
 
-	struct ff_shape shape;
+	struct ff_envelope envelope;
+
+/* Only used if waveform == FF_CUSTOM */
+	__u32 custom_len;	/* Number of samples  */	
+	__s16 *custom_data;	/* Buffer of samples */
+/* Note: the data pointed by custom_data is copied by the driver. You can
+ * therefore dispose of the memory after the upload/update */
+};
+
+/* FF_RUMBLE */
+/* Some rumble pads have two motors of different weight.
+   strong_magnitude represents the magnitude of the vibration generated
+   by the heavy motor.
+*/
+struct ff_rumble_effect {
+        __u16 strong_magnitude;  /* Magnitude of the heavy motor */
+        __u16 weak_magnitude;    /* Magnitude of the light one */
 };
 
 /*
@@ -554,36 +603,30 @@
 struct ff_effect {
 	__u16 type;
 /* Following field denotes the unique id assigned to an effect.
- * It is set by the driver.
+ * If user sets if to -1, a new effect is created, and its id is returned in the same field
+ * Else, the user sets it to the effect id it wants to update.
  */
 	__s16 id;
 
+	__u16 direction;	/* Direction. 0 deg -> 0x0000 (down)
+					     90 deg -> 0x4000 (left)
+					    180 deg -> 0x8000 (up)
+					    270 deg -> 0xC000 (right)
+				*/
+
 	struct ff_trigger trigger;
 	struct ff_replay replay;
 
 	union {
 		struct ff_constant_effect constant;
+		struct ff_ramp_effect ramp;
 		struct ff_periodic_effect periodic;
-		struct ff_interactive_effect interactive;
+		struct ff_condition_effect condition[2];	/* One for each axis */
+                struct ff_rumble_effect rumble;
 	} u;
 };
 
 /*
- * Buttons that can trigger effects.  Use for example FF_BTN(BTN_TRIGGER) to
- * access the bitmap.
- */
-
-#define FF_BTN(x)	((x) - BTN_MISC + FF_BTN_OFFSET)
-#define FF_BTN_OFFSET	0x00
-
-/*
- * Force feedback axis mappings. Use FF_ABS() to access the bitmap.
- */
-
-#define FF_ABS(x)	((x) + FF_ABS_OFFSET)
-#define FF_ABS_OFFSET	0x40
-
-/*
  * Force feedback effect types
  */
 
@@ -592,6 +635,9 @@
 #define FF_CONSTANT	0x52
 #define FF_SPRING	0x53
 #define FF_FRICTION	0x54
+#define FF_DAMPER	0x55
+#define FF_INERTIA	0x56
+#define FF_RAMP		0x57
 
 /*
  * Force feedback periodic effect types
@@ -630,8 +676,9 @@
 
 	void *private;
 
-	int number;
 	char *name;
+	char *phys;
+	char *uniq;
 	unsigned short idbus;
 	unsigned short idvendor;
 	unsigned short idproduct;
@@ -654,6 +701,9 @@
 	unsigned int repeat_key;
 	struct timer_list timer;
 
+	struct pm_dev *pm_dev;
+	int state;
+
 	int abs[ABS_MAX + 1];
 	int rep[REP_MAX + 1];
 
@@ -668,6 +718,8 @@
 
 	int (*open)(struct input_dev *dev);
 	void (*close)(struct input_dev *dev);
+	int (*accept)(struct input_dev *dev, struct file *file);
+	int (*flush)(struct input_dev *dev, struct file *file);
 	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
 	int (*upload_effect)(struct input_dev *dev, struct ff_effect *effect);
 	int (*erase_effect)(struct input_dev *dev, int effect_id);
@@ -676,16 +728,63 @@
 	struct input_dev *next;
 };
 
+/*
+ * Structure for hotplug & device<->driver matching.
+ */
+
+#define INPUT_DEVICE_ID_MATCH_BUS	1
+#define INPUT_DEVICE_ID_MATCH_VENDOR	2
+#define INPUT_DEVICE_ID_MATCH_PRODUCT	4
+#define INPUT_DEVICE_ID_MATCH_VERSION	8
+
+#define INPUT_DEVICE_ID_MATCH_EVBIT	0x010
+#define INPUT_DEVICE_ID_MATCH_KEYBIT	0x020
+#define INPUT_DEVICE_ID_MATCH_RELBIT	0x040
+#define INPUT_DEVICE_ID_MATCH_ABSBIT	0x080
+#define INPUT_DEVICE_ID_MATCH_MSCIT	0x100
+#define INPUT_DEVICE_ID_MATCH_LEDBIT	0x200
+#define INPUT_DEVICE_ID_MATCH_SNDBIT	0x400
+#define INPUT_DEVICE_ID_MATCH_FFBIT	0x800
+
+#define INPUT_DEVICE_ID_MATCH_DEVICE\
+	(INPUT_DEVICE_ID_MATCH_BUS | INPUT_DEVICE_ID_MATCH_VENDOR | INPUT_DEVICE_ID_MATCH_PRODUCT)
+#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION\
+	(INPUT_DEVICE_ID_MATCH_DEVICE | INPUT_DEVICE_ID_MATCH_VERSION)
+
+struct input_device_id {
+
+	unsigned long flags;
+
+	unsigned short idbus;
+	unsigned short idvendor;
+	unsigned short idproduct;
+	unsigned short idversion;
+
+	unsigned long evbit[NBITS(EV_MAX)];
+	unsigned long keybit[NBITS(KEY_MAX)];
+	unsigned long relbit[NBITS(REL_MAX)];
+	unsigned long absbit[NBITS(ABS_MAX)];
+	unsigned long mscbit[NBITS(MSC_MAX)];
+	unsigned long ledbit[NBITS(LED_MAX)];
+	unsigned long sndbit[NBITS(SND_MAX)];
+	unsigned long ffbit[NBITS(FF_MAX)];
+
+	unsigned long driver_info;
+};
+
 struct input_handler {
 
 	void *private;
 
 	void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
-	struct input_handle* (*connect)(struct input_handler *handler, struct input_dev *dev);
+	struct input_handle* (*connect)(struct input_handler *handler, struct input_dev *dev, struct input_device_id *id);
 	void (*disconnect)(struct input_handle *handle);
 
 	struct file_operations *fops;
 	int minor;
+	char *name;
+
+	struct input_device_id *id_table;
 
 	struct input_handle *handle;
 	struct input_handler *next;
@@ -696,6 +795,7 @@
 	void *private;
 
 	int open;
+	char *name;
 
 	struct input_dev *dev;
 	struct input_handler *handler;
@@ -713,6 +813,9 @@
 int input_open_device(struct input_handle *);
 void input_close_device(struct input_handle *);
 
+int input_accept_process(struct input_handle *handle, struct file *file);
+int input_flush_device(struct input_handle* handle, struct file* file);
+
 devfs_handle_t input_register_minor(char *name, int minor, int minor_base);
 void input_unregister_minor(devfs_handle_t handle);
 
@@ -721,6 +824,8 @@
 #define input_report_key(a,b,c) input_event(a, EV_KEY, b, !!(c))
 #define input_report_rel(a,b,c) input_event(a, EV_REL, b, c)
 #define input_report_abs(a,b,c) input_event(a, EV_ABS, b, c)
+#define input_report_ff(a,b,c)	input_event(a, EV_FF, b, c)
+#define input_report_ff_status(a,b,c)	input_event(a, EV_FF_STATUS, b, c)
 
 #endif
 #endif
diff -u -N -r --exclude=*.rej --exclude=CVS --exclude=.* --exclude=*~ linux-vanilla/include/linux/serio.h linux-modified/include/linux/serio.h
--- linux-vanilla/include/linux/serio.h	Fri Nov 29 01:53:15 2002
+++ linux-modified/include/linux/serio.h	Mon Jan 13 22:42:43 2003
@@ -2,38 +2,38 @@
 #define _SERIO_H
 
 /*
- * $Id$
+ * $Id$
  *
- * Copyright (C) 1999 Vojtech Pavlik
- *
- * Sponsored by SuSE
+ * Copyright (C) 1999-2001 Vojtech Pavlik
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or 
+ * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * 
+ *
  * Should you need to contact me, the author, you can do so either by
  * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
- * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 /*
  * The serial port set type ioctl.
  */
 
+#include <asm/errno.h>
 #include <linux/ioctl.h>
+
 #define SPIOCSTYPE	_IOW('q', 0x01, unsigned long)
 
 struct serio;
@@ -42,23 +42,30 @@
 
 	void *private;
 	void *driver;
+	char *name;
+	char *phys;
+
+	unsigned short idbus;
+	unsigned short idvendor;
+	unsigned short idproduct;
+	unsigned short idversion;
 
 	unsigned long type;
-	int number;
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
 	void (*close)(struct serio *);
 
 	struct serio_dev *dev;
-
 	struct serio *next;
 };
 
 struct serio_dev {
 
 	void *private;
+	char *name;
 
+	void (*write_wakeup)(struct serio *);
 	void (*interrupt)(struct serio *, unsigned char, unsigned int);
 	void (*connect)(struct serio *, struct serio_dev *dev);
 	void (*disconnect)(struct serio *);
@@ -77,7 +84,14 @@
 
 static __inline__ int serio_write(struct serio *serio, unsigned char data)
 {
-	return serio->write(serio, data);
+	return serio->write?serio->write(serio, data):-ENOSYS;
+}
+
+static __inline__ void serio_dev_write_wakeup(struct serio *serio)
+{
+	if (serio->dev && serio->dev->write_wakeup) {
+		serio->dev->write_wakeup(serio);
+	}
 }
 
 #define SERIO_TIMEOUT	1
@@ -109,6 +123,8 @@
 #define SERIO_STOWAWAY	0x20
 #define SERIO_H3600	0x21
 #define SERIO_PS2SER	0x22
+#define SERIO_TWIDKBD	0x23
+#define SERIO_TWIDJOY	0x24
 #define SERIO_HIL	0x25
 
 #define SERIO_ID	0xff00UL
