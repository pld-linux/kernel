; https://github.com/sfjro/aufs-standalone/issues/35
; from https://github.com/tombriden/linux/commits/linux-6.7.y
;
From 29bbb4f7a4322a7dbbebb9ac80088ef02085457a Mon Sep 17 00:00:00 2001
From: Tom Briden <tom@decompile.me.uk>
Date: Fri, 22 Dec 2023 08:09:43 +0000
Subject: [PATCH] fix(aufs): apply fix from upstream

---
 fs/aufs/i_op.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/fs/aufs/i_op.c b/fs/aufs/i_op.c
index a5cc8743c2bca4..f64e465c37e8ae 100644
--- a/fs/aufs/i_op.c
+++ b/fs/aufs/i_op.c
@@ -1293,9 +1293,14 @@ static int aufs_getattr(struct mnt_idmap *idmap, const struct path *path,
 		goto out_fill; /* pretending success */
 
 	positive = d_is_positive(h_path.dentry);
-	if (positive)
+	if (positive) {
 		/* no vfsub version */
 		err = vfs_getattr(&h_path, st, request, query);
+		if (query & AT_GETATTR_NOSEC)
+			err = vfs_getattr_nosec(&h_path, st, request, query);
+		else
+			err = vfs_getattr(&h_path, st, request, query);
+	}
 	if (!err) {
 		if (positive)
 			au_refresh_iattr(inode, st,
From 4f20b6e23c56db7520a8416b752f7820920ec283 Mon Sep 17 00:00:00 2001
From: Tom Briden <tom@decompile.me.uk>
Date: Thu, 11 Jan 2024 11:20:23 +0000
Subject: [PATCH] aufs: fixes for linux-6.7.y

---
 fs/aufs/branch.c | 2 +-
 fs/aufs/cpup.c   | 8 ++++----
 fs/aufs/dir.c    | 2 +-
 fs/aufs/i_op.c   | 4 ++--
 fs/aufs/vfsub.h  | 2 +-
 fs/namespace.c   | 1 -
 fs/proc/base.c   | 2 +-
 7 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/fs/aufs/branch.c b/fs/aufs/branch.c
index 2a85d744d2b5f7..3ecc05573cc028 100644
--- a/fs/aufs/branch.c
+++ b/fs/aufs/branch.c
@@ -1293,7 +1293,7 @@ static int au_br_mod_files_ro(struct super_block *sb, aufs_bindex_t bindex)
 			if (hf->f_mode & FMODE_READ)
 				i_readcount_inc(h_inode);
 			put_write_access(h_inode);
-			__mnt_drop_write(hf->f_path.mnt);
+			mnt_put_write_access(hf->f_path.mnt);
 		}
 	}
 
diff --git a/fs/aufs/cpup.c b/fs/aufs/cpup.c
index 8c8bd5f7b28d81..3f09876a3bd5ee 100644
--- a/fs/aufs/cpup.c
+++ b/fs/aufs/cpup.c
@@ -133,8 +133,8 @@ void au_dtime_store(struct au_dtime *dt, struct dentry *dentry,
 	dt->dt_dentry = dentry;
 	dt->dt_h_path = *h_path;
 	h_inode = d_inode(h_path->dentry);
-	dt->dt_atime = h_inode->i_atime;
-	dt->dt_mtime = h_inode->i_mtime;
+	dt->dt_atime = h_inode->__i_atime;
+	dt->dt_mtime = h_inode->__i_mtime;
 	/* smp_mb(); */
 }
 
@@ -200,8 +200,8 @@ int cpup_iattr(struct dentry *dst, aufs_bindex_t bindex, struct path *h_src,
 	} else {
 		ia.ia_uid = h_isrc->i_uid;
 		ia.ia_gid = h_isrc->i_gid;
-		ia.ia_atime = h_isrc->i_atime;
-		ia.ia_mtime = h_isrc->i_mtime;
+		ia.ia_atime = h_isrc->__i_atime;
+		ia.ia_mtime = h_isrc->__i_mtime;
 		if (h_idst->i_mode != h_isrc->i_mode
 		    && !S_ISLNK(h_idst->i_mode)) {
 			ia.ia_valid |= ATTR_MODE;
diff --git a/fs/aufs/dir.c b/fs/aufs/dir.c
index ee900ea3264b22..e986deffef5e9e 100644
--- a/fs/aufs/dir.c
+++ b/fs/aufs/dir.c
@@ -145,7 +145,7 @@ static void au_do_dir_ts(void *arg)
 	au_hn_inode_lock_nested(hdir, AuLsc_I_PARENT);
 	h_dir = au_h_iptr(dir, btop);
 	if (h_dir->i_nlink
-	    && timespec64_compare(&h_dir->i_mtime, &dt.dt_mtime) < 0) {
+	    && timespec64_compare(&h_dir->__i_mtime, &dt.dt_mtime) < 0) {
 		dt.dt_h_path = h_path;
 		au_dtime_revert(&dt);
 	}
diff --git a/fs/aufs/i_op.c b/fs/aufs/i_op.c
index f64e465c37e8ae..020a88b719567c 100644
--- a/fs/aufs/i_op.c
+++ b/fs/aufs/i_op.c
@@ -1167,8 +1167,8 @@ static void au_refresh_iattr(struct inode *inode, struct kstat *st,
 	/* don't i_[ug]id_write() here */
 	inode->i_uid = st->uid;
 	inode->i_gid = st->gid;
-	inode->i_atime = st->atime;
-	inode->i_mtime = st->mtime;
+	inode->__i_atime = st->atime;
+	inode->__i_mtime = st->mtime;
 	inode_set_ctime_to_ts(inode, st->ctime);
 
 	au_cpup_attr_nlink(inode, /*force*/0);
diff --git a/fs/aufs/vfsub.h b/fs/aufs/vfsub.h
index ed218d95770d0c..b45603c2d651bf 100644
--- a/fs/aufs/vfsub.h
+++ b/fs/aufs/vfsub.h
@@ -33,7 +33,7 @@
 
 /* copied from linux/fs/internal.h */
 /* todo: BAD approach!! */
-extern void __mnt_drop_write(struct vfsmount *);
+extern void mnt_put_write_access(struct vfsmount *);
 extern struct file *alloc_empty_file(int, const struct cred *);
 
 /* ---------------------------------------------------------------------- */
diff --git a/fs/namespace.c b/fs/namespace.c
index 1b942a6b72fa9f..07e2fee153f7f3 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -489,7 +489,6 @@ void mnt_put_write_access_file(struct file *file)
 	if (!(file->f_mode & FMODE_WRITER))
 		mnt_put_write_access(file->f_path.mnt);
 }
-EXPORT_SYMBOL_GPL(__mnt_drop_write);
 
 void mnt_drop_write_file(struct file *file)
 {
diff --git a/fs/proc/base.c b/fs/proc/base.c
index dd31e3b6bf77cc..d4dcd73a765a20 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -2214,7 +2214,7 @@ static int map_files_get_link(struct dentry *dentry, struct path *path)
 	rc = -ENOENT;
 	vma = find_exact_vma(mm, vm_start, vm_end);
 	if (vma && vma->vm_file) {
-		*path = *file_user_path(vma->vm_file);
+		*path = vma_pr_or_file(vma)->f_path;
 		path_get(path);
 		rc = 0;
 	}
