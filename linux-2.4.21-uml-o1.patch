diff -urN linux-2.4.20-uml/arch/um/include/2_5compat.h linux-2.4.20-uml-o1/arch/um/include/2_5compat.h
--- linux-2.4.20-uml/arch/um/include/2_5compat.h	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/include/2_5compat.h	Sat Mar 15 20:46:24 2003
@@ -32,8 +31,7 @@
 
 #define IS_WRITE(req) ((req)->cmd == WRITE)
 
-#define SET_PRI(task) \
-	do { (task)->nice = 20; (task)->counter = -100; } while(0);
+#define SET_PRI(task) do { } while(0)
 
 #else
 
diff -u um/arch/um/include/kern_util.h um/arch/um/include/kern_util.h
--- um/arch/um/include/kern_util.h
+++ um/arch/um/include/kern_util.h
@@ -106,7 +106,7 @@
 extern void arch_switch(void);
 extern void free_irq(unsigned int, void *);
 extern int um_in_interrupt(void);
-extern int cpu(void);
+extern int um_cpu(void);
 #endif
 
 /*
diff -urN linux-2.4.20-uml/arch/um/include/user_util.h linux-2.4.20-uml-o1/arch/um/include/user_util.h
--- linux-2.4.20-uml/arch/um/include/user_util.h	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/include/user_util.h	Sat Mar 15 19:58:20 2003
@@ -89,6 +89,7 @@
 extern int arch_fixup(unsigned long address, void *sc_ptr);
 extern int can_do_skas(void);
 extern void arch_init_thread(void);
+extern void forward_pending_sigio(int target);
 
 #endif
 
diff -urN linux-2.4.20-uml/arch/um/kernel/irq.c linux-2.4.20-uml-o1/arch/um/kernel/irq.c
--- linux-2.4.20-uml/arch/um/kernel/irq.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/irq.c	Sat Mar 15 20:30:22 2003
@@ -151,10 +151,12 @@
 
 	status = 1;	/* Force the "do bottom halves" bit */
 
-	if (!(action->flags & SA_INTERRUPT))
-		__sti();
-
 	do {
+		if (!(action->flags & SA_INTERRUPT))
+			__sti();
+		else
+			__cli();
+
 		status |= action->flags;
 		action->handler(irq, action->dev_id, regs);
 		action = action->next;
diff -urN linux-2.4.20-uml/arch/um/kernel/process.c linux-2.4.20-uml-o1/arch/um/kernel/process.c
--- linux-2.4.20-uml/arch/um/kernel/process.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/process.c	Sat Mar 15 19:59:12 2003
@@ -275,6 +275,16 @@
 #endif
 }
 
+void forward_pending_sigio(int target)
+{
+	sigset_t sigs;
+
+	if(sigpending(&sigs)) 
+		panic("forward_pending_sigio : sigpending failed");
+	if(sigismember(&sigs, SIGIO))
+		kill(target, SIGIO);
+}
+
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically
diff -u um/arch/um/kernel/process_kern.c um/arch/um/kernel/process_kern.c
--- um/arch/um/kernel/process_kern.c
+++ um/arch/um/kernel/process_kern.c
@@ -124,7 +124,7 @@
 {
 	struct task_struct *task = t;
 
-	cpu_tasks[task->processor] = ((struct cpu_task) 
+	cpu_tasks[task->cpu] = ((struct cpu_task) 
 		{ external_pid(task), task });
 }
 
@@ -360,7 +360,7 @@
 int smp_sigio_handler(void)
 {
 #ifdef CONFIG_SMP
-	int cpu = current->processor;
+	int cpu = current->cpu;
 
 	IPI_handler(cpu);
 	if(cpu != 0)
@@ -374,9 +374,9 @@
 	return(in_interrupt());
 }
 
-int cpu(void)
+int um_cpu(void)
 {
-        return(current->processor);
+        return(current->cpu);
 }
 
 /*
--- linux-2.4.20/arch/um/kernel/reboot.c~	Sun Mar 16 01:41:54 2003
+++ linux-2.4.20/arch/um/kernel/reboot.c	Sun Mar 16 03:05:25 2003
@@ -14,15 +14,9 @@
 #ifdef CONFIG_SMP
 static void kill_idlers(int me)
 {
-	struct task_struct *p;
-	int i;
-
-	for(i = 0; i < sizeof(init_tasks)/sizeof(init_tasks[0]); i++){
-		p = init_tasks[i];
-		if((p != NULL) && (p->thread.mode.tt.extern_pid != me) &&
-		   (p->thread.mode.tt.extern_pid != -1))
-			os_kill_process(p->thread.mode.tt.extern_pid, 0);
-	}
+	if((init_task.thread.mode.tt.extern_pid != me) &&
+	   (init_task.thread.mode.tt.extern_pid != -1))
+		os_kill_process(init_task.thread.mode.tt.extern_pid, 0);
 }
 #endif
 
diff -urN linux-2.4.20-uml/arch/um/kernel/skas/process_kern.c linux-2.4.20-uml-o1/arch/um/kernel/skas/process_kern.c
--- linux-2.4.20-uml/arch/um/kernel/skas/process_kern.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/skas/process_kern.c	Sat Mar 15 20:03:07 2003
@@ -47,7 +47,7 @@
 	return(current->thread.prev_sched);
 }
 
-extern void schedule_tail(struct task_struct *prev);
+asmlinkage void schedule_tail(task_t *prev);
 
 void new_thread_handler(int sig)
 {
@@ -60,8 +60,10 @@
 	thread_wait(&current->thread.mode.skas.switch_buf, 
 		    current->thread.mode.skas.fork_buf);
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	n = run_kernel_thread(fn, arg, &current->thread.exec_buf);
@@ -91,8 +93,10 @@
 		    current->thread.mode.skas.fork_buf);
   	
 	force_flush_all();
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 	unblock_signals();
 
@@ -137,7 +137,7 @@
 
 void init_idle_skas(void)
 {
-	cpu_tasks[current->processor].pid = os_getpid();
+	cpu_tasks[current->cpu].pid = os_getpid();
 }
 
 extern void start_kernel(void);
diff -u um/arch/um/kernel/skas/trap_user.c um/arch/um/kernel/skas/trap_user.c
--- um/arch/um/kernel/skas/trap_user.c
+++ um/arch/um/kernel/skas/trap_user.c
@@ -42,7 +42,7 @@
 	struct signal_info *info;
 
 	if(sig == SIGVTALRM)
-		missed_ticks[cpu()]++;
+		missed_ticks[um_cpu()]++;
 	regs->skas.is_user = 1;
 	regs->skas.fault_addr = 0;
 	regs->skas.fault_type = 0;
--- linux-2.4.20/arch/um/kernel/smp.c~	Sat Mar 15 23:38:50 2003
+++ linux-2.4.20/arch/um/kernel/smp.c	Sun Mar 16 01:27:45 2003
@@ -30,6 +30,8 @@
 
 /* Per CPU bogomips and other parameters */
 
+unsigned long cache_decay_ticks = HZ/100;
+
 /* The only piece used here is the ipi pipe, which is set before SMP is
  * started and never changed.
  */
@@ -97,7 +97,7 @@
  
 	printk(KERN_INFO "Stopping all CPUs...");
 	for(i = 0; i < ncpus; i++){
-		if(i == current->processor)
+		if(i == current->cpu)
 			continue;
 		write(cpu_data[i].ipi_pipe[1], "S", 1);
 	}
@@ -121,10 +121,9 @@
 	int cpu, err;
 
 	set_current(current);
-	del_from_runqueue(current);
 	unhash_process(current);
 
-	cpu = current->processor;
+	cpu = current->cpu;
 	err = os_pipe(cpu_data[cpu].ipi_pipe, 1, 1);
 	if(err)
 		panic("CPU#%d failed to create IPI pipe, errno = %d", cpu, 
@@ -134,8 +134,8 @@
 		     current->thread.mode.tt.extern_pid);
  
 	wmb();
-	if (test_and_set_bit(current->processor, &smp_callin_map)) {
-		printk("huh, CPU#%d already present??\n", current->processor);
+	if (test_and_set_bit(current->cpu, &smp_callin_map)) {
+		printk("huh, CPU#%d already present??\n", current->cpu);
 		BUG();
 	}
 
@@ -142,7 +142,6 @@
 	while (!atomic_read(&smp_commenced))
 		cpu_relax();
 
-	init_idle();
 	cpu_idle();
 	return(0);
 }
@@ -161,10 +160,8 @@
 
 	cpu_tasks[cpu].pid = new_task->thread.mode.tt.extern_pid;
 	cpu_tasks[cpu].task = new_task;
-	init_tasks[cpu] = new_task;
-	new_task->processor = cpu;
+	init_idle(new_task, cpu);
 	new_task->cpus_allowed = 1 << cpu;
-	new_task->cpus_runnable = new_task->cpus_allowed;
 	CHOOSE_MODE(write(new_task->thread.mode.tt.switch_pipe[1], &c, 
 			  sizeof(c)),
 		    ({ panic("skas mode doesn't support SMP"); }));
@@ -296,7 +296,7 @@
 	info = _info;
 
 	for (i=0;i<NR_CPUS;i++)
-		if (i != current->processor && test_bit(i, &cpu_online_map))
+		if (i != current->cpu && test_bit(i, &cpu_online_map))
 			write(cpu_data[i].ipi_pipe[1], "C", 1);
 
 	while (atomic_read(&scf_started) != cpus)
diff -urN linux-2.4.20-uml/arch/um/kernel/sys_call_table.c linux-2.4.20-uml-o1/arch/um/kernel/sys_call_table.c
--- linux-2.4.20-uml/arch/um/kernel/sys_call_table.c	Sat Mar 15 18:34:03 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/sys_call_table.c	Sat Mar 15 19:41:51 2003
@@ -153,6 +153,7 @@
 extern syscall_handler_t sys_sched_getparam;
 extern syscall_handler_t sys_sched_setscheduler;
 extern syscall_handler_t sys_sched_getscheduler;
+extern syscall_handler_t sys_sched_yield;
 extern syscall_handler_t sys_sched_get_priority_max;
 extern syscall_handler_t sys_sched_get_priority_min;
 extern syscall_handler_t sys_sched_rr_get_interval;
@@ -261,7 +262,7 @@
 
 	/* declared differently in kern_util.h */
 	[ __NR_execve ] = (syscall_handler_t *) sys_execve,
-	[ __NR_chdir ] = sys_chdir,
+	[ __NR_chdir ] = (syscall_handler_t *) sys_chdir,
 	[ __NR_time ] = um_time,
 	[ __NR_mknod ] = sys_mknod,
 	[ __NR_chmod ] = sys_chmod,
@@ -306,15 +307,15 @@
 	[ __NR_umount2 ] = sys_umount,
 	[ __NR_lock ] = sys_ni_syscall,
 	[ __NR_ioctl ] = sys_ioctl,
-	[ __NR_fcntl ] = sys_fcntl,
+	[ __NR_fcntl ] = (syscall_handler_t *) sys_fcntl,
 	[ __NR_mpx ] = sys_ni_syscall,
 	[ __NR_setpgid ] = sys_setpgid,
 	[ __NR_ulimit ] = sys_ni_syscall,
 	[ __NR_oldolduname ] = sys_olduname,
 	[ __NR_umask ] = sys_umask,
-	[ __NR_chroot ] = sys_chroot,
+	[ __NR_chroot ] = (syscall_handler_t *) sys_chroot,
 	[ __NR_ustat ] = sys_ustat,
-	[ __NR_dup2 ] = sys_dup2,
+	[ __NR_dup2 ] = (syscall_handler_t *) sys_dup2,
 	[ __NR_getppid ] = sys_getppid,
 	[ __NR_getpgrp ] = sys_getpgrp,
 	[ __NR_setsid ] = (syscall_handler_t *) sys_setsid,
--- linux-2.4.20/arch/um/kernel/time_kern.c~	Sat Mar 15 23:38:50 2003
+++ linux-2.4.20/arch/um/kernel/time_kern.c	Sun Mar 16 01:20:23 2003
@@ -37,7 +37,7 @@
 
 void timer_irq(union uml_pt_regs *regs)
 {
-	int cpu = current->processor, ticks = missed_ticks[cpu];
+	int cpu = current->cpu, ticks = missed_ticks[cpu];
 
         if(!timer_irq_inited) return;
 	missed_ticks[cpu] = 0;
@@ -123,7 +123,7 @@
 #ifdef CONFIG_SMP
 	update_process_times(user_context(UPT_SP(regs)));
 #endif
-	if(current->processor == 0)
+	if(current->cpu == 0)
 		timer_irq(regs);
 }
 
diff -u um/arch/um/kernel/trap_user.c um/arch/um/kernel/trap_user.c
--- um/arch/um/kernel/trap_user.c
+++ um/arch/um/kernel/trap_user.c
@@ -107,7 +107,7 @@
 void alarm_handler(int sig, struct sigcontext sc)
 {
 	if(!timer_irq_inited) return;
-	missed_ticks[cpu()]++;
+	missed_ticks[um_cpu()]++;
 
 	if(sig == SIGALRM)
 		switch_timers(0);
--- linux-2.4.20/arch/um/kernel/tt/exec_kern.c~	Sat Mar 15 23:38:50 2003
+++ linux-2.4.20/arch/um/kernel/tt/exec_kern.c	Sun Mar 16 01:12:57 2003
@@ -46,7 +46,7 @@
 		do_exit(SIGKILL);
 	}
 
-	if(current->processor == 0)
+	if(current->cpu == 0)
 		forward_interrupts(new_pid);
 	current->thread.request.op = OP_EXEC;
 	current->thread.request.u.exec.pid = new_pid;
diff -urN linux-2.4.20-uml/arch/um/kernel/tt/process_kern.c linux-2.4.20-uml-o1/arch/um/kernel/tt/process_kern.c
--- linux-2.4.20-uml/arch/um/kernel/tt/process_kern.c	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/arch/um/kernel/tt/process_kern.c	Sat Mar 15 20:06:05 2003
@@ -29,10 +29,6 @@
 	unsigned long flags;
 	int err, vtalrm, alrm, prof, cpu;
 	char c;
-	/* jailing and SMP are incompatible, so this doesn't need to be 
-	 * made per-cpu 
-	 */
-	static int reading;
 
 	from = prev;
 	to = next;
@@ -35,7 +35,7 @@
 
 	to->thread.prev_sched = from;
 
-	cpu = from->processor;
+	cpu = from->cpu;
 	if(cpu == 0)
 		forward_interrupts(to->thread.mode.tt.extern_pid);
 #ifdef CONFIG_SMP
@@ -51,15 +47,15 @@
 	alrm = change_sig(SIGALRM, 0);
 	prof = change_sig(SIGPROF, 0);
 
+	forward_pending_sigio(to->thread.mode.tt.extern_pid);
+
 	c = 0;
 	set_current(to);
 
-	reading = 0;
 	err = os_write_file(to->thread.mode.tt.switch_pipe[1], &c, sizeof(c));
 	if(err != sizeof(c))
 		panic("write of switch_pipe failed, errno = %d", -err);
 
-	reading = 1;
 	if(from->state == TASK_ZOMBIE)
 		os_kill_process(os_getpid(), 0);
 
@@ -67,24 +63,6 @@
 	if(err != sizeof(c))
 		panic("read of switch_pipe failed, errno = %d", -err);
 
-	/* This works around a nasty race with 'jail'.  If we are switching
-	 * between two threads of a threaded app and the incoming process 
-	 * runs before the outgoing process reaches the read, and it makes
-	 * it all the way out to userspace, then it will have write-protected 
-	 * the outgoing process stack.  Then, when the outgoing process 
-	 * returns from the write, it will segfault because it can no longer
-	 * write its own stack.  So, in order to avoid that, the incoming 
-	 * thread sits in a loop yielding until 'reading' is set.  This 
-	 * isn't entirely safe, since there may be a reschedule from a timer
-	 * happening between setting 'reading' and sleeping in read.  But,
-	 * it should get a whole quantum in which to reach the read and sleep,
-	 * which should be enough.
-	 */
-
-	if(jail){
-		while(!reading) sched_yield();
-	}
-
 	change_sig(SIGVTALRM, vtalrm);
 	change_sig(SIGALRM, alrm);
 	change_sig(SIGPROF, prof);
@@ -108,7 +86,7 @@
 	close(current->thread.mode.tt.switch_pipe[1]);
 }
 
-extern void schedule_tail(struct task_struct *prev);
+asmlinkage void schedule_tail(task_t *prev);
 
 static void new_thread_handler(int sig)
 {
@@ -126,8 +104,10 @@
 	set_cmdline("(kernel thread)");
 	force_flush_all();
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	change_sig(SIGUSR1, 1);
@@ -169,8 +149,10 @@
 			       1, 0, 1);
 	task_protections((unsigned long) current);
 
+#ifdef CONFIG_SMP
 	if(current->thread.prev_sched != NULL)
 		schedule_tail(current->thread.prev_sched);
+#endif
 	current->thread.prev_sched = NULL;
 
 	free_page(current->thread.temp_stack);
@@ -281,7 +281,7 @@
 		pid = thread->request.u.exec.pid;
 		do_exec(thread->mode.tt.extern_pid, pid);
 		thread->mode.tt.extern_pid = pid;
-		cpu_tasks[task->processor].pid = pid;
+		cpu_tasks[task->cpu].pid = pid;
 		break;
 	case OP_FORK:
 		attach_process(thread->request.u.fork.pid);
diff -urN linux-2.4.20-uml/include/asm-um/cache.h linux-2.4.20-uml-o1/include/asm-um/cache.h
--- linux-2.4.20-uml/include/asm-um/cache.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/cache.h	Sat Mar 15 20:23:30 2003
@@ -1,6 +1,7 @@
 #ifndef __UM_CACHE_H
 #define __UM_CACHE_H
 
-#define        L1_CACHE_BYTES  32
+#define L1_CACHE_SHIFT  (5)
+#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
 
 #endif
diff -urN linux-2.4.20-uml/include/asm-um/fixmap.h linux-2.4.20-uml-o1/include/asm-um/fixmap.h
--- linux-2.4.20-uml/include/asm-um/fixmap.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/fixmap.h	Sat Mar 15 20:44:39 2003
@@ -2,7 +2,9 @@
 #define __UM_FIXMAP_H
 
 #include <linux/config.h>
+#ifdef CONFIG_HIGHMEM
 #include <asm/kmap_types.h>
+#endif
 
 /*
  * Here we define all the compile-time 'special' virtual
diff -urN linux-2.4.20-uml/include/asm-um/page.h linux-2.4.20-uml-o1/include/asm-um/page.h
--- linux-2.4.20-uml/include/asm-um/page.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/page.h	Sat Mar 15 19:47:48 2003
@@ -50,4 +50,7 @@
 extern struct page *arch_validate(struct page *page, int mask, int order);
 #define HAVE_ARCH_VALIDATE
 
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
 #endif
diff -urN linux-2.4.20-uml/include/asm-um/smp.h linux-2.4.20-uml-o1/include/asm-um/smp.h
--- linux-2.4.20-uml/include/asm-um/smp.h	Sat Mar 15 18:34:04 2003
+++ linux-2.4.20-uml-o1/include/asm-um/smp.h	Sat Mar 15 19:50:18 2003
@@ -6,7 +6,7 @@
 #include "linux/config.h"
 #include "asm/current.h"
 
-#define smp_processor_id() (current->processor)
+#define smp_processor_id() (current->cpu)
 #define cpu_logical_map(n) (n)
 #define cpu_number_map(n) (n)
 #define PROC_CHANGE_PENALTY	15 /* Pick a number, any number */
