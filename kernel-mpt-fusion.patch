Subject: MPT fusion driver update to 4.16.00.00
From: Satya Prakash <sathya.prakash@lsi.com>
Date: Thu Nov 20 14:13:01 2008 +0100:
References: bnc#425660

Update the mpt fusion driver to internal version 4.16.00.00.

Signed-off-by: Satya Prakash <sathya.prakash@lsi.com>
Acked-by: Hannes Reinecke <hare@suse.de>

Index: linux-2.6.27/drivers/message/fusion/csmi/csmisas.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/csmi/csmisas.c
+++ linux-2.6.27/drivers/message/fusion/csmi/csmisas.c
@@ -43,16 +43,13 @@
 */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-#define MPT_CSMI_DESCRIPTION "LSI Corporation: Fusion MPT Driver "MPT_LINUX_VERSION_COMMON
+#define MPT_CSMI_DESCRIPTION \
+    "LSI Corporation: Fusion MPT Driver "MPT_LINUX_VERSION_COMMON
 #define csmisas_is_this_sas_cntr(ioc) (ioc->bus_type == SAS) ? 1 : 0
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-#define __user
-#include <asm/div64.h>
-#endif
 
-static int csmisas_do_raid(MPT_ADAPTER *ioc, u8 action, u8 PhysDiskNum, u8 VolumeBus,
-    u8 VolumeId, pMpiRaidActionReply_t reply);
+static int csmisas_do_raid(MPT_ADAPTER *ioc, u8 action, u8 PhysDiskNum,
+    u8 VolumeBus, u8 VolumeId, pMpiRaidActionReply_t reply);
 static u8  map_sas_status_to_csmi(u8 mpi_sas_status);
 
 /**
@@ -66,7 +63,7 @@ reverse_byte_order64(u64 data64)
 {
 	int i;
 	u64 rc;
-	u8  *inWord = (u8*)&data64, *outWord = (u8*)&rc;
+	u8  *inWord = (u8 *)&data64, *outWord = (u8 *)&rc;
 
 	for (i = 0 ; i < 8 ; i++)
 		outWord[i] = inWord[7-i];
@@ -98,7 +95,7 @@ csmisas_is_sata(RaidPhysDiskPage0_t *phy
  *
  **/
 static inline int
-csmisas_is_end_device(struct mptsas_devinfo * attached)
+csmisas_is_end_device(struct mptsas_devinfo *attached)
 {
 	if ((attached->sas_address) &&
 	    (attached->device_info &
@@ -130,7 +127,8 @@ csmisas_is_phys_disk(MPT_ADAPTER *ioc, i
 		goto out;
 	for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {
 		if ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&
-		    (channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {
+		    (channel ==
+		     ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {
 			rc = 1;
 			goto out;
 		}
@@ -142,14 +140,14 @@ csmisas_is_phys_disk(MPT_ADAPTER *ioc, i
 	if (list_empty(&ioc->raid_data.inactive_list))
 		goto out;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	list_for_each_entry(component_info, &ioc->raid_data.inactive_list,
 	    list) {
 		if ((component_info->d.PhysDiskID == id) &&
 		    (component_info->d.PhysDiskBus == channel))
 			rc = 1;
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_unlock(&ioc->raid_data.inactive_list_mutex);
 
  out:
 	return rc;
@@ -161,7 +159,8 @@ csmisas_is_phys_disk(MPT_ADAPTER *ioc, i
  * Obtains the phys disk num for given H:C:T nexus
  *
  * input (channel/id)
- * output (phys disk number - used by SCSI_IO_PASSTHRU to access hidden component)
+ * output (phys disk number - used by SCSI_IO_PASSTHRU to access hidden
+ * component)
  *
  * returns - signed return means failure
  **/
@@ -176,7 +175,8 @@ csmisas_raid_id_to_num(MPT_ADAPTER *ioc,
 		goto out;
 	for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {
 		if ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&
-		    (channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {
+		    (channel ==
+		     ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {
 			rc = ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum;
 			goto out;
 		}
@@ -188,14 +188,14 @@ csmisas_raid_id_to_num(MPT_ADAPTER *ioc,
 	if (list_empty(&ioc->raid_data.inactive_list))
 		goto out;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	list_for_each_entry(component_info, &ioc->raid_data.inactive_list,
 	    list) {
 		if ((component_info->d.PhysDiskID == id) &&
 		    (component_info->d.PhysDiskBus == channel))
 			rc = component_info->d.PhysDiskNum;
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_unlock(&ioc->raid_data.inactive_list_mutex);
 
  out:
 	return rc;
@@ -218,7 +218,7 @@ csmisas_get_device_component_by_os(MPT_A
 
 	sas_info = NULL;
 
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry(p, &ioc->sas_device_info_list, list) {
 		if (p->os.channel == channel && p->os.id == id) {
 			sas_info = p;
@@ -227,7 +227,7 @@ csmisas_get_device_component_by_os(MPT_A
 	}
 
  out:
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 	return sas_info;
 }
 
@@ -248,7 +248,7 @@ csmisas_get_device_component_by_fw(MPT_A
 
 	sas_info = NULL;
 
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry(p, &ioc->sas_device_info_list, list) {
 		if (p->fw.channel == channel && p->fw.id == id) {
 			sas_info = p;
@@ -257,7 +257,7 @@ csmisas_get_device_component_by_fw(MPT_A
 	}
 
  out:
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 	return sas_info;
 }
 
@@ -279,7 +279,7 @@ csmisas_get_device_component_by_sas_addr
 
 	sas_info = NULL;
 
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry(p, &ioc->sas_device_info_list, list) {
 		if (p->sas_address == sas_address) {
 			sas_info = p;
@@ -288,7 +288,7 @@ csmisas_get_device_component_by_sas_addr
 	}
 
  out:
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 	return sas_info;
 }
 
@@ -305,7 +305,8 @@ csmisas_get_device_component_by_sas_addr
  *	non-zero, failure
  **/
 static int
-csmisas_send_command_wait(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, unsigned long timeout)
+csmisas_send_command_wait(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,
+    unsigned long timeout)
 {
 	int rc;
 	unsigned long timeleft;
@@ -314,40 +315,15 @@ csmisas_send_command_wait(MPT_ADAPTER *i
 	rc = 0;
 	timeleft = 0;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-
-	INITIALIZE_IOCTL_STATUS(ioc->ioctl_cmds.status)
-	ioc->ioctl_cmds.wait_done = 0;
-	ioc->ioctl_cmds.timer.expires = jiffies + (MPT_JIFFY * timeout);
-	ioc->ioctl_cmds.status |= MPT_MGMT_STATUS_TIMER_ACTIVE;
-	ADD_TIMER(&ioc->ioctl_cmds.timer);
-	mpt_put_msg_frame(mptctl_id, ioc, mf);
-	WAIT_EVENT(mptctl_wait, ioc->ioctl_cmds.wait_done);
-
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-
-	INITIALIZE_IOCTL_STATUS(ioc->ioctl_cmds.status)
-	ioc->ioctl_cmds.wait_done = 0;
-	mpt_put_msg_frame(mptctl_id, ioc, mf);
-
-	if ((wait_event_timeout(mptctl_wait,
-	    ioc->ioctl_cmds.wait_done == 1, HZ * timeout) <=0) &&
-	    ioc->ioctl_cmds.wait_done != 1 ) {
-		mptctl_timeout_expired(ioc,mf);
-		mpt_free_msg_frame(ioc, mf);
-		rc = -1;
-	}
-
-#else
-
 	SET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,
 	    mf->u.hdr.MsgContext);
 	INITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)
 	mpt_put_msg_frame(mptctl_id, ioc, mf);
-	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done, timeout*HZ);
+	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,
+	    timeout*HZ);
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -1;
-		printk("%s: failed\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: failed\n", __func__);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
 			CLEAR_MGMT_STATUS(ioc->ioctl_cmds.status)
@@ -357,7 +333,6 @@ csmisas_send_command_wait(MPT_ADAPTER *i
 			mptctl_timeout_expired(ioc, mf);
 	}
 	SET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, 0);
-#endif
 	return rc;
 }
 
@@ -375,7 +350,8 @@ csmisas_send_command_wait(MPT_ADAPTER *i
  *	non-zero, failure
  **/
 static int
-csmisas_send_handshake_wait(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, unsigned long timeout)
+csmisas_send_handshake_wait(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,
+    unsigned long timeout)
 {
 	int rc;
 	unsigned long timeleft;
@@ -384,42 +360,13 @@ csmisas_send_handshake_wait(MPT_ADAPTER 
 	rc = 0;
 	timeleft = 0;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
-
-	INITIALIZE_IOCTL_STATUS(ioc->taskmgmt_cmds.status)
-	ioc->taskmgmt_cmds.timer.expires = jiffies + (MPT_JIFFY*timeout);
-	ioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_TIMER_ACTIVE;
-	ioc->taskmgmt_cmds.wait_done = 0;
-	ADD_TIMER(&ioc->taskmgmt_cmds.timer);
-	rc = mpt_send_special_message(mptctl_taskmgmt_id, ioc,
-	    sizeof(SCSITaskMgmt_t), (u32*)mf, timeout, CAN_SLEEP);
-	if (rc != 0)
-		return rc;
-	WAIT_EVENT(mptctl_taskmgmt_wait, ioc->taskmgmt_cmds.wait_done);
-
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-
-	INITIALIZE_IOCTL_STATUS(ioc->taskmgmt_cmds.status)
-	ioc->taskmgmt_cmds.wait_done = 0;
-	rc = mpt_send_special_message(mptctl_taskmgmt_id, ioc,
-	    sizeof(SCSITaskMgmt_t), (u32*)mf, timeout, CAN_SLEEP);
-	if (rc != 0)
-		return rc;
-	if ((wait_event_timeout(mptctl_taskmgmt_wait,
-	    ioc->taskmgmt_cmds.wait_done == 1, HZ * timeout) <=0) &&
-	    ioc->taskmgmt_cmds.wait_done != 1 ) {
-		mptctl_timeout_expired(ioc, mf);
-		mpt_free_msg_frame(ioc, mf);
-		rc = -1;
-	}
-
-#else
 	INITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)
 	mpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);
-	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);
+	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,
+	    timeout*HZ);
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -1;
-		printk("%s: failed\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: failed\n", __func__);
 		mpt_clear_taskmgmt_in_progress_flag(ioc);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
@@ -429,7 +376,6 @@ csmisas_send_handshake_wait(MPT_ADAPTER 
 		if (!timeleft)
 			mptctl_timeout_expired(ioc, mf);
 	}
-#endif
 	return rc;
 }
 
@@ -527,7 +473,8 @@ csmisas_get_ioc_pg5(MPT_ADAPTER *ioc, IO
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
 	cfg.timeout = MPT_IOCTL_DEFAULT_TIMEOUT;
 
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
+	rc = mpt_config(ioc, &cfg);
+	if (rc != 0)
 		goto get_ioc_pg5;
 
 	if (hdr.PageLength == 0) {
@@ -547,7 +494,8 @@ csmisas_get_ioc_pg5(MPT_ADAPTER *ioc, IO
 	cfg.physAddr = dma_handle;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
+	rc = mpt_config(ioc, &cfg);
+	if (rc != 0)
 		goto get_ioc_pg5;
 
 	memcpy(iocPage5, buffer, data_size);
@@ -565,7 +513,8 @@ csmisas_get_ioc_pg5(MPT_ADAPTER *ioc, IO
  *	csmisas_sas_device_pg0 - sas device page 0
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@mptsas_devinfo: structure found in mptsas.h
- *	@form, @form_specific - defines the Page Address field in the config page
+ *	@form, @form_specific - defines the Page Address field in
+ *	the config page
  *		(pls refer to chapter 5.1 in the mpi spec)
  *
  *	Return: 0 for success
@@ -602,7 +551,8 @@ csmisas_sas_device_pg0(MPT_ADAPTER *ioc,
 	cfg.timeout = 10;
 
 	memset(device_info, 0, sizeof(struct mptsas_devinfo));
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
+	rc = mpt_config(ioc, &cfg);
+	if (rc != 0)
 		goto out;
 
 	if (!hdr.ExtPageLength) {
@@ -620,7 +570,8 @@ csmisas_sas_device_pg0(MPT_ADAPTER *ioc,
 	cfg.physAddr = dma_handle;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
+	rc = mpt_config(ioc, &cfg);
+	if (rc != 0)
 		goto out_free_consistent;
 
 	device_info->handle = le16_to_cpu(buffer->DevHandle);
@@ -664,31 +615,31 @@ csmisas_get_driver_info(unsigned long ar
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 	      "Unable to read in csmi_sas_get_driver_info_buffer struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Fill in the data and return the structure to the calling
 	 * program
 	 */
-	memcpy( karg.Information.szName, MPT_MISCDEV_BASENAME,
+	memcpy(karg.Information.szName, MPT_MISCDEV_BASENAME,
 	    sizeof(MPT_MISCDEV_BASENAME));
-	memcpy( karg.Information.szDescription, MPT_CSMI_DESCRIPTION,
+	memcpy(karg.Information.szDescription, MPT_CSMI_DESCRIPTION,
 	    sizeof(MPT_CSMI_DESCRIPTION));
 
 	karg.Information.usMajorRevision = MPT_LINUX_MAJOR_VERSION;
@@ -707,11 +658,11 @@ csmisas_get_driver_info(unsigned long ar
 		sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		   "Unable to write out csmi_sas_get_driver_info_buffer @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -736,28 +687,28 @@ csmisas_get_cntlr_config(unsigned long a
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_CNTLR_CONFIG_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 	     "Unable to read in csmi_sas_get_cntlr_config_buffer struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Clear the struct before filling in data. */
-	memset( &karg.Configuration, 0, sizeof(CSMI_SAS_CNTLR_CONFIG));
+	memset(&karg.Configuration, 0, sizeof(CSMI_SAS_CNTLR_CONFIG));
 
 	/* Fill in the data and return the structure to the calling
 	 * program
@@ -786,7 +737,7 @@ csmisas_get_cntlr_config(unsigned long a
 	karg.Configuration.BusAddress.PciAddress.bFunctionNumber =
 	    PCI_FUNC(ioc->pcidev->devfn);
 	karg.Configuration.BusAddress.PciAddress.bReserved = 0;
-	memcpy( &karg.Configuration.szSerialNumber, ioc->board_tracer, 16 );
+	memcpy(&karg.Configuration.szSerialNumber, ioc->board_tracer, 16);
 	karg.Configuration.usMajorRevision = ioc->facts.FWVersion.Struct.Major;
 	karg.Configuration.usMinorRevision = ioc->facts.FWVersion.Struct.Minor;
 	karg.Configuration.usBuildRevision = ioc->facts.FWVersion.Struct.Unit;
@@ -819,11 +770,11 @@ csmisas_get_cntlr_config(unsigned long a
 		sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to write out csmi_sas_get_driver_info_buffer @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -848,24 +799,24 @@ csmisas_get_cntlr_status(unsigned long a
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_CNTLR_STATUS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 	     "Unable to read in csmi_sas_get_cntlr_status_buffer struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Fill in the data and return the structure to the calling
 	 * program
@@ -902,11 +853,11 @@ csmisas_get_cntlr_status(unsigned long a
 		sizeof(CSMI_SAS_CNTLR_STATUS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		    "Unable to write out csmi_sas_get_cntlr_status @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -940,19 +891,19 @@ csmisas_get_phy_info(unsigned long arg)
 	struct mptsas_devinfo	device_info;
 	int			memory_pages;
 
-	sasIoUnitPg0=NULL;
-	sasPhyPg0=NULL;
-	sasIoUnitPg0_data_sz=0;
-	sasPhyPg0_data_sz=0;
+	sasIoUnitPg0 = NULL;
+	sasPhyPg0 = NULL;
+	sasIoUnitPg0_data_sz = 0;
+	sasPhyPg0_data_sz = 0;
 
 	memory_pages = get_order(sizeof(CSMI_SAS_PHY_INFO_BUFFER));
 	karg = (CSMI_SAS_PHY_INFO_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to malloc CSMI_SAS_PHY_INFO_BUFFER "
 			"malloc_data_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			(int)sizeof(CSMI_SAS_PHY_INFO_BUFFER), memory_pages);
 		return -ENOMEM;
 	}
@@ -962,7 +913,7 @@ csmisas_get_phy_info(unsigned long arg)
 	if (copy_from_user(karg, uarg, sizeof(CSMI_SAS_PHY_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in csmisas_get_phy_info_buffer struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -970,19 +921,19 @@ csmisas_get_phy_info(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Fill in the data and return the structure to the calling
 	 * program
@@ -1011,7 +962,7 @@ csmisas_get_phy_info(unsigned long arg)
 		 */
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASIOUNITPAGE0_PAGEVERSION: HEADER\n"));
-		dcsmisasprintk(ioc, printk(": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(": rc=%x\n", rc));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto sas_get_phy_info_exit;
 	}
@@ -1020,7 +971,8 @@ csmisas_get_phy_info(unsigned long arg)
 		/* Don't check if this failed.  Already in a
 		 * failure case.
 		 */
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": hdr.ExtPageLength == 0\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto sas_get_phy_info_exit;
 	}
@@ -1032,7 +984,8 @@ csmisas_get_phy_info(unsigned long arg)
 	    sasIoUnitPg0_data_sz, &sasIoUnitPg0_dma);
 
 	if (!sasIoUnitPg0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": pci_alloc_consistent: FAILED\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto sas_get_phy_info_exit;
 	}
@@ -1048,7 +1001,7 @@ csmisas_get_phy_info(unsigned long arg)
 		 */
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASIOUNITPAGE0_PAGEVERSION: PAGE\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto sas_get_phy_info_exit;
 	}
@@ -1058,27 +1011,30 @@ csmisas_get_phy_info(unsigned long arg)
 
 	/* Fill in information for each phy. */
 	for (ii = 0; ii < karg->Information.bNumberOfPhys; ii++) {
-
-/* EDM : dump IO Unit Page 0 data*/
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "---- IO UNIT PAGE 0 ------------\n"));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Handle=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"---- IO UNIT PAGE 0 ------------\n"));
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Handle=0x%X\n",
 		    le16_to_cpu(sasIoUnitPg0->PhyData[ii].AttachedDeviceHandle)));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Controller Handle=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Controller Handle=0x%X\n",
 		    le16_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerDevHandle)));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Port=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Port=0x%X\n",
 		    sasIoUnitPg0->PhyData[ii].Port));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "Port Flags=0x%X\n",
 		    sasIoUnitPg0->PhyData[ii].PortFlags));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "PHY Flags=0x%X\n",
 		    sasIoUnitPg0->PhyData[ii].PhyFlags));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Negotiated Link Rate=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Negotiated Link Rate=0x%X\n",
 		    sasIoUnitPg0->PhyData[ii].NegotiatedLinkRate));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Controller PHY Device Info=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Controller PHY Device Info=0x%X\n",
 		    le32_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo)));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "DiscoveryStatus=0x%X\n",
 		    le32_to_cpu(sasIoUnitPg0->PhyData[ii].DiscoveryStatus)));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "\n"));
-/* EDM : debug data */
 
 		/* PHY stuff. */
 		karg->Information.Phy[ii].bPortIdentifier =
@@ -1147,13 +1103,14 @@ csmisas_get_phy_info(unsigned long arg)
 		if ((rc = mpt_config(ioc, &cfg)) != 0) {
 			dcsmisasprintk(ioc, printk(KERN_ERR
 			    ": FAILED: MPI_SASPHY0_PAGEVERSION: HEADER\n"));
-			dcsmisasprintk(ioc, printk(": rc=%x\n",rc));
+			dcsmisasprintk(ioc, printk(": rc=%x\n", rc));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto sas_get_phy_info_exit;
 		}
 
 		if (hdr.ExtPageLength == 0) {
-			dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+			dcsmisasprintk(ioc, printk(KERN_ERR
+				": pci_alloc_consistent: FAILED\n"));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto sas_get_phy_info_exit;
 		}
@@ -1164,8 +1121,9 @@ csmisas_get_phy_info(unsigned long arg)
 		sasPhyPg0 = (SasPhyPage0_t *) pci_alloc_consistent(
 		    ioc->pcidev, sasPhyPg0_data_sz, &sasPhyPg0_dma);
 
-		if (! sasPhyPg0) {
-			dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		if (!sasPhyPg0) {
+			dcsmisasprintk(ioc, printk(KERN_ERR
+				": pci_alloc_consistent: FAILED\n"));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto sas_get_phy_info_exit;
 		}
@@ -1177,34 +1135,37 @@ csmisas_get_phy_info(unsigned long arg)
 		if ((rc = mpt_config(ioc, &cfg)) != 0) {
 			dcsmisasprintk(ioc, printk(KERN_ERR
 			    ": FAILED: MPI_SASPHY0_PAGEVERSION: PAGE\n"));
-			dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+			dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
 			    (u8 *) sasPhyPg0, sasPhyPg0_dma);
 			goto sas_get_phy_info_exit;
 		}
 
-/* EDM : dump PHY Page 0 data*/
 		memcpy(&sas_address, &sasPhyPg0->SASAddress, sizeof(u64));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "---- SAS PHY PAGE 0 ------------\n"));
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"---- SAS PHY PAGE 0 ------------\n"));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "Handle=0x%X\n",
 		    le16_to_cpu(sasPhyPg0->AttachedDevHandle)));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "SAS Address=0x%llX\n",
 		    (unsigned long long)sas_address));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Attached PHY Identifier=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Attached PHY Identifier=0x%X\n",
 		    sasPhyPg0->AttachedPhyIdentifier));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Attached Device Info=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Attached Device Info=0x%X\n",
 		    le32_to_cpu(sasPhyPg0->AttachedDeviceInfo)));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Programmed Link Rate=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Programmed Link Rate=0x%X\n",
 		    sasPhyPg0->ProgrammedLinkRate));
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "Hardware Link Rate=0x%X\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"Hardware Link Rate=0x%X\n",
 		    sasPhyPg0->HwLinkRate));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "Change Count=0x%X\n",
 		    sasPhyPg0->ChangeCount));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "PHY Info=0x%X\n",
 		    le32_to_cpu(sasPhyPg0->PhyInfo)));
 		dcsmisasprintk(ioc, printk(KERN_DEBUG "\n"));
-/* EDM : debug data */
 
 		/* save the data */
 
@@ -1284,8 +1245,9 @@ csmisas_get_phy_info(unsigned long arg)
 		}
 
 		karg->Information.Phy[ii].bPhyChangeCount = sasPhyPg0->ChangeCount;
-		if( sasPhyPg0->PhyInfo & MPI_SAS_PHY0_PHYINFO_VIRTUAL_PHY )
-			karg->Information.Phy[ii].bPhyFeatures = CSMI_SAS_PHY_VIRTUAL_SMP;
+		if (sasPhyPg0->PhyInfo & MPI_SAS_PHY0_PHYINFO_VIRTUAL_PHY)
+			karg->Information.Phy[ii].bPhyFeatures
+			   = CSMI_SAS_PHY_VIRTUAL_SMP;
 
 		/* Fill in Attached Device
 		 * Initiator Port Protocol.
@@ -1295,17 +1257,17 @@ csmisas_get_phy_info(unsigned long arg)
 		protocol = le32_to_cpu(sasPhyPg0->AttachedDeviceInfo) & 0x78;
 		karg->Information.Phy[ii].Attached.bInitiatorPortProtocol = 0;
 		if (protocol & MPI_SAS_DEVICE_INFO_SSP_INITIATOR)
-		      karg->Information.Phy[ii].Attached.bInitiatorPortProtocol =
-			    CSMI_SAS_PROTOCOL_SSP;
+		      karg->Information.Phy[ii].Attached.bInitiatorPortProtocol
+			  = CSMI_SAS_PROTOCOL_SSP;
 		if (protocol & MPI_SAS_DEVICE_INFO_STP_INITIATOR)
-		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_STP;
+		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_STP;
 		if (protocol & MPI_SAS_DEVICE_INFO_SMP_INITIATOR)
-		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SMP;
+		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_SMP;
 		if (protocol & MPI_SAS_DEVICE_INFO_SATA_HOST)
-		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SATA;
+		     karg->Information.Phy[ii].Attached.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_SATA;
 
 		/* Fill in Phy Target Port
 		 * Protocol. Bits 10:7
@@ -1314,17 +1276,17 @@ csmisas_get_phy_info(unsigned long arg)
 		protocol = le32_to_cpu(sasPhyPg0->AttachedDeviceInfo) & 0x780;
 		karg->Information.Phy[ii].Attached.bTargetPortProtocol = 0;
 		if (protocol & MPI_SAS_DEVICE_INFO_SSP_TARGET)
-			karg->Information.Phy[ii].Attached.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SSP;
+			karg->Information.Phy[ii].Attached.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SSP;
 		if (protocol & MPI_SAS_DEVICE_INFO_STP_TARGET)
-			karg->Information.Phy[ii].Attached.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_STP;
+			karg->Information.Phy[ii].Attached.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_STP;
 		if (protocol & MPI_SAS_DEVICE_INFO_SMP_TARGET)
-			karg->Information.Phy[ii].Attached.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SMP;
+			karg->Information.Phy[ii].Attached.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SMP;
 		if (protocol & MPI_SAS_DEVICE_INFO_SATA_DEVICE)
-			karg->Information.Phy[ii].Attached.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SATA;
+			karg->Information.Phy[ii].Attached.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SATA;
 
 
 		/* Fill in Attached device type */
@@ -1353,7 +1315,8 @@ csmisas_get_phy_info(unsigned long arg)
 		}
 
 		/* Identify Info. */
-		switch (le32_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo) &
+		switch (le32_to_cpu
+		    (sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo) &
 		    MPI_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {
 
 		case MPI_SAS_DEVICE_INFO_NO_DEVICE:
@@ -1383,18 +1346,18 @@ csmisas_get_phy_info(unsigned long arg)
 		protocol = le32_to_cpu(
 		    sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo) & 0x78;
 		karg->Information.Phy[ii].Identify.bInitiatorPortProtocol = 0;
-		if( protocol & MPI_SAS_DEVICE_INFO_SSP_INITIATOR )
-		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SSP;
-		if( protocol & MPI_SAS_DEVICE_INFO_STP_INITIATOR )
-		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_STP;
-		if( protocol & MPI_SAS_DEVICE_INFO_SMP_INITIATOR )
-		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SMP;
-		if( protocol & MPI_SAS_DEVICE_INFO_SATA_HOST )
-		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SATA;
+		if (protocol & MPI_SAS_DEVICE_INFO_SSP_INITIATOR)
+		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_SSP;
+		if (protocol & MPI_SAS_DEVICE_INFO_STP_INITIATOR)
+		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_STP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SMP_INITIATOR)
+		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_SMP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SATA_HOST)
+		     karg->Information.Phy[ii].Identify.bInitiatorPortProtocol
+			 |= CSMI_SAS_PROTOCOL_SATA;
 
 		/* Fill in Phy Target Port Protocol. Bits 10:7
 		 * More than one bit can be set, fall through cases.
@@ -1402,18 +1365,18 @@ csmisas_get_phy_info(unsigned long arg)
 		protocol = le32_to_cpu(
 		    sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo) & 0x780;
 		karg->Information.Phy[ii].Identify.bTargetPortProtocol = 0;
-		if( protocol & MPI_SAS_DEVICE_INFO_SSP_TARGET )
-			karg->Information.Phy[ii].Identify.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SSP;
-		if( protocol & MPI_SAS_DEVICE_INFO_STP_TARGET )
-			karg->Information.Phy[ii].Identify.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_STP;
-		if( protocol & MPI_SAS_DEVICE_INFO_SMP_TARGET )
-			karg->Information.Phy[ii].Identify.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SMP;
-		if( protocol & MPI_SAS_DEVICE_INFO_SATA_DEVICE )
-			karg->Information.Phy[ii].Identify.bTargetPortProtocol |=
-			    CSMI_SAS_PROTOCOL_SATA;
+		if (protocol & MPI_SAS_DEVICE_INFO_SSP_TARGET)
+			karg->Information.Phy[ii].Identify.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SSP;
+		if (protocol & MPI_SAS_DEVICE_INFO_STP_TARGET)
+			karg->Information.Phy[ii].Identify.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_STP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SMP_TARGET)
+			karg->Information.Phy[ii].Identify.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SMP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SATA_DEVICE)
+			karg->Information.Phy[ii].Identify.bTargetPortProtocol
+			    |= CSMI_SAS_PROTOCOL_SATA;
 
 		/* Setup SAS Address for the attached device */
 		if (sasPhyPg0->AttachedDevHandle) {
@@ -1450,13 +1413,13 @@ sas_get_phy_info_exit:
 	    sizeof(CSMI_SAS_PHY_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		    "Unable to write out csmisas_get_phy_info_buffer @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__,  __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
 	free_pages((unsigned long)karg, memory_pages);
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -1479,30 +1442,28 @@ csmisas_set_phy_info(unsigned long arg)
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SET_PHY_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_set_phy_info struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__,  __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__,  __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
-/* TODO - implement IOCTL here */
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_BAD_CNTL_CODE;
 	dcsmisasprintk(ioc, printk(KERN_DEBUG ": not implemented\n"));
 
-// cim_set_phy_info_exit:
 
 	/* Copy the data from kernel memory to user memory
 	 */
@@ -1510,11 +1471,11 @@ csmisas_set_phy_info(unsigned long arg)
 				sizeof(CSMI_SAS_SET_PHY_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_set_phy_info @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 
 }
@@ -1541,24 +1502,24 @@ csmisas_get_scsi_address(unsigned long a
 	    sizeof(CSMI_SAS_GET_SCSI_ADDRESS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_get_scsi_address struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* reverse byte order the sas address */
 	memcpy(&sas_address, karg.bSASAddress, sizeof(u64));
@@ -1586,11 +1547,11 @@ csmisas_get_scsi_address(unsigned long a
 	    sizeof(CSMI_SAS_GET_SCSI_ADDRESS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to write out csmi_sas_get_scsi_address @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -1621,37 +1582,38 @@ csmisas_get_sata_signature(unsigned long
 	u8				phyId;
 	u64				sas_address;
 
-	sasPhyPg0=NULL;
-	sasPhyPg0_data_sz=0;
-	sasDevicePg1=NULL;
-	sasDevicePg1_data_sz=0;
+	sasPhyPg0 = NULL;
+	sasPhyPg0_data_sz = 0;
+	sasDevicePg1 = NULL;
+	sasDevicePg1_data_sz = 0;
 
 	if (copy_from_user(&karg, uarg,
 	     sizeof(CSMI_SAS_SATA_SIGNATURE_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_sata_signature struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		     __FILE__, __FUNCTION__, __LINE__, iocnum);
+		     __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 	phyId = karg.Signature.bPhyIdentifier;
 	if (phyId >= ioc->num_ports) {
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_PHY_DOES_NOT_EXIST;
-		dcsmisasprintk(ioc, printk(KERN_WARNING ": phyId >= ioc->num_ports\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_WARNING ": phyId >= ioc->num_ports\n"));
 		goto cim_sata_signature_exit;
 	}
 
@@ -1683,7 +1645,7 @@ csmisas_get_sata_signature(unsigned long
 		 */
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASPHY0_PAGEVERSION: HEADER\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1692,7 +1654,8 @@ csmisas_get_sata_signature(unsigned long
 		/* Don't check if this failed.  Already in a
 		 * failure case.
 		 */
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1704,8 +1667,9 @@ csmisas_get_sata_signature(unsigned long
 	sasPhyPg0 = (SasPhyPage0_t *) pci_alloc_consistent(ioc->pcidev,
 	    sasPhyPg0_data_sz, &sasPhyPg0_dma);
 
-	if (! sasPhyPg0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+	if (!sasPhyPg0) {
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1720,7 +1684,7 @@ csmisas_get_sata_signature(unsigned long
 		 */
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASPHY0_PAGEVERSION: PAGE\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1728,7 +1692,8 @@ csmisas_get_sata_signature(unsigned long
 	/* Make sure a SATA device is attached. */
 	if ((le32_to_cpu(sasPhyPg0->AttachedDeviceInfo) &
 	    MPI_SAS_DEVICE_INFO_SATA_DEVICE) == 0) {
-		dcsmisasprintk(ioc, printk(KERN_WARNING ": NOT A SATA DEVICE\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_WARNING ": NOT A SATA DEVICE\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_NO_SATA_DEVICE;
 		goto cim_sata_signature_exit;
 	}
@@ -1755,13 +1720,14 @@ csmisas_get_sata_signature(unsigned long
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASDEVICE1_PAGEVERSION: HEADER\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
 
 	if (hdr.ExtPageLength == 0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": hdr.ExtPageLength == 0\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1772,8 +1738,9 @@ csmisas_get_sata_signature(unsigned long
 	sasDevicePg1 = (SasDevicePage1_t *) pci_alloc_consistent
 	    (ioc->pcidev, sasDevicePg1_data_sz, &sasDevicePg1_dma);
 
-	if (! sasDevicePg1) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+	if (!sasDevicePg1) {
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": pci_alloc_consistent: FAILED\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
@@ -1785,29 +1752,31 @@ csmisas_get_sata_signature(unsigned long
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASDEVICE1_PAGEVERSION: PAGE\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sata_signature_exit;
 	}
 
-/* EDM : dump Device Page 1 data*/
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "---- SAS DEVICE PAGE 1 ---------\n"));
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "Handle=0x%x\n",sasDevicePg1->DevHandle));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"---- SAS DEVICE PAGE 1 ---------\n"));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"Handle=0x%x\n", sasDevicePg1->DevHandle));
 	memcpy(&sas_address, &sasDevicePg1->SASAddress, sizeof(u64));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "SAS Address=0x%llX\n",
 	    (unsigned long long)sas_address));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\n"));
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "Target ID=0x%x\n",sasDevicePg1->TargetID));
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "Bus=0x%x\n",sasDevicePg1->Bus));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"Target ID=0x%x\n", sasDevicePg1->TargetID));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"Bus=0x%x\n", sasDevicePg1->Bus));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "Initial Reg Device FIS="));
-	for(jj=0;jj<20;jj++)
+	for (jj = 0; jj < 20; jj++)
 		dcsmisasprintk(ioc, printk("%02x ",
 		((u8 *)&sasDevicePg1->InitialRegDeviceFIS)[jj]));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\n\n"));
-/* EDM : debug data */
 
 	memcpy(karg.Signature.bSignatureFIS,
-		sasDevicePg1->InitialRegDeviceFIS,20);
+		sasDevicePg1->InitialRegDeviceFIS, 20);
 
  cim_sata_signature_exit:
 
@@ -1825,11 +1794,11 @@ csmisas_get_sata_signature(unsigned long
 	    sizeof(CSMI_SAS_SATA_SIGNATURE_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to write out csmi_sas_sata_signature @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -1855,24 +1824,24 @@ csmisas_get_device_address(unsigned long
 	    sizeof(CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 	   "Unable to read in csmi_sas_get_device_address_buffer struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_NO_DEVICE_ADDRESS;
 	memset(karg.bSASAddress, 0, sizeof(u64));
@@ -1896,11 +1865,11 @@ csmisas_get_device_address(unsigned long
 	    sizeof(CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		"Unable to write out csmi_sas_get_device_address_buffer @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -1933,35 +1902,36 @@ csmisas_get_link_errors(unsigned long ar
 	u16				ioc_status;
 	u32				MsgContext;
 
-	sasPhyPage1=NULL;
-	sasPhyPage1_data_sz=0;
+	sasPhyPage1 = NULL;
+	sasPhyPage1_data_sz = 0;
 
 	if (copy_from_user(&karg, uarg,
 	     sizeof(CSMI_SAS_LINK_ERRORS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmisas_get_link_errors struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		     __FILE__, __FUNCTION__, __LINE__, iocnum);
+		     __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 	phyId = karg.Information.bPhyIdentifier;
 	if (phyId >= ioc->num_ports) {
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_PHY_DOES_NOT_EXIST;
-		dcsmisasprintk(ioc, printk(KERN_WARNING ": phyId >= ioc->num_ports\n"));
+		dcsmisasprintk(ioc, printk(KERN_WARNING
+			": phyId >= ioc->num_ports\n"));
 		goto cim_get_link_errors_exit;
 	}
 
@@ -1993,7 +1963,7 @@ csmisas_get_link_errors(unsigned long ar
 		 */
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    ": FAILED: MPI_SASPHY1_PAGEVERSION: HEADER\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_get_link_errors_exit;
 	}
@@ -2002,7 +1972,8 @@ csmisas_get_link_errors(unsigned long ar
 		/* Don't check if this failed.  Already in a
 		 * failure case.
 		 */
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": hdr.ExtPageLength == 0\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_get_link_errors_exit;
 	}
@@ -2014,8 +1985,9 @@ csmisas_get_link_errors(unsigned long ar
 	sasPhyPage1 = (SasPhyPage1_t *) pci_alloc_consistent(ioc->pcidev,
 	    sasPhyPage1_data_sz, &sasPhyPage1_dma);
 
-	if (! sasPhyPage1) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+	if (!sasPhyPage1) {
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": pci_alloc_consistent: FAILED\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_get_link_errors_exit;
 	}
@@ -2028,24 +2000,25 @@ csmisas_get_link_errors(unsigned long ar
 		/* Don't check if this failed.  Already in a
 		 * failure case.
 		 */
-		dcsmisasprintk(ioc, printk(KERN_ERR ": FAILED: MPI_SASPHY1_PAGEVERSION: PAGE\n"));
-		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n",rc));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": FAILED: MPI_SASPHY1_PAGEVERSION: PAGE\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR ": rc=%x\n", rc));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_get_link_errors_exit;
 	}
 
-/* EDM : dump PHY Page 1 data*/
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "---- SAS PHY PAGE 1 ------------\n"));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"---- SAS PHY PAGE 1 ------------\n"));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "Invalid Dword Count=0x%x\n",
 	    sasPhyPage1->InvalidDwordCount));
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "Running Disparity Error Count=0x%x\n",
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"Running Disparity Error Count=0x%x\n",
 	    sasPhyPage1->RunningDisparityErrorCount));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "Loss Dword Synch Count=0x%x\n",
 	    sasPhyPage1->LossDwordSynchCount));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "PHY Reset Problem Count=0x%x\n",
 	    sasPhyPage1->PhyResetProblemCount));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\n\n"));
-/* EDM : debug data */
 
 	karg.Information.uInvalidDwordCount =
 		le32_to_cpu(sasPhyPage1->InvalidDwordCount);
@@ -2057,7 +2030,7 @@ csmisas_get_link_errors(unsigned long ar
 		le32_to_cpu(sasPhyPage1->PhyResetProblemCount);
 
 	if (karg.Information.bResetCounts ==
-	    CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS ) {
+	    CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS) {
 		goto cim_get_link_errors_exit;
 	}
 
@@ -2072,12 +2045,12 @@ csmisas_get_link_errors(unsigned long ar
 		dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_get_link_errors_exit;
-        }
+	}
 
 	mpi_hdr = (MPIHeader_t *) mf;
 	MsgContext = mpi_hdr->MsgContext;
 	sasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;
-	memset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));
+	memset(sasIoUnitCntrReq, 0, sizeof(SasIoUnitControlRequest_t));
 	sasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;
 	sasIoUnitCntrReq->MsgContext = MsgContext;
 	sasIoUnitCntrReq->PhyNum = phyId;
@@ -2097,8 +2070,10 @@ csmisas_get_link_errors(unsigned long ar
 		    & MPI_IOCSTATUS_MASK;
 
 		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
-			dcsmisasprintk(ioc, printk(KERN_DEBUG ": SAS IO Unit Control: "));
-			dcsmisasprintk(ioc, printk("IOCStatus=0x%X IOCLogInfo=0x%X\n",
+			dcsmisasprintk(ioc, printk(KERN_DEBUG
+				": SAS IO Unit Control: "));
+			dcsmisasprintk(ioc, printk(
+				"IOCStatus=0x%X IOCLogInfo=0x%X\n",
 			    sasIoUnitCntrReply->IOCStatus,
 			    sasIoUnitCntrReply->IOCLogInfo));
 		}
@@ -2116,11 +2091,11 @@ csmisas_get_link_errors(unsigned long ar
 	    sizeof(CSMI_SAS_LINK_ERRORS_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to write out csmisas_get_link_errors @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 
 }
@@ -2145,10 +2120,10 @@ csmisas_smp_passthru(unsigned long arg)
 	MPIHeader_t			*mpi_hdr;
 	char				*psge;
 	int				iocnum, flagsLength;
-	void *				request_data;
+	void 				*request_data;
 	dma_addr_t			request_data_dma;
 	u32				request_data_sz;
-	void *				response_data;
+	void 				*response_data;
 	dma_addr_t			response_data_dma;
 	u32				response_data_sz;
 	u16				ioc_status;
@@ -2161,11 +2136,11 @@ csmisas_smp_passthru(unsigned long arg)
 	memory_pages = get_order(malloc_data_sz);
 	karg = (CSMI_SAS_SMP_PASSTHRU_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to malloc CSMI_SAS_SMP_PASSTHRU_BUFFER "
 			"malloc_data_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			malloc_data_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -2173,7 +2148,7 @@ csmisas_smp_passthru(unsigned long arg)
 	if (copy_from_user(karg, uarg, sizeof(CSMI_SAS_SMP_PASSTHRU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_smp_passthru struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -2186,7 +2161,7 @@ csmisas_smp_passthru(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
@@ -2194,19 +2169,19 @@ csmisas_smp_passthru(unsigned long arg)
 	if (ioc->ioc_reset_in_progress) {
 		printk(KERN_ERR "%s@%d::%s - "
 		    "Busy with IOC Reset \n",
-		    __FILE__, __LINE__,__FUNCTION__);
+		    __FILE__, __LINE__, __func__);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EBUSY;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Default to success.*/
 	karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
@@ -2228,13 +2203,13 @@ csmisas_smp_passthru(unsigned long arg)
 		dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_smp_passthru_exit;
-        }
+	}
 
 	mpi_hdr = (MPIHeader_t *) mf;
 	MsgContext = mpi_hdr->MsgContext;
-	smpReq = (pSmpPassthroughRequest_t ) mf;
+	smpReq = (pSmpPassthroughRequest_t) mf;
 
-	memset(smpReq,0,ioc->req_sz);
+	memset(smpReq, 0, ioc->req_sz);
 
 	memcpy(&sas_address, karg->Parameters.bDestinationSASAddress,
 	    sizeof(u64));
@@ -2270,7 +2245,8 @@ csmisas_smp_passthru(unsigned long arg)
 	    ioc->pcidev, request_data_sz, &request_data_dma);
 
 	if (!request_data) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": pci_alloc_consistent: FAILED\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		mpt_free_msg_frame(ioc, mf);
 		goto cim_smp_passthru_exit;
@@ -2286,7 +2262,8 @@ csmisas_smp_passthru(unsigned long arg)
 	    ioc->pcidev, response_data_sz, &response_data_dma);
 
 	if (!response_data) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		dcsmisasprintk(ioc, printk(KERN_ERR
+			": pci_alloc_consistent: FAILED\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		mpt_free_msg_frame(ioc, mf);
 		goto cim_smp_passthru_exit;
@@ -2302,26 +2279,29 @@ csmisas_smp_passthru(unsigned long arg)
 
 	ioc->add_sge(psge, flagsLength, response_data_dma);
 
-	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout) != 0) {
+	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout)
+	    != 0) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_smp_passthru_exit;
 	}
 
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) == 0) {
-		dcsmisasprintk(ioc, printk(KERN_DEBUG ": SMP Passthru: oh no, there is no reply!!"));
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			": SMP Passthru: oh no, there is no reply!!"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_smp_passthru_exit;
 	}
 
 	/* process the completed Reply Message Frame */
-	smpReply = (pSmpPassthroughReply_t )ioc->ioctl_cmds.reply;
+	smpReply = (pSmpPassthroughReply_t)ioc->ioctl_cmds.reply;
 	ioc_status = le16_to_cpu(smpReply->IOCStatus) & MPI_IOCSTATUS_MASK;
 
 	if ((ioc_status != MPI_IOCSTATUS_SUCCESS) &&
 	    (ioc_status != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN)) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		dcsmisasprintk(ioc, printk(KERN_DEBUG ": SMP Passthru: "));
-		dcsmisasprintk(ioc, printk("IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
+		dcsmisasprintk(ioc, printk(
+			"IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
 		    le16_to_cpu(smpReply->IOCStatus),
 		    le32_to_cpu(smpReply->IOCLogInfo),
 		    smpReply->SASStatus));
@@ -2333,7 +2313,8 @@ csmisas_smp_passthru(unsigned long arg)
 
 
 	if (le16_to_cpu(smpReply->ResponseDataLength)) {
-		karg->Parameters.uResponseBytes = le16_to_cpu(smpReply->ResponseDataLength);
+		karg->Parameters.uResponseBytes
+		    = le16_to_cpu(smpReply->ResponseDataLength);
 		memcpy(&karg->Parameters.Response,
 		    response_data, le16_to_cpu(smpReply->ResponseDataLength));
 	}
@@ -2355,13 +2336,13 @@ csmisas_smp_passthru(unsigned long arg)
 	    sizeof(CSMI_SAS_SMP_PASSTHRU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_smp_passthru @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
 	free_pages((unsigned long)karg, memory_pages);
-	dcsmisasprintk(ioc, printk(KERN_DEBUG ": %s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG ": %s exit.\n", __func__));
 	return 0;
 }
 
@@ -2376,18 +2357,18 @@ csmisas_smp_passthru(unsigned long arg)
 static int csmisas_ssp_passthru(unsigned long arg)
 {
 	CSMI_SAS_SSP_PASSTHRU_BUFFER __user *uarg = (void __user *) arg;
-	CSMI_SAS_SSP_PASSTHRU_BUFFER	 karg_hdr, * karg;
+	CSMI_SAS_SSP_PASSTHRU_BUFFER	 karg_hdr, *karg;
 	MPT_ADAPTER			*ioc = NULL;
 	pSCSIIORequest_t		pScsiRequest;
 	pSCSIIOReply_t			pScsiReply;
 	MPT_FRAME_HDR			*mf = NULL;
 	MPIHeader_t 			*mpi_hdr;
-	int				iocnum,ii;
+	int				iocnum, ii;
 	u64				sas_address;
 	u16				req_idx;
 	char				*psge;
 	int				flagsLength;
-	void *				request_data;
+	void 				*request_data;
 	dma_addr_t			request_data_dma;
 	u32				request_data_sz;
 	int				malloc_data_sz;
@@ -2402,10 +2383,11 @@ static int csmisas_ssp_passthru(unsigned
 	u8				skey, asc, ascq;
 	u32				MsgContext;
 
-	if (copy_from_user(&karg_hdr, uarg, sizeof(CSMI_SAS_SSP_PASSTHRU_BUFFER))) {
+	if (copy_from_user(&karg_hdr, uarg,
+		sizeof(CSMI_SAS_SSP_PASSTHRU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_ssp_passthru struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -2422,11 +2404,11 @@ static int csmisas_ssp_passthru(unsigned
 	memory_pages = get_order(malloc_data_sz);
 	karg = (CSMI_SAS_SSP_PASSTHRU_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to malloc SAS_SSP_PASSTHRU_BUFFER "
 			"malloc_data_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			malloc_data_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -2434,10 +2416,10 @@ static int csmisas_ssp_passthru(unsigned
 	memset(karg, 0, sizeof(*karg));
 
 	if (copy_from_user(karg, uarg, request_data_sz +
-	    offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER,bDataBuffer))) {
+	    offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER, bDataBuffer))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_ssp_passthru struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -2445,40 +2427,43 @@ static int csmisas_ssp_passthru(unsigned
 	/*
 	 * some checks of the incoming frame
 	 */
-	if ( offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER,bDataBuffer) +
+	if (offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER, bDataBuffer) +
 	    request_data_sz - sizeof(IOCTL_HEADER) >
-	    karg->IoctlHeader.Length ) {
-		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+	    karg->IoctlHeader.Length) {
+		karg->IoctlHeader.ReturnCode
+		    = CSMI_SAS_STATUS_INVALID_PARAMETER;
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    "%s::%s()"
 		    " @%d - expected datalen incorrect!\n",
-		    __FILE__, __FUNCTION__, __LINE__));
+		    __FILE__, __func__, __LINE__));
 		goto cim_ssp_passthru_exit;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
-		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		karg->IoctlHeader.ReturnCode
+		    = CSMI_SAS_STATUS_INVALID_PARAMETER;
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		goto cim_ssp_passthru_exit;
 	}
 
 	if (ioc->ioc_reset_in_progress) {
 		printk(KERN_ERR "%s@%d::%s - "
 		    "Busy with IOC Reset \n",
-		    __FILE__, __LINE__,__FUNCTION__);
+		    __FILE__, __LINE__, __func__);
 		return -EBUSY;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
-		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		karg->IoctlHeader.ReturnCode
+		    = CSMI_SAS_STATUS_INVALID_PARAMETER;
 		printk(KERN_ERR "%s::%s()@%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		goto cim_ssp_passthru_exit;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Default to success.
 	 */
@@ -2492,7 +2477,7 @@ static int csmisas_ssp_passthru(unsigned
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    "%s::%s()"
 		    " @%d - incorrect bPhyIdentifier and bPortIdentifier!\n",
-		    __FILE__, __FUNCTION__, __LINE__));
+		    __FILE__, __func__, __LINE__));
 		goto cim_ssp_passthru_exit;
 	}
 
@@ -2502,7 +2487,8 @@ static int csmisas_ssp_passthru(unsigned
 
 		/* Is the phy in range? */
 		if (karg->Parameters.bPhyIdentifier >= ioc->num_ports) {
-			dcsmisasprintk(ioc, printk(KERN_WARNING ": phyId >= ioc->num_ports (%d %d)\n",
+			dcsmisasprintk(ioc, printk(KERN_WARNING
+				": phyId >= ioc->num_ports (%d %d)\n",
 			    karg->Parameters.bPhyIdentifier,
 			    ioc->num_ports));
 			karg->IoctlHeader.ReturnCode =
@@ -2511,10 +2497,9 @@ static int csmisas_ssp_passthru(unsigned
 		}
 	}
 
-	if(karg->Parameters.bAdditionalCDBLength) {
-	/* TODO - SCSI IO (32) Request Message support
-	 */
-		dcsmisasprintk(ioc, printk(KERN_DEBUG ": greater than 16-byte cdb "
+	if (karg->Parameters.bAdditionalCDBLength) {
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			": greater than 16-byte cdb "
 		    "is not supported!\n"));
 		    karg->IoctlHeader.ReturnCode =
 			CSMI_SAS_STATUS_INVALID_PARAMETER;
@@ -2538,7 +2523,7 @@ static int csmisas_ssp_passthru(unsigned
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    "%s::%s() @%d - couldn't find associated "
-		    "SASAddress=%llX!\n", __FILE__, __FUNCTION__, __LINE__,
+		    "SASAddress=%llX!\n", __FILE__, __func__, __LINE__,
 		    (unsigned long long)sas_address));
 		goto cim_ssp_passthru_exit;
 	}
@@ -2558,20 +2543,21 @@ static int csmisas_ssp_passthru(unsigned
 		dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_ssp_passthru_exit;
-        }
+	}
 
 	mpi_hdr = (MPIHeader_t *) mf;
 	MsgContext = mpi_hdr->MsgContext;
 	pScsiRequest = (pSCSIIORequest_t) mf;
 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	memset(pScsiRequest,0,sizeof(SCSIIORequest_t));
+	memset(pScsiRequest, 0, sizeof(SCSIIORequest_t));
 
 	/* Fill in SCSI IO (16) request.
 	 */
 
 	pScsiRequest->Function = (is_hidden_raid_component == 1) ?
-	    MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH : MPI_FUNCTION_SCSI_IO_REQUEST;
+	    MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
+	    : MPI_FUNCTION_SCSI_IO_REQUEST;
 	pScsiRequest->TargetID = id;
 	pScsiRequest->Bus = channel;
 	memcpy(pScsiRequest->LUN, &karg->Parameters.bLun, 8);
@@ -2583,10 +2569,11 @@ static int csmisas_ssp_passthru(unsigned
 
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\tchannel = %d id = %d ",
 	    sas_info->fw.channel, sas_info->fw.id));
-	dcsmisasprintk(ioc, if(is_hidden_raid_component)
+	dcsmisasprintk(ioc, if (is_hidden_raid_component)
 	    printk(KERN_DEBUG "num_id = %d ", id));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\n"));
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "\tcdb_len = %d request_len = %d\n",
+	dcsmisasprintk(ioc, printk(KERN_DEBUG
+		"\tcdb_len = %d request_len = %d\n",
 	    pScsiRequest->CDBLength, request_data_sz));
 	dcsmisasprintk(ioc, printk(KERN_DEBUG "\t"));
 	dcsmisasprintk(ioc, for (ii = 0; ii < pScsiRequest->CDBLength; ++ii)
@@ -2603,7 +2590,8 @@ static int csmisas_ssp_passthru(unsigned
 	    (!karg->Parameters.uDataLength)) {
 		/* no data transfer
 		 */
-		pScsiRequest->Control = cpu_to_le32(MPI_SCSIIO_CONTROL_NODATATRANSFER);
+		pScsiRequest->Control
+		    = cpu_to_le32(MPI_SCSIIO_CONTROL_NODATATRANSFER);
 	} else {
 		/* no direction specified
 		 */
@@ -2618,19 +2606,23 @@ static int csmisas_ssp_passthru(unsigned
 
 	/* task attributes
 	 */
-	if((karg->Parameters.uFlags && 0xFF) == 0) {
-		pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_SIMPLEQ);
+	if ((karg->Parameters.uFlags && 0xFF) == 0) {
+		pScsiRequest->Control
+		    |= cpu_to_le32(MPI_SCSIIO_CONTROL_SIMPLEQ);
 	} else if (karg->Parameters.uFlags &
 	    CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE) {
-		pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_HEADOFQ);
+		pScsiRequest->Control
+		    |= cpu_to_le32(MPI_SCSIIO_CONTROL_HEADOFQ);
 	} else if (karg->Parameters.uFlags &
 	    CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED) {
-		pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_ORDEREDQ);
+		pScsiRequest->Control
+		    |= cpu_to_le32(MPI_SCSIIO_CONTROL_ORDEREDQ);
 	} else if (karg->Parameters.uFlags &
 	    CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA) {
 		pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_ACAQ);
 	} else {
-		pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_UNTAGGED);
+		pScsiRequest->Control
+		    |= cpu_to_le32(MPI_SCSIIO_CONTROL_UNTAGGED);
 	}
 
 	/* setup sense
@@ -2647,19 +2639,20 @@ static int csmisas_ssp_passthru(unsigned
 		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
 	} else if (karg->Parameters.uFlags & CSMI_SAS_SSP_READ) {
 		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
-	}else {
-		flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-				MPI_SGE_FLAGS_DIRECTION )
+	} else {
+		flagsLength = (MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+				MPI_SGE_FLAGS_DIRECTION)
 				<< MPI_SGE_FLAGS_SHIFT;
 	}
 	flagsLength |= request_data_sz;
 
-	if ( request_data_sz > 0) {
+	if (request_data_sz > 0) {
 		request_data = pci_alloc_consistent(
 		    ioc->pcidev, request_data_sz, &request_data_dma);
 
 		if (request_data == NULL) {
-			dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED "
+			dcsmisasprintk(ioc, printk(KERN_ERR
+				": pci_alloc_consistent: FAILED "
 			    "request_data_sz=%d\n", request_data_sz));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			mpt_free_msg_frame(ioc, mf);
@@ -2668,17 +2661,19 @@ static int csmisas_ssp_passthru(unsigned
 
 		ioc->add_sge(psge, flagsLength, request_data_dma);
 		if (karg->Parameters.uFlags & CSMI_SAS_SSP_WRITE)
-			memcpy(request_data, karg->bDataBuffer, request_data_sz);
+			memcpy(request_data, karg->bDataBuffer,
+			    request_data_sz);
 	} else {
 		ioc->add_sge(psge, flagsLength, (dma_addr_t) -1);
 	}
 
-	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout) != 0) {
+	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout)
+	    != 0) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_ssp_passthru_exit;
 	}
 
-	memset(&karg->Status,0,sizeof(CSMI_SAS_SSP_PASSTHRU_STATUS));
+	memset(&karg->Status, 0, sizeof(CSMI_SAS_SSP_PASSTHRU_STATUS));
 	karg->Status.bConnectionStatus = CSMI_SAS_OPEN_ACCEPT;
 	karg->Status.bDataPresent = CSMI_SAS_SSP_NO_DATA_PRESENT;
 	karg->Status.bStatus = GOOD;
@@ -2689,11 +2684,13 @@ static int csmisas_ssp_passthru(unsigned
 	/* process the completed Reply Message Frame */
 	if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {
 
-		pScsiReply = (pSCSIIOReply_t ) ioc->ioctl_cmds.reply;
+		pScsiReply = (pSCSIIOReply_t) ioc->ioctl_cmds.reply;
 		karg->Status.bStatus = pScsiReply->SCSIStatus;
-		karg->Status.uDataBytes = min(le32_to_cpu(pScsiReply->TransferCount),
+		karg->Status.uDataBytes
+		    = min(le32_to_cpu(pScsiReply->TransferCount),
 		    request_data_sz);
-		ioc_status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+		ioc_status
+		    = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;
 
 		if (pScsiReply->SCSIState ==
 		    MPI_SCSI_STATE_AUTOSENSE_VALID) {
@@ -2701,26 +2698,28 @@ static int csmisas_ssp_passthru(unsigned
 			    CSMI_SAS_SSP_SENSE_DATA_PRESENT;
 			karg->Status.bResponseLength[0] =
 				(u8)le32_to_cpu(pScsiReply->SenseCount) & 0xFF;
-			memcpy(karg->Status.bResponse,
-			    ioc->ioctl_cmds.sense, le32_to_cpu(pScsiReply->SenseCount));
+			memcpy(karg->Status.bResponse, ioc->ioctl_cmds.sense,
+			    le32_to_cpu(pScsiReply->SenseCount));
 
 			skey = ioc->ioctl_cmds.sense[2] & 0x0F;
 			asc = ioc->ioctl_cmds.sense[12];
 			ascq = ioc->ioctl_cmds.sense[13];
 
-			dcsmisasprintk(ioc, printk(KERN_DEBUG "\t [sense_key,asc,ascq]: "
-			    "[0x%02x,0x%02x,0x%02x]\n",
-			    skey, asc, ascq));
+			dcsmisasprintk(ioc, printk(KERN_DEBUG
+				"\t [sense_key,asc,ascq]: "
+				"[0x%02x,0x%02x,0x%02x]\n",
+				skey, asc, ascq));
 
-		} else if(pScsiReply->SCSIState ==
+		} else if (pScsiReply->SCSIState ==
 		    MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
 			karg->Status.bDataPresent =
 			    CSMI_SAS_SSP_RESPONSE_DATA_PRESENT;
 			karg->Status.bResponseLength[0] =
 				sizeof(pScsiReply->ResponseInfo);
-			for (ii=0;ii<sizeof(pScsiReply->ResponseInfo);ii++) {
+			for (ii = 0; ii < sizeof(pScsiReply->ResponseInfo);
+			    ii++) {
 				karg->Status.bResponse[ii] =
-				((u8*)&pScsiReply->ResponseInfo)[
+				((u8 *)&pScsiReply->ResponseInfo)[
 				    (sizeof(pScsiReply->ResponseInfo)-1)-ii];
 			}
 		} else if ((ioc_status != MPI_IOCSTATUS_SUCCESS) &&
@@ -2728,7 +2727,8 @@ static int csmisas_ssp_passthru(unsigned
 		    (ioc_status != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN)) {
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			dcsmisasprintk(ioc, printk(KERN_DEBUG ": SCSI IO : "));
-			dcsmisasprintk(ioc, printk("IOCStatus=0x%X IOCLogInfo=0x%X\n",
+			dcsmisasprintk(ioc,
+			    printk("IOCStatus=0x%X IOCLogInfo=0x%X\n",
 			    pScsiReply->IOCStatus,
 			    pScsiReply->IOCLogInfo));
 		}
@@ -2740,8 +2740,8 @@ static int csmisas_ssp_passthru(unsigned
 		    request_data, karg->Status.uDataBytes)) {
 			printk(KERN_ERR "%s@%d::%s - "
 			    "Unable to write data to user %p\n",
-			    __FILE__, __LINE__,__FUNCTION__,
-			    (void*)karg->bDataBuffer);
+			    __FILE__, __LINE__, __func__,
+			    (void *)karg->bDataBuffer);
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		}
 	}
@@ -2759,12 +2759,12 @@ static int csmisas_ssp_passthru(unsigned
 	    offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER, bDataBuffer))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_ssp_passthru @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)karg, memory_pages);
 	return 0;
 }
@@ -2793,7 +2793,7 @@ csmisas_stp_passthru(unsigned long arg)
 	u16				req_idx;
 	char				*psge;
 	int				flagsLength;
-	void *				request_data;
+	void 				*request_data;
 	dma_addr_t			request_data_dma;
 	u32				request_data_sz;
 	int				malloc_data_sz;
@@ -2806,14 +2806,15 @@ csmisas_stp_passthru(unsigned long arg)
 	u16				ioc_status;
 	u32				MsgContext;
 
-	if (copy_from_user(&karg_hdr, uarg, sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER))) {
+	if (copy_from_user(&karg_hdr, uarg,
+		sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	request_data=NULL;
+	request_data = NULL;
 	request_data_sz = karg_hdr.Parameters.uDataLength;
 	volume_id = 0;
 	volume_bus = 0;
@@ -2825,11 +2826,11 @@ csmisas_stp_passthru(unsigned long arg)
 	memory_pages = get_order(malloc_data_sz);
 	karg = (CSMI_SAS_STP_PASSTHRU_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to malloc CSMI_SAS_STP_PASSTHRU_BUFFER "
 			"malloc_data_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			malloc_data_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -2839,7 +2840,7 @@ csmisas_stp_passthru(unsigned long arg)
 	if (copy_from_user(karg, uarg, malloc_data_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_ssp_passthru struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -2847,7 +2848,7 @@ csmisas_stp_passthru(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
@@ -2855,19 +2856,19 @@ csmisas_stp_passthru(unsigned long arg)
 	if (ioc->ioc_reset_in_progress) {
 		printk(KERN_ERR "%s@%d::%s - "
 		    "Busy with IOC Reset \n",
-		    __FILE__, __LINE__,__FUNCTION__);
+		    __FILE__, __LINE__, __func__);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EBUSY;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Default to success.
 	 */
@@ -2879,8 +2880,9 @@ csmisas_stp_passthru(unsigned long arg)
 		(karg->Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT)) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_SELECT_PHY_OR_PORT;
 		dcsmisasprintk(ioc, printk(KERN_ERR
-		    "%s::%s() @%d - incorrect bPhyIdentifier and bPortIdentifier!\n",
-		    __FILE__,__FUNCTION__, __LINE__));
+		    "%s::%s() @%d -incorrect bPhyIdentifier"
+		    " and bPortIdentifier!\n",
+		    __FILE__, __func__, __LINE__));
 		goto cim_stp_passthru_exit;
 	}
 
@@ -2897,15 +2899,15 @@ csmisas_stp_passthru(unsigned long arg)
 	}
 
 	data_sz = sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER) -
-	    sizeof(IOCTL_HEADER) - sizeof(u8*) +
+	    sizeof(IOCTL_HEADER) - sizeof(u8 *) +
 	    request_data_sz;
 
-	if ( data_sz > karg->IoctlHeader.Length ) {
+	if (data_sz > karg->IoctlHeader.Length) {
 		karg->IoctlHeader.ReturnCode =
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    "%s::%s() @%d - expected datalen incorrect!\n",
-		    __FILE__, __FUNCTION__,__LINE__));
+		    __FILE__, __func__, __LINE__));
 		goto cim_stp_passthru_exit;
 	}
 
@@ -2927,7 +2929,7 @@ csmisas_stp_passthru(unsigned long arg)
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		dcsmisasprintk(ioc, printk(KERN_ERR
 		    "%s::%s() @%d - couldn't find associated "
-		    "SASAddress=%llX!\n", __FILE__, __FUNCTION__, __LINE__,
+		    "SASAddress=%llX!\n", __FILE__, __func__, __LINE__,
 		    (unsigned long long)sas_address));
 		goto cim_stp_passthru_exit;
 	}
@@ -2937,8 +2939,8 @@ csmisas_stp_passthru(unsigned long arg)
 
 	/* check that this is an STP or SATA target device
 	 */
-	if ( !(sas_info->device_info & MPI_SAS_DEVICE_INFO_STP_TARGET ) &&
-	     !(sas_info->device_info & MPI_SAS_DEVICE_INFO_SATA_DEVICE )) {
+	if (!(sas_info->device_info & MPI_SAS_DEVICE_INFO_STP_TARGET) &&
+	     !(sas_info->device_info & MPI_SAS_DEVICE_INFO_SATA_DEVICE)) {
 		karg->IoctlHeader.ReturnCode =
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		goto cim_stp_passthru_exit;
@@ -2950,14 +2952,14 @@ csmisas_stp_passthru(unsigned long arg)
 		dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_stp_passthru_exit;
-        }
+	}
 
 	mpi_hdr = (MPIHeader_t *) mf;
 	MsgContext = mpi_hdr->MsgContext;
 	pSataRequest = (pSataPassthroughRequest_t) mf;
 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	memset(pSataRequest,0,sizeof(pSataPassthroughRequest_t));
+	memset(pSataRequest, 0, sizeof(pSataPassthroughRequest_t));
 
 	pSataRequest->TargetID = id;
 	pSataRequest->Bus = channel;
@@ -2967,16 +2969,16 @@ csmisas_stp_passthru(unsigned long arg)
 	pSataRequest->MsgContext = MsgContext;
 	pSataRequest->DataLength = cpu_to_le32(request_data_sz);
 	pSataRequest->MsgFlags = 0;
-	memcpy( pSataRequest->CommandFIS,karg->Parameters.bCommandFIS, 20);
+	memcpy(pSataRequest->CommandFIS, karg->Parameters.bCommandFIS, 20);
 
 	psge = (char *)&pSataRequest->SGL;
 	if (karg->Parameters.uFlags & CSMI_SAS_STP_WRITE) {
 		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
 	} else if (karg->Parameters.uFlags & CSMI_SAS_STP_READ) {
 		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
-	}else {
-		flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-				MPI_SGE_FLAGS_DIRECTION )
+	} else {
+		flagsLength = (MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+				MPI_SGE_FLAGS_DIRECTION)
 				<< MPI_SGE_FLAGS_SHIFT;
 	}
 
@@ -2986,7 +2988,8 @@ csmisas_stp_passthru(unsigned long arg)
 		    ioc->pcidev, request_data_sz, &request_data_dma);
 
 		if (request_data == NULL) {
-			dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+			dcsmisasprintk(ioc, printk(KERN_ERR
+				": pci_alloc_consistent: FAILED\n"));
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			mpt_free_msg_frame(ioc, mf);
 			goto cim_stp_passthru_exit;
@@ -2994,33 +2997,37 @@ csmisas_stp_passthru(unsigned long arg)
 
 		ioc->add_sge(psge, flagsLength, request_data_dma);
 		if (karg->Parameters.uFlags & CSMI_SAS_SSP_WRITE)
-			memcpy(request_data, karg->bDataBuffer, request_data_sz);
+			memcpy(request_data, karg->bDataBuffer,
+			    request_data_sz);
 	} else {
 		ioc->add_sge(psge, flagsLength, (dma_addr_t) -1);
 	}
 
-	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout) != 0) {
+	if (csmisas_send_command_wait(ioc, mf, karg->IoctlHeader.Timeout)
+	    != 0) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_stp_passthru_exit;
 	}
 
-	memset(&karg->Status,0,sizeof(CSMI_SAS_STP_PASSTHRU_STATUS));
+	memset(&karg->Status, 0, sizeof(CSMI_SAS_STP_PASSTHRU_STATUS));
 
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) == 0) {
-		dcsmisasprintk(ioc, printk(KERN_DEBUG  ": STP Passthru: oh no, there is no reply!!"));
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			": STP Passthru: oh no, there is no reply!!"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_stp_passthru_exit;
 	}
 
 	/* process the completed Reply Message Frame */
-	pSataReply = (pSataPassthroughReply_t ) ioc->ioctl_cmds.reply;
+	pSataReply = (pSataPassthroughReply_t) ioc->ioctl_cmds.reply;
 	ioc_status = le16_to_cpu(pSataReply->IOCStatus) & MPI_IOCSTATUS_MASK;
 
 	if (ioc_status != MPI_IOCSTATUS_SUCCESS &&
 	    ioc_status != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN) {
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		dcsmisasprintk(ioc, printk(KERN_DEBUG ": STP Passthru: "));
-		dcsmisasprintk(ioc, printk("IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
+		dcsmisasprintk(ioc,
+		    printk("IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
 		    le16_to_cpu(pSataReply->IOCStatus),
 		    le32_to_cpu(pSataReply->IOCLogInfo),
 		    pSataReply->SASStatus));
@@ -3029,26 +3036,27 @@ csmisas_stp_passthru(unsigned long arg)
 	karg->Status.bConnectionStatus =
 	    map_sas_status_to_csmi(pSataReply->SASStatus);
 
-	memcpy(karg->Status.bStatusFIS,pSataReply->StatusFIS, 20);
+	memcpy(karg->Status.bStatusFIS, pSataReply->StatusFIS, 20);
 
 	/*
 	 * for now, just zero out uSCR array,
 	 * then copy the one dword returned
 	 * in the reply frame into uSCR[0]
 	 */
-	memset( karg->Status.uSCR, 0, 64);
+	memset(karg->Status.uSCR, 0, 64);
 	karg->Status.uSCR[0] = le32_to_cpu(pSataReply->StatusControlRegisters);
 
-	if((le32_to_cpu(pSataReply->TransferCount)) && (request_data) &&
+	if ((le32_to_cpu(pSataReply->TransferCount)) && (request_data) &&
 	    (karg->Parameters.uFlags & CSMI_SAS_STP_READ)) {
 		karg->Status.uDataBytes =
-		    min(le32_to_cpu(pSataReply->TransferCount),request_data_sz);
+		    min(le32_to_cpu(pSataReply->TransferCount),
+			request_data_sz);
 		if (copy_to_user((void __user *)uarg->bDataBuffer,
 		    request_data, karg->Status.uDataBytes)) {
 			printk(KERN_ERR "%s::%s() @%d - "
 			    "Unable to write data to user %p\n",
-			    __FILE__, __FUNCTION__, __LINE__,
-			    (void*)karg->bDataBuffer);
+			    __FILE__, __func__, __LINE__,
+			    (void *)karg->bDataBuffer);
 			karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		}
 	}
@@ -3065,13 +3073,13 @@ csmisas_stp_passthru(unsigned long arg)
 	    offsetof(CSMI_SAS_STP_PASSTHRU_BUFFER, bDataBuffer))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_ssp_passthru @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
 	free_pages((unsigned long)karg, memory_pages);
-	dcsmisasprintk(ioc, printk(KERN_DEBUG ": %s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG ": %s exit.\n", __func__));
 	return 0;
 }
 
@@ -3090,30 +3098,30 @@ csmisas_firmware_download(unsigned long 
 	CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER	 karg;
 	MPT_ADAPTER			*ioc = NULL;
 	int				iocnum;
-	pMpiFwHeader_t			pFwHeader=NULL;
+	pMpiFwHeader_t			pFwHeader = NULL;
 
 	if (copy_from_user(&karg, uarg,
 		sizeof(CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
-		    "Unable to read in csmi_sas_firmware_download struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    "Unable to read in csmi_sas_firmware_download struct@ %p\n",
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	/* Default to success.*/
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
@@ -3130,7 +3138,7 @@ csmisas_firmware_download(unsigned long 
 		goto cim_firmware_download_exit;
 	}
 
-	if ( karg.Information.uDownloadFlags &
+	if (karg.Information.uDownloadFlags &
 	    (CSMI_SAS_FWD_SOFT_RESET | CSMI_SAS_FWD_VALIDATE)) {
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
@@ -3142,7 +3150,7 @@ csmisas_firmware_download(unsigned long 
 	 * fw image attached to end of incoming packet.
 	 */
 	pFwHeader = kmalloc(karg.Information.uBufferLength, GFP_KERNEL);
-	if (!pFwHeader){
+	if (!pFwHeader) {
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
 		karg.Information.usSeverity = CSMI_SAS_FWD_ERROR;
@@ -3154,21 +3162,21 @@ csmisas_firmware_download(unsigned long 
 		karg.Information.uBufferLength)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in pFwHeader @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	if ( !((pFwHeader->Signature0 == MPI_FW_HEADER_SIGNATURE_0) &&
+	if (!((pFwHeader->Signature0 == MPI_FW_HEADER_SIGNATURE_0) &&
 	    (pFwHeader->Signature1 == MPI_FW_HEADER_SIGNATURE_1) &&
 	    (pFwHeader->Signature2 == MPI_FW_HEADER_SIGNATURE_2))) {
-		// the signature check failed
+		/* the signature check failed */
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
 		karg.Information.usSeverity = CSMI_SAS_FWD_ERROR;
 		goto cim_firmware_download_exit;
 	}
 
-	if ( mptctl_do_fw_download(karg.IoctlHeader.IOControllerNumber,
+	if (mptctl_do_fw_download(karg.IoctlHeader.IOControllerNumber,
 	    uarg->bDataBuffer, karg.Information.uBufferLength)
 	    != 0) {
 		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
@@ -3177,7 +3185,7 @@ csmisas_firmware_download(unsigned long 
 		goto cim_firmware_download_exit;
 	}
 
-	if((karg.Information.uDownloadFlags & CSMI_SAS_FWD_SOFT_RESET) ||
+	if ((karg.Information.uDownloadFlags & CSMI_SAS_FWD_SOFT_RESET) ||
 	    (karg.Information.uDownloadFlags & CSMI_SAS_FWD_HARD_RESET)) {
 		if (mpt_HardResetHandler(ioc, CAN_SLEEP) != 0) {
 			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
@@ -3188,7 +3196,7 @@ csmisas_firmware_download(unsigned long 
 
  cim_firmware_download_exit:
 
-	if(pFwHeader)
+	if (pFwHeader)
 		kfree(pFwHeader);
 
 	/* Copy the data from kernel memory to user memory
@@ -3197,11 +3205,11 @@ csmisas_firmware_download(unsigned long 
 				sizeof(CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_firmware_download @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -3227,24 +3235,24 @@ csmisas_get_raid_info(unsigned long arg)
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_RAID_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_get_raid_info struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 	if (!ioc->raid_data.pIocPg2)
@@ -3252,8 +3260,8 @@ csmisas_get_raid_info(unsigned long arg)
 	karg.Information.uNumRaidSets =
 	    ioc->raid_data.pIocPg2->NumActiveVolumes;
 	karg.Information.uMaxRaidSets = ioc->raid_data.pIocPg2->MaxVolumes;
-	if( ioc->raid_data.pIocPg6 ) {
-		// get absolute maximum for all RAID sets
+	if (ioc->raid_data.pIocPg6) {
+		/* get absolute maximum for all RAID sets */
 		maxDrivesPerSet = ioc->raid_data.pIocPg6->MaxDrivesIS;
 		maxDrivesPerSet = max(ioc->raid_data.pIocPg6->MaxDrivesIM,
 		    maxDrivesPerSet);
@@ -3263,17 +3271,19 @@ csmisas_get_raid_info(unsigned long arg)
 	}
 	else
 		karg.Information.uMaxDrivesPerSet = 8;
-	// For bMaxRaidSets, count bits set in bits 0-6 of CapabilitiesFlags
+	/* For bMaxRaidSets, count bits set in bits 0-6 of CapabilitiesFlags */
 	raidFlags = ioc->raid_data.pIocPg2->CapabilitiesFlags & 0x0000007F;
-	for( maxRaidTypes=0; raidFlags; maxRaidTypes++ )
+	for (maxRaidTypes = 0; raidFlags; maxRaidTypes++)
 		raidFlags &= raidFlags - 1;
 	karg.Information.bMaxRaidTypes = maxRaidTypes;
-	// ulMinRaidSetBlocks hard coded to 1MB until available from config page
+	/* ulMinRaidSetBlocks hard coded to 1MB until available
+	 * from config page
+	 */
 	karg.Information.ulMinRaidSetBlocks.uLowPart = 2048;
 	karg.Information.ulMinRaidSetBlocks.uHighPart = 0;
 	karg.Information.ulMaxRaidSetBlocks.uLowPart = 0xffffffff;
-	if( ioc->raid_data.pIocPg2->CapabilitiesFlags &
-	    MPI_IOCPAGE2_CAP_FLAGS_RAID_64_BIT_ADDRESSING )
+	if (ioc->raid_data.pIocPg2->CapabilitiesFlags &
+	    MPI_IOCPAGE2_CAP_FLAGS_RAID_64_BIT_ADDRESSING)
 		karg.Information.ulMaxRaidSetBlocks.uHighPart = 0xffffffff;
 	else
 		karg.Information.ulMaxRaidSetBlocks.uHighPart = 0;
@@ -3293,11 +3303,11 @@ csmisas_get_raid_info_out:
 				sizeof(CSMI_SAS_RAID_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_get_raid_info @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -3315,7 +3325,8 @@ csmisas_get_raid_info_out:
  *	Remark: Wait to return until reply processed by the ISR.
  **/
 static int
-csmisas_do_raid(MPT_ADAPTER *ioc, u8 action, u8 PhysDiskNum, u8 VolumeBus, u8 VolumeId, pMpiRaidActionReply_t reply)
+csmisas_do_raid(MPT_ADAPTER *ioc, u8 action, u8 PhysDiskNum, u8 VolumeBus,
+    u8 VolumeId, pMpiRaidActionReply_t reply)
 {
 	MpiRaidActionRequest_t	*pReq;
 	MpiRaidActionReply_t	*pReply;
@@ -3338,7 +3349,6 @@ csmisas_do_raid(MPT_ADAPTER *ioc, u8 act
 	pReq->MsgFlags = 0;
 	pReq->Reserved2 = 0;
 	pReq->ActionDataWord = 0; /* Reserved for this action */
-	//pReq->ActionDataSGE = 0;
 
 	ioc->add_sge((char *)&pReq->ActionDataSGE,
 		MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
@@ -3347,7 +3357,7 @@ csmisas_do_raid(MPT_ADAPTER *ioc, u8 act
 		return -ENODATA;
 
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) &&
-	    (reply != NULL)){
+	    (reply != NULL)) {
 		pReply = (MpiRaidActionReply_t *)&(ioc->ioctl_cmds.reply);
 		memcpy(reply, pReply,
 			min(ioc->reply_sz,
@@ -3371,7 +3381,7 @@ csmisas_do_raid(MPT_ADAPTER *ioc, u8 act
  **/
 static int
 csmisas_raid_inq(MPT_ADAPTER *ioc, u8 opcode, u8 bus, u8 id, u8 inq_vpd_page,
-    u8 * inq_vpd, u32 inq_vpd_sz)
+    u8 *inq_vpd, u32 inq_vpd_sz)
 {
 	MPT_FRAME_HDR		*mf = NULL;
 	MPIHeader_t 		*mpi_hdr;
@@ -3379,7 +3389,7 @@ csmisas_raid_inq(MPT_ADAPTER *ioc, u8 op
 	u16			req_idx;
 	char			*psge;
 	u8 			inq_vpd_cdb[6];
-	u8 			*request_data=NULL;
+	u8 			*request_data = NULL;
 	dma_addr_t		request_data_dma;
 	u32			request_data_sz;
 	int			rc = 0;
@@ -3409,14 +3419,14 @@ csmisas_raid_inq(MPT_ADAPTER *ioc, u8 op
 	pScsiRequest = (pSCSIIORequest_t) mf;
 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	memset(pScsiRequest,0,sizeof(SCSIIORequest_t));
+	memset(pScsiRequest, 0, sizeof(SCSIIORequest_t));
 	pScsiRequest->Function = opcode;
 	pScsiRequest->TargetID = id;
 	pScsiRequest->Bus = bus;
 	pScsiRequest->CDBLength = 6;
 	pScsiRequest->DataLength = cpu_to_le32(request_data_sz);
 	pScsiRequest->MsgContext = MsgContext;
-	memcpy(pScsiRequest->CDB,inq_vpd_cdb,pScsiRequest->CDBLength);
+	memcpy(pScsiRequest->CDB, inq_vpd_cdb, pScsiRequest->CDBLength);
 	pScsiRequest->Control = cpu_to_le32(MPI_SCSIIO_CONTROL_READ);
 	pScsiRequest->Control |= cpu_to_le32(MPI_SCSIIO_CONTROL_SIMPLEQ);
 	pScsiRequest->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
@@ -3434,17 +3444,18 @@ csmisas_raid_inq(MPT_ADAPTER *ioc, u8 op
 
 	if (request_data == NULL) {
 		mpt_free_msg_frame(ioc, mf);
-		rc=-1;
+		rc = -1;
 		goto csmisas_raid_inq_exit;
 	}
 
-	memset(request_data,0,request_data_sz);
+	memset(request_data, 0, request_data_sz);
 	psge = (char *)&pScsiRequest->SGL;
 	ioc->add_sge(psge, (MPT_SGE_FLAGS_SSIMPLE_READ | 0xFC) ,
 	    request_data_dma);
 
-	if (csmisas_send_command_wait(ioc, mf, MPT_IOCTL_DEFAULT_TIMEOUT) != 0) {
-		rc=-1;
+	if (csmisas_send_command_wait(ioc, mf, MPT_IOCTL_DEFAULT_TIMEOUT)
+	    != 0) {
+		rc = -1;
 		goto csmisas_raid_inq_exit;
 	}
 
@@ -3472,7 +3483,7 @@ static int
 csmisas_get_raid_config(unsigned long arg)
 {
 	CSMI_SAS_RAID_CONFIG_BUFFER __user *uarg = (void __user *) arg;
-	CSMI_SAS_RAID_CONFIG_BUFFER	 karg,*pKarg=NULL;
+	CSMI_SAS_RAID_CONFIG_BUFFER	 karg, *pKarg = NULL;
 	CONFIGPARMS		 	cfg;
 	ConfigPageHeader_t	 	header;
 	MPT_ADAPTER			*ioc = NULL;
@@ -3498,7 +3509,7 @@ csmisas_get_raid_config(unsigned long ar
 	if (copy_from_user(&karg, uarg, sizeof(IOCTL_HEADER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmisas_get_raid_config struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -3506,11 +3517,11 @@ csmisas_get_raid_config(unsigned long ar
 	memory_pages = get_order(csmi_sas_raid_config_buffer_sz);
 	pKarg = (CSMI_SAS_RAID_CONFIG_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!pKarg){
+	if (!pKarg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to malloc RAID_CONFIG_BUFFER "
 			"csmi_sas_raid_config_buffer_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			csmi_sas_raid_config_buffer_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -3519,7 +3530,7 @@ csmisas_get_raid_config(unsigned long ar
 	if (copy_from_user(pKarg, uarg, csmi_sas_raid_config_buffer_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmisas_get_raid_config struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
@@ -3527,22 +3538,22 @@ csmisas_get_raid_config(unsigned long ar
 	if (((iocnum = mpt_verify_adapter(pKarg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	if (pKarg->Configuration.uChangeCount != 0 &&
-		pKarg->Configuration.uChangeCount != ioc->csmi_change_count ) {
+		pKarg->Configuration.uChangeCount != ioc->csmi_change_count) {
 		pKarg->IoctlHeader.ReturnCode =
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		pKarg->Configuration.uFailureCode =
@@ -3615,7 +3626,7 @@ csmisas_get_raid_config(unsigned long ar
 	pKarg->Configuration.uStripeSize =
 		le32_to_cpu(pVolume0->StripeSize)/2;
 
-	switch(pVolume0->VolumeType) {
+	switch (pVolume0->VolumeType) {
 	case MPI_RAID_VOL_TYPE_IS:
 		pKarg->Configuration.bRaidType = CSMI_SAS_RAID_TYPE_0;
 		break;
@@ -3636,7 +3647,8 @@ csmisas_get_raid_config(unsigned long ar
 		break;
 	case MPI_RAIDVOL0_STATUS_STATE_DEGRADED:
 		/* Volume is degraded, check if Resyncing or Inactive */
-		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_DEGRADED;
+		pKarg->Configuration.bStatus
+		    = CSMI_SAS_RAID_SET_STATUS_DEGRADED;
 		break;
 	case MPI_RAIDVOL0_STATUS_STATE_FAILED:
 		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_FAILED;
@@ -3649,25 +3661,26 @@ csmisas_get_raid_config(unsigned long ar
 		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_OFFLINE;
 	else if (pVolume0->VolumeStatus.Flags &
 	    MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS)
-		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_REBUILDING;
+		pKarg->Configuration.bStatus
+		    = CSMI_SAS_RAID_SET_STATUS_REBUILDING;
 
 	pKarg->Configuration.bInformation = 0;  /* default */
-	if(pVolume0->VolumeStatus.Flags &
-	    MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS ) {
+	if (pVolume0->VolumeStatus.Flags &
+	    MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) {
 
-		uint64_t 	* ptrUint64;
+		uint64_t 	*ptrUint64;
 		uint64_t	totalBlocks64, blocksRemaining64;
 		uint32_t	totalBlocks32, blocksRemaining32;
 
 		/* get percentage complete */
-		pRaidActionReply = kmalloc( sizeof(MPI_RAID_VOL_INDICATOR) +
-		    offsetof(MSG_RAID_ACTION_REPLY,ActionData),
+		pRaidActionReply = kmalloc(sizeof(MPI_RAID_VOL_INDICATOR) +
+		    offsetof(MSG_RAID_ACTION_REPLY, ActionData),
 		    GFP_KERNEL);
 
-		if (!pRaidActionReply){
+		if (!pRaidActionReply) {
 			printk(KERN_ERR "%s@%d::%s() - "
 			    "Unable to malloc @ %p\n",
-			    __FILE__, __LINE__, __FUNCTION__,pKarg);
+			    __FILE__, __LINE__, __func__, pKarg);
 			goto cim_get_raid_config_exit;
 		}
 		memset(pRaidActionReply, 0, sizeof(*pRaidActionReply));
@@ -3680,14 +3693,14 @@ csmisas_get_raid_config(unsigned long ar
 		totalBlocks64     = *ptrUint64;
 		ptrUint64++;
 		blocksRemaining64 = *ptrUint64;
-		while(totalBlocks64 > 0xFFFFFFFFUL){
+		while (totalBlocks64 > 0xFFFFFFFFUL) {
 			totalBlocks64 = totalBlocks64 >> 1;
 			blocksRemaining64 = blocksRemaining64 >> 1;
 		}
 		totalBlocks32 = (uint32_t)totalBlocks64;
 		blocksRemaining32 = (uint32_t)blocksRemaining64;
 
-		if(totalBlocks32)
+		if (totalBlocks32)
 			pKarg->Configuration.bInformation =
 			    (totalBlocks32 - blocksRemaining32) /
 			    (totalBlocks32 / 100);
@@ -3713,15 +3726,14 @@ csmisas_get_raid_config(unsigned long ar
 		pKarg->Configuration.Data->ulRaidSetBlocks.uHighPart =
 		    le32_to_cpu(pVolume0->MaxLBAHigh);
 		if (pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IS ||
-		    pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IME ) {
+		    pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IME) {
 			pKarg->Configuration.Data->uStripeSizeInBlocks =
 			    le32_to_cpu(pVolume0->StripeSize);
 		} else {
 			pKarg->Configuration.Data->uStripeSizeInBlocks = 0;
 		}
 		pKarg->Configuration.Data->uSectorsPerTrack = 128;
-		for (i=0; i<16; i++) {
-			// unsupported
+		for (i = 0; i < 16; i++) {
 			pKarg->Configuration.Data->bApplicationScratchPad[i] =
 			    0xFF;
 		}
@@ -3732,15 +3744,15 @@ csmisas_get_raid_config(unsigned long ar
 		    (pKarg->Configuration.Data->uNumberOfHeads *
 		     pKarg->Configuration.Data->uSectorsPerTrack));
 		pKarg->Configuration.Data->uNumberOfTracks = tmpTotalMaxLBA;
-	} else if ( pKarg->Configuration.bDataType ==
-	    CSMI_SAS_RAID_DATA_DEVICE_ID ) {
+	} else if (pKarg->Configuration.bDataType ==
+	    CSMI_SAS_RAID_DATA_DEVICE_ID) {
 		/* Send inquiry to get VPD Page 0x83 */
 		u32 vpd_page_sz;
 		vpd_page_sz = csmi_sas_raid_config_buffer_sz -
-		    offsetof(CSMI_SAS_RAID_CONFIG,DeviceId);
+		    offsetof(CSMI_SAS_RAID_CONFIG, DeviceId);
 		if (csmisas_raid_inq(ioc, MPI_FUNCTION_SCSI_IO_REQUEST,
 			VolumeBus, volumeID, 0x83,
-			(u8*)&pKarg->Configuration.DeviceId->bDeviceIdentificationVPDPage,
+			(u8 *)&pKarg->Configuration.DeviceId->bDeviceIdentificationVPDPage,
 			vpd_page_sz) != 0) {
 			pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto cim_get_raid_config_exit;
@@ -3773,7 +3785,7 @@ csmisas_get_raid_config(unsigned long ar
 			pIocPage5 = pci_alloc_consistent(ioc->pcidev,
 			    ioc_page5_sz,
 			    &ioc_page5_dma);
-			memset(pIocPage5,0,ioc_page5_sz);
+			memset(pIocPage5, 0, ioc_page5_sz);
 			if (ioc_page5_dma) {
 				cfg.physAddr = ioc_page5_dma;
 				cfg.action =
@@ -3816,52 +3828,55 @@ csmisas_get_raid_config(unsigned long ar
 	cfg.physAddr = physdisk0_dma;
 
 	physDiskNumMax = (csmi_sas_raid_config_buffer_sz -
-	    offsetof(CSMI_SAS_RAID_CONFIG,Drives))
+	    offsetof(CSMI_SAS_RAID_CONFIG, Drives))
 	    / sizeof(CSMI_SAS_RAID_DRIVES);
 
 	tmpTotalMaxLBA = totalMaxLBA;
 	if (pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IS) {
 		do_div(tmpTotalMaxLBA, pVolume0->NumPhysDisks);
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "IS Volume tmpTotalMaxLBA=%llX\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"IS Volume tmpTotalMaxLBA=%llX\n",
 		(unsigned long long)tmpTotalMaxLBA));
-	}
-	else if (pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IME) {
+	} else if (pVolume0->VolumeType == MPI_RAID_VOL_TYPE_IME) {
 		do_div(tmpTotalMaxLBA, pVolume0->NumPhysDisks * 2);
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "IME Volume tmpTotalMaxLBA=%llX\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"IME Volume tmpTotalMaxLBA=%llX\n",
 		(unsigned long long)tmpTotalMaxLBA));
 	} else {
-		dcsmisasprintk(ioc, printk(KERN_DEBUG "IM Volume tmpTotalMaxLBA=%llX\n",
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"IM Volume tmpTotalMaxLBA=%llX\n",
 		(unsigned long long)tmpTotalMaxLBA));
 	}
 
-	for (i=0; i< min(pVolume0->NumPhysDisks, physDiskNumMax); i++) {
+	for (i = 0; i < min(pVolume0->NumPhysDisks, physDiskNumMax); i++) {
 
 		physDiskNum = pVolume0->PhysDisk[i].PhysDiskNum;
 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 		cfg.pageAddr = physDiskNum;
-		if (mpt_config(ioc, &cfg) != 0){
+		if (mpt_config(ioc, &cfg) != 0) {
 			pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto cim_get_raid_config_exit;
 		}
 
-	        pKarg->Configuration.bDriveCount++;
+		pKarg->Configuration.bDriveCount++;
 		if (pKarg->Configuration.bDataType != CSMI_SAS_RAID_DATA_DRIVES)
 			continue;
 
 		/* Search the list for the matching SAS address. */
-		sas_info = csmisas_get_device_component_by_fw(ioc, pPhysDisk0->PhysDiskBus,
-		    pPhysDisk0->PhysDiskID);
+		sas_info = csmisas_get_device_component_by_fw(ioc,
+		    pPhysDisk0->PhysDiskBus, pPhysDisk0->PhysDiskID);
 		if (sas_info) {
-			sas_address = reverse_byte_order64(sas_info->sas_address);
+			sas_address
+			    = reverse_byte_order64(sas_info->sas_address);
 			memcpy(pKarg->Configuration.Drives[i].bSASAddress,
-			   &sas_address,sizeof(u64));
+			   &sas_address, sizeof(u64));
 			if (!device_info)
 				device_info = sas_info->device_info;
 		}
 
 		memcpy(pKarg->Configuration.Drives[i].bModel,
 		    pPhysDisk0->InquiryData.VendorID,
-		    offsetof(RAID_PHYS_DISK0_INQUIRY_DATA,ProductRevLevel));
+		    offsetof(RAID_PHYS_DISK0_INQUIRY_DATA, ProductRevLevel));
 		memcpy(pKarg->Configuration.Drives[i].bFirmware,
 			pPhysDisk0->InquiryData.ProductRevLevel,
 			sizeof(pPhysDisk0->InquiryData.ProductRevLevel));
@@ -3890,19 +3905,19 @@ csmisas_get_raid_config(unsigned long ar
 		    MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED) {
 			pKarg->Configuration.Drives[i].bDriveStatus =
 			    CSMI_SAS_DRIVE_STATUS_OFFLINE;
-		} else if(pPhysDisk0->PhysDiskStatus.State) {
+		} else if (pPhysDisk0->PhysDiskStatus.State) {
 			pKarg->Configuration.Drives[i].bDriveStatus =
 			    CSMI_SAS_DRIVE_STATUS_FAILED;
-			if(pKarg->Configuration.bStatus ==
+			if (pKarg->Configuration.bStatus ==
 			    CSMI_SAS_RAID_SET_STATUS_DEGRADED)
 				pKarg->Configuration.bInformation = i;
-		} else if((pVolume0->VolumeStatus.Flags &
+		} else if ((pVolume0->VolumeStatus.Flags &
 		    MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) &&
 		    (pPhysDisk0->PhysDiskStatus.Flags &
 		    MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC))
 			pKarg->Configuration.Drives[i].bDriveStatus =
 			    CSMI_SAS_DRIVE_STATUS_REBUILDING;
-		else if(pPhysDisk0->ErrorData.SmartCount ||
+		else if (pPhysDisk0->ErrorData.SmartCount ||
 		    (pPhysDisk0->PhysDiskStatus.Flags &
 		    MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC))
 			pKarg->Configuration.Drives[i].bDriveStatus =
@@ -3918,7 +3933,7 @@ csmisas_get_raid_config(unsigned long ar
 				CSMI_SAS_DRIVE_TYPE_SINGLE_PORT_SAS;
 			if (mpt_raid_phys_disk_get_num_paths(ioc,
 			    pVolume0->PhysDisk[i].PhysDiskNum) > 1)
-					pKarg->Configuration.Drives[i].bDriveType =
+				pKarg->Configuration.Drives[i].bDriveType =
 					    CSMI_SAS_DRIVE_TYPE_DUAL_PORT_SAS;
 		}
 
@@ -3941,9 +3956,9 @@ csmisas_get_raid_config(unsigned long ar
 			if ((pVolume0->VolumeSettings.HotSparePool &
 			    pIocPage5->HotSpare[idx].HotSparePool) == 0)
 				continue;
-			if(pIocPage5->HotSpare[idx].Flags !=
+			if (pIocPage5->HotSpare[idx].Flags !=
 			    MPI_IOC_PAGE_5_HOT_SPARE_ACTIVE)
-			    continue;
+				continue;
 			physDiskNum = pIocPage5->HotSpare[idx].PhysDiskNum;
 			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 			cfg.pageAddr = physDiskNum;
@@ -3981,11 +3996,11 @@ csmisas_get_raid_config(unsigned long ar
 			    MPI_RAID_VOL_TYPE_IME) &&
 			    (((totalMaxLBA +
 			    pVolume0->NumPhysDisks) * 2) +
-			    (64*2*1024 ) /*metadata = 64MB*/ >
+			    (64*2*1024) /*metadata = 64MB*/ >
 			    le32_to_cpu(pPhysDisk0->MaxLBA)))
 				continue;
 
-		        pKarg->Configuration.bDriveCount++;
+			pKarg->Configuration.bDriveCount++;
 			if (pKarg->Configuration.bDataType !=
 			    CSMI_SAS_RAID_DATA_DRIVES) {
 				i++;
@@ -3996,14 +4011,16 @@ csmisas_get_raid_config(unsigned long ar
 			sas_info = csmisas_get_device_component_by_fw(ioc,
 			    pPhysDisk0->PhysDiskBus, pPhysDisk0->PhysDiskID);
 			if (sas_info) {
-				sas_address = reverse_byte_order64(sas_info->sas_address);
+				sas_address =
+				    reverse_byte_order64(sas_info->sas_address);
 				memcpy(pKarg->Configuration.Drives[i].bSASAddress,
-				   &sas_address,sizeof(u64));
+				   &sas_address, sizeof(u64));
 			}
 
 			memcpy(pKarg->Configuration.Drives[i].bModel,
 			    pPhysDisk0->InquiryData.VendorID,
-			    offsetof(RAID_PHYS_DISK0_INQUIRY_DATA,ProductRevLevel));
+			    offsetof(RAID_PHYS_DISK0_INQUIRY_DATA,
+				ProductRevLevel));
 			memcpy(pKarg->Configuration.Drives[i].bFirmware,
 				pPhysDisk0->InquiryData.ProductRevLevel,
 				sizeof(pPhysDisk0->InquiryData.ProductRevLevel));
@@ -4021,10 +4038,10 @@ csmisas_get_raid_config(unsigned long ar
 			}
 			pKarg->Configuration.Drives[i].bDriveStatus =
 			    CSMI_SAS_DRIVE_STATUS_OK;
-			if(pPhysDisk0->PhysDiskStatus.State)
+			if (pPhysDisk0->PhysDiskStatus.State)
 				pKarg->Configuration.Drives[i].bDriveStatus =
 				    CSMI_SAS_DRIVE_STATUS_FAILED;
-			else if(pPhysDisk0->ErrorData.SmartCount)
+			else if (pPhysDisk0->ErrorData.SmartCount)
 				pKarg->Configuration.Drives[i].bDriveStatus =
 				    CSMI_SAS_DRIVE_STATUS_DEGRADED;
 			pKarg->Configuration.Drives[i].bDriveUsage =
@@ -4047,8 +4064,8 @@ csmisas_get_raid_config(unsigned long ar
 		}
 	}
 
-	// Only return data on the first 240 drives
-	if( pKarg->Configuration.bDriveCount > 0xF0 )
+	/* Only return data on the first 240 drives */
+	if (pKarg->Configuration.bDriveCount > 0xF0)
 		pKarg->Configuration.bDriveCount =
 		    CSMI_SAS_RAID_DRIVE_COUNT_TOO_BIG;
 
@@ -4060,11 +4077,11 @@ csmisas_get_raid_config(unsigned long ar
 		pci_free_consistent(ioc->pcidev, volumepage0sz, pVolume0,
 		    volume0_dma);
 
-	if(pPhysDisk0 != NULL)
+	if (pPhysDisk0 != NULL)
 		pci_free_consistent(ioc->pcidev, physdiskpage0sz, pPhysDisk0,
 		    physdisk0_dma);
 
-	if(pIocPage5 != NULL)
+	if (pIocPage5 != NULL)
 		pci_free_consistent(ioc->pcidev, ioc_page5_sz, pIocPage5,
 		    ioc_page5_dma);
 
@@ -4075,17 +4092,17 @@ csmisas_get_raid_config(unsigned long ar
 	switch (pKarg->Configuration.bDataType) {
 	case CSMI_SAS_RAID_DATA_ADDITIONAL_DATA:
 		copy_buffer_sz = sizeof(IOCTL_HEADER) +
-		    offsetof(CSMI_SAS_RAID_CONFIG,Data) +
+		    offsetof(CSMI_SAS_RAID_CONFIG, Data) +
 		    sizeof(CSMI_SAS_RAID_SET_ADDITIONAL_DATA);
 		break;
 	case CSMI_SAS_RAID_DATA_DRIVES:
 		if (pKarg->Configuration.bDriveCount ==
 		    CSMI_SAS_RAID_DRIVE_COUNT_SUPRESSED)
 			copy_buffer_sz = sizeof(IOCTL_HEADER) +
-			    offsetof(CSMI_SAS_RAID_CONFIG,Drives);
-	        else
+			    offsetof(CSMI_SAS_RAID_CONFIG, Drives);
+		else
 			copy_buffer_sz = sizeof(IOCTL_HEADER) +
-			    offsetof(CSMI_SAS_RAID_CONFIG,Drives) +
+			    offsetof(CSMI_SAS_RAID_CONFIG, Drives) +
 			    (pKarg->Configuration.bDriveCount *
 			    sizeof(CSMI_SAS_RAID_DRIVES));
 		break;
@@ -4097,12 +4114,12 @@ csmisas_get_raid_config(unsigned long ar
 	if (copy_to_user(uarg, pKarg, copy_buffer_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		       "Unable to write out csmi_sas_get_raid_config @ %p\n",
-		   	   __FILE__, __LINE__, __FUNCTION__, uarg);
+		       __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)pKarg, memory_pages);
 	return 0;
 }
@@ -4119,15 +4136,15 @@ static int
 csmisas_get_raid_features(unsigned long arg)
 {
 	CSMI_SAS_RAID_FEATURES_BUFFER __user *uarg = (void __user *) arg;
-	CSMI_SAS_RAID_FEATURES_BUFFER karg, *pKarg=NULL;
+	CSMI_SAS_RAID_FEATURES_BUFFER karg, *pKarg = NULL;
 	int csmi_sas_raid_features_buffer_sz, iocnum;
 	int				memory_pages;
 	MPT_ADAPTER		*ioc = NULL;
 
 	if (copy_from_user(&karg, uarg, sizeof(IOCTL_HEADER))) {
-		printk(KERN_ERR "%s@%d::%s() - "
-		    "Unable to read in csmi_sas_get_raid_features struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		printk(KERN_ERR "%s@%d::%s() - Unable to "
+		    "read in csmi_sas_get_raid_features struct @ %p\n",
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -4135,20 +4152,20 @@ csmisas_get_raid_features(unsigned long 
 	memory_pages = get_order(csmi_sas_raid_features_buffer_sz);
 	pKarg = (CSMI_SAS_RAID_FEATURES_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!pKarg){
+	if (!pKarg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to malloc RAID_FEATURES_BUFFER "
 			"csmi_sas_raid_features_buffer_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			csmi_sas_raid_features_buffer_sz, memory_pages);
 		return -ENOMEM;
 	}
 	memset(pKarg, 0, sizeof(*pKarg));
 
 	if (copy_from_user(pKarg, uarg, csmi_sas_raid_features_buffer_sz)) {
-		printk(KERN_ERR "%s@%d::%s() - "
-		    "Unable to read in csmi_sas_get_raid_features struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		printk(KERN_ERR "%s@%d::%s() -  Unable to "
+		    "read in csmi_sas_get_raid_features struct @ %p\n",
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
@@ -4156,22 +4173,22 @@ csmisas_get_raid_features(unsigned long 
 	if (((iocnum = mpt_verify_adapter(pKarg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	if (pKarg->Information.uChangeCount != 0 &&
-	    pKarg->Information.uChangeCount != ioc->csmi_change_count ) {
+	    pKarg->Information.uChangeCount != ioc->csmi_change_count) {
 		pKarg->IoctlHeader.ReturnCode =
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		pKarg->Information.uFailureCode =
@@ -4218,12 +4235,12 @@ csmisas_get_raid_features(unsigned long 
 	    sizeof(CSMI_SAS_RAID_FEATURES_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		"Unable to write out csmi_sas_get_raid_features @ %p\n",
-		__FILE__, __LINE__, __FUNCTION__, uarg);
+		__FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)pKarg, memory_pages);
 	return 0;
 }
@@ -4240,7 +4257,7 @@ static int
 csmisas_set_raid_control(unsigned long arg)
 {
 	CSMI_SAS_RAID_CONTROL_BUFFER __user *uarg = (void __user *) arg;
-	CSMI_SAS_RAID_CONTROL_BUFFER karg, *pKarg=NULL;
+	CSMI_SAS_RAID_CONTROL_BUFFER karg, *pKarg = NULL;
 	int csmi_sas_raid_control_buffer_sz, iocnum;
 	int				memory_pages;
 	MPT_ADAPTER	*ioc = NULL;
@@ -4248,7 +4265,7 @@ csmisas_set_raid_control(unsigned long a
 	if (copy_from_user(&karg, uarg, sizeof(IOCTL_HEADER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_set_raid_control struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -4256,11 +4273,11 @@ csmisas_set_raid_control(unsigned long a
 	memory_pages = get_order(csmi_sas_raid_control_buffer_sz);
 	pKarg = (CSMI_SAS_RAID_CONTROL_BUFFER *)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!pKarg){
+	if (!pKarg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to malloc RAID_CONTROL_BUFFER "
 			"csmi_sas_raid_control_buffer_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			csmi_sas_raid_control_buffer_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -4269,7 +4286,7 @@ csmisas_set_raid_control(unsigned long a
 	if (copy_from_user(pKarg, uarg, csmi_sas_raid_control_buffer_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_set_raid_control struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
@@ -4277,22 +4294,22 @@ csmisas_set_raid_control(unsigned long a
 	if (((iocnum = mpt_verify_adapter(pKarg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	if (pKarg->Information.uChangeCount != 0 &&
-		pKarg->Information.uChangeCount != ioc->csmi_change_count ) {
+		pKarg->Information.uChangeCount != ioc->csmi_change_count) {
 		pKarg->IoctlHeader.ReturnCode =
 		    CSMI_SAS_STATUS_INVALID_PARAMETER;
 		pKarg->Information.uFailureCode =
@@ -4329,8 +4346,8 @@ csmisas_set_raid_control(unsigned long a
 		goto cim_set_raid_control_exit;
 	}
 
-	if( !strcmp(pKarg->Information.bClearConfiguration,
-		CSMI_SAS_RAID_CLEAR_CONFIGURATION_SIGNATURE) ) {
+	if (!strcmp(pKarg->Information.bClearConfiguration,
+		CSMI_SAS_RAID_CLEAR_CONFIGURATION_SIGNATURE)) {
 		pKarg->IoctlHeader.ReturnCode =
 			CSMI_SAS_STATUS_INVALID_PARAMETER;
 		pKarg->Information.uFailureCode =
@@ -4349,12 +4366,12 @@ csmisas_set_raid_control(unsigned long a
 		sizeof(CSMI_SAS_RAID_CONTROL_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		"Unable to write out csmi_sas_set_raid_control @ %p\n",
-		__FILE__, __LINE__, __FUNCTION__, uarg);
+		__FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)pKarg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)pKarg, memory_pages);
 	return 0;
 }
@@ -4378,42 +4395,39 @@ csmisas_get_raid_element(unsigned long a
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_RAID_ELEMENT_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmisas_get_raid_element struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
-/* TODO - implement IOCTL here */
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_BAD_CNTL_CODE;
 	dcsmisasprintk(ioc, printk(KERN_DEBUG ": not implemented\n"));
 
-// csmisas_get_raid_element_exit:
-
 	/* Copy the data from kernel memory to user memory
 	 */
 	if (copy_to_user(uarg, &karg,
 				sizeof(CSMI_SAS_RAID_ELEMENT_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmisas_get_raid_element @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 
 }
@@ -4434,45 +4448,43 @@ csmisas_set_raid_operation(unsigned long
 	MPT_ADAPTER			*ioc = NULL;
 	int				iocnum;
 
-	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_RAID_SET_OPERATION_BUFFER))) {
+	if (copy_from_user(&karg, uarg,
+		sizeof(CSMI_SAS_RAID_SET_OPERATION_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_set_raid_operation struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
-/* TODO - implement IOCTL here */
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_BAD_CNTL_CODE;
 	dcsmisasprintk(ioc, printk(KERN_DEBUG ": not implemented\n"));
 
-// cim_set_raid_operation:
-
 	/* Copy the data from kernel memory to user memory
 	 */
 	if (copy_to_user(uarg, &karg,
 				sizeof(CSMI_SAS_RAID_SET_OPERATION_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_set_raid_operation @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 
 }
@@ -4512,24 +4524,24 @@ csmisas_task_managment(unsigned long arg
 	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SSP_TASK_IU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_task_managment struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
 
@@ -4575,18 +4587,22 @@ csmisas_task_managment(unsigned long arg
 		goto cim_get_task_managment_exit;
 
 	switch (karg.Parameters.uInformation) {
-		case CSMI_SAS_SSP_TEST:
-			dcsmisasprintk(ioc, printk(KERN_DEBUG "TM request for test purposes\n"));
-			break;
-		case CSMI_SAS_SSP_EXCEEDED:
-			dcsmisasprintk(ioc, printk(KERN_DEBUG "TM request due to timeout\n"));
-			break;
-		case CSMI_SAS_SSP_DEMAND:
-			dcsmisasprintk(ioc, printk(KERN_DEBUG "TM request demanded by app\n"));
-			break;
-		case CSMI_SAS_SSP_TRIGGER:
-			dcsmisasprintk(ioc, printk(KERN_DEBUG "TM request sent to trigger event\n"));
-			break;
+	case CSMI_SAS_SSP_TEST:
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"TM request for test purposes\n"));
+		break;
+	case CSMI_SAS_SSP_EXCEEDED:
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"TM request due to timeout\n"));
+		break;
+	case CSMI_SAS_SSP_DEMAND:
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"TM request demanded by app\n"));
+		break;
+	case CSMI_SAS_SSP_TRIGGER:
+		dcsmisasprintk(ioc, printk(KERN_DEBUG
+			"TM request sent to trigger event\n"));
+		break;
 	}
 
 	switch (taskType) {
@@ -4601,12 +4617,12 @@ csmisas_task_managment(unsigned long arg
 				mf = MPT_INDEX_2_MFPTR(hd->ioc, i);
 				TaskMsgContext =
 				    mf->u.frame.hwhdr.msgctxu.MsgContext;
-				found_qtag=1;
+				found_qtag = 1;
 				break;
 			}
 		}
 
-		if(!found_qtag)
+		if (!found_qtag)
 			goto cim_get_task_managment_exit;
 
 	case MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:
@@ -4618,7 +4634,6 @@ csmisas_task_managment(unsigned long arg
 
 		/* Single threading ....
 		 */
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
 		mutex_lock(&ioc->taskmgmt_cmds.mutex);
 		if (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {
 			mutex_unlock(&ioc->taskmgmt_cmds.mutex);
@@ -4626,50 +4641,34 @@ csmisas_task_managment(unsigned long arg
 			    CSMI_SAS_STATUS_FAILED;
 			goto cim_get_task_managment_exit;
 		}
-#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))
-		if (mptctl_set_tm_flags(hd) != 0) {
-			karg.IoctlHeader.ReturnCode =
-			    CSMI_SAS_STATUS_FAILED;
-			goto cim_get_task_managment_exit;
-		}
-#endif
 		/* Send request
 		 */
 		if ((mf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc)) == NULL) {
-			dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
+			dcsmisasprintk(ioc,
+			    printk(KERN_ERR ": no msg frames!\n"));
 			mutex_unlock(&ioc->taskmgmt_cmds.mutex);
 			mpt_clear_taskmgmt_in_progress_flag(ioc);
-#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))
-			mptctl_free_tm_flags(ioc);
-#endif
 			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto cim_get_task_managment_exit;
 		}
 
 		mpi_hdr = (MPIHeader_t *) mf;
 		MsgContext = mpi_hdr->MsgContext;
-		pScsiTm = (pSCSITaskMgmt_t ) mf;
+		pScsiTm = (pSCSITaskMgmt_t) mf;
 
-		memset(pScsiTm,0,sizeof(SCSITaskMgmt_t));
+		memset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));
 		pScsiTm->TaskType = taskType;
 		pScsiTm->Bus = channel;
 		pScsiTm->TargetID = id;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
 		int_to_scsilun(karg.Parameters.bLun,
 		    (struct scsi_lun *)pScsiTm->LUN);
-#else
-		pScsiTm->LUN[1] = karg.Parameters.bLun;
-#endif
 		pScsiTm->MsgContext = MsgContext;
 		pScsiTm->TaskMsgContext = TaskMsgContext;
 		pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
 
 		if (csmisas_send_handshake_wait(ioc, mf,
 		    karg.IoctlHeader.Timeout) != 0)  {
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
 			mutex_unlock(&ioc->taskmgmt_cmds.mutex);
-#endif
 			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 			goto cim_get_task_managment_exit;
 		}
@@ -4677,25 +4676,26 @@ csmisas_task_managment(unsigned long arg
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {
 
 			pScsiTmReply =
-			    (pSCSITaskMgmtReply_t ) ioc->ioctl_cmds.reply;
+			    (pSCSITaskMgmtReply_t) ioc->ioctl_cmds.reply;
 
 			ioc_status = le16_to_cpu(pScsiTmReply->IOCStatus)
 			    & MPI_IOCSTATUS_MASK;
 
-			memset(&karg.Status,0,
+			memset(&karg.Status, 0,
 			    sizeof(CSMI_SAS_SSP_PASSTHRU_STATUS));
 
-			if(ioc_status == MPI_IOCSTATUS_SUCCESS) {
+			if (ioc_status == MPI_IOCSTATUS_SUCCESS) {
 				karg.IoctlHeader.ReturnCode =
 				    CSMI_SAS_STATUS_SUCCESS;
 				karg.Status.bSSPStatus =
 				    CSMI_SAS_SSP_STATUS_COMPLETED;
-			}else if(ioc_status == MPI_IOCSTATUS_INSUFFICIENT_RESOURCES) {
+			} else if (ioc_status
+			    == MPI_IOCSTATUS_INSUFFICIENT_RESOURCES) {
 				karg.IoctlHeader.ReturnCode =
 				    CSMI_SAS_STATUS_SUCCESS;
 				karg.Status.bSSPStatus =
 				    CSMI_SAS_SSP_STATUS_RETRY;
-			}else {
+			} else {
 				karg.IoctlHeader.ReturnCode =
 				    CSMI_SAS_STATUS_FAILED;
 				karg.Status.bSSPStatus =
@@ -4711,9 +4711,7 @@ csmisas_task_managment(unsigned long arg
 		break;
 	}
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
 	mutex_unlock(&ioc->taskmgmt_cmds.mutex);
-#endif
 
  cim_get_task_managment_exit:
 
@@ -4723,11 +4721,11 @@ csmisas_task_managment(unsigned long arg
 				sizeof(CSMI_SAS_SSP_TASK_IU_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to write out csmi_sas_task_managment @ %p\n",
-				__FILE__, __LINE__, __FUNCTION__, uarg);
+				__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -4827,19 +4825,19 @@ csmisas_phy_reset(MPT_ADAPTER *ioc, u8 P
 
 	if ((opcode != MPI_SAS_OP_PHY_LINK_RESET) &&
 	    (opcode != MPI_SAS_OP_PHY_HARD_RESET))
-	    return -1;
+		return -1;
 
 	/* Get a MF for this command.
 	 */
 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
 		dcsmisasprintk(ioc, printk(KERN_ERR ": no msg frames!\n"));
 		return -1;
-        }
+	}
 
 	mpi_hdr = (MPIHeader_t *) mf;
 	MsgContext =  mpi_hdr->MsgContext;
 	sasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;
-	memset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));
+	memset(sasIoUnitCntrReq, 0, sizeof(SasIoUnitControlRequest_t));
 	sasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;
 	sasIoUnitCntrReq->MsgContext = MsgContext;
 	sasIoUnitCntrReq->Operation = opcode;
@@ -4857,7 +4855,7 @@ csmisas_phy_reset(MPT_ADAPTER *ioc, u8 P
 	    & MPI_IOCSTATUS_MASK;
 	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
 		printk(KERN_DEBUG "%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",
-		    __FUNCTION__,
+		    __func__,
 		    sasIoUnitCntrReply->IOCStatus,
 		    sasIoUnitCntrReply->IOCLogInfo);
 		return -1;
@@ -4878,12 +4876,12 @@ csmisas_phy_control(unsigned long arg)
 	CSMI_SAS_PHY_CONTROL_BUFFER __user *uarg = (void __user *) arg;
 	IOCTL_HEADER			ioctl_header;
 	PCSMI_SAS_PHY_CONTROL_BUFFER	karg;
-	SasIOUnitPage0_t		*sasIoUnitPg0=NULL;
+	SasIOUnitPage0_t		*sasIoUnitPg0 = NULL;
 	dma_addr_t			sasIoUnitPg0_dma;
-	int				sasIoUnitPg0_data_sz=0;
-	SasIOUnitPage1_t		*sasIoUnitPg1=NULL;
+	int				sasIoUnitPg0_data_sz = 0;
+	SasIOUnitPage1_t		*sasIoUnitPg1 = NULL;
 	dma_addr_t			sasIoUnitPg1_dma;
-	int				sasIoUnitPg1_data_sz=0;
+	int				sasIoUnitPg1_data_sz = 0;
 	ConfigExtendedPageHeader_t  	hdr;
 	CONFIGPARMS			cfg;
 	MPT_ADAPTER			*ioc = NULL;
@@ -4894,7 +4892,7 @@ csmisas_phy_control(unsigned long arg)
 	if (copy_from_user(&ioctl_header, uarg, sizeof(IOCTL_HEADER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in IOCTL_HEADER"
-		    "struct @ %p\n", __FILE__, __LINE__, __FUNCTION__, uarg);
+		    "struct @ %p\n", __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -4902,11 +4900,11 @@ csmisas_phy_control(unsigned long arg)
 	memory_pages = get_order(csmi_sas_phy_control_buffer_sz);
 	karg = (PCSMI_SAS_PHY_CONTROL_BUFFER)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to malloc SAS_PHY_CONTROL_BUFFER "
 			"csmi_sas_phy_control_buffer_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			csmi_sas_phy_control_buffer_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -4915,7 +4913,7 @@ csmisas_phy_control(unsigned long arg)
 	if (copy_from_user(karg, uarg, csmi_sas_phy_control_buffer_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_phy_control_buffer "
-		    "struct @ %p\n", __FILE__, __LINE__, __FUNCTION__, uarg);
+		    "struct @ %p\n", __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -4923,19 +4921,19 @@ csmisas_phy_control(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(ioctl_header.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	if (karg->bPhyIdentifier >= ioc->num_ports) {
 		karg->IoctlHeader.ReturnCode =
@@ -4970,7 +4968,8 @@ csmisas_phy_control(unsigned long arg)
 	}
 
 	if (hdr.ExtPageLength == 0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sas_phy_control_exit;
 	}
@@ -4980,7 +4979,8 @@ csmisas_phy_control(unsigned long arg)
 	    sasIoUnitPg0_data_sz, &sasIoUnitPg0_dma);
 
 	if (!sasIoUnitPg0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sas_phy_control_exit;
 	}
@@ -5023,7 +5023,8 @@ csmisas_phy_control(unsigned long arg)
 	}
 
 	if (hdr.ExtPageLength == 0) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": hdr.ExtPageLength == 0\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sas_phy_control_exit;
 	}
@@ -5033,7 +5034,8 @@ csmisas_phy_control(unsigned long arg)
 	    sasIoUnitPg1_data_sz, &sasIoUnitPg1_dma);
 
 	if (!sasIoUnitPg1) {
-		dcsmisasprintk(ioc, printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
+		dcsmisasprintk(ioc,
+		    printk(KERN_ERR ": pci_alloc_consistent: FAILED\n"));
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
 		goto cim_sas_phy_control_exit;
 	}
@@ -5054,19 +5056,18 @@ csmisas_phy_control(unsigned long arg)
 	case CSMI_SAS_PC_LINK_RESET:
 	case CSMI_SAS_PC_HARD_RESET:
 	{
-		u8 opcode = (karg->uFunction==CSMI_SAS_PC_LINK_RESET) ?
+		u8 opcode = (karg->uFunction == CSMI_SAS_PC_LINK_RESET) ?
 		    MPI_SAS_OP_PHY_LINK_RESET : MPI_SAS_OP_PHY_HARD_RESET;
 
-		if((karg->uLinkFlags & CSMI_SAS_PHY_ACTIVATE_CONTROL) &&
+		if ((karg->uLinkFlags & CSMI_SAS_PHY_ACTIVATE_CONTROL) &&
 		    (karg->usLengthOfControl >= sizeof(CSMI_SAS_PHY_CONTROL)) &&
-		    (karg->bNumberOfControls > 0)){
-			if(karg->Control[0].bRate ==
+		    (karg->bNumberOfControls > 0)) {
+			if (karg->Control[0].bRate ==
 			   CSMI_SAS_LINK_RATE_1_5_GBPS) {
 				sasIoUnitPg1->PhyData[karg->bPhyIdentifier].MaxMinLinkRate =
 				MPI_SAS_IOUNIT1_MAX_RATE_1_5 |
 				MPI_SAS_IOUNIT1_MIN_RATE_1_5;
-			}
-			else if(karg->Control[0].bRate ==
+			} else if (karg->Control[0].bRate ==
 			   CSMI_SAS_LINK_RATE_3_0_GBPS) {
 				sasIoUnitPg1->PhyData[karg->bPhyIdentifier].MaxMinLinkRate =
 				MPI_SAS_IOUNIT1_MAX_RATE_3_0 |
@@ -5103,7 +5104,7 @@ csmisas_phy_control(unsigned long arg)
 
 	}
 	case CSMI_SAS_PC_PHY_DISABLE:
-		if(karg->usLengthOfControl || karg->bNumberOfControls) {
+		if (karg->usLengthOfControl || karg->bNumberOfControls) {
 			karg->IoctlHeader.ReturnCode =
 			    CSMI_SAS_STATUS_INVALID_PARAMETER;
 			break;
@@ -5135,14 +5136,14 @@ csmisas_phy_control(unsigned long arg)
 		break;
 
 	case CSMI_SAS_PC_GET_PHY_SETTINGS:
-		if(karg->usLengthOfControl || karg->bNumberOfControls) {
+		if (karg->usLengthOfControl || karg->bNumberOfControls) {
 			karg->IoctlHeader.ReturnCode =
 			    CSMI_SAS_STATUS_INVALID_PARAMETER;
 			break;
 		}
-		if(csmi_sas_phy_control_buffer_sz <
-		    offsetof(CSMI_SAS_PHY_CONTROL_BUFFER,Control) +
-		    (4* sizeof(CSMI_SAS_PHY_CONTROL))) {
+		if (csmi_sas_phy_control_buffer_sz <
+		    offsetof(CSMI_SAS_PHY_CONTROL_BUFFER, Control) +
+		    (4 * sizeof(CSMI_SAS_PHY_CONTROL))) {
 			karg->IoctlHeader.ReturnCode =
 			    CSMI_SAS_STATUS_INVALID_PARAMETER;
 			break;
@@ -5175,15 +5176,15 @@ csmisas_phy_control(unsigned long arg)
 
 	/* Copy the data from kernel memory to user memory
 	 */
-	if (copy_to_user(uarg, karg,csmi_sas_phy_control_buffer_sz)) {
+	if (copy_to_user(uarg, karg, csmi_sas_phy_control_buffer_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to write out csmi_sas_phy_control_buffer @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)karg, memory_pages);
 	return 0;
 }
@@ -5202,7 +5203,8 @@ csmisas_phy_control(unsigned long arg)
  *		-EFAULT for non-successful reply or no reply (timeout)
  **/
 static int
-csmisas_get_manuf_pg_7(MPT_ADAPTER *ioc, ManufacturingPage7_t *mfgpage7_buffer, int mfg_size)
+csmisas_get_manuf_pg_7(MPT_ADAPTER *ioc, ManufacturingPage7_t *mfgpage7_buffer,
+    int mfg_size)
 {
 	ConfigPageHeader_t hdr;
 	CONFIGPARMS	cfg;
@@ -5281,41 +5283,41 @@ csmisas_get_connector_info(unsigned long
 		printk(KERN_ERR "%s@%d::%s() - "
 		   "Unable to read in csmi_sas_connector_info_buffer"
 		   " struct @ %p\n",
-		   __FILE__, __LINE__, __FUNCTION__, uarg);
+		   __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
 
 	/* `32` is the sizeof MPI_MANPAGE7_CONNECTOR_INFO */
 	for (i = 0; i < 32; i++) {
 		karg.Reference[i].uPinout = CSMI_SAS_CON_UNKNOWN;
-		strcpy(karg.Reference[i].bConnector,"");
+		strcpy(karg.Reference[i].bConnector, "");
 		karg.Reference[i].bLocation = CSMI_SAS_CON_UNKNOWN;
 	}
 
-	mfgPg7_sz = offsetof(CONFIG_PAGE_MANUFACTURING_7,ConnectorInfo) +
+	mfgPg7_sz = offsetof(CONFIG_PAGE_MANUFACTURING_7, ConnectorInfo) +
 	    (ioc->num_ports * sizeof(MPI_MANPAGE7_CONNECTOR_INFO));
 	mfgPg7 = kmalloc(mfgPg7_sz, GFP_KERNEL);
-	if (!mfgPg7){
+	if (!mfgPg7) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to malloc @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, mfgPg7);
+		    __FILE__, __LINE__, __func__, mfgPg7);
 		return -EFAULT;
 	}
 	memset(mfgPg7, 0, mfgPg7_sz);
@@ -5339,13 +5341,12 @@ csmisas_get_connector_info(unsigned long
 	if (copy_to_user(uarg, &karg,
 		sizeof(CSMI_SAS_CONNECTOR_INFO_BUFFER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
-		"Unable to write out csmi_sas_connector_info_buffer @"
-	       "%p\n",
-		__FILE__, __LINE__, __FUNCTION__, uarg);
+		"Unable to write out csmi_sas_connector_info_buffer @%p\n",
+		__FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return 0;
 }
 
@@ -5357,21 +5358,21 @@ csmisas_get_connector_info(unsigned long
  **/
 static int
 csmisas_fill_location_data(MPT_ADAPTER *ioc, u8 bus, u8 id, u8 opcode,
-	CSMI_SAS_LOCATION_IDENTIFIER * location_ident)
+	CSMI_SAS_LOCATION_IDENTIFIER *location_ident)
 {
 
 	ConfigExtendedPageHeader_t 	hdr;
 	CONFIGPARMS			cfg;
 	int				rc;
-	SasDevicePage0_t		*sasDevicePg0=NULL;
-	SasEnclosurePage0_t		*sasEnclosurePg0=NULL;
-	dma_addr_t			sasDevicePg0_dma,sasEnclosurePg0_dma;
-	int				sasDevicePg0_data_sz=0;
-	int				sasEnclosurePg0_data_sz=0;
+	SasDevicePage0_t		*sasDevicePg0 = NULL;
+	SasEnclosurePage0_t		*sasEnclosurePg0 = NULL;
+	dma_addr_t			sasDevicePg0_dma, sasEnclosurePg0_dma;
+	int				sasDevicePg0_data_sz = 0;
+	int				sasEnclosurePg0_data_sz = 0;
 	u64				sas_address;
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
-	memset (location_ident, 0, sizeof(*location_ident));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
+	memset(location_ident, 0, sizeof(*location_ident));
 
 	/* SAS Device Page 0 */
 	hdr.PageVersion = MPI_SASDEVICE0_PAGEVERSION;
@@ -5389,12 +5390,12 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	cfg.timeout = MPT_IOCTL_DEFAULT_TIMEOUT;
 
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
-		rc=-1;
+		rc = -1;
 		goto fill_location_data_exit;
 	}
 
 	if (hdr.ExtPageLength == 0) {
-		rc=-1;
+		rc = -1;
 		goto fill_location_data_exit;
 	}
 
@@ -5402,7 +5403,7 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	sasDevicePg0 = (SasDevicePage0_t *) pci_alloc_consistent(
 	    ioc->pcidev, sasDevicePg0_data_sz, &sasDevicePg0_dma);
 	if (!sasDevicePg0) {
-		rc=-1;
+		rc = -1;
 		goto fill_location_data_exit;
 	}
 
@@ -5411,10 +5412,10 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 	cfg.pageAddr = (bus << 8) + id
 	    + (MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<
-	       	MPI_SAS_DEVICE_PGAD_FORM_SHIFT);
+		MPI_SAS_DEVICE_PGAD_FORM_SHIFT);
 
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
-		rc=-1;
+		rc = -1;
 		goto fill_location_data_exit;
 	}
 
@@ -5442,12 +5443,12 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	cfg.timeout = MPT_IOCTL_DEFAULT_TIMEOUT;
 
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
-		rc=0;
+		rc = 0;
 		goto fill_location_data_exit;
 	}
 
 	if (hdr.ExtPageLength == 0) {
-		rc=0;
+		rc = 0;
 		goto fill_location_data_exit;
 	}
 
@@ -5455,36 +5456,34 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	sasEnclosurePg0 = (SasEnclosurePage0_t *) pci_alloc_consistent(
 	    ioc->pcidev, sasEnclosurePg0_data_sz, &sasEnclosurePg0_dma);
 	if (!sasEnclosurePg0) {
-		rc=0;
+		rc = 0;
 		goto fill_location_data_exit;
 	}
 	cfg.physAddr = sasEnclosurePg0_dma;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 	cfg.pageAddr = sasDevicePg0->EnclosureHandle
-	    + (MPI_SAS_ENCLOS_PGAD_FORM_HANDLE << MPI_SAS_ENCLOS_PGAD_FORM_SHIFT);
+	    + (MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<
+		MPI_SAS_ENCLOS_PGAD_FORM_SHIFT);
 
 	if ((rc = mpt_config(ioc, &cfg)) != 0) {
-		rc=0;
+		rc = 0;
 		goto fill_location_data_exit;
 	}
 
-	location_ident->bLocationFlags |= CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID;
+	location_ident->bLocationFlags |=
+	    CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID;
 	memcpy(&sas_address, &sasEnclosurePg0->EnclosureLogicalID, sizeof(u64));
 	sas_address = reverse_byte_order64(sas_address);
 	if (sas_address)
-		memcpy(location_ident->bEnclosureIdentifier, &sas_address, sizeof(u64));
+		memcpy(location_ident->bEnclosureIdentifier, &sas_address,
+		    sizeof(u64));
 	else
-		strcpy(location_ident->bEnclosureIdentifier,"Internal");
+		strcpy(location_ident->bEnclosureIdentifier, "Internal");
 
-// bBayPrefix - not supported
+/* bBayPrefix - not supported */
 
-// TODO - We need to look at sasEnclosurePg0-.Flags , to determine
-//	whether SEP BUS/TargetID is valid.  Ifs its a SES device, then
-//	issue internal inquiry to (bus/id) to gather the Enclosure name.
-//	If the device is SMP, then issue SMP_MANUFACTURING to get enclosure name
-//	If its direct attached, there is no enclosure name
 	location_ident->bLocationFlags |= CSMI_SAS_LOCATE_ENCLOSURE_NAME_VALID;
-	strcpy(location_ident->bEnclosureName,"Not Supported");
+	strcpy(location_ident->bEnclosureName, "Not Supported");
 
 	location_ident->bLocationFlags |= CSMI_SAS_LOCATE_LOCATION_STATE_VALID;
 	location_ident->bLocationState = CSMI_SAS_LOCATE_UNKNOWN;
@@ -5493,11 +5492,6 @@ csmisas_fill_location_data(MPT_ADAPTER *
 	location_ident->bBayIdentifier = le16_to_cpu(sasDevicePg0->Slot);
 
 
-// TODO - illuminating LEDs,
-// karg->bIdentify = CSMI_SAS_LOCATE_FORCE_OFF, CSMI_SAS_LOCATE_FORCE_ON
-// We can enable/disable LEDs by SCSI Enclosure Processor MPI request message
-// printk("Flags=0x%x\n",sasEnclosurePg0->Flags);
-
 /* check sasEnclosurePg0->Flags -
  * to validate whether we need to send the SEPRequest
  * bit:5 should be set
@@ -5527,13 +5521,13 @@ fill_location_data_exit:
 		pci_free_consistent(ioc->pcidev, sasEnclosurePg0_data_sz,
 		    sasEnclosurePg0, sasEnclosurePg0_dma);
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	return rc;
 }
 
 static int
-csmisas_fill_location_data_raid(MPT_ADAPTER *ioc, PCSMI_SAS_GET_LOCATION_BUFFER karg, u8 VolumeBus,
-	u8 volumeID)
+csmisas_fill_location_data_raid(MPT_ADAPTER *ioc,
+    PCSMI_SAS_GET_LOCATION_BUFFER karg, u8 VolumeBus, u8 volumeID)
 {
 	pRaidVolumePage0_t		pVolume0 = NULL;
 	pRaidPhysDiskPage0_t		pPhysDisk0 = NULL;
@@ -5554,9 +5548,9 @@ csmisas_fill_location_data_raid(MPT_ADAP
 
 	csmi_sas_get_location_sz = karg->IoctlHeader.Length;
 	physDiskNumMax = (csmi_sas_get_location_sz -
-	    offsetof(CSMI_SAS_GET_LOCATION_BUFFER,Location))
+	    offsetof(CSMI_SAS_GET_LOCATION_BUFFER, Location))
 	    / sizeof(CSMI_SAS_LOCATION_IDENTIFIER);
-	karg->bNumberOfLocationIdentifiers=0;
+	karg->bNumberOfLocationIdentifiers = 0;
 
 	/*
 	 * get RAID Volume Page 0
@@ -5592,7 +5586,7 @@ csmisas_fill_location_data_raid(MPT_ADAP
 
 	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 	cfg.physAddr = volume0_dma;
-	if (mpt_config(ioc, &cfg) != 0){
+	if (mpt_config(ioc, &cfg) != 0) {
 		rc = -1;
 		goto sas_fill_location_data_raid_exit;
 	}
@@ -5632,17 +5626,17 @@ csmisas_fill_location_data_raid(MPT_ADAP
 	}
 	cfg.physAddr = physdisk0_dma;
 
-	for (i=0; i < min(pVolume0->NumPhysDisks, physDiskNumMax); i++) {
+	for (i = 0; i < min(pVolume0->NumPhysDisks, physDiskNumMax); i++) {
 
 		/* obtain a refresh of pPhysDisk0 */
 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 		cfg.pageAddr = pVolume0->PhysDisk[i].PhysDiskNum;
-		if (mpt_config(ioc, &cfg) != 0){
+		if (mpt_config(ioc, &cfg) != 0) {
 			rc = -1;
 			goto sas_fill_location_data_raid_exit;
 		}
 
-		if((csmisas_fill_location_data(ioc, pPhysDisk0->PhysDiskBus,
+		if ((csmisas_fill_location_data(ioc, pPhysDisk0->PhysDiskBus,
 		    pPhysDisk0->PhysDiskID, karg->bIdentify,
 		    &karg->Location[karg->bNumberOfLocationIdentifiers])) == 0)
 			karg->bNumberOfLocationIdentifiers++;
@@ -5679,7 +5673,7 @@ csmisas_fill_location_data_raid(MPT_ADAP
 		if (csmisas_get_ioc_pg5(ioc, iocPage5, sz) != 0)
 			goto sas_fill_location_data_raid_exit;
 
-		for(i = 0, idx = pVolume0->NumPhysDisks ; i < num_hotpares;
+		for (i = 0, idx = pVolume0->NumPhysDisks ; i < num_hotpares;
 		    i++, idx++) {
 
 			if (idx >= physDiskNumMax)
@@ -5728,11 +5722,11 @@ csmisas_fill_location_data_raid(MPT_ADAP
 			if ((pVolume0->VolumeType ==
 				MPI_RAID_VOL_TYPE_IME) &&
 			    ((tmpTotalMaxLBA * 2) +
-			     (64*2*1024 ) /*metadata = 64MB*/ >
+			     (64*2*1024) /*metadata = 64MB*/ >
 			    le32_to_cpu(pPhysDisk0->MaxLBA)))
 				continue;
 
-			if((csmisas_fill_location_data(ioc,
+			if ((csmisas_fill_location_data(ioc,
 			    pPhysDisk0->PhysDiskBus, pPhysDisk0->PhysDiskID,
 			    karg->bIdentify,
 			    &karg->Location[karg->bNumberOfLocationIdentifiers])) == 0)
@@ -5749,7 +5743,7 @@ csmisas_fill_location_data_raid(MPT_ADAP
 		pci_free_consistent(ioc->pcidev, volumepage0sz, pVolume0,
 		    volume0_dma);
 
-	if(pPhysDisk0)
+	if (pPhysDisk0)
 		pci_free_consistent(ioc->pcidev, physdiskpage0sz, pPhysDisk0,
 		    physdisk0_dma);
 
@@ -5771,7 +5765,7 @@ csmisas_get_location(unsigned long arg)
 	PCSMI_SAS_GET_LOCATION_BUFFER	karg;
 	IOCTL_HEADER			ioctl_header;
 	MPT_ADAPTER			*ioc = NULL;
-	int				iocnum,i;
+	int				iocnum, i;
 	int				csmi_sas_get_location_sz;
 	int				memory_pages;
 	struct sas_device_info		*sas_info;
@@ -5779,7 +5773,7 @@ csmisas_get_location(unsigned long arg)
 	if (copy_from_user(&ioctl_header, uarg, sizeof(IOCTL_HEADER))) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in IOCTL_HEADER"
-		    "struct @ %p\n", __FILE__, __LINE__, __FUNCTION__, uarg);
+		    "struct @ %p\n", __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
@@ -5787,11 +5781,11 @@ csmisas_get_location(unsigned long arg)
 	memory_pages = get_order(csmi_sas_get_location_sz);
 	karg = (PCSMI_SAS_GET_LOCATION_BUFFER)__get_free_pages(
 		GFP_KERNEL, memory_pages);
-	if (!karg){
+	if (!karg) {
 		printk(KERN_ERR "%s@%d::%s() - "
 			"Unable to malloc GET_LOCATION_BUFFER "
 			"csmi_sas_get_location_sz=%d memory_pages=%d\n",
-			__FILE__, __LINE__, __FUNCTION__,
+			__FILE__, __LINE__, __func__,
 			csmi_sas_get_location_sz, memory_pages);
 		return -ENOMEM;
 	}
@@ -5800,7 +5794,7 @@ csmisas_get_location(unsigned long arg)
 	if (copy_from_user(karg, uarg, csmi_sas_get_location_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to read in csmi_sas_phy_control_buffer "
-		    "struct @ %p\n", __FILE__, __LINE__, __FUNCTION__, uarg);
+		    "struct @ %p\n", __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
@@ -5808,22 +5802,22 @@ csmisas_get_location(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg->IoctlHeader.IOControllerNumber,
 	    &ioc)) < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
 	if (!csmisas_is_this_sas_cntr(ioc)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not SAS controller!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		free_pages((unsigned long)karg, memory_pages);
 		return -ENODEV;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s enter.\n", __func__));
 
 	karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
-	if(karg->bLengthOfLocationIdentifier !=
+	if (karg->bLengthOfLocationIdentifier !=
 	    sizeof(CSMI_SAS_LOCATION_IDENTIFIER))
 		goto cim_sas_get_location_exit;
 
@@ -5834,12 +5828,12 @@ csmisas_get_location(unsigned long arg)
 
 	/* RAID SUPPORT */
 	if (ioc->raid_data.pIocPg2 && sas_info->is_logical_volume) {
-		for (i=0; i<ioc->raid_data.pIocPg2->NumActiveVolumes; i++){
+		for (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {
 			if (sas_info->fw.id ==
 			    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID &&
 			    sas_info->fw.channel ==
 			    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeBus) {
-				if(csmisas_fill_location_data_raid(ioc, karg,
+				if (csmisas_fill_location_data_raid(ioc, karg,
 				    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeBus,
 				    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID) == 0)
 					karg->IoctlHeader.ReturnCode =
@@ -5858,13 +5852,13 @@ csmisas_get_location(unsigned long arg)
 
 	/* make sure there's enough room to populate the Location[] struct */
 	if ((csmi_sas_get_location_sz -
-	    offsetof(CSMI_SAS_GET_LOCATION_BUFFER,Location)) <
+	    offsetof(CSMI_SAS_GET_LOCATION_BUFFER, Location)) <
 	    sizeof(CSMI_SAS_LOCATION_IDENTIFIER))
 		goto cim_sas_get_location_exit;
 
-	karg->bNumberOfLocationIdentifiers=1;
-	karg->Location[0].bLocationFlags=0;
-	if((csmisas_fill_location_data(ioc, sas_info->fw.channel,
+	karg->bNumberOfLocationIdentifiers = 1;
+	karg->Location[0].bLocationFlags = 0;
+	if ((csmisas_fill_location_data(ioc, sas_info->fw.channel,
 	    sas_info->fw.id, karg->bIdentify, &karg->Location[0])) == 0)
 		karg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
 	else
@@ -5877,12 +5871,12 @@ csmisas_get_location(unsigned long arg)
 	if (copy_to_user(uarg, karg, csmi_sas_get_location_sz)) {
 		printk(KERN_ERR "%s@%d::%s() - "
 		    "Unable to write out csmi_sas_get_location_buffer "
-		    "@ %p\n",__FILE__, __LINE__, __FUNCTION__, uarg);
+		    "@ %p\n", __FILE__, __LINE__, __func__, uarg);
 		free_pages((unsigned long)karg, memory_pages);
 		return -EFAULT;
 	}
 
-	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n",__FUNCTION__));
+	dcsmisasprintk(ioc, printk(KERN_DEBUG "%s exit.\n", __func__));
 	free_pages((unsigned long)karg, memory_pages);
 	return 0;
 }
Index: linux-2.6.27/drivers/message/fusion/csmi/csmisas.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/csmi/csmisas.h
+++ linux-2.6.27/drivers/message/fusion/csmi/csmisas.h
@@ -87,10 +87,10 @@ Revision History:
 #ifndef _CSMI_SAS_H_
 #define _CSMI_SAS_H_
 
-// CSMI Specification Revision, the intent is that all versions of the
-// specification will be backward compatible after the 1.00 release.
-// Major revision number, corresponds to xxxx. of CSMI specification
-// Minor revision number, corresponds to .xxxx of CSMI specification
+/* CSMI Specification Revision, the intent is that all versions of the
+ specification will be backward compatible after the 1.00 release.
+ Major revision number, corresponds to xxxx. of CSMI specification
+ Minor revision number, corresponds to .xxxx of CSMI specification */
 #define CSMI_MAJOR_REVISION   0
 #define CSMI_MINOR_REVISION   90
 
@@ -104,60 +104,60 @@ Revision History:
 /* TARGET OS LINUX SPECIFIC CODE                                         */
 /*************************************************************************/
 
-// EDM #ifdef _linux
 #ifdef __KERNEL__
 
-// Linux base types
+/* Linux base types */
 
 #include <linux/types.h>
 
 #define __i8    char
 
-// pack definition
+/* pack definition */
 
-// EDM #define CSMI_SAS_BEGIN_PACK(x)    pack(x)
-// EDM #define CSMI_SAS_END_PACK         pack()
+#if 0
+ #define CSMI_SAS_BEGIN_PACK(x)    pack(x)
+ #define CSMI_SAS_END_PACK         pack()
 
-// IOCTL Control Codes
-// (IoctlHeader.ControlCode)
+ /* IOCTL Control Codes */
+ /* (IoctlHeader.ControlCode) */
 
-// Control Codes prior to 0.77
+ /* Control Codes prior to 0.77 */
 
-// Control Codes requiring CSMI_ALL_SIGNATURE
+ /* Control Codes requiring CSMI_ALL_SIGNATURE */
 
-// #define CC_CSMI_SAS_GET_DRIVER_INFO    0x12345678
-// #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x23456781
-// #define CC_CSMI_SAS_GET_CNTLR_STATUS   0x34567812
-// #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x92345678
+ #define CC_CSMI_SAS_GET_DRIVER_INFO    0x12345678
+ #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x23456781
+ #define CC_CSMI_SAS_GET_CNTLR_STATUS   0x34567812
+ #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x92345678
 
-// Control Codes requiring CSMI_RAID_SIGNATURE
+ /* Control Codes requiring CSMI_RAID_SIGNATURE */
 
-// #define CC_CSMI_SAS_GET_RAID_INFO      0x45678123
-// #define CC_CSMI_SAS_GET_RAID_CONFIG    0x56781234
+ #define CC_CSMI_SAS_GET_RAID_INFO      0x45678123
+ #define CC_CSMI_SAS_GET_RAID_CONFIG    0x56781234
 
-// Control Codes requiring CSMI_SAS_SIGNATURE
+ /* Control Codes requiring CSMI_SAS_SIGNATURE */
 
-// #define CC_CSMI_SAS_GET_PHY_INFO       0x67812345
-// #define CC_CSMI_SAS_SET_PHY_INFO       0x78123456
-// #define CC_CSMI_SAS_GET_LINK_ERRORS    0x81234567
-// #define CC_CSMI_SAS_SMP_PASSTHRU       0xA1234567
-// #define CC_CSMI_SAS_SSP_PASSTHRU       0xB1234567
-// #define CC_CSMI_SAS_STP_PASSTHRU       0xC1234567
-// #define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xD1234567
-// #define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xE1234567
-// #define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xF1234567
-// #define CC_CSMI_SAS_TASK_MANAGEMENT    0xA2345678
-
-// Control Codes for 0.77 and later
+ #define CC_CSMI_SAS_GET_PHY_INFO       0x67812345
+ #define CC_CSMI_SAS_SET_PHY_INFO       0x78123456
+ #define CC_CSMI_SAS_GET_LINK_ERRORS    0x81234567
+ #define CC_CSMI_SAS_SMP_PASSTHRU       0xA1234567
+ #define CC_CSMI_SAS_SSP_PASSTHRU       0xB1234567
+ #define CC_CSMI_SAS_STP_PASSTHRU       0xC1234567
+ #define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xD1234567
+ #define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xE1234567
+ #define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xF1234567
+ #define CC_CSMI_SAS_TASK_MANAGEMENT    0xA2345678
+#endif
+ /* Control Codes for 0.77 and later */
 
-// Control Codes requiring CSMI_ALL_SIGNATURE
+ /* Control Codes requiring CSMI_ALL_SIGNATURE */
 
 #define CC_CSMI_SAS_GET_DRIVER_INFO    0xCC770001
 #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0xCC770002
 #define CC_CSMI_SAS_GET_CNTLR_STATUS   0xCC770003
 #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0xCC770004
 
-// Control Codes requiring CSMI_RAID_SIGNATURE
+/* Control Codes requiring CSMI_RAID_SIGNATURE */
 
 #define CC_CSMI_SAS_GET_RAID_INFO      0xCC77000A
 #define CC_CSMI_SAS_GET_RAID_CONFIG    0xCC77000B
@@ -166,7 +166,7 @@ Revision History:
 #define CC_CSMI_SAS_GET_RAID_ELEMENT   0xCC77000E
 #define CC_CSMI_SAS_SET_RAID_OPERATION 0xCC77000F
 
-// Control Codes requiring CSMI_SAS_SIGNATURE
+/* Control Codes requiring CSMI_SAS_SIGNATURE */
 
 #define CC_CSMI_SAS_GET_PHY_INFO       0xCC770014
 #define CC_CSMI_SAS_SET_PHY_INFO       0xCC770015
@@ -182,14 +182,14 @@ Revision History:
 #define CC_CSMI_SAS_GET_LOCATION       0xCC770025
 
 
-// Control Codes requiring CSMI_PHY_SIGNATURE
+/* Control Codes requiring CSMI_PHY_SIGNATURE */
 
 #define CC_CSMI_SAS_PHY_CONTROL        0xCC77003C
 
-// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
+/* #pragma CSMI_SAS_BEGIN_PACK(8) */
 #pragma pack(8)
 
-// IOCTL_HEADER
+/* IOCTL_HEADER */
 typedef struct _IOCTL_HEADER {
     __u32 IOControllerNumber;
     __u32 Length;
@@ -199,189 +199,18 @@ typedef struct _IOCTL_HEADER {
 } IOCTL_HEADER,
   *PIOCTL_HEADER;
 
-// EDM #pragma CSMI_SAS_END_PACK
-#pragma pack()
-
-#endif
-
-/*************************************************************************/
-/* TARGET OS WINDOWS SPECIFIC CODE                                       */
-/*************************************************************************/
-
-#ifdef _WIN32
-
-// windows IOCTL definitions
-
-#ifndef _NTDDSCSIH_
-#include <ntddscsi.h>
-#endif
-
-// pack definition
-
-#if defined _MSC_VER
-   #define CSMI_SAS_BEGIN_PACK(x)    pack(push,x)
-   #define CSMI_SAS_END_PACK         pack(pop)
-#elif defined __BORLANDC__
-   #define CSMI_SAS_BEGIN_PACK(x)    option -a##x
-   #define CSMI_SAS_END_PACK         option -a.
-#else
-   #error "CSMISAS.H - Must externally define a pack compiler designator."
-#endif
-
-// base types
-
-#define __u8    unsigned char
-#define __u16   unsigned short
-#define __u32   unsigned long
-#define __u64   unsigned __int64
-
-#define __i8    char
-
-// IOCTL Control Codes
-// (IoctlHeader.ControlCode)
-
-// Control Codes requiring CSMI_ALL_SIGNATURE
-
-#define CC_CSMI_SAS_GET_DRIVER_INFO    1
-#define CC_CSMI_SAS_GET_CNTLR_CONFIG   2
-#define CC_CSMI_SAS_GET_CNTLR_STATUS   3
-#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  4
-
-// Control Codes requiring CSMI_RAID_SIGNATURE
-
-#define CC_CSMI_SAS_GET_RAID_INFO      10
-#define CC_CSMI_SAS_GET_RAID_CONFIG    11
-#define CC_CSMI_SAS_GET_RAID_FEATURES  12
-#define CC_CSMI_SAS_SET_RAID_CONTROL   13
-#define CC_CSMI_SAS_GET_RAID_ELEMENT   14
-#define CC_CSMI_SAS_SET_RAID_OPERATION 15
-
-// Control Codes requiring CSMI_SAS_SIGNATURE
-
-#define CC_CSMI_SAS_GET_PHY_INFO       20
-#define CC_CSMI_SAS_SET_PHY_INFO       21
-#define CC_CSMI_SAS_GET_LINK_ERRORS    22
-#define CC_CSMI_SAS_SMP_PASSTHRU       23
-#define CC_CSMI_SAS_SSP_PASSTHRU       24
-#define CC_CSMI_SAS_STP_PASSTHRU       25
-#define CC_CSMI_SAS_GET_SATA_SIGNATURE 26
-#define CC_CSMI_SAS_GET_SCSI_ADDRESS   27
-#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 28
-#define CC_CSMI_SAS_TASK_MANAGEMENT    29
-#define CC_CSMI_SAS_GET_CONNECTOR_INFO 30
-#define CC_CSMI_SAS_GET_LOCATION       31
-
-// Control Codes requiring CSMI_PHY_SIGNATURE
-
-#define CC_CSMI_SAS_PHY_CONTROL        60
-
-#define IOCTL_HEADER SRB_IO_CONTROL
-#define PIOCTL_HEADER PSRB_IO_CONTROL
-
-#endif
-
-/*************************************************************************/
-/* TARGET OS NETWARE SPECIFIC CODE                                       */
-/*************************************************************************/
-
-#ifdef _NETWARE
-
-// NetWare IOCTL definitions
-
-#define CSMI_SAS_BEGIN_PACK(x)    pack(x)
-#define CSMI_SAS_END_PACK         pack()
-
-#ifndef LONG
-typedef unsigned long LONG;
-#endif
-
-#ifndef WORD
-typedef unsigned short WORD;
-#endif
-
-#ifndef BYTE
-typedef unsigned char BYTE;
-#endif
-
-/* Need to have these definitions for Netware */
-#define __u8    unsigned char
-#define __u16   unsigned short
-#define __u32   unsigned long
-#define __u64   unsigned __int64
-
-#define __i8    char
-
-
-// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
-#pragma pack(8)
-
-// IOCTL_HEADER
-typedef struct _IOCTL_HEADER {
-    __u32 Length;
-    __u32 ReturnCode;
-} IOCTL_HEADER,
-  *PIOCTL_HEADER;
-
-// EDM #pragma CSMI_SAS_END_PACK
 #pragma pack()
 
-// IOCTL Control Codes
-// (IoctlHeader.ControlCode)
-
-// Control Codes requiring CSMI_ALL_SIGNATURE
-
-#define CC_CSMI_SAS_GET_DRIVER_INFO    0x01FF0001
-#define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x01FF0002
-#define CC_CSMI_SAS_GET_CNTLR_STATUS   0x01FF0003
-#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x01FF0004
-
-// Control Codes requiring CSMI_RAID_SIGNATURE
-
-#define CC_CSMI_SAS_GET_RAID_INFO      0x01FF000A
-#define CC_CSMI_SAS_GET_RAID_CONFIG    0x01FF000B
-#define CC_CSMI_SAS_GET_RAID_FEATURES  0x01FF000C
-#define CC_CSMI_SAS_SET_RAID_CONTROL   0x01FF000D
-#define CC_CSMI_SAS_GET_RAID_ELEMENT   0x01FF000E
-#define CC_CSMI_SAS_SET_RAID_OPERATION 0x01FF000F
-
-// Control Codes requiring CSMI_SAS_SIGNATURE
-
-#define CC_CSMI_SAS_GET_PHY_INFO       0x01FF0014
-#define CC_CSMI_SAS_SET_PHY_INFO       0x01FF0015
-#define CC_CSMI_SAS_GET_LINK_ERRORS    0x01FF0016
-#define CC_CSMI_SAS_SMP_PASSTHRU       0x01FF0017
-#define CC_CSMI_SAS_SSP_PASSTHRU       0x01FF0018
-#define CC_CSMI_SAS_STP_PASSTHRU       0x01FF0019
-#define CC_CSMI_SAS_GET_SATA_SIGNATURE 0x01FF001A
-#define CC_CSMI_SAS_GET_SCSI_ADDRESS   0x01FF001B
-#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0x01FF001C
-#define CC_CSMI_SAS_TASK_MANAGEMENT    0x01FF001D
-#define CC_CSMI_SAS_GET_CONNECTOR_INFO 0x01FF001E
-#define CC_CSMI_SAS_GET_LOCATION       0x01FF001F
-
-// Control Codes requiring CSMI_PHY_SIGNATURE
-
-#define CC_CSMI_SAS_PHY_CONTROL        60
-
 #endif
 
 /*************************************************************************/
-/* TARGET OS NOT DEFINED ERROR                                           */
-/*************************************************************************/
-
-// EDM
-//#if (!_WIN32 && !_linux && !_NETWARE)
-//   #error "Unknown target OS."
-//#endif
-
-/*************************************************************************/
 /* OS INDEPENDENT CODE                                                   */
 /*************************************************************************/
 
 /* * * * * * * * * * Class Independent IOCTL Constants * * * * * * * * * */
 
-// Return codes for all IOCTL's regardless of class
-// (IoctlHeader.ReturnCode)
+/* Return codes for all IOCTL's regardless of class*/
+/* (IoctlHeader.ReturnCode) */
 
 #define CSMI_SAS_STATUS_SUCCESS              0
 #define CSMI_SAS_STATUS_FAILED               1
@@ -389,51 +218,51 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_STATUS_INVALID_PARAMETER    3
 #define CSMI_SAS_STATUS_WRITE_ATTEMPTED      4
 
-// Signature value
-// (IoctlHeader.Signature)
+/* Signature value
+ (IoctlHeader.Signature) */
 
 #define CSMI_ALL_SIGNATURE    "CSMIALL"
 
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
+/* Timeout value default of 60 seconds
+ (IoctlHeader.Timeout) */
 
 #define CSMI_ALL_TIMEOUT      60
 
-//  Direction values for data flow on this IOCTL
-// (IoctlHeader.Direction, Linux only)
+/*  Direction values for data flow on this IOCTL
+ (IoctlHeader.Direction, Linux only) */
 #define CSMI_SAS_DATA_READ    0
 #define CSMI_SAS_DATA_WRITE   1
 
-// I/O Bus Types
-// ISA and EISA bus types are not supported
-// (bIoBusType)
+/* I/O Bus Types
+ ISA and EISA bus types are not supported
+ (bIoBusType) */
 
 #define CSMI_SAS_BUS_TYPE_PCI       3
 #define CSMI_SAS_BUS_TYPE_PCMCIA    4
 
-// Controller Status
-// (uStatus)
+/* Controller Status
+ (uStatus) */
 
 #define CSMI_SAS_CNTLR_STATUS_GOOD     1
 #define CSMI_SAS_CNTLR_STATUS_FAILED   2
 #define CSMI_SAS_CNTLR_STATUS_OFFLINE  3
 #define CSMI_SAS_CNTLR_STATUS_POWEROFF 4
 
-// Offline Status Reason
-// (uOfflineReason)
+/* Offline Status Reason
+ (uOfflineReason) */
 
 #define CSMI_SAS_OFFLINE_REASON_NO_REASON             0
 #define CSMI_SAS_OFFLINE_REASON_INITIALIZING          1
 #define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_DEGRADED 2
 #define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_FAILURE  3
 
-// Controller Class
-// (bControllerClass)
+/* Controller Class
+ (bControllerClass) */
 
 #define CSMI_SAS_CNTLR_CLASS_HBA    5
 
-// Controller Flag bits
-// (uControllerFlags)
+/* Controller Flag bits
+ (uControllerFlags) */
 
 #define CSMI_SAS_CNTLR_SAS_HBA          0x00000001
 #define CSMI_SAS_CNTLR_SAS_RAID         0x00000002
@@ -441,32 +270,29 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_CNTLR_SATA_RAID        0x00000008
 #define CSMI_SAS_CNTLR_SMART_ARRAY      0x00000010
 
-// for firmware download
+/* for firmware download */
 #define CSMI_SAS_CNTLR_FWD_SUPPORT      0x00010000
 #define CSMI_SAS_CNTLR_FWD_ONLINE       0x00020000
 #define CSMI_SAS_CNTLR_FWD_SRESET       0x00040000
 #define CSMI_SAS_CNTLR_FWD_HRESET       0x00080000
 #define CSMI_SAS_CNTLR_FWD_RROM         0x00100000
 
-// for RAID configuration supported
+/* for RAID configuration supported */
 #define CSMI_SAS_CNTLR_RAID_CFG_SUPPORT 0x01000000
 
-// Download Flag bits
-// (uDownloadFlags)
+/* Download Flag bits (uDownloadFlags) */
 #define CSMI_SAS_FWD_VALIDATE       0x00000001
 #define CSMI_SAS_FWD_SOFT_RESET     0x00000002
 #define CSMI_SAS_FWD_HARD_RESET     0x00000004
 
-// Firmware Download Status
-// (usStatus)
+/* Firmware Download Status (usStatus) */
 #define CSMI_SAS_FWD_SUCCESS        0
 #define CSMI_SAS_FWD_FAILED         1
 #define CSMI_SAS_FWD_USING_RROM     2
 #define CSMI_SAS_FWD_REJECT         3
 #define CSMI_SAS_FWD_DOWNREV        4
 
-// Firmware Download Severity
-// (usSeverity>
+/* Firmware Download Severity (usSeverity) */
 #define CSMI_SAS_FWD_INFORMATION    0
 #define CSMI_SAS_FWD_WARNING        1
 #define CSMI_SAS_FWD_ERROR          2
@@ -474,25 +300,22 @@ typedef struct _IOCTL_HEADER {
 
 /* * * * * * * * * * SAS RAID Class IOCTL Constants  * * * * * * * * */
 
-// Return codes for the RAID IOCTL's regardless of class
-// (IoctlHeader.ReturnCode)
+/* Return codes for the RAID IOCTL's regardless of class */
+/* (IoctlHeader.ReturnCode) */
 
 #define CSMI_SAS_RAID_SET_OUT_OF_RANGE       1000
 #define CSMI_SAS_RAID_SET_BUFFER_TOO_SMALL   1001
 #define CSMI_SAS_RAID_SET_DATA_CHANGED       1002
 
-// Signature value
-// (IoctlHeader.Signature)
+/* Signature value (IoctlHeader.Signature) */
 
 #define CSMI_RAID_SIGNATURE    "CSMIARY"
 
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
+/* Timeout value default of 60 seconds  (IoctlHeader.Timeout) */
 
 #define CSMI_RAID_TIMEOUT      60
 
-// RAID Types
-// (bRaidType)
+/* RAID Types  (bRaidType) */
 #define CSMI_SAS_RAID_TYPE_NONE     0
 #define CSMI_SAS_RAID_TYPE_0        1
 #define CSMI_SAS_RAID_TYPE_1        2
@@ -504,12 +327,11 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_RAID_TYPE_VOLUME   8
 #define CSMI_SAS_RAID_TYPE_1E       9
 #define CSMI_SAS_RAID_TYPE_OTHER    255
-// the last value 255 was already defined for other
-// so end is defined as 254
+/* the last value 255 was already defined for other  so end is defined as 254 */
 #define CSMI_SAS_RAID_TYPE_END      254
 
-// RAID Status
-// (bStatus)
+/* RAID Status  (bStatus) */
+
 #define CSMI_SAS_RAID_SET_STATUS_OK             0
 #define CSMI_SAS_RAID_SET_STATUS_DEGRADED       1
 #define CSMI_SAS_RAID_SET_STATUS_REBUILDING     2
@@ -519,19 +341,16 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_RAID_SET_STATUS_QUEUED_FOR_REBUILD         6
 #define CSMI_SAS_RAID_SET_STATUS_QUEUED_FOR_TRANSFORMATION  7
 
-// RAID Drive Count
-// (bDriveCount, 0xF1 to 0xFF are reserved)
+/* RAID Drive Count  (bDriveCount, 0xF1 to 0xFF are reserved) */
 #define CSMI_SAS_RAID_DRIVE_COUNT_TOO_BIG   0xF1
 #define CSMI_SAS_RAID_DRIVE_COUNT_SUPRESSED 0xF2
 
-// RAID Data Type
-// (bDataType)
+/* RAID Data Type  (bDataType) */
 #define CSMI_SAS_RAID_DATA_DRIVES           0
 #define CSMI_SAS_RAID_DATA_DEVICE_ID        1
 #define CSMI_SAS_RAID_DATA_ADDITIONAL_DATA  2
 
-// RAID Drive Status
-// (bDriveStatus)
+/* RAID Drive Status  (bDriveStatus) */
 #define CSMI_SAS_DRIVE_STATUS_OK          0
 #define CSMI_SAS_DRIVE_STATUS_REBUILDING  1
 #define CSMI_SAS_DRIVE_STATUS_FAILED      2
@@ -539,15 +358,13 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_DRIVE_STATUS_OFFLINE     4
 #define CSMI_SAS_DRIVE_STATUS_QUEUED_FOR_REBUILD 5
 
-// RAID Drive Usage
-// (bDriveUsage)
+/* RAID Drive Usage  (bDriveUsage) */
 #define CSMI_SAS_DRIVE_CONFIG_NOT_USED      0
 #define CSMI_SAS_DRIVE_CONFIG_MEMBER        1
 #define CSMI_SAS_DRIVE_CONFIG_SPARE         2
 #define CSMI_SAS_DRIVE_CONFIG_SPARE_ACTIVE  3
 
-// RAID Drive Type
-// (bDriveType)
+/* RAID Drive Type  (bDriveType) */
 #define CSMI_SAS_DRIVE_TYPE_UNKNOWN         0
 #define CSMI_SAS_DRIVE_TYPE_SINGLE_PORT_SAS 1
 #define CSMI_SAS_DRIVE_TYPE_DUAL_PORT_SAS   2
@@ -555,23 +372,20 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_DRIVE_TYPE_SATA_PS         4
 #define CSMI_SAS_DRIVE_TYPE_OTHER           255
 
-// RAID Write Protect
-// (bWriteProtect)
+/* RAID Write Protect  (bWriteProtect) */
 #define CSMI_SAS_RAID_SET_WRITE_PROTECT_UNKNOWN     0
 #define CSMI_SAS_RAID_SET_WRITE_PROTECT_UNCHANGED   0
 #define CSMI_SAS_RAID_SET_WRITE_PROTECT_ENABLED     1
 #define CSMI_SAS_RAID_SET_WRITE_PROTECT_DISABLED    2
 
-// RAID Cache Setting
-// (bCacheSetting)
+/* RAID Cache Setting (bCacheSetting) */
 #define CSMI_SAS_RAID_SET_CACHE_UNKNOWN             0
 #define CSMI_SAS_RAID_SET_CACHE_UNCHANGED           0
 #define CSMI_SAS_RAID_SET_CACHE_ENABLED             1
 #define CSMI_SAS_RAID_SET_CACHE_DISABLED            2
 #define CSMI_SAS_RAID_SET_CACHE_CORRUPT             3
 
-// RAID Features
-// (uFeatures)
+/* RAID Features  (uFeatures) */
 #define CSMI_SAS_RAID_FEATURE_TRANSFORMATION    0x00000001
 #define CSMI_SAS_RAID_FEATURE_REBUILD           0x00000002
 #define CSMI_SAS_RAID_FEATURE_SPLIT_MIRROR      0x00000004
@@ -580,8 +394,7 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_RAID_FEATURE_SURFACE_SCAN      0x00000020
 #define CSMI_SAS_RAID_FEATURE_SPARES_SHARED     0x00000040
 
-// RAID Priority
-// (bDefaultTransformPriority, etc.)
+/* RAID Priority  (bDefaultTransformPriority, etc.) */
 #define CSMI_SAS_PRIORITY_UNKNOWN   0
 #define CSMI_SAS_PRIORITY_UNCHANGED 0
 #define CSMI_SAS_PRIORITY_AUTO      1
@@ -590,30 +403,25 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_PRIORITY_MEDIUM    4
 #define CSMI_SAS_PRIORITY_HIGH      5
 
-// RAID Transformation Rules
-// (uRaidSetTransformationRules)
+/* RAID Transformation Rules  (uRaidSetTransformationRules) */
 #define CSMI_SAS_RAID_RULE_AVAILABLE_MEMORY     0x00000001
 #define CSMI_SAS_RAID_RULE_OVERLAPPED_EXTENTS   0x00000002
 
-// RAID Cache Ratios Supported
-// (bCacheRatiosSupported)
-// from 0 to 100 defines the write to read ratio, 0 is 100% write
+/* RAID Cache Ratios Supported  (bCacheRatiosSupported) */
+/*  from 0 to 100 defines the write to read ratio, 0 is 100% write */
 #define CSMI_SAS_RAID_CACHE_RATIO_RANGE     101
 #define CSMI_SAS_RAID_CACHE_RATIO_FIXED     102
 #define CSMI_SAS_RAID_CACHE_RATIO_AUTO      103
 #define CSMI_SAS_RAID_CACHE_RATIO_END       255
 
-// RAID Cache Ratio Flag
-// (bCacheRatioFlag)
+/* RAID Cache Ratio Flag  (bCacheRatioFlag) */
 #define CSMI_SAS_RAID_CACHE_RATIO_DISABLE   0
 #define CSMI_SAS_RAID_CACHE_RATIO_ENABLE    1
 
-// RAID Clear Configuration Signature
-// (bClearConfiguration)
+/* RAID Clear Configuration Signature  (bClearConfiguration) */
 #define CSMI_SAS_RAID_CLEAR_CONFIGURATION_SIGNATURE "RAIDCLR"
 
-// RAID Failure Codes
-// (uFailureCode)
+/* RAID Failure Codes  (uFailureCode) */
 #define CSMI_SAS_FAIL_CODE_OK                           0
 #define CSMI_SAS_FAIL_CODE_PARAMETER_INVALID            1000
 #define CSMI_SAS_FAIL_CODE_TRANSFORM_PRIORITY_INVALID   1001
@@ -638,22 +446,19 @@ typedef struct _IOCTL_HEADER {
 
 #define CSMI_SAS_FAIL_CODE_WAIT_FOR_OPERATION           3000
 
-// RAID Enumeration Types
-// (uEnumerationType)
+/* RAID Enumeration Types  (uEnumerationType) */
 #define CSMI_SAS_RAID_ELEMENT_TYPE_DRIVE                0
 #define CSMI_SAS_RAID_ELEMENT_TYPE_MODULE               1
 #define CSMI_SAS_RAID_ELEMENT_TYPE_DRIVE_RAID_SET       2
 #define CSMI_SAS_RAID_ELEMENT_TYPE_EXTENT_DRIVE         3
 
-// RAID Extent Types
-// (bExtentType)
+/* RAID Extent Types  (bExtentType) */
 #define CSMI_SAS_RAID_EXTENT_RESERVED       0
 #define CSMI_SAS_RAID_EXTENT_METADATA       1
 #define CSMI_SAS_RAID_EXTENT_ALLOCATED      2
 #define CSMI_SAS_RAID_EXTENT_UNALLOCATED    3
 
-// RAID Operation Types
-// (uOperationType)
+/* RAID Operation Types  (uOperationType) */
 #define CSMI_SAS_RAID_SET_CREATE            0
 #define CSMI_SAS_RAID_SET_LABEL             1
 #define CSMI_SAS_RAID_SET_TRANSFORM         2
@@ -663,23 +468,20 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_RAID_SET_ONLINE_STATE      6
 #define CSMI_SAS_RAID_SET_SPARE             7
 
-// RAID Transform Types
-// (bTransformType)
+/* RAID Transform Types  (bTransformType) */
 #define CSMI_SAS_RAID_SET_TRANSFORM_SPLIT_MIRROR    0
 #define CSMI_SAS_RAID_SET_TRANSFORM_MERGE_RAID_0    1
 #define CSMI_SAS_RAID_SET_TRANSFORM_LUN_RENUMBER    2
 #define CSMI_SAS_RAID_SET_TRANSFORM_RAID_SET        3
 
-// RAID Online State
-// (bOnlineState)
+/* RAID Online State  (bOnlineState) */
 #define CSMI_SAS_RAID_SET_STATE_UNKNOWN     0
 #define CSMI_SAS_RAID_SET_STATE_ONLINE      1
 #define CSMI_SAS_RAID_SET_STATE_OFFLINE     2
 
 /* * * * * * * * * * SAS HBA Class IOCTL Constants * * * * * * * * * */
 
-// Return codes for SAS IOCTL's
-// (IoctlHeader.ReturnCode)
+/* Return codes for SAS IOCTL's (IoctlHeader.ReturnCode) */
 
 #define CSMI_SAS_PHY_INFO_CHANGED            CSMI_SAS_STATUS_SUCCESS
 #define CSMI_SAS_PHY_INFO_NOT_CHANGEABLE     2000
@@ -700,18 +502,15 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_NO_SCSI_ADDRESS             2013
 #define CSMI_SAS_NO_DEVICE_ADDRESS           2014
 
-// Signature value
-// (IoctlHeader.Signature)
+/* Signature value  (IoctlHeader.Signature) */
 
 #define CSMI_SAS_SIGNATURE    "CSMISAS"
 
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
+/* Timeout value default of 60 seconds (IoctlHeader.Timeout) */
 
 #define CSMI_SAS_TIMEOUT      60
 
-// Device types
-// (bDeviceType)
+/* Device types (bDeviceType) */
 
 #define CSMI_SAS_PHY_UNUSED               0x00
 #define CSMI_SAS_NO_DEVICE_ATTACHED       0x00
@@ -719,16 +518,15 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_EDGE_EXPANDER_DEVICE     0x20
 #define CSMI_SAS_FANOUT_EXPANDER_DEVICE   0x30
 
-// Protocol options
-// (bInitiatorPortProtocol, bTargetPortProtocol)
+/* Protocol options  (bInitiatorPortProtocol, bTargetPortProtocol) */
 
 #define CSMI_SAS_PROTOCOL_SATA   0x01
 #define CSMI_SAS_PROTOCOL_SMP    0x02
 #define CSMI_SAS_PROTOCOL_STP    0x04
 #define CSMI_SAS_PROTOCOL_SSP    0x08
 
-// Negotiated and hardware link rates
-// (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate)
+/* Negotiated and hardware link rates */
+/* (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate) */
 
 #define CSMI_SAS_LINK_RATE_UNKNOWN  0x00
 #define CSMI_SAS_PHY_DISABLED       0x01
@@ -739,8 +537,7 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_LINK_RATE_3_0_GBPS 0x09
 #define CSMI_SAS_LINK_VIRTUAL       0x10
 
-// Discover state
-// (bAutoDiscover)
+/* Discover state  (bAutoDiscover) */
 
 #define CSMI_SAS_DISCOVER_NOT_SUPPORTED   0x00
 #define CSMI_SAS_DISCOVER_NOT_STARTED     0x01
@@ -748,57 +545,49 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_DISCOVER_COMPLETE        0x03
 #define CSMI_SAS_DISCOVER_ERROR           0x04
 
-// Phy features
+/*  Phy features */
 
 #define CSMI_SAS_PHY_VIRTUAL_SMP          0x01
 
-// Programmed link rates
-// (bMinimumLinkRate, bMaximumLinkRate)
-// (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate)
+/* Programmed link rates  (bMinimumLinkRate, bMaximumLinkRate) */
+/* (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate) */
 
 #define CSMI_SAS_PROGRAMMED_LINK_RATE_UNCHANGED 0x00
 #define CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS  0x08
 #define CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS  0x09
 
-// Link rate
-// (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO)
+/* Link rate  (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO) */
 
 #define CSMI_SAS_LINK_RATE_NEGOTIATE      0x00
 #define CSMI_SAS_LINK_RATE_PHY_DISABLED   0x01
 
-// Signal class
-// (bSignalClass in CSMI_SAS_SET_PHY_INFO)
+/* Signal class  (bSignalClass in CSMI_SAS_SET_PHY_INFO) */
 
 #define CSMI_SAS_SIGNAL_CLASS_UNKNOWN     0x00
 #define CSMI_SAS_SIGNAL_CLASS_DIRECT      0x01
 #define CSMI_SAS_SIGNAL_CLASS_SERVER      0x02
 #define CSMI_SAS_SIGNAL_CLASS_ENCLOSURE   0x03
 
-// Link error reset
-// (bResetCounts)
+/* Link error reset  (bResetCounts) */
 
 #define CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS   0x00
 #define CSMI_SAS_LINK_ERROR_RESET_COUNTS        0x01
 
-// Phy identifier
-// (bPhyIdentifier)
+/* Phy identifier  (bPhyIdentifier) */
 
 #define CSMI_SAS_USE_PORT_IDENTIFIER   0xFF
 
-// Port identifier
-// (bPortIdentifier)
+/* Port identifier  (bPortIdentifier) */
 
 #define CSMI_SAS_IGNORE_PORT           0xFF
 
-// Programmed link rates
-// (bConnectionRate)
+/* Programmed link rates  (bConnectionRate) */
 
 #define CSMI_SAS_LINK_RATE_NEGOTIATED  0x00
 #define CSMI_SAS_LINK_RATE_1_5_GBPS    0x08
 #define CSMI_SAS_LINK_RATE_3_0_GBPS    0x09
 
-// Connection status
-// (bConnectionStatus)
+/* Connection status  (bConnectionStatus) */
 
 #define CSMI_SAS_OPEN_ACCEPT                          0
 #define CSMI_SAS_OPEN_REJECT_BAD_DESTINATION          1
@@ -814,8 +603,7 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY       11
 #define CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION        12
 
-// SSP Status
-// (bSSPStatus)
+/* SSP Status  (bSSPStatus)*/
 
 #define CSMI_SAS_SSP_STATUS_UNKNOWN     0x00
 #define CSMI_SAS_SSP_STATUS_WAITING     0x01
@@ -824,8 +612,7 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_SSP_STATUS_RETRY       0x04
 #define CSMI_SAS_SSP_STATUS_NO_TAG      0x05
 
-// SSP Flags
-// (uFlags)
+/* SSP Flags  (uFlags) */
 
 #define CSMI_SAS_SSP_READ           0x00000001
 #define CSMI_SAS_SSP_WRITE          0x00000002
@@ -836,15 +623,13 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED        0x00000020
 #define CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA            0x00000040
 
-// SSP Data present
-// (bDataPresent)
+/* SSP Data present  (bDataPresent) */
 
 #define CSMI_SAS_SSP_NO_DATA_PRESENT         0x00
 #define CSMI_SAS_SSP_RESPONSE_DATA_PRESENT   0x01
 #define CSMI_SAS_SSP_SENSE_DATA_PRESENT      0x02
 
-// STP Flags
-// (uFlags)
+/* STP Flags  (uFlags) */
 
 #define CSMI_SAS_STP_READ           0x00000001
 #define CSMI_SAS_STP_WRITE          0x00000002
@@ -856,15 +641,13 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_STP_EXECUTE_DIAG   0x00000100
 #define CSMI_SAS_STP_RESET_DEVICE   0x00000200
 
-// Task Management Flags
-// (uFlags)
+/* Task Management Flags  (uFlags) */
 
 #define CSMI_SAS_TASK_IU               0x00000001
 #define CSMI_SAS_HARD_RESET_SEQUENCE   0x00000002
 #define CSMI_SAS_SUPPRESS_RESULT       0x00000004
 
-// Task Management Functions
-// (bTaskManagement)
+/* Task Management Functions  (bTaskManagement) */
 
 #define CSMI_SAS_SSP_ABORT_TASK           0x01
 #define CSMI_SAS_SSP_ABORT_TASK_SET       0x02
@@ -873,16 +656,14 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_SSP_CLEAR_ACA            0x40
 #define CSMI_SAS_SSP_QUERY_TASK           0x80
 
-// Task Management Information
-// (uInformation)
+/* Task Management Information  (uInformation) */
 
 #define CSMI_SAS_SSP_TEST           1
 #define CSMI_SAS_SSP_EXCEEDED       2
 #define CSMI_SAS_SSP_DEMAND         3
 #define CSMI_SAS_SSP_TRIGGER        4
 
-// Connector Pinout Information
-// (uPinout)
+/* Connector Pinout Information  (uPinout) */
 
 #define CSMI_SAS_CON_UNKNOWN              0x00000001
 #define CSMI_SAS_CON_SFF_8482             0x00000002
@@ -895,10 +676,9 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_CON_SFF_8484_LANE_3      0x00040000
 #define CSMI_SAS_CON_SFF_8484_LANE_4      0x00080000
 
-// Connector Location Information
-// (bLocation)
+/* Connector Location Information  (bLocation) */
 
-// same as uPinout above...
+/* same as uPinout above... */
 // #define CSMI_SAS_CON_UNKNOWN              0x01
 #define CSMI_SAS_CON_INTERNAL             0x02
 #define CSMI_SAS_CON_EXTERNAL             0x04
@@ -907,15 +687,13 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_CON_NOT_PRESENT          0x20
 #define CSMI_SAS_CON_NOT_CONNECTED        0x80
 
-// Device location identification
-// (bIdentify)
+/* Device location identification  (bIdentify) */
 
 #define CSMI_SAS_LOCATE_UNKNOWN           0x00
 #define CSMI_SAS_LOCATE_FORCE_OFF         0x01
 #define CSMI_SAS_LOCATE_FORCE_ON          0x02
 
-// Location Valid flags
-// (uLocationFlags)
+/* Location Valid flags  (uLocationFlags) */
 
 #define CSMI_SAS_LOCATE_SAS_ADDRESS_VALID           0x00000001
 #define CSMI_SAS_LOCATE_SAS_LUN_VALID               0x00000002
@@ -927,48 +705,41 @@ typedef struct _IOCTL_HEADER {
 
 /* * * * * * * * SAS Phy Control Class IOCTL Constants * * * * * * * * */
 
-// Return codes for SAS Phy Control IOCTL's
-// (IoctlHeader.ReturnCode)
+/* Return codes for SAS Phy Control IOCTL's  (IoctlHeader.ReturnCode) */
 
-// Signature value
-// (IoctlHeader.Signature)
+/* Signature value  (IoctlHeader.Signature) */
 
 #define CSMI_PHY_SIGNATURE    "CSMIPHY"
 
-// Phy Control Functions
-// (bFunction)
+/* Phy Control Functions  (bFunction) */
 
-// values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL
-// function defined in the SAS spec
+/* values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL
+  function defined in the SAS spec */
 #define CSMI_SAS_PC_NOP                   0x00000000
 #define CSMI_SAS_PC_LINK_RESET            0x00000001
 #define CSMI_SAS_PC_HARD_RESET            0x00000002
 #define CSMI_SAS_PC_PHY_DISABLE           0x00000003
-// 0x04 to 0xFF reserved...
+/* 0x04 to 0xFF reserved... */
 #define CSMI_SAS_PC_GET_PHY_SETTINGS      0x00000100
 
-// Link Flags
+/* Link Flags */
 #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
 #define CSMI_SAS_PHY_UPDATE_SPINUP_RATE   0x00000002
 #define CSMI_SAS_PHY_AUTO_COMWAKE         0x00000004
 
-// Device Types for Phy Settings
-// (bType)
+/* Device Types for Phy Settings  (bType) */
 #define CSMI_SAS_UNDEFINED 0x00
 #define CSMI_SAS_SATA      0x01
 #define CSMI_SAS_SAS       0x02
 
-// Transmitter Flags
-// (uTransmitterFlags)
+/* Transmitter Flags  (uTransmitterFlags) */
 #define CSMI_SAS_PHY_PREEMPHASIS_DISABLED    0x00000001
 
-// Receiver Flags
-// (uReceiverFlags)
+/* Receiver Flags  (uReceiverFlags) */
 #define CSMI_SAS_PHY_EQUALIZATION_DISABLED   0x00000001
 
-// Pattern Flags
-// (uPatternFlags)
-// #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
+/* Pattern Flags  (uPatternFlags) */
+#define CSMI_SAS_PHY_ACTIVATE_CONTROL        0x00000001
 #define CSMI_SAS_PHY_DISABLE_SCRAMBLING      0x00000002
 #define CSMI_SAS_PHY_DISABLE_ALIGN           0x00000004
 #define CSMI_SAS_PHY_DISABLE_SSC             0x00000008
@@ -976,18 +747,16 @@ typedef struct _IOCTL_HEADER {
 #define CSMI_SAS_PHY_FIXED_PATTERN           0x00000010
 #define CSMI_SAS_PHY_USER_PATTERN            0x00000020
 
-// Fixed Patterns
-// (bFixedPattern)
+/* Fixed Patterns  (bFixedPattern) */
 #define CSMI_SAS_PHY_CJPAT                   0x00000001
 #define CSMI_SAS_PHY_ALIGN                   0x00000002
 
-// Type Flags
-// (bTypeFlags)
+/* Type Flags  (bTypeFlags) */
 #define CSMI_SAS_PHY_POSITIVE_DISPARITY      0x01
 #define CSMI_SAS_PHY_NEGATIVE_DISPARITY      0x02
 #define CSMI_SAS_PHY_CONTROL_CHARACTER       0x04
 
-// Miscellaneous
+/* Miscellaneous */
 #define SLOT_NUMBER_UNKNOWN   0xFFFF
 
 /*************************************************************************/
@@ -996,10 +765,9 @@ typedef struct _IOCTL_HEADER {
 
 /* * * * * * * * * * Class Independent Structures * * * * * * * * * */
 
-// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
 #pragma pack(8)
 
-// CC_CSMI_SAS_DRIVER_INFO
+/* CC_CSMI_SAS_DRIVER_INFO */
 
 typedef struct _CSMI_SAS_DRIVER_INFO {
    __u8  szName[81];
@@ -1019,7 +787,7 @@ typedef struct _CSMI_SAS_DRIVER_INFO_BUF
 } CSMI_SAS_DRIVER_INFO_BUFFER,
   *PCSMI_SAS_DRIVER_INFO_BUFFER;
 
-// CC_CSMI_SAS_CNTLR_CONFIGURATION
+/* CC_CSMI_SAS_CNTLR_CONFIGURATION */
 
 typedef struct _CSMI_SAS_PCI_BUS_ADDRESS {
    __u8  bBusNumber;
@@ -1074,7 +842,7 @@ typedef struct _CSMI_SAS_CNTLR_CONFIG_BU
 } CSMI_SAS_CNTLR_CONFIG_BUFFER,
   *PCSMI_SAS_CNTLR_CONFIG_BUFFER;
 
-// CC_CSMI_SAS_CNTLR_STATUS
+/* CC_CSMI_SAS_CNTLR_STATUS */
 
 typedef struct _CSMI_SAS_CNTLR_STATUS {
    __u32 uStatus;
@@ -1089,7 +857,7 @@ typedef struct _CSMI_SAS_CNTLR_STATUS_BU
 } CSMI_SAS_CNTLR_STATUS_BUFFER,
   *PCSMI_SAS_CNTLR_STATUS_BUFFER;
 
-// CC_CSMI_SAS_FIRMWARE_DOWNLOAD
+/* CC_CSMI_SAS_FIRMWARE_DOWNLOAD  */
 
 typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD {
    __u32 uBufferLength;
@@ -1107,7 +875,7 @@ typedef struct _CSMI_SAS_FIRMWARE_DOWNLO
 } CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER,
   *PCSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER;
 
-// CC_CSMI_SAS_RAID_INFO
+/* CC_CSMI_SAS_RAID_INFO */
 
 typedef struct _CSMI_SAS_RAID_INFO {
    __u32 uNumRaidSets;
@@ -1140,7 +908,7 @@ typedef struct _CSMI_SAS_RAID_INFO_BUFFE
 } CSMI_SAS_RAID_INFO_BUFFER,
   *PCSMI_SAS_RAID_INFO_BUFFER;
 
-// CC_CSMI_SAS_GET_RAID_CONFIG
+/* CC_CSMI_SAS_GET_RAID_CONFIG */
 
 typedef struct _CSMI_SAS_RAID_DRIVES {
    __u8  bModel[40];
@@ -1220,7 +988,7 @@ typedef struct _CSMI_SAS_RAID_CONFIG_BUF
 } CSMI_SAS_RAID_CONFIG_BUFFER,
   *PCSMI_SAS_RAID_CONFIG_BUFFER;
 
-// CC_CSMI_SAS_GET_RAID_FEATURES
+/* CC_CSMI_SAS_GET_RAID_FEATURES */
 
 typedef struct _CSMI_SAS_RAID_TYPE_DESCRIPTION {
   __u8  bRaidType;
@@ -1256,7 +1024,7 @@ typedef struct _CSMI_SAS_RAID_FEATURES_B
 } CSMI_SAS_RAID_FEATURES_BUFFER,
   *PCSMI_SAS_RAID_FEATURES_BUFFER;
 
-// CC_CSMI_SAS_SET_RAID_CONTROL
+/* CC_CSMI_SAS_SET_RAID_CONTROL */
 
 typedef struct _CSMI_SAS_RAID_CONTROL {
    __u8  bTransformPriority;
@@ -1279,7 +1047,7 @@ typedef struct _CSMI_SAS_RAID_CONTROL_BU
 } CSMI_SAS_RAID_CONTROL_BUFFER,
   *PCSMI_SAS_RAID_CONTROL_BUFFER;
 
-// CC_CSMI_SAS_GET_RAID_ELEMENT
+/* CC_CSMI_SAS_GET_RAID_ELEMENT */
 
 typedef struct _CSMI_SAS_DRIVE_EXTENT_INFO {
    __u32 uDriveIndex;
@@ -1353,7 +1121,7 @@ typedef struct _CSMI_SAS_RAID_ELEMENT_BU
 } CSMI_SAS_RAID_ELEMENT_BUFFER,
   *PCSMI_SAS_RAID_ELEMENT_BUFFER;
 
-// CC_CSMI_SAS_SET_RAID_OPERATION
+/* CC_CSMI_SAS_SET_RAID_OPERATION */
 
 typedef struct _CSMI_SAS_RAID_SET_LIST {
    __u32 uRaidSetIndex;
@@ -1503,7 +1271,7 @@ typedef struct _CSMI_SAS_RAID_SET_OPERAT
 
 /* * * * * * * * * * SAS HBA Class Structures * * * * * * * * * */
 
-// CC_CSMI_SAS_GET_PHY_INFO
+/* CC_CSMI_SAS_GET_PHY_INFO */
 
 typedef struct _CSMI_SAS_IDENTIFY {
    __u8  bDeviceType;
@@ -1545,7 +1313,7 @@ typedef struct _CSMI_SAS_PHY_INFO_BUFFER
 } CSMI_SAS_PHY_INFO_BUFFER,
   *PCSMI_SAS_PHY_INFO_BUFFER;
 
-// CC_CSMI_SAS_SET_PHY_INFO
+/* CC_CSMI_SAS_SET_PHY_INFO */
 
 typedef struct _CSMI_SAS_SET_PHY_INFO {
    __u8  bPhyIdentifier;
@@ -1563,7 +1331,7 @@ typedef struct _CSMI_SAS_SET_PHY_INFO_BU
 } CSMI_SAS_SET_PHY_INFO_BUFFER,
   *PCSMI_SAS_SET_PHY_INFO_BUFFER;
 
-// CC_CSMI_SAS_GET_LINK_ERRORS
+/* CC_CSMI_SAS_GET_LINK_ERRORS */
 
 typedef struct _CSMI_SAS_LINK_ERRORS {
    __u8  bPhyIdentifier;
@@ -1582,7 +1350,7 @@ typedef struct _CSMI_SAS_LINK_ERRORS_BUF
 } CSMI_SAS_LINK_ERRORS_BUFFER,
   *PCSMI_SAS_LINK_ERRORS_BUFFER;
 
-// CC_CSMI_SAS_SMP_PASSTHRU
+/* CC_CSMI_SAS_SMP_PASSTHRU */
 
 typedef struct _CSMI_SAS_SMP_REQUEST {
    __u8  bFrameType;
@@ -1622,7 +1390,7 @@ typedef struct _CSMI_SAS_SMP_PASSTHRU_BU
 } CSMI_SAS_SMP_PASSTHRU_BUFFER,
   *PCSMI_SAS_SMP_PASSTHRU_BUFFER;
 
-// CC_CSMI_SAS_SSP_PASSTHRU
+/* CC_CSMI_SAS_SSP_PASSTHRU */
 
 typedef struct _CSMI_SAS_SSP_PASSTHRU {
    __u8  bPhyIdentifier;
@@ -1661,7 +1429,7 @@ typedef struct _CSMI_SAS_SSP_PASSTHRU_BU
 } CSMI_SAS_SSP_PASSTHRU_BUFFER,
   *PCSMI_SAS_SSP_PASSTHRU_BUFFER;
 
-// CC_CSMI_SAS_STP_PASSTHRU
+/* CC_CSMI_SAS_STP_PASSTHRU */
 
 typedef struct _CSMI_SAS_STP_PASSTHRU {
    __u8  bPhyIdentifier;
@@ -1693,7 +1461,7 @@ typedef struct _CSMI_SAS_STP_PASSTHRU_BU
 } CSMI_SAS_STP_PASSTHRU_BUFFER,
   *PCSMI_SAS_STP_PASSTHRU_BUFFER;
 
-// CC_CSMI_SAS_GET_SATA_SIGNATURE
+/* CC_CSMI_SAS_GET_SATA_SIGNATURE */
 
 typedef struct _CSMI_SAS_SATA_SIGNATURE {
    __u8  bPhyIdentifier;
@@ -1708,7 +1476,7 @@ typedef struct _CSMI_SAS_SATA_SIGNATURE_
 } CSMI_SAS_SATA_SIGNATURE_BUFFER,
   *PCSMI_SAS_SATA_SIGNATURE_BUFFER;
 
-// CC_CSMI_SAS_GET_SCSI_ADDRESS
+/* CC_CSMI_SAS_GET_SCSI_ADDRESS */
 
 typedef struct _CSMI_SAS_GET_SCSI_ADDRESS_BUFFER {
    IOCTL_HEADER IoctlHeader;
@@ -1721,7 +1489,7 @@ typedef struct _CSMI_SAS_GET_SCSI_ADDRES
 } CSMI_SAS_GET_SCSI_ADDRESS_BUFFER,
    *PCSMI_SAS_GET_SCSI_ADDRESS_BUFFER;
 
-// CC_CSMI_SAS_GET_DEVICE_ADDRESS
+/* CC_CSMI_SAS_GET_DEVICE_ADDRESS */
 
 typedef struct _CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER {
    IOCTL_HEADER IoctlHeader;
@@ -1734,7 +1502,7 @@ typedef struct _CSMI_SAS_GET_DEVICE_ADDR
 } CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER,
   *PCSMI_SAS_GET_DEVICE_ADDRESS_BUFFER;
 
-// CC_CSMI_SAS_TASK_MANAGEMENT
+/* CC_CSMI_SAS_TASK_MANAGEMENT */
 
 typedef struct _CSMI_SAS_SSP_TASK_IU {
    __u8  bHostIndex;
@@ -1757,7 +1525,7 @@ typedef struct _CSMI_SAS_SSP_TASK_IU_BUF
 } CSMI_SAS_SSP_TASK_IU_BUFFER,
   *PCSMI_SAS_SSP_TASK_IU_BUFFER;
 
-// CC_CSMI_SAS_GET_CONNECTOR_INFO
+/* CC_CSMI_SAS_GET_CONNECTOR_INFO */
 
 typedef struct _CSMI_SAS_GET_CONNECTOR_INFO {
    __u32 uPinout;
@@ -1773,7 +1541,7 @@ typedef struct _CSMI_SAS_CONNECTOR_INFO_
 } CSMI_SAS_CONNECTOR_INFO_BUFFER,
   *PCSMI_SAS_CONNECTOR_INFO_BUFFER;
 
-// CC_CSMI_SAS_GET_LOCATION
+/* CC_CSMI_SAS_GET_LOCATION */
 
 typedef struct _CSMI_SAS_LOCATION_IDENTIFIER {
    __u32 bLocationFlags;
@@ -1801,7 +1569,7 @@ typedef struct _CSMI_SAS_GET_LOCATION_BU
 } CSMI_SAS_GET_LOCATION_BUFFER,
   *PCSMI_SAS_GET_LOCATION_BUFFER;
 
-// CC_CSMI_SAS_PHY_CONTROL
+/* CC_CSMI_SAS_PHY_CONTROL */
 
 typedef struct _CSMI_SAS_CHARACTER {
    __u8  bTypeFlags;
@@ -1848,7 +1616,6 @@ typedef struct _CSMI_SAS_PHY_CONTROL_BUF
 } CSMI_SAS_PHY_CONTROL_BUFFER,
   *PCSMI_SAS_PHY_CONTROL_BUFFER;
 
-//EDM #pragma CSMI_SAS_END_PACK
 #pragma pack()
 
 #endif // _CSMI_SAS_H_
Index: linux-2.6.27/drivers/message/fusion/lsi/mpi_cnfg.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/lsi/mpi_cnfg.h
+++ linux-2.6.27/drivers/message/fusion/lsi/mpi_cnfg.h
@@ -1452,8 +1452,7 @@ typedef struct _CONFIG_PAGE_BIOS_2
 #define MPI_BIOSPAGE2_FORM_SAS_WWN                      (0x05)
 #define MPI_BIOSPAGE2_FORM_ENCLOSURE_SLOT               (0x06)
 
-typedef struct _CONFIG_PAGE_BIOS_4
-{
+typedef struct _CONFIG_PAGE_BIOS_4 {
     CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     ReassignmentBaseWWID;       /* 04h */
 } CONFIG_PAGE_BIOS_4, MPI_POINTER PTR_CONFIG_PAGE_BIOS_4,
Index: linux-2.6.27/drivers/message/fusion/lsi/mpi_log_sas.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/lsi/mpi_log_sas.h
+++ linux-2.6.27/drivers/message/fusion/lsi/mpi_log_sas.h
@@ -160,11 +160,12 @@
 
 
 #define PL_LOGINFO_SUB_CODE_INVALID_SGL                      (0x00000200)
+
 #define PL_LOGINFO_SUB_CODE_WRONG_REL_OFF_OR_FRAME_LENGTH    (0x00000300)
-#define PL_LOGINFO_SUB_CODE_FRAME_XFER_ERROR                 (0x00000400) /* Bits 0-3 encode Transport Status Register (offset 0x08) */
-                                                                          /* Bit 0 is Status Bit 0: FrameXferErr */
-                                                                          /* Bit 1 & 2 are Status Bits 16 and 17: FrameXmitErrStatus */
-                                                                          /* Bit 3 is Status Bit 18 WriteDataLenghtGTDataLengthErr */
+/* Bits 0-3 encode Transport Status Register (offset 0x08) */
+/* Bit 0 is Status Bit 0: FrameXferErr */
+/* Bit 1 & 2 are Status Bits 16 and 17: FrameXmitErrStatus */
+/* Bit 3 is Status Bit 18 WriteDataLenghtGTDataLengthErr */
 
 #define PL_LOGINFO_SUB_CODE_TX_FM_CONNECTED_LOW              (0x00000500)
 #define PL_LOGINFO_SUB_CODE_SATA_NON_NCQ_RW_ERR_BIT_SET      (0x00000600)
@@ -179,7 +180,7 @@
 #define PL_LOGINFO_SUB_CODE_DISCOVERY_REMOTE_SEP_RESET       (0x00000E01)
 #define PL_LOGINFO_SUB_CODE_SECOND_OPEN                      (0x00000F00)
 #define PL_LOGINFO_SUB_CODE_DSCVRY_SATA_INIT_TIMEOUT         (0x00001000)
-#define PL_LOGINFO_SUB_CODE_BREAK_ON_SATA_CONNECTION  		 (0x00002000) /* not currently used in mainline */
+#define PL_LOGINFO_SUB_CODE_BREAK_ON_SATA_CONNECTION  		 (0x00002000)
 #define PL_LOGINFO_SUB_CODE_BREAK_ON_STUCK_LINK              (0x00003000)
 #define PL_LOGINFO_SUB_CODE_BREAK_ON_STUCK_LINK_AIP          (0x00004000)
 #define PL_LOGINFO_SUB_CODE_BREAK_ON_INCOMPLETE_BREAK_RCVD   (0x00005000)
@@ -308,7 +309,6 @@
 /* Device Firmware Update: Unable to allocate memory for page */
 #define IR_LOGINFO_DEV_FW_UPDATE_ERR_ALLOC_CFG_PAGE             (0x00010056)
 /* Device Firmware Update:  */
-//#define IR_LOGINFO_DEV_FW_UPDATE_ERR_                         (0x00010054)
 
 
 /****************************************************************************/
Index: linux-2.6.27/drivers/message/fusion/lsi/mpi_type.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/lsi/mpi_type.h
+++ linux-2.6.27/drivers/message/fusion/lsi/mpi_type.h
@@ -50,18 +50,8 @@ typedef signed   short  S16;
 typedef unsigned short  U16;
 
 
-#if defined(unix) || defined(__arm) || defined(ALPHA) || defined(__PPC__) || defined(__ppc)
-
-    typedef signed   int   S32;
-    typedef unsigned int   U32;
-
-#else
-
-    typedef signed   long  S32;
-    typedef unsigned long  U32;
-
-#endif
-
+typedef int32_t   S32;
+typedef u_int32_t U32;
 
 typedef struct _S64
 {
Index: linux-2.6.27/drivers/message/fusion/mptbase.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptbase.c
+++ linux-2.6.27/drivers/message/fusion/mptbase.c
@@ -83,15 +83,18 @@ MODULE_VERSION(my_VERSION);
 
 static int mpt_msi_enable_spi;
 module_param(mpt_msi_enable_spi, int, 0);
-MODULE_PARM_DESC(mpt_msi_enable_spi, " Enable MSI Support for SPI controllers (default=0)");
+MODULE_PARM_DESC(mpt_msi_enable_spi,
+    " Enable MSI Support for SPI controllers (default=0)");
 
 static int mpt_msi_enable_fc;
 module_param(mpt_msi_enable_fc, int, 0);
-MODULE_PARM_DESC(mpt_msi_enable_fc, " Enable MSI Support for FC controllers (default=0)");
+MODULE_PARM_DESC(mpt_msi_enable_fc,
+    " Enable MSI Support for FC controllers (default=0)");
 
 static int mpt_msi_enable_sas = 1;
 module_param(mpt_msi_enable_sas, int, 0);
-MODULE_PARM_DESC(mpt_msi_enable_sas, " Enable MSI Support for SAS controllers (default=1)");
+MODULE_PARM_DESC(mpt_msi_enable_sas,
+    " Enable MSI Support for SAS controllers (default=1)");
 
 
 static int mpt_channel_mapping;
@@ -99,18 +102,20 @@ module_param(mpt_channel_mapping, int, 0
 MODULE_PARM_DESC(mpt_channel_mapping, " Mapping id's to channels (default=0)");
 
 int mpt_debug_level;
+EXPORT_SYMBOL(mpt_debug_level);
+
 static int mpt_set_debug_level(const char *val, struct kernel_param *kp);
 module_param_call(mpt_debug_level, mpt_set_debug_level, param_get_int,
 		  &mpt_debug_level, 0600);
-MODULE_PARM_DESC(mpt_debug_level, " debug level - refer to mptdebug.h - (default=0)");
-EXPORT_SYMBOL(mpt_debug_level);
+MODULE_PARM_DESC(mpt_debug_level,
+    " debug level - refer to mptdebug.h - (default=0)");
 
 int mpt_fwfault_debug;
+EXPORT_SYMBOL(mpt_fwfault_debug);
 module_param_call(mpt_fwfault_debug, param_set_int, param_get_int,
 		  &mpt_fwfault_debug, 0600);
 MODULE_PARM_DESC(mpt_fwfault_debug, "Enable detection of Firmware fault"
 		" and halt Firmware on fault - (default=0)");
-EXPORT_SYMBOL(mpt_fwfault_debug);
 
 
 #ifdef MFCNT
@@ -122,7 +127,7 @@ static int mfcounter = 0;
 /*
  *  Public data...
  */
-struct proc_dir_entry *mpt_proc_root_dir;
+static struct proc_dir_entry *mpt_proc_root_dir;
 
 #define WHOINIT_UNKNOWN		0xAA
 
@@ -156,7 +161,8 @@ static u8 last_drv_idx;
 /*
  *  Forward protos...
  */
-static int	mptbase_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
+static int	mptbase_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,
+    MPT_FRAME_HDR *reply);
 static int	mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes,
 			u32 *req, int replyBytes, u16 *u16reply, int maxwait,
 			int sleepFlag);
@@ -188,7 +194,8 @@ static int	mpt_readScsiDevicePageHeaders
 static void 	mpt_read_ioc_pg_1(MPT_ADAPTER *ioc);
 static void 	mpt_read_ioc_pg_4(MPT_ADAPTER *ioc);
 static void	mpt_get_manufacturing_pg_0(MPT_ADAPTER *ioc);
-static int	SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch, int sleepFlag);
+static int	SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch,
+    int sleepFlag);
 static int	SendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp);
 static int	mpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag);
 static int	mpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init);
@@ -353,10 +360,10 @@ mpt_fault_reset_work(struct work_struct 
 		printk(MYIOC_s_WARN_FMT "IOC is in FAULT state (%04xh)!!!\n",
 		    ioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);
 		printk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",
-		    ioc->name, __FUNCTION__);
+		    ioc->name, __func__);
 		rc = mpt_HardResetHandler(ioc, CAN_SLEEP);
 		printk(MYIOC_s_WARN_FMT "%s: HardReset: %s\n", ioc->name,
-		    __FUNCTION__, (rc == 0) ? "success" : "failed");
+		    __func__, (rc == 0) ? "success" : "failed");
 		ioc_raw_state = mpt_GetIocState(ioc, 0);
 		if ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT)
 			printk(MYIOC_s_WARN_FMT "IOC is in FAULT state after "
@@ -378,11 +385,11 @@ mpt_fault_reset_work(struct work_struct 
 		ioc = ioc->alt_ioc;
 
 	/* rearm the timer */
-	spin_lock_irqsave(&ioc->taskmgmt_lock, flags);
+	spin_lock_irqsave(&ioc->fault_reset_work_lock, flags);
 	if (ioc->reset_work_q)
 		queue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,
 			msecs_to_jiffies(MPT_POLLING_INTERVAL));
-	spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
+	spin_unlock_irqrestore(&ioc->fault_reset_work_lock, flags);
 }
 
 /*
@@ -439,7 +446,7 @@ mpt_turbo_reply(MPT_ADAPTER *ioc, u32 pa
 	if (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||
 	    MptCallbacks[cb_idx] == NULL) {
 		printk(MYIOC_s_WARN_FMT "%s: Invalid cb_idx (%d)!\n",
-				__FUNCTION__, ioc->name, cb_idx);
+				__func__, ioc->name, cb_idx);
 		goto out;
 	}
 
@@ -497,9 +504,6 @@ mpt_reply(MPT_ADAPTER *ioc, u32 pa)
 			mpt_sas_log_info(ioc, log_info);
 	}
 
-	/* TODO - add shost_attrs, or command line option, and
-	 * extend this to SAS/FC
-	 */
 	if (ioc_stat & MPI_IOCSTATUS_MASK)
 		mpt_iocstatus_info(ioc, (u32)ioc_stat, mf);
 
@@ -507,7 +511,7 @@ mpt_reply(MPT_ADAPTER *ioc, u32 pa)
 	if (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||
 	    MptCallbacks[cb_idx] == NULL) {
 		printk(MYIOC_s_WARN_FMT "%s: Invalid cb_idx (%d)!\n",
-				__FUNCTION__, ioc->name, cb_idx);
+				__func__, ioc->name, cb_idx);
 		freeme = 0;
 		goto out;
 	}
@@ -523,11 +527,11 @@ mpt_reply(MPT_ADAPTER *ioc, u32 pa)
 	mb();
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_interrupt - MPT adapter (IOC) specific interrupt handler.
  *	@irq: irq number (not used)
  *	@bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure
- *	@r: pt_regs pointer (not used)
  *
  *	This routine is registered via the request_irq() kernel API call,
  *	and handles all interrupts generated from a specific MPT adapter
@@ -539,7 +543,7 @@ mpt_reply(MPT_ADAPTER *ioc, u32 pa)
  *	This routine handles register-level access of the adapter but
  *	dispatches (calls) a protocol-specific callback routine to handle
  *	the protocol-specific details of the MPT request completion.
- **/
+ */
 static irqreturn_t
 mpt_interrupt(int irq, void *bus_id)
 {
@@ -630,6 +634,7 @@ mptbase_reply(MPT_ADAPTER *ioc, MPT_FRAM
 	return freereq;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_register - Register protocol-specific main callback handler.
  *	@cbfunc: callback function pointer
@@ -648,7 +653,7 @@ mptbase_reply(MPT_ADAPTER *ioc, MPT_FRAM
  *	{N,...,7,6,5,...,1} if successful.
  *	A return value of MPT_MAX_PROTOCOL_DRIVERS (including zero!) should be
  *	considered an error by the caller.
- **/
+ */
 u8
 mpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass)
 {
@@ -672,13 +677,14 @@ mpt_register(MPT_CALLBACK cbfunc, MPT_DR
 	return last_drv_idx;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_deregister - Deregister a protocol drivers resources.
  *	@cb_idx: previously registered callback handle
  *
  *	Each protocol-specific driver should call this routine when its
  *	module is unloaded.
- **/
+ */
 void
 mpt_deregister(u8 cb_idx)
 {
@@ -691,9 +697,9 @@ mpt_deregister(u8 cb_idx)
 	}
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_event_register - Register protocol-specific event callback
- *	handler.
+ *	mpt_event_register - Register protocol-specific event callback handler.
  *	@cb_idx: previously registered (via mpt_register) callback handle
  *	@ev_cbfunc: callback function
  *
@@ -701,7 +707,7 @@ mpt_deregister(u8 cb_idx)
  *	if/when they choose to be notified of MPT events.
  *
  *	Returns 0 for success.
- **/
+ */
 int
 mpt_event_register(u8 cb_idx, MPT_EVHANDLER ev_cbfunc)
 {
@@ -712,15 +718,15 @@ mpt_event_register(u8 cb_idx, MPT_EVHAND
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_event_deregister - Deregister protocol-specific event callback
- *	handler.
+ *	mpt_event_deregister - Deregister protocol-specific event callback handler.
  *	@cb_idx: previously registered callback handle
  *
  *	Each protocol-specific driver should call this routine
  *	when it does not (or can no longer) handle events,
  *	or when its module is unloaded.
- **/
+ */
 void
 mpt_event_deregister(u8 cb_idx)
 {
@@ -730,6 +736,7 @@ mpt_event_deregister(u8 cb_idx)
 	MptEvHandlers[cb_idx] = NULL;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_reset_register - Register protocol-specific IOC reset handler.
  *	@cb_idx: previously registered (via mpt_register) callback handle
@@ -739,7 +746,7 @@ mpt_event_deregister(u8 cb_idx)
  *	if/when they choose to be notified of IOC resets.
  *
  *	Returns 0 for success.
- **/
+ */
 int
 mpt_reset_register(u8 cb_idx, MPT_RESETHANDLER reset_func)
 {
@@ -750,6 +757,7 @@ mpt_reset_register(u8 cb_idx, MPT_RESETH
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_reset_deregister - Deregister protocol-specific IOC reset handler.
  *	@cb_idx: previously registered callback handle
@@ -757,7 +765,7 @@ mpt_reset_register(u8 cb_idx, MPT_RESETH
  *	Each protocol-specific driver should call this routine
  *	when it does not (or can no longer) handle IOC reset handling,
  *	or when its module is unloaded.
- **/
+ */
 void
 mpt_reset_deregister(u8 cb_idx)
 {
@@ -767,11 +775,12 @@ mpt_reset_deregister(u8 cb_idx)
 	MptResetHandlers[cb_idx] = NULL;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_device_driver_register - Register device driver hooks
  *	@dd_cbfunc: driver callbacks struct
  *	@cb_idx: MPT protocol driver index
- **/
+ */
 int
 mpt_device_driver_register(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx)
 {
@@ -785,8 +794,6 @@ mpt_device_driver_register(struct mpt_pc
 
 	/* call per pci device probe entry point */
 	list_for_each_entry(ioc, &ioc_list, list) {
-		if (!pci_get_drvdata(ioc->pcidev))
-			continue;
 		id = ioc->pcidev->driver ?
 		    ioc->pcidev->driver->id_table : NULL;
 		if (dd_cbfunc->probe)
@@ -796,10 +803,11 @@ mpt_device_driver_register(struct mpt_pc
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_device_driver_deregister - DeRegister device driver hooks
  *	@cb_idx: MPT protocol driver index
- **/
+ */
 void
 mpt_device_driver_deregister(u8 cb_idx)
 {
@@ -819,15 +827,18 @@ mpt_device_driver_deregister(u8 cb_idx)
 	MptDeviceDriverHandlers[cb_idx] = NULL;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_get_msg_frame - Obtain a MPT request frame from the pool (of 1024)
- *	allocated per MPT adapter.
+ *	mpt_get_msg_frame - Obtain an MPT request frame from the pool
  *	@cb_idx: Handle of registered MPT protocol driver
  *	@ioc: Pointer to MPT adapter structure
  *
+ *	Obtain an MPT request frame from the pool (of 1024) that are
+ *	allocated per MPT adapter.
+ *
  *	Returns pointer to a MPT request frame or %NULL if none are available
  *	or IOC is not active.
- **/
+ */
 MPT_FRAME_HDR*
 mpt_get_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc)
 {
@@ -886,16 +897,16 @@ mpt_get_msg_frame(u8 cb_idx, MPT_ADAPTER
 	return mf;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_put_msg_frame - Send a protocol specific MPT request frame
- *	to a IOC.
+ *	mpt_put_msg_frame - Send a protocol-specific MPT request frame to an IOC
  *	@cb_idx: Handle of registered MPT protocol driver
  *	@ioc: Pointer to MPT adapter structure
  *	@mf: Pointer to MPT request frame
  *
- *	This routine posts a MPT request frame to the request post FIFO of a
+ *	This routine posts an MPT request frame to the request post FIFO of a
  *	specific MPT adapter.
- **/
+ */
 void
 mpt_put_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)
 {
@@ -921,13 +932,15 @@ mpt_put_msg_frame(u8 cb_idx, MPT_ADAPTER
 }
 
 /**
- *	mpt_put_msg_frame_hi_pri - Send a protocol specific MPT request frame
- *	to a IOC using hi priority request queue.
+ *	mpt_put_msg_frame_hi_pri - Send a hi-pri protocol-specific MPT request frame
  *	@cb_idx: Handle of registered MPT protocol driver
  *	@ioc: Pointer to MPT adapter structure
  *	@mf: Pointer to MPT request frame
  *
- *	This routine posts a MPT request frame to the request post FIFO of a
+ *	Send a protocol-specific MPT request frame to an IOC using
+ *	hi-priority request queue.
+ *
+ *	This routine posts an MPT request frame to the request post FIFO of a
  *	specific MPT adapter.
  **/
 void
@@ -952,6 +965,7 @@ mpt_put_msg_frame_hi_pri(u8 cb_idx, MPT_
 	CHIPREG_WRITE32(&ioc->chip->RequestHiPriFifo, mf_dma_addr);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_free_msg_frame - Place MPT request frame back on FreeQ.
  *	@handle: Handle of registered MPT protocol driver
@@ -960,7 +974,7 @@ mpt_put_msg_frame_hi_pri(u8 cb_idx, MPT_
  *
  *	This routine places a MPT request frame back on the MPT adapter's
  *	FreeQ.
- **/
+ */
 void
 mpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)
 {
@@ -970,7 +984,8 @@ mpt_free_msg_frame(MPT_ADAPTER *ioc, MPT
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
 	if (cpu_to_le32(mf->u.frame.linkage.arg1) == 0xdeadbeaf)
 		goto out;
-	mf->u.frame.linkage.arg1 = cpu_to_le32(0xdeadbeaf); /* signature to know if this mf is freed */
+	/* signature to know if this mf is freed */
+	mf->u.frame.linkage.arg1 = cpu_to_le32(0xdeadbeaf);
 	list_add_tail(&mf->u.frame.linkage.list, &ioc->FreeQ);
 #ifdef MFCNT
 	ioc->mfcnt--;
@@ -1122,7 +1137,7 @@ mpt_add_chain_64bit(char *pAddr, u8 next
  *	request which are greater than 1 byte in size.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 int
 mpt_send_handshake_request(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)
 {
@@ -1199,6 +1214,7 @@ mpt_send_handshake_request(u8 cb_idx, MP
 	return r;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  * mpt_host_page_access_control - control the IOC's Host Page Buffer access
  * @ioc: Pointer to MPT adapter structure
@@ -1215,7 +1231,7 @@ mpt_send_handshake_request(u8 cb_idx, MP
  * 3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }
  *
  * Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 mpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag)
 {
@@ -1240,6 +1256,7 @@ mpt_host_page_access_control(MPT_ADAPTER
 		return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_host_page_alloc - allocate system memory for the fw
  *	@ioc: Pointer to pointer to IOC adapter
@@ -1247,7 +1264,7 @@ mpt_host_page_access_control(MPT_ADAPTER
  *
  *	If we already allocated memory in past, then resend the same pointer.
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 mpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init)
 {
@@ -1305,6 +1322,7 @@ mpt_host_page_alloc(MPT_ADAPTER *ioc, pI
 return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_verify_adapter - Given IOC identifier, set pointer to its adapter structure.
  *	@iocid: IOC unique identifier (integer)
@@ -1315,7 +1333,7 @@ return 0;
  *
  *	Returns iocid and sets iocpp if iocid is found.
  *	Returns -1 if iocid is not found.
- **/
+ */
 int
 mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp)
 {
@@ -1604,7 +1622,8 @@ mpt_mapresources(MPT_ADAPTER *ioc)
 		return r;
 	}
 	if (sizeof(dma_addr_t) > 4) {
-		const uint64_t required_mask = dma_get_required_mask(&pdev->dev);
+		uint64_t required_mask;
+		required_mask = dma_get_required_mask(&pdev->dev);
 		if (required_mask > DMA_32BIT_MASK
 		    && !pci_set_dma_mask(pdev, DMA_64BIT_MASK)
 		    && !pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK)) {
@@ -1674,15 +1693,13 @@ mpt_mapresources(MPT_ADAPTER *ioc)
 	ioc->chip = (SYSIF_REGS __iomem *)mem;
 
 	/* Save Port IO values in case we need to do downloadboot */
-	{
-		u8 *pmem = (u8*)port;
-		ioc->pio_mem_phys = port;
-		ioc->pio_chip = (SYSIF_REGS __iomem *)pmem;
-	}
+	ioc->pio_mem_phys = port;
+	ioc->pio_chip = (SYSIF_REGS __iomem *)port;
 
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_attach - Install a PCI intelligent MPT adapter.
  *	@pdev: Pointer to pci_dev structure
@@ -1698,8 +1715,7 @@ mpt_mapresources(MPT_ADAPTER *ioc)
  *
  *	Returns 0 for success, non-zero for failure.
  *
- *	TODO: Add support for polled controllers
- **/
+ */
 int
 mpt_attach(struct pci_dev *pdev, const struct pci_device_id *id)
 {
@@ -1795,6 +1811,7 @@ mpt_attach(struct pci_dev *pdev, const s
 
 	/* Initialize work */
 	INIT_DELAYED_WORK(&ioc->fault_reset_work, mpt_fault_reset_work);
+	spin_lock_init(&ioc->fault_reset_work_lock);
 
 	/* Initialize workqueue */
 	snprintf(ioc->reset_work_q_name, sizeof(ioc->reset_work_q_name),
@@ -1809,7 +1826,8 @@ mpt_attach(struct pci_dev *pdev, const s
 		return -ENOMEM;
 	}
 
-	dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "facts @ %p, pfacts[0] @ %p\n",
+	dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "facts @ %p,"
+		" pfacts[0] @ %p\n",
 		ioc->name, &ioc->facts, &ioc->pfacts[0]));
 
 	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
@@ -1911,6 +1929,9 @@ mpt_attach(struct pci_dev *pdev, const s
 	ioc->active = 0;
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
+	/* Set IOC ptr in the pcidev's driver data. */
+	pci_set_drvdata(ioc->pcidev, ioc);
+
 	/* Set lookup ptr. */
 	list_add_tail(&ioc->list, &ioc_list);
 
@@ -1979,10 +2000,11 @@ mpt_attach(struct pci_dev *pdev, const s
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_detach - Remove a PCI intelligent MPT adapter.
  *	@pdev: Pointer to pci_dev structure
- **/
+ */
 void
 mpt_detach(struct pci_dev *pdev)
 {
@@ -1995,10 +2017,10 @@ mpt_detach(struct pci_dev *pdev)
 	/*
 	 * Stop polling ioc for fault condition
 	 */
-	spin_lock_irqsave(&ioc->taskmgmt_lock, flags);
+	spin_lock_irqsave(&ioc->fault_reset_work_lock, flags);
 	wq = ioc->reset_work_q;
 	ioc->reset_work_q = NULL;
-	spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
+	spin_unlock_irqrestore(&ioc->fault_reset_work_lock, flags);
 	cancel_delayed_work(&ioc->fault_reset_work);
 	destroy_workqueue(wq);
 
@@ -2030,11 +2052,12 @@ mpt_detach(struct pci_dev *pdev)
  * Power Management
  */
 #ifdef CONFIG_PM
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_suspend - Fusion MPT base driver suspend routine.
  *	@pdev: Pointer to pci_dev structure
  *	@state: new state to enter
- **/
+ */
 int
 mpt_suspend(struct pci_dev *pdev, pm_message_t state)
 {
@@ -2069,10 +2092,11 @@ mpt_suspend(struct pci_dev *pdev, pm_mes
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_resume - Fusion MPT base driver resume routine.
  *	@pdev: Pointer to pci_dev structure
- **/
+ */
 int
 mpt_resume(struct pci_dev *pdev)
 {
@@ -2132,7 +2156,9 @@ mpt_resume(struct pci_dev *pdev)
 
 	/* bring ioc to operational state */
 	printk(MYIOC_s_INFO_FMT "Sending mpt_do_ioc_recovery\n", ioc->name);
-	if ((recovery_state = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP, CAN_SLEEP)) != 0)
+	recovery_state = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP,
+						CAN_SLEEP);
+	if (recovery_state != 0)
 		printk(MYIOC_s_WARN_FMT "pci-resume: Cannot recover, "
 		    "error:[%x]\n", ioc->name, recovery_state);
 	else
@@ -2158,6 +2184,7 @@ mpt_signal_reset(u8 index, MPT_ADAPTER *
 	return (MptResetHandlers[index])(ioc, reset_phase);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_do_ioc_recovery - Initialize or recover MPT adapter.
  *	@ioc: Pointer to MPT adapter structure
@@ -2176,7 +2203,9 @@ mpt_signal_reset(u8 index, MPT_ADAPTER *
  *		-2 if READY but IOCFacts Failed
  *		-3 if READY but PrimeIOCFifos Failed
  *		-4 if READY but IOCInit Failed
- **/
+ *		-5 if failed to enable_device and/or request_selected_regions
+ *		-6 if failed to upload firmware
+ */
 static int
 mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag)
 {
@@ -2217,14 +2246,16 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 
 			if (reset_alt_ioc_active && ioc->alt_ioc) {
 				/* (re)Enable alt-IOC! (reply interrupt, FreeQ) */
-				dprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": alt-ioc reply irq re-enabled\n",
+				dprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+					": alt-ioc reply irq re-enabled\n",
 				    ioc->alt_ioc->name));
 				CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);
 				ioc->alt_ioc->active = 1;
 			}
 
 		} else {
-			printk(MYIOC_s_WARN_FMT "NOT READY WARNING!\n", ioc->name);
+			printk(MYIOC_s_WARN_FMT "NOT READY WARNING!\n",
+			    ioc->name);
 		}
 		ret = -1;
 		goto out;
@@ -2238,7 +2269,8 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 			alt_ioc_ready = 1;
 		else
 			printk(MYIOC_s_WARN_FMT
-			    ": alt-ioc Not ready WARNING!\n", ioc->alt_ioc->name);
+			    ": alt-ioc Not ready WARNING!\n",
+			    ioc->alt_ioc->name);
 	}
 
 	for (ii=0; ii<5; ii++) {
@@ -2340,8 +2372,9 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 		ret = -4;
 // NEW!
 	if (alt_ioc_ready && ((rc = PrimeIocFifos(ioc->alt_ioc)) != 0)) {
-		printk(MYIOC_s_WARN_FMT ": alt-ioc (%d) FIFO mgmt alloc WARNING!\n",
-				ioc->alt_ioc->name, rc);
+		printk(MYIOC_s_WARN_FMT
+		    ": alt-ioc (%d) FIFO mgmt alloc WARNING!\n",
+		    ioc->alt_ioc->name, rc);
 		alt_ioc_ready = 0;
 		reset_alt_ioc_active = 0;
 	}
@@ -2382,7 +2415,7 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 				} else {
 					printk(MYIOC_s_WARN_FMT
 					    "firmware upload failure!\n", ioc->name);
-					ret = -5;
+					ret = -6;
 				}
 			}
 		}
@@ -2392,8 +2425,8 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 	 *  and EventAck handling.
 	 */
 	if ((ret == 0) && (!ioc->facts.EventState)) {
-		dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "SendEventNotification\n",
-		    ioc->name));
+		dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+			"SendEventNotification\n", ioc->name));
 		ret = SendEventNotification(ioc, 1, sleepFlag);	/* 1=Enable */
 	}
 
@@ -2408,9 +2441,11 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 	if (rc == 0) {	/* alt ioc */
 		if (reset_alt_ioc_active && ioc->alt_ioc) {
 			/* (re)Enable alt-IOC! (reply interrupt) */
-			dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "alt-ioc reply irq re-enabled\n",
+			dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+				"alt-ioc reply irq re-enabled\n",
 				ioc->alt_ioc->name));
-			CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);
+			CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,
+			    MPI_HIM_DIM);
 			ioc->alt_ioc->active = 1;
 		}
 	}
@@ -2427,7 +2462,7 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 		/*
 		 * Initalize link list for inactive raid volumes.
 		 */
-		init_MUTEX(&ioc->raid_data.inactive_list_mutex);
+		mutex_init(&ioc->raid_data.inactive_list_mutex);
 		INIT_LIST_HEAD(&ioc->raid_data.inactive_list);
 
 		switch (ioc->bus_type) {
@@ -2461,7 +2496,8 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 				 *  (LANPage1_t stuff)
 				 */
 				(void) GetLanConfigPages(ioc);
-				a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
+				a = (u8 *)
+				    &ioc->lan_cnfg_page1.HardwareAddressLow;
 				dprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 					"LanAddr = %02X:%02X:%02X"
 					":%02X:%02X:%02X\n",
@@ -2507,6 +2543,7 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 	return ret;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_detect_bound_ports - Search for matching PCI bus/dev_function
  *	@ioc: Pointer to MPT adapter structure
@@ -2518,7 +2555,7 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
  *
  *	If match on PCI dev_function +/-1 is found, bind the two MPT adapters
  *	using alt_ioc pointer fields in their %MPT_ADAPTER structures.
- **/
+ */
 static void
 mpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
 {
@@ -2544,15 +2581,19 @@ mpt_detect_bound_ports(MPT_ADAPTER *ioc,
 		if (_pcidev == peer) {
 			/* Paranoia checks */
 			if (ioc->alt_ioc != NULL) {
-				printk(MYIOC_s_WARN_FMT "Oops, already bound (%s <==> %s)!\n",
-					ioc->name, ioc->name, ioc->alt_ioc->name);
+				printk(MYIOC_s_WARN_FMT
+				    "Oops, already bound (%s <==> %s)!\n",
+				    ioc->name, ioc->name, ioc->alt_ioc->name);
 				break;
 			} else if (ioc_srch->alt_ioc != NULL) {
-				printk(MYIOC_s_WARN_FMT "Oops, already bound (%s <==> %s)!\n",
-					ioc_srch->name, ioc_srch->name, ioc_srch->alt_ioc->name);
+				printk(MYIOC_s_WARN_FMT
+				    "Oops, already bound (%s <==> %s)!\n",
+				    ioc_srch->name, ioc_srch->name,
+				    ioc_srch->alt_ioc->name);
 				break;
 			}
-			dprintk(ioc, printk(MYIOC_s_DEBUG_FMT "FOUND! binding %s <==> %s\n",
+			dprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+				"FOUND! binding %s <==> %s\n",
 				ioc->name, ioc->name, ioc_srch->name));
 			ioc_srch->alt_ioc = ioc;
 			ioc->alt_ioc = ioc_srch;
@@ -2561,10 +2602,11 @@ mpt_detect_bound_ports(MPT_ADAPTER *ioc,
 	pci_dev_put(peer);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_adapter_disable - Disable misbehaving MPT adapter.
  *	@ioc: Pointer to MPT adapter structure
- **/
+ */
 static void
 mpt_adapter_disable(MPT_ADAPTER *ioc)
 {
@@ -2577,7 +2619,8 @@ mpt_adapter_disable(MPT_ADAPTER *ioc)
 		if ((ret = mpt_downloadboot(ioc, (MpiFwHeader_t *)
 		    ioc->cached_fw, CAN_SLEEP)) < 0) {
 			printk(MYIOC_s_WARN_FMT
-			    ": firmware downloadboot failure (%d)!\n", ioc->name, ret);
+			    ": firmware downloadboot failure (%d)!\n",
+			    ioc->name, ret);
 		}
 	}
 
@@ -2585,15 +2628,15 @@ mpt_adapter_disable(MPT_ADAPTER *ioc)
 	 * Put the controller into ready state (if its not already)
 	 */
 	if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY) {
-		if(!SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET,
+		if (!SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET,
 		    CAN_SLEEP)) {
 			if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY)
 				printk(MYIOC_s_ERR_FMT "%s:  IOC msg unit "
 				    "reset failed to put ioc in ready state!\n",
-				    ioc->name, __FUNCTION__);
+				    ioc->name, __func__);
 		} else
 			printk(MYIOC_s_ERR_FMT "%s:  IOC msg unit reset "
-			    "failed!\n", ioc->name, __FUNCTION__);
+			    "failed!\n", ioc->name, __func__);
 	}
 
 	/* Disable adapter interrupts! */
@@ -2607,8 +2650,9 @@ mpt_adapter_disable(MPT_ADAPTER *ioc)
 
 	if (ioc->alloc != NULL) {
 		sz = ioc->alloc_sz;
-		dexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "free  @ %p, sz=%d bytes\n",
-		 	ioc->name, ioc->alloc, ioc->alloc_sz));
+		dexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"free  @ %p, sz=%d bytes\n", ioc->name,
+			ioc->alloc, ioc->alloc_sz));
 		pci_free_consistent(ioc->pcidev, sz,
 				ioc->alloc, ioc->alloc_dma);
 		ioc->reply_frames = NULL;
@@ -2666,10 +2710,11 @@ mpt_adapter_disable(MPT_ADAPTER *ioc)
 		    MPI_DB_HPBAC_FREE_BUFFER, NO_SLEEP)) != 0) {
 			printk(MYIOC_s_ERR_FMT
 			   ": %s: host page buffers free failed (%d)!\n",
-			    ioc->name, __FUNCTION__, ret);
+			    ioc->name, __func__, ret);
 		}
-		dexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HostPageBuffer free  @ %p, sz=%d bytes\n",
-		 	ioc->name, ioc->HostPageBuffer, ioc->HostPageBuffer_sz));
+		dexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"HostPageBuffer free  @ %p, sz=%d bytes\n", ioc->name,
+			ioc->HostPageBuffer, ioc->HostPageBuffer_sz));
 		pci_free_consistent(ioc->pcidev, ioc->HostPageBuffer_sz,
 				ioc->HostPageBuffer,
 				ioc->HostPageBuffer_dma);
@@ -2681,13 +2726,14 @@ mpt_adapter_disable(MPT_ADAPTER *ioc)
 	pci_set_drvdata(ioc->pcidev, NULL);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_adapter_dispose - Free all resources associated with an MPT adapter
  *	@ioc: Pointer to MPT adapter structure
  *
  *	This routine unregisters h/w resources and frees all alloc'd memory
  *	associated with a MPT adapter structure.
- **/
+ */
 static void
 mpt_adapter_dispose(MPT_ADAPTER *ioc)
 {
@@ -2718,7 +2764,8 @@ mpt_adapter_dispose(MPT_ADAPTER *ioc)
 #if defined(CONFIG_MTRR) && 0
 	if (ioc->mtrr_reg > 0) {
 		mtrr_del(ioc->mtrr_reg, 0, 0);
-		dprintk(ioc, printk(MYIOC_s_DEBUG_FMT "MTRR region de-registered\n", ioc->name));
+		dprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"MTRR region de-registered\n", ioc->name));
 	}
 #endif
 
@@ -2727,7 +2774,8 @@ mpt_adapter_dispose(MPT_ADAPTER *ioc)
 
 	sz_last = ioc->alloc_total;
 	dprintk(ioc, printk(MYIOC_s_DEBUG_FMT "free'd %d of %d bytes\n",
-			ioc->name, sz_first-sz_last+(int)sizeof(*ioc), sz_first));
+			ioc->name, sz_first-sz_last+(int)sizeof(*ioc),
+			sz_first));
 
 	if (ioc->alt_ioc)
 		ioc->alt_ioc->alt_ioc = NULL;
@@ -2735,10 +2783,11 @@ mpt_adapter_dispose(MPT_ADAPTER *ioc)
 	kfree(ioc);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	MptDisplayIocCapabilities - Disply IOC's capabilities.
  *	@ioc: Pointer to MPT adapter structure
- **/
+ */
 static void
 MptDisplayIocCapabilities(MPT_ADAPTER *ioc)
 {
@@ -2777,6 +2826,7 @@ MptDisplayIocCapabilities(MPT_ADAPTER *i
 	printk("}\n");
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	MakeIocReady - Get IOC to a READY state, using KickStart if needed.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -2790,7 +2840,7 @@ MptDisplayIocCapabilities(MPT_ADAPTER *i
  *		-2 - Msg Unit Reset Failed
  *		-3 - IO Unit Reset Failed
  *		-4 - IOC owned by a PEER
- **/
+ */
 static int
 MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
@@ -2804,7 +2854,8 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 
 	/* Get current [raw] IOC state  */
 	ioc_state = mpt_GetIocState(ioc, 0);
-	dhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "MakeIocReady, [raw] state=%08x\n", ioc->name, ioc_state));
+	dhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"MakeIocReady, [raw] state=%08x\n", ioc->name, ioc_state));
 
 	/*
 	 *	Check to see if IOC got left/stuck in doorbell handshake
@@ -2817,8 +2868,10 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 	}
 
 	/* Is it already READY? */
-	if (!statefault && (ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_READY) {
-		dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "IOC is in READY state\n",
+	if (!statefault &&
+	    (ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_READY) {
+		dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+			"IOC is in READY state\n",
 		    ioc->name));
 		return 0;
 	}
@@ -2894,8 +2947,9 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 
 		ii++; cntdn--;
 		if (!cntdn) {
-			printk(MYIOC_s_ERR_FMT "Wait IOC_READY state (0x%x) timeout(%d)!\n",
-					ioc->name, ioc_state, (int)((ii+5)/HZ));
+			printk(MYIOC_s_ERR_FMT
+			    "Wait IOC_READY state (0x%x) timeout(%d)!\n",
+			    ioc->name, ioc_state, (int)((ii+5)/HZ));
 			return -ETIME;
 		}
 
@@ -2916,6 +2970,7 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 	return hard_reset_done;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_GetIocState - Get the current state of a MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -2923,7 +2978,7 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
  *
  *	Returns all IOC Doorbell register bits if cooked==0, else just the
  *	Doorbell bits in MPI_IOC_STATE_MASK.
- **/
+ */
 u32
 mpt_GetIocState(MPT_ADAPTER *ioc, int cooked)
 {
@@ -2939,6 +2994,7 @@ mpt_GetIocState(MPT_ADAPTER *ioc, int co
 	return cooked ? sc : s;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	GetIocFacts - Send IOCFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -2946,7 +3002,7 @@ mpt_GetIocState(MPT_ADAPTER *ioc, int co
  *	@reason: If recovery, only update facts.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 GetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason)
 {
@@ -2961,9 +3017,9 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 
 	/* IOC *must* NOT be in RESET state! */
 	if (ioc->last_state == MPI_IOC_STATE_RESET) {
-		printk(KERN_ERR MYNAM ": ERROR - Can't get IOCFacts, %s NOT READY! (%08x)\n",
-				ioc->name,
-				ioc->last_state );
+		printk(KERN_ERR MYNAM
+		    ": ERROR - Can't get IOCFacts, %s NOT READY! (%08x)\n",
+		    ioc->name, ioc->last_state);
 		return -44;
 	}
 
@@ -3011,7 +3067,8 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 
 		facts->MsgVersion = le16_to_cpu(facts->MsgVersion);
 		if (facts->MsgVersion == MPI_VERSION_01_05)
-			facts->HeaderVersion = le16_to_cpu(facts->HeaderVersion);
+			facts->HeaderVersion =
+			    le16_to_cpu(facts->HeaderVersion);
 		facts->MsgContext = le32_to_cpu(facts->MsgContext);
 		facts->IOCExceptions = le16_to_cpu(facts->IOCExceptions);
 		facts->IOCStatus = le16_to_cpu(facts->IOCStatus);
@@ -3120,6 +3177,7 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	GetPortFacts - Send PortFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3127,7 +3185,7 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
  *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 GetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
@@ -3141,7 +3199,7 @@ GetPortFacts(MPT_ADAPTER *ioc, int portn
 	/* IOC *must* NOT be in RESET state! */
 	if (ioc->last_state == MPI_IOC_STATE_RESET) {
 		printk(MYIOC_s_ERR_FMT "Can't get PortFacts, "
-		   " NOT READY! (%08x)\n", ioc->name, ioc->last_state );
+		   " NOT READY! (%08x)\n", ioc->name, ioc->last_state);
 		return -4;
 	}
 
@@ -3159,14 +3217,14 @@ GetPortFacts(MPT_ADAPTER *ioc, int portn
 	get_pfacts.PortNumber = portnum;
 	/* Assert: All other get_pfacts fields are zero! */
 
-	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "Sending get PortFacts(%d) request\n",
-		ioc->name, portnum));
+	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+		"Sending get PortFacts(%d) request\n", ioc->name, portnum));
 
 	/* No non-zero fields in the get_pfacts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
 	ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,
-		reply_sz, (u16*)pfacts, 5 /*seconds*/, sleepFlag);
+		reply_sz, (u16 *)pfacts, 5 /*seconds*/, sleepFlag);
 	if (ii != 0)
 		return ii;
 
@@ -3201,6 +3259,7 @@ GetPortFacts(MPT_ADAPTER *ioc, int portn
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	SendIocInit - Send IOCInit request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3209,7 +3268,7 @@ GetPortFacts(MPT_ADAPTER *ioc, int portn
  *	Send IOCInit followed by PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 SendIocInit(MPT_ADAPTER *ioc, int sleepFlag)
 {
@@ -3323,6 +3382,7 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 	return r;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	SendPortEnable - Send PortEnable request to MPT adapter port.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3332,7 +3392,7 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
  *	Send PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
@@ -3355,18 +3415,19 @@ SendPortEnable(MPT_ADAPTER *ioc, int por
 /*	port_enable.MsgFlags = 0;		*/
 /*	port_enable.MsgContext = 0;		*/
 
-	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "Sending Port(%d)Enable (req @ %p)\n",
-			ioc->name, portnum, &port_enable));
+	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+		"Sending Port(%d)Enable (req @ %p)\n", ioc->name,
+		portnum, &port_enable));
 
 	/* RAID FW may take a long time to enable
 	 */
 	if (ioc->ir_firmware || ioc->bus_type == SAS) {
 		rc = mpt_handshake_req_reply_wait(ioc, req_sz,
-		(u32*)&port_enable, reply_sz, (u16*)&reply_buf,
+		(u32 *)&port_enable, reply_sz, (u16 *)&reply_buf,
 		300 /*seconds*/, sleepFlag);
 	} else {
 		rc = mpt_handshake_req_reply_wait(ioc, req_sz,
-		(u32*)&port_enable, reply_sz, (u16*)&reply_buf,
+		(u32 *)&port_enable, reply_sz, (u16 *)&reply_buf,
 		30 /*seconds*/, sleepFlag);
 	}
 	return rc;
@@ -3435,6 +3496,7 @@ mpt_free_fw_memory(MPT_ADAPTER *ioc)
 	ioc->cached_fw = NULL;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_do_upload - Construct and Send FWUpload request to MPT adapter port.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3447,7 +3509,7 @@ mpt_free_fw_memory(MPT_ADAPTER *ioc)
  *	on the bound IOC, the second image is discarded
  *	and memory is free'd. Both channels must upload to prevent
  *	IOC from running in degraded mode.
- **/
+ */
 static int
 mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag)
 {
@@ -3499,8 +3561,8 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 	    ioc->facts.FWImageSize, request_size));
 	DBG_DUMP_FW_REQUEST_FRAME(ioc, (u32 *)prequest);
 
-	ii = mpt_handshake_req_reply_wait(ioc, request_size, (u32*)prequest,
-	    reply_sz, (u16*)preply, 65 /*seconds*/, sleepFlag);
+	ii = mpt_handshake_req_reply_wait(ioc, request_size, (u32 *)prequest,
+	    reply_sz, (u16 *)preply, 65 /*seconds*/, sleepFlag);
 
 	dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "FW Upload completed "
 	    "rc=%x \n", ioc->name, ii));
@@ -3512,10 +3574,10 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 		 */
 		int status;
 		status = le16_to_cpu(preply->IOCStatus) &
-	            MPI_IOCSTATUS_MASK;
+		    MPI_IOCSTATUS_MASK;
 		if (status == MPI_IOCSTATUS_SUCCESS &&
 		    ioc->facts.FWImageSize ==
-		    le32_to_cpu(preply->ActualImageSize));
+		    le32_to_cpu(preply->ActualImageSize))
 			cmdStatus = 0;
 	}
 	dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "do_upload cmdStatus=%d \n",
@@ -3532,6 +3594,7 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 	return cmdStatus;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_downloadboot - DownloadBoot code
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3544,7 +3607,7 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
  *		-1 FW Image size is 0
  *		-2 No valid cached_fw Pointer
  *		<0 for fw upload failure.
- **/
+ */
 static int
 mpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag)
 {
@@ -3648,13 +3711,15 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 	}
 
 	/* Write the IopResetVectorRegAddr */
-	ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write IopResetVector Addr=%x! \n",
-	    ioc->name, pFwHeader->IopResetRegAddr));
+	ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"Write IopResetVector Addr=%x!\n", ioc->name,
+		pFwHeader->IopResetRegAddr));
 	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->IopResetRegAddr);
 
 	/* Write the IopResetVectorValue */
-	ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write IopResetVector Value=%x! \n",
-	    ioc->name, pFwHeader->IopResetVectorValue));
+	ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"Write IopResetVector Value=%x!\n", ioc->name,
+		pFwHeader->IopResetVectorValue));
 	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, pFwHeader->IopResetVectorValue);
 
 	/* Clear the internal flash bad bit - autoincrementing register,
@@ -3684,7 +3749,7 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 	    ioc->name, diag0val));
 	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
 
-	if (ioc->bus_type == SAS ) {
+	if (ioc->bus_type == SAS) {
 		/* wait 1 sec */
 		if (sleepFlag == CAN_SLEEP)
 			msleep(1000);
@@ -3692,7 +3757,7 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 			mdelay(1000);
 
 		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-		ddlprintk(ioc, printk (MYIOC_s_DEBUG_FMT
+		ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		    "diag0val=%x, turning off RW_ENABLE\n", ioc->name,
 		    diag0val));
 		diag0val &= ~(MPI_DIAG_RW_ENABLE);
@@ -3715,8 +3780,9 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 	/* Write 0xFF to reset the sequencer */
 	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
 
-	for (count = 0; count < 30; count ++) {
-		doorbell = CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_IOC_STATE_MASK;
+	for (count = 0; count < 30; count++) {
+		doorbell = CHIPREG_READ32(&ioc->chip->Doorbell)
+		    & MPI_IOC_STATE_MASK;
 		if (doorbell == MPI_IOC_STATE_READY) {
 			if (ioc->bus_type == SAS)
 				return 0;
@@ -3729,17 +3795,20 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 			    "SendIocInit successful\n", ioc->name));
 			return 0;
 		}
-		ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "looking for READY STATE:"
-		    " doorbell=%x count=%d\n", ioc->name, doorbell, count));
+		ddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"looking for READY STATE: doorbell=%x count=%d\n",
+			ioc->name, doorbell, count));
 		if (sleepFlag == CAN_SLEEP)
 			msleep(1000);
 		else
 			mdelay(1000);
 	}
-	ddlprintk(ioc, printk(MYIOC_s_WARN_FMT "downloadboot failed! count=%d\n", ioc->name, count));
+	ddlprintk(ioc, printk(MYIOC_s_WARN_FMT
+		"downloadboot failed! count=%d\n", ioc->name, count));
 	return -EFAULT;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	KickStart - Perform hard reset of MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3764,7 +3833,7 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
  *		     OR reset but failed to come READY
  *		-2 - no reset, could not enter DIAG mode
  *		-3 - reset but bad FW bit
- **/
+ */
 static int
 KickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
@@ -3790,16 +3859,20 @@ KickStart(MPT_ADAPTER *ioc, int force, i
 	if (hard_reset_done < 0)
 		return hard_reset_done;
 
-	/* may not have worked but hard_reset_done doesn't always signal failure */
-	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "Diagnostic reset completed!\n",
-			ioc->name));
+	/* may not have worked but hard_reset_done
+	 * doesn't always signal failure
+	 */
+	dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+		"Diagnostic reset completed!\n", ioc->name));
 
 	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 2;	/* 2 seconds */
 	for (cnt=0; cnt<cntdn; cnt++) {
 		ioc_state = mpt_GetIocState(ioc, 1);
-		if ((ioc_state == MPI_IOC_STATE_READY) || (ioc_state == MPI_IOC_STATE_OPERATIONAL)) {
-			dinitprintk(ioc, printk(MYIOC_s_INFO_FMT "KickStart successful! (cnt=%d)\n",
- 					ioc->name, cnt));
+		if ((ioc_state == MPI_IOC_STATE_READY) ||
+		    (ioc_state == MPI_IOC_STATE_OPERATIONAL)) {
+			dinitprintk(ioc, printk(MYIOC_s_INFO_FMT
+				"KickStart successful! (cnt=%d)\n", ioc->name,
+				cnt));
 			return hard_reset_done;
 		}
 		if (sleepFlag == CAN_SLEEP) {
@@ -3814,6 +3887,7 @@ KickStart(MPT_ADAPTER *ioc, int force, i
 	return -1;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_diag_reset - Perform hard reset of the adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3831,7 +3905,7 @@ KickStart(MPT_ADAPTER *ioc, int force, i
  *		  0  no reset performed because reset history bit set
  *		 -2  enabling diagnostic mode failed
  *		 -3  diagnostic reset failed
- **/
+ */
 static int
 mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag)
 {
@@ -3852,7 +3926,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 			return 0;
 
 		drsprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: Doorbell=%p; 1078 reset "
-		    "address=%p\n",  ioc->name, __FUNCTION__, &ioc->chip->Doorbell,
+		    "address=%p\n",  ioc->name, __func__, &ioc->chip->Doorbell,
 		    &ioc->chip->Reset_1078));
 		CHIPREG_WRITE32(&ioc->chip->Reset_1078, 0x07);
 		if (sleepFlag == CAN_SLEEP)
@@ -3868,7 +3942,8 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		 */
 		for (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {
 			if (MptResetHandlers[cb_idx])
-				(*(MptResetHandlers[cb_idx]))(ioc, MPT_IOC_PRE_RESET);
+				(*(MptResetHandlers[cb_idx]))
+				    (ioc, MPT_IOC_PRE_RESET);
 		}
 
 		for (count = 0; count < 60; count ++) {
@@ -3907,8 +3982,10 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 
 	if (ioc->debug_level & MPT_DEBUG_RESET) {
 		if (ioc->alt_ioc)
-			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG1: diag0=%08x, diag1=%08x\n",
+			diag1val =
+			    CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"DbG1: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
 	}
 
@@ -3943,14 +4020,16 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 
 			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
 
-			drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
-					ioc->name, diag0val));
+			drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+				"Wrote magic DiagWriteEn sequence (%x)\n",
+				ioc->name, diag0val));
 		}
 
 		if (ioc->debug_level & MPT_DEBUG_RESET) {
 			if (ioc->alt_ioc)
 				diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-			drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG2: diag0=%08x, diag1=%08x\n",
+			drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+				"DbG2: diag0=%08x, diag1=%08x\n",
 				ioc->name, diag0val, diag1val));
 		}
 		/*
@@ -3966,8 +4045,8 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		 */
 		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
 		hard_reset_done = 1;
-		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Diagnostic reset performed\n",
-				ioc->name));
+		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"Diagnostic reset performed\n", ioc->name));
 
 		/*
 		 * Call each currently registered protocol IOC reset handler
@@ -3977,10 +4056,11 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		 */
 		for (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {
 			if (MptResetHandlers[cb_idx]) {
-				mpt_signal_reset(cb_idx, ioc, MPT_IOC_PRE_RESET);
-				if (ioc->alt_ioc) {
-					mpt_signal_reset(cb_idx, ioc->alt_ioc, MPT_IOC_PRE_RESET);
-				}
+				mpt_signal_reset(cb_idx, ioc,
+				    MPT_IOC_PRE_RESET);
+				if (ioc->alt_ioc)
+					mpt_signal_reset(cb_idx,
+					    ioc->alt_ioc, MPT_IOC_PRE_RESET);
 			}
 		}
 
@@ -4001,7 +4081,8 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 					break;
 				}
 
-				drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "cached_fw: diag0val=%x count=%d\n",
+				drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+					"cached_fw: diag0val=%x count=%d\n",
 					ioc->name, diag0val, count));
 				/* wait 1 sec */
 				if (sleepFlag == CAN_SLEEP)
@@ -4055,7 +4136,8 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	if (ioc->debug_level & MPT_DEBUG_RESET) {
 		if (ioc->alt_ioc)
 			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG3: diag0=%08x, diag1=%08x\n",
+		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"DbG3: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
 	}
 
@@ -4113,8 +4195,9 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	if (ioc->debug_level & MPT_DEBUG_RESET) {
 		if (ioc->alt_ioc)
 			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG4: diag0=%08x, diag1=%08x\n",
-				ioc->name, diag0val, diag1val));
+		drsprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"DbG4: diag0=%08x, diag1=%08x\n",
+			ioc->name, diag0val, diag1val));
 	}
 
 	/*
@@ -4128,6 +4211,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	return hard_reset_done;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	SendIocReset - Send IOCReset request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4138,7 +4222,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
  *	Send IOCReset request to the MPT adapter.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)
 {
@@ -4164,8 +4248,9 @@ SendIocReset(MPT_ADAPTER *ioc, u8 reset_
 			if (sleepFlag != CAN_SLEEP)
 				count *= 10;
 
-			printk(MYIOC_s_ERR_FMT "Wait IOC_READY state (0x%x) timeout(%d)!\n",
-					ioc->name, state, (int)((count+5)/HZ));
+			printk(MYIOC_s_ERR_FMT
+			    "Wait IOC_READY state (0x%x) timeout(%d)!\n",
+			    ioc->name, state, (int)((count+5)/HZ));
 			return -ETIME;
 		}
 
@@ -4176,23 +4261,20 @@ SendIocReset(MPT_ADAPTER *ioc, u8 reset_
 		}
 	}
 
-	/* TODO!
-	 *  Cleanup all event stuff for this IOC; re-issue EventNotification
-	 *  request if needed.
-	 */
 	if (ioc->facts.Function)
 		ioc->facts.EventState = 0;
 
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	initChainBuffers - Allocate memory for and initialize chain buffers
  *	@ioc: Pointer to MPT_ADAPTER structure
  *
  *	Allocates memory for and initializes chain buffers,
  *	chain buffer control arrays and spinlock.
- **/
+ */
 static int
 initChainBuffers(MPT_ADAPTER *ioc)
 {
@@ -4234,11 +4316,11 @@ initChainBuffers(MPT_ADAPTER *ioc)
 	 * num_sge = num sge in request frame + last chain buffer
 	 * scale = num sge per chain buffer if no chain element
 	 */
-	scale = ioc->req_sz/ ioc->SGE_size;
+	scale = ioc->req_sz / ioc->SGE_size;
 	if (ioc->sg_addr_size == sizeof(u64))
 		num_sge =  scale + (ioc->req_sz - 60) / ioc->SGE_size;
 	else
-		num_sge =  1+ scale + (ioc->req_sz - 64) / ioc->SGE_size;
+		num_sge =  1 + scale + (ioc->req_sz - 64) / ioc->SGE_size;
 
 	if (ioc->sg_addr_size == sizeof(u64)) {
 		numSGE = (scale - 1) * (ioc->facts.MaxChainDepth-1) + scale +
@@ -4253,8 +4335,7 @@ initChainBuffers(MPT_ADAPTER *ioc)
 	if (ioc->bus_type == FC) {
 		if (numSGE > MPT_SCSI_FC_SG_DEPTH)
 			numSGE = MPT_SCSI_FC_SG_DEPTH;
-	}
-	else {
+	} else {
 		if (numSGE > MPT_SCSI_SG_DEPTH)
 			numSGE = MPT_SCSI_SG_DEPTH;
 	}
@@ -4292,6 +4373,7 @@ initChainBuffers(MPT_ADAPTER *ioc)
 	return num_chain;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	PrimeIocFifos - Initialize IOC request and reply FIFOs.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4301,7 +4383,7 @@ initChainBuffers(MPT_ADAPTER *ioc)
  *	reply frames.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 PrimeIocFifos(MPT_ADAPTER *ioc)
 {
@@ -4513,6 +4595,7 @@ out_fail:
 	return -1;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply
  *	from IOC via doorbell handshake method.
@@ -4530,7 +4613,7 @@ out_fail:
  *	greater than 1 byte in size.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,
 		int replyBytes, u16 *u16reply, int maxwait, int sleepFlag)
@@ -4624,6 +4707,7 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 	return -failcnt;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	WaitForDoorbellAck - Wait for IOC doorbell handshake acknowledge
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4635,7 +4719,7 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
  *	bit in its IntStatus register being clear.
  *
  *	Returns a negative value on failure, else wait loop count.
- **/
+ */
 static int
 WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
@@ -4674,6 +4758,7 @@ WaitForDoorbellAck(MPT_ADAPTER *ioc, int
 	return -1;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	WaitForDoorbellInt - Wait for IOC to set its doorbell interrupt bit
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4684,7 +4769,7 @@ WaitForDoorbellAck(MPT_ADAPTER *ioc, int
  *	(MPI_HIS_DOORBELL_INTERRUPT) to be set in the IntStatus register.
  *
  *	Returns a negative value on failure, else wait loop count.
- **/
+ */
 static int
 WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
@@ -4703,7 +4788,7 @@ WaitForDoorbellInt(MPT_ADAPTER *ioc, int
 		}
 	} else {
 		while (--cntdn) {
-			udelay (1000);
+			udelay(1000);
 			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
 			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
 				break;
@@ -4722,6 +4807,7 @@ WaitForDoorbellInt(MPT_ADAPTER *ioc, int
 	return -1;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	WaitForDoorbellReply - Wait for and capture an IOC handshake reply.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4733,7 +4819,7 @@ WaitForDoorbellInt(MPT_ADAPTER *ioc, int
  *	of 128 bytes of reply data.
  *
  *	Returns a negative value on failure, else size of reply in WORDS.
- **/
+ */
 static int
 WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
@@ -4807,6 +4893,7 @@ WaitForDoorbellReply(MPT_ADAPTER *ioc, i
 	return u16cnt/2;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	GetLanConfigPages - Fetch LANConfig pages.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4816,7 +4903,7 @@ WaitForDoorbellReply(MPT_ADAPTER *ioc, i
  *		-EPERM if not allowed due to ISR context
  *		-EAGAIN if no msg frames currently available
  *		-EFAULT for non-successful reply or no reply (timeout)
- **/
+ */
 static int
 GetLanConfigPages(MPT_ADAPTER *ioc)
 {
@@ -4863,10 +4950,6 @@ GetLanConfigPages(MPT_ADAPTER *ioc)
 
 			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
 
-			/* FIXME!
-			 *	Normalize endianness of structure data,
-			 *	by byte-swapping all > 1 byte fields!
-			 */
 
 		}
 
@@ -4907,16 +4990,12 @@ GetLanConfigPages(MPT_ADAPTER *ioc)
 
 		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);
 
-		/* FIXME!
-		 *	Normalize endianness of structure data,
-		 *	by byte-swapping all > 1 byte fields!
-		 */
-
 	}
 
 	return rc;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptbase_sas_persist_operation - Perform operation on SAS Persistent Table
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -4929,7 +5008,7 @@ GetLanConfigPages(MPT_ADAPTER *ioc)
  *	NOTE: Don't use not this function during interrupt time.
  *
  *	Returns 0 for success, non-zero error
- **/
+ */
 int
 mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode)
 {
@@ -4958,12 +5037,12 @@ mptbase_sas_persist_operation(MPT_ADAPTE
 		goto out;
 	}
 
-	printk("%s: persist_opcode=%x\n",__FUNCTION__, persist_opcode);
+	printk("%s: persist_opcode=%x\n",__func__, persist_opcode);
 
 	/* Get a MF for this command.
 	 */
 	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
-		printk("%s: no msg frames!\n",__FUNCTION__);
+		printk("%s: no msg frames!\n",__func__);
 		ret = -1;
 		goto out;
         }
@@ -4979,12 +5058,12 @@ mptbase_sas_persist_operation(MPT_ADAPTE
 	timeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done, 10*HZ);
 	if (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		ret = -ETIME;
-		printk("%s: failed\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: failed\n", __func__);
 		if (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)
 			goto out;
 		if (!timeleft) {
 			printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-			    ioc->name, __FUNCTION__);
+			    ioc->name, __func__);
 			if (mpt_SoftResetHandler(ioc, CAN_SLEEP) != 0)
 				mpt_HardResetHandler(ioc, CAN_SLEEP);
 			mpt_free_msg_frame(ioc, mf);
@@ -5000,12 +5079,13 @@ mptbase_sas_persist_operation(MPT_ADAPTE
 	sasIoUnitCntrReply =
 	    (SasIoUnitControlReply_t *)ioc->mptbase_cmds.reply;
 	if (le16_to_cpu(sasIoUnitCntrReply->IOCStatus) != MPI_IOCSTATUS_SUCCESS) {
-		printk("%s: IOCStatus=0x%X IOCLogInfo=0x%X\n", __FUNCTION__,
-		    sasIoUnitCntrReply->IOCStatus, sasIoUnitCntrReply->IOCLogInfo);
-		printk("%s: failed\n",__FUNCTION__);
+		printk(KERN_WARNING "%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",
+		    __func__, sasIoUnitCntrReply->IOCStatus,
+		    sasIoUnitCntrReply->IOCLogInfo);
+		printk(KERN_WARNING "%s: failed\n", __func__);
 		ret = -1;
 	} else
-		printk("%s: success\n",__FUNCTION__);
+		printk(KERN_INFO "%s: success\n", __func__);
  out:
 
 	CLEAR_MGMT_STATUS(ioc->mptbase_cmds.status)
@@ -5013,6 +5093,8 @@ mptbase_sas_persist_operation(MPT_ADAPTE
 	return ret;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
 static void
 mptbase_raid_process_event_data(MPT_ADAPTER *ioc,
     MpiEventDataRaid_t * pRaidEventData)
@@ -5143,6 +5225,7 @@ mptbase_raid_process_event_data(MPT_ADAP
 	}
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	GetIoUnitPage2 - Retrieve BIOS version and boot order information.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -5152,7 +5235,7 @@ mptbase_raid_process_event_data(MPT_ADAP
  *		-EPERM if not allowed due to ISR context
  *		-EAGAIN if no msg frames currently available
  *		-EFAULT for non-successful reply or no reply (timeout)
- **/
+ */
 static int
 GetIoUnitPage2(MPT_ADAPTER *ioc)
 {
@@ -5200,6 +5283,7 @@ GetIoUnitPage2(MPT_ADAPTER *ioc)
 	return rc;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_GetScsiPortSettings - read SCSI Port Page 0 and 2
  *	@ioc: Pointer to a Adapter Strucutre
@@ -5219,7 +5303,7 @@ GetIoUnitPage2(MPT_ADAPTER *ioc)
  *		Both valid
  *		Return 0
  *	CHECK - what type of locking mechanisms should be used????
- **/
+ */
 static int
 mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)
 {
@@ -5290,7 +5374,8 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 
 				if ( (pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_QAS) == 0 ) {
 					ioc->spi_data.noQas |= MPT_TARGET_NO_NEGO_QAS;
-					ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT "noQas due to Capabilities=%x\n",
+					ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+						"noQas due to Capabilities=%x\n",
 						ioc->name, pPP0->Capabilities));
 				}
 				ioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;
@@ -5299,7 +5384,8 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 					ioc->spi_data.maxSyncOffset = (u8) (data >> 16);
 					data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
 					ioc->spi_data.minSyncFactor = (u8) (data >> 8);
-					ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT "PortPage0 minSyncFactor=%x\n",
+					ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+						"PortPage0 minSyncFactor=%x\n",
 						ioc->name, ioc->spi_data.minSyncFactor));
 				} else {
 					ioc->spi_data.maxSyncOffset = 0;
@@ -5315,7 +5401,8 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 
 					if (ioc->spi_data.minSyncFactor < MPT_ULTRA) {
 						ioc->spi_data.minSyncFactor = MPT_ULTRA;
-						ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HVD or SE detected, minSyncFactor=%x\n",
+						ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+							"HVD or SE detected, minSyncFactor=%x\n",
 							ioc->name, ioc->spi_data.minSyncFactor));
 					}
 				}
@@ -5420,6 +5507,7 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 	return rc;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_readScsiDevicePageHeaders - save version and length of SDP1
  *	@ioc: Pointer to a Adapter Strucutre
@@ -5427,7 +5515,7 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
  *
  *	Return: -EFAULT if read of config page header fails
  *		or 0 if success.
- **/
+ */
 static int
 mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum)
 {
@@ -5475,7 +5563,7 @@ mpt_read_ioc_pg_6(MPT_ADAPTER *ioc)
 {
 	CONFIGPARMS		 cfg;
 	ConfigPageHeader_t	 header;
-	IOCPage6_t		*pIoc6=NULL;
+	IOCPage6_t		*pIoc6 = NULL;
 	dma_addr_t		 ioc6_dma;
 	int			 iocpage6sz;
 	void			*mem;
@@ -5546,13 +5634,13 @@ mpt_inactive_raid_list_free(MPT_ADAPTER 
 	if (list_empty(&ioc->raid_data.inactive_list))
 		return;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	list_for_each_entry_safe(component_info, pNext,
 	    &ioc->raid_data.inactive_list, list) {
 		list_del(&component_info->list);
 		kfree(component_info);
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_unlock(&ioc->raid_data.inactive_list_mutex);
 }
 
 /**
@@ -5615,7 +5703,7 @@ mpt_inactive_raid_volumes(MPT_ADAPTER *i
 	if (!handle_inactive_volumes)
 		goto out;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	for (i = 0; i < buffer->NumPhysDisks; i++) {
 		if(mpt_raid_phys_disk_pg0(ioc,
 		    buffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)
@@ -5631,7 +5719,7 @@ mpt_inactive_raid_volumes(MPT_ADAPTER *i
 		    buffer->PhysDisk[i].PhysDiskNum);
 		if (num_paths < 2)
 			continue;
-		phys_disk_1 = kzalloc(offsetof(RaidPhysDiskPage1_t,Path) +
+		phys_disk_1 = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +
 		   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);
 		if (!phys_disk_1)
 			continue;
@@ -5658,7 +5746,7 @@ mpt_inactive_raid_volumes(MPT_ADAPTER *i
 		list_add_tail(&component_info->list,
 		    &ioc->raid_data.inactive_list);
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_unlock(&ioc->raid_data.inactive_list_mutex);
 
  out:
 	if (buffer)
@@ -5678,7 +5766,8 @@ mpt_inactive_raid_volumes(MPT_ADAPTER *i
  *	-ENOMEM if pci_alloc failed
  **/
 int
-mpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage0_t *phys_disk)
+mpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num,
+    RaidPhysDiskPage0_t *phys_disk)
 {
 	CONFIGPARMS		 	cfg;
 	ConfigPageHeader_t	 	hdr;
@@ -5812,7 +5901,8 @@ mpt_raid_phys_disk_get_num_paths(MPT_ADA
  *	-ENOMEM if pci_alloc failed
  **/
 int
-mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage1_t *phys_disk)
+mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num,
+    RaidPhysDiskPage1_t *phys_disk)
 {
 	CONFIGPARMS		 	cfg;
 	ConfigPageHeader_t	 	hdr;
@@ -5865,14 +5955,20 @@ mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc,
 	for (i = 0; i < phys_disk->NumPhysDiskPaths; i++) {
 		phys_disk->Path[i].PhysDiskID = buffer->Path[i].PhysDiskID;
 		phys_disk->Path[i].PhysDiskBus = buffer->Path[i].PhysDiskBus;
-		phys_disk->Path[i].OwnerIdentifier = buffer->Path[i].OwnerIdentifier;
-		phys_disk->Path[i].Flags = le16_to_cpu(buffer->Path[i].Flags);
-		memcpy(&sas_address, &buffer->Path[i].WWID, sizeof(__le64));
+		phys_disk->Path[i].OwnerIdentifier =
+		    buffer->Path[i].OwnerIdentifier;
+		phys_disk->Path[i].Flags =
+		    le16_to_cpu(buffer->Path[i].Flags);
+		memcpy(&sas_address, &buffer->Path[i].WWID,
+		    sizeof(__le64));
 		sas_address = le64_to_cpu(sas_address);
-		memcpy(&phys_disk->Path[i].WWID, &sas_address, sizeof(__le64));
-		memcpy(&sas_address, &buffer->Path[i].OwnerWWID, sizeof(__le64));
+		memcpy(&phys_disk->Path[i].WWID, &sas_address,
+		    sizeof(__le64));
+		memcpy(&sas_address, &buffer->Path[i].OwnerWWID,
+		    sizeof(__le64));
 		sas_address = le64_to_cpu(sas_address);
-		memcpy(&phys_disk->Path[i].OwnerWWID, &sas_address, sizeof(__le64));
+		memcpy(&phys_disk->Path[i].OwnerWWID, &sas_address,
+		    sizeof(__le64));
 	}
 
  out:
@@ -5896,8 +5992,8 @@ mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc,
 static int
 mpt_sort_ioc_pg2(const void *a, const void *b)
 {
-	ConfigPageIoc2RaidVol_t * volume_a = (ConfigPageIoc2RaidVol_t *)a;
-	ConfigPageIoc2RaidVol_t * volume_b = (ConfigPageIoc2RaidVol_t *)b;
+	ConfigPageIoc2RaidVol_t *volume_a = (ConfigPageIoc2RaidVol_t *)a;
+	ConfigPageIoc2RaidVol_t *volume_b = (ConfigPageIoc2RaidVol_t *)b;
 
 	if (volume_a->VolumeBus == volume_b->VolumeBus) {
 		if (volume_a->VolumeID == volume_b->VolumeID)
@@ -6186,7 +6282,8 @@ mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 			}
 
 		} else {
-			dprintk(ioc, printk(MYIOC_s_WARN_FMT "Coalescing Disabled\n", ioc->name));
+			dprintk(ioc, printk(MYIOC_s_WARN_FMT
+				"Coalescing Disabled\n", ioc->name));
 		}
 	}
 
@@ -6238,12 +6335,13 @@ mpt_get_manufacturing_pg_0(MPT_ADAPTER *
 		pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	SendEventNotification - Send EventNotification (on or off) request to adapter
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@EvSwitch: Event switch flags
  *	@sleepFlag: Specifies whether the process can sleep
- **/
+ */
 static int
 SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch, int sleepFlag)
 {
@@ -6262,15 +6360,16 @@ SendEventNotification(MPT_ADAPTER *ioc, 
 	    ioc->name, EvSwitch, &evn));
 
 	return mpt_handshake_req_reply_wait(ioc, sizeof(EventNotification_t),
-	    (u32*)&evn, sizeof(MPIDefaultReply_t), (u16*)&reply_buf, 30,
+	    (u32 *)&evn, sizeof(MPIDefaultReply_t), (u16 *)&reply_buf, 30,
 	    sleepFlag);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	SendEventAck - Send EventAck request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@evnp: Pointer to original EventNotification request
- **/
+ */
 static int
 SendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp)
 {
@@ -6278,7 +6377,7 @@ SendEventAck(MPT_ADAPTER *ioc, EventNoti
 
 	if ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames!!\n",
-		    ioc->name,__FUNCTION__));
+		    ioc->name,__func__));
 		return -1;
 	}
 
@@ -6297,6 +6396,7 @@ SendEventAck(MPT_ADAPTER *ioc, EventNoti
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_config - Generic function to issue config message
  *	@ioc:   Pointer to an adapter structure
@@ -6309,7 +6409,7 @@ SendEventAck(MPT_ADAPTER *ioc, EventNoti
  *	-EPERM if not allowed due to ISR context
  *	-EAGAIN if no msg frames currently available
  *	-EFAULT for non-successful reply or no reply (timeout)
- **/
+ */
 int
 mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)
 {
@@ -6334,7 +6434,7 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	spin_lock_irqsave(&ioc->taskmgmt_lock, flags);
 	if (ioc->ioc_reset_in_progress) {
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: busy with host reset\n", ioc->name, __FUNCTION__));
+		    "%s: busy with host reset\n", ioc->name, __func__));
 		spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
 		return -EBUSY;
 	}
@@ -6345,7 +6445,7 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	    mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		    "%s: ioc not operational, %d, %xh\n",
-		    ioc->name, __FUNCTION__, ioc->active,
+		    ioc->name, __func__, ioc->active,
 		    mpt_GetIocState(ioc, 0)));
 		return -EFAULT;
 	}
@@ -6423,7 +6523,8 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	ioc->add_sge((char *)&pReq->PageBufferSGE, flagsLength, pCfg->physAddr);
 	timeout = (pCfg->timeout < 15) ? HZ*15 : HZ*pCfg->timeout;
 	mpt_put_msg_frame(mpt_base_index, ioc, mf);
-	timeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done, timeout);
+	timeleft =
+	    wait_for_completion_timeout(&ioc->mptbase_cmds.done, timeout);
 	if (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		ret = -ETIME;
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT
@@ -6459,7 +6560,8 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	}
 
 	if (retry_count)
-		printk(MYIOC_s_INFO_FMT "Retry completed ret=0x%x timeleft=%ld\n",
+		printk(MYIOC_s_INFO_FMT
+		    "Retry completed ret=0x%x timeleft=%ld\n",
 		    ioc->name, ret, timeleft);
 
 	dcprintk(ioc, printk(KERN_DEBUG "IOCStatus=%04xh, IOCLogInfo=%08xh\n",
@@ -6472,15 +6574,15 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	if (issue_hard_reset) {
 		issue_hard_reset = 0;
 		printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-		    ioc->name, __FUNCTION__);
+		    ioc->name, __func__);
 		if (mpt_SoftResetHandler(ioc, CAN_SLEEP) != 0)
 			mpt_HardResetHandler(ioc, CAN_SLEEP);
 		mpt_free_msg_frame(ioc, mf);
 		/* attempt one retry for a timed out command */
 		if (!retry_count) {
 			printk(MYIOC_s_INFO_FMT
-			    "Attempting Retry Config request type 0x%x, page 0x%x,"
-			    " action %d\n", ioc->name, page_type,
+			    "Attempting Retry Config request type 0x%x,"
+			    " page 0x%x, action %d\n", ioc->name, page_type,
 			    pCfg->cfghdr.hdr->PageNumber, pCfg->action);
 			retry_count++;
 			goto retry_config;
@@ -6489,37 +6591,40 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	return ret;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_ioc_reset - Base cleanup for hard reset
  *	@ioc: Pointer to the adapter structure
  *	@reset_phase: Indicates pre- or post-reset functionality
  *
  *	Remark: Frees resources with internally generated commands.
- **/
+ */
 static int
 mpt_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
 {
-	switch(reset_phase) {
+	switch (reset_phase) {
 	case MPT_IOC_SETUP_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));
 		ioc->taskmgmt_quiesce_io = 1;
 		break;
 	case MPT_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_POST_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_POST_RESET\n",  ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_POST_RESET\n",  ioc->name, __func__));
 /* wake up mptbase_cmds */
 		if (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_PENDING) {
-			ioc->mptbase_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;
+			ioc->mptbase_cmds.status
+			    |= MPT_MGMT_STATUS_DID_IOCRESET;
 			complete(&ioc->mptbase_cmds.done);
 		}
 /* wake up taskmgmt_cmds */
 		if (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {
-			ioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;
+			ioc->taskmgmt_cmds.status
+			    |= MPT_MGMT_STATUS_DID_IOCRESET;
 			complete(&ioc->taskmgmt_cmds.done);
 		}
 		break;
@@ -6532,11 +6637,12 @@ mpt_ioc_reset(MPT_ADAPTER *ioc, int rese
 
 
 #ifdef CONFIG_PROC_FS		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	procmpt_create - Create %MPT_PROCFS_MPTBASEDIR entries.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int
 procmpt_create(void)
 {
@@ -6557,11 +6663,12 @@ procmpt_create(void)
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	procmpt_destroy - Tear down %MPT_PROCFS_MPTBASEDIR entries.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static void
 procmpt_destroy(void)
 {
@@ -6570,6 +6677,7 @@ procmpt_destroy(void)
 	remove_proc_entry(MPT_PROCFS_MPTBASEDIR, NULL);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	procmpt_summary_read - Handle read request of a summary file
  *	@buf: Pointer to area to write information
@@ -6581,7 +6689,7 @@ procmpt_destroy(void)
  *
  *	Handles read request from /proc/mpt/summary or /proc/mpt/iocN/summary.
  *	Returns number of characters written to process performing the read.
- **/
+ */
 static int
 procmpt_summary_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
@@ -6613,6 +6721,7 @@ procmpt_summary_read(char *buf, char **s
 	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	procmpt_version_read - Handle read request from /proc/mpt/version.
  *	@buf: Pointer to area to write information
@@ -6623,7 +6732,7 @@ procmpt_summary_read(char *buf, char **s
  *	@data: Pointer
  *
  *	Returns number of characters written to process performing the read.
- **/
+ */
 static int
 procmpt_version_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
@@ -6668,6 +6777,7 @@ procmpt_version_read(char *buf, char **s
 	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	procmpt_iocinfo_read - Handle read request from /proc/mpt/iocN/info.
  *	@buf: Pointer to area to write information
@@ -6678,7 +6788,7 @@ procmpt_version_read(char *buf, char **s
  *	@data: Pointer
  *
  *	Returns number of characters written to process performing the read.
- **/
+ */
 static int
 procmpt_iocinfo_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
@@ -6779,6 +6889,7 @@ mpt_get_fw_exp_ver(char *buf, MPT_ADAPTE
 	}
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_print_ioc_summary - Write ASCII summary of IOC to a buffer.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -6789,7 +6900,7 @@ mpt_get_fw_exp_ver(char *buf, MPT_ADAPTE
  *
  *	This routine writes (english readable) ASCII text, which represents
  *	a summary of IOC information, to a buffer.
- **/
+ */
 void
 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buffer, int *size, int len, int showlan)
 {
@@ -6901,19 +7012,19 @@ mpt_halt_firmware(MPT_ADAPTER *ioc)
 	if ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {
 		printk(MYIOC_s_ERR_FMT "IOC is in FAULT state (%04xh)!!!\n",
 			ioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);
-		if(mpt_fwfault_debug == 2)
-			for(;;);
+		if (mpt_fwfault_debug == 2)
+			for (;;);
 		else
-			panic("%s: IOC Fault (%04xh)!!!\n",ioc->name,
+			panic("%s: IOC Fault (%04xh)!!!\n", ioc->name,
 				ioc_raw_state & MPI_DOORBELL_DATA_MASK);
 	} else {
 		CHIPREG_WRITE32(&ioc->chip->Doorbell, 0xC0FFEE00);
-		if(mpt_fwfault_debug == 2) {
-			printk("%s: Firmware is halted due to command timeout\n"
-					,ioc->name);
-			for(;;);
-		}
-		else
+		if (mpt_fwfault_debug == 2) {
+			printk(KERN_ERR
+			    "%s: Firmware is halted due to command timeout\n",
+			    ioc->name);
+			for (;;);
+		} else
 			panic("%s: Firmware is halted due to command timeout\n",
 					ioc->name);
 	}
@@ -6943,14 +7054,16 @@ mpt_SoftResetHandler(MPT_ADAPTER *ioc, i
 	u32		 ioc_state;
 	unsigned long	 time_count;
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SoftResetHandler Entered!\n", ioc->name));
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"SoftResetHandler Entered!\n", ioc->name));
 
 	ioc_state = mpt_GetIocState(ioc, 0) & MPI_IOC_STATE_MASK;
 
-	if(mpt_fwfault_debug)
+	if (mpt_fwfault_debug)
 		mpt_halt_firmware(ioc);
 
-	if (ioc_state == MPI_IOC_STATE_FAULT || ioc_state == MPI_IOC_STATE_RESET) {
+	if (ioc_state == MPI_IOC_STATE_FAULT
+	    || ioc_state == MPI_IOC_STATE_RESET) {
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		    "skipping, either in FAULT or RESET state!\n", ioc->name));
 		return -1;
@@ -6995,11 +7108,10 @@ mpt_SoftResetHandler(MPT_ADAPTER *ioc, i
 		if ((rc = GetIocFacts(ioc, sleepFlag,
 			    MPT_HOSTEVENT_IOC_RECOVER)) == 0)
 			break;
-		if (sleepFlag == CAN_SLEEP) {
+		if (sleepFlag == CAN_SLEEP)
 			msleep(100);
-		} else {
+		else
 			mdelay(100);
-		}
 	}
 	if (ii == 5)
 		goto out;
@@ -7033,13 +7145,15 @@ mpt_SoftResetHandler(MPT_ADAPTER *ioc, i
 	if (ioc->active) {	/* otherwise, hard reset coming */
 		for (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {
 			if (MptResetHandlers[cb_idx])
-				mpt_signal_reset(cb_idx, ioc, MPT_IOC_POST_RESET);
+				mpt_signal_reset(cb_idx,
+				    ioc, MPT_IOC_POST_RESET);
 		}
 	}
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SoftResetHandler: completed (%d seconds): %s\n",
-	    ioc->name, jiffies_to_msecs(jiffies - time_count)/1000,
-	    ((rc == 0) ? "SUCCESS" : "FAILED")));
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"SoftResetHandler: completed (%d seconds): %s\n",
+		ioc->name, jiffies_to_msecs(jiffies - time_count)/1000,
+		((rc == 0) ? "SUCCESS" : "FAILED")));
 
 	return rc;
 }
@@ -7060,7 +7174,7 @@ mpt_SoftResetHandler(MPT_ADAPTER *ioc, i
  *	FW reload/initialization failed.
  *
  *	Returns 0 for SUCCESS or -1 if FAILED.
- **/
+ */
 int
 mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag)
 {
@@ -7075,7 +7189,7 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 	printk("MF count 0x%x !\n", ioc->mfcnt);
 #endif
 
-	if(mpt_fwfault_debug)
+	if (mpt_fwfault_debug)
 		mpt_halt_firmware(ioc);
 
 	/* Reset the adapter. Prevent more than 1 call to
@@ -7101,14 +7215,15 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 		if (MptResetHandlers[cb_idx]) {
 			mpt_signal_reset(cb_idx, ioc, MPT_IOC_SETUP_RESET);
 			if (ioc->alt_ioc)
-				mpt_signal_reset(cb_idx, ioc->alt_ioc, MPT_IOC_SETUP_RESET);
+				mpt_signal_reset(cb_idx,
+				    ioc->alt_ioc, MPT_IOC_SETUP_RESET);
 		}
 	}
 
 	time_count = jiffies;
 	if ((rc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag)) != 0) {
-		printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
-			rc, ioc->name);
+		printk(KERN_WARNING MYNAM
+		    ": WARNING - (%d) Cannot recover %s\n", rc, ioc->name);
 	} else {
 		if (ioc->hard_resets < -1)
 			ioc->hard_resets++;
@@ -7129,13 +7244,15 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 		if (MptResetHandlers[cb_idx]) {
 			mpt_signal_reset(cb_idx, ioc, MPT_IOC_POST_RESET);
 			if (ioc->alt_ioc)
-				mpt_signal_reset(cb_idx, ioc->alt_ioc, MPT_IOC_POST_RESET);
+				mpt_signal_reset(cb_idx,
+				    ioc->alt_ioc, MPT_IOC_POST_RESET);
 		}
 	}
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HardResetHandler: completed (%d seconds): %s\n",
-	    ioc->name, jiffies_to_msecs(jiffies - time_count)/1000,
-	    ((rc == 0) ? "SUCCESS" : "FAILED")));
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"HardResetHandler: completed (%d seconds): %s\n",
+		ioc->name, jiffies_to_msecs(jiffies - time_count)/1000,
+		((rc == 0) ? "SUCCESS" : "FAILED")));
 	return rc;
 }
 
@@ -7607,6 +7724,7 @@ mpt_display_event_info(MPT_ADAPTER *ioc,
 }
 #endif
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	ProcessEventNotification - Route EventNotificationReply to all event handlers
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -7616,7 +7734,7 @@ mpt_display_event_info(MPT_ADAPTER *ioc,
  *	Routes a received EventNotificationReply to all currently registered
  *	event handlers.
  *	Returns sum of event handlers return values.
- **/
+ */
 static int
 ProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *pEventReply, int *evHandlers)
 {
@@ -7695,12 +7813,12 @@ ProcessEventNotification(MPT_ADAPTER *io
 	for (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {
 		if (MptEvHandlers[cb_idx]) {
 			devtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-			    "Routing Event to event handler #%d\n", ioc->name, cb_idx));
+			    "Routing Event to event handler #%d\n",
+			    ioc->name, cb_idx));
 			r += (*(MptEvHandlers[cb_idx]))(ioc, pEventReply);
 			handlers++;
 		}
 	}
-	/* FIXME?  Examine results here? */
 
 	/*
 	 *  If needed, send (a single) EventAck.
@@ -7762,6 +7880,7 @@ mpt_fc_log_info(MPT_ADAPTER *ioc, u32 lo
 			ioc->name, log_info, desc, (log_info & 0xFFFFFF));
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_spi_log_info - Log information returned from SCSI Parallel IOC.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -7769,7 +7888,7 @@ mpt_fc_log_info(MPT_ADAPTER *ioc, u32 lo
  *	@log_info: U32 LogInfo word from the IOC
  *
  *	Refer to lsi/sp_log.h.
- **/
+ */
 static void
 mpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info)
 {
@@ -8353,7 +8472,8 @@ mpt_iocstatus_info(MPT_ADAPTER *ioc, u32
 	if (!desc)
 		return;
 
-	dreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT "IOCStatus(0x%04X): %s\n", ioc->name, status, desc));
+	dreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"IOCStatus(0x%04X): %s\n", ioc->name, status, desc));
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -8364,7 +8484,6 @@ EXPORT_SYMBOL(mpt_resume);
 EXPORT_SYMBOL(mpt_suspend);
 #endif
 EXPORT_SYMBOL(ioc_list);
-EXPORT_SYMBOL(mpt_proc_root_dir);
 EXPORT_SYMBOL(mpt_register);
 EXPORT_SYMBOL(mpt_deregister);
 EXPORT_SYMBOL(mpt_event_register);
@@ -8395,11 +8514,12 @@ EXPORT_SYMBOL(mpt_set_taskmgmt_in_progre
 EXPORT_SYMBOL(mpt_clear_taskmgmt_in_progress_flag);
 EXPORT_SYMBOL(mpt_halt_firmware);
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	fusion_init - Fusion MPT base driver initialization routine.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int __init
 fusion_init(void)
 {
@@ -8430,12 +8550,13 @@ fusion_init(void)
 	return 0;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	fusion_exit - Perform driver unload cleanup.
  *
  *	This routine frees all resources associated with each MPT adapter
  *	and removes all %MPT_PROCFS_MPTBASEDIR entries.
- **/
+ */
 static void __exit
 fusion_exit(void)
 {
Index: linux-2.6.27/drivers/message/fusion/mptbase.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptbase.h
+++ linux-2.6.27/drivers/message/fusion/mptbase.h
@@ -72,8 +72,8 @@
 #define COPYRIGHT	"Copyright (c) 1999-2008 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"4.00.43.00"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-4.00.43.00"
+#define MPT_LINUX_VERSION_COMMON	"4.00.43.00suse"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-4.00.43.00suse"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 #define MPT_LINUX_MAJOR_VERSION		4
 #define MPT_LINUX_MINOR_VERSION		00
@@ -177,10 +177,10 @@
 #define MPT_SCSI_SG_DEPTH	40
 #endif
 
-#ifdef  CONFIG_FUSION_MAX_FC_SGE
-#if     CONFIG_FUSION_MAX_FC_SGE  < 16
+#ifdef	CONFIG_FUSION_MAX_FC_SGE
+#if	CONFIG_FUSION_MAX_FC_SGE  < 16
 #define MPT_SCSI_FC_SG_DEPTH	16
-#elif   CONFIG_FUSION_MAX_FC_SGE  > 256
+#elif	CONFIG_FUSION_MAX_FC_SGE  > 256
 #define MPT_SCSI_FC_SG_DEPTH	256
 #else
 #define MPT_SCSI_FC_SG_DEPTH	CONFIG_FUSION_MAX_FC_SGE
@@ -444,10 +444,10 @@ do { \
 #define MPT_MGMT_STATUS_RF_VALID	0x01	/* The Reply Frame is VALID */
 #define MPT_MGMT_STATUS_COMMAND_GOOD	0x02	/* Command Status GOOD */
 #define MPT_MGMT_STATUS_PENDING		0x04	/* command is pending */
-#define MPT_MGMT_STATUS_DID_IOCRESET	0x08	/* IOC Reset occurred on the current*/
+#define MPT_MGMT_STATUS_DID_IOCRESET	0x08	/* IOC Reset occurred */
 #define MPT_MGMT_STATUS_SENSE_VALID	0x10	/* valid sense info */
 #define MPT_MGMT_STATUS_TIMER_ACTIVE	0x20	/* obsolete */
-#define MPT_MGMT_STATUS_FREE_MF		0x40	/* free the mf from complete routine */
+#define MPT_MGMT_STATUS_FREE_MF		0x40	/* free the mf */
 
 
 #define INITIALIZE_MGMT_STATUS(status) \
@@ -467,7 +467,7 @@ typedef struct _MPT_MGMT {
 	u8			 status;	/* current command status */
 	int			 completion_code;
 	u32			 msg_context;
-}MPT_MGMT;
+} MPT_MGMT;
 
 /*
  *  Event Structure and define
@@ -540,7 +540,7 @@ typedef	struct _RaidCfgData {
 	IOCPage2_t	*pIocPg2;		/* table of Raid Volumes */
 	IOCPage3_t	*pIocPg3;		/* table of physical disks */
 	IOCPage6_t	*pIocPg6;		/* table of IR static data */
-	struct semaphore	inactive_list_mutex;
+	struct mutex	inactive_list_mutex;
 	struct list_head	inactive_list; /* link list for physical
 						disk that belong in
 						inactive volumes */
@@ -571,7 +571,8 @@ struct mptfc_rport_info
 };
 
 typedef void (*MPT_ADD_SGE)(char *pAddr, u32 flagslength, dma_addr_t dma_addr);
-typedef void (*MPT_ADD_CHAIN)(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr);
+typedef void (*MPT_ADD_CHAIN)
+	(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr);
 
 /*
  *  Adapter Structure - pci_dev specific. Maximum: MPT_MAX_ADAPTERS
@@ -583,7 +584,8 @@ typedef struct _MPT_ADAPTER
 	char			 name[MPT_NAME_LENGTH];	/* "iocN"             */
 	char			 prod_name[MPT_NAME_LENGTH];	/* "LSIFC9x9"         */
 #ifdef CONFIG_FUSION_LOGGING
-	char			 evStr[EVENT_DESCR_STR_SZ]; /* used in mpt_display_event_info */
+	/* used in mpt_display_event_info */
+	char			 evStr[EVENT_DESCR_STR_SZ];
 #endif
 	char			 board_name[16];
 	char			 board_assembly[16];
@@ -597,7 +599,8 @@ typedef struct _MPT_ADAPTER
 	SYSIF_REGS __iomem	*pio_chip;	/* Programmed IO (downloadboot) */
 	u8			 bus_type;
 	unsigned long		 mem_phys;	/* == f4020000 (mmap) */
-	unsigned long		 pio_mem_phys;	/* Programmed IO (downloadboot) */
+	/* Programmed IO (downloadboot) */
+	unsigned long		 pio_mem_phys;
 	int			 mem_size;	/* mmap memory size */
 	int			 number_of_buses;
 	int			 devices_per_bus;
@@ -612,8 +615,10 @@ typedef struct _MPT_ADAPTER
 	int			 reply_depth;	/* Num Allocated reply frames */
 	int			 reply_sz;	/* Reply frame size */
 	int			 num_chain;	/* Number of chain buffers */
-	MPT_ADD_SGE		 add_sge;	/* Pointer to add_sge function */
-	MPT_ADD_CHAIN		 add_chain;	/* Pointer to add_chain function */
+	/* Pointer to add_sge function */
+	MPT_ADD_SGE		 add_sge;
+	/* Pointer to add_chain function */
+	MPT_ADD_CHAIN		 add_chain;
 		/* Pool of buffers for chaining. ReqToChain
 		 * and ChainToChain track index of chain buffers.
 		 * ChainBuffer (DMA) virt/phys addresses.
@@ -646,7 +651,8 @@ typedef struct _MPT_ADAPTER
 	dma_addr_t		 HostPageBuffer_dma;
 	int			 mtrr_reg;
 	struct pci_dev		*pcidev;	/* struct pci_dev pointer */
-	int			bars;	/* bitmask of BAR's that must be configured */
+	/* bitmask of BAR's that must be configured */
+	int			bars;
 	int			 msi_enable;
 	u8			__iomem *memmap;	/* mmap address */
 	struct Scsi_Host	*sh;		/* Scsi Host pointer */
@@ -680,7 +686,8 @@ typedef struct _MPT_ADAPTER
 #if defined(CPQ_CIM)
 	u32			 csmi_change_count;	/* count to track all IR
 					events for CSMI */
-	u8			 pci_slot_number; /* ioc page 1 - pci slot number */
+	/* ioc page 1 - pci slot number */
+	u8			 pci_slot_number;
 #endif
 
 	u8			 ir_firmware; /* =1 if IR firmware detected */
@@ -711,11 +718,12 @@ typedef struct _MPT_ADAPTER
 	u8			 fw_events_off; /* if '1', then ignore events */
 	char fw_event_q_name[20];
 
-	struct mptsas_portinfo	*hba_port_info; /* port_info object for the host */
+	/* port_info object for the host */
+	struct mptsas_portinfo	*hba_port_info;
 	u64			 hba_port_sas_addr;
 	u16			 hba_port_num_phy;
 	struct list_head	 sas_device_info_list;
-	struct semaphore	 sas_device_info_mutex;
+	struct mutex		 sas_device_info_mutex;
 	u8			 old_sas_discovery_protocal;
 	u8			 sas_discovery_quiesce_io;
 	int			 sas_index; /* index refrencing */
@@ -735,6 +743,7 @@ typedef struct _MPT_ADAPTER
 	char			 reset_work_q_name[20];
 	struct workqueue_struct *reset_work_q;
 	struct delayed_work	 fault_reset_work;
+	spinlock_t		 fault_reset_work_lock;
 	struct work_struct	 fc_setup_reset_work;
 	struct list_head	 fc_rports;
 	struct work_struct	 fc_lsc_work;
@@ -743,9 +752,12 @@ typedef struct _MPT_ADAPTER
 	struct work_struct	 fc_rescan_work;
 	char			 fc_rescan_work_q_name[20];
 	struct workqueue_struct *fc_rescan_work_q;
-	unsigned long		  hard_resets;		/* driver forced bus resets count */
-	unsigned long		  soft_resets;		/* fw/external bus resets count */
-	unsigned long		  timeouts;		/* cmd timeouts */
+	/* driver forced bus resets count */
+	unsigned long		  hard_resets;
+	/* fw/external bus resets count */
+	unsigned long		  soft_resets;
+	/* cmd timeouts */
+	unsigned long		  timeouts;
 	struct scsi_cmnd	**ScsiLookup;
 	spinlock_t		  scsi_lookup_lock;
 	int			  sdev_queue_depth;	/* sdev queue depth */
@@ -907,10 +919,14 @@ extern int	 mpt_config(MPT_ADAPTER *ioc,
 extern int	 mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size);
 extern void	 mpt_free_fw_memory(MPT_ADAPTER *ioc);
 extern int	 mpt_findImVolumes(MPT_ADAPTER *ioc);
-extern int	 mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);
-extern int	 mpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num, pRaidPhysDiskPage0_t phys_disk);
-extern int	 mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num, pRaidPhysDiskPage1_t phys_disk);
-extern int	 mpt_raid_phys_disk_get_num_paths(MPT_ADAPTER *ioc, u8 phys_disk_num);
+extern int	 mptbase_sas_persist_operation(MPT_ADAPTER *ioc,
+    u8 persist_opcode);
+extern int	 mpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num,
+    pRaidPhysDiskPage0_t phys_disk);
+extern int	 mpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num,
+    pRaidPhysDiskPage1_t phys_disk);
+extern int	 mpt_raid_phys_disk_get_num_paths(MPT_ADAPTER *ioc,
+    u8 phys_disk_num);
 
 extern int	 mpt_set_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc);
 extern void	 mpt_clear_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc);
@@ -920,7 +936,6 @@ extern void	 mpt_halt_firmware(MPT_ADAPT
  *  Public data decl's...
  */
 extern struct list_head	  ioc_list;
-extern struct proc_dir_entry	*mpt_proc_root_dir;
 extern int mpt_debug_level;
 extern int mpt_fwfault_debug;
 
Index: linux-2.6.27/drivers/message/fusion/mptctl.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptctl.c
+++ linux-2.6.27/drivers/message/fusion/mptctl.c
@@ -75,7 +75,7 @@
 #if defined(CPQ_CIM)
 #include "mptsas.h"
 #include "csmi/csmisas.h"
-#endif // CPQ_CIM
+#endif
 
 #if defined(DIAG_BUFFER_SUPPORT)
 #include "rejected_ioctls/diag_buffer.h"
@@ -148,7 +148,7 @@ static int csmisas_task_managment(unsign
 static int csmisas_phy_control(unsigned long arg);
 static int csmisas_get_connector_info(unsigned long arg);
 static int csmisas_get_location(unsigned long arg);
-#endif // CPQ_CIM
+#endif
 
 #if defined(DIAG_BUFFER_SUPPORT)
 /* diag_buffer proto's */
@@ -157,7 +157,7 @@ static int mptctl_release_diag_buffer(un
 static int mptctl_unregister_diag_buffer(unsigned long arg);
 static int mptctl_query_diag_buffer(unsigned long arg);
 static int mptctl_read_diag_buffer(unsigned long arg);
-#endif // DIAG_BUFFER_SUPPORT
+#endif
 
 static int  mptctl_probe(struct pci_dev *, const struct pci_device_id *);
 static void mptctl_remove(struct pci_dev *);
@@ -279,7 +279,8 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 		    le32_to_cpu(reply->u.reply.IOCLogInfo)));
 
 	if ((req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) ||
-		(req->u.hdr.Function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+		(req->u.hdr.Function
+			 == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
 
 		if (reply->u.sreply.SCSIStatus || reply->u.sreply.SCSIState)
 			dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
@@ -290,7 +291,8 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 			le16_to_cpu(reply->u.sreply.TaskTag),
 			le32_to_cpu(reply->u.sreply.TransferCount)));
 
-		if (reply->u.sreply.SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
+		if (reply->u.sreply.SCSIState
+		    & MPI_SCSI_STATE_AUTOSENSE_VALID) {
 			sz = req->u.scsireq.SenseBufferLength;
 			req_index =
 			    le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);
@@ -324,7 +326,8 @@ mptctl_taskmgmt_reply(MPT_ADAPTER *ioc, 
 	if (!mf)
 		return 0;
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt completed (mf=%p, mr=%p)\n",
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+	       "TaskMgmt completed (mf=%p, mr=%p)\n",
 	    ioc->name, mf, mr));
 
 	ioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;
@@ -365,8 +368,8 @@ mptctl_bus_reset(MPT_ADAPTER *ioc, u8 fu
 	/* bus reset is only good for SCSI IO, RAID PASSTHRU */
 	if (!(function == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) ||
 	    (function == MPI_FUNCTION_SCSI_IO_REQUEST)) {
-		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT "TaskMgmt, not SCSI_IO!!\n",
-				ioc->name));
+		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT
+			"TaskMgmt, not SCSI_IO!!\n", ioc->name));
 		return -EPERM;
 	}
 
@@ -381,8 +384,8 @@ mptctl_bus_reset(MPT_ADAPTER *ioc, u8 fu
 	/* Send request
 	 */
 	if ((mf = mpt_get_msg_frame(mptctl_taskmgmt_id, ioc)) == NULL) {
-		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT "TaskMgmt, no msg frames!!\n",
-				ioc->name));
+		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT
+			"TaskMgmt, no msg frames!!\n", ioc->name));
 		mpt_clear_taskmgmt_in_progress_flag(ioc);
 		retval = -ENOMEM;
 		goto mptctl_bus_reset_done;
@@ -408,20 +411,21 @@ mptctl_bus_reset(MPT_ADAPTER *ioc, u8 fu
 		pScsiTm->Reserved2[ii] = 0;
 
 	switch (ioc->bus_type) {
-		case FC:
-			timeout = 40;
-			break;
-		case SAS:
-			timeout = 30;
-			break;
-		case SPI:
-		default:
-			timeout = 2;
-			break;
+	case FC:
+		timeout = 40;
+		break;
+	case SAS:
+		timeout = 30;
+		break;
+	case SPI:
+	default:
+		timeout = 10;
+		break;
 	}
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt type=%d timeout=%ld\n",
-	    ioc->name, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS, timeout));
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"TaskMgmt type=%d timeout=%ld\n", ioc->name,
+		MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS, timeout));
 
 	INITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)
 	CLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)
@@ -431,9 +435,10 @@ mptctl_bus_reset(MPT_ADAPTER *ioc, u8 fu
 		mpt_put_msg_frame_hi_pri(mptctl_taskmgmt_id, ioc, mf);
 	else {
 		retval = mpt_send_handshake_request(mptctl_taskmgmt_id, ioc,
-		    sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP);
+		    sizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);
 		if (retval != 0) {
-			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "TaskMgmt send_handshake FAILED!"
+			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
+				"TaskMgmt send_handshake FAILED!"
 				" (ioc %p, mf %p, rc=%d) \n", ioc->name,
 				ioc, mf, retval));
 			mpt_clear_taskmgmt_in_progress_flag(ioc);
@@ -498,11 +503,10 @@ mptctl_timeout_expired(MPT_ADAPTER *ioc,
 	unsigned long flags;
 
 	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": %s\n",
-		ioc->name, __FUNCTION__));
+		ioc->name, __func__));
 
-	if(mpt_fwfault_debug)
+	if (mpt_fwfault_debug)
 		mpt_halt_firmware(ioc);
-
 	spin_lock_irqsave(&ioc->taskmgmt_lock, flags);
 	if (ioc->ioc_reset_in_progress) {
 		spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
@@ -540,15 +544,15 @@ mptctl_ioc_reset(MPT_ADAPTER *ioc, int r
 	switch(reset_phase) {
 	case MPT_IOC_SETUP_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_POST_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_PENDING) {
 			ioc->ioctl_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;
 			complete(&ioc->ioctl_cmds.done);
@@ -571,13 +575,11 @@ mptctl_event_process(MPT_ADAPTER *ioc, E
 	event = le32_to_cpu(pEvReply->Event) & 0xFF;
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s() called\n",
-	    ioc->name, __FUNCTION__));
+	    ioc->name, __func__));
 	if(async_queue == NULL)
 		return 1;
 
 	/* Raise SIGIO for persistent events.
-	 * TODO - this define is not in MPI spec yet,
-	 * but they plan to set it to 0x21
 	 */
 	 if (event == 0x21 ) {
 		ioc->aen_event_read_flag=1;
@@ -660,8 +662,9 @@ __mptctl_ioctl(struct file *file, unsign
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnumX);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnumX);
 		return -ENODEV;
 	}
 
@@ -700,9 +703,9 @@ __mptctl_ioctl(struct file *file, unsign
 		return csmisas_get_cntlr_status(arg);
 	} else if (cmd == CC_CSMI_SAS_GET_SCSI_ADDRESS) {
 		return csmisas_get_scsi_address(arg);
-	} else if (cmd == CC_CSMI_SAS_GET_DEVICE_ADDRESS){
+	} else if (cmd == CC_CSMI_SAS_GET_DEVICE_ADDRESS) {
 		return csmisas_get_device_address(arg);
-#endif // CPQ_CIM
+#endif
 	}
 
 	/* All of these commands require an interrupt or
@@ -711,8 +714,6 @@ __mptctl_ioctl(struct file *file, unsign
 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
 		return ret;
 
-//	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT ": mptctl_ioctl()\n", iocp->name));
-
 	if (cmd == MPTFWDOWNLOAD)
 		ret = mptctl_fw_download(arg);
 	else if (cmd == MPTCOMMAND)
@@ -763,7 +764,7 @@ __mptctl_ioctl(struct file *file, unsign
 		ret = csmisas_get_connector_info(arg);
 	else if (cmd == CC_CSMI_SAS_GET_LOCATION)
 		ret = csmisas_get_location(arg);
-#endif // CPQ_CIM
+#endif
 
 #if defined(DIAG_BUFFER_SUPPORT)
 /* diag_buffer requiring fw calls*/
@@ -773,7 +774,7 @@ __mptctl_ioctl(struct file *file, unsign
 		ret = mptctl_release_diag_buffer(arg);
 	else if (cmd == MPTDIAGREADBUFFER)
 		ret = mptctl_read_diag_buffer(arg);
-#endif // DIAG_BUFFER_SUPPORT
+#endif
 	else
 		ret = -EINVAL;
 
@@ -807,8 +808,9 @@ static int mptctl_do_reset(unsigned long
 
 	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s@%d::mptctl_do_reset - ioc%d not found!\n",
-				__FILE__, __LINE__, krinfo.hdr.iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s@%d::%s - ioc%d not found!\n",
+			    __FILE__, __LINE__, __func__,  krinfo.hdr.iocnum);
 		return -ENODEV; /* (-6) No such device or address */
 	}
 
@@ -898,7 +900,8 @@ mptctl_do_fw_download(int ioc, char __us
 
 	if (mpt_verify_adapter(ioc, &iocp) < 0) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "ioctl_fwdl - ioc%d not found!\n", ioc);
+			printk(KERN_DEBUG MYNAM
+			    "ioctl_fwdl - ioc%d not found!\n", ioc);
 		return -ENODEV; /* (-6) No such device or address */
 	} else {
 
@@ -982,7 +985,7 @@ mptctl_do_fw_download(int ioc, char __us
 			/ iocp->SGE_size;
 	if (numfrags > maxfrags) {
 		ret = -EMLINK;
- 		goto fwdl_out;
+		goto fwdl_out;
 	}
 
 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: sgl buffer = %p, sgfrags = %d\n",
@@ -1036,7 +1039,7 @@ mptctl_do_fw_download(int ioc, char __us
 	timeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);
 	if (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		ret = -ETIME;
-		printk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __FUNCTION__);
+		printk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __func__);
 		if (iocp->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(iocp, mf);
 			goto fwdl_out;
@@ -1047,7 +1050,7 @@ mptctl_do_fw_download(int ioc, char __us
 	}
 
 	if (!(iocp->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {
-		printk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __FUNCTION__);
+		printk(MYIOC_s_WARN_FMT "%s: failed\n", iocp->name, __func__);
 		mpt_free_msg_frame(iocp, mf);
 		ret = -ENODATA;
 		goto fwdl_out;
@@ -1059,10 +1062,12 @@ mptctl_do_fw_download(int ioc, char __us
 	ReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;
 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
-		printk(MYIOC_s_INFO_FMT ": F/W update successfully sent!\n", iocp->name);
+		printk(MYIOC_s_INFO_FMT
+		    ": F/W update successfully sent!\n", iocp->name);
 		return 0;
 	} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {
-		printk(MYIOC_s_WARN_FMT "Hmmm...  doesn't support F/W download?\n",
+		printk(MYIOC_s_WARN_FMT
+		    "Hmmm...  doesn't support F/W download?\n",
 		    iocp->name);
 		printk(MYIOC_s_WARN_FMT "(time to go bang on somebodies door)\n",
 		    iocp->name);
@@ -1177,7 +1182,8 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 			bytes_allocd += this_alloc;
 			sgl->FlagsLength = (0x10000000|sgdir|this_alloc);
 			if (ioc->sg_addr_size == sizeof(u64))
-				sgl->FlagsLength |= MPT_SGE_FLAGS_64_BIT_ADDRESSING;
+				sgl->FlagsLength
+				    |= MPT_SGE_FLAGS_64_BIT_ADDRESSING;
 			dma_addr = pci_map_single(ioc->pcidev, buflist[buflist_ent].kptr, this_alloc, dir);
 			sgl->Address = dma_addr;
 
@@ -1362,8 +1368,9 @@ mptctl_getiocinfo (unsigned long arg, un
 	if (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			   "%s::%s @%d - ioc%d not found!\n",
+			   __FILE__, __func__,  __LINE__, iocnum);
 		kfree(karg);
 		return -ENODEV;
 	}
@@ -1498,8 +1505,9 @@ mptctl_gettargetinfo (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+				__FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1514,7 +1522,8 @@ mptctl_gettargetinfo (unsigned long arg)
 	port = karg.hdr.port;
 
 	if (maxWordsLeft <= 0) {
-		printk(MYIOC_s_ERR_FMT "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+		printk(MYIOC_s_ERR_FMT
+		    "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
 		    ioc->name, __FILE__, __LINE__);
 		return -ENOMEM;
 	}
@@ -1535,7 +1544,8 @@ mptctl_gettargetinfo (unsigned long arg)
 	 */
 	pmem = kzalloc(numBytes, GFP_KERNEL);
 	if (!pmem) {
-		printk(MYIOC_s_ERR_FMT "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+		printk(MYIOC_s_ERR_FMT
+		    "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
 		    ioc->name, __FILE__, __LINE__);
 		return -ENOMEM;
 	}
@@ -1615,8 +1625,9 @@ mptctl_readtest (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_readtest() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1677,8 +1688,9 @@ mptctl_eventquery (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1717,8 +1729,9 @@ mptctl_eventenable (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1730,7 +1743,8 @@ mptctl_eventenable (unsigned long arg)
 		int sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
 		ioc->events = kzalloc(sz, GFP_KERNEL);
 		if (!ioc->events) {
-			printk(MYIOC_s_ERR_FMT "Insufficient memory to add adapter!\n",
+			printk(MYIOC_s_ERR_FMT
+			    "Insufficient memory to add adapter!\n",
 			    ioc->name);
 			return -ENOMEM;
 		}
@@ -1766,8 +1780,9 @@ mptctl_eventreport (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1821,8 +1836,9 @@ mptctl_replace_fw (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1870,7 +1886,8 @@ mptctl_replace_fw (unsigned long arg)
  *
  * Outputs:	None.
  * Return:	0 if successful
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		not complete.
  *		-EFAULT if data unavailable
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
@@ -1896,8 +1913,9 @@ mptctl_mpt_command (unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -1911,7 +1929,8 @@ mptctl_mpt_command (unsigned long arg)
  *
  * Outputs:	None.
  * Return:	0 if successful
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		not complete.
  *		-EFAULT if data unavailable
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
@@ -1948,8 +1967,9 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -2194,10 +2214,12 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	{
 		SCSITaskMgmt_t	*pScsiTm;
 		pScsiTm = (SCSITaskMgmt_t *)mf;
-		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\tTaskType=0x%x MsgFlags=0x%x "
-		    "TaskMsgContext=0x%x id=%d channel=%d\n", ioc->name, pScsiTm->TaskType,
-		    le32_to_cpu(pScsiTm->TaskMsgContext), pScsiTm->MsgFlags,
-		    pScsiTm->TargetID, pScsiTm->Bus));
+		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"\tTaskType=0x%x MsgFlags=0x%x "
+			"TaskMsgContext=0x%x id=%d channel=%d\n",
+			ioc->name, pScsiTm->TaskType,
+			le32_to_cpu(pScsiTm->TaskMsgContext),
+			pScsiTm->MsgFlags, pScsiTm->TargetID, pScsiTm->Bus));
 		break;
 	}
 
@@ -2286,9 +2308,9 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		/* Set up the dataOut memory allocation */
 		if (karg.dataOutSize > 0) {
 			if (karg.dataInSize > 0) {
-				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+				flagsLength = (MPI_SGE_FLAGS_SIMPLE_ELEMENT |
 						MPI_SGE_FLAGS_END_OF_BUFFER |
-						MPI_SGE_FLAGS_DIRECTION )
+						MPI_SGE_FLAGS_DIRECTION)
 						<< MPI_SGE_FLAGS_SHIFT;
 			} else {
 				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
@@ -2365,7 +2387,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			mpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);
 		else {
 			rc = mpt_send_handshake_request(mptctl_id, ioc,
-			    sizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);
+			    sizeof(SCSITaskMgmt_t), (u32 *)mf, CAN_SLEEP);
 			if (rc != 0) {
 				dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				    "send_handshake FAILED! (ioc %p, mf %p)\n",
@@ -2381,16 +2403,16 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 
 	/* Now wait for the command to complete */
 	timeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;
-	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done, HZ*timeout);
+	timeleft =
+	    wait_for_completion_timeout(&ioc->ioctl_cmds.done, HZ*timeout);
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -ETIME;
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "%s: TIMED OUT!\n",
-		    ioc->name, __FUNCTION__));
+		    ioc->name, __func__));
 		if (function == MPI_FUNCTION_SCSI_TASK_MGMT)
 			mutex_unlock(&ioc->taskmgmt_cmds.mutex);
-		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
+		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)
 			goto done_free_mem;
-		}
 		if (!timeleft) {
 			mptctl_timeout_expired(ioc, mf);
 			mf = NULL;
@@ -2408,7 +2430,8 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	 */
 	if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) {
 		if (karg.maxReplyBytes < ioc->reply_sz) {
-			 sz = min(karg.maxReplyBytes, 4*ioc->ioctl_cmds.reply[2]);
+			 sz = min(karg.maxReplyBytes,
+			     4*ioc->ioctl_cmds.reply[2]);
 		} else {
 			 sz = min(ioc->reply_sz, 4*ioc->ioctl_cmds.reply[2]);
 		}
@@ -2430,7 +2453,8 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_SENSE_VALID) {
 		sz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
 		if (sz > 0) {
-			if (copy_to_user(karg.senseDataPtr, ioc->ioctl_cmds.sense, sz)) {
+			if (copy_to_user(karg.senseDataPtr,
+				ioc->ioctl_cmds.sense, sz)) {
 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
 				"Unable to write sense data to user %p\n",
 				ioc->name, __FILE__, __LINE__,
@@ -2488,7 +2512,8 @@ done_free_mem:
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		 not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
@@ -2499,7 +2524,7 @@ mptctl_hp_hostinfo(unsigned long arg, un
 	hp_host_info_t	__user *uarg = (void __user *) arg;
 	MPT_ADAPTER		*ioc;
 	struct pci_dev		*pdev;
-	char			*pbuf=NULL;
+	char			*pbuf = NULL;
 	dma_addr_t		buf_dma;
 	hp_host_info_t		karg;
 	int			iocnum;
@@ -2530,8 +2555,9 @@ mptctl_hp_hostinfo(unsigned long arg, un
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
@@ -2619,7 +2645,7 @@ mptctl_hp_hostinfo(unsigned long arg, un
 	 */
 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames!!\n",
-		    ioc->name,__FUNCTION__));
+		    ioc->name,__func__));
 		retval = -ENOMEM;
 		goto out;
 	}
@@ -2644,16 +2670,19 @@ mptctl_hp_hostinfo(unsigned long arg, un
 		retval = -ENOMEM;
 		goto out;
 	}
-	ioc->add_sge((char *)&IstwiRWRequest->SGL, (MPT_SGE_FLAGS_SSIMPLE_READ|4),buf_dma);
+	ioc->add_sge((char *)&IstwiRWRequest->SGL,
+	    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);
 
 	retval = 0;
-	SET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context, IstwiRWRequest->MsgContext);
+	SET_MGMT_MSG_CONTEXT(ioc->ioctl_cmds.msg_context,
+	    IstwiRWRequest->MsgContext);
 	INITIALIZE_MGMT_STATUS(ioc->ioctl_cmds.status)
 	mpt_put_msg_frame(mptctl_id, ioc, mf);
-	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done, HZ*MPT_IOCTL_DEFAULT_TIMEOUT);
+	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,
+	    HZ*MPT_IOCTL_DEFAULT_TIMEOUT);
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		retval = -ETIME;
-		printk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name, __FUNCTION__);
+		printk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name, __func__);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
 			goto out;
@@ -2701,7 +2730,8 @@ mptctl_hp_hostinfo(unsigned long arg, un
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
@@ -2732,12 +2762,14 @@ mptctl_hp_targetinfo(unsigned long arg)
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 		(ioc == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum);
+			printk(KERN_DEBUG MYNAM
+			    "%s::%s @%d - ioc%d not found!\n",
+			    __FILE__, __func__,  __LINE__, iocnum);
 		return -ENODEV;
 	}
 
-	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": mptctl_hp_targetinfo called.\n",
+	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		": mptctl_hp_targetinfo called.\n",
 	    ioc->name));
 	/*  There is nothing to do for FCP parts.
 	 */
@@ -2889,8 +2921,9 @@ compat_mptfwxfer_ioctl(struct file *filp
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n",
-				__LINE__, iocnumX);
+			printk(KERN_DEBUG MYNAM
+			    "::%s @%d - ioc%d not found!\n", __func__,
+			    __LINE__, iocnumX);
 		return -ENODEV;
 	}
 
@@ -2930,8 +2963,9 @@ compat_mpt_command(struct file *filp, un
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
 		if (mpt_debug_level & MPT_DEBUG_IOCTL)
-		printk(KERN_DEBUG MYNAM "::compat_mpt_command @%d - ioc%d not found!\n",
-				__LINE__, iocnumX);
+			printk(KERN_DEBUG MYNAM
+			    "::%s @%d - ioc%d not found!\n",
+			    __func__, __LINE__, iocnumX);
 		return -ENODEV;
 	}
 
@@ -3144,7 +3178,7 @@ static void mptctl_exit(void)
 
 #if defined(CPQ_CIM)
 #include "csmi/csmisas.c"
-#endif // CPQ_CIM
+#endif
 
 #if defined(DIAG_BUFFER_SUPPORT)
 #include "rejected_ioctls/diag_buffer.c"
Index: linux-2.6.27/drivers/message/fusion/mptfc.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptfc.c
+++ linux-2.6.27/drivers/message/fusion/mptfc.c
@@ -270,28 +270,28 @@ static int
 mptfc_abort(struct scsi_cmnd *SCpnt)
 {
 	return
-	    mptfc_block_error_handler(SCpnt, mptscsih_abort, __FUNCTION__);
+	    mptfc_block_error_handler(SCpnt, mptscsih_abort, __func__);
 }
 
 static int
 mptfc_dev_reset(struct scsi_cmnd *SCpnt)
 {
 	return
-	    mptfc_block_error_handler(SCpnt, mptscsih_dev_reset, __FUNCTION__);
+	    mptfc_block_error_handler(SCpnt, mptscsih_dev_reset, __func__);
 }
 
 static int
 mptfc_bus_reset(struct scsi_cmnd *SCpnt)
 {
 	return
-	    mptfc_block_error_handler(SCpnt, mptscsih_bus_reset, __FUNCTION__);
+	    mptfc_block_error_handler(SCpnt, mptscsih_bus_reset, __func__);
 }
 
 static int
 mptfc_host_reset(struct scsi_cmnd *SCpnt)
 {
 	return
-	    mptfc_block_error_handler(SCpnt, mptscsih_host_reset, __FUNCTION__);
+	    mptfc_block_error_handler(SCpnt, mptscsih_host_reset, __func__);
 }
 
 static void
@@ -553,7 +553,6 @@ mptfc_target_destroy(struct scsi_target 
 	struct fc_rport		*rport;
 	struct mptfc_rport_info *ri;
 
-	printk("%s - starget=%p\n", __FUNCTION__, starget);
 	rport = starget_to_rport(starget);
 	if (rport) {
 		ri = *((struct mptfc_rport_info **)rport->dd_data);
@@ -994,7 +993,8 @@ mptfc_SetFcPortPage1_defaults(MPT_ADAPTE
 	#define OFF_FLAGS (MPI_FCPORTPAGE1_FLAGS_VERBOSE_RESCAN_EVENTS)
 
 	for (ii=0; ii<ioc->facts.NumberOfPorts; ii++) {
-		if ((rc = mptfc_GetFcPortPage1(ioc, ii)) < 0)
+		rc = mptfc_GetFcPortPage1(ioc, ii);
+		if (rc < 0)
 			return rc;
 		pp1 = ioc->fc_data.fc_port_page1[ii].data;
 		if ((pp1->InitiatorDeviceTimeout == MPTFC_FW_DEVICE_TIMEOUT)
@@ -1006,7 +1006,8 @@ mptfc_SetFcPortPage1_defaults(MPT_ADAPTE
 		pp1->InitiatorIoPendTimeout = MPTFC_FW_IO_PEND_TIMEOUT;
 		pp1->Flags &= ~OFF_FLAGS;
 		pp1->Flags |= ON_FLAGS;
-		if ((rc = mptfc_WriteFcPortPage1(ioc, ii)) < 0)
+		rc = mptfc_WriteFcPortPage1(ioc, ii);
+		if (rc < 0)
 			return rc;
 	}
 	return 0;
@@ -1170,8 +1171,9 @@ mptfc_rescan_devices(struct work_struct 
 	 * if cannot set defaults, something's really wrong, bail out
 	 */
 
-	if ((rc = mptfc_SetFcPortPage1_defaults(ioc)) < 0) {
-		dfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT
+	rc = mptfc_SetFcPortPage1_defaults(ioc);
+	if (rc < 0) {
+		dfcprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		    "mptfc_rescan.%d: unable to set PP1 defaults, rc %d.\n",
 		    ioc->name, ioc->sh->host_no, rc));
 		return;
@@ -1373,8 +1375,9 @@ mptfc_probe(struct pci_dev *pdev, const 
 
 	/* initialize workqueue */
 
-	snprintf(ioc->fc_rescan_work_q_name, sizeof(ioc->fc_rescan_work_q_name), "mptfc_wq_%d",
-		sh->host_no);
+	snprintf(ioc->fc_rescan_work_q_name,
+	    sizeof(ioc->fc_rescan_work_q_name), "mptfc_wq_%d",
+	    sh->host_no);
 	ioc->fc_rescan_work_q =
 		create_singlethread_workqueue(ioc->fc_rescan_work_q_name);
 	if (!ioc->fc_rescan_work_q)
@@ -1462,10 +1465,10 @@ mptfc_ioc_reset(MPT_ADAPTER *ioc, int re
 	if ((ioc->bus_type != FC) || (!rc))
 		return rc;
 
-	switch(reset_phase) {
+	switch (reset_phase) {
 	case MPT_IOC_SETUP_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));
 		spin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);
 		if (ioc->fc_rescan_work_q) {
 			queue_work(ioc->fc_rescan_work_q,
@@ -1475,11 +1478,11 @@ mptfc_ioc_reset(MPT_ADAPTER *ioc, int re
 		break;
 	case MPT_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_POST_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_POST_RESET\n",  ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_POST_RESET\n",  ioc->name, __func__));
 		spin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);
 		if (ioc->fc_rescan_work_q) {
 			queue_work(ioc->fc_rescan_work_q,
@@ -1493,11 +1496,12 @@ mptfc_ioc_reset(MPT_ADAPTER *ioc, int re
 	return 1;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptfc_init - Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.
  *
  *	Returns 0 for success, non-zero for failure.
- **/
+ */
 static int __init
 mptfc_init(void)
 {
@@ -1529,11 +1533,12 @@ mptfc_init(void)
 	return error;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptfc_remove - Remove fc infrastructure for devices
  *	@pdev: Pointer to pci_dev structure
  *
- **/
+ */
 static void __devexit
 mptfc_remove(struct pci_dev *pdev)
 {
@@ -1543,8 +1548,6 @@ mptfc_remove(struct pci_dev *pdev)
 	unsigned long		flags;
 	int			ii;
 
-	printk("%s -pdev=%p\n", __FUNCTION__, pdev);
-
 	/* destroy workqueue */
 	if ((work_q=ioc->fc_rescan_work_q)) {
 		spin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);
Index: linux-2.6.27/drivers/message/fusion/mptlan.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptlan.c
+++ linux-2.6.27/drivers/message/fusion/mptlan.c
@@ -614,7 +614,7 @@ mpt_lan_send_turbo(struct net_device *de
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: @%s, skb %p sent.\n",
 			IOC_AND_NETDEV_NAMES_s_s(dev),
-			__FUNCTION__, sent));
+			__func__, sent));
 
 	priv->SendCtl[ctx].skb = NULL;
 	pci_unmap_single(mpt_dev->pcidev, priv->SendCtl[ctx].dma,
@@ -680,7 +680,7 @@ mpt_lan_send_reply(struct net_device *de
 
 		dioprintk((KERN_INFO MYNAM ": %s/%s: @%s, skb %p sent.\n",
 				IOC_AND_NETDEV_NAMES_s_s(dev),
-				__FUNCTION__, sent));
+				__func__, sent));
 
 		priv->SendCtl[ctx].skb = NULL;
 		pci_unmap_single(mpt_dev->pcidev, priv->SendCtl[ctx].dma,
@@ -719,7 +719,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 	u16 cur_naa = 0x1000;
 
 	dioprintk((KERN_INFO MYNAM ": %s called, skb_addr = %p\n",
-			__FUNCTION__, skb));
+			__func__, skb));
 
 	spin_lock_irqsave(&priv->txfidx_lock, flags);
 	if (priv->mpt_txfidx_tail < 0) {
@@ -727,7 +727,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 		spin_unlock_irqrestore(&priv->txfidx_lock, flags);
 
 		printk (KERN_ERR "%s: no tx context available: %u\n",
-			__FUNCTION__, priv->mpt_txfidx_tail);
+			__func__, priv->mpt_txfidx_tail);
 		return 1;
 	}
 
@@ -737,7 +737,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 		spin_unlock_irqrestore(&priv->txfidx_lock, flags);
 
 		printk (KERN_ERR "%s: Unable to alloc request frame\n",
-			__FUNCTION__);
+			__func__);
 		return 1;
 	}
 
@@ -1213,7 +1213,7 @@ mpt_lan_post_receive_buckets(struct mpt_
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: @%s, Start_buckets = %u, buckets_out = %u\n",
 			IOC_AND_NETDEV_NAMES_s_s(dev),
-			__FUNCTION__, buckets, curr));
+			__func__, buckets, curr));
 
 	max = (mpt_dev->req_sz - MPT_LAN_RECEIVE_POST_REQUEST_SIZE) /
 			(MPT_LAN_TRANSACTION32_SIZE + sizeof(SGESimple64_t));
@@ -1222,9 +1222,9 @@ mpt_lan_post_receive_buckets(struct mpt_
 		mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 		if (mf == NULL) {
 			printk (KERN_ERR "%s: Unable to alloc request frame\n",
-				__FUNCTION__);
+				__func__);
 			dioprintk((KERN_ERR "%s: %u buckets remaining\n",
-				 __FUNCTION__, buckets));
+				 __func__, buckets));
 			goto out;
 		}
 		pRecvReq = (LANReceivePostRequest_t *) mf;
@@ -1249,7 +1249,7 @@ mpt_lan_post_receive_buckets(struct mpt_
 			spin_lock_irqsave(&priv->rxfidx_lock, flags);
 			if (priv->mpt_rxfidx_tail < 0) {
 				printk (KERN_ERR "%s: Can't alloc context\n",
-					__FUNCTION__);
+					__func__);
 				spin_unlock_irqrestore(&priv->rxfidx_lock,
 						       flags);
 				break;
@@ -1272,7 +1272,7 @@ mpt_lan_post_receive_buckets(struct mpt_
 				if (skb == NULL) {
 					printk (KERN_WARNING
 						MYNAM "/%s: Can't alloc skb\n",
-						__FUNCTION__);
+						__func__);
 					priv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;
 					spin_unlock_irqrestore(&priv->rxfidx_lock, flags);
 					break;
@@ -1310,7 +1310,7 @@ mpt_lan_post_receive_buckets(struct mpt_
 
 		if (pSimple == NULL) {
 /**/			printk (KERN_WARNING MYNAM "/%s: No buckets posted\n",
-/**/				__FUNCTION__);
+/**/				__func__);
 			mpt_free_msg_frame(mpt_dev, mf);
 			goto out;
 		}
@@ -1334,9 +1334,9 @@ mpt_lan_post_receive_buckets(struct mpt_
 
 out:
 	dioprintk((KERN_INFO MYNAM "/%s: End_buckets = %u, priv->buckets_out = %u\n",
-		  __FUNCTION__, buckets, atomic_read(&priv->buckets_out)));
+		  __func__, buckets, atomic_read(&priv->buckets_out)));
 	dioprintk((KERN_INFO MYNAM "/%s: Posted %u buckets and received %u back\n",
-	__FUNCTION__, priv->total_posted, priv->total_received));
+	__func__, priv->total_posted, priv->total_received));
 
 	clear_bit(0, &priv->post_buckets_active);
 }
Index: linux-2.6.27/drivers/message/fusion/mptsas.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptsas.c
+++ linux-2.6.27/drivers/message/fusion/mptsas.c
@@ -117,19 +117,23 @@ static u8	mptsasInternalCtx = MPT_MAX_PR
 static u8	mptsasMgmtCtx = MPT_MAX_PROTOCOL_DRIVERS;
 static u8	mptsasDeviceResetCtx = MPT_MAX_PROTOCOL_DRIVERS;
 
-static inline void mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy);
-static struct mptsas_phyinfo * mptsas_find_phyinfo_by_sas_address(MPT_ADAPTER *ioc,
-	u64 sas_address);
-static int mptsas_sas_device_pg0(MPT_ADAPTER *ioc, struct mptsas_devinfo *device_info,
-	u32 form, u32 form_specific);
-static int mptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc, struct mptsas_enclosure *enclosure,
-		u32 form, u32 form_specific);
-
-static int mptsas_add_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info);
-static void mptsas_del_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info);
-static void mptsas_expander_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info);
-static int mptsas_sas_expander_pg0(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info,
-		u32 form, u32 form_specific);
+static inline void mptsas_set_rphy(MPT_ADAPTER *ioc,
+    struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy);
+static struct mptsas_phyinfo *mptsas_find_phyinfo_by_sas_address(
+    MPT_ADAPTER *ioc, u64 sas_address);
+static int mptsas_sas_device_pg0(MPT_ADAPTER *ioc,
+    struct mptsas_devinfo *device_info, u32 form, u32 form_specific);
+static int mptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc,
+    struct mptsas_enclosure *enclosure,	u32 form, u32 form_specific);
+
+static int mptsas_add_end_device(MPT_ADAPTER *ioc,
+    struct mptsas_phyinfo *phy_info);
+static void mptsas_del_end_device(MPT_ADAPTER *ioc,
+    struct mptsas_phyinfo *phy_info);
+static void mptsas_expander_delete(MPT_ADAPTER *ioc,
+    struct mptsas_portinfo *port_info);
+static int mptsas_sas_expander_pg0(MPT_ADAPTER *ioc,
+    struct mptsas_portinfo *port_info, u32 form, u32 form_specific);
 static void mptsas_scan_sas_topology(MPT_ADAPTER *ioc);
 static void mptsas_not_responding_devices(MPT_ADAPTER *ioc);
 
@@ -323,7 +327,7 @@ mptsas_add_fw_event(MPT_ADAPTER *ioc, st
 	list_add_tail(&fw_event->list, &ioc->fw_event_list);
 	INIT_DELAYED_WORK(&fw_event->work, mptsas_firmware_event_work);
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "%s: add (fw_event=0x%p)\n",
-	    ioc->name,__FUNCTION__, fw_event));
+	    ioc->name, __func__, fw_event));
 	queue_delayed_work(ioc->fw_event_q, &fw_event->work,
 	    msecs_to_jiffies(delay));
 	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
@@ -337,7 +341,7 @@ mptsas_requeue_fw_event(MPT_ADAPTER *ioc
 	unsigned long flags;
 	spin_lock_irqsave(&ioc->fw_event_lock, flags);
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "%s: reschedule task "
-	    "(fw_event=0x%p)\n", ioc->name,__FUNCTION__, fw_event));
+	    "(fw_event=0x%p)\n", ioc->name, __func__, fw_event));
 	fw_event->retries++;
 	queue_delayed_work(ioc->fw_event_q, &fw_event->work,
 	    msecs_to_jiffies(delay));
@@ -352,13 +356,14 @@ mptsas_free_fw_event(MPT_ADAPTER *ioc, s
 
 	spin_lock_irqsave(&ioc->fw_event_lock, flags);
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "%s: kfree (fw_event=0x%p)\n",
-	    ioc->name,__FUNCTION__, fw_event));
+	    ioc->name, __func__, fw_event));
 	list_del(&fw_event->list);
 	kfree(fw_event);
 	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
 }
 
-/* walk the firmware event queue, and either stop or wait for outstanding events to complete */
+/* walk the firmware event queue, and either stop or wait for
+ * outstanding events to complete */
 static void
 mptsas_cleanup_fw_event_q(MPT_ADAPTER *ioc)
 {
@@ -373,7 +378,7 @@ mptsas_cleanup_fw_event_q(MPT_ADAPTER *i
 		    &hd->target_reset_list, list) {
 			dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 			    "%s: removing target reset for id=%d\n",
-			    ioc->name, __FUNCTION__,
+			    ioc->name, __func__,
 			   target_reset_list->sas_event_data.TargetID));
 			list_del(&target_reset_list->list);
 			kfree(target_reset_list);
@@ -433,7 +438,7 @@ rphy_to_ioc(struct sas_rphy *rphy)
 static struct mptsas_portinfo *
 mptsas_find_portinfo_by_sas_address(MPT_ADAPTER *ioc, u64 sas_address)
 {
-	struct mptsas_portinfo *port_info, *rc=NULL;
+	struct mptsas_portinfo *port_info, *rc = NULL;
 	int i;
 
 	if (sas_address >= ioc->hba_port_sas_addr &&
@@ -523,7 +528,7 @@ mptsas_port_delete(MPT_ADAPTER *ioc, str
 	phy_info = port_info->phy_info;
 
 	dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: [%p]: num_phys=%02d "
-	    "bitmask=0x%016llX\n", ioc->name, __FUNCTION__, port_details,
+	    "bitmask=0x%016llX\n", ioc->name, __func__, port_details,
 	    port_details->num_phys, (unsigned long long)
 	    port_details->phy_bitmask));
 
@@ -659,7 +664,7 @@ mptsas_add_device_component(MPT_ADAPTER 
 	/*
 	 * Delete all matching devices out of the list
 	 */
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,
 	    list) {
 		if (!sas_info->is_logical_volume &&
@@ -700,7 +705,7 @@ mptsas_add_device_component(MPT_ADAPTER 
 	}
 
  out:
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 	return;
 }
 
@@ -745,7 +750,8 @@ mptsas_add_device_component_by_fw(MPT_AD
  *
  **/
 static void
-mptsas_add_device_component_starget_ir(MPT_ADAPTER *ioc, struct scsi_target *starget)
+mptsas_add_device_component_starget_ir(MPT_ADAPTER *ioc,
+    struct scsi_target *starget)
 {
 	CONFIGPARMS			cfg;
 	ConfigPageHeader_t		hdr;
@@ -790,14 +796,14 @@ mptsas_add_device_component_starget_ir(M
 	 */
 	for (i = 0; i < buffer->NumPhysDisks; i++) {
 
-		if(mpt_raid_phys_disk_pg0(ioc,
+		if (mpt_raid_phys_disk_pg0(ioc,
 		    buffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)
 			continue;
 
 		mptsas_add_device_component_by_fw(ioc, phys_disk.PhysDiskBus,
 		    phys_disk.PhysDiskID);
 
-		down(&ioc->sas_device_info_mutex);
+		mutex_lock(&ioc->sas_device_info_mutex);
 		list_for_each_entry(sas_info, &ioc->sas_device_info_list,
 		    list) {
 			if (!sas_info->is_logical_volume &&
@@ -807,13 +813,13 @@ mptsas_add_device_component_starget_ir(M
 				sas_info->volume_id = starget->id;
 			}
 		}
-		up(&ioc->sas_device_info_mutex);
+		mutex_unlock(&ioc->sas_device_info_mutex);
 	}
 
 	/*
 	 * Delete all matching devices out of the list
 	 */
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,
 	    list) {
 		if (sas_info->is_logical_volume && sas_info->fw.id ==
@@ -832,7 +838,7 @@ mptsas_add_device_component_starget_ir(M
 		INIT_LIST_HEAD(&sas_info->list);
 		list_add_tail(&sas_info->list, &ioc->sas_device_info_list);
 	}
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 
  out:
 	if (buffer)
@@ -847,7 +853,8 @@ mptsas_add_device_component_starget_ir(M
  *
  **/
 static void
-mptsas_add_device_component_starget(MPT_ADAPTER *ioc, struct scsi_target *starget)
+mptsas_add_device_component_starget(MPT_ADAPTER *ioc,
+    struct scsi_target *starget)
 {
 	VirtTarget		*vtarget;
 	struct sas_rphy		*rphy;
@@ -906,13 +913,13 @@ mptsas_del_device_components(MPT_ADAPTER
 {
 	struct sas_device_info	*sas_info, *next;
 
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	list_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,
 		list) {
 		list_del(&sas_info->list);
 		kfree(sas_info);
 	}
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 }
 
 /**
@@ -926,7 +933,7 @@ mptsas_del_device_components(MPT_ADAPTER
 static void
 mptsas_setup_wide_ports(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)
 {
-	struct mptsas_portinfo_details * port_details;
+	struct mptsas_portinfo_details *port_details;
 	struct mptsas_phyinfo *phy_info, *phy_info_cmp;
 	u64	sas_address;
 	int	i, j;
@@ -949,9 +956,9 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 		 */
 		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 			"%s: [%p]: deleting phy = %d\n",
-			ioc->name, __FUNCTION__, port_details, i));
+			ioc->name, __func__, port_details, i));
 		port_details->num_phys--;
-		port_details->phy_bitmask &= ~ (1 << phy_info->phy_id);
+		port_details->phy_bitmask &= ~(1 << phy_info->phy_id);
 		memset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));
 		devtprintk(ioc, dev_printk(KERN_DEBUG, &phy_info->phy->dev,
 		    MYIOC_s_FMT "delete phy %d, phy-obj (0x%p)\n", ioc->name,
@@ -966,8 +973,9 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 	phy_info = port_info->phy_info;
 	for (i = 0 ; i < port_info->num_phys ; i++, phy_info++) {
 		sas_address = phy_info->attached.sas_address;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "phy_id=%d sas_address=0x%018llX\n",
-		    ioc->name, i, (unsigned long long)sas_address));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"phy_id=%d sas_address=0x%018llX\n",
+			ioc->name, i, (unsigned long long)sas_address));
 		if (!sas_address)
 			continue;
 		port_details = phy_info->port_details;
@@ -981,13 +989,14 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 				goto out;
 			port_details->num_phys = 1;
 			port_details->port_info = port_info;
-			if (phy_info->phy_id < 64 )
+			if (phy_info->phy_id < 64)
 				port_details->phy_bitmask |=
 				    (1 << phy_info->phy_id);
-			phy_info->sas_port_add_phy=1;
-			dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\t\tForming port\n\t\t"
-			    "phy_id=%d sas_address=0x%018llX\n", ioc->name, i,
-			    (unsigned long long) sas_address));
+			phy_info->sas_port_add_phy = 1;
+			dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+				"\t\tForming port\n\t\t"
+				"phy_id=%d sas_address=0x%018llX\n", ioc->name,
+				i, (unsigned long long) sas_address));
 			phy_info->port_details = port_details;
 		}
 
@@ -1000,7 +1009,7 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 				continue;
 			if (sas_address != phy_info_cmp->attached.sas_address)
 				continue;
-			if (phy_info_cmp->port_details == port_details )
+			if (phy_info_cmp->port_details == port_details)
 				continue;
 			dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 			    "\t\tphy_id=%d sas_address=0x%018llX\n",
@@ -1018,12 +1027,12 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 				if (!phy_info_cmp->port_details->num_phys)
 					kfree(phy_info_cmp->port_details);
 			} else
-				phy_info_cmp->sas_port_add_phy=1;
+				phy_info_cmp->sas_port_add_phy = 1;
 			/*
 			 * Adding a phy to a port
 			 */
 			phy_info_cmp->port_details = port_details;
-			if (phy_info_cmp->phy_id < 64 )
+			if (phy_info_cmp->phy_id < 64)
 				port_details->phy_bitmask |=
 				(1 << phy_info_cmp->phy_id);
 			port_details->num_phys++;
@@ -1038,11 +1047,12 @@ mptsas_setup_wide_ports(MPT_ADAPTER *ioc
 			continue;
 		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		    "%s: [%p]: phy_id=%02d num_phys=%02d "
-		    "bitmask=0x%016llX\n", ioc->name, __FUNCTION__,
+		    "bitmask=0x%016llX\n", ioc->name, __func__,
 		    port_details, i, port_details->num_phys,
 		    (unsigned long long)port_details->phy_bitmask));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\t\tport = %p rphy=%p\n",
-		    ioc->name, port_details->port, port_details->rphy));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"\t\tport = %p rphy=%p\n",
+			ioc->name, port_details->port, port_details->rphy));
 	}
 	dsaswideprintk(ioc, printk("\n"));
 	mutex_unlock(&ioc->sas_topology_mutex);
@@ -1089,7 +1099,7 @@ mptsas_queue_device_delete(MPT_ADAPTER *
 	fw_event = kzalloc(sz, GFP_ATOMIC);
 	if (!fw_event) {
 		printk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n",
-		    ioc->name, __FUNCTION__, __LINE__);
+		    ioc->name, __func__, __LINE__);
 		return;
 	}
 	memcpy(fw_event->event_data, sas_event_data,
@@ -1109,7 +1119,7 @@ mptsas_queue_rescan(MPT_ADAPTER *ioc)
 	fw_event = kzalloc(sz, GFP_ATOMIC);
 	if (!fw_event) {
 		printk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n",
-		    ioc->name, __FUNCTION__, __LINE__);
+		    ioc->name, __func__, __LINE__);
 		return;
 	}
 	fw_event->event = -1;
@@ -1139,8 +1149,9 @@ mptsas_target_reset(MPT_ADAPTER *ioc, u8
 		return 0;
 
 	if ((mf = mpt_get_msg_frame(mptsasDeviceResetCtx, ioc)) == NULL) {
-		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames @%d!!\n",
-		    ioc->name,__FUNCTION__, __LINE__));
+		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT
+			"%s, no msg frames @%d!!\n",
+			ioc->name, __func__, __LINE__));
 		goto out_fail;
 	}
 
@@ -1150,7 +1161,7 @@ mptsas_target_reset(MPT_ADAPTER *ioc, u8
 	/* Format the Request
 	 */
 	pScsiTm = (SCSITaskMgmt_t *) mf;
-	memset (pScsiTm, 0, sizeof(SCSITaskMgmt_t));
+	memset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));
 	pScsiTm->TargetID = id;
 	pScsiTm->Bus = channel;
 	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
@@ -1201,8 +1212,9 @@ mptsas_target_reset_queue(MPT_ADAPTER *i
 	target_reset_list = kzalloc(sizeof(struct mptsas_target_reset_event),
 	    GFP_ATOMIC);
 	if (!target_reset_list) {
-		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, failed to allocate mem @%d..!!\n",
-		    ioc->name,__FUNCTION__, __LINE__));
+		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT
+			"%s, failed to allocate mem @%d..!!\n",
+			ioc->name, __func__, __LINE__));
 		return;
 	}
 
@@ -1227,7 +1239,7 @@ static int
 mptsas_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
 {
 	MPT_SCSI_HOST	*hd = shost_priv(ioc->sh);
-        struct list_head *head = &hd->target_reset_list;
+	struct list_head *head = &hd->target_reset_list;
 	struct mptsas_target_reset_event	*target_reset_list;
 	u8		id, channel;
 	SCSITaskMgmtReply_t *pScsiTmReply;
@@ -1300,7 +1312,8 @@ mptsas_taskmgmt_complete(MPT_ADAPTER *io
 	 */
 	list_del(&target_reset_list->list);
 	if ((mptsas_find_vtarget(ioc, channel, id)) && !ioc->fw_events_off)
-		mptsas_queue_device_delete(ioc, &target_reset_list->sas_event_data);
+		mptsas_queue_device_delete(ioc,
+		    &target_reset_list->sas_event_data);
 
 
 	/*
@@ -1311,8 +1324,8 @@ mptsas_taskmgmt_complete(MPT_ADAPTER *io
 	if (list_empty(head))
 		return 1;
 
-	target_reset_list = list_entry(head->next, struct mptsas_target_reset_event,
-	    list);
+	target_reset_list = list_entry(head->next,
+	    struct mptsas_target_reset_event, list);
 
 	id = target_reset_list->sas_event_data.TargetID;
 	channel = target_reset_list->sas_event_data.Bus;
@@ -1344,19 +1357,19 @@ mptsas_ioc_reset(MPT_ADAPTER *ioc, int r
 	if (!hd->ioc)
 		goto out;
 
-	switch(reset_phase) {
+	switch (reset_phase) {
 	case MPT_IOC_SETUP_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));
 		mptsas_fw_event_off(ioc);
 		break;
 	case MPT_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_POST_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));
 		if (ioc->sas_mgmt.status & MPT_MGMT_STATUS_PENDING) {
 			ioc->sas_mgmt.status |= MPT_MGMT_STATUS_DID_IOCRESET;
 			complete(&ioc->sas_mgmt.done);
@@ -1473,7 +1486,7 @@ mptsas_get_lun_number(MPT_ADAPTER *ioc, 
 	    &lun_data_dma);
 	if (!lun_data) {
 		printk(MYIOC_s_ERR_FMT "%s: pci_alloc_consistent(%d) FAILED!\n",
-		    ioc->name, __FUNCTION__, lun_data_len);
+		    ioc->name, __func__, lun_data_len);
 		rc = -ENOMEM;
 		goto out;
 	}
@@ -1481,7 +1494,7 @@ mptsas_get_lun_number(MPT_ADAPTER *ioc, 
 	iocmd = kzalloc(sizeof(INTERNAL_CMD), GFP_KERNEL);
 	if (!iocmd) {
 		printk(MYIOC_s_ERR_FMT "%s: kzalloc(%zd) FAILED!\n",
-		    ioc->name, __FUNCTION__, sizeof(INTERNAL_CMD));
+		    ioc->name, __func__, sizeof(INTERNAL_CMD));
 		rc = -ENOMEM;
 		goto out;
 	}
@@ -1499,14 +1512,14 @@ mptsas_get_lun_number(MPT_ADAPTER *ioc, 
 	if ((rc = mptscsih_do_cmd(hd, iocmd)) < 0) {
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d: "
 		    "report_luns failed due to rc=0x%x\n", ioc->name,
-		    __FUNCTION__, channel, id, rc);
+		    __func__, channel, id, rc);
 		goto out;
 	}
 
 	if (rc != MPT_SCANDV_GOOD) {
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d: "
 		    "report_luns failed due to rc=0x%x\n", ioc->name,
-		    __FUNCTION__, channel, id, rc);
+		    __func__, channel, id, rc);
 		rc = -rc;
 		goto out;
 	}
@@ -1576,7 +1589,7 @@ mptsas_test_unit_ready(MPT_ADAPTER *ioc,
 	iocmd = kzalloc(sizeof(INTERNAL_CMD), GFP_KERNEL);
 	if (!iocmd) {
 		printk(MYIOC_s_ERR_FMT "%s: kzalloc(%zd) FAILED!\n",
-		__FUNCTION__, ioc->name, sizeof(INTERNAL_CMD));
+		__func__, ioc->name, sizeof(INTERNAL_CMD));
 		return DEVICE_ERROR;
 	}
 
@@ -1595,31 +1608,31 @@ mptsas_test_unit_ready(MPT_ADAPTER *ioc,
 
  retry:
 	devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: fw_channel=%d "
-	    "fw_id=%d retry=%d\n", ioc->name, __FUNCTION__, channel, id, count));
+	    "fw_id=%d retry=%d\n", ioc->name, __func__, channel, id, count));
 	rc = mptscsih_do_cmd(hd, iocmd);
 	devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: rc=0x%02x\n",
-	    ioc->name, __FUNCTION__, rc));
+	    ioc->name, __func__, rc));
 	if (rc < 0) {
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d: "
 		    "tur failed due to timeout\n", ioc->name,
-		    __FUNCTION__, channel, id);
+		    __func__, channel, id);
 		goto tur_done;
 	}
 
-	switch(rc) {
+	switch (rc) {
 	case MPT_SCANDV_GOOD:
 		state = DEVICE_READY;
 		goto tur_done;
 	case MPT_SCANDV_BUSY:
 		devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: "
 		    "fw_channel=%d fw_id=%d : device busy\n",
-		    ioc->name, __FUNCTION__, channel, id));
+		    ioc->name, __func__, channel, id));
 		state = DEVICE_RETRY;
 		break;
 	case MPT_SCANDV_DID_RESET:
 		devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: "
 		    "fw_channel=%d fw_id=%d : did reset\n",
-		    ioc->name, __FUNCTION__, channel, id));
+		    ioc->name, __func__, channel, id));
 		state = DEVICE_RETRY;
 		break;
 	case MPT_SCANDV_SENSE:
@@ -1630,7 +1643,7 @@ mptsas_test_unit_ready(MPT_ADAPTER *ioc,
 		devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: "
 		    "fw_channel=%d fw_id=%d : [sense_key,asc,"
 		    "ascq]: [0x%02x,0x%02x,0x%02x]\n", ioc->name,
-		     __FUNCTION__, channel, id, skey, asc, ascq));
+		     __func__, channel, id, skey, asc, ascq));
 
 		if (skey == UNIT_ATTENTION) {
 			if (!retry_ua) {
@@ -1656,7 +1669,7 @@ mptsas_test_unit_ready(MPT_ADAPTER *ioc,
 				break;
 			}
 		} else if (skey == ILLEGAL_REQUEST) {
-		/* try sending a tur to a non-zero lun number */
+			/* try sending a tur to a non-zero lun number */
 			if (!iocmd->lun && !mptsas_get_lun_number(ioc,
 			    channel, id, &iocmd->lun) && iocmd->lun)
 				goto retry;
@@ -1664,25 +1677,25 @@ mptsas_test_unit_ready(MPT_ADAPTER *ioc,
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d : "
 		    "tur failed due to [sense_key,asc,ascq]: "
 		    "[0x%02x,0x%02x,0x%02x]\n", ioc->name,
-		    __FUNCTION__, channel, id, skey, asc, ascq);
+		    __func__, channel, id, skey, asc, ascq);
 		goto tur_done;
 	case MPT_SCANDV_SELECTION_TIMEOUT:
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d: "
 		    "tur failed due to no device\n", ioc->name,
-		    __FUNCTION__, channel,
+		    __func__, channel,
 		    id);
 		goto tur_done;
 	case MPT_SCANDV_SOME_ERROR:
 		printk(MYIOC_s_ERR_FMT "%s: fw_channel=%d fw_id=%d: "
 		    "tur failed due to some error\n", ioc->name,
-		    __FUNCTION__,
+		    __func__,
 		    channel, id);
 		goto tur_done;
 	default:
 		printk(MYIOC_s_ERR_FMT
 		    "%s: fw_channel=%d fw_id=%d: tur failed due to "
-		    "unknown rc=0x%02x\n", ioc->name, __FUNCTION__,
-		    channel, id, rc );
+		    "unknown rc=0x%02x\n", ioc->name, __func__,
+		    channel, id, rc);
 		goto tur_done;
 	}
  tur_done:
@@ -1705,19 +1718,19 @@ mptsas_issue_tlr(MPT_SCSI_HOST *hd, stru
 	u8		rc;
 	MPT_ADAPTER *ioc = hd->ioc;
 
-	if ( sdev->inquiry[8]  == 'H' &&
+	if (sdev->inquiry[8]  == 'H' &&
 	     sdev->inquiry[9]  == 'P' &&
 	     sdev->inquiry[10] == ' ' &&
 	     sdev->inquiry[11] == ' ' &&
 	     sdev->inquiry[12] == ' ' &&
 	     sdev->inquiry[13] == ' ' &&
 	     sdev->inquiry[14] == ' ' &&
-	     sdev->inquiry[15] == ' ' ) {
+	     sdev->inquiry[15] == ' ') {
 
 		iocmd = kzalloc(sizeof(INTERNAL_CMD), GFP_KERNEL);
 		if (!iocmd) {
 			printk(MYIOC_s_ERR_FMT "%s: kzalloc(%zd) FAILED!\n",
-			__FUNCTION__, ioc->name, sizeof(INTERNAL_CMD));
+			__func__, ioc->name, sizeof(INTERNAL_CMD));
 			return;
 		}
 		iocmd->id = vdevice->vtarget->id;
@@ -1773,7 +1786,7 @@ mptsas_slave_configure(struct scsi_devic
 	mptsas_add_device_component_starget(ioc, scsi_target(sdev));
 
 	if (sdev->type == TYPE_TAPE &&
-	    (ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_TLR ))
+	    (ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_TLR))
 		mptsas_issue_tlr(hd, sdev);
  out:
 
@@ -1815,7 +1828,7 @@ mptsas_target_alloc(struct scsi_target *
 			kfree(vtarget);
 			return -ENXIO;
 		}
-		for (i=0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++)
+		for (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++)
 			if (id == ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID)
 				channel = ioc->raid_data.pIocPg2->RaidVolume[i].VolumeBus;
 		vtarget->raidVolume = 1;
@@ -1834,9 +1847,11 @@ mptsas_target_alloc(struct scsi_target *
 			mptsas_set_starget(&p->phy_info[i], starget);
 
 			starget_printk(KERN_INFO, starget, MYIOC_s_FMT
-			"add device: fw_channel %d, fw_id %d, phy %d, sas_addr 0x%llx\n",
+			"add device: fw_channel %d, fw_id %d, phy %d,"
+			" sas_addr 0x%llx\n",
 			ioc->name, p->phy_info[i].attached.channel,
-			p->phy_info[i].attached.id, p->phy_info[i].attached.phy_id,
+			p->phy_info[i].attached.id,
+			p->phy_info[i].attached.phy_id,
 			(unsigned long long)p->phy_info[i].attached.sas_address);
 
 			/*
@@ -1899,9 +1914,9 @@ mptsas_target_destroy(struct scsi_target
 			starget_printk(KERN_INFO, starget, MYIOC_s_FMT
 			"delete device: fw_channel %d, fw_id %d, phy %d, "
 			"sas_addr 0x%llx\n", ioc->name,
-		       	p->phy_info[i].attached.channel,
+			p->phy_info[i].attached.channel,
 			p->phy_info[i].attached.id,
-		       	p->phy_info[i].attached.phy_id, (unsigned long long)
+			p->phy_info[i].attached.phy_id, (unsigned long long)
 			p->phy_info[i].attached.sas_address);
 
 			mptsas_port_delete(ioc, p->phy_info[i].port_details);
@@ -2000,8 +2015,7 @@ mptsas_qcmd(struct scsi_cmnd *SCpnt, voi
 	if (ioc->sas_discovery_quiesce_io)
 		return SCSI_MLQUEUE_HOST_BUSY;
 
-//	scsi_print_command(SCpnt);
-	return mptscsih_qcmd(SCpnt,done);
+	return mptscsih_qcmd(SCpnt, done);
 }
 
 
@@ -2046,7 +2060,6 @@ static int mptsas_get_linkerrors(struct 
 	dma_addr_t dma_handle;
 	int error;
 
-	/* FIXME: only have link errors on local phys */
 	if (!scsi_is_sas_phy_local(phy))
 		return -EINVAL;
 
@@ -2140,7 +2153,6 @@ static int mptsas_phy_reset(struct sas_p
 	unsigned long timeleft;
 	int error = -ERESTARTSYS;
 
-	/* FIXME: fusion doesn't allow non-local phy reset */
 	if (!scsi_is_sas_phy_local(phy))
 		return -EINVAL;
 
@@ -2192,7 +2204,7 @@ static int mptsas_phy_reset(struct sas_p
 	reply = (SasIoUnitControlReply_t *)ioc->sas_mgmt.reply;
 	if (reply->IOCStatus != MPI_IOCSTATUS_SUCCESS) {
 		printk(MYIOC_s_INFO_FMT "%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",
-		    ioc->name, __FUNCTION__, reply->IOCStatus, reply->IOCLogInfo);
+		    ioc->name, __func__, reply->IOCStatus, reply->IOCLogInfo);
 		error = -ENXIO;
 		goto out_unlock;
 	}
@@ -2275,11 +2287,160 @@ mptsas_get_bay_identifier(struct sas_rph
 	return rc;
 }
 
+static int mptsas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
+			      struct request *req)
+{
+	MPT_ADAPTER *ioc = ((MPT_SCSI_HOST *) shost->hostdata)->ioc;
+	MPT_FRAME_HDR *mf;
+	SmpPassthroughRequest_t *smpreq;
+	struct request *rsp = req->next_rq;
+	int ret;
+	int flagsLength;
+	unsigned long timeleft;
+	char *psge;
+	dma_addr_t dma_addr_in = 0;
+	dma_addr_t dma_addr_out = 0;
+	u64 sas_address = 0;
+
+	if (!rsp) {
+		printk(MYIOC_s_ERR_FMT
+		    "%s: the smp response space is missing\n",
+		    ioc->name, __func__);
+		return -EINVAL;
+	}
+
+	/* do we need to support multiple segments? */
+	if (req->bio->bi_vcnt > 1 || rsp->bio->bi_vcnt > 1) {
+		printk(MYIOC_s_ERR_FMT
+		    "%s: multiple segments req %u %u, rsp %u %u\n",
+		    ioc->name, __func__, req->bio->bi_vcnt, req->data_len,
+		    rsp->bio->bi_vcnt, rsp->data_len);
+		return -EINVAL;
+	}
+
+	ret = mutex_lock_interruptible(&ioc->sas_mgmt.mutex);
+	if (ret)
+		goto out;
+
+	mf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);
+	if (!mf) {
+		ret = -ENOMEM;
+		goto out_unlock;
+	}
+
+	smpreq = (SmpPassthroughRequest_t *)mf;
+	memset(smpreq, 0, sizeof(*smpreq));
+
+	smpreq->RequestDataLength = cpu_to_le16(req->data_len - 4);
+	smpreq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;
+
+	if (rphy)
+		sas_address = rphy->identify.sas_address;
+	else {
+		struct mptsas_portinfo *port_info;
+
+		mutex_lock(&ioc->sas_topology_mutex);
+		port_info = ioc->hba_port_info;
+		if (port_info && port_info->phy_info)
+			sas_address =
+				port_info->phy_info[0].phy->identify.sas_address;
+		mutex_unlock(&ioc->sas_topology_mutex);
+	}
+
+	*((u64 *)&smpreq->SASAddress) = cpu_to_le64(sas_address);
+
+	psge = (char *)
+		(((int *) mf) + (offsetof(SmpPassthroughRequest_t, SGL) / 4));
+
+	/* request */
+
+	flagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+		MPI_SGE_FLAGS_SYSTEM_ADDRESS |
+		MPI_SGE_FLAGS_HOST_TO_IOC |
+		MPI_SGE_FLAGS_END_OF_BUFFER;
+
+	flagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;
+
+	flagsLength |= (req->data_len - 4);
+
+	dma_addr_out = pci_map_single(ioc->pcidev, bio_data(req->bio),
+				      req->data_len, PCI_DMA_BIDIRECTIONAL);
+	if (!dma_addr_out)
+		goto put_mf;
+	ioc->add_sge(psge, flagsLength, dma_addr_out);
+	psge += ioc->SGE_size;
+
+	/* response */
+	flagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+		MPI_SGE_FLAGS_SYSTEM_ADDRESS |
+		MPI_SGE_FLAGS_IOC_TO_HOST |
+		MPI_SGE_FLAGS_END_OF_BUFFER;
+
+	flagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;
+	flagsLength |= rsp->data_len + 4;
+	dma_addr_in =  pci_map_single(ioc->pcidev, bio_data(rsp->bio),
+				      rsp->data_len, PCI_DMA_BIDIRECTIONAL);
+	if (!dma_addr_in)
+		goto out_unmap;
+
+	ioc->add_sge(psge, flagsLength, dma_addr_in);
+
+	INITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)
+	mpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);
+
+	timeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);
+	if (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
+		ret = -ETIME;
+		mpt_free_msg_frame(ioc, mf);
+		mf = NULL;
+		if (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)
+			goto out_unmap;
+		if (!timeleft) {
+			if (mpt_SoftResetHandler(ioc, CAN_SLEEP) != 0)
+				mpt_HardResetHandler(ioc, CAN_SLEEP);
+		}
+		goto out_unmap;
+	}
+
+	mf = NULL;
+
+	if (ioc->sas_mgmt.status & MPT_MGMT_STATUS_RF_VALID) {
+		SmpPassthroughReply_t *smprep;
+
+		smprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply;
+		memcpy(req->sense, smprep, sizeof(*smprep));
+		req->sense_len = sizeof(*smprep);
+		req->data_len = 0;
+		rsp->data_len -= smprep->ResponseDataLength;
+	} else {
+		printk(MYIOC_s_ERR_FMT
+		    "%s: smp passthru reply failed to be returned\n",
+		    ioc->name, __func__);
+		ret = -ENXIO;
+	}
+out_unmap:
+	if (dma_addr_out)
+		pci_unmap_single(ioc->pcidev, dma_addr_out, req->data_len,
+				 PCI_DMA_BIDIRECTIONAL);
+	if (dma_addr_in)
+		pci_unmap_single(ioc->pcidev, dma_addr_in, rsp->data_len,
+				 PCI_DMA_BIDIRECTIONAL);
+put_mf:
+	if (mf)
+		mpt_free_msg_frame(ioc, mf);
+out_unlock:
+	CLEAR_MGMT_STATUS(ioc->sas_mgmt.status)
+	mutex_unlock(&ioc->sas_mgmt.mutex);
+out:
+	return ret;
+}
+
 static struct sas_function_template mptsas_transport_functions = {
 	.get_linkerrors		= mptsas_get_linkerrors,
 	.get_enclosure_identifier = mptsas_get_enclosure_identifier,
 	.get_bay_identifier	= mptsas_get_bay_identifier,
 	.phy_reset		= mptsas_phy_reset,
+	.smp_handler		= mptsas_smp_handler,
 };
 
 static struct scsi_transport_template *mptsas_transport_template;
@@ -2338,7 +2499,7 @@ mptsas_sas_io_unit_pg0(MPT_ADAPTER *ioc,
 
 	port_info->num_phys = buffer->NumPhys;
 	port_info->phy_info = kcalloc(port_info->num_phys,
-		sizeof(struct mptsas_phyinfo),GFP_KERNEL);
+		sizeof(struct mptsas_phyinfo), GFP_KERNEL);
 	if (!port_info->phy_info) {
 		error = -ENOMEM;
 		goto out_free_consistent;
@@ -2659,7 +2820,7 @@ mptsas_sas_expander_pg0(MPT_ADAPTER *ioc
 	/* save config data */
 	port_info->num_phys = (buffer->NumPhys) ? buffer->NumPhys : 1;
 	port_info->phy_info = kcalloc(port_info->num_phys,
-		sizeof(struct mptsas_phyinfo),GFP_KERNEL);
+		sizeof(struct mptsas_phyinfo), GFP_KERNEL);
 	if (!port_info->phy_info) {
 		error = -ENOMEM;
 		goto out_free_consistent;
@@ -2970,7 +3131,7 @@ static int mptsas_probe_one_phy(struct d
 			if (error) {
 				dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 					"%s: exit at line=%d\n", ioc->name,
-					__FUNCTION__, __LINE__));
+					__func__, __LINE__));
 				goto out;
 			}
 			mptsas_set_port(ioc, phy_info, port);
@@ -3036,7 +3197,7 @@ static int mptsas_probe_one_phy(struct d
 		if (!rphy) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				"%s: exit at line=%d\n", ioc->name,
-				__FUNCTION__, __LINE__));
+				__func__, __LINE__));
 			goto out;
 		}
 
@@ -3045,7 +3206,7 @@ static int mptsas_probe_one_phy(struct d
 		if (error) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				"%s: exit at line=%d\n", ioc->name,
-				__FUNCTION__, __LINE__));
+				__func__, __LINE__));
 			sas_rphy_free(rphy);
 			goto out;
 		}
@@ -3069,7 +3230,7 @@ mptsas_probe_hba_phys(MPT_ADAPTER *ioc)
 	int error = -ENOMEM, i;
 
 	hba = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);
-	if (! hba)
+	if (!hba)
 		goto out;
 
 	error = mptsas_sas_io_unit_pg0(ioc, hba);
@@ -3195,7 +3356,7 @@ mptsas_find_phyinfo_by_phys_disk_num(MPT
 	num_paths = mpt_raid_phys_disk_get_num_paths(ioc, phys_disk_num);
 	if (!num_paths)
 		goto out;
-	phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t,Path) +
+	phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +
 	   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);
 	if (!phys_disk)
 		goto out;
@@ -3208,7 +3369,8 @@ mptsas_find_phyinfo_by_phys_disk_num(MPT
 		    (channel == phys_disk->Path[i].PhysDiskBus)) {
 			memcpy(&sas_address, &phys_disk->Path[i].WWID,
 				sizeof(u64));
-			phy_info = mptsas_find_phyinfo_by_sas_address(ioc, sas_address);
+			phy_info = mptsas_find_phyinfo_by_sas_address(ioc,
+			    sas_address);
 			goto out;
 		}
 	}
@@ -3230,7 +3392,8 @@ mptsas_find_phyinfo_by_phys_disk_num(MPT
 				continue;
 			if (port_info->phy_info[i].attached.phys_disk_num == ~0)
 				continue;
-			if (port_info->phy_info[i].attached.phys_disk_num == phys_disk_num &&
+			if (port_info->phy_info[i].attached.phys_disk_num ==
+			    phys_disk_num &&
 			    port_info->phy_info[i].attached.id == id &&
 			    port_info->phy_info[i].attached.channel == channel)
 				phy_info = &port_info->phy_info[i];
@@ -3275,7 +3438,6 @@ mptsas_reprobe_target(struct scsi_target
  *	@id:
  *
  *
- *	 TODO: check for hotspares
  **/
 static void
 mptsas_adding_inactive_raid_components(MPT_ADAPTER *ioc, u8 channel, u8 id)
@@ -3363,10 +3525,10 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, 
 	char *ds = NULL;
 	u8 fw_id;
 
-	if (!phy_info){
+	if (!phy_info) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: exit at line=%d\n", ioc->name,
-			__FUNCTION__, __LINE__));
+			__func__, __LINE__));
 		return 1;
 	}
 
@@ -3375,7 +3537,7 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, 
 	if (mptsas_get_rphy(phy_info)) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-			__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return 2;
 	}
 
@@ -3383,7 +3545,7 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, 
 	if (!port) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-			__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return 3;
 	}
 
@@ -3408,7 +3570,7 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, 
 	if (!rphy) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-			__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return 5; /* non-fatal: an rphy can be added later */
 	}
 
@@ -3416,7 +3578,7 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, 
 	if (sas_rphy_add(rphy)) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-			__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		sas_rphy_free(rphy);
 		return 6;
 	}
@@ -3439,7 +3601,7 @@ mptsas_del_end_device(MPT_ADAPTER *ioc, 
 	struct mptsas_portinfo *port_info;
 	struct mptsas_phyinfo *phy_info_parent;
 	int i;
-	struct scsi_target * starget;
+	struct scsi_target *starget;
 	char *ds = NULL;
 	u8 fw_id;
 	u64 sas_address;
@@ -3453,14 +3615,14 @@ mptsas_del_end_device(MPT_ADAPTER *ioc, 
 	if (!phy_info->port_details) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-		       	__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return;
 	}
 	rphy = mptsas_get_rphy(phy_info);
 	if (!rphy) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-		       	__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return;
 	}
 	if (phy_info->attached.device_info &
@@ -3485,13 +3647,13 @@ mptsas_del_end_device(MPT_ADAPTER *ioc, 
 	if (!port) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-		       	__FUNCTION__, fw_id, __LINE__));
+			__func__, fw_id, __LINE__));
 		return;
 	}
 	port_info = phy_info->portinfo;
 	phy_info_parent = port_info->phy_info;
 	for (i = 0; i < port_info->num_phys; i++, phy_info_parent++) {
-		if(!phy_info_parent->phy)
+		if (!phy_info_parent->phy)
 			continue;
 		if (phy_info_parent->attached.sas_address !=
 		    sas_address)
@@ -3507,11 +3669,11 @@ mptsas_del_end_device(MPT_ADAPTER *ioc, 
 	    "delete port %d, sas_addr (0x%llx)\n", ioc->name,
 	     port->port_identifier, (unsigned long long)sas_address);
 	sas_port_delete(port);
-//	mptsas_port_delete(ioc, phy_info->port_details);
 }
 
 struct mptsas_phyinfo *
-mptsas_refreshing_device_handles(MPT_ADAPTER *ioc, struct mptsas_devinfo *sas_device)
+mptsas_refreshing_device_handles(MPT_ADAPTER *ioc,
+    struct mptsas_devinfo *sas_device)
 {
 	struct mptsas_phyinfo *phy_info;
 	struct mptsas_portinfo *port_info;
@@ -3526,7 +3688,7 @@ mptsas_refreshing_device_handles(MPT_ADA
 		goto out;
 	mutex_lock(&ioc->sas_topology_mutex);
 	for (i = 0; i < port_info->num_phys; i++) {
-		if(port_info->phy_info[i].attached.sas_address !=
+		if (port_info->phy_info[i].attached.sas_address !=
 		    sas_device->sas_address)
 			continue;
 		port_info->phy_info[i].attached.channel = sas_device->channel;
@@ -3555,7 +3717,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
     struct mptsas_hotplug_event *hot_plug_info)
 {
 	struct mptsas_phyinfo *phy_info;
-	struct scsi_target * starget;
+	struct scsi_target *starget;
 	struct mptsas_devinfo sas_device;
 	VirtTarget *vtarget;
 	enum device_state state;
@@ -3636,17 +3798,17 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		    (hot_plug_info->channel << 8) + hot_plug_info->id)) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: fw_id=%d exit at line=%d\n", ioc->name,
-				__FUNCTION__, hot_plug_info->id, __LINE__));
+			__func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
 		phy_info = mptsas_find_phyinfo_by_sas_address(
 		    ioc, sas_device.sas_address);
 
-		if (!phy_info){
+		if (!phy_info) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				"%s: fw_id=%d exit at line=%d\n", ioc->name,
-			       	__FUNCTION__, hot_plug_info->id, __LINE__));
+				__func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3654,7 +3816,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		if (!starget) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				"%s: fw_id=%d exit at line=%d\n", ioc->name,
-				__FUNCTION__, hot_plug_info->id, __LINE__));
+				__func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3662,7 +3824,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		if (!vtarget) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				"%s: fw_id=%d exit at line=%d\n", ioc->name,
-				__FUNCTION__, hot_plug_info->id, __LINE__));
+				__func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3688,7 +3850,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 			(hot_plug_info->channel << 8) + hot_plug_info->id)) {
 				dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 				    "%s: fw_id=%d exit at line=%d\n",
-				    ioc->name, __FUNCTION__,
+				    ioc->name, __func__,
 				    hot_plug_info->id, __LINE__));
 			break;
 		}
@@ -3698,7 +3860,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		if (!phy_info) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			    "%s: fw_id=%d exit at line=%d\n", ioc->name,
-			    __FUNCTION__, hot_plug_info->id, __LINE__));
+			    __func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3706,7 +3868,7 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		if (!starget) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			    "%s: fw_id=%d exit at line=%d\n", ioc->name,
-			    __FUNCTION__, hot_plug_info->id, __LINE__));
+			    __func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3714,14 +3876,14 @@ mptsas_hotplug_work(MPT_ADAPTER *ioc, st
 		if (!vtarget) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			    "%s: fw_id=%d exit at line=%d\n", ioc->name,
-			    __FUNCTION__, hot_plug_info->id, __LINE__));
+			    __func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
 		if (!(vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			    "%s: fw_id=%d exit at line=%d\n", ioc->name,
-			    __FUNCTION__, hot_plug_info->id, __LINE__));
+			    __func__, hot_plug_info->id, __LINE__));
 			break;
 		}
 
@@ -3800,7 +3962,7 @@ mptsas_send_sas_event(struct fw_event_wo
 	if ((device_info &
 	     (MPI_SAS_DEVICE_INFO_SSP_TARGET |
 	      MPI_SAS_DEVICE_INFO_STP_TARGET |
-	      MPI_SAS_DEVICE_INFO_SATA_DEVICE )) == 0) {
+	      MPI_SAS_DEVICE_INFO_SATA_DEVICE)) == 0) {
 		mptsas_free_fw_event(ioc, fw_event);
 		return;
 	}
@@ -3840,9 +4002,7 @@ mptsas_send_sas_event(struct fw_event_wo
 		break;
 
 	case MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:
-	/* TODO */
 	case MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:
-	/* TODO */
 	default:
 		mptsas_free_fw_event(ioc, fw_event);
 		break;
@@ -3892,7 +4052,7 @@ mptsas_send_raid_event(struct fw_event_w
 	}
 
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "Entering %s: "
-	    "ReasonCode=%02x\n", ioc->name, __FUNCTION__,
+	    "ReasonCode=%02x\n", ioc->name, __func__,
 	    raid_event_data->ReasonCode));
 
 	switch (raid_event_data->ReasonCode) {
@@ -3988,8 +4148,8 @@ mptsas_send_raid_event(struct fw_event_w
  *
  **/
 static int
-mptsas_issue_tm(MPT_ADAPTER *ioc, u8 type, u8 channel, u8 id, u64 lun, int task_context, ulong timeout,
-	u8 *issue_reset)
+mptsas_issue_tm(MPT_ADAPTER *ioc, u8 type, u8 channel, u8 id, u64 lun,
+    int task_context, ulong timeout, u8 *issue_reset)
 {
 	MPT_FRAME_HDR	*mf;
 	SCSITaskMgmt_t	*pScsiTm;
@@ -4068,7 +4228,7 @@ mptsas_broadcast_primative_work(struct f
 	VirtDevice		*vdevice;
 	int			ii;
 	struct scsi_cmnd	*sc;
-	SCSITaskMgmtReply_t *	pScsiTmReply;
+	SCSITaskMgmtReply_t 	*pScsiTmReply;
 	u8			issue_reset;
 	int			task_context;
 	u8			channel, id;
@@ -4077,7 +4237,7 @@ mptsas_broadcast_primative_work(struct f
 	u32			 query_count;
 
 	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-	    "%s - enter\n", ioc->name, __FUNCTION__));
+	    "%s - enter\n", ioc->name, __func__));
 
 	mutex_lock(&ioc->taskmgmt_cmds.mutex);
 	if (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {
@@ -4133,7 +4293,7 @@ mptsas_broadcast_primative_work(struct f
  out:
 	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 	    "%s - exit, query_count = %d termination_count = %d\n",
-	    ioc->name, __FUNCTION__, query_count, termination_count));
+	    ioc->name, __func__, query_count, termination_count));
 
 	ioc->broadcast_aen_busy = 0;
 	mpt_clear_taskmgmt_in_progress_flag(ioc);
@@ -4141,7 +4301,7 @@ mptsas_broadcast_primative_work(struct f
 
 	if (issue_reset) {
 		printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-		    ioc->name, __FUNCTION__);
+		    ioc->name, __func__);
 		if (mpt_SoftResetHandler(ioc, CAN_SLEEP))
 			mpt_HardResetHandler(ioc, CAN_SLEEP);
 	}
@@ -4159,7 +4319,7 @@ mptsas_send_ir2_event(struct fw_event_wo
 {
 	MPT_ADAPTER *ioc;
 	struct mptsas_hotplug_event hot_plug_info;
-	MPI_EVENT_DATA_IR2 * ir2_data;
+	MPI_EVENT_DATA_IR2 *ir2_data;
 	u8 reasonCode;
 	RaidPhysDiskPage0_t phys_disk;
 
@@ -4168,7 +4328,7 @@ mptsas_send_ir2_event(struct fw_event_wo
 	reasonCode = ir2_data->ReasonCode;
 
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "Entering %s: "
-	    "ReasonCode=%02x\n", ioc->name,__FUNCTION__, reasonCode));
+	    "ReasonCode=%02x\n", ioc->name, __func__, reasonCode));
 
 	memset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));
 	hot_plug_info.id = ir2_data->TargetID;
@@ -4255,7 +4415,7 @@ mptsas_expander_refresh(MPT_ADAPTER *ioc
 
 static void
 mptsas_expander_event_add(MPT_ADAPTER *ioc,
-    MpiEventDataSasExpanderStatusChange_t* expander_data)
+    MpiEventDataSasExpanderStatusChange_t *expander_data)
 {
 	struct mptsas_portinfo *port_info;
 	int i;
@@ -4267,7 +4427,7 @@ mptsas_expander_event_add(MPT_ADAPTER *i
 	port_info->num_phys = (expander_data->NumPhys) ?
 	    expander_data->NumPhys : 1;
 	port_info->phy_info = kcalloc(port_info->num_phys,
-	    sizeof(struct mptsas_phyinfo),GFP_KERNEL);
+	    sizeof(struct mptsas_phyinfo), GFP_KERNEL);
 	if (!port_info->phy_info)
 		BUG();
 	memcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));
@@ -4351,8 +4511,8 @@ mptsas_expander_delete(MPT_ADAPTER *ioc,
 	u64		expander_sas_address;
 	struct mptsas_phyinfo *phy_info;
 	struct mptsas_portinfo buffer;
-	struct mptsas_portinfo_details * port_details;
-	struct sas_port * port;
+	struct mptsas_portinfo_details *port_details;
+	struct sas_port *port;
 
 	if (!port_info)
 		return;
@@ -4388,7 +4548,7 @@ mptsas_expander_delete(MPT_ADAPTER *ioc,
 	phy_info = parent->phy_info;
 	port = NULL;
 	for (i = 0; i < parent->num_phys; i++, phy_info++) {
-		if(!phy_info->phy)
+		if (!phy_info->phy)
 			continue;
 		if (phy_info->attached.sas_address !=
 		    expander_sas_address)
@@ -4438,7 +4598,7 @@ static void
 mptsas_send_expander_event(struct fw_event_work *fw_event)
 {
 	MPT_ADAPTER *ioc;
-	MpiEventDataSasExpanderStatusChange_t* expander_data;
+	MpiEventDataSasExpanderStatusChange_t *expander_data;
 	struct mptsas_portinfo *port_info;
 	__le64 sas_address;
 	int i;
@@ -4492,7 +4652,7 @@ mptsas_expander_add(MPT_ADAPTER *ioc, u1
 	if (!port_info) {
 		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 		"%s: exit at line=%d\n", ioc->name,
-		__FUNCTION__, __LINE__));
+		__func__, __LINE__));
 		return NULL;
 	}
 	port_info->num_phys = buffer.num_phys;
@@ -4589,7 +4749,7 @@ mptsas_handle_queue_full_event(struct fw
 	current_depth = le16_to_cpu(qfull_data->CurrentDepth);
 
 	/* if hidden raid component, look for the volume id */
-	down(&ioc->sas_device_info_mutex);
+	mutex_lock(&ioc->sas_device_info_mutex);
 	if (mptscsih_is_phys_disk(ioc, fw_channel, fw_id)) {
 		list_for_each_entry(sas_info, &ioc->sas_device_info_list,
 		    list) {
@@ -4622,7 +4782,7 @@ mptsas_handle_queue_full_event(struct fw
 	}
 
  out:
-	up(&ioc->sas_device_info_mutex);
+	mutex_unlock(&ioc->sas_device_info_mutex);
 
 	if (id != -1) {
 		shost_for_each_device(sdev, ioc->sh) {
@@ -4643,8 +4803,8 @@ mptsas_handle_queue_full_event(struct fw
 					   depth);
 				else if (depth < 0)
 					sdev_printk(KERN_INFO, sdev,
-				    	"Tagged Command Queueing is being "
-					"disabled\n");
+					    "Tagged Command Queueing is being "
+					    "disabled\n");
 				else if (depth == 0)
 					sdev_printk(KERN_INFO, sdev,
 					"Queue depth not changed yet\n");
@@ -4671,7 +4831,7 @@ mptsas_firmware_event_work(struct work_s
 	/* special rescan topology handling */
 	if (fw_event->event == -1) {
 		devtprintk(ioc, printk(MYIOC_s_INFO_FMT "%s: rescan after "
-		    "reset\n", ioc->name,__FUNCTION__));
+		    "reset\n", ioc->name, __func__));
 		mptsas_not_responding_devices(ioc);
 		mptsas_scan_sas_topology(ioc);
 		mptsas_free_fw_event(ioc, fw_event);
@@ -4685,7 +4845,7 @@ mptsas_firmware_event_work(struct work_s
 	}
 
 	devtprintk(ioc, printk(MYIOC_s_INFO_FMT "%s: fw_event=(0x%p), "
-	    "event = (0x%02x)\n", ioc->name,__FUNCTION__, fw_event,
+	    "event = (0x%02x)\n", ioc->name, __func__, fw_event,
 	    (fw_event->event & 0xFF)));
 
 	switch (fw_event->event) {
@@ -4805,7 +4965,7 @@ mptsas_event_process(MPT_ADAPTER *ioc, E
 	fw_event = kzalloc(sz, GFP_ATOMIC);
 	if (!fw_event) {
 		printk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n", ioc->name,
-		    __FUNCTION__, __LINE__);
+		    __func__, __LINE__);
 		return 0;
 	}
 	memcpy(fw_event->event_data, reply->Data, event_data_sz);
@@ -4835,7 +4995,7 @@ static void mptsas_volume_delete(MPT_ADA
 			goto release_sdev;
  out:
 	printk(MYIOC_s_INFO_FMT "removing raid volume, channel %d, "
-	    "id %d\n", ioc->name, MPTSAS_RAID_CHANNEL,id);
+	    "id %d\n", ioc->name, MPTSAS_RAID_CHANNEL, id);
 	scsi_remove_device(sdev);
  release_sdev:
 	scsi_device_put(sdev);
@@ -4953,7 +5113,7 @@ mptsas_probe_expanders(MPT_ADAPTER *ioc)
 		if (!port_info) {
 			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
 			"%s: exit at line=%d\n", ioc->name,
-			__FUNCTION__, __LINE__));
+			__func__, __LINE__));
 			return;
 		}
 		port_info->num_phys = buffer.num_phys;
@@ -5000,7 +5160,7 @@ mptsas_probe_devices(MPT_ADAPTER *ioc)
 
 		state = DEVICE_RETRY;
 		retry_count = 0;
-		while(state == DEVICE_RETRY) {
+		while (state == DEVICE_RETRY) {
 			state = mptsas_test_unit_ready(ioc, sas_device.channel,
 			    sas_device.id, retry_count++);
 			ssleep(1);
@@ -5032,7 +5192,7 @@ mptsas_scan_sas_topology(MPT_ADAPTER *io
 	if (!ioc->ir_firmware || !ioc->raid_data.pIocPg2 ||
 	    !ioc->raid_data.pIocPg2->NumActiveVolumes)
 		return;
-	for (i=0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {
+	for (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {
 		if ((sdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL,
 		    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0))) {
 			scsi_device_put(sdev);
@@ -5196,11 +5356,12 @@ mptsas_probe(struct pci_dev *pdev, const
 	hd->last_queue_full = 0;
 	ioc->disable_hotplug_remove = mpt_disable_hotplug_remove;
 	if (ioc->disable_hotplug_remove)
-		printk(MYIOC_s_INFO_FMT "disabling hotplug remove\n", ioc->name);
+		printk(MYIOC_s_INFO_FMT
+		    "disabling hotplug remove\n", ioc->name);
 
 	INIT_LIST_HEAD(&hd->target_reset_list);
 	INIT_LIST_HEAD(&ioc->sas_device_info_list);
-	init_MUTEX(&ioc->sas_device_info_mutex);
+	mutex_init(&ioc->sas_device_info_mutex);
 
 	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
Index: linux-2.6.27/drivers/message/fusion/mptsas.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptsas.h
+++ linux-2.6.27/drivers/message/fusion/mptsas.h
@@ -84,9 +84,12 @@ struct sas_device_info {
 	u16			slot;		/* enclosure slot id */
 	u64			enclosure_logical_id; /*enclosure address */
 	u8			is_logical_volume; /* is this logical volume */
-	u8			is_hidden_raid_component; /* this belongs to volume */
-	u8			volume_id; /* this valid when is_hidden_raid_component set */
-	u8			is_cached;	/* cached data for a removed device */
+	/* this belongs to volume */
+	u8			is_hidden_raid_component;
+	/* this valid when is_hidden_raid_component set */
+	u8			volume_id;
+	/* cached data for a removed device */
+	u8			is_cached;
 };
 
 struct mptsas_hotplug_event {
Index: linux-2.6.27/drivers/message/fusion/mptscsih.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptscsih.c
+++ linux-2.6.27/drivers/message/fusion/mptscsih.c
@@ -102,7 +102,8 @@ static void	mptscsih_copy_sense_data(str
 
 int		mptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);
 int		mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
-static void	mptscsih_synchronize_cache(struct scsi_device *sdev, MPT_SCSI_HOST *hd, VirtDevice *vdevice);
+static void	mptscsih_synchronize_cache(struct scsi_device *sdev,
+    MPT_SCSI_HOST *hd, VirtDevice *vdevice);
 
 void 		mptscsih_remove(struct pci_dev *);
 void 		mptscsih_shutdown(struct pci_dev *);
@@ -142,12 +143,16 @@ mptscsih_getFreeChainBuffer(MPT_ADAPTER 
 		offset = (u8 *)chainBuf - (u8 *)ioc->ChainBuffer;
 		chain_idx = offset / ioc->req_sz;
 		rc = SUCCESS;
-		dsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "getFreeChainBuffer chainBuf=%p ChainBuffer=%p offset=%d chain_idx=%d\n",
-			ioc->name, chainBuf, ioc->ChainBuffer, offset, chain_idx));
+		dsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+			"getFreeChainBuffer chainBuf=%p ChainBuffer=%p"
+			" offset=%d chain_idx=%d\n",
+			ioc->name, chainBuf, ioc->ChainBuffer, offset,
+			chain_idx));
 	} else {
 		rc = FAILED;
 		chain_idx = MPT_HOST_NO_CHAIN;
-		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "getFreeChainBuffer failed\n",
+		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
+			"getFreeChainBuffer failed\n",
 			ioc->name));
 	}
 	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
@@ -216,7 +221,7 @@ mptscsih_AddSGE(MPT_ADAPTER *ioc, struct
 	 */
 
 nextSGEset:
-	numSgeSlots = ((frm_sz - sgeOffset) / ioc->SGE_size );
+	numSgeSlots = ((frm_sz - sgeOffset) / ioc->SGE_size);
 	numSgeThisFrame = (sges_left < numSgeSlots) ? sges_left : numSgeSlots;
 
 	sgflags = MPT_SGE_FLAGS_SIMPLE_ELEMENT | sgdir;
@@ -265,7 +270,8 @@ nextSGEset:
 			 * Update the chain element
 			 * Offset and Length fields.
 			 */
-			ioc->add_chain((char *)chainSge, 0, sgeOffset, ioc->ChainBufferDMA + chain_dma_off);
+			ioc->add_chain((char *)chainSge, 0, sgeOffset,
+			    ioc->ChainBufferDMA + chain_dma_off);
 		} else {
 			/* The current buffer is the original MF
 			 * and there is no Chain buffer.
@@ -313,7 +319,8 @@ nextSGEset:
 			 */
 			u8 nextChain = (u8) (sgeOffset >> 2);
 			sgeOffset += ioc->SGE_size;
-			ioc->add_chain((char *)chainSge, nextChain, sgeOffset, ioc->ChainBufferDMA + chain_dma_off);
+			ioc->add_chain((char *)chainSge, nextChain, sgeOffset,
+			   ioc->ChainBufferDMA + chain_dma_off);
 		} else {
 			/* The original MF buffer requires a chain buffer -
 			 * set the offset.
@@ -392,7 +399,7 @@ mptscsih_issue_sep_command(MPT_ADAPTER *
 
 	if ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {
 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: no msg frames!!\n",
-		    ioc->name,__FUNCTION__));
+		    ioc->name,__func__));
 		return;
 	}
 
@@ -525,9 +532,11 @@ mptscsih_info_scsiio(MPT_ADAPTER *ioc, s
 	scsi_print_command(sc);
 	printk(MYIOC_s_DEBUG_FMT "\tfw_channel = %d, fw_id = %d, lun = %d\n",
 	    ioc->name, pScsiReply->Bus, pScsiReply->TargetID, sc->device->lun);
-	printk(MYIOC_s_DEBUG_FMT "\trequest_len = %d, underflow = %d, resid = %d\n",
+	printk(MYIOC_s_DEBUG_FMT
+	    "\trequest_len = %d, underflow = %d, resid = %d\n",
 	       ioc->name, scsi_bufflen(sc), sc->underflow, scsi_get_resid(sc));
-	printk(MYIOC_s_DEBUG_FMT "\ttag = %d, transfer_count = %d, sc->result = %08X\n",
+	printk(MYIOC_s_DEBUG_FMT
+	    "\ttag = %d, transfer_count = %d, sc->result = %08X\n",
 	    ioc->name, le16_to_cpu(pScsiReply->TaskTag),
 	    le32_to_cpu(pScsiReply->TransferCount), sc->result);
 
@@ -590,7 +599,7 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 	    (le32_to_cpu(mf->u.frame.linkage.arg1) == 0xdeadbeaf)) {
 		printk(MYIOC_s_WARN_FMT
 		    "Received a mf that was already freed\n", ioc->name);
-		printk (MYIOC_s_WARN_FMT
+		printk(MYIOC_s_WARN_FMT
 		    "req_idx=%x req_idx_MR=%x mf=%p mr=%p sc=%p\n",
 		    ioc->name, req_idx, req_idx_MR, mf, mr,
 		    mptscsih_get_scsi_lookup(ioc, req_idx_MR));
@@ -715,11 +724,12 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 					}
 				}
 			} else if (ioc->bus_type == FC) {
-				/* The FC IOC may kill a request for variety of reasons,
-				some of which may be recovered by a retry, some which
-				are unlikely to be recovered. Return DID_ERROR instead
-				of DID_RESET to permit retry of the command, just not
-				an infinite number of them */
+				/* The FC IOC may kill a request for variety
+				 * of reasons, some of which may be recovered
+				 *  by a retry, some which are unlikely to be
+				 *  recovered. Return DID_ERROR instead	of
+				 *  DID_RESET to permit retry of the command,
+				 *  just not an infinite number of them */
 				sc->result = DID_ERROR << 16;
 				break;
 			}
@@ -735,7 +745,7 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 			sc->result = DID_RESET << 16;
 
 		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
-			if ( ioc->bus_type == FC )
+			if (ioc->bus_type == FC)
 				sc->result = DID_ERROR << 16;
 			else
 				sc->result = DID_RESET << 16;
@@ -1421,8 +1431,8 @@ mptscsih_qcmd(struct scsi_cmnd *SCpnt, v
 	 */
 	if (datalen == 0) {
 		/* Add a NULL SGE */
-		ioc->add_sge((char *)&pScsiReq->SGL, MPT_SGE_FLAGS_SSIMPLE_READ | 0,
-			(dma_addr_t) -1);
+		ioc->add_sge((char *)&pScsiReq->SGL,
+		    MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
 	} else {
 		/* Add a 32 or 64 bit SGE */
 		if (mptscsih_AddSGE(ioc, SCpnt, pScsiReq, my_idx) != SUCCESS)
@@ -1523,8 +1533,8 @@ mptscsih_scandv_bus_reset(MPT_ADAPTER *i
 	/* Send request
 	 */
 	if ((mf = mpt_get_msg_frame(ioc->TaskCtx, ioc)) == NULL) {
-		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT "TaskMgmt, no msg frames!!\n",
-				ioc->name));
+		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT
+			"TaskMgmt, no msg frames!!\n", ioc->name));
 		mpt_clear_taskmgmt_in_progress_flag(ioc);
 		retval = -ENOMEM;
 		goto out;
@@ -1544,26 +1554,27 @@ mptscsih_scandv_bus_reset(MPT_ADAPTER *i
 	pScsiTm->Reserved = 0;
 	pScsiTm->Reserved1 = 0;
 	pScsiTm->TaskMsgContext = 0;
-	for (ii= 0; ii < 8; ii++)
+	for (ii = 0; ii < 8; ii++)
 		pScsiTm->LUN[ii] = 0;
-	for (ii=0; ii < 7; ii++)
+	for (ii = 0; ii < 7; ii++)
 		pScsiTm->Reserved2[ii] = 0;
 
 	switch (ioc->bus_type) {
-		case FC:
-			timeout = 40;
-			break;
-		case SAS:
-			timeout = 30;
-			break;
-		case SPI:
-		default:
-			timeout = 2;
-			break;
+	case FC:
+		timeout = 40;
+		break;
+	case SAS:
+		timeout = 30;
+		break;
+	case SPI:
+	default:
+		timeout = 10;
+		break;
 	}
 
-	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt type=%d timeout=%ld\n",
-	    ioc->name, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS, timeout));
+	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"TaskMgmt type=%d timeout=%ld\n", ioc->name,
+		MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS, timeout));
 
 	INITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)
 	CLEAR_MGMT_STATUS(ioc->internal_cmds.status)
@@ -1576,7 +1587,8 @@ mptscsih_scandv_bus_reset(MPT_ADAPTER *i
 		retval = mpt_send_handshake_request(ioc->TaskCtx, ioc,
 		    sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP);
 		if (retval != 0) {
-			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "TaskMgmt send_handshake FAILED!"
+			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
+				"TaskMgmt send_handshake FAILED!"
 				" (ioc %p, mf %p, rc=%d) \n", ioc->name,
 				ioc, mf, retval));
 			mpt_clear_taskmgmt_in_progress_flag(ioc);
@@ -1642,19 +1654,20 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 	switch (reset_phase) {
 	case MPT_IOC_SETUP_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));
 		break;
 	case MPT_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));
 		hd = shost_priv(ioc->sh);
 		mptscsih_flush_running_cmds(hd);
 		break;
 	case MPT_IOC_POST_RESET:
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __FUNCTION__));
+		    "%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));
 		if (ioc->internal_cmds.status & MPT_MGMT_STATUS_PENDING) {
-			ioc->internal_cmds.status |= MPT_MGMT_STATUS_DID_IOCRESET;
+			ioc->internal_cmds.status
+			    |= MPT_MGMT_STATUS_DID_IOCRESET;
 			complete(&ioc->internal_cmds.done);
 		}
 		break;
@@ -1700,7 +1713,8 @@ mptscsih_taskmgmt_response_code(MPT_ADAP
 }
 
 static int
-mptscsih_taskmgmt_reply(MPT_ADAPTER *ioc, u8 type, SCSITaskMgmtReply_t *pScsiTmReply)
+mptscsih_taskmgmt_reply(MPT_ADAPTER *ioc, u8 type,
+    SCSITaskMgmtReply_t *pScsiTmReply)
 {
 	u16			 iocstatus;
 	u32			 termination_count;
@@ -1764,7 +1778,8 @@ mptscsih_taskmgmt_reply(MPT_ADAPTER *ioc
  *	Returns 1 indicating alloc'd request frame ptr should be freed.
  **/
 int
-mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
+mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,
+    MPT_FRAME_HDR *mr)
 {
 	dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt completed (mf=%p, mr=%p)\n",
 	    ioc->name, mf, mr));
@@ -1807,7 +1822,8 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
  *
  **/
 int
-mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id, int lun, int ctx2abort, ulong timeout)
+mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id, int lun,
+    int ctx2abort, ulong timeout)
 {
 	MPT_FRAME_HDR	*mf = NULL;
 	SCSITaskMgmt_t	*pScsiTm;
@@ -1827,7 +1843,7 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 			"TaskMgmt type=%x: IOC Not operational (0x%x)!\n",
 			ioc->name, type, ioc_raw_state);
 		printk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",
-		    ioc->name, __FUNCTION__);
+		    ioc->name, __func__);
 		if (mpt_HardResetHandler(ioc, CAN_SLEEP) < 0)
 			printk(MYIOC_s_WARN_FMT "TaskMgmt HardReset "
 			    "FAILED!!\n", ioc->name);
@@ -1844,7 +1860,7 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 
 	mutex_lock(&ioc->taskmgmt_cmds.mutex);
 	if (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {
-	mutex_unlock(&ioc->taskmgmt_cmds.mutex);
+		mutex_unlock(&ioc->taskmgmt_cmds.mutex);
 		retval = FAILED;
 		goto out;
 	}
@@ -1852,8 +1868,9 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 	/* Return Fail to calling function if no message frames available.
 	 */
 	if ((mf = mpt_get_msg_frame(ioc->TaskCtx, ioc)) == NULL) {
-		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "TaskMgmt no msg frames!!\n",
-				ioc->name));
+		dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
+			"TaskMgmt no msg frames!!\n",
+			ioc->name));
 		retval = FAILED;
 		mpt_clear_taskmgmt_in_progress_flag(ioc);
 		goto out;
@@ -1873,11 +1890,11 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 	pScsiTm->TaskType = type;
 	pScsiTm->Reserved1 = 0;
 	pScsiTm->MsgFlags = (type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
-                    ? MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION : 0;
+		? MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION : 0;
 
 	int_to_scsilun(lun, (struct scsi_lun *)pScsiTm->LUN);
 
-	for (ii=0; ii < 7; ii++)
+	for (ii = 0; ii < 7; ii++)
 		pScsiTm->Reserved2[ii] = 0;
 
 	pScsiTm->TaskMsgContext = ctx2abort;
@@ -1895,17 +1912,19 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 		mpt_put_msg_frame_hi_pri(ioc->TaskCtx, ioc, mf);
 	else {
 		retval = mpt_send_handshake_request(ioc->TaskCtx, ioc,
-			sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP);
+			sizeof(SCSITaskMgmt_t), (u32 *)pScsiTm, CAN_SLEEP);
 		if (retval) {
-			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT "TaskMgmt handshake FAILED!"
-			    " (mf=%p, rc=%d) \n", ioc->name, mf, retval));
+			dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
+				"TaskMgmt handshake FAILED!"
+				" (mf=%p, rc=%d) \n", ioc->name, mf, retval));
 			mpt_free_msg_frame(ioc, mf);
 			mpt_clear_taskmgmt_in_progress_flag(ioc);
 			goto out;
 		}
 	}
 
-	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);
+	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,
+	    timeout*HZ);
 	if (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		retval = FAILED;
 		dtmprintk(ioc, printk(MYIOC_s_ERR_FMT
@@ -1927,9 +1946,9 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
  out:
 
 	CLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)
-	if(issue_hard_reset) {
+	if (issue_hard_reset) {
 		printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-		    ioc->name, __FUNCTION__);
+		    ioc->name, __func__);
 		if ((retval = mpt_SoftResetHandler(ioc, CAN_SLEEP)) != 0)
 			retval = mpt_HardResetHandler(ioc, CAN_SLEEP);
 		mpt_free_msg_frame(ioc, mf);
@@ -2037,7 +2056,7 @@ mptscsih_abort(struct scsi_cmnd * SCpnt)
 		goto out;
 	}
 
-	if(mpt_fwfault_debug)
+	if (mpt_fwfault_debug)
 		mpt_halt_firmware(ioc);
 
 	if (ioc->timeouts < -1)
@@ -2075,7 +2094,7 @@ mptscsih_abort(struct scsi_cmnd * SCpnt)
 
  out:
 	printk(MYIOC_s_INFO_FMT "task abort: %s (sc=%p)\n",
-	    ioc->name, ((retval == SUCCESS) ? "SUCCESS" : "FAILED" ), SCpnt);
+	    ioc->name, ((retval == SUCCESS) ? "SUCCESS" : "FAILED"), SCpnt);
 
 	return retval;
 }
@@ -2306,7 +2325,7 @@ mptscsih_is_phys_disk(MPT_ADAPTER *ioc, 
 		    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);
 		if (num_paths < 2)
 			continue;
-		phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t,Path) +
+		phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +
 		   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);
 		if (!phys_disk)
 			continue;
@@ -2339,14 +2358,14 @@ mptscsih_is_phys_disk(MPT_ADAPTER *ioc, 
 	if (list_empty(&ioc->raid_data.inactive_list))
 		goto out;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	list_for_each_entry(component_info, &ioc->raid_data.inactive_list,
 	    list) {
 		if ((component_info->d.PhysDiskID == id) &&
 		    (component_info->d.PhysDiskBus == channel))
 			rc = 1;
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 
  out:
 	return rc;
@@ -2357,7 +2376,7 @@ u8
 mptscsih_raid_id_to_num(MPT_ADAPTER *ioc, u8 channel, u8 id)
 {
 	struct inactive_raid_component_info *component_info;
-	int i,j;
+	int i, j;
 	RaidPhysDiskPage1_t *phys_disk;
 	int rc = -ENXIO;
 	u8 num_paths;
@@ -2384,7 +2403,7 @@ mptscsih_raid_id_to_num(MPT_ADAPTER *ioc
 		    ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);
 		if (num_paths < 2)
 			continue;
-		phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t,Path) +
+		phys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +
 		   (num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);
 		if (!phys_disk)
 			continue;
@@ -2417,14 +2436,14 @@ mptscsih_raid_id_to_num(MPT_ADAPTER *ioc
 	if (list_empty(&ioc->raid_data.inactive_list))
 		goto out;
 
-	down(&ioc->raid_data.inactive_list_mutex);
+	mutex_lock(&ioc->raid_data.inactive_list_mutex);
 	list_for_each_entry(component_info, &ioc->raid_data.inactive_list,
 	    list) {
 		if ((component_info->d.PhysDiskID == id) &&
 		    (component_info->d.PhysDiskBus == channel))
 			rc = component_info->d.PhysDiskNum;
 	}
-	up(&ioc->raid_data.inactive_list_mutex);
+	mutex_unlock(&ioc->raid_data.inactive_list_mutex);
 
  out:
 	return rc;
@@ -2595,9 +2614,11 @@ mptscsih_copy_sense_data(struct scsi_cmn
 
 				ioc->eventContext++;
 				if (ioc->pcidev->vendor == PCI_VENDOR_ID_IBM) {
-					mptscsih_issue_sep_command(ioc, vdevice->vtarget,
+					mptscsih_issue_sep_command(ioc,
+					    vdevice->vtarget,
 					    MPI_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);
-					vdevice->vtarget->tflags |= MPT_TARGET_FLAGS_LED_ON;
+					vdevice->vtarget->tflags |=
+					    MPT_TARGET_FLAGS_LED_ON;
 				}
 			}
 		}
@@ -2736,8 +2757,9 @@ mptscsih_quiesce_raid(MPT_SCSI_HOST *hd,
 	/* Get and Populate a free Frame
 	 */
 	if ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {
-		dfailprintk(hd->ioc, printk(MYIOC_s_WARN_FMT "%s: no msg frames!\n",
-			ioc->name, __FUNCTION__));
+		dfailprintk(hd->ioc, printk(MYIOC_s_WARN_FMT
+			"%s: no msg frames!\n",
+			ioc->name, __func__));
 		ret = -EAGAIN;
 		goto out;
 	}
@@ -2759,8 +2781,9 @@ mptscsih_quiesce_raid(MPT_SCSI_HOST *hd,
 	ioc->add_sge((char *)&pReq->ActionDataSGE,
 		MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
 
-	ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RAID Volume action=%x channel=%d id=%d\n",
-			ioc->name, pReq->Action, channel, id));
+	ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
+		"RAID Volume action=%x channel=%d id=%d\n",
+		ioc->name, pReq->Action, channel, id));
 
 	INITIALIZE_MGMT_STATUS(ioc->internal_cmds.status)
 	mpt_put_msg_frame(ioc->InternalCtx, ioc, mf);
@@ -2768,12 +2791,12 @@ mptscsih_quiesce_raid(MPT_SCSI_HOST *hd,
 	if (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		ret = -ETIME;
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: TIMED OUT!\n",
-		    ioc->name, __FUNCTION__));
+		    ioc->name, __func__));
 		if (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)
 			goto out;
 		if (!timeleft) {
 			printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-			    ioc->name, __FUNCTION__);
+			    ioc->name, __func__);
 			if (mpt_SoftResetHandler(ioc, CAN_SLEEP) != 0)
 				mpt_HardResetHandler(ioc, CAN_SLEEP);
 			mpt_free_msg_frame(ioc, mf);
@@ -2797,7 +2820,8 @@ mptscsih_quiesce_raid(MPT_SCSI_HOST *hd,
  *
  **/
 static int
-mptscsih_get_completion_code(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)
+mptscsih_get_completion_code(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,
+    MPT_FRAME_HDR *reply)
 {
 	SCSIIOReply_t	*pReply;
 	MpiRaidActionReply_t *pr;
@@ -2810,10 +2834,12 @@ mptscsih_get_completion_code(MPT_ADAPTER
 	scsi_status = pReply->SCSIStatus;
 
 	devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-	    "IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
-	     ioc->name, status, pReply->SCSIState, scsi_status, le32_to_cpu(pReply->IOCLogInfo)));
+	    "IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh,"
+	    " IOCLogInfo=%08xh\n",
+	     ioc->name, status, pReply->SCSIState, scsi_status,
+	     le32_to_cpu(pReply->IOCLogInfo)));
 
-	switch(status) {
+	switch (status) {
 
 	case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:	/* 0x0043 */
 		completion_code = MPT_SCANDV_SELECTION_TIMEOUT;
@@ -2836,9 +2862,11 @@ mptscsih_get_completion_code(MPT_ADAPTER
 	case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
 		if (pReply->Function == MPI_FUNCTION_CONFIG) {
 			completion_code = MPT_SCANDV_GOOD;
-		} else if (pReply->Function == MPI_FUNCTION_RAID_ACTION) {
+		} else if (pReply->Function ==
+		    MPI_FUNCTION_RAID_ACTION) {
 			pr = (MpiRaidActionReply_t *)reply;
-			if (le16_to_cpu(pr->ActionStatus) == MPI_RAID_ACTION_ASTATUS_SUCCESS)
+			if (le16_to_cpu(pr->ActionStatus) ==
+			    MPI_RAID_ACTION_ASTATUS_SUCCESS)
 				completion_code = MPT_SCANDV_GOOD;
 			else
 				completion_code = MPT_SCANDV_SOME_ERROR;
@@ -2849,8 +2877,7 @@ mptscsih_get_completion_code(MPT_ADAPTER
 				completion_code = MPT_SCANDV_ISSUE_SENSE;
 			else
 				completion_code = MPT_SCANDV_DID_RESET;
-		}
-		else if (pReply->SCSIState & MPI_SCSI_STATE_NO_SCSI_STATUS)
+		} else if (pReply->SCSIState & MPI_SCSI_STATE_NO_SCSI_STATUS)
 			completion_code = MPT_SCANDV_DID_RESET;
 		else if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)
 			completion_code = MPT_SCANDV_DID_RESET;
@@ -2885,7 +2912,8 @@ mptscsih_get_completion_code(MPT_ADAPTER
  *
  **/
 int
-mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)
+mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,
+    MPT_FRAME_HDR *reply)
 {
 	SCSIIORequest_t *pReq;
 	SCSIIOReply_t	*pReply;
@@ -2965,7 +2993,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	if (ioc->ioc_reset_in_progress) {
 		spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: busy with host reset\n", ioc->name, __FUNCTION__));
+		    "%s: busy with host reset\n", ioc->name, __func__));
 		return MPT_SCANDV_BUSY;
 	}
 	spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
@@ -3091,7 +3119,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	 */
 	if ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {
 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: No msg frames!\n",
-		    ioc->name, __FUNCTION__));
+		    ioc->name, __func__));
 		ret = MPT_SCANDV_BUSY;
 		goto out;
 	}
@@ -3128,11 +3156,11 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	if (cmd == REQUEST_SENSE) {
 		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);
 		devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: Untagged! 0x%02x\n", ioc->name, __FUNCTION__, cmd));
+		    "%s: Untagged! 0x%02x\n", ioc->name, __func__, cmd));
 	}
 
 	for (ii = 0; ii < 16; ii++)
-	    pScsiReq->CDB[ii] = CDB[ii];
+		pScsiReq->CDB[ii] = CDB[ii];
 
 	pScsiReq->DataLength = cpu_to_le32(io->size);
 	pScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma
@@ -3140,7 +3168,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 	    "%s: Sending Command 0x%02x for fw_channel=%d fw_id=%d lun=%d\n",
-	    ioc->name, __FUNCTION__, cmd, io->channel, io->id, io->lun));
+	    ioc->name, __func__, cmd, io->channel, io->id, io->lun));
 
 	if (dir == MPI_SCSIIO_CONTROL_READ)
 		ioc->add_sge((char *) &pScsiReq->SGL,
@@ -3156,7 +3184,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	if (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		ret = MPT_SCANDV_DID_RESET;
 		dfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		    "%s: TIMED OUT for cmd=0x%02x\n", ioc->name, __FUNCTION__,
+		    "%s: TIMED OUT for cmd=0x%02x\n", ioc->name, __func__,
 		    cmd));
 		if (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
@@ -3166,7 +3194,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 			if (!mptscsih_scandv_bus_reset(ioc))
 				goto out;
 			printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
-			    ioc->name, __FUNCTION__);
+			    ioc->name, __func__);
 			if (mpt_SoftResetHandler(ioc, CAN_SLEEP) != 0)
 				mpt_HardResetHandler(ioc, CAN_SLEEP);
 			mpt_free_msg_frame(ioc, mf);
@@ -3176,7 +3204,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	ret = ioc->internal_cmds.completion_code;
 	devtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: success, rc=0x%02x\n",
-			ioc->name, __FUNCTION__, ret));
+			ioc->name, __func__, ret));
 
  out:
 	CLEAR_MGMT_STATUS(ioc->internal_cmds.status)
@@ -3195,7 +3223,8 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
  *
  */
 static void
-mptscsih_synchronize_cache(struct scsi_device *sdev, MPT_SCSI_HOST *hd, VirtDevice *vdevice)
+mptscsih_synchronize_cache(struct scsi_device *sdev, MPT_SCSI_HOST *hd,
+    VirtDevice *vdevice)
 {
 	INTERNAL_CMD		 iocmd;
 	MPT_ADAPTER *ioc = hd->ioc;
@@ -3219,8 +3248,9 @@ mptscsih_synchronize_cache(struct scsi_d
 	iocmd.id = vdevice->vtarget->id;
 	iocmd.lun = vdevice->lun;
 
-	sdev_printk(KERN_INFO, sdev, MYIOC_s_FMT "SYNCHRONIZE_CACHE: fw_channel %d,"
-	    " fw_id %d\n", ioc->name, vdevice->vtarget->channel, vdevice->vtarget->id);
+	sdev_printk(KERN_INFO, sdev, MYIOC_s_FMT
+	    "SYNCHRONIZE_CACHE: fw_channel %d, fw_id %d\n",
+	    ioc->name, vdevice->vtarget->channel, vdevice->vtarget->id);
 	mptscsih_do_cmd(hd, &iocmd);
 }
 
@@ -3408,7 +3438,8 @@ static DEVICE_ATTR(debug_level, S_IRUGO 
 	mptscsih_debug_level_show, mptscsih_debug_level_store);
 
 static ssize_t
-mptscsih_disable_hotplug_remove_show(struct device *dev, struct device_attribute *attr, char *buf)
+mptscsih_disable_hotplug_remove_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
 {
 	struct Scsi_Host *host = class_to_shost(dev);
 	MPT_SCSI_HOST	*hd = shost_priv(host);
@@ -3417,7 +3448,8 @@ mptscsih_disable_hotplug_remove_show(str
 	return snprintf(buf, PAGE_SIZE, "%02xh\n", ioc->disable_hotplug_remove);
 }
 static ssize_t
-mptscsih_disable_hotplug_remove_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+mptscsih_disable_hotplug_remove_store(struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct Scsi_Host *host = class_to_shost(dev);
 	MPT_SCSI_HOST	*hd = shost_priv(host);
@@ -3436,7 +3468,8 @@ mptscsih_disable_hotplug_remove_store(st
 	return strlen(buf);
 }
 static DEVICE_ATTR(disable_hotplug_remove, S_IRUGO | S_IWUSR,
-	mptscsih_disable_hotplug_remove_show, mptscsih_disable_hotplug_remove_store);
+	mptscsih_disable_hotplug_remove_show,
+	mptscsih_disable_hotplug_remove_store);
 
 struct device_attribute *mptscsih_host_attrs[] = {
 	&dev_attr_version_fw,
Index: linux-2.6.27/drivers/message/fusion/mptscsih.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptscsih.h
+++ linux-2.6.27/drivers/message/fusion/mptscsih.h
@@ -129,11 +129,13 @@ extern int mptscsih_scandv_complete(MPT_
 extern int mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
 extern int mptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);
 extern int mptscsih_change_queue_depth(struct scsi_device *sdev, int qdepth);
-extern int mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id, int lun, int ctx2abort, ulong timeout);
+extern int mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel,
+    u8 id, int lun, int ctx2abort, ulong timeout);
 extern u8 mptscsih_raid_id_to_num(MPT_ADAPTER *ioc, u8 channel, u8 id);
 extern int mptscsih_is_phys_disk(MPT_ADAPTER *ioc, u8 channel, u8 id);
 extern int mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *iocmd);
 extern struct device_attribute *mptscsih_host_attrs[];
-extern int mptscsih_quiesce_raid(MPT_SCSI_HOST *hd, int quiesce, u8 channel, u8 id);
+extern int mptscsih_quiesce_raid(MPT_SCSI_HOST *hd, int quiesce, u8 channel,
+    u8 id);
 extern struct scsi_cmnd * mptscsih_get_scsi_lookup(MPT_ADAPTER *ioc, int i);
 extern void mptscsih_taskmgmt_response_code(MPT_ADAPTER *ioc, u8 response_code);
Index: linux-2.6.27/drivers/message/fusion/mptspi.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/mptspi.c
+++ linux-2.6.27/drivers/message/fusion/mptspi.c
@@ -87,7 +87,8 @@ MODULE_PARM_DESC(mpt_saf_te, " Force ena
 
 static int mpt_qas = MPTSCSIH_QAS;
 module_param(mpt_qas, int, 1);
-MODULE_PARM_DESC(mpt_qas, " Quick Arbitration and Selection (QAS) enabled=1, disabled=0 (default=MPTSCSIH_QAS=1)");
+MODULE_PARM_DESC(mpt_qas, " Quick Arbitration and Selection (QAS) enabled=1,"
+   " disabled= (default=MPTSCSIH_QAS=1)");
 
 static void mptspi_write_offset(struct scsi_target *, int);
 static void mptspi_write_width(struct scsi_target *, int);
@@ -240,7 +241,7 @@ mptspi_setTargetNegoParms(MPT_SCSI_HOST 
 		 */
 
 		ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
-		"Disabling QAS due to noQas=%02x on id=%d!\n", ioc->name, noQas, id));
+			"Disabling QAS due to noQas=%02x on id=%d!\n", ioc->name, noQas, id));
 	}
 }
 
@@ -314,7 +315,7 @@ mptspi_writeIOCPage4(MPT_SCSI_HOST *hd, 
 
 	ddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT
 		"writeIOCPage4: MaxSEP=%d ActiveSEP=%d id=%d bus=%d\n",
-			ioc->name, IOCPage4Ptr->MaxSEP, IOCPage4Ptr->ActiveSEP, id, channel));
+		ioc->name, IOCPage4Ptr->MaxSEP, IOCPage4Ptr->ActiveSEP, id, channel));
 
 	mpt_put_msg_frame(ioc->DoneCtx, ioc, mf);
 
@@ -495,7 +496,7 @@ mptspi_print_write_nego(struct _MPT_SCSI
 	    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",
 	    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",
 	    ii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",
-	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": "");
+	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP " : "");
 }
 
 /**
@@ -523,7 +524,7 @@ mptspi_print_read_nego(struct _MPT_SCSI_
 	    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",
 	    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",
 	    ii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",
-	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": "");
+	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP " : "");
 }
 
 static int mptspi_read_spi_device_pg0(struct scsi_target *starget,
@@ -822,8 +823,8 @@ static int mptspi_write_spi_device_pg1(s
 
 	pg1 = dma_alloc_coherent(&ioc->pcidev->dev, size, &pg1_dma, GFP_KERNEL);
 	if (pg1 == NULL) {
-		starget_printk(KERN_ERR, starget,
-		    MYIOC_s_FMT "dma_alloc_coherent for parameters failed\n", ioc->name);
+		starget_printk(KERN_ERR, starget, MYIOC_s_FMT
+		    "dma_alloc_coherent for parameters failed\n", ioc->name);
 		return -EINVAL;
 	}
 
@@ -1071,12 +1072,12 @@ mpt_work_wrapper(struct work_struct *wor
 		if(vtarget->id != disk)
 			continue;
 
-		starget_printk(KERN_INFO, vtarget->starget,
-		    MYIOC_s_FMT "Integrated RAID requests DV of new device\n", ioc->name);
+		starget_printk(KERN_INFO, vtarget->starget, MYIOC_s_FMT
+		    "Integrated RAID requests DV of new device\n", ioc->name);
 		mptspi_dv_device(hd, sdev);
 	}
-	shost_printk(KERN_INFO, shost,
-	    MYIOC_s_FMT "Integrated RAID detects new device %d\n", ioc->name, disk);
+	shost_printk(KERN_INFO, shost, MYIOC_s_FMT
+	    "Integrated RAID detects new device %d\n", ioc->name, disk);
 	scsi_scan_target(&ioc->sh->shost_gendev, 1, disk, 0, 1);
 }
 
@@ -1087,8 +1088,8 @@ static void mpt_dv_raid(struct _MPT_SCSI
 	MPT_ADAPTER *ioc = hd->ioc;
 
 	if (!wqw) {
-		shost_printk(KERN_ERR, ioc->sh,
-		    MYIOC_s_FMT "Failed to act on RAID event for physical disk %d\n",
+		shost_printk(KERN_ERR, ioc->sh, MYIOC_s_FMT
+		    "Failed to act on RAID event for physical disk %d\n",
 		    ioc->name, disk);
 		return;
 	}
Index: linux-2.6.27/drivers/message/fusion/rejected_ioctls/diag_buffer.c
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/rejected_ioctls/diag_buffer.c
+++ linux-2.6.27/drivers/message/fusion/rejected_ioctls/diag_buffer.c
@@ -4,19 +4,20 @@
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is not
+ *		complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_register_diag_buffer (unsigned long arg)
+mptctl_register_diag_buffer(unsigned long arg)
 {
 	mpt_diag_register_t	__user *uarg = (void __user *) arg;
 	mpt_diag_register_t	karg;
 	MPT_ADAPTER		*ioc;
 	int			iocnum, rc, ii;
-	void *			request_data;
+	void 			*request_data;
 	dma_addr_t		request_data_dma;
 	u32			request_data_sz;
 	MPT_FRAME_HDR		*mf;
@@ -30,37 +31,39 @@ mptctl_register_diag_buffer (unsigned lo
 	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_register_t))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in mpt_diag_register_t struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
-		(ioc == NULL)) {
+	iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc);
+
+	if ((iocnum < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s enter.\n", ioc->name,
-	       	__FUNCTION__));
+		__func__));
 	buffer_type = karg.data.BufferType;
 	if (!(ioc->facts.IOCCapabilities & MPT_DIAG_CAPABILITY(buffer_type))) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have Capability for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -ENODEV;
 	}
 
 	if (ioc->DiagBuffer_Status[buffer_type] &
 	    MPT_DIAG_BUFFER_IS_REGISTERED) {
 		printk(MYIOC_s_DEBUG_FMT "%s: already has a Registered "
-		    "buffer for buffer_type=%x\n", ioc->name, __FUNCTION__,
+		    "buffer for buffer_type=%x\n", ioc->name, __func__,
 		    buffer_type);
 		return -EFAULT;
 	}
 
 	/* Get a free request frame and save the message context.
 	 */
-	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
+	mf = mpt_get_msg_frame(mptctl_id, ioc);
+	if (mf  == NULL)
 		return -EAGAIN;
 
 	request_data = ioc->DiagBuffer[buffer_type];
@@ -85,9 +88,9 @@ mptctl_register_diag_buffer (unsigned lo
 		if (request_data == NULL) {
 			printk(MYIOC_s_DEBUG_FMT "%s: pci_alloc_consistent"
 			    " FAILED, (request_sz=%d)\n", ioc->name,
-			    __FUNCTION__, request_data_sz);
+			    __func__, request_data_sz);
 			mpt_free_msg_frame(ioc, mf);
-                	return -EAGAIN;
+			return -EAGAIN;
 		}
 		ioc->DiagBuffer[buffer_type] = request_data;
 		ioc->DiagBuffer_sz[buffer_type] = request_data_sz;
@@ -95,7 +98,7 @@ mptctl_register_diag_buffer (unsigned lo
 	}
 
 	ioc->DiagBuffer_Status[buffer_type] = 0;
- 	diag_buffer_post_request = (DiagBufferPostRequest_t *)mf;
+	diag_buffer_post_request = (DiagBufferPostRequest_t *)mf;
 	diag_buffer_post_request->Function = MPI_FUNCTION_DIAG_BUFFER_POST;
 	diag_buffer_post_request->ChainOffset = 0;
 	diag_buffer_post_request->BufferType = karg.data.BufferType;
@@ -137,7 +140,7 @@ mptctl_register_diag_buffer (unsigned lo
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -ETIME;
 		printk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name,
-		    __FUNCTION__);
+		    __func__);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
 			goto out;
@@ -150,7 +153,7 @@ mptctl_register_diag_buffer (unsigned lo
 	/* process the completed Reply Message Frame */
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) == 0) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: status=%x\n",
-		    ioc->name, __FUNCTION__, ioc->ioctl_cmds.status));
+		    ioc->name, __func__, ioc->ioctl_cmds.status));
 		rc = -EFAULT;
 		goto out;
 	}
@@ -160,12 +163,13 @@ mptctl_register_diag_buffer (unsigned lo
 	    MPI_IOCSTATUS_SUCCESS) {
 		if (diag_buffer_post_reply->MsgLength > 5)
 			ioc->DataSize[buffer_type] =
-			     le32_to_cpu(diag_buffer_post_reply->TransferLength);
+			    le32_to_cpu
+			    (diag_buffer_post_reply->TransferLength);
 		ioc->DiagBuffer_Status[buffer_type] |=
 			MPT_DIAG_BUFFER_IS_REGISTERED;
 	} else {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: IOCStatus=%x "
-		    "IOCLogInfo=%x\n", ioc->name, __FUNCTION__,
+		    "IOCLogInfo=%x\n", ioc->name, __func__,
 		    diag_buffer_post_reply->IOCStatus,
 		    diag_buffer_post_reply->IOCLogInfo));
 		rc = -EFAULT;
@@ -187,18 +191,19 @@ mptctl_register_diag_buffer (unsigned lo
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_release_diag_buffer (unsigned long arg)
+mptctl_release_diag_buffer(unsigned long arg)
 {
 	mpt_diag_release_t	__user *uarg = (void __user *) arg;
 	mpt_diag_release_t	karg;
 	MPT_ADAPTER		*ioc;
-	void *			request_data;
+	void 			*request_data;
 	int			iocnum, rc;
 	MPT_FRAME_HDR		*mf;
 	DiagReleaseRequest_t 	*diag_release;
@@ -210,42 +215,42 @@ mptctl_release_diag_buffer (unsigned lon
 	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_release_t))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in mpt_diag_release_t struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
-		(ioc == NULL)) {
+	iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc);
+	if ((iocnum < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s enter.\n", ioc->name,
-	       	__FUNCTION__));
+		__func__));
 	buffer_type = karg.data.UniqueId & 0x000000ff;
 	if (!(ioc->facts.IOCCapabilities & MPT_DIAG_CAPABILITY(buffer_type))) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have Capability for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -ENODEV;
 	}
 
 	if ((ioc->DiagBuffer_Status[buffer_type] &
-	       	MPT_DIAG_BUFFER_IS_REGISTERED) == 0 ) {
+		MPT_DIAG_BUFFER_IS_REGISTERED) == 0) {
 		printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x is not "
-		    "registered\n", ioc->name, __FUNCTION__, buffer_type);
+		    "registered\n", ioc->name, __func__, buffer_type);
 		return -EFAULT;
 	}
 
 	if (karg.data.UniqueId != ioc->UniqueId[buffer_type]) {
 		printk(MYIOC_s_DEBUG_FMT "%s: unique_id=%x is not registered\n",
-		    ioc->name, __FUNCTION__, karg.data.UniqueId);
+		    ioc->name, __func__, karg.data.UniqueId);
 		return -EFAULT;
 	}
 
 	if (ioc->DiagBuffer_Status[buffer_type] & MPT_DIAG_BUFFER_IS_RELEASED) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x "
-		    "is already released\n", ioc->name, __FUNCTION__,
+		    "is already released\n", ioc->name, __func__,
 		    buffer_type));
 		return rc;
 	}
@@ -254,13 +259,14 @@ mptctl_release_diag_buffer (unsigned lon
 
 	if (request_data == NULL) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have buffer for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -ENODEV;
 	}
 
 	/* Get a free request frame and save the message context.
 	 */
-	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
+	mf = mpt_get_msg_frame(mptctl_id, ioc);
+	if (mf == NULL)
 		return -EAGAIN;
 
 	diag_release = (DiagReleaseRequest_t *)mf;
@@ -281,7 +287,7 @@ mptctl_release_diag_buffer (unsigned lon
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -ETIME;
 		printk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name,
-		    __FUNCTION__);
+		    __func__);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
 			goto out;
@@ -294,7 +300,7 @@ mptctl_release_diag_buffer (unsigned lon
 	/* process the completed Reply Message Frame */
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) == 0) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: status=%x\n",
-		    ioc->name, __FUNCTION__, ioc->ioctl_cmds.status));
+		    ioc->name, __func__, ioc->ioctl_cmds.status));
 		rc = -EFAULT;
 		goto out;
 	}
@@ -304,7 +310,7 @@ mptctl_release_diag_buffer (unsigned lon
 	    MPI_IOCSTATUS_SUCCESS) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: IOCStatus=%x "
 			"IOCLogInfo=%x\n",
-		    ioc->name, __FUNCTION__, diag_release_reply->IOCStatus,
+		    ioc->name, __func__, diag_release_reply->IOCStatus,
 		    diag_release_reply->IOCLogInfo));
 		rc = -EFAULT;
 	} else
@@ -324,19 +330,20 @@ mptctl_release_diag_buffer (unsigned lon
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset is
+ *		not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_unregister_diag_buffer (unsigned long arg)
+mptctl_unregister_diag_buffer(unsigned long arg)
 {
 	mpt_diag_unregister_t	__user *uarg = (void __user *) arg;
 	mpt_diag_unregister_t	karg;
 	MPT_ADAPTER		*ioc;
 	int			iocnum;
-	void *			request_data;
+	void 			*request_data;
 	dma_addr_t		request_data_dma;
 	u32			request_data_sz;
 	u8			buffer_type;
@@ -344,49 +351,48 @@ mptctl_unregister_diag_buffer (unsigned 
 	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_unregister_t))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in mpt_diag_unregister_t struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
-
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
-		(ioc == NULL)) {
+	iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc);
+	if ((iocnum < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s enter.\n", ioc->name,
-		__FUNCTION__));
+		__func__));
 	buffer_type = karg.data.UniqueId & 0x000000ff;
 	if (!(ioc->facts.IOCCapabilities & MPT_DIAG_CAPABILITY(buffer_type))) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have Capability for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -ENODEV;
 	}
 
 	if ((ioc->DiagBuffer_Status[buffer_type] &
 		MPT_DIAG_BUFFER_IS_REGISTERED) == 0) {
 		printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x is not "
-		    "registered\n", ioc->name, __FUNCTION__, buffer_type);
+		    "registered\n", ioc->name, __func__, buffer_type);
 		return -EFAULT;
 	}
 	if ((ioc->DiagBuffer_Status[buffer_type] &
 		MPT_DIAG_BUFFER_IS_RELEASED) == 0) {
 		printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x has not been "
-		    "released\n", ioc->name, __FUNCTION__, buffer_type);
+		    "released\n", ioc->name, __func__, buffer_type);
 		return -EFAULT;
 	}
 
 	if (karg.data.UniqueId != ioc->UniqueId[buffer_type]) {
 		printk(MYIOC_s_DEBUG_FMT "%s: unique_id=%x is not registered\n",
-		    ioc->name, __FUNCTION__, karg.data.UniqueId);
+		    ioc->name, __func__, karg.data.UniqueId);
 		return -EFAULT;
 	}
 
 	request_data = ioc->DiagBuffer[buffer_type];
 	if (!request_data) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have buffer for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -ENODEV;
 	}
 
@@ -405,18 +411,19 @@ mptctl_unregister_diag_buffer (unsigned 
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset
+ *		is not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_query_diag_buffer (unsigned long arg)
+mptctl_query_diag_buffer(unsigned long arg)
 {
 	mpt_diag_query_t	__user *uarg = (void __user *)arg;
 	mpt_diag_query_t	karg;
 	MPT_ADAPTER		*ioc;
-	void *			request_data;
+	void 			*request_data;
 	int			iocnum, ii, rc;
 	u8			buffer_type;
 
@@ -424,38 +431,38 @@ mptctl_query_diag_buffer (unsigned long 
 	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_query_t))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in mpt_diag_query_t struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
 
 	karg.data.Flags = 0;
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
-		(ioc == NULL)) {
+	iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc);
+	if ((iocnum < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		goto out;
 	}
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s enter.\n", ioc->name,
-	       	__FUNCTION__));
+		__func__));
 	buffer_type = karg.data.BufferType;
 	if (!(ioc->facts.IOCCapabilities & MPT_DIAG_CAPABILITY(buffer_type))) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have Capability for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		goto out;
 	}
 
 	if ((ioc->DiagBuffer_Status[buffer_type] &
-	       	MPT_DIAG_BUFFER_IS_REGISTERED) == 0) {
+		MPT_DIAG_BUFFER_IS_REGISTERED) == 0) {
 		printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x is not "
-		    "registered\n", ioc->name, __FUNCTION__, buffer_type);
+		    "registered\n", ioc->name, __func__, buffer_type);
 		goto out;
 	}
 
 	if (karg.data.UniqueId & 0xffffff00) {
 		if (karg.data.UniqueId != ioc->UniqueId[buffer_type]) {
 			printk(MYIOC_s_DEBUG_FMT "%s: unique_id=%x is not "
-			    "registered\n", ioc->name, __FUNCTION__,
+			    "registered\n", ioc->name, __func__,
 			    karg.data.UniqueId);
 			goto out;
 		}
@@ -464,7 +471,7 @@ mptctl_query_diag_buffer (unsigned long 
 	request_data = ioc->DiagBuffer[buffer_type];
 	if (!request_data) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have buffer for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		goto out;
 	}
 
@@ -490,7 +497,7 @@ mptctl_query_diag_buffer (unsigned long 
  out:
 	if (copy_to_user(uarg, &karg, sizeof(mpt_diag_query_t))) {
 		printk(MYIOC_s_ERR_FMT "%s Unable to write mpt_diag_query_t "
-		    "data @ %p\n", ioc->name, __FUNCTION__, uarg);
+		    "data @ %p\n", ioc->name, __func__, uarg);
 		return -EFAULT;
 	}
 	return rc;
@@ -502,13 +509,14 @@ mptctl_query_diag_buffer (unsigned long 
  * Outputs:	None.
  * Return:	0 if successful
  *		-EFAULT if data unavailable
- *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EBUSY  if previous command timout and IOC reset
+ *		is not complete.
  *		-ENODEV if no such device/adapter
  *		-ETIME	if timer expires
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_read_diag_buffer (unsigned long arg)
+mptctl_read_diag_buffer(unsigned long arg)
 {
 	mpt_diag_read_buffer_t	__user *uarg = (void __user *) arg;
 	mpt_diag_read_buffer_t	karg;
@@ -527,50 +535,49 @@ mptctl_read_diag_buffer (unsigned long a
 	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_read_buffer_t))) {
 		printk(KERN_ERR "%s@%d::%s - "
 		"Unable to read in mpt_diag_read_buffer_t struct @ %p\n",
-		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		    __FILE__, __LINE__, __func__, uarg);
 		return -EFAULT;
 	}
-
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
-		(ioc == NULL)) {
+	iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc);
+	if ((iocnum < 0) || (ioc == NULL)) {
 		printk(KERN_ERR "%s::%s() @%d - ioc%d not found!\n",
-		    __FILE__, __FUNCTION__, __LINE__, iocnum);
+		    __FILE__, __func__, __LINE__, iocnum);
 		return -ENODEV;
 	}
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s enter.\n", ioc->name,
-	    __FUNCTION__));
+		__func__));
 	buffer_type = karg.data.UniqueId & 0x000000ff;
 	if (!(ioc->facts.IOCCapabilities & MPT_DIAG_CAPABILITY(buffer_type))) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have Capability "
-		    "for buffer_type=%x\n", ioc->name, __FUNCTION__,
+		    "for buffer_type=%x\n", ioc->name, __func__,
 		    buffer_type);
 		return -EFAULT;
 	}
 
 	if (karg.data.UniqueId != ioc->UniqueId[buffer_type]) {
 		printk(MYIOC_s_DEBUG_FMT "%s: unique_id=%x is not registered\n",
-		    ioc->name, __FUNCTION__, karg.data.UniqueId);
+		    ioc->name, __func__, karg.data.UniqueId);
 		return -EFAULT;
 	}
 
 	request_data = ioc->DiagBuffer[buffer_type];
 	if (!request_data) {
 		printk(MYIOC_s_DEBUG_FMT "%s: doesn't have buffer for "
-		    "buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type);
+		    "buffer_type=%x\n", ioc->name, __func__, buffer_type);
 		return -EFAULT;
 	}
 
 	diagData = (void *)(request_data + karg.data.StartingOffset);
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: diagData=%p "
-	    "request_data=%p StartingOffset=%x\n", ioc->name, __FUNCTION__,
+	    "request_data=%p StartingOffset=%x\n", ioc->name, __func__,
 	    diagData, request_data, karg.data.StartingOffset));
 
 	if (copy_to_user((void __user *)&uarg->data.DiagnosticData[0],
 	    diagData, karg.data.BytesToRead)) {
 		printk(MYIOC_s_ERR_FMT "%s: Unable to write "
 		    "mpt_diag_read_buffer_t data @ %p\n", ioc->name,
-		    __FUNCTION__, diagData);
+		    __func__, diagData);
 		return -EFAULT;
 	}
 
@@ -578,17 +585,18 @@ mptctl_read_diag_buffer (unsigned long a
 		goto out;
 
 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: Reregister "
-		"buffer_type=%x\n", ioc->name, __FUNCTION__, buffer_type));
+		"buffer_type=%x\n", ioc->name, __func__, buffer_type));
 	if ((ioc->DiagBuffer_Status[buffer_type] &
-	    MPT_DIAG_BUFFER_IS_RELEASED) == 0) {
+		MPT_DIAG_BUFFER_IS_RELEASED) == 0) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: buffer_type=%x "
-		    "is still registered\n", ioc->name, __FUNCTION__,
+		    "is still registered\n", ioc->name, __func__,
 		    buffer_type));
 		return rc;
 	}
 	/* Get a free request frame and save the message context.
 	*/
-	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
+	mf = mpt_get_msg_frame(mptctl_id, ioc);
+	if (mf == NULL)
 		return -EAGAIN;
 
 	diag_buffer_post_request = (DiagBufferPostRequest_t *)mf;
@@ -602,7 +610,7 @@ mptctl_read_diag_buffer (unsigned long a
 	diag_buffer_post_request->Reserved2 = 0;
 	diag_buffer_post_request->Reserved3 = 0;
 	diag_buffer_post_request->BufferAddress.High = 0;
-	if ( buffer_type == MPI_DIAG_BUF_TYPE_EXTENDED )
+	if (buffer_type == MPI_DIAG_BUF_TYPE_EXTENDED)
 		diag_buffer_post_request->ExtendedType =
 			cpu_to_le32(ioc->ExtendedType[buffer_type]);
 	diag_buffer_post_request->BufferLength =
@@ -627,7 +635,7 @@ mptctl_read_diag_buffer (unsigned long a
 	if (!(ioc->ioctl_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {
 		rc = -ETIME;
 		printk(MYIOC_s_WARN_FMT "%s: failed\n", ioc->name,
-		    __FUNCTION__);
+		    __func__);
 		if (ioc->ioctl_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {
 			mpt_free_msg_frame(ioc, mf);
 			goto out;
@@ -640,7 +648,7 @@ mptctl_read_diag_buffer (unsigned long a
 	/* process the completed Reply Message Frame */
 	if ((ioc->ioctl_cmds.status & MPT_MGMT_STATUS_RF_VALID) == 0) {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: status=%x\n",
-		    ioc->name, __FUNCTION__, ioc->ioctl_cmds.status));
+		    ioc->name, __func__, ioc->ioctl_cmds.status));
 		rc = -EFAULT;
 	}
 
@@ -654,7 +662,7 @@ mptctl_read_diag_buffer (unsigned long a
 		    MPT_DIAG_BUFFER_IS_REGISTERED;
 	} else {
 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: IOCStatus=%x "
-		    "IOCLogInfo=%x\n", ioc->name, __FUNCTION__,
+		    "IOCLogInfo=%x\n", ioc->name, __func__,
 		    diag_buffer_post_reply->IOCStatus,
 		    diag_buffer_post_reply->IOCLogInfo));
 		rc = -EFAULT;
Index: linux-2.6.27/drivers/message/fusion/rejected_ioctls/diag_buffer.h
===================================================================
--- linux-2.6.27.orig/drivers/message/fusion/rejected_ioctls/diag_buffer.h
+++ linux-2.6.27/drivers/message/fusion/rejected_ioctls/diag_buffer.h
@@ -1,8 +1,13 @@
-#define MPTDIAGREGISTER				_IOWR(MPT_MAGIC_NUMBER,26,mpt_diag_register_t)
-#define MPTDIAGRELEASE				_IOWR(MPT_MAGIC_NUMBER,27,mpt_diag_release_t)
-#define MPTDIAGUNREGISTER			_IOWR(MPT_MAGIC_NUMBER,28,mpt_diag_unregister_t)
-#define MPTDIAGQUERY				_IOWR(MPT_MAGIC_NUMBER,29,mpt_diag_query_t)
-#define MPTDIAGREADBUFFER			_IOWR(MPT_MAGIC_NUMBER,30,mpt_diag_read_buffer_t)
+#define MPTDIAGREGISTER	\
+	_IOWR(MPT_MAGIC_NUMBER, 26, mpt_diag_register_t)
+#define MPTDIAGRELEASE \
+	_IOWR(MPT_MAGIC_NUMBER, 27, mpt_diag_release_t)
+#define MPTDIAGUNREGISTER \
+	_IOWR(MPT_MAGIC_NUMBER, 28, mpt_diag_unregister_t)
+#define MPTDIAGQUERY \
+	_IOWR(MPT_MAGIC_NUMBER, 29, mpt_diag_query_t)
+#define MPTDIAGREADBUFFER \
+	_IOWR(MPT_MAGIC_NUMBER, 30, mpt_diag_read_buffer_t)
 
 #define MPI_FW_DIAG_IOCTL			(0x80646961)
 #define MPI_FW_DIAG_TYPE_REGISTER		(0x00000001)
@@ -25,7 +30,8 @@
 #define MPI_FW_DIAG_ERROR_NO_BUFFER		(0x00000013)
 #define MPI_FW_DIAG_ERROR_ALREADY_RELEASED	(0x00000014)
 
-#define MPT_DIAG_CAPABILITY(bufftype)	(MPI_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER << bufftype)
+#define MPT_DIAG_CAPABILITY(bufftype) \
+    (MPI_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER << bufftype)
 
 #define MPT_DIAG_BUFFER_IS_REGISTERED 		1
 #define MPT_DIAG_BUFFER_IS_RELEASED 		2
