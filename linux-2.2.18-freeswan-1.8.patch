diff -druN linux-noipsec/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-noipsec/Documentation/Configure.help	Fri Dec 15 15:17:02 2000
+++ linux/Documentation/Configure.help	Fri Dec 15 15:18:21 2000
@@ -3715,6 +3715,59 @@
   This is a backward compatibility option, choose Y for now.
   This option will be removed soon.
 
+IP Security Protocol (IPSEC) (EXPERIMENTAL)
+CONFIG_IPSEC
+  This unit is experimental code.
+  Pick 'y' for static linking, 'm' for module support or 'n' for none.
+  This option adds support for network layer packet encryption and/or
+  authentication with participating hosts.  The standards start with:
+  RFCs 2411, 2407 and 2401.  Others are mentioned where they refer to
+  specific features below.  There are more pending which can be found
+  at:  ftp://ftp.ietf.org/internet-drafts/draft-ietf-ipsec-*.
+  A description of each document can also be found at: 
+  http://ietf.org/ids.by.wg/ipsec.html.
+  Their charter can be found at: 
+  http://www.ietf.org/html.charters/ipsec-charter.html
+  Snapshots and releases of the current work can be found at: 
+  http://www.freeswan.org/
+
+IPSEC: IP-in-IP encapsulation
+CONFIG_IPSEC_IPIP
+  This option provides support for tunnel mode IPSEC.  It is recommended
+  to enable this.
+
+IPSEC: Authentication Header
+CONFIG_IPSEC_AH
+  This option provides support for the IPSEC Authentication Header
+  (IP protocol 51) which provides packet layer sender and content
+  authentication.  It is recommended to enable this.  RFC2402
+
+HMAC-MD5 algorithm
+CONFIG_IPSEC_AUTH_HMAC_MD5
+  Provides support for authentication using the HMAC MD5
+  algorithm with 96 bits of hash used as the authenticator.  RFC2403
+
+HMAC-SHA1 algorithm
+CONFIG_IPSEC_AUTH_HMAC_SHA1
+  Provides support for Authentication Header using the HMAC SHA1
+  algorithm with 96 bits of hash used as the authenticator.  RFC2404
+
+IPSEC: Encapsulating Security Payload
+CONFIG_IPSEC_ESP
+  This option provides support for the IPSEC Encapsulation Security
+  Payload (IP protocol 50) which provides packet layer content
+  hiding.  It is recommended to enable this.  RFC2406
+
+3DES algorithm
+CONFIG_IPSEC_ENC_3DES
+  Provides support for Encapsulation Security Payload protocol, using
+  the triple DES encryption algorithm.  RFC2451
+
+IPSEC Debugging Option
+CONFIG_IPSEC_DEBUG
+  Enables IPSEC kernel debugging.  It is further controlled by the
+  user space utility 'klipsdebug'.
+
 SCSI support?
 CONFIG_SCSI
   If you want to use a SCSI hard disk, SCSI tape drive, SCSI CDROM or
diff -druN linux-noipsec/Documentation/Configure.help.wipsec linux/Documentation/Configure.help.wipsec
--- linux-noipsec/Documentation/Configure.help.wipsec	Thu Jan  1 01:00:00 1970
+++ linux/Documentation/Configure.help.wipsec	Fri Dec 15 15:18:21 2000
@@ -0,0 +1,13789 @@
+# Maintained by Axel Boldt (boldt@math.ucsb.edu)
+#
+# This version of the Linux kernel configuration help texts
+# corresponds to the kernel versions 2.2.x.
+#
+# Translations of this file available on the WWW:
+#
+#   - Japanese, maintained by the JF Project (JF@linux.or.jp), at
+#     http://www.linux.or.jp/JF/JFdocs/Configure.help/
+#   - Russian, by kaf@linux.nevod.perm.su, at
+#     http://nevod.perm.su/service/linux/doc/kernel/Configure.help
+#   - French, by Pierre Tane (tanep@bigfoot.com), at
+#     http://www.traduc.org/kernelfr
+#   - Spanish, by Carlos Perelló Marín (fperllo@ehome.encis.es), at
+#     http://visar.csustan.edu/~carlos/
+#   - Polish, by Cezar Cichocki (cezar@cs.net.pl), at
+#     http://www.cs.net.pl/~cezar/Kernel
+#   - German, by Jörg Strebel (jstrebel@suse.de) and Karl Eichwalder
+#     (ke@suse.de), at http://www.suse.de/~ke/kernel/Configure.de.help.gz
+#
+# Information about what a kernel is, what it does, how to patch and
+# compile it and much more is contained in the Kernel-HOWTO, available
+# via FTP (user: anonymous) from metalab.unc.edu in the directory
+# /pub/Linux/docs/HOWTO. Before you start compiling, make sure that
+# you have the necessary versions of all programs and libraries
+# required to compile and run this kernel; they are listed in the file
+# Documentation/Changes. Make sure to read the toplevel kernel README 
+# file as well.
+#
+# Format of this file: description<nl>variable<nl>help text<nl><nl>. If
+# the question being documented is of type "choice", we list only the
+# first occurring config variable. The help texts may contain empty
+# lines, but every non-empty line must be indented two positions.
+# Order of the help texts does not matter, however, no variable should
+# be documented twice: if it is, only the first occurrence will be
+# used by Configure. We try to keep the help texts of related variables
+# close together. Lines starting with `#' are ignored. To be nice to
+# menuconfig, limit your line length to 70 characters. Use emacs'
+# kfill.el to edit and ispell.el to spell check this file or you lose.
+#
+# If you add a help text to this file, please try to be as gentle as
+# possible. Don't use unexplained acronyms and generally write for the
+# hypothetical ignorant but intelligent user who has just bought a PC,
+# removed Windows, installed Linux and is now recompiling the kernel
+# for the first time. Tell them what to do if they're unsure. Technical 
+# information should go in a README in the Documentation directory.
+# Mention all the relevant READMEs and HOWTOs in the help text.
+# Repetitions are fine since the help texts are not meant to be read
+# in sequence.
+#
+# All this was shamelessly stolen from several different sources. Many
+# thanks to all the contributors. Feel free to use these help texts in
+# your own kernel configuration tools. The texts are copyrighted (c)
+# 1995-1999 by Axel Boldt and many others and are governed by the GNU
+# General Public License.
+
+Prompt for development and/or incomplete code/drivers
+CONFIG_EXPERIMENTAL
+  Some of the various things that Linux supports (such as network 
+  drivers, filesystems, network protocols, etc.) can be in a state 
+  of development where the functionality, stability, or the level of 
+  testing is not yet high enough for general use. This is usually
+  known as the "alpha-test" phase amongst developers. If a feature is
+  currently in alpha-test, then the developers usually discourage 
+  uninformed widespread use of this feature by the general public to
+  avoid "Why doesn't this work?" type mail messages. However, active
+  testing and use of these systems is welcomed. Just be aware that it
+  may not meet the normal level of reliability or it may fail to work
+  in some special cases. Detailed bug reports from people familiar
+  with the kernel internals are usually welcomed by the developers
+  (before submitting bug reports, please read the documents README,
+  MAINTAINERS, REPORTING_BUGS, Documentation/BUG-HUNTING, and
+  Documentation/oops-tracing.txt in the kernel source). 
+
+  Unless you intend to help test and develop a feature or driver that
+  falls into this category, or you have a situation that requires
+  using these features you should probably say N here, which will
+  cause this configure script to present you with fewer choices. If
+  you say Y here, you will be offered the choice of using features or
+  drivers that are currently considered to be in the alpha-test phase.
+
+Symmetric Multi Processing
+CONFIG_SMP
+  This enables support for systems with more than one CPU. If you have
+  a system with only one CPU, like most personal computers, say N. If
+  you have a system with more than one CPU, say Y.
+
+  If you say N here, the kernel will run on single and multiprocessor
+  machines, but will use only one CPU of a multiprocessor machine. If
+  you say Y here, the kernel will run on many, but not all,
+  singleprocessor machines. On a singleprocessor machine, the kernel
+  will run faster if you say N here.
+
+  Note that if you say Y here and choose architecture "586" or
+  "Pentium" under "Processor family", the kernel will not work on 486
+  architectures. Similarly, multiprocessor kernels for the "PPro"
+  architecture may not work on all Pentium based boards.
+
+  People using multiprocessor machines who say Y here should also say
+  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
+  Management" code will be disabled if you say Y here.
+
+  See also: Documentation/SMP.txt, Documentation/smp.tex,
+  Documentation/smp.txt, and Documentation/IO-APIC.txt.  Also see the
+  SMP-FAQ on the WWW at http://www.irisa.fr/prive/mentre/smp-faq/ (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape).
+  
+  If you don't know what to do here, say N.
+  
+Kernel math emulation
+CONFIG_MATH_EMULATION
+  Linux can emulate a math coprocessor (used for floating point
+  operations) if you don't have one. 486DX and Pentium processors have
+  a math coprocessor built in, 486SX and 386 do not, unless you added
+  a 487DX or 387, respectively. (The messages during boot time can
+  give you some hints here ["man dmesg"].) Everyone needs either a
+  coprocessor or this emulation. 
+
+  If you don't have a math coprocessor, you need to say Y here; if you
+  say Y here even though you have a coprocessor, the coprocessor will
+  be used nevertheless. (This behavior can be changed with the kernel
+  command line option "no387", which comes handy if your coprocessor
+  is broken. Try "man bootparam" or see the documentation of your boot
+  loader (lilo or loadlin) about how to pass options to the kernel at
+  boot time. The lilo procedure is also explained in the SCSI-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.) This means that it is a
+  good idea to say Y here if you intend to use this kernel on
+  different machines. 
+
+  More information about the internals of the Linux math coprocessor
+  emulation can be found in arch/i386/math-emu/README.
+
+  If you are not sure, say Y; apart from resulting in a 45 KB bigger
+  kernel, it won't hurt.
+  
+Timer and CPU usage LEDs
+CONFIG_LEDS
+  If you define this option, the LEDs on your machine will be used
+  to provide useful information about your current system status.
+
+  If you are compiling a kernel for a NetWinder or EBSA-285, you
+  will be able to select which LEDs are active using the options
+  below. If you are compiling a kernel for the EBSA-110 however,
+  the red LED will simply flash regularly to indicate that the
+  system is still functional. It is still safe to say yes here if
+  you have a CATS system, but the driver will do nothing.
+
+Timer LED
+CONFIG_LEDS_TIMER
+  If you say yes here, one of the system LEDs (the green one on the
+  NetWinder or the amber one on the EBSA285) will flash regularly to
+  indicate that the system is still operational. This is mainly
+  useful to kernel hackers who are debugging unstable kernels.
+
+CPU usage LED
+CONFIG_LEDS_CPU
+  If you say yes here, the red LED will be used to give a good real
+  time indication of CPU usage, by lighting whenever the idle task
+  is not currently executing.
+
+Kernel FP software completion
+CONFIG_MATHEMU
+  This option is required for IEEE compliant floating point arithmetic
+  on the Alpha. The only time you would ever not say Y is to say M in
+  order to debug the code. Say Y unless you know what you are doing.
+
+Normal PC floppy disk support
+CONFIG_BLK_DEV_FD
+  If you want to use the floppy disk drive(s) of your PC under Linux,
+  say Y. Information about this driver, especially important for IBM
+  Thinkpad users, is contained in drivers/block/README.fd. This file
+  also contains the location of the Floppy driver FAQ as well as
+  location of the fdutils package used to configure additional
+  parameters of the driver at run time.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called floppy.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Support for PowerMac floppy
+CONFIG_MAC_FLOPPY
+  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)
+  floppy controller, say Y here. Most commonly found in PowerMacs.
+
+RAM disk support
+CONFIG_BLK_DEV_RAM
+  Saying Y here will allow you to use a portion of your RAM memory as
+  a block device, so that you can make filesystems on it, read and
+  write to it and do all the other things that you can do with normal
+  block devices (such as hard drives). It is usually used to load and
+  store a copy of a minimal root file system off of a floppy into RAM
+  during the initial install of Linux. 
+
+  Note that the kernel command line option "ramdisk=XX" is now
+  obsolete. For details, read Documentation/ramdisk.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. The module will be called
+  rd.o. 
+
+  Most normal users won't need the RAM disk functionality, and can
+  thus say N here.
+
+Default RAM disk size
+CONFIG_BLK_DEV_RAM_SIZE
+  The default value is 4096. Only change this if you know what are
+  you doing. If you are using IBM S/390, then set this to 8192.
+
+Initial RAM disk (initrd) support
+CONFIG_BLK_DEV_INITRD
+  The initial RAM disk is a RAM disk that is loaded by the boot loader
+  (loadlin or lilo) and that is mounted as root before the normal boot
+  procedure. It is typically used to load modules needed to mount the
+  "real" root file system, etc. See Documentation/initrd.txt for
+  details.
+
+Loop device support
+CONFIG_BLK_DEV_LOOP
+  Saying Y here will allow you to use a regular file as a block
+  device; you can then create a file system on that block device and
+  mount it just as you would mount other block devices such as hard
+  drive partitions, CDROM drives or floppy drives.
+
+  This is useful if you want to check an ISO 9660 file system before
+  burning the CD, or if you want to use floppy images without first
+  writing them to floppy.
+
+  The loop device driver can also be used to "hide" a filesystem in a
+  disk partition, floppy, or regular file, either using encryption
+  (scrambling the data) or steganography (hiding the data in the low
+  bits of, say, a sound file). This is also safe if the file resides
+  on a remote file server. If you want to do this, you will first have
+  to acquire and install a kernel patch from
+  ftp://ftp.replay.com/pub/crypto/linux/all or
+  ftp://verden.pvv.org/pub/linux/kerneli/v2.1/, and then you need to
+  say Y to this option.
+
+  Note that alternative ways to use encrypted filesystems are provided
+  by the cfs package, which can be gotten via FTP (user: anonymous)
+  from ftp://ftp.replay.com/pub/crypto/disk/, and the newer tcfs
+  package, available at http://tcfs.dia.unisa.it/. You do not need to
+  say Y here if you want to use one of these. However, using cfs
+  requires saying Y to "NFS filesystem support" below while using tcfs
+  requires applying a kernel patch.
+
+  To use the loop device, you need the losetup utility and a recent
+  version of the mount program, both contained in the util-linux
+  package. The location and current version number of util-linux is
+  contained in the file Documentation/Changes.
+
+  Note that this loop device has nothing to do with the loopback
+  device used for network connections from the machine to itself.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called loop.o.
+
+  Most users will answer N here.
+
+Network Block Device support
+CONFIG_BLK_DEV_NBD
+  Saying Y here will allow your computer to be a client for network
+  block devices, i.e. it will be able to use block devices exported by
+  servers (mount filesystems on them etc.). Communication between
+  client and server works over TCP/IP networking, but to the client
+  program this is hidden: it looks like a regular local file access to
+  a block device special file such as /dev/nd0. 
+
+  Network block devices also allows you to run a block-device in
+  userland (making server and client physically the same computer,
+  communicating using the loopback network device).
+  
+  Read Documentation/nbd.txt for more information, especially about
+  where to find the server code, which runs in user space and does not
+  need special kernel support.
+
+  Note that this has nothing to do with the network file systems NFS
+  or Coda; you can say N here even if you intend to use NFS or Coda.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called nbd.o.
+
+  If unsure, say N.
+
+Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
+CONFIG_BLK_DEV_IDE
+  If you say Y here, you will use the full-featured IDE driver to
+  control up to four IDE interfaces, each being able to serve a
+  "master" and a "slave" device, for a total of up to eight IDE
+  disk/cdrom/tape/floppy drives. People with SCSI-only systems
+  can say N here.
+
+  Useful information about large (>540 MB) IDE disks, multiple
+  interfaces, what to do if IDE devices are not automatically
+  detected, sound card IDE ports, module support, and other topics, is
+  contained in Documentation/ide.txt. For detailed information about
+  hard drives, consult the Disk-HOWTO and the Multi-Disk-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  To fine-tune IDE drive/interface parameters for improved
+  performance, look for the hdparm package at
+  ftp://metalab.unc.edu/pub/Linux/kernel/patches/diskdrives/
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/ide.txt. The module will be called ide.o. Do not
+  compile this driver as a module if your root filesystem (the one
+  containing the directory /) is located on an IDE device.
+
+  If you have one or more IDE drives, say Y or M here. If your system
+  has no IDE drives, or if memory requirements are really tight, you
+  could say N here, and select the "Old hard disk driver" below
+  instead to save about 13 KB of memory in the kernel.
+
+Old hard disk (MFM/RLL/IDE) driver
+CONFIG_BLK_DEV_HD_ONLY
+  There are two drivers for MFM/RLL/IDE hard disks. Most people use
+  the newer enhanced driver, but this old one is still around for two
+  reasons. Some older systems have strange timing problems and seem to
+  work only with the old driver (which itself does not work with some
+  newer systems). The other reason is that the old driver is smaller,
+  since it lacks the enhanced functionality of the new one. This makes
+  it a good choice for systems with very tight memory restrictions, or
+  for systems with only older MFM/RLL/ESDI drives. Choosing the old
+  driver can save 13 KB or so of kernel memory. 
+
+  If you are unsure, then just choose the Enhanced IDE/MFM/RLL driver
+  instead of this one. For more detailed information, read the
+  Disk-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  People with SCSI-only systems can say N here.
+
+Use old disk-only driver on primary interface
+CONFIG_BLK_DEV_HD_IDE
+  There are two drivers for MFM/RLL/IDE disks. Most people use just
+  the new enhanced driver by itself. This option however installs the
+  old hard disk driver to control the primary IDE/disk interface in
+  the system, leaving the new enhanced IDE driver to take care of only
+  the 2nd/3rd/4th IDE interfaces. Doing this will prevent you from
+  having an IDE/ATAPI CDROM or tape drive connected to the primary IDE
+  interface. Choosing this option may be useful for older systems
+  which have MFM/RLL/ESDI controller+drives at the primary port
+  address (0x1f0), along with IDE drives at the secondary/3rd/4th port
+  addresses. 
+
+  Normally, just say N here; you will then use the new driver for all
+  4 interfaces.
+
+  People with SCSI-only systems don't need this and can say N here as
+  well.
+
+Include IDE/ATA-2 DISK support
+CONFIG_BLK_DEV_IDEDISK
+  This will include enhanced support for MFM/RLL/IDE hard disks. If
+  you have a MFM/RLL/IDE disk, and there is no special reason to use
+  the old hard disk driver instead, say Y. If you have an SCSI-only
+  system, you can say N here.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-disk.o. Do not compile this driver as a module if your
+  root filesystem (the one containing the directory /) is located on
+  the IDE disk. If unsure, say Y.
+
+Include IDE/ATAPI CDROM support
+CONFIG_BLK_DEV_IDECD
+  If you have a CDROM drive using the ATAPI protocol, say Y. ATAPI is
+  a newer protocol used by IDE CDROM and TAPE drives, similar to the
+  SCSI protocol. Most new CDROM drives use ATAPI, including the
+  NEC-260, Mitsumi FX400, Sony 55E, and just about all non-SCSI
+  double(2X) or better speed drives.
+
+  If you say Y here, the CDROM drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar (check the boot messages with dmesg). If this is your only
+  CDROM drive, you can say N to all other CDROM options, but be sure
+  to say Y or M to "ISO 9660 CDROM filesystem support".
+
+  Read the CDROM-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and the file
+  Documentation/cdrom/ide-cd. Note that older versions of lilo (the
+  Linux boot loader) cannot properly deal with IDE/ATAPI CDROMs, so
+  install lilo-16 or higher, available from
+  ftp://metalab.unc.edu/pub/Linux/system/Linux-boot/lilo.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-cd.o.
+
+Include IDE/ATAPI TAPE support
+CONFIG_BLK_DEV_IDETAPE
+  If you have an IDE tape drive using the ATAPI protocol, say Y.
+  ATAPI is a newer protocol used by IDE tape and CDROM drives, similar
+  to the SCSI protocol. If you have an SCSI tape drive however, you
+  can say N here.
+
+  If you say Y here, the tape drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar, and will be mapped to a character device such as "ht0"
+  (check the boot messages with dmesg). Be sure to consult the
+  drivers/block/ide-tape.c and Documentation/ide.txt files for usage
+  information.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-tape.o.
+
+Include IDE/ATAPI FLOPPY support
+CONFIG_BLK_DEV_IDEFLOPPY
+  If you have an IDE floppy drive which uses the ATAPI protocol,
+  answer Y. ATAPI is a newer protocol used by IDE CDROM/tape/floppy
+  drives, similar to the SCSI protocol. 
+
+  The LS-120 and the IDE/ATAPI Iomega ZIP drive are also supported by
+  this driver. (ATAPI PD-CD/CDR drives are not supported by this
+  driver; support for PD-CD/CDR drives is available if you answer Y to
+  "SCSI emulation support", below).
+
+  If you say Y here, the FLOPPY drive will be identified along with
+  other IDE devices, as "hdb" or "hdc", or something similar (check
+  the boot messages with dmesg).
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-floppy.o.
+
+SCSI emulation support
+CONFIG_BLK_DEV_IDESCSI
+  This will provide SCSI host adapter emulation for IDE ATAPI devices,
+  and will allow you to use a SCSI device driver instead of a native
+  ATAPI driver.
+
+  This is useful if you have an ATAPI device for which no native
+  driver has been written (for example, an ATAPI PD-CD or CDR drive);
+  you can then use this emulation together with an appropriate SCSI
+  device driver. In order to do this, say Y here and to "SCSI support"
+  and "SCSI generic support", below.
+
+  Note that this option does NOT allow you to attach SCSI devices to a
+  box that doesn't have a SCSI host adapter installed.
+
+  If both this SCSI emulation and native ATAPI support are compiled
+  into the kernel, the native support will be used.
+
+  People with SCSI-only systems can say N here. If unsure, say N.
+
+CMD640 chipset bugfix/support
+CONFIG_BLK_DEV_CMD640
+  The CMD-Technologies CMD640 IDE chip is used on many common 486 and
+  Pentium motherboards, usually in combination with a "Neptune" or
+  "SiS" chipset. Unfortunately, it has a number of rather nasty
+  design flaws that can cause severe data corruption under many common
+  conditions. Say Y here to include code which tries to automatically
+  detect and correct the problems under Linux. This option also
+  enables access to the secondary IDE ports in some CMD640 based
+  systems. 
+
+  This driver will work automatically in PCI based systems (most new
+  systems have PCI slots). But if your system uses VESA local bus
+  (VLB) instead of PCI, you must also supply a kernel boot parameter
+  to enable the CMD640 bugfix/support: "ide0=cmd640_vlb". (Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel. The lilo procedure is also explained in
+  the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+
+  The CMD640 chip is also used on add-in cards by Acculogic, and on
+  the "CSA-6400E PCI to IDE controller" that some people have. For
+  details, read Documentation/ide.txt. 
+
+  People with SCSI-only systems should say N here. If unsure, say Y.
+
+CMD640 enhanced support
+CONFIG_BLK_DEV_CMD640_ENHANCED
+  This option includes support for setting/autotuning PIO modes and
+  prefetch on CMD640 IDE interfaces. For details, read
+  Documentation/ide.txt. If you have a CMD640 IDE interface and your
+  BIOS does not already do this for you, then say Y here. Otherwise
+  say N.
+
+RZ1000 chipset bugfix/support
+CONFIG_BLK_DEV_RZ1000
+  The PC-Technologies RZ1000 IDE chip is used on many common 486 and
+  Pentium motherboards, usually along with the "Neptune" chipset.
+  Unfortunately, it has a rather nasty design flaw that can cause
+  severe data corruption under many conditions. Say Y here to include
+  code which automatically detects and corrects the problem under
+  Linux. This may slow disk throughput by a few percent, but at least
+  things will operate 100% reliably. 
+
+  People with SCSI-only systems should say N here. If unsure, say Y.
+
+Generic PCI IDE chipset support
+CONFIG_BLK_DEV_IDEPCI
+  Say Y here for PCI systems which use IDE drive(s).
+  This option helps the IDE driver to automatically detect and
+  configure all PCI-based IDE interfaces in your system.
+  
+  People with SCSI-only systems should say N here; if unsure say Y.
+
+Generic PCI bus-master DMA support
+CONFIG_BLK_DEV_IDEDMA
+  If your PCI system uses IDE drive(s) (as opposed to SCSI, say) and
+  is capable of bus-master DMA operation (most Pentium PCI systems),
+  you will want to say Y here to reduce CPU overhead. You can then use
+  the "hdparm" utility to enable DMA for drives for which it was not
+  enabled automatically. By default, DMA is not enabled automatically
+  for these drives, but you can change that by saying Y to the
+  following question "Use DMA by default when available". You can get
+  the latest version of the hdparm utility via anonymous FTP from
+  ftp://metalab.unc.edu/pub/Linux/system/hardware/.
+
+  Read the comments at the beginning of drivers/block/idedma.c and the
+  file Documentation/ide.txt for more information. 
+
+  It is safe to say Y to this question.
+
+Winbond SL82c105 support
+CONFIG_BLK_DEV_SL82C105
+  If you have a Winbond SL82c105 IDE controller, say Y here to enable
+  special configuration for this chip. This is common on various CHRP
+  motherboards, but could be used elsewhere. If in doubt, say Y.
+
+Boot off-board chipsets first support
+CONFIG_BLK_DEV_OFFBOARD
+  Normally, IDE controllers built into the motherboard (on-board
+  controllers) are assigned to ide0 and ide1 while those on add-in PCI
+  cards (off-board controllers) are relegated to ide2 and ide3.
+  Answering Y here will reverse the situation, with off-board
+  controllers on ide0/1 and on-board controllers on ide2/3. This can
+  improve the usability of some boot managers such as LILO when
+  booting from a drive on an off-board controller.
+
+  Note that, if you say Y here, the order of the hd* devices will be
+  rearranged which may require modification of fstab and other files.
+
+  If in doubt, say N.
+
+Use DMA by default when available
+CONFIG_IDEDMA_AUTO
+  Prior to kernel version 2.1.112, Linux used to automatically use
+  DMA for IDE drives and chipsets which support it. Due to concerns
+  about a couple of cases where buggy hardware may have caused damage,
+  the default is now to NOT use DMA automatically. To revert to the
+  previous behaviour, say Y to this question.
+
+  If you suspect your hardware is at all flakey, say N here.
+  Do NOT email the IDE kernel people regarding this issue!
+
+  It is normally safe to answer Y to this question unless your
+  motherboard uses a VIA VP2 chipset, in which case you should say N.
+
+Other IDE chipset support
+CONFIG_IDE_CHIPSETS
+  Say Y here if you want to include enhanced support for various IDE
+  interface chipsets used on motherboards and add-on cards. You can
+  then pick your particular IDE chip from among the following options.
+  This enhanced support may be necessary for Linux to be able to
+  access the 3rd/4th drives in some systems. It may also enable
+  setting of higher speed I/O rates to improve system performance with
+  these chipsets. Most of these also require special kernel boot
+  parameters to actually turn on the support at runtime; you can find
+  a list of these in the file Documentation/ide.txt.
+  
+  People with SCSI-only systems can say N here. 
+
+Generic 4 drives/port support
+CONFIG_BLK_DEV_4DRIVES
+  Certain older chipsets, including the Tekram 690CD, use a single set
+  of I/O ports at 0x1f0 to control up to four drives, instead of the
+  customary two drives per port. Support for this can be enabled at
+  runtime using the "ide0=four" kernel boot parameter if you say Y
+  here.
+
+DTC-2278 support
+CONFIG_BLK_DEV_DTC2278
+  This driver is enabled at runtime using the "ide0=dtc2278" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the DTC-2278 card, and permits faster I/O speeds to be set as
+  well. See the Documentation/ide.txt and drivers/block/dtc2278.c
+  files for more info.
+
+Holtek HT6560B support
+CONFIG_BLK_DEV_HT6560B
+  This driver is enabled at runtime using the "ide0=ht6560b" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the Holtek card, and permits faster I/O speeds to be set as well.
+  See the Documentation/ide.txt and drivers/block/ht6560b.c files for
+  more info.
+
+PROMISE DC4030 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_PDC4030
+  This driver provides support for the secondary IDE interface and
+  cache of Promise IDE chipsets, e.g. DC4030 and DC5030. This driver
+  is known to incur timeouts/retries during heavy I/O to drives
+  attached to the secondary interface. CDROM and TAPE devices are not
+  supported yet. This driver is enabled at runtime using the
+  "ide0=dc4030" kernel boot parameter. See the Documentation/ide.txt
+  and drivers/block/pdc4030.c files for more info.
+
+PS/2 ESDI hard disk support
+CONFIG_BLK_DEV_PS2
+  Say Y here if you have a PS/2 machine with a MCA bus and an ESDI
+  hard disk.
+  
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ps2esdi.o.
+
+ALI M15X3 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_ALI15X3
+  This driver ensures (U)DMA support for ALI 1543 and 1543C,
+  1535, 1535D onboard chipsets.
+
+Tekram TRM290 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_TRM290
+  This driver adds support for bus master DMA transfers
+  using the Tekram TRM290 PCI IDE chip. Volunteers are
+  needed for further tweaking and development.
+  Please read the comments at the top of drivers/block/trm290.c.
+
+OPTi 82C621 enhanced support (EXPERIMENTAL)
+CONFIG_BLK_DEV_OPTI621
+  This is a driver for the OPTi 82C621 EIDE controller.
+  Please read the comments at the top of drivers/block/opti621.c.
+
+NS87415 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_NS87415
+  This driver adds detection and support for the NS87415 chip
+  (used in SPARC64, among others).
+
+  Please read the comments at the top of drivers/block/ns87415.c.
+
+VIA82C586 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_VIA82C586
+  This adds initial timing settings for VIA (U)DMA onboard ide
+  controllers that are ATA3 compliant. May work with ATA4 systems, but
+  not tested to date.
+
+  If you say Y here, you also need to say Y to "Use DMA by default
+  when available", above.
+
+  If unsure, say N.
+
+CMD646 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_CMD646
+  Say Y here if you have an IDE controller like this.
+
+Cyrix CS5530 MediaGX chipset support
+CONFIG_BLK_DEV_CS5530
+  Include support for UDMA on the Cyrix MediaGX 5530 chipset. This
+  will automatically be detected and configured if found.
+
+  It is safe to say Y to this question.
+
+QDI QD6580 support
+CONFIG_BLK_DEV_QD6580
+  This driver is enabled at runtime using the "ide0=qd6580" kernel
+  boot parameter. It permits faster I/O speeds to be set. See the
+  files Documentation/ide.txt and drivers/block/qd6580.c for more
+  info.
+
+UMC 8672 support
+CONFIG_BLK_DEV_UMC8672
+  This driver is enabled at runtime using the "ide0=umc8672" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the UMC-8672, and permits faster I/O speeds to be set as well.
+  See the files Documentation/ide.txt and drivers/block/umc8672.c for
+  more info.
+
+ALI M14xx support
+CONFIG_BLK_DEV_ALI14XX
+  This driver is enabled at runtime using the "ide0=ali14xx" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the ALI M1439/1443/1445/1487/1489 chipsets, and permits faster
+  I/O speeds to be set as well. See the files Documentation/ide.txt
+  and drivers/block/ali14xx.c for more info.
+
+Generic PC I/O port IDE interface support
+CONFIG_BLK_DEV_PCIDE
+  This is the IDE driver for most generic PC style IDE interfaces.
+  Say Y if you have a PC and want to use IDE devices (hard disks, CD-ROM
+  drives, etc.) that are connected to the builtin IDE interface.
+
+Amiga builtin Gayle IDE interface support
+CONFIG_BLK_DEV_GAYLE
+  This is the IDE driver for the builtin IDE interface on some Amiga
+  models.  It supports both the `A1200 style' (used in A600 and A1200)
+  and `A4000 style' (used in A4000 and A4000T) of the Gayle IDE
+  interface.
+  Say Y if you have such an Amiga model and want to use IDE devices
+  (hard disks, CD-ROM drives, etc.) that are connected to the builtin
+  IDE interface.
+
+Falcon IDE interface support
+CONFIG_BLK_DEV_FALCON_IDE
+  This is the IDE driver for the builtin IDE interface on the Atari
+  Falcon.
+  Say Y if you have a Falcon and want to use IDE devices (hard disks,
+  CD-ROM drives, etc.) that are connected to the builtin IDE interface.
+
+Amiga Buddha/Catweasel IDE interface support (EXPERIMENTAL)
+CONFIG_BLK_DEV_BUDDHA
+  This is the IDE driver for the IDE interfaces on the Buddha and
+  Catweasel expansion boards.  It supports up to two interfaces on the
+  Buddha and three on the Catweasel.
+  Say Y if you have a Buddha or Catweasel expansion board and want to
+  use IDE devices (hard disks, CD-ROM drives, etc.) that are connected
+  to one of its IDE interfaces.
+
+Amiga IDE Doubler support (EXPERIMENTAL)
+CONFIG_BLK_DEV_IDEDOUBLER
+  This driver provides support for the so called `IDE doublers' (made by
+  various manufacturers, e.g. Eyetech) that can be connected to the
+  builtin IDE interface of some Amiga models. Using such an IDE doubler,
+  you can connect up to four instead of two IDE devices on the Amiga's
+  builtin IDE interface.
+  Note that the normal Amiga Gayle IDE driver may not work correctly if
+  you have an IDE doubler and don't enable this driver!
+  Say Y if you have an IDE doubler.  The driver is enabled at kernel
+  runtime using the "ide=doubler" kernel boot parameter.
+
+XT hard disk support
+CONFIG_BLK_DEV_XD
+  Very old 8 bit hard disk controllers used in the IBM XT computer
+  will be supported if you say Y here. 
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called xd.o. 
+
+  It's pretty unlikely that you have one of these: say N.
+
+Mylex DAC960/DAC1100 PCI RAID Controller support
+CONFIG_BLK_DEV_DAC960
+  This driver adds support for the Mylex DAC960, AcceleRAID, and
+  eXtremeRAID PCI RAID controllers.  See README.DAC960 for further
+  information about this driver.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt.  The module will be
+  called DAC960.o. 
+
+Parallel port IDE device support
+CONFIG_PARIDE
+  There are many external CD-ROM and disk devices that connect through
+  your computer's parallel port. Most of them are actually IDE devices
+  using a parallel port IDE adapter. This option enables the PARIDE
+  subsystem which contains drivers for many of these external drives.
+  Read linux/Documentation/paride.txt for more information.
+
+  If you have said Y to the "Parallel-port support" configuration
+  option, you may share a single port between your printer and other
+  parallel port devices. Answer Y to build PARIDE support into your
+  kernel, or M if you would like to build it as a loadable module. If
+  your parallel port support is in a loadable module, you must build
+  PARIDE as a module. If you built PARIDE support into your kernel,
+  you may still build the individual protocol modules and high-level
+  drivers as loadable modules. If you build this support as a module,
+  it will be called paride.o.
+
+  To use the PARIDE support, you must say Y or M here and also to at
+  least one high-level driver (e.g. "Parallel port IDE disks",
+  "Parallel port ATAPI CD-ROMs", "Parallel port ATAPI disks" etc.) and
+  to at least one protocol driver (e.g. "ATEN EH-100 protocol",
+  "MicroSolutions backpack protocol", "DataStor Commuter protocol"
+  etc.).
+
+Parallel port IDE disks
+CONFIG_PARIDE_PD
+  This option enables the high-level driver for IDE-type disk devices 
+  connected through a parallel port. If you chose to build PARIDE 
+  support into your kernel, you may answer Y here to build in the 
+  parallel port IDE driver, otherwise you should answer M to build 
+  it as a loadable module. The module will be called pd.o. You 
+  must also have at least one parallel port protocol driver in your 
+  system. Among the devices supported by this driver are the SyQuest 
+  EZ-135, EZ-230 and SparQ drives, the Avatar Shark and the backpack
+  hard drives from MicroSolutions.
+
+Parallel port ATAPI CD-ROMs
+CONFIG_PARIDE_PCD
+  This option enables the high-level driver for ATAPI CD-ROM devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI CD-ROM driver, otherwise you should answer M to
+  build it as a loadable module. The module will be called pcd.o. You
+  must also have at least one parallel port protocol driver in your
+  system. Among the devices supported by this driver are the
+  MicroSolutions backpack CD-ROM drives and the Freecom Power CD. If
+  you have such a CD-ROM drive, you should also say Y or M to "ISO
+  9660 CDROM filesystem support" below, because that's the filesystem
+  used on CDROMs.
+
+Parallel port ATAPI disks
+CONFIG_PARIDE_PF
+  This option enables the high-level driver for ATAPI disk devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pf.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver are the
+  MicroSolutions backpack PD/CD drive and the Imation Superdisk
+  LS-120 drive.
+
+Parallel port ATAPI tapes
+CONFIG_PARIDE_PT
+  This option enables the high-level driver for ATAPI tape devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pt.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver is the
+  parallel port version of the HP 5GB drive.
+
+Parallel port generic ATAPI devices
+CONFIG_PARIDE_PG
+  This option enables a special high-level driver for generic ATAPI
+  devices connected through a parallel port. The driver allows user
+  programs, such as cdrecord, to send ATAPI commands directly to a
+  device. 
+
+  If you chose to build PARIDE support into your kernel, you may
+  answer Y here to build in the parallel port generic ATAPI driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called pg.o.
+
+  You must also have at least one parallel port protocol driver in
+  your system.
+
+  This driver implements an API loosely related to the generic SCSI
+  driver. See /usr/include/linux/pg.h for details.
+
+  You can obtain the most recent version of cdrecord from
+  ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/ . Versions 1.6.1a3 and
+  later fully support this driver.
+
+ATEN EH-100 protocol
+CONFIG_PARIDE_ATEN
+  This option enables support for the ATEN EH-100 parallel port IDE
+  protocol. This protocol is used in some inexpensive low performance
+  parallel port kits made in Hong Kong. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called aten.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+MicroSolutions backpack protocol
+CONFIG_PARIDE_BPCK
+  This option enables support for the MicroSolutions backpack parallel
+  port IDE protocol. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called bpck.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+DataStor Commuter protocol
+CONFIG_PARIDE_COMM
+  This option enables support for the Commuter parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called comm.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+DataStor EP-2000 protocol
+CONFIG_PARIDE_DSTR
+  This option enables support for the EP-2000 parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called dstr.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+Shuttle EPAT/EPEZ protocol
+CONFIG_PARIDE_EPAT
+  This option enables support for the EPAT parallel port IDE protocol.
+  EPAT is a parallel port IDE adapter manufactured by Shuttle
+  Technology and widely used in devices from major vendors such as
+  Hewlett-Packard, SyQuest, Imation and Avatar. If you chose to build
+  PARIDE support into your kernel, you may answer Y here to build in
+  the protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called epat.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+Shuttle EPIA protocol
+CONFIG_PARIDE_EPIA
+  This option enables support for the (obsolete) EPIA parallel port
+  IDE protocol from Shuttle Technology. This adapter can still be
+  found in some no-name kits. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called epia.o. You must also have a
+  high-level driver for the type of device that you want to support.
+
+FIT TD-2000 protocol
+CONFIG_PARIDE_FIT2
+  This option enables support for the TD-2000 parallel port IDE
+  protocol from Fidelity International Technology. This is a simple
+  (low speed) adapter that is used in some portable hard drives. If
+  you chose to build PARIDE support into your kernel, you may answer Y
+  here to build in the protocol driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called ktti.o.
+  You must also have a high-level driver for the type of device that
+  you want to support.
+
+FIT TD-3000 protocol
+CONFIG_PARIDE_FIT3
+  This option enables support for the TD-3000 parallel port IDE
+  protocol from Fidelity International Technology. This protocol is
+  used in newer models of their portable disk, CD-ROM and PD/CD
+  devices. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called fit3.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Freecom IQ ASIC-2 protocol
+CONFIG_PARIDE_FRIQ
+  This option enables support for version 2 of the Freecom IQ parallel
+  port IDE adapter.  This adapter is used by the Maxell Superdisk 
+  drive.  If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called friq.o. You must also have a high-level driver for the type
+  of device that you want to support. 
+
+FreeCom power protocol
+CONFIG_PARIDE_FRPW
+  This option enables support for the Freecom power parallel port IDE
+  protocol. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called frpw.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+KingByte KBIC-951A/971A protocols
+CONFIG_PARIDE_KBIC
+  This option enables support for the KBIC-951A and KBIC-971A parallel
+  port IDE protocols from KingByte Information Corp. KingByte's
+  adapters appear in many no-name portable disk and CD-ROM products,
+  especially in Europe. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called kbic.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+KT PHd protocol
+CONFIG_PARIDE_KTTI
+  This option enables support for the "PHd" parallel port IDE protocol
+  from KT Technology. This is a simple (low speed) adapter that is
+  used in some 2.5" portable hard drives. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called ktti.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+OnSpec 90c20 protocol
+CONFIG_PARIDE_ON20
+  This option enables support for the (obsolete) 90c20 parallel port 
+  IDE protocol from OnSpec (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you 
+  may answer Y here to build in the protocol driver, otherwise you 
+  should answer M to build it as a loadable module. The module will 
+  be called on20.o. You must also have a high-level driver for the 
+  type of device that you want to support.
+
+OnSpec 90c26 protocol
+CONFIG_PARIDE_ON26
+  This option enables support for the 90c26 parallel port IDE protocol
+  from OnSpec Electronics (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called on26.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Multiple devices driver support
+CONFIG_BLK_DEV_MD
+  This driver lets you combine several hard disk partitions into one
+  logical block device. This can be used to simply append one
+  partition to another one or to combine several redundant
+  hard disks to a RAID1/4/5 device so as to provide protection against
+  hard disk failures. This is called "Software RAID" since the
+  combining of the partitions is done by the kernel. "Hardware RAID"
+  means that the combining is done by a dedicated controller; if you
+  have such a controller, you do not need to say Y here.
+
+  More information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If unsure, say N.
+
+Linear (append) mode
+CONFIG_MD_LINEAR
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called linear mode, i.e. it will combine the hard disk
+  partitions by simply appending one to the other. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called linear.o.
+
+  If unsure, say Y.
+
+RAID-0 (striping) mode
+CONFIG_MD_STRIPED
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called raid0 mode, i.e. it will combine the hard disk
+  partitions into one logical device in such a fashion as to fill them
+  up evenly, one chunk here and one chunk there. This will increase
+  the throughput rate if the partitions reside on distinct disks. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called raid0.o.
+
+  If unsure, say Y.
+
+RAID-1 (mirroring) mode
+CONFIG_MD_MIRRORING
+  A RAID-1 set consists of several disk drives which are exact copies
+  of each other. In the event of a mirror failure, the RAID driver
+  will continue to use the operational mirrors in the set, providing
+  an error free MD (multiple device) to the higher levels of the
+  kernel. In a set with N drives, the available space is the capacity
+  of a single drive, and the set protects against a failure of (N - 1)
+  drives. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-1 set, say Y. This code is also
+  available as a module called raid1.o ( = code which can be inserted
+  in and removed from the running kernel whenever you want). If you
+  want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+RAID-4/RAID-5 mode
+CONFIG_MD_RAID5
+  A RAID-5 set of N drives with a capacity of C MB per drive provides
+  the capacity of C * (N - 1) drives, and protects against a failure
+  of a single drive. For a given sector (row) number, (N - 1) drives
+  contain data sectors, and one drive contains the parity protection.
+  For a RAID-4 set, the parity blocks are present on a single drive,
+  while a RAID-5 set distributes the parity across the drives in one
+  of the available parity distribution methods.
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-4/RAID-5 set, say Y. This code is
+  also available as a module called raid5.o ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+Boot support (linear, striped)
+CONFIG_MD_BOOT
+  To boot with an initial linear or striped md device you have to
+  answer Y here. For lilo and loadlin options see the file
+  Documentation/md.txt.
+
+Support for Deskstation RPC44 
+CONFIG_DESKSTATION_RPC44
+  This is a machine with a R4400 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux
+  on the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).
+
+Support for Acer PICA 1 chipset
+CONFIG_ACER_PICA_61
+  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+Support for Algorithmics P4032
+CONFIG_ALGOR_P4032
+  This is an evaluation board of the British company Algorithmics. The
+  board uses the R4300 and a R5230 CPUs. For more information about
+  this board see http://www.algor.co.uk.
+
+IDE card support
+CONFIG_BLK_DEV_IDE_CARDS
+  On Acorn systems, enable this if you wish to use an IDE interface
+  expansion card. If you do not or are unsure, say N to this.
+
+ICS IDE interface
+CONFIG_BLK_DEV_IDE_ICS
+  On Acorn systems, enable this if you wish to use the ICS IDE
+  interface card.  This is not required for ICS partition support.
+  If you are unsure, say N to this.
+
+ADFS partition support
+CONFIG_BLK_DEV_PART
+  This allows Linux on Acorn systems to determine its partitions in
+  the 'non-ADFS' partition area of the hard disk - usually located
+  after the ADFS partition.  You are probably using this system, so
+  you should enable it.
+
+Support for Mips Magnum 4000
+CONFIG_MIPS_MAGNUM_4000
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+Support for Olivetti M700
+CONFIG_OLIVETTI_M700
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+CPU type
+CONFIG_CPU_R3000
+  Give the type of your machine's MIPS CPU. For this question, it
+  suffices to give a unique prefix of the option you want to choose.
+  In case of doubt select the R3000 CPU. The kernel will then run on
+  other MIPS machines but with slightly reduced performance.
+
+Compile the kernel into the ECOFF object format
+CONFIG_ECOFF_KERNEL
+  Some machines require a kernel in the ECOFF format. You will have to
+  say Y here for example if you want to use a Mips Magnum 3000 or a
+  DECstation.
+
+Generate little endian code
+CONFIG_CPU_LITTLE_ENDIAN
+  Some MIPS machines can be configured for either little or big endian
+  byte order. These modes require different kernels. Say Y if your
+  machine is little endian, N if it's a big endian machine.
+
+Kernel support for IRIX binaries
+CONFIG_BINFMT_IRIX
+  If you say Y here, the kernel will support running of IRIX binaries.
+  You will need IRIX libraries for this to work.
+
+Networking support
+CONFIG_NET
+  Unless you really know what you are doing, you should say Y here.
+  The reason is that some programs need kernel networking support even
+  when running on a stand-alone machine that isn't connected to any
+  other computer. If you are upgrading from an older kernel, you
+  should consider updating your networking tools too because changes
+  in the kernel and the tools often go hand in hand. The tools are
+  contained in the package net-tools, the location and version number
+  of which are given in Documentation/Changes.
+
+  For a general introduction to Linux networking, it is highly
+  recommended to read the NET-3-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+Socket filtering
+CONFIG_FILTER
+  The Linux Socket Filter is derived from the Berkeley Packet Filter.
+  If you say Y here, user-space programs can attach a filter to any
+  socket and thereby tell the kernel that it should allow or disallow
+  certain types of data to get through the socket. Linux Socket
+  Filtering works on all socket types except TCP for now. See the text
+  file linux/Documentation/networking/filter.txt for more information.
+  If unsure, say N.
+
+Network firewalls
+CONFIG_FIREWALL
+  A firewall is a computer which protects a local network from the
+  rest of the world: all traffic to and from computers on the local
+  net is inspected by the firewall first, and sometimes blocked or
+  modified. The type of firewall you'll get if you say Y here is
+  called a "packet filter": it can block network traffic based on
+  type, origin and destination. By contrast, "proxy-based" firewalls
+  are more secure but more intrusive and more bothersome to set up;
+  they inspect the network traffic much more closely, modify it and
+  have knowledge about the higher level protocols, which packet
+  filters lack. They also often require changes in the programs
+  running on the local clients. Proxy-based firewalls don't need
+  support by the kernel, but they are often combined with packet
+  filters, which only works if you say Y here.
+
+  If you want to configure your Linux box as a packet filter firewall
+  for a local network, say Y here. If your local network is TCP/IP
+  based, you will then also have to say Y to "IP: firewalling", below.
+
+  You also need to say Y here and to "IP firewalling" below in order
+  to be able to use IP masquerading (i.e. local computers can chat
+  with an outside host, but that outside host is made to think that it
+  is talking to the firewall box -- makes the local network completely
+  invisible to the outside world and avoids the need to allocate
+  globally valid IP host addresses for the machines on the local net)
+  and IP transparent proxying (makes the computers on the local
+  network think they're talking to a remote computer, while in reality
+  the traffic is redirected by your Linux firewall to a local proxy
+  server).
+
+  Make sure to say N to "Fast switching" below if you intend to say Y
+  here.
+
+  Chances are that you should say Y here for every machine which is
+  run as a router and N for every regular host. If unsure, say N.
+
+SYN flood protection
+CONFIG_SYN_COOKIES
+  Normal TCP/IP networking is open to an attack known as "SYN
+  flooding". This denial-of-service attack prevents legitimate remote
+  users from being able to connect to your computer during an ongoing
+  attack and requires very little work from the attacker, who can
+  operate from anywhere on the Internet.
+
+  SYN cookies provide protection against this type of attack. If you
+  say Y here, the TCP/IP stack will use a cryptographic challenge
+  protocol known as "SYN cookies" to enable legitimate users to
+  continue to connect, even when your machine is under attack. There
+  is no need for the legitimate users to change their TCP/IP software;
+  SYN cookies work transparently to them. For technical information
+  about SYN cookies, check out
+  ftp://koobera.math.uic.edu/syncookies.html .
+
+  If you are SYN flooded, the source address reported by the kernel is
+  likely to have been forged by the attacker; it is only reported as
+  an aid in tracing the packets to their actual source and should not
+  be taken as absolute truth.
+
+  SYN cookies may prevent correct error reporting on clients when the
+  server is really overloaded. If this happens frequently better turn
+  them off.
+
+  If you say Y here, note that SYN cookies aren't enabled by default;
+  you can enable them by saying Y to "/proc filesystem support" and
+  "Sysctl support" below and executing the command
+
+    echo 1 >/proc/sys/net/ipv4/tcp_syncookies 
+
+  at boot time after the proc filesystem has been mounted.
+  
+  If unsure, say Y.
+
+Sun floppy controller support
+CONFIG_BLK_DEV_SUNFD
+  This is support for floppy drives on Sun SPARC workstations. Say Y
+  if you have a floppy drive, otherwise N. Easy.
+
+Alpha system type
+CONFIG_ALPHA_GENERIC
+  This is the system type of your hardware.  A "generic" kernel will
+  run on any supported Alpha system. However, if you configure a
+  kernel for your specific system, it will be faster and smaller.
+
+  To find out what type of Alpha system you have, you may want to
+  check out the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).  In summary:
+
+  Alcor/Alpha-XLT     AS 600
+  Alpha-XL            XL-233, XL-266
+  AlphaBook1          Alpha laptop
+  Avanti              AS 200, AS 205, AS 250, AS 255, AS 300, AS 400
+  Cabriolet           AlphaPC64, AlphaPCI64
+  DP264               DP264
+  EB164               EB164 21164 evaluation board
+  EB64+               EB64+ 21064 evaluation board
+  EB66                EB66 21066 evaluation board
+  EB66+               EB66+ 21066 evaluation board
+  Jensen              DECpc 150, DEC 2000 model 300, 
+                      DEC 2000 model 500
+  LX164               AlphaPC164-LX
+  Miata               Personal Workstation 433a, 433au, 500a,
+                      500au, 600a, or 600au
+  Mikasa              AS 1000
+  Noname              AXPpci33, UDB (Multia)
+  Noritake            AS 1000A, AS 600A, AS 800
+  PC164               AlphaPC164
+  Rawhide             AS 1200, AS 4000, AS 4100
+  Ruffian             RPX164-2, AlphaPC164-UX, AlphaPC164-BX
+  SX164               AlphaPC164-SX
+  Sable               AS 2000, AS 2100
+  Takara              Takara
+
+  If you don't know what to do, choose "generic".
+
+EV5 CPU daughtercard
+CONFIG_ALPHA_PRIMO
+  Say Y if you have an AS 1000 5/xxx or an AS 1000A 5/xxx.
+
+EV5 CPU(s)
+CONFIG_ALPHA_GAMMA
+  Say Y if you have an AS 2000 5/xxx or an AS 2100 5/xxx.
+
+Using SRM as bootloader
+CONFIG_ALPHA_SRM
+  There are two different types of booting firmware on Alphas: SRM,
+  which is command line driven, and ARC, which uses menus and arrow
+  keys. Details about the Linux/Alpha booting process are contained in
+  the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).
+
+  The usual way to load Linux on an Alpha machine is to use MILO
+  (a bootloader that lets you pass command line parameters to the
+  kernel just like lilo does for the x86 architecture) which can be
+  loaded either from ARC or can be installed directly as a permanent
+  firmware replacement from floppy (which requires changing a certain
+  jumper on the motherboard). If you want to do either of these, say N
+  here. If MILO doesn't work on your system (true for Jensen
+  motherboards), you can bypass it altogether and boot Linux directly
+  from an SRM console; say Y here in order to do that. Note that you
+  won't be able to boot from an IDE disk using SRM. 
+
+  If unsure, say N.
+
+Use SRM PCI setup
+CONFIG_ALPHA_SRM_SETUP
+  This option controls whether or not the PCI configuration set up by
+  SRM is modified.  If you say Y, the existing PCI configuration will
+  be left intact.
+
+Non-standard serial port support
+CONFIG_SERIAL_NONSTANDARD
+  Say Y here if you have any non-standard serial boards -- boards
+  which aren't supported using the standard "dumb" serial driver.
+  This includes intelligent serial boards such as Cyclades,
+  Digiboards, etc. These are usually used for systems that need many
+  serial ports because they serve many terminals or dial-in
+  connections. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-standard serial boards. 
+
+  Most people can say N here.
+
+Extended dumb serial driver options
+CONFIG_SERIAL_EXTENDED
+  If you wish to use any non-standard features of the standard "dumb"
+  driver, say Y here. This includes HUB6 support, shared serial
+  interrupts, special multiport support, support for more than the
+  four COM 1/2/3/4 boards, etc. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about serial driver options. If unsure, say N.
+
+Support more than 4 serial ports
+CONFIG_SERIAL_MANY_PORTS
+  Say Y here if you have dumb serial boards other than the four
+  standard COM 1/2/3/4 ports. This may happen if you have an AST
+  FourPort, Accent Async, Boca (read the Boca mini-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini), or other custom
+  serial port hardware which acts similar to standard serial port
+  hardware. If you only use the standard COM 1/2/3/4 ports, you can
+  say N here to save some memory. You can also say Y if you have an
+  "intelligent" multiport card such as Cyclades, Digiboards, etc.
+
+Support for sharing serial interrupts
+CONFIG_SERIAL_SHARE_IRQ
+  Some serial boards have hardware support which allows multiple dumb
+  serial ports on the same board to share a single IRQ. To enable
+  support for this in the serial driver, say Y here.
+
+Auto detect IRQ on standard ports (unsafe)
+CONFIG_SERIAL_DETECT_IRQ
+  Say Y here if you want the kernel to try to guess which IRQ
+  to use for your serial port. 
+
+  This is considered unsafe; it is far better to configure the IRQ in
+  a boot script using the setserial command.
+
+  If unsure, say N.
+
+Support special multiport boards
+CONFIG_SERIAL_MULTIPORT
+  Some multiport serial ports have special ports which are used to
+  signal when there are any serial ports on the board which need
+  servicing. Say Y here to enable the serial driver to take advantage
+  of those special I/O ports.
+
+SGI Zilog85C30 serial support
+CONFIG_SGI_SERIAL
+  If you want to use your SGI's built-in serial ports under Linux,
+  answer Y.
+
+SGI graphics support
+CONFIG_SGI_GRAPHICS
+  If you have an SGI machine and you want to compile the graphics
+  drivers, say Y here. This will include the code for the
+  /dev/graphics and /dev/gfx drivers into the kernel for supporting
+  virtualized access to your graphics hardware.
+
+Support the Bell Technologies HUB6 card
+CONFIG_HUB6
+  Say Y here to enable support in the dumb serial driver to support
+  the HUB6 card.
+
+PCI support
+CONFIG_PCI
+  Find out whether you have a PCI motherboard. PCI is the name of a
+  bus system, i.e. the way the CPU talks to the other stuff inside
+  your box. Other bus systems are ISA, EISA, Microchannel (MCA) or
+  VESA. If you have PCI, say Y, otherwise N. 
+
+  The PCI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, contains valuable
+  information about which PCI hardware does work under Linux and which
+  doesn't.
+
+PCI access mode
+CONFIG_PCI_GOBIOS
+  On PCI systems, the BIOS can be used to detect the PCI devices and
+  determine their configuration. However, some old PCI motherboards
+  have BIOS bugs and may crash if this is done. Also, some embedded
+  PCI-based systems don't have any BIOS at all. Linux can also try to
+  detect the PCI hardware directly without using the BIOS.
+
+  With this option, you can specify how Linux should detect the PCI
+  devices. If you choose "BIOS", the BIOS will be used, if you choose
+  "Direct", the BIOS won't be used, and if you choose "Any", the
+  kernel will try the direct access method and falls back to the BIOS
+  if that doesn't work. If unsure, go with the default.
+
+PCI quirks
+CONFIG_PCI_QUIRKS
+  If you have a broken BIOS, it may fail to set up the PCI bus in a
+  correct or optimal fashion. Saying Y here will correct that problem.
+  If your BIOS is fine you can say N here for a very slightly smaller
+  kernel. If unsure, say Y.
+
+PCI bridge optimization (experimental)
+CONFIG_PCI_OPTIMIZE
+  This can improve access times for some hardware devices if you have
+  a really broken BIOS and your computer uses a PCI bus system. Say Y
+  if you think it might help, but try turning it off if you experience
+  any problems with the PCI bus. N is the safe answer.
+
+Backward-compatible /proc/pci
+CONFIG_PCI_OLD_PROC
+  Older kernels supported a /proc/pci file containing brief textual
+  descriptions of all PCI devices in the system. Several programs
+  tried to parse this file, so it became almost impossible to add new
+  fields without breaking compatibility. So a new /proc interface to
+  PCI (/proc/bus/pci) has been implemented and the old one is
+  supported for compatibility reasons only; you'll get the old one (in
+  addition to the new one) if you say Y here and to "/proc filesystem
+  support", below. If unsure, say Y. If you say N, you'll only get the
+  new /proc/bus/pci interface.
+
+MCA support
+CONFIG_MCA
+  MicroChannel Architecture is found in some IBM PS/2 machines and
+  laptops. It is a bus system similar to PCI or ISA. See
+  Documentation/mca.txt (and especially the web page given there)
+  before attempting to build an MCA bus kernel.
+
+SGI Visual Workstation support
+CONFIG_VISWS
+  The SGI Visual Workstation series is an IA32-based workstation
+  based on SGI systems chips with some legacy PC hardware attached.
+  Say Y here to create a kernel to run on the SGI 320 or 540.
+  A kernel compiled for the Visual Workstation will not run on other
+  PC boards and vice versa.
+  See Documentation/sgi-visws.txt for more.
+
+SGI Visual Workstation framebuffer support
+CONFIG_FB_SGIVW
+  SGI Visual Workstation support for framebuffer graphics.
+
+I2O support
+CONFIG_I2O
+  The Intelligent Input/Output (I2O) architecture allows hardware
+  drivers to be split into two parts: an operating system specific
+  module called the OSM and an hardware specific module called the
+  HDM. The OSM can talk to a whole range of HDM's, and ideally the
+  HDM's are not OS dependent. This allows for the same HDM driver to
+  be used under different operating systems if the relevant OSM is in
+  place. In order for this to work, you need to have an I2O interface
+  adapter card in your computer. This card contains a special I/O
+  processor (IOP), thus allowing high speeds since the CPU does not
+  have to deal with I/O.
+
+  If you say Y here, you will get a choice of interface adapter
+  drivers and OSM's with the following questions.
+
+  This support is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. You will get modules called i2o_core.o
+  and i20_config.o. 
+
+  If unsure, say N.
+
+I2O PCI support
+CONFIG_I2O_PCI
+  Say Y for support of PCI bus I2O interface adapters. Currently this
+  is the only variety supported, so you should say Y.
+
+  This support is also available as a module called i2o_pci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O Block OSM
+CONFIG_I2O_BLOCK
+  Include support for the I2O Block OSM. The Block OSM presents disk
+  and other structured block devices to the operating system.
+
+  This support is also available as a module called i2o_block.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O SCSI OSM
+CONFIG_I2O_SCSI
+  Allows direct SCSI access to SCSI devices on a SCSI or FibreChannel
+  I2O controller. You can use both the SCSI and Block OSM together if
+  you wish.
+
+  This support is also available as a module called i2o_scsi.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+System V IPC
+CONFIG_SYSVIPC
+  Inter Process Communication is a suite of library functions and
+  system calls which let processes (running programs) synchronize
+  and exchange information. It is generally considered to be a good
+  thing, and some programs won't run unless you say Y here. In
+  particular, if you want to run the DOS emulator dosemu under Linux
+  (read the DOSEMU-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO), you'll need to say Y
+  here.
+  
+  You can find documentation about IPC with "info ipc" and also in
+  section 6.4 of the Linux Programmer's Guide, available via FTP
+  (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/LDP/programmers-guide.
+
+  Saying Y here enlarges your kernel by about 7 KB. Just say Y.
+
+BSD Process Accounting
+CONFIG_BSD_PROCESS_ACCT
+  If you say Y here, a user level program will be able to instruct the
+  kernel (via a special system call) to write process accounting
+  information to a file: whenever a process exits, information about
+  that process will be appended to the file by the kernel. The
+  information includes things such as creation time, owning user,
+  command name, memory usage, controlling terminal etc. (the complete
+  list is in the struct acct in include/linux/acct.h). It is up to the
+  user level program to do useful things with this information. This
+  is generally a good idea, so say Y.
+  
+Sysctl support
+CONFIG_SYSCTL
+  The sysctl interface provides a means of dynamically changing
+  certain kernel parameters and variables on the fly without requiring
+  a recompile of the kernel or reboot of the system. The primary
+  interface consists of a system call, but if the /proc filesystem is
+  enabled, a tree of modifiable sysctl entries will be generated
+  beneath the /proc/sys directory. They are explained in the files in
+  Documentation/sysctl/. Note that enabling this option will enlarge
+  the kernel by at least 8 KB. 
+
+  As it is generally a good thing, you should say Y here unless
+  building a kernel for install/rescue disks or your system is very
+  limited in memory.
+
+Kernel support for ELF binaries
+CONFIG_BINFMT_ELF
+  ELF (Executable and Linkable Format) is a format for libraries and
+  executables used across different architectures and operating
+  systems. Saying Y here will enable your kernel to run ELF binaries
+  and enlarge it by about 2 KB. ELF support under Linux has now all
+  but replaced the traditional Linux a.out formats (QMAGIC and ZMAGIC)
+  because it is portable (this does *not* mean that you will be able
+  to run executables from different architectures or operating systems
+  however) and makes building run-time libraries very easy. Many new
+  executables are distributed solely in ELF format. You definitely
+  want to say Y here.
+
+  Information about ELF is contained in the ELF HOWTO available via
+  FTP (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you find that after upgrading from Linux kernel 1.2 and saying Y
+  here, you still can't run any ELF binaries (they just crash), then
+  you'll have to install the newest ELF runtime libraries, including
+  ld.so (check the file Documentation/Changes for location and latest
+  version).
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called binfmt_elf.o. Saying M or N here is dangerous because some
+  crucial programs on your system might be in ELF format.
+
+Kernel support for A.OUT binaries
+CONFIG_BINFMT_AOUT
+  A.out (Assembler.OUTput) is a set of formats for libraries and
+  executables used in the earliest versions of UNIX. Linux used the
+  a.out formats QMAGIC and ZMAGIC until they were replaced with the
+  ELF format.
+
+  As more and more programs are converted to ELF, the use for a.out
+  will gradually diminish. If you disable this option it will reduce
+  your kernel by one page. This is not much and by itself does not
+  warrant removing support. However its removal is a good idea if you
+  wish to ensure that absolutely none of your programs will use this
+  older executable format. If you don't know what to answer at this
+  point then answer Y. If someone told you "You need a kernel with
+  QMAGIC support" then you'll have to say Y here. You may answer M to
+  compile a.out support as a module and later load the module when you
+  want to use a program or library in a.out format. The module will be
+  called binfmt_aout.o. Saying M or N here is dangerous though,
+  because some crucial programs on your system might still be in A.OUT
+  format.
+
+Kernel support for JAVA binaries (obsolete)
+CONFIG_BINFMT_JAVA
+  JAVA(tm) is an object oriented programming language developed by
+  SUN; JAVA programs are compiled into "JAVA bytecode" binaries which
+  can then be interpreted by run time systems on many different
+  architectures and operating systems. These JAVA binaries are
+  becoming a universal executable format.
+
+  If you want to execute JAVA binaries, read the Java on Linux HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You will then need to
+  install the run time system contained in the Java Developers Kit
+  (JDK) as described in the HOWTO. This is completely independent of
+  the Linux kernel and you do NOT need to say Y here for this to work.
+
+  Saying Y here allows you to execute a JAVA bytecode binary just like
+  any other Linux program: by simply typing in its name. (You also
+  need to have the JDK installed for this to work). As more and more
+  Java programs become available, the use for this will gradually
+  increase. You can even execute HTML files containing JAVA applets
+  (little embedded JAVA binaries) if those files start with the string
+  "<!--applet-->". If you want to use this, say Y here and read
+  Documentation/java.txt.
+
+  If you disable this option it will reduce your kernel by about 4 KB.
+  This is not much and by itself does not warrant removing support.
+  However its removal is a good idea if you do not have the JDK
+  installed. You may answer M for module support and later load the
+  module when you install the JDK or find an interesting Java program
+  that you can't live without. The module will be called
+  binfmt_java.o.
+
+  The complete functionality of this Java support is also provided by
+  the more general option "Kernel support for MISC binaries",
+  below. This option is therefore considered obsolete and you should
+  say N here and Y to "Kernel support for MISC binaries" if you're 
+  interested in transparently executing Java programs.
+
+Kernel support for Linux/Intel ELF binaries
+CONFIG_BINFMT_EM86
+  Say Y here if you want to be able to execute Linux/Intel ELF
+  binaries just like native Alpha binaries on your Alpha machine. For
+  this to work, you need to have the emulator /usr/bin/em86 in place.
+  You may answer M to compile the emulation support as a module and
+  later load the module when you want to use a Linux/Intel binary. The
+  module will be called binfmt_em86.o. If unsure, say Y.
+
+Kernel support for MISC binaries
+CONFIG_BINFMT_MISC
+  If you say Y here, it will be possible to plug wrapper-driven binary
+  formats into the kernel. You will like this especially when you use
+  programs that need an interpreter to run like Java, Python or
+  Emacs-Lisp. It's also useful if you often run DOS executables under
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO). Once you have
+  registered such a binary class with the kernel, you can start one of
+  those programs simply by typing in its name at a shell prompt; Linux
+  will automatically feed it to the correct interpreter.
+
+  If you say Y here, you won't need "Kernel support for JAVA binaries"
+  (CONFIG_BINFMT_JAVA) or "Kernel support for Linux/Intel ELF
+  binaries" (CONFIG_BINFMT_EM86), as this is a more general solution.
+
+  You can do other nice things, too. Read
+  Documentation/binfmt_misc.txt to learn how to use this feature, and
+  Documentation/java.txt for information about how to include Java
+  support.
+
+  You must say Y to "proc filesystem support" (CONFIG_PROC_FS) to
+  use this part of the kernel.
+
+  You may say M here for module support and later load the module when
+  you have use for it; the module is called binfmt_misc.o. If you
+  don't know what to answer at this point, say Y.
+
+Solaris binary emulation
+CONFIG_SOLARIS_EMUL
+  This is experimental code which will enable you to run (many)
+  Solaris binaries on your SPARC Linux machine. 
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called solaris.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Processor family
+CONFIG_M386
+  This is the processor type of your CPU. This information is used for
+  optimizing purposes. In order to compile a kernel that can run on
+  all x86 CPU types (albeit not optimally fast), you can specify
+  "386" here.
+
+  If you specify one of "486" or "586" or "Pentium" or "PPro", then
+  the kernel will not necessarily run on earlier architectures (e.g. a
+  Pentium optimized kernel will run on a PPro, but not necessarily on
+  a i486).
+
+  Here are the settings recommended for greatest speed:
+   - "386" for the AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI
+     486DLC/DLC2 and UMC 486SX-S. Only "386" kernels will run on a 386
+     class machine.
+   - "486" for the AMD/Cyrix/IBM/Intel DX4 or 486DX/DX2/SL/SX/SX2,
+     AMD/Cyrix 5x86, NexGen Nx586 and UMC U5D or U5S.
+   - "586" for generic Pentium CPUs, possibly lacking the TSC 
+     (time stamp counter) register.
+   - "Pentium" for the Intel Pentium/Pentium MMX, AMD K5, K6 and 
+     K6-3D.
+   - "PPro" for the Cyrix/IBM/National Semiconductor 6x86MX, MII and
+     Intel Pentium II/Pentium Pro.
+
+  If you don't know what to do, choose "386".
+
+VGA text console
+CONFIG_VGA_CONSOLE
+  Saying Y here will allow you to use Linux in text mode through a
+  display that complies with the generic VGA standard. Virtually
+  everyone wants that. 
+
+  The program SVGATextMode can be used to utilize SVGA video cards to
+  their full potential in text mode. Download it via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/utils/console.
+
+  Say Y.
+
+Video mode selection support
+CONFIG_VIDEO_SELECT
+  This enables support for text mode selection on kernel startup. If
+  you want to take advantage of some high-resolution text mode your
+  card's BIOS offers, but the traditional Linux utilities like
+  SVGATextMode don't, you can say Y here and set the mode using the
+  "vga=" option from your boot loader (lilo or loadlin) or set
+  "vga=ask" which brings up a video mode menu on kernel startup. Try
+  "man bootparam" or see the documentation of your boot loader about
+  how to pass options to the kernel. The lilo procedure is also
+  explained in the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Read
+  Documentation/svga.txt for more information about the Video mode
+  selection support. If unsure, say N.
+
+Support for frame buffer devices (EXPERIMENTAL)
+CONFIG_FB
+  The frame buffer device provides an abstraction for the graphics
+  hardware. It represents the frame buffer of some video hardware and
+  allows application software to access the graphics hardware through
+  a well-defined interface, so the software doesn't need to know
+  anything about the low-level (hardware register) stuff. 
+
+  Frame buffer devices work identically across the different
+  architectures supported by Linux and make the implementation of
+  application programs easier and more portable; at this point, an X
+  server exists which uses the frame buffer device exclusively.
+  On several non-X86 architectures, the frame buffer device is the
+  only way to use the graphics hardware.
+ 
+  The device is accessed through special device nodes, usually located
+  in the /dev directory, i.e. /dev/fb*.
+
+  You need an utility program called fbset to make full use of frame
+  buffer devices. Please read Documentation/fb/framebuffer.txt and the
+  Framebuffer-HOWTO at
+  http://www.tahallah.demon.co.uk/programming/prog.html for more
+  information.
+
+  Say Y here and to the driver for your graphics board below if you
+  are compiling a kernel for a non-x86 architecture.
+
+  If you are compiling for the x86 architecture, you can say Y if you
+  want to play with it, but it is not essential. Please note that
+  running graphical applications that directly touch the hardware
+  (e.g. an accelerated X server) and that are not frame buffer
+  device-aware may cause unexpected results. If unsure, say N.
+
+Acorn VIDC support
+CONFIG_FB_ACORN
+  This is the frame buffer device driver for the Acorn VIDC graphics
+  chipset.
+
+Apollo frame buffer device
+CONFIG_FB_APOLLO
+  This is the frame buffer device driver for the monochrome graphics
+  hardware found in some Apollo workstations.
+
+Amiga native chipset support
+CONFIG_FB_AMIGA
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Amigas.
+
+Amiga OCS chipset support
+CONFIG_FB_AMIGA_OCS
+  This enables support for the original Agnus and Denise video chips,
+  found in the Amiga 1000 and most A500's and A2000's. If you intend
+  to run Linux on any of these systems, say Y; otherwise say N.
+
+Amiga ECS chipset support
+CONFIG_FB_AMIGA_ECS
+  This enables support for the Enhanced Chip Set, found in later
+  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
+  you intend to run Linux on any of these systems, say Y; otherwise
+  say N.
+
+Amiga AGA chipset support
+CONFIG_FB_AMIGA_AGA
+  This enables support for the Advanced Graphics Architecture (also
+  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
+  and CD32. If you intend to run Linux on any of these systems, say Y;
+  otherwise say N.
+
+Amiga CyberVision support
+CONFIG_FB_CYBER
+  This enables support for the Cybervision 64 graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64 or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the
+  Cybervision 64 3D card, as they use incompatible video chips.
+
+Amiga CyberVision3D support (EXPERIMENTAL)
+CONFIG_FB_VIRGE
+  This enables support for the Cybervision 64/3D graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64/3D or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the older
+  Cybervision 64 card, as they use incompatible video chips.
+
+Amiga RetinaZ3 support (EXPERIMENTAL)
+CONFIG_FB_RETINAZ3
+  This enables support for the Retina Z3 graphics card. Say N unless
+  you have a Retina Z3 or plan to get one before you next recompile
+  the kernel.
+
+Amiga CLgen driver (EXPERIMENTAL)
+CONFIG_FB_CLGEN
+  This enables support for Cirrus Logic GD542x/543x based boards on
+  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.
+  Say N unless you have such a graphics board or plan to get one
+  before you next recompile the kernel.
+
+Apollo support
+CONFIG_APOLLO
+  Say Y here if you want to run Linux on an MC680x0-based Apollo
+  Domain workstation such as the DN3500.
+
+Apollo 3c505 support
+CONFIG_APOLLO_ELPLUS
+  Say Y or M here if your Apollo has a 3Com 3c505 ISA Ethernet card.
+  If you don't have one made for Apollos, you can use one from a PC,
+  except that your Apollo won't be able to boot from it (because the
+  code in the ROM will be for a PC).
+
+Atari native chipset support
+CONFIG_FB_ATARI
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Ataris.
+
+Open Firmware frame buffer device support 
+CONFIG_FB_OF
+  Say Y if you want support with Open Firmware for your graphics
+  board.
+
+S3 Trio frame buffer device support 
+CONFIG_FB_S3TRIO
+  If you have a S3 Trio say Y. Say N for S3 Virge. 
+
+ATI Mach64 display support
+CONFIG_FB_ATY
+  This driver supports graphics boards with the ATI Mach64 chips.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called atyfb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+ATI Rage128 display support (EXPERIMENTAL)
+CONFIG_FB_ATY128
+  This driver supports graphics boards with the ATI Rage128 chips.
+  Say Y if you have such a graphics board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called aty128fb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PowerMac "control" frame buffer device support
+CONFIG_FB_CONTROL
+  This driver supports a frame buffer for the graphics adapter in the
+  Power Macintosh 7300 and others.
+
+PowerMac "platinum" frame buffer device support
+CONFIG_FB_PLATINUM
+  This driver supports a frame buffer for the "platinum" graphics
+  adapter in some Power Macintoshes.
+
+PowerMac "valkyrie" frame buffer device support
+CONFIG_FB_VALKYRIE
+  This driver supports a frame buffer for the "valkyrie" graphics
+  adapter found in some Power Macintoshes, as well as the 580 and 630
+  series 68k Macintoshes.
+
+Chips 65550 display support
+CONFIG_FB_CT65550
+  This is the frame buffer device driver for the Chips & Technologies
+  65550 graphics chip in PowerBooks.
+
+Mac frame buffer device
+CONFIG_FB_MAC
+  This is the a generic frame buffer device driver for the graphics
+  hardware in m68k Macintoshes.  It can only use the video mode set
+  by MacOS at boot time.  You should probably say Y here.
+
+HP300 frame buffer device
+CONFIG_FB_HP300
+  This is the frame buffer device driver for the Topcat graphics
+  hardware found in HP300 workstations.
+
+TGA frame buffer support
+CONFIG_FB_TGA
+  This is the frame buffer device driver for generic TGA graphic
+  cards. Say Y if you have one of those.
+
+VESA VGA graphics console
+CONFIG_FB_VESA
+  This is the frame buffer device driver for generic VESA 2.0
+  compliant graphic cards. The older VESA 1.2 cards are not supported.
+  You will get a boot time penguin logo at no additional cost. Please
+  read Documentation/fb/vesafb.txt. If unsure, say Y.
+
+VGA 16-color graphics console
+CONFIG_FB_VGA16
+  This is the frame buffer device driver for VGA 16 color graphic
+  cards. Say Y if you have such a card.
+
+Backward compatibility mode for Xpmac
+CONFIG_FB_COMPAT_XPMAC
+  If you use the Xpmac X server (common with mklinux), you'll need to
+  say Y here to use X. You should consider changing to XFree86 which
+  includes a server that supports the frame buffer device directly
+  (XF68_FBDev).
+
+Matrox unified accelerated driver
+CONFIG_FB_MATROX
+  Say Y here if you have Matrox Millennium, Matrox Millennium II,
+  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
+  Mystique G200, Matrox Millennium G200 or Matrox Marvel G200 video
+  card in your box. At this time, support for the G100, Mystique G200
+  and Marvel G200 is untested.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called matroxfb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  You can pass several parameters to the driver at boot time or at
+  module load time. The parameters look like "video=matrox:XXX", where
+  the meaning of XXX can be found at the end of the main source file
+  (drivers/video/matroxfb.c). Please see the file
+  Documentation/fb/matroxfb.txt. 
+
+Matrox Millennium support
+CONFIG_FB_MATROX_MILLENIUM
+  Say Y here if you have a Matrox Millennium or Matrox Millennium II
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
+  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
+  also use font widths different from 8.
+
+Matrox Mystique support
+CONFIG_FB_MATROX_MYSTIQUE
+  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
+  packed pixel and 32 bpp packed pixel. You can also use font widths
+  different from 8.
+
+Matrox G100/G200 support
+CONFIG_FB_MATROX_G100
+  Say Y here if you have a Matrox Productiva G100, Matrox Mystique
+  G200, Matrox Marvel G200 or Matrox Millennium G200 video card. If
+  you select "Advanced lowlevel driver options", you should check 8
+  bpp packed pixel, 16 bpp packed pixel, 24 bpp packed pixel and 32
+  bpp packed pixel. You can also use font widths different from 8.
+
+Matrox unified driver multihead support
+CONFIG_FB_MATROX_MULTIHEAD
+  Say Y here if you have more than one (supported) Matrox device in
+  your computer and you want to use all of them. If you have only one
+  device, you should say N because the driver compiled with Y is
+  larger and a bit slower, especially on ia32 (ix86). 
+
+  If you said M to "Matrox unified accelerated driver" and N here, you
+  will still be able to use several Matrox devices simultaneously.
+  This is slightly faster but uses 40 KB of kernel memory per Matrox
+  card. You do this by inserting several instances of the module 
+  matroxfb.o into the kernel with insmod, supplying the parameter
+  "dev=N" where N is 0, 1, etc. for the different Matrox devices.
+
+MDA text console (dual-headed)
+CONFIG_MDA_CONSOLE
+  Say Y here if you have an old MDA or monochrome Hercules graphics
+  adapter in your system acting as a second head ( = video card). You
+  will then be able to use two monitors with your Linux system. Do not
+  say Y here if your MDA card is the primary card in your system; the
+  normal VGA driver will handle it.
+  
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called mdacon.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+SBUS and UPA frame buffers
+CONFIG_FB_SBUS
+  Say Y if you want support for SBUS or UPA based frame buffer device.
+
+Creator/Creator3D support
+CONFIG_FB_CREATOR
+  This is the frame buffer device driver for the Creator and Creator3D
+  graphics boards.
+
+CGsix (GX,TurboGX) support
+CONFIG_FB_CGSIX
+  This is the frame buffer device driver for the CGsix (GX, TurboGX)
+  frame buffer.
+
+BWtwo support
+CONFIG_FB_BWTWO
+  This is the frame buffer device driver for the BWtwo frame buffer.
+
+CGthree support
+CONFIG_FB_CGTHREE
+  This is the frame buffer device driver for the CGthree frame buffer.
+
+TCX (SS4/SS5 only) support
+CONFIG_FB_TCX
+  This is the frame buffer device driver for the TCX 24/8bit frame
+  buffer.
+
+Virtual Frame Buffer support (ONLY FOR TESTING!)
+CONFIG_FB_VIRTUAL
+  This is a `virtual' frame buffer device. It operates on a chunk of
+  unswapable kernel memory instead of on the memory of a graphics
+  board. This means you cannot see any output sent to this frame
+  buffer device, while it does consume precious memory. The main use
+  of this frame buffer device is testing and debugging the frame
+  buffer subsystem. Do NOT enable it for normal systems! To protect
+  the innocent, it has to be enabled explicitly at boot time using the
+  kernel option `video=vfb:'.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called vfb.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+ 
+  If unsure, say N.
+
+Advanced low level driver options
+CONFIG_FBCON_ADVANCED
+  The frame buffer console uses character drawing routines that are
+  tailored to the specific organization of pixels in the memory of
+  your graphics hardware. These are called the low level frame buffer
+  console drivers. Note that they are used for text console output
+  only; they are NOT needed for graphical applications.
+
+  If you say N here, the needed low level drivers are automatically
+  enabled, depending on what frame buffer devices you selected above.
+  This is recommended for most users.
+
+  If you say Y here, you have more fine-grained control over which low
+  level drivers are enabled. You can e.g. leave out low level drivers
+  for color depths you do not intend to use for text consoles.
+
+  Low level frame buffer console drivers can be modules ( = code which
+  can be inserted and removed from the running kernel whenever you
+  want). The modules will be called fbcon-*.o. If you want to compile
+  (some of) them as modules, read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+Monochrome support
+CONFIG_FBCON_MFB
+  This is the low level frame buffer console driver for monochrome
+  (2 colors) packed pixels.
+
+2 bpp packed pixels support
+CONFIG_FBCON_CFB2
+  This is the low level frame buffer console driver for 2 bits per
+  pixel (4 colors) packed pixels.
+
+4 bpp packed pixels support
+CONFIG_FBCON_CFB4
+  This is the low level frame buffer console driver for 4 bits per
+  pixel (16 colors) packed pixels.
+
+8 bpp packed pixels support
+CONFIG_FBCON_CFB8
+  This is the low level frame buffer console driver for 8 bits per
+  pixel (256 colors) packed pixels.
+
+16 bpp packed pixels support
+CONFIG_FBCON_CFB16
+  This is the low level frame buffer console driver for 15 or 16 bits
+  per pixel (32K or 64K colors, also known as `hicolor') packed
+  pixels.
+
+24 bpp packed pixels support
+CONFIG_FBCON_CFB24
+  This is the low level frame buffer console driver for 24 bits per
+  pixel (16M colors, also known as `truecolor') packed pixels. It is
+  NOT for `sparse' 32 bits per pixel mode.
+
+32 bpp packed pixels support
+CONFIG_FBCON_CFB32
+  This is the low level frame buffer console driver for 32 bits per
+  pixel (16M colors, also known as `truecolor') sparse packed pixels.
+
+Amiga bitplanes support
+CONFIG_FBCON_AFB
+  This is the low level frame buffer console driver for 1 to 8
+  bitplanes (2 to 256 colors) on Amiga.
+
+Amiga interleaved bitplanes support
+CONFIG_FBCON_ILBM
+  This is the low level frame buffer console driver for 1 to 8
+  interleaved bitplanes (2 to 256 colors) on Amiga.
+
+Atari interleaved bitplanes (2 planes) support
+CONFIG_FBCON_IPLAN2P2
+  This is the low level frame buffer console driver for 2 interleaved
+  bitplanes (4 colors) on Atari.
+
+Atari interleaved bitplanes (4 planes) support
+CONFIG_FBCON_IPLAN2P4
+  This is the low level frame buffer console driver for 4 interleaved
+  bitplanes (16 colors) on Atari.
+
+Atari interleaved bitplanes (8 planes) support
+CONFIG_FBCON_IPLAN2P8
+  This is the low level frame buffer console driver for 8 interleaved
+  bitplanes (256 colors) on Atari.
+
+Mac variable bpp packed pixels support
+CONFIG_FBCON_MAC
+  This is the low level frame buffer console driver for 1/2/4/8/16/32
+  bits per pixel packed pixels on Mac. It supports variable font
+  widths for low resolution screens.
+  
+VGA characters/attributes support
+CONFIG_FBCON_VGA
+  This is the low level frame buffer console driver for VGA text mode;
+  it is used if you said Y to "VGA chipset support (text only)" above.
+
+Parallel-port support
+CONFIG_PARPORT
+  If you want to use devices connected to your machine's parallel port
+  (the connector at the computer with 25 holes), e.g. printer, ZIP
+  drive, PLIP link (Parallel Line Internet Protocol is mainly used to
+  create a mini network by connecting the parallel ports of two local
+  machines) etc., then you need to say Y here; please read
+  Documentation/parport.txt and drivers/misc/BUGS-parport.
+
+  For extensive information about drivers for many devices attaching
+  to the parallel port see http://www.torque.net/linux-pp.html on the
+  WWW (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape).
+
+  It is possible to share a single parallel port among several devices
+  and it is safe to compile all the corresponding drivers into the
+  kernel. If you want to compile parallel port support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called parport.o. If you have more than one
+  parallel port and want to specify which port and IRQ to be used by
+  this driver at module load time, read
+  Documentation/networking/net-modules.txt.
+
+  If unsure, say Y.
+
+PC-style hardware 
+CONFIG_PARPORT_PC
+  You should say Y here if you have a PC-style parallel port. All IBM
+  PC compatible computers and some Alphas have PC-style parallel
+  ports. 
+
+  This code is also available as a module. If you want to compile it
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called parport_pc.o.
+  
+  If unsure, say Y.
+
+Support foreign hardware
+CONFIG_PARPORT_OTHER
+  Say Y here if you want to be able to load driver modules to support
+  other non-standard types of parallel ports. This causes a
+  performance loss, so most people say N.
+
+Sun Ultra/AX-style hardware 
+CONFIG_PARPORT_AX
+  Say Y here if you need support for the parallel port hardware on Sun
+  Ultra/AX machines. This code is also available as a module (say M),
+  called parport_ax.o. If in doubt, saying N is the safe plan.
+
+Plug and Play support
+CONFIG_PNP
+  Plug and Play support allows the kernel to automatically configure
+  some peripheral devices. Say Y to enable PnP.
+
+Auto-probe for parallel devices
+CONFIG_PNP_PARPORT
+  Some IEEE-1284 conforming parallel-port devices can identify
+  themselves when requested. Say Y to enable this feature, or M to
+  compile it as a module (parport_probe.o). If in doubt, say N.
+
+Enable loadable module support
+CONFIG_MODULES
+  Kernel modules are small pieces of compiled code which can be
+  inserted in or removed from the running kernel, using the programs
+  insmod and rmmod. This is described in the file
+  Documentation/modules.txt, including the fact that you have to say
+  "make modules" in order to compile the modules that you chose during
+  kernel configuration. Modules can be device drivers, file systems,
+  binary executable formats, and so on. If you think that you may want
+  to make use of modules with this kernel in the future, then say Y
+  here. If unsure, say Y.
+
+Set version information on all symbols for modules
+CONFIG_MODVERSIONS
+  Usually, modules have to be recompiled whenever you switch to a new
+  kernel. Saying Y here makes it possible, and safe, to use the
+  same modules even after compiling a new kernel; this requires the
+  program modprobe. All the software needed for module support is in
+  the modutils package (check the file Documentation/Changes for
+  location and latest version). NOTE: if you say Y here but don't
+  have the program genksyms (which is also contained in the above
+  mentioned modutils package), then the building of your kernel will
+  fail. If you are going to use modules that are generated from
+  non-kernel sources, you would benefit from this option. Otherwise
+  it's not that important. So, N ought to be a safe bet.
+
+Kernel module loader support
+CONFIG_KMOD
+  Normally when you have selected some drivers and/or filesystems to
+  be created as loadable modules, you also have the responsibility to
+  load the corresponding modules (using the programs insmod or
+  modprobe) before you can use them. If you say Y here however, the
+  kernel will be able to load modules for itself: when a part of the
+  kernel needs a module, it runs modprobe with the appropriate
+  arguments, thereby loading the module if it is available. (This is a
+  replacement for kerneld.) Say Y here and read about configuring it
+  in Documentation/kmod.txt.
+
+ARP daemon support (EXPERIMENTAL)
+CONFIG_ARPD
+  Normally, the kernel maintains an internal cache which maps IP 
+  addresses to hardware addresses on the local network, so that
+  Ethernet/Token Ring/ etc. frames are sent to the proper address on
+  the physical networking layer. For small networks having a few
+  hundred directly connected hosts or less, keeping this address
+  resolution (ARP) cache inside the kernel works well. However,
+  maintaining an internal ARP cache does not work well for very large
+  switched networks, and will use a lot of kernel memory if TCP/IP
+  connections are made to many machines on the network. 
+
+  If you say Y here, the kernel's internal ARP cache will never grow
+  to more than 256 entries (the oldest entries are expired in a LIFO
+  manner) and communication will be attempted with the user space ARP
+  daemon arpd. Arpd then answers the address resolution request either
+  from its own cache or by asking the net.
+
+  This code is experimental. If you do say Y here, you should obtain a
+  copy of arpd from http://www.loran.com/~layes/arpd/index.html, and
+  you should also say Y to "Kernel/User network link driver", below.
+  If unsure, say N.
+
+TCP/IP networking
+CONFIG_INET
+  These are the protocols used on the Internet and on most local
+  Ethernets. It is highly recommended to say Y here (this will enlarge
+  your kernel by about 35 KB), since some programs (e.g. the X window
+  system) use TCP/IP even if your machine is not connected to any
+  other computer. You will get the so-called loopback device which
+  allows you to ping yourself (great fun, that!).
+
+  For an excellent introduction to Linux networking, please read the
+  NET-3-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This option is also necessary if you want to use the full power of
+  term (term is a program which gives you almost full Internet
+  connectivity if you have a regular dial up shell account on some
+  Internet connected Unix computer; for more information, read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html).
+  
+  If you say Y here and also to "/proc filesystem support" and "Sysctl
+  support" below, you can change various aspects of the behavior of
+  the TCP/IP code by writing to the (virtual) files in
+  /proc/sys/net/ipv4/*; the options are explained in the file
+  Documentation/Networking/ip-sysctl.txt.
+
+  Short answer: say Y.
+
+IP: multicasting
+CONFIG_IP_MULTICAST
+  This is code for addressing several networked computers at once,
+  enlarging your kernel by about 2 kB. You need multicasting if you
+  intend to participate in the MBONE, a high bandwidth network on top
+  of the Internet which carries audio and video broadcasts. More
+  information about the MBONE is on the WWW at
+  http://www.best.com/~prince/techinfo/mbone.html (to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape). Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. For most people, it's safe
+  to say N.
+
+IP: advanced router
+CONFIG_IP_ADVANCED_ROUTER
+  If you intend to run your Linux box mostly as a router, i.e. as a
+  computer that forwards and redistributes network packets, say Y; you
+  will then be presented with several options that allow more precise
+  control about the routing process.
+
+  The answer to this question won't directly affect the kernel:
+  answering N will just cause this configure script to skip all the
+  questions about advanced routing.
+
+  Note that your box can only act as a router if you enable IP
+  forwarding in your kernel; you can do that by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and executing the
+  line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. 
+
+  If you turn on IP forwarding, you will also get the rp_filter, which
+  automatically rejects incoming packets if the routing table entry
+  for their source address doesn't match the network interface they're
+  arriving on. This has security advantages because it prevents the
+  so-called IP spoofing, however it can pose problems if you use
+  asymmetric routing (packets from you to a host take a different path
+  than packets from that host to you) or if you operate a non-routing
+  host which has several IP addresses on different interfaces. To turn
+  rp_filter off use:
+
+        echo 0 > /proc/sys/net/ipv4/conf/<device>/rp_filter
+  or
+        echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
+
+  If unsure, say N here.
+
+IP: policy routing
+CONFIG_IP_MULTIPLE_TABLES
+  Normally, a router decides what to do with a received packet based
+  solely on the packet's final destination address. If you say Y here,
+  the Linux router will also be able to take the packet's source
+  address into account. Furthermore, if you also say Y to "IP: use TOS
+  value as routing key" below, the TOS (Type-Of-Service) field of the
+  packet can be used for routing decisions as well. In addition, if
+  you say Y here and to "IP: fast network address translation" below,
+  the router will also be able to modify source and destination
+  addresses of forwarded packets.
+
+  If you are interested in this, please see the preliminary
+  documentation at http://www.compendium.com.ar/policy-routing.txt and
+  ftp://post.tepkom.ru/pub/vol2/Linux/docs/advanced-routing.tex. You
+  will need supporting software from ftp://ftp.inr.ac.ru/ip-routing/
+  
+  If unsure, say N.
+  
+IP: equal cost multipath
+CONFIG_IP_ROUTE_MULTIPATH
+  Normally, the routing tables specify a single action to be taken in
+  a deterministic manner for a given packet. If you say Y here
+  however, it becomes possible to attach several actions to a packet
+  pattern, in effect specifying several alternative paths to travel
+  for those packets. The router considers all these paths to be of
+  equal "cost" and chooses one of them in a non-deterministic fashion
+  if a matching packet arrives.
+
+IP: use TOS value as routing key
+CONFIG_IP_ROUTE_TOS
+  The header of every IP packet carries a TOS (Type of Service) value
+  with which the packet requests a certain treatment, e.g. low latency
+  (for interactive traffic), high throughput, or high reliability. If
+  you say Y here, you will be able to specify different routes for
+  packets with different TOS values.
+
+IP: use FWMARK value as routing key
+CONFIG_IP_ROUTE_FWMARK
+  If you say Y here, you will be able to specify different routes for
+  packets with different FWMARK ("firewalling mark") values
+  (see ipchains(8), "-m" argument).
+
+IP: verbose route monitoring
+CONFIG_IP_ROUTE_VERBOSE
+  If you say Y here, which is recommended, then the kernel will print
+  verbose messages regarding the routing, for example warnings about
+  received packets which look strange and could be evidence of an
+  attack or a misconfigured system somewhere. The information is
+  handled by the klogd daemon which is responsible for kernel messages
+  ("man klogd").
+
+IP: large routing tables
+CONFIG_IP_ROUTE_LARGE_TABLES
+  If you have routing zones that grow to more than about 64 entries,
+  you may want to say Y here to speed up the routing process.
+
+IP: fast network address translation
+CONFIG_IP_ROUTE_NAT
+  If you say Y here, your router will be able to modify source and
+  destination addresses of packets that pass through it, in a manner
+  you specify. General information about Network Address Translation
+  can be gotten from the document
+  http://www.csn.tu-chemnitz.de/~mha/linux-ip-nat/diplom/nat.html
+
+IP: optimize as router not host
+CONFIG_IP_ROUTER
+  Some Linux network drivers use a technique called copy and checksum
+  to optimize host performance. For a machine which acts as a router
+  most of the time and is forwarding most packets to another host this
+  is however a loss. If you say Y here, copy and checksum will be
+  switched off. In the future, it may make other changes which
+  optimize for router operation.
+
+  Note that your box can only act as a router if you enable IP
+  forwarding in your kernel; you can do that by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and executing the
+  line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. You can do
+  that even if you say N here.
+
+  If unsure, say N here.
+
+IP: firewalling
+CONFIG_IP_FIREWALL
+  If you want to configure your Linux box as a packet filter firewall
+  for a local TCP/IP based network, say Y here. You may want to read
+  the FIREWALL-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Also, you will need the ipchains tool (available on the WWW at
+  http://netfilter.kernelnotes.org/ipchains/) to allow selective blocking
+  of Internet traffic based on type, origin and destination. 
+  Note that the Linux firewall code has changed and the old program
+  called ipfwadm won't work anymore. Please read the IPCHAINS-HOWTO.
+
+  The type of firewall provided by ipchains and this kernel support is
+  called a "packet filter". The other type of firewall, a
+  "proxy-based" one, is more secure but more intrusive and more
+  bothersome to set up; it inspects the network traffic much more
+  closely, modifies it and has knowledge about the higher level
+  protocols, which a packet filter lacks. Moreover, proxy-based
+  firewalls often require changes to the programs running on the local
+  clients. Proxy-based firewalls don't need support by the kernel, but
+  they are often combined with a packet filter, which only works if
+  you say Y here.
+
+  The firewalling code will only work if IP forwarding is enabled in
+  your kernel. You can do that by saying Y to "/proc filesystem
+  support" and "Sysctl support" below and executing the line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. 
+
+  You need to say Y to "IP firewalling" in order to be able to use IP
+  masquerading (masquerading means that local computers can chat with
+  an outside host, but that outside host is made to think that it is
+  talking to the firewall box -- makes the local network completely
+  invisible to the outside world and avoids the need to allocate
+  globally valid IP host addresses for the machines on the local net)
+  and IP packet logging and accounting (keeping track of what is using
+  all your network bandwidth) and IP transparent proxying (makes the
+  computers on the local network think they're talking to a remote
+  computer, while in reality the traffic is redirected by your Linux
+  firewall to a local proxy server).
+
+  If in doubt, say N here.
+
+IP: firewall packet netlink device
+CONFIG_IP_FIREWALL_NETLINK
+  If you say Y here, you can use the ipchains tool to copy all or part
+  of any packet you specify that hits your Linux firewall to optional
+  user space monitoring software that can then look for attacks and
+  take actions such as paging the administrator of the site.
+
+  To use this, you need to create a character special file under /dev
+  with major number 36 and minor number 3 using mknod ("man mknod"),
+  and you need (to write) a program that reads from that device and
+  takes appropriate action.
+
+IP: kernel level autoconfiguration
+CONFIG_IP_PNP
+  This enables automatic configuration of IP addresses of devices and
+  of the routing table during kernel boot, based on either information
+  supplied at the kernel command line or by BOOTP or RARP protocols.
+  You need to say Y only for diskless machines requiring network
+  access to boot (in which case you want to say Y to "Root file system
+  on NFS" as well), because all other machines configure the network
+  in their startup scripts.
+
+BOOTP support
+CONFIG_IP_PNP_BOOTP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the BOOTP protocol (a
+  special protocol designed for doing this job), say Y here. In case
+  the boot ROM of your network card was designed for booting Linux and
+  does BOOTP itself, providing all necessary information on the kernel
+  command line, you can say N here.
+
+  If unsure, say Y. Note that if you want to use BOOTP, a BOOTP server
+  must be operating on your network.  Read Documentation/nfsroot.txt
+  for details.
+
+DHCP support
+CONFIG_IP_PNP_DHCP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the DHCP protocol (a
+  special protocol designed for doing this job), say Y here. In case
+  the boot ROM of your network card was designed for booting Linux and
+  does DHCP itself, providing all necessary information on the kernel
+  command line, you can say N here.
+
+  If unsure, say Y. Note that if you want to use DHCP, a DHCP server
+  must be operating on your network.  Read Documentation/nfsroot.txt
+  for details.
+
+RARP support
+CONFIG_IP_PNP_RARP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the RARP protocol (an
+  older protocol which is being obsoleted by BOOTP and DHCP), say Y
+  here. Note that if you want to use RARP, a RARP server must be
+  operating on your network. Read Documentation/nfsroot.txt for
+  details.
+
+IP: tunneling
+CONFIG_NET_IPIP
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  encapsulation of IP within IP, which sounds kind of pointless, but
+  can be useful if you want to make your (or some other) machine
+  appear on a different network than it physically is, or to use
+  mobile-IP facilities (allowing laptops to seamlessly move between
+  networks without changing their IP addresses; check out
+  http://anchor.cs.binghamton.edu/~mobileip/LJ/index.html). 
+
+  Saying Y to this option will produce two modules ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). Most people won't need this and can say N.
+
+IP: GRE tunnels over IP
+CONFIG_NET_IPGRE
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  GRE (Generic Routing Encapsulation) and at this time allows
+  encapsulating of IPv4 or IPv6 over existing IPv4 infrastructure.
+  This driver is useful if the other endpoint is a Cisco router: Cisco
+  likes GRE much better than the other Linux tunneling driver ("IP:
+  tunneling" above). In addition, GRE allows multicast redistribution
+  through the tunnel.
+
+IP: broadcast GRE over IP
+CONFIG_NET_IPGRE_BROADCAST
+  One application of GRE/IP is to construct a broadcast WAN (Wide Area
+  Network), which looks like a normal Ethernet LAN (Local Area
+  Network), but can be distributed all over the Internet. If you want
+  to do that, say Y here and to "IP: multicast routing" below.
+
+IP: transparent proxying
+CONFIG_IP_TRANSPARENT_PROXY
+  This enables your Linux firewall to transparently redirect any
+  network traffic originating from the local network and destined
+  for a remote host to a local server, called a "transparent proxy
+  server". This makes the local computers think they are talking to
+  the remote end, while in fact they are connected to the local
+  proxy. Redirection is activated by defining special input firewall
+  rules (using the ipchains utility) and/or by doing an appropriate
+  bind() system call.
+
+IP: masquerading
+CONFIG_IP_MASQUERADE
+  If one of the computers on your local network for which your Linux
+  box acts as a firewall wants to send something to the outside, your
+  box can "masquerade" as that computer, i.e. it forwards the traffic
+  to the intended outside destination, but makes it look like it came
+  from the firewall box itself. It works both ways: if the outside
+  host replies, the Linux firewall will silently forward the traffic
+  to the corresponding local computer. This way, the computers on your
+  local net are completely invisible to the outside world, even though
+  they can reach the outside and can receive replies. This makes it
+  possible to have the computers on the local network participate on
+  the Internet even if they don't have officially registered IP
+  addresses. (This last problem can also be solved by connecting the
+  Linux box to the Internet using SLiRP [SLiRP is a SLIP/PPP emulator
+  that works if you have a regular dial up shell account on some UNIX
+  computer; get it via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ].) 
+
+  The IP masquerading code will only work if IP forwarding is enabled
+  in your kernel; you can do this by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and then executing a
+  line like
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  from a boot time script after the /proc filesystem has been mounted.
+
+  Enabling masquerading automagically enables ip_always_defrag too.
+
+  Details on how to set things up are contained in the IP Masquerade
+  mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini; there's also some
+  information on the WWW at
+  http://www.tor.shaw.wave.ca/~ambrose/kernel21.html. 
+
+  If you say Y here, then the modules ip_masq_ftp.o (for ftp file
+  transfers), ip_masq_irc.o (for irc chats), ip_masq_quake.o (you
+  guessed it), ip_masq_vdolive.o (for VDOLive video connections),
+  ip_masq_cuseeme.o (for CU-SeeMe broadcasts) and ip_masq_raudio.o
+  (for RealAudio downloads) will automatically be compiled. They are
+  needed to make masquerading for these protocols work. Modules are
+  pieces of code which can be inserted in and removed from the running
+  kernel whenever you want; read Documentation/modules.txt for
+  details.
+
+IP: UDP masquerading loose checking
+CONFIG_IP_MASQUERADE_UDP_LOOSE
+  Whether UDP masquerading does address checking in a loose fashion.
+
+  If you say Y here, then UDP masqueraded connections will allow
+  any external system to be connect back through the firewall to the
+  port on the internal machine.  However it will allow the more
+  efficient use of masqueraded ports, and may be required for some
+  gaming uses.
+
+  You should only say Y here if you understand the consequences since
+  it will open your internal network to external probing and potential
+  attacks.  In all other cases choose N
+
+IP: ICMP masquerading
+CONFIG_IP_MASQUERADE_ICMP
+  The basic masquerade code described for "IP: masquerading" above
+  only handles TCP or UDP packets (and ICMP errors for existing
+  connections). This option adds additional support for masquerading
+  ICMP packets, such as ping or the probes used by the Windows 95
+  tracert program.
+
+  If you want this, say Y. 
+
+IP: masquerading special modules support
+CONFIG_IP_MASQUERADE_MOD
+  This provides support for special modules that can modify the
+  rewriting rules used when masquerading. Please note that this
+  feature adds a little overhead in the input packet processing chain.
+
+  Examples of such modules are ipautofw (allowing the masquerading of
+  protocols which don't have their own protocol helpers) and port
+  forwarding (making an incoming port of a local computer visible
+  through the masquerading host).
+
+  You will need the user space program "ipmasqadm" to use these
+  additional modules; you can download it from
+  http://juanjox.kernelnotes.org/
+
+  All this additional code is still under development and so is
+  currently marked EXPERIMENTAL.
+  
+  If you want to try, for example, PORT FORWARDING, say Y.
+
+IP: ipautofw masquerade support (Experimental)
+CONFIG_IP_MASQUERADE_IPAUTOFW
+  ipautofw is a program which allows the masquerading of protocols
+  which do not (as yet) have their own protocol helpers. Information
+  and source for ipautofw is available via FTP (user: anonymous) from
+  ftp://ftp.netis.com/pub/members/rlynch/
+
+  You will also need the ipmasqadm tool available from
+  http://juanjox.kernelnotes.org/ .
+
+  The ipautofw code is still under development and so is currently
+  marked EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_autofw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: ipportfw masquerade support
+CONFIG_IP_MASQUERADE_IPPORTFW
+  Port Forwarding is an addition to IP Masquerading which allows some
+  forwarding of packets from outside to inside a firewall on given
+  ports. This could be useful if, for example, you want to run a web
+  server behind the firewall or masquerading host and that web server
+  should be accessible from the outside world. An external client
+  sends a request to port 80 of the firewall, the firewall forwards
+  this request to the web server, the web server handles the request
+  and the results are sent through the firewall to the original
+  client. The client thinks that the firewall machine itself is
+  running the web server. This can also be used for load balancing if
+  you have a farm of identical web servers behind the firewall.
+
+  Information about this feature is available from
+  http://www.monmouth.demon.co.uk/ipsubs/portforwarding.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). For general info, please
+  see ftp://ftp.compsoc.net/users/steve/ipportfw/linux21/
+
+  You will need the user space program "ipmasqadm" which can be
+  downloaded from http://juanjox.kernelnotes.org/
+
+  The portfw code is still under development and so is currently
+  marked EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_portfw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: ipmarkfw masquerade support
+CONFIG_IP_MASQUERADE_MFW
+  Firewall Mark Forwarding provides functionality similar to port
+  forwarding (see "IP: ipportfw masquerade support", above), the
+  difference being that Firewall Mark Forwarding uses "firewalling
+  mark" to select which packets must be forwarded (see ipchains(8),
+  "-m" argument).
+
+  This code is still under development and so is currently marked
+  EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_markfw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: aliasing support
+CONFIG_IP_ALIAS
+  Sometimes it is useful to give several IP addresses to a single
+  physical network interface (serial port or Ethernet card). The most
+  common case is that you want to serve different WWW or ftp documents
+  to the outside depending on which of your host names was used to
+  connect to you. This is called "multihosting" or "virtual domains"
+  or "virtual hosting services" and is explained in detail on the WWW
+  at http://www.thesphere.com/~dlp/TwoServers/ (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape) and also in the Virtual-Services-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Another scenario would be that there are two logical networks living
+  on your local Ethernet and you want to access them both with the
+  same Ethernet card. This can also be done if you say Y here.
+
+  The configuration of these alias addresses is done with a special
+  name syntax explained in Documentation/networking/alias.txt and in
+  the IP-Alias mini-HOWTO. If you want this, say Y. Most people don't
+  need it and say N.
+
+IP: multicast routing
+CONFIG_IP_MROUTE
+  This is used if you want your machine to act as a router for IP
+  packets that have several destination addresses. It is needed on the
+  MBONE, a high bandwidth network on top of the Internet which carries
+  audio and video broadcasts. In order to do that, you would most
+  likely run the program mrouted. Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. If you haven't heard about
+  it, you don't need it.
+
+IP: PIM-SM version 1 support
+CONFIG_IP_PIMSM_V1
+  Kernel side support for Sparse Mode PIM (Protocol Independent
+  Multicast) version 1. This multicast routing protocol is used widely
+  because Cisco supports it. You need special software to use it
+  (pimd-v1). Please see http://netweb.usc.edu/pim/ for more
+  information about PIM (to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or
+  netscape). 
+
+  Say Y if you want to use PIM-SM v1. Note that you can say N here if
+  you just want to use Dense Mode PIM.
+
+IP: PIM-SM version 2 support
+CONFIG_IP_PIMSM_V2
+  Kernel side support for Sparse Mode PIM version 2. In order to use
+  this, you need an experimental routing daemon supporting it (pimd or
+  gated-5). This routing protocol is not used widely, so say N unless
+  you want to play with it.
+
+PC/TCP compatibility mode
+CONFIG_INET_PCTCP
+  If you have been having difficulties telnetting to your Linux
+  machine from a DOS system that uses (broken) PC/TCP networking
+  software (all versions up to OnNet 2.0) over your local Ethernet try
+  saying Y here. Everyone else says N. 
+
+  People having problems with NCSA telnet should see the file
+  linux/Documentation/networking/ncsa-telnet.
+
+Reverse ARP server
+CONFIG_INET_RARP
+  If there are (usually diskless or portable) machines on your local
+  network that know their hardware Ethernet addresses but don't know
+  their IP addresses upon startup, they can send out a Reverse Address
+  Resolution Protocol (RARP) request to find out their own IP
+  addresses. Diskless Sun 3 machines use this procedure at boot time,
+  and diskless Linux boxes can be configured to do it as well.
+  
+  If you want your Linux box to be able to *answer* such requests,
+  answer Y here; you'll then have to run the program rarp ("man rarp")
+  on your box.
+
+  If you actually want to use a diskless Sun 3 machine as an X
+  terminal to Linux, say Y here and fetch Linux-Xkernel from
+  ftp://metalab.unc.edu/pub/Linux/system/network/boot.net/.
+
+  Superior solutions to the problem of booting and configuring
+  machines over a net connection are given by the protocol BOOTP and
+  its successor DHCP. See the DHCP FAQ
+  http://web.syr.edu/~jmwobus/comfaqs/dhcp.faq.html for details (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape).
+
+  If you want to compile RARP support as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called rarp.o. 
+
+  If you don't understand a word of the above, say N and rest in
+  peace.
+
+Assume subnets are local
+CONFIG_INET_SNARL
+  Say Y if you are on a subnetted network with all machines connected
+  by Ethernet segments only, as this option optimizes network access
+  for this special case. If there are other connections, e.g. SLIP
+  links, between machines of your IP network, say N. If in doubt,
+  answer N. The PATH mtu discovery facility will cover most cases
+  anyway.
+
+Path MTU Discovery (normally enabled)
+CONFIG_PATH_MTU_DISCOVERY
+  MTU (maximal transfer unit) is the size of the chunks we send out
+  over the net. "Path MTU Discovery" means that, instead of always
+  sending very small chunks, we start out sending big ones and if we
+  then discover that some host along the way likes its chunks smaller,
+  we adjust to a smaller size. This is good, so most people say Y
+  here.
+
+  However, some DOS software (versions of DOS NCSA telnet and Trumpet
+  Winsock in PPP mode) is broken and won't be able to connect to your
+  Linux machine correctly in all cases (especially through a terminal
+  server) unless you say N here. See
+  Documentation/networking/ncsa-telnet for the location of fixed NCSA
+  telnet clients. If in doubt, say Y.
+
+Disable NAGLE algorithm (normally enabled)
+CONFIG_TCP_NAGLE_OFF
+  The NAGLE algorithm works by requiring an acknowledgment before
+  sending small IP frames (packets). This keeps tiny telnet and
+  rlogin packets from congesting Wide Area Networks. Most people
+  strongly recommend to say N here, thereby leaving NAGLE
+  enabled. Those programs that would benefit from disabling this
+  facility can do it on a per connection basis themselves.
+
+IP: Allow large windows (not recommended if <16 MB of memory)
+CONFIG_SKB_LARGE
+  On high speed, long distance networks the performance limit on
+  networking becomes the amount of data the sending machine can buffer
+  until the other end confirms its reception. (At 45 Mbit/second there
+  are a lot of bits between New York and London ...). If you say Y
+  here, bigger buffers can be used which allows larger amounts of data
+  to be "in flight" at any given time. It also means a user process
+  can require a lot more memory for network buffers and thus this
+  option is best used only on machines with 16 MB of memory or higher.
+  Unless you are using long links with end to end speeds of over 2
+  Mbit a second or satellite links this option will make no difference
+  to performance.
+
+Unix domain sockets
+CONFIG_UNIX
+  If you say Y here, you will include support for Unix domain sockets;
+  sockets are the standard Unix mechanism for establishing and
+  accessing network connections. Many commonly used programs such as
+  the X Window system and syslog use these sockets even if your
+  machine is not connected to any network. Unless you are working on
+  an embedded system or something similar, you therefore definitely
+  want to say Y here.
+
+  However, the socket support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  unix.o. If you try building this as a module and you have said Y to
+  "Kernel module loader support" above, be sure to add 'alias net-pf-1
+  unix' to your /etc/conf.modules file. Note that several important
+  services won't work correctly if you say M here and then neglect to
+  load the module.
+
+  Say Y unless you know what you are doing.
+
+The IPv6 protocol
+CONFIG_IPV6
+  This is experimental support for the next version of the Internet
+  Protocol: IP version 6 (also called IPng "IP next generation"). 
+  Features of this new protocol include: expanded address space,
+  authentication and privacy, and seamless interoperability with the
+  current version of IP (IP version 4). For general information about
+  IPv6, see http://playground.sun.com/pub/ipng/html/ipng-main.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape); for specific information
+  about IPv6 under Linux read the file net/ipv6/README in the kernel source. 
+
+  If you want to use IPv6, please upgrade to the newest net-tools as
+  given in Documentation/Changes. You will still be able to do regular
+  IPv4 networking as well.
+
+  This protocol support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module will be called ipv6.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+  It is safe to say N here for now.
+
+IPv6: enable EUI-64 token format
+CONFIG_IPV6_EUI64
+  6bone, the network of computers using the IPv6 protocol, is moving
+  to a new aggregatable address format and a new link local address
+  assignment (EUI-64). Say Y if your site has upgraded already, or
+  has started to upgrade.
+
+IPv6: disable provider based addresses
+CONFIG_IPV6_NO_PB
+  Linux tries to operate correctly when your site has moved to EUI-64
+  only partially. Unfortunately, the two address formats (old:
+  "provider based" and new: "aggregatable") are incompatible. Say Y if
+  your site finished the upgrade to EUI-64, and/or you encountered
+  some problems caused by the presence of two link-local addresses on
+  an interface.
+
+IPv6: routing messages via old netlink
+CONFIG_IPV6_NETLINK
+  You can say Y here to receive routing messages from the IPv6 code
+  through the old netlink interface. However, a better option is to
+  say Y to "Kernel/User network link driver" and to "Routing
+  messages" instead.
+  
+IPX networking
+CONFIG_IPX
+  This is support for the Novell networking protocol, IPX, commonly
+  used for local networks of Windows machines. You need it if you want
+  to access Novell NetWare file or print servers using the Linux
+  Novell client ncpfs (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/) or from within
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO). In order to do the
+  former, you'll also have to say Y to "NCP filesystem support",
+  below.
+
+  IPX is similar in scope to IP, while SPX, which runs on top of IPX,
+  is similar to TCP. There is also experimental support for SPX in
+  Linux (see "SPX networking", below).
+
+  To turn your Linux box into a fully featured NetWare file server and
+  IPX router, say Y here and fetch either lwared from
+  ftp://metalab.unc.edu/pub/Linux/system/network/daemons/ or mars_nwe
+  from ftp://ftp.gwdg.de/pub/linux/misc/ncpfs. For more information,
+  read the IPX-HOWTO in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  The IPX driver would enlarge your kernel by about 5 kB. This driver
+  is also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module will
+  be called ipx.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. Unless you want to integrate
+  your Linux box with a local Novell network, say N.
+
+IPX: Full internal IPX network
+CONFIG_IPX_INTERN
+  Every IPX network has an address that identifies it. Sometimes it is
+  useful to give an IPX "network" address to your Linux box as well
+  (for example if your box is acting as a file server for different
+  IPX networks: it will then be accessible from everywhere using the
+  same address). The way this is done is to create a virtual internal
+  "network" inside your box and to assign an IPX address to this
+  network. Say Y here if you want to do this; read the IPX-HOWTO at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO for details.
+
+  The full internal IPX network enables you to allocate sockets on
+  different virtual nodes of the internal network. This is done by
+  evaluating the field sipx_node of the socket address given to the
+  bind call. So applications should always initialize the node field
+  to 0 when binding a socket on the primary network. In this case the
+  socket is assigned the default node that has been given to the
+  kernel when the internal network was created. By enabling the full
+  internal IPX network the cross-forwarding of packets targeted at
+  'special' sockets to sockets listening on the primary network is
+  disabled. This might break existing applications, especially RIP/SAP
+  daemons. A RIP/SAP daemon that works well with the full internal net
+  can be found on ftp://ftp.gwdg.de/pub/linux/misc/ncpfs. 
+
+  If you don't know what you are doing, say N.
+
+IPX: SPX networking (EXPERIMENTAL)
+CONFIG_SPX
+  The Sequenced Packet eXchange protocol is a transport layer protocol
+  built on top of IPX. It is used in Novell NetWare systems for
+  client-server applications and is similar to TCP (which runs on top
+  of IP).
+
+  Note that Novell NetWare file sharing does not use SPX; it uses a
+  protocol called NCP, for which separate Linux support is available
+  ("NCP filesystem support" below for the client side, and the user
+  space programs lwared or mars_nwe for the server side).
+
+  Say Y here if you have use for SPX; read the IPX-HOWTO at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called af_spx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AppleTalk DDP
+CONFIG_ATALK
+  AppleTalk is the way Apple computers speak to each other on a
+  network. If your Linux box is connected to such a network and you
+  want to join the conversation, say Y. You will need to use the
+  netatalk package so that your Linux box can act as a print and file
+  server for Macs as well as access AppleTalk printers. Check out
+  http://threepio.hitchcock.org/cgi-bin/faq/netatalk/faq.pl on the WWW
+  for details (to browse the WWW, you need to have access to a machine
+  on the Internet that has a program like lynx or netscape). EtherTalk
+  is the name used for AppleTalk over Ethernet and the cheaper and
+  slower LocalTalk is AppleTalk over a proprietary Apple network using
+  serial links. EtherTalk and LocalTalk are fully supported by Linux.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html
+  The NET-3-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO contains valuable
+  information as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called appletalk.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. I hear that
+  the GNU boycott of Apple is over, so even politically correct people
+  are allowed to say Y here.
+
+AppleTalk-IP driver support
+CONFIG_IPDDP
+  This allows IP networking for users who only have AppleTalk
+  networking available. This feature is experimental. With this
+  driver, you can encapsulate IP inside AppleTalk (e.g. if your Linux
+  box is stuck on an AppleTalk only network) or decapsulate (e.g. if
+  you want your Linux box to act as an Internet gateway for a zoo of
+  AppleTalk connected Macs). Please see the file
+  Documentation/networking/ipddp.txt for more information.
+
+  If you say Y here, the AppleTalk-IP support will be compiled into
+  the kernel. In this case, you can either use encapsulation or
+  decapsulation, but not both. With the following two questions, you
+  decide which one you want.
+
+  If you say M here, the AppleTalk-IP support will be compiled as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want, read Documentation/modules.txt).
+  The module is called ipddp.o. In this case, you will be able to use
+  both encapsulation and decapsulation simultaneously, by loading two
+  copies of the module and specifying different values for the module
+  option ipddp_mode. 
+
+IP to AppleTalk-IP Encapsulation support
+CONFIG_IPDDP_ENCAP
+  If you say Y here, the AppleTalk-IP code will be able to encapsulate
+  IP packets inside AppleTalk frames; this is useful if your Linux box
+  is stuck on an AppleTalk network (which hopefully contains a
+  decapsulator somewhere). Please see
+  Documentation/networking/ipddp.txt for more information. If you said
+  Y to "AppleTalk-IP driver support" above and you say Y here, then
+  you cannot say Y to "AppleTalk-IP to IP Decapsulation support",
+  below.
+
+AppleTalk-IP to IP Decapsulation support
+CONFIG_IPDDP_DECAP
+  If you say Y here, the AppleTalk-IP code will be able to decapsulate
+  AppleTalk-IP frames to IP packets; this is useful if you want your
+  Linux box to act as an Internet gateway for an AppleTalk network.
+  Please see Documentation/networking/ipddp.txt for more information.
+  If you said Y to "AppleTalk-IP driver support" above and you say Y
+  here, then you cannot say Y to "IP to AppleTalk-IP Encapsulation
+  support", above.
+
+Apple/Farallon LocalTalk PC card support
+CONFIG_LTPC
+  This allows you to use the AppleTalk PC card to connect to LocalTalk
+  networks. The card is also known as the Farallon PhoneNet PC card.
+  If you are in doubt, this card is the one with the 65C02 chip on it.
+  You also need version 1.3.3 or later of the netatalk package.
+  This driver is experimental, which means that it may not work.
+  See the file Documentation/networking/ltpc.txt.
+
+COPS LocalTalk PC card support
+CONFIG_COPS
+  This allows you to use COPS AppleTalk cards to connect to LocalTalk
+  networks. You also need version 1.3.3 or later of the netatalk
+  package. This driver is experimental, which means that it may not
+  work. This driver will only work if you choose "AppleTalk DDP"
+  networking support, above.
+  Please read the file Documentation/networking/cops.txt. 
+
+Dayna firmware support
+CONFIG_COPS_DAYNA
+  Support COPS compatible cards with Dayna style firmware (Dayna
+  DL2000/ Daynatalk/PC (half length), COPS LT-95, Farallon PhoneNET PC
+  III, Farallon PhoneNET PC II).
+
+Tangent firmware support
+CONFIG_COPS_TANGENT
+  Support COPS compatible cards with Tangent style firmware (Tangent
+  ATB_II, Novell NL-1000, Daystar Digital LT-200.
+
+Amateur Radio support
+CONFIG_HAMRADIO
+  If you want to connect your Linux box to an amateur radio, answer Y
+  here. You want to read http://www.tapr.org/tapr/html/pkthome.html
+  (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape) and the HAM-HOWTO
+  and the AX25-HOWTO, both available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about amateur radio.
+
+Amateur Radio AX.25 Level 2
+CONFIG_AX25
+  This is the protocol used for computer communication over amateur
+  radio. It is either used by itself for point-to-point links, or to
+  carry other protocols such as tcp/ip. To use it, you need a device
+  that connects your Linux box to your amateur radio. You can either
+  use a low speed TNC (a Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output) supporting the KISS protocol or
+  one of the various SCC cards that are supported by the generic Z8530
+  or the DMA SCC driver. Another option are the Baycom modem serial
+  and parallel port hacks or the sound card modem (supported by their
+  own drivers). If you say Y here, you also have to say Y to one of
+  those drivers.
+
+  Information about where to get supporting software for Linux amateur
+  radio as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You might also want to
+  check out the file Documentation/networking/ax25.txt in the kernel
+  source. More information about digital amateur radio in general is
+  on the WWW at http://www.tapr.org/tapr/html/pkthome.html. (To browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ax25.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AX.25 DAMA Slave support
+CONFIG_AX25_DAMA_SLAVE
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other slaves.
+  If you say Y here, your Linux box will act as a DAMA slave; this is
+  transparent in that you don't have to do any special DAMA
+  configuration. (Linux cannot yet act as a DAMA server.) If unsure,
+  say N.
+
+AX.25 DAMA Master support
+CONFIG_AX25_DAMA_MASTER
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other
+  slaves. If you say Y here, your Linux box will act as a DAMA server.
+  If unsure, say N.
+
+Amateur Radio NET/ROM
+CONFIG_NETROM
+  NET/ROM is a network layer protocol on top of AX.25 useful for
+  routing.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called netrom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amateur Radio X.25 PLP (Rose)
+CONFIG_ROSE
+  The Packet Layer Protocol (PLP) is a way to route packets over X.25
+  connections in general and amateur radio AX.25 connections in
+  particular, essentially an alternative to NET/ROM.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rose.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Serial port KISS driver for AX.25
+CONFIG_MKISS
+  KISS is a protocol used for the exchange of data between a computer
+  and a Terminal Node Controller (a small embedded system commonly
+  used for networking over AX.25 amateur radio connections; it
+  connects the computer's serial port with the radio's microphone
+  input and speaker output).
+
+  Although KISS is less advanced than the 6pack protocol, it has
+  the advantage that it is already supported by most modern TNCs
+  without the need for a firmware upgrade.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called mkiss.o.
+
+Serial port 6PACK driver for AX.25
+CONFIG_6PACK
+  6pack is a transmission protocol for the data exchange between your
+  PC and your TNC (the Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output). This protocol can be used as
+  an alternative to KISS for networking over AX.25 amateur radio
+  connections, but it has some extended functionality.
+
+  Note that this driver is still experimental and might cause
+  problems. For details about the features and the usage of the
+  driver, read Documentation/networking/6pack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called 6pack.o.
+
+BPQ Ethernet driver
+CONFIG_BPQETHER
+  AX.25 is the protocol used for computer communication over amateur
+  radio. If you say Y here, you will be able to send and receive AX.25
+  traffic over Ethernet (also called "BPQ AX.25"), which could be
+  useful if some other computer on your local network has a direct
+  amateur radio connection.
+
+High-speed (DMA) SCC driver for AX.25
+CONFIG_DMASCC
+  This is a driver for high-speed SCC boards, i.e. those supporting
+  DMA on one port. You usually use those boards to connect your
+  computer to an amateur radio modem (such as the WA4DSY 56kbps
+  modem), in order to send and receive AX.25 packet radio network
+  traffic.
+
+  Currently, this driver supports Ottawa PI/PI2
+  (http://hydra.carleton.ca/info/pi2.html) and Gracilis PackeTwin
+  (http://www.paccomm.com/gracilis.html) boards. They are detected
+  automatically. If you have one of these cards, say Y here and read
+  the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/.
+
+  This driver can operate multiple boards simultaneously. If you
+  compile it as a module (by saying M instead of Y), it will be called
+  dmascc.o. If you don't pass any parameter to the driver, all
+  possible I/O addresses are probed. This could irritate other devices
+  that are currently not in use. You may specify the list of addresses
+  to be probed by "dmascc=addr1,addr2,..." (when compiled into the
+  kernel image) or "io=addr1,addr2,..." (when loaded as a module). The
+  network interfaces will be called dmascc0 and dmascc1 for the board
+  detected first, dmascc2 and dmascc3 for the second one, and so on.
+
+  Before you configure each interface with ifconfig, you MUST set
+  certain parameters, such as channel access timing, clock mode, and
+  DMA channel. This is accomplished with a small utility program,
+  dmascc_cfg, available at
+  http://www.nt.tuwien.ac.at/~kkudielk/Linux/. (To browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+Z8530 SCC driver for AX.25
+CONFIG_SCC
+  These cards are used to connect your Linux box to an amateur radio
+  in order to communicate with other computers. If you want to use
+  this, read Documentation/networking/z8530drv.txt and the
+  AX25-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also make sure to say Y
+  to "Amateur Radio AX.25 Level 2" support.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called scc.o.
+
+additional delay for PA0HZP OptoSCC compatible boards
+CONFIG_SCC_DELAY
+  Say Y here if you experience problems with the SCC driver not
+  working properly; please read Documentation/networking/z8530drv.txt
+  for details. If unsure, say N.
+
+#support for TRX that feedback the tx signal to rx
+#CONFIG_SCC_TRXECHO
+###
+### Don't know what's going on here.
+###
+#
+YAM driver for AX.25
+CONFIG_YAM
+  Support for the YAM modem on serial port. If you want to compile this
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt.
+
+BAYCOM picpar and par96 driver for AX.25
+CONFIG_BAYCOM_PAR
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the picpar and
+  par96 designs. To configure the driver, use the sethdlc utility
+  available in the standard ax25 utilities package. For information on
+  the modems, see http://www.baycom.de (to browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape) and Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM EPP driver for AX.25
+CONFIG_BAYCOM_EPP
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the EPP
+  designs. To configure the driver, use the sethdlc utility available
+  in the standard ax25 utilities package. For information on the
+  modems, see http://www.baycom.de (to browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape) and Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM ser12 full duplex driver for AX.25
+CONFIG_BAYCOM_SER_FDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. In addition, it allows the
+  baudrate to be set between 300 and 4800 baud (however not all modems
+  support all baudrates). This is the preferred driver. The next
+  driver, "BAYCOM ser12 half duplex driver for AX.25" is the old
+  driver and still provided in case this driver does not work with
+  your serial interface chip. To configure the driver, use the sethdlc
+  utility available in the standard ax25 utilities package. For
+  information on the modems, see http://www.baycom.de (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) and
+  Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_fdx.o.
+
+BAYCOM ser12 half duplex driver for AX.25
+CONFIG_BAYCOM_SER_HDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. This is the old driver. It is
+  still provided in case your serial interface chip does not work with
+  the full duplex driver. This driver is depreciated. To configure
+  the driver, use the sethdlc utility available in the standard ax25
+  utilities package. For information on the modems, see
+  http://www.baycom.de (to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape)
+  and Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_hdx.o.
+
+Sound card modem driver for AX.25
+CONFIG_SOUNDMODEM
+  This experimental driver allows a standard Sound Blaster or
+  WindowsSoundSystem compatible sound card to be used as a packet
+  radio modem (NOT as a telephone modem!), to send digital traffic
+  over amateur radio.
+
+  To configure the driver, use the sethdlc, smdiag and smmixer
+  utilities available in the standard ax25 utilities package. For
+  information on how to key the transmitter, see
+  http://www.ife.ee.ethz.ch/~sailer/pcf/ptt_circ/ptt.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape) and
+  Documentation/networking/soundmodem.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called soundmodem.o.
+
+Sound card modem support for Sound Blaster and compatible cards
+CONFIG_SOUNDMODEM_SBC
+  This option enables the soundmodem driver to use Sound Blaster and
+  compatible cards. If you have a dual mode card (i.e. a WSS cards
+  with a Sound Blaster emulation) you should say N here and Y to
+  "Sound card modem support for WSS and Crystal cards", below, because
+  this usually results in better performance. This option also
+  supports SB16/32/64 in full duplex mode.
+
+Sound card modem support for WSS and Crystal cards
+CONFIG_SOUNDMODEM_WSS
+  This option enables the soundmodem driver to use WindowsSoundSystem
+  compatible cards. These cards feature a codec chip from either
+  Analog Devices (such as AD1848, AD1845, AD1812) or Crystal
+  Semiconductors (such as CS4248, CS423x). This option also supports
+  the WSS full duplex operation which currently works with Crystal
+  CS423x chips. If you don't need full duplex operation, do not enable
+  it to save performance.
+
+Sound card modem support for 1200 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK1200
+  This option enables the soundmodem driver 1200 baud AFSK modem,
+  compatible to popular modems using TCM3105 or AM7911. The
+  demodulator requires about 12% of the CPU power of a Pentium 75 CPU
+  per channel.
+
+Sound card modem support for 2400 baud AFSK modulation (7.3728MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_7
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with a 7.3728MHz
+  crystal. Note that the availability of this driver does _not_ imply
+  that I recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2400 baud AFSK modulation (8MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_8
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with an 8MHz crystal.
+  Note that the availability of this driver does _not_ imply that I
+  recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2666 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK2666
+  This option enables the soundmodem driver 2666 baud AFSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud 8PSK modulation
+CONFIG_SOUNDMODEM_PSK4800
+  This option enables the soundmodem driver 4800 baud 8PSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud HAPN-1 modulation
+CONFIG_SOUNDMODEM_HAPN4800
+  This option enables the soundmodem driver 4800 baud HAPN-1
+  compatible modem. This modulation seems to be widely used 'down
+  under' and in the Netherlands. Here, nobody uses it, so I could not
+  test if it works. It is compatible to itself, however :-)
+
+Sound card modem support for 9600 baud FSK G3RUH modulation
+CONFIG_SOUNDMODEM_FSK9600
+  This option enables the soundmodem driver 9600 baud FSK modem,
+  compatible to the G3RUH standard. The demodulator requires about 4%
+  of the CPU power of a Pentium 75 CPU per channel. You can say Y to
+  both 1200 baud AFSK and 9600 baud FSK if you want (but obviously you
+  can only use one protocol at a time, depending on what the other end
+  can understand).
+
+CCITT X.25 Packet Layer
+CONFIG_X25
+  X.25 is a set of standardized network protocols, similar in scope to
+  frame relay; the one physical line from your box to the X.25 network
+  entry point can carry several logical point-to-point connections
+  (called "virtual circuits") to other computers connected to the X.25
+  network. Governments, banks, and other organizations tend to use it
+  to connect to each other or to form Wide Area Networks (WANs). Many
+  countries have public X.25 networks. X.25 consists of two
+  protocols: the higher level Packet Layer Protocol (PLP) (say Y here
+  if you want that) and the lower level data link layer protocol LAPB
+  (say Y to "LAPB Data Link Driver" below if you want that). 
+
+  You can read more about X.25 at http://www.sangoma.com/x25.html and
+  http://www.cisco.com/univercd/data/doc/software/11_0/rpcg/cx25.htm
+  (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape). Information
+  about X.25 for Linux is contained in the files
+  Documentation/networking/x25.txt and
+  Documentation/networking/x25-iface.txt. 
+
+  One connects to an X.25 network either with a dedicated network card
+  using the X.21 protocol (not yet supported by Linux) or one can do
+  X.25 over a standard telephone line using an ordinary modem (say Y
+  to "X.25 async driver" below) or over Ethernet using an ordinary
+  Ethernet card and either the 802.2 LLC protocol (say Y to "802.2
+  LLC" below) or LAPB over Ethernet (say Y to "LAPB Data Link Driver"
+  and "LAPB over Ethernet driver" below). 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25.o. If unsure, say N.
+
+LAPB Data Link Driver (EXPERIMENTAL) 
+CONFIG_LAPB
+  Link Access Procedure, Balanced (LAPB) is the data link layer (i.e.
+  the lower) part of the X.25 protocol. It offers a reliable
+  connection service to exchange data frames with one other host, and
+  it is used to transport higher level protocols (mostly X.25 Packet
+  Layer, the higher part of X.25, but others are possible as well).
+  Usually, LAPB is used with specialized X.21 network cards, but Linux
+  currently supports LAPB only over Ethernet connections. If you want
+  to use LAPB connections over Ethernet, say Y here and to "LAPB over
+  Ethernet driver" below. Read
+  Documentation/networking/lapb-module.txt for technical details.
+
+  If you want to compile this driver as a module though ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called lapb.o. If unsure, say N.
+
+802.2 LLC (VERY EXPERIMENTAL)
+CONFIG_LLC
+  This is a Logical Link Layer protocol used for X.25 connections over
+  Ethernet, using ordinary Ethernet cards. 
+
+Bridging (EXPERIMENTAL)
+CONFIG_BRIDGE
+  If you say Y here, then your Linux box will be able to act as an
+  Ethernet bridge, which means that the different Ethernet segments it
+  is connected to will appear as one Ethernet to the participants.
+  Several such bridges can work together to create even larger
+  networks of Ethernets using the IEEE802.1 spanning tree algorithm.
+  As this is a standard, Linux bridges will interwork properly with
+  other third party bridge products. 
+
+  In order to use this, you'll need the bridge configuration tools
+  available from http://lrp.plain.co.nz/tarballs/bridgex-0.30.tar.gz
+  Note that if your box acts as a bridge, it probably contains several
+  Ethernet devices, but the kernel is not able to recognize more than 
+  one ISA ethernet card at boot time without help; for  details read 
+  the Ethernet-HOWTO, available via FTP (user: anonymous)
+  in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. The Bridging code is
+  still in test. If unsure, say N.
+
+Frame Diverter (EXPERIMENTAL)
+CONFIG_NET_DIVERT
+  The Frame Diverter allows you to divert packets from the
+  network, that are not aimed at the interface receiving it (in 
+  promisc. mode). Typically, a Linux box setup as an ethernet bridge
+  with the Frames Diverter on, can do some *really* transparent www 
+  caching using a Squid proxy for example.
+
+  This is very useful when you don't want to change your router's
+  config (or if you simply don't have access to it).
+
+  The other possible usages of diverting Ethernet Frames are numberous:
+   - reroute smtp traffic to another interface
+   - traffic-shape certain network streams
+   - transparently proxy smtp connections
+   - etc...
+
+  For more informations, please refer to:
+    http://www.freshmeat.net/projects/etherdivert
+    http://perso.wanadoo.fr/magpie/EtherDivert.html
+
+  If unsure, say N
+
+Packet socket
+CONFIG_PACKET
+  The Packet protocol is used by applications which communicate
+  directly with network devices without an intermediate network
+  protocol implemented in the kernel, e.g. tcpdump. If you want them
+  to work, choose Y. This driver is also available as a module called
+  af_packet.o ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.  You will
+  need to add 'alias net-pf-17 af_packet' to your /etc/conf.modules
+  file for the module version to function automatically.  If unsure, say Y.
+
+Kernel/User network link driver
+CONFIG_NETLINK
+  This driver allows for two-way communication between certain parts
+  of the kernel or modules and user processes; the user processes are
+  able to read from and write to character special files in the /dev
+  directory having major mode 36. So far, the kernel uses it to
+  publish some network related information if you say Y to "Routing
+  messages", below. It is also used by the firewall code to publish
+  information about possible attacks if you say Y to "IP: firewall
+  packet netlink device" further down. You also need to say Y here if
+  you want to use arpd, a daemon that helps keep the internal ARP
+  cache (a mapping between IP addresses and hardware addresses on the
+  local network) small. The ethertap device, which lets user space
+  programs read and write raw Ethernet frames, also needs the network
+  link driver. If unsure, say Y.
+
+Routing messages
+CONFIG_RTNETLINK
+  If you say Y here and create a character special file /dev/route
+  with major number 36 and minor number 0 using mknod ("man mknod"),
+  you (or some user space utility) can read some network related
+  routing information from that file. Everything you write to that
+  file will be discarded.
+
+Netlink device emulation
+CONFIG_NETLINK_DEV
+  This is a backward compatibility option, choose Y for now.
+  This option will be removed soon.
+
+IP Security Protocol (IPSEC) (EXPERIMENTAL)
+CONFIG_IPSEC
+  This unit is experimental code.
+  Pick 'y' for static linking, 'm' for module support or 'n' for none.
+  This option adds support for network layer packet encryption and/or
+  authentication with participating hosts.  The standards start with:
+  RFCs 2411, 2407 and 2401.  Others are mentioned where they refer to
+  specific features below.  There are more pending which can be found
+  at:  ftp://ftp.ietf.org/internet-drafts/draft-ietf-ipsec-*.
+  A description of each document can also be found at: 
+  http://ietf.org/ids.by.wg/ipsec.html.
+  Their charter can be found at: 
+  http://www.ietf.org/html.charters/ipsec-charter.html
+  Snapshots and releases of the current work can be found at: 
+  http://www.freeswan.org/
+
+IPSEC: IP-in-IP encapsulation
+CONFIG_IPSEC_IPIP
+  This option provides support for tunnel mode IPSEC.  It is recommended
+  to enable this.
+
+IPSEC: Authentication Header
+CONFIG_IPSEC_AH
+  This option provides support for the IPSEC Authentication Header
+  (IP protocol 51) which provides packet layer sender and content
+  authentication.  It is recommended to enable this.  RFC2402
+
+HMAC-MD5 algorithm
+CONFIG_IPSEC_AUTH_HMAC_MD5
+  Provides support for authentication using the HMAC MD5
+  algorithm with 96 bits of hash used as the authenticator.  RFC2403
+
+HMAC-SHA1 algorithm
+CONFIG_IPSEC_AUTH_HMAC_SHA1
+  Provides support for Authentication Header using the HMAC SHA1
+  algorithm with 96 bits of hash used as the authenticator.  RFC2404
+
+IPSEC: Encapsulating Security Payload
+CONFIG_IPSEC_ESP
+  This option provides support for the IPSEC Encapsulation Security
+  Payload (IP protocol 50) which provides packet layer content
+  hiding.  It is recommended to enable this.  RFC2406
+
+3DES algorithm
+CONFIG_IPSEC_ENC_3DES
+  Provides support for Encapsulation Security Payload protocol, using
+  the triple DES encryption algorithm.  RFC2451
+
+IPSEC Debugging Option
+CONFIG_IPSEC_DEBUG
+  Enables IPSEC kernel debugging.  It is further controlled by the
+  user space utility 'klipsdebug'.
+
+SCSI support?
+CONFIG_SCSI
+  If you want to use a SCSI hard disk, SCSI tape drive, SCSI CDROM or
+  any other SCSI device under Linux, say Y and make sure that you know
+  the name of your SCSI host adapter (the card inside your computer
+  that "speaks" the SCSI protocol, also called SCSI controller),
+  because you will be asked for it. 
+
+  You also need to say Y here if you want support for the parallel
+  port version of the 100 MB IOMEGA ZIP drive.
+
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. The
+  SCSI-Programming-HOWTO contains information about how to add or
+  remove an SCSI device from a running Linux machine without
+  rebooting.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scsi_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. However, do not compile this as a module if
+  your root filesystem (the one containing the directory /) is located
+  on a SCSI device.
+
+SCSI disk support
+CONFIG_BLK_DEV_SD
+  If you want to use a SCSI hard disk or the SCSI or parallel port
+  version of the IOMEGA ZIP drive under Linux, say Y and read the
+  SCSI-HOWTO, the Disk-HOWTO and the Multi-Disk-HOWTO, available via
+  FTP (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  This is NOT for SCSI CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sd_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. Do not compile this driver as a module if
+  your root filesystem (the one containing the directory /) is located
+  on a SCSI disk. In this case, do not compile the driver for your
+  SCSI host adapter (below) as a module either.
+
+SCSI tape support
+CONFIG_CHR_DEV_ST
+  If you want to use a SCSI tape drive under Linux, say Y and read the
+  SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and
+  drivers/scsi/README.st in the kernel source. This is NOT for SCSI
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called st.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+SCSI CDROM support
+CONFIG_BLK_DEV_SR
+  If you want to use a SCSI CDROM under Linux, say Y and read the
+  SCSI-HOWTO and the CDROM-HOWTO from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also make sure to say Y
+  or M to "ISO 9660 CDROM filesystem support" later.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sr_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+Enable vendor-specific extensions (for SCSI CDROM)
+CONFIG_BLK_DEV_SR_VENDOR
+  This enables the usage of vendor specific SCSI commands. This is
+  required to support multisession CDs with old NEC/TOSHIBA cdrom
+  drives (and HP Writers). If you have such a drive and get the first
+  session only, try saying Y here; everybody else says N.
+
+SCSI generic support
+CONFIG_CHR_DEV_SG
+  If you want to use SCSI scanners, synthesizers or CD-writers or just
+  about anything having "SCSI" in its name other than hard disks,
+  CDROMs or tapes, say Y here. These won't be supported by the kernel
+  directly, so you need some additional software which knows how to
+  talk to these devices using the SCSI protocol. For scanners, look at
+  SANE (www.mostang.com/sane). For CD writer software look at cdrecord
+  (www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private
+  /cdrecord.html) and for burning a "disk at once": cdrdao
+  (www.ping.de/sites/daneb/cdrdao.html). Cdparanoia is a high quality
+  digital reader of audio CDs (www.xiph.org/paranoia).
+  For other devices, it's possible that you'll have to write the driver
+  software yourself. Please read the file Documentation/scsi-generic.txt
+  for more information.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. The module will be called sg.o. If unsure,
+  say N.
+
+Probe all LUNs on each SCSI device
+CONFIG_SCSI_MULTI_LUN
+  If you have a SCSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, and only one LUN is detected, you
+  can say Y here to force the SCSI driver to probe for multiple LUNs. 
+  A SCSI device with multiple LUNs acts logically like multiple SCSI
+  devices. The vast majority of SCSI devices have only one LUN, and
+  so most people can say N here and should in fact do so, because it
+  is safer.
+
+Verbose SCSI error reporting (kernel size +=12K)
+CONFIG_SCSI_CONSTANTS
+  The error messages regarding your SCSI hardware will be easier to
+  understand if you say Y here; it will enlarge your kernel by about
+  12 KB. If in doubt, say Y.
+
+SCSI logging facility
+CONFIG_SCSI_LOGGING
+  This turns on a logging facility that can be used to debug a number
+  of SCSI related problems. 
+
+  If you say Y here, no logging output will appear by default, but you
+  can enable logging by saying Y to "/proc filesystem support" and
+  "Sysctl support" below and executing the command
+
+     echo "scsi log token [level]" > /proc/scsi/scsi
+
+  at boot time after the /proc filesystem has been mounted.
+
+  There are a number of things that can be used for 'token' (you can
+  find them in the source: drivers/scsi/scsi.c), and this allows you
+  to select the types of information you want, and the level allows
+  you to select the level of verbosity. 
+
+  If you say N here, it may be harder to track down some types of SCSI
+  problems. If you say Y here your kernel will be somewhat larger, but
+  there should be no noticeable performance impact as long as you have
+  logging turned off.
+
+AdvanSys SCSI support
+CONFIG_SCSI_ADVANSYS
+  This is a driver for all SCSI host adapters manufactured by
+  AdvanSys. It is documented in the kernel source in
+  drivers/scsi/advansys.c. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called advansys.o.
+
+Adaptec AHA152X/2825 support
+CONFIG_SCSI_AHA152X
+  This is a driver for the AHA-1510, AHA-1520, AHA-1522, and AHA-2825
+  SCSI host adapters. It also works for the AVA-1505, but the IRQ etc.
+  must be manually specified in this case.
+
+  It is explained in section 3.3 of the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You
+  might also want to read the comments at the top of
+  drivers/scsi/aha152x.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha152x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AHA1542 support
+CONFIG_SCSI_AHA1542
+  This is support for a SCSI host adapter. It is explained in section
+  3.4 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that Trantor was
+  recently purchased by Adaptec, and some former Trantor products are
+  being sold under the Adaptec name. If it doesn't work out of the
+  box, you may have to change some settings in drivers/scsi/aha1542.h.
+  
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aha1542.o.
+
+Adaptec AHA1740 support
+CONFIG_SCSI_AHA1740
+  This is support for a SCSI host adapter. It is explained in section
+  3.5 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/aha1740.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha1740.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AIC7xxx chipset SCSI controller support
+CONFIG_SCSI_AIC7XXX
+  This is support for the various aic7xxx based Adaptec SCSI
+  controllers. These include the 274x EISA cards; 284x VLB cards;
+  2902, 2910, 293x, 294x, 394x, 3985 and several other PCI and
+  motherboard based SCSI controllers from Adaptec. It does not support
+  the AAA-13x RAID controllers from Adaptec, nor will it likely ever
+  support them. It does not support the 2920 cards from Adaptec that
+  use the Future Domain SCSI controller chip. For those cards, you
+  need the "Future Domain 16xx SCSI support" driver.
+
+  In general, if the controller is based on an Adaptec SCSI controller
+  chip from the aic777x series or the aic78xx series, this driver
+  should work. The only exception is the 7810 which is specifically
+  not supported (that's the RAID controller chip on the AAA-13x
+  cards).
+
+  Note that the AHA2920 SCSI host adapter is *not* supported by this
+  driver; choose "Future Domain 16xx SCSI support" instead if you have
+  one of those.
+
+  Information on the configuration options for this controller can be
+  found by checking the help file for each of the available
+  configuration options. You should read drivers/scsi/README.aic7xxx
+  at a minimum before contacting the maintainer with any questions.  
+  The SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO can also be of great
+  help.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aic7xxx.o.
+
+Enable or Disable Tagged Command Queueing by default
+CONFIG_AIC7XXX_TCQ_ON_BY_DEFAULT
+  This option causes the aic7xxx driver to attempt to use tagged command
+  queueing on any devices that claim to support it.  If this is set to yes,
+  you can still turn off TCQ on troublesome devices with the use of the
+  tag_info boot parameter.  See /usr/src/linux/drivers/scsi/README.aic7xxx
+  for more information on that and other aic7xxx setup commands.  If this
+  option is turned off, you may still enable TCQ on known good devices by
+  use of the tag_info boot parameter.
+  
+  If you are unsure about your devices then it is safest to say N here.
+  
+  However, TCQ can increase performance on some hard drives by as much
+  as 50% or more, so I would recommend that if you say N here, that you
+  at least read the README.aic7xxx file so you will know how to enable
+  this option manually should your drives prove to be safe in regards
+  to TCQ.
+
+  Conversely, certain drives are known to lock up or cause bus resets when
+  TCQ is enabled on them.  If you have a Western Digital Enterprise SCSI
+  drive for instance, then don't even bother to enable TCQ on it as the
+  drive will become unreliable, and it will actually reduce performance.
+
+Default number of TCQ commands per device
+CONFIG_AIC7XXX_CMDS_PER_DEVICE
+  Specify the number of commands you would like to allocate per SCSI
+  device when Tagged Command Queueing (TCQ) is enabled on that device.
+
+  Reasonable figures are in the range of 8 to 24 commands per device,
+  but depending on hardware could be increased or decreased from that
+  figure. If the number is too high for any particular device, the
+  driver will automatically compensate usually after only 10 minutes
+  of uptime. It will not hinder performance if some of your devices
+  eventually have their command depth reduced, but is a waste of memory
+  if all of your devices end up reducing this number down to a more
+  reasonable figure.
+  
+  NOTE: Certain very broken drives are known to lock up when given more
+  commands than they like to deal with.  Quantum Fireball drives are the
+  most common in this category.  For the Quantum Fireball drives I would
+  suggest no more than 8 commands per device.
+
+  Default: 8
+
+Collect statistics to report in /proc
+CONFIG_AIC7XXX_PROC_STATS
+  This option tells the driver to keep track of how many commands have
+  been sent to each particular device and report that information to
+  the user via the /proc/scsi/aic7xxx/n file, where n is the number of
+  the aic7xxx controller you want the information on. This adds a
+  small amount of overhead to each and every SCSI command the aic7xxx
+  driver handles, so if you aren't really interested in this
+  information, it is best to leave it disabled. This will only work if
+  you also say Y to "/proc filesystem support", below. 
+
+  If unsure, say N.
+
+Delay in seconds after SCSI bus reset
+CONFIG_AIC7XXX_RESET_DELAY
+  This sets how long the driver will wait after resetting the SCSI bus
+  before attempting to communicate with the devices on the SCSI bus
+  again. This delay will be used during the reset phase at bootup time
+  as well as after any reset that might occur during normal operation.
+  Reasonable numbers range anywhere from 5 to 15 seconds depending on
+  your devices. DAT tape drives are notorious for needing more time
+  after a bus reset to be ready for the next command, but most hard
+  drives and CD-ROM devices are ready in only a few seconds. This
+  option has a maximum upper limit of 20 seconds to avoid bad
+  interactions between the aic7xxx driver and the rest of the linux
+  kernel. The default value has been reduced to 5 seconds. If this
+  doesn't work with your hardware, try increasing this value.
+
+IBM ServeRAID Support
+CONFIG_SCSI_IPS
+  This is support for the IBM ServeRAID hardware RAID controllers.
+  See http://www.developer.ibm.com/welcome/netfinity/serveraid.html
+  for more information.  If this driver does not work correctly
+  without modification please contact the author by email at
+  ipslinux@us.ibm.com.
+
+BusLogic SCSI support
+CONFIG_SCSI_BUSLOGIC
+  This is support for BusLogic MultiMaster and FlashPoint SCSI Host
+  Adapters. Consult the SCSI-HOWTO, available via anonymous FTP from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, and the files
+  README.BusLogic and README.FlashPoint in drivers/scsi for more
+  information. If this driver does not work correctly without
+  modification, please contact the author, Leonard N. Zubkoff, by
+  email to lnz@dandelion.com. 
+
+  You can also build this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  but only a single instance may be loaded. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. The
+  module will be called BusLogic.o.
+
+Omit BusLogic SCSI FlashPoint support
+CONFIG_SCSI_OMIT_FLASHPOINT
+  This option allows you to omit the FlashPoint support from the
+  BusLogic SCSI driver. The FlashPoint SCCB Manager code is
+  substantial, so users of MultiMaster Host Adapters may wish to omit
+  it.
+
+DTC3180/3280 SCSI support
+CONFIG_SCSI_DTC3280
+  This is support for DTC 3180/3280 SCSI Host Adapters. Please read
+  the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and the file
+  drivers/scsi/README.dtc3x80. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dtc.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-DMA [Obsolete] (DPT, NEC, AT&T, SNI, AST, Olivetti, Alphatronix) support
+CONFIG_SCSI_EATA_DMA
+  This is support for the EATA-DMA protocol compliant SCSI Host
+  Adapters like the SmartCache III/IV, SmartRAID controller families
+  and the DPT PM2011B and PM2012B controllers. 
+
+  Note that this driver is obsolete; if you have one of the above SCSI
+  Host Adapters, you should normally say N here and Y to "EATA
+  ISA/EISA/PCI support", below. Please read the SCSI-HOWTO, available
+  via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eata_dma.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-PIO (old DPT PM2001, PM2012A) support
+CONFIG_SCSI_EATA_PIO
+  This driver supports all EATA-PIO protocol compliant SCSI Host
+  Adapters like the DPT PM2001 and the PM2012A. EATA-DMA compliant
+  host adapters could also use this driver but are discouraged from
+  doing so, since this driver only supports hard disks and lacks
+  numerous features. You might want to have a look at the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata_pio.o.
+
+UltraStor 14F/34F support
+CONFIG_SCSI_U14_34F
+  This is support for the UltraStor 14F and 34F SCSI-2 host adapters.
+  The source at drivers/scsi/u14-34f.c contains some information about
+  this hardware. If the driver doesn't work out of the box, you may
+  have to change some settings in drivers/scsi/u14-34f.c. Read the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that there is also
+  another driver for the same hardware: "UltraStor SCSI support",
+  below. You should say Y to both only if you want 24F support as
+  well. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called u14-34f.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+enable elevator sorting
+CONFIG_SCSI_U14_34F_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_U14_34F_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 8
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 14. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+Future Domain 16xx SCSI/AHA-2920A support
+CONFIG_SCSI_FUTURE_DOMAIN
+  This is support for Future Domain's 16-bit SCSI host adapters
+  (TMC-1660/1680, TMC-1650/1670, TMC-3260, TMC-1610M/MER/MEX) and
+  other adapters based on the Future Domain chipsets (Quantum
+  ISA-200S, ISA-250MG; Adaptec AHA-2920A; and at least one IBM board).
+  It is explained in section 3.7 of the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  NOTE: Newer Adaptec AHA-2920C boards use the Adaptec AIC-7850 chip
+  and should use the aic7xxx driver ("Adaptec AIC7xxx chipset SCSI
+  controller support"). This Future Domain driver works with the older
+  Adaptec AHA-2920A boards with a Future Domain chip on them.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fdomain.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Future Domain MCS-600/700 SCSI support
+CONFIG_SCSI_FD_MCS
+ This is support for Future Domain MCS 600/700 MCA SCSI adapters. Some
+ PS/2 computers are equipped with IBM Fast SCSI Adapter/A which is
+ identical to the MCS 700 and hence also supported by this driver.
+ This driver also supports the Reply SB16/SCSI card (the SCSI part).
+ It supports multiple adapters in the same system.
+
+Generic NCR5380/53c400 SCSI support
+CONFIG_SCSI_GENERIC_NCR5380
+  This is the generic NCR family of SCSI controllers, not to be
+  confused with the NCR 53c7 or 8xx controllers. It is explained in
+  section 3.8 of the SCSI-HOWTO, available via FTP (user: anonymous)
+  at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work
+  out of the box, you may have to change some settings in
+  drivers/scsi/g_NCR5380.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called g_NCR5380.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Enable NCR53c400 extensions
+CONFIG_SCSI_GENERIC_NCR53C400
+  This enables certain optimizations for the NCR53c400 SCSI cards. You
+  might as well try it out. Note that this driver will only probe for
+  the Trantor T130B in its default configuration; you might have to
+  pass a command line option to the kernel at boot time if it doesn't
+  detect your card. See the file drivers/scsi/README.g_NCR5380 for
+  details.
+
+NCR5380/53c400 mapping method (use Port for T130B)
+CONFIG_SCSI_G_NCR5380_PORT
+  The NCR5380 and NCR53c400 SCSI controllers come in two varieties:
+  port or memory mapped. You should know what you have. The most
+  common card, Trantor T130B, uses port mapped mode.
+
+NCR53c7,8xx SCSI support
+CONFIG_SCSI_NCR53C7xx
+  This is a driver for the 53c7 and 8xx NCR family of SCSI
+  controllers, not to be confused with the NCR 5380 controllers. It is
+  explained in section 3.8 of the SCSI-HOWTO, available via FTP (user:
+  anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it
+  doesn't work out of the box, you may have to change some settings in
+  drivers/scsi/53c7,8xx.h. Please read drivers/scsi/README.ncr53c7xx
+  for the available boot time command line options.
+
+  Note: there is another driver for the 53c8xx family of controllers
+  ("NCR53C8XX SCSI support" below). If you want to use them both, you
+  need to say M to both and build them as modules, but only one may be
+  active at a time. If you have a 53c8xx board, it's better to use the
+  other driver.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 53c7,8xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+always negotiate synchronous transfers
+CONFIG_SCSI_NCR53C7xx_sync
+  In general, this is good; however, it is a bit dangerous since there
+  are some broken SCSI devices out there. Take your chances. Safe bet
+  is N.
+
+allow FAST-SCSI [10MHz]
+CONFIG_SCSI_NCR53C7xx_FAST
+  This will enable 10MHz FAST-SCSI transfers with your host
+  adapter. Some systems have problems with that speed, so it's safest
+  to say N here.
+
+allow DISCONNECT
+CONFIG_SCSI_NCR53C7xx_DISCONNECT
+  This enables the disconnect/reconnect feature of the NCR SCSI
+  controller. When you say Y here, a slow SCSI device will not lock
+  the SCSI bus while processing a request, allowing simultaneous use
+  of e.g. a SCSI hard disk and SCSI tape or CD-ROM drive, and
+  providing much better performance when using slow and fast SCSI
+  devices at the same time. Some devices, however, do not operate
+  properly with this option enabled, and will cause your SCSI system
+  to hang, which might cause a system crash. The safe answer
+  therefore is to say N.
+
+NCR53C8XX SCSI support
+CONFIG_SCSI_NCR53C8XX
+  This is the BSD ncr driver adapted to Linux for the NCR53C8XX family
+  of PCI-SCSI controllers. This driver supports parity checking,
+  tagged command queuing and fast synchronous data transfers up to 80
+  MB/s with wide FAST-40 LVD devices and controllers.
+
+  This driver does not support SYM53C1010 Ultra-160 PCI-SCSI chips.
+  Support for SYM53C1010 chips requires the "SYM53C8XX SCSI option" to
+  be configured. This option will configure a different driver.
+  Recent versions of the 53C8XX chips are better supported by the
+  option "SYM53C8XX SCSI support", below.
+
+  If you want the kernel to select the recommended driver for each of 
+  of your NCR/SYM53C8XX controllers you may just configure both the 
+  NCR53C8XX and the SYM53C8XX options to Y, or if modules are preferred, 
+  load first the sym53c8xx.o module and then the ncr53c8xx.o module.
+
+  Note: there is yet another driver for the 53c8xx family of controllers
+  ("NCR53c7,8xx SCSI support" above). If you want to use them both,
+  you need to say M to both and build them as modules, but only one
+  may be active at a time. If you have a 53c8xx board, you probably do
+  not want to use the "NCR53c7,8xx SCSI support".
+
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+SYM53C8XX SCSI support
+CONFIG_SCSI_SYM53C8XX
+  This driver supports all the features of recent 53C8XX chips (used
+  in PCI SCSI controllers), notably the hardware phase mismatch
+  feature of the SYM53C896, SYM53C895A and SYM53C1010.
+  It also supports Ultra-160 SCSI data transfers for the SYM53C1010.
+
+  Older versions of the 53C8XX chips are not supported by this
+  driver. If your system uses either a 810 rev. < 16, a 815, or a 825
+  rev. < 16 PCI SCSI processor, you must use the generic NCR53C8XX
+  driver ("NCR53C8XX SCSI support" above) or configure both the
+  NCR53C8XX and this SYM53C8XX drivers either as module or linked to
+  the kernel image.
+
+  When both drivers are linked to the kernel, the SYM53C8XX driver is 
+  called first at initialization and you can use the 'excl=ioaddr' 
+  driver boot option to exclude attachment of adapters by the SYM53C8XX 
+  driver. For instance, entering 'sym53c8xx=excl:0xb400,excl=0xc000' at 
+  lilo prompt prevents adapters at io address 0xb400 and 0xc000 from 
+  being attached by the SYM53C8XX driver, thus allowing the NCR53C8XX 
+  driver to attach them. The 'excl' option is also supported by the 
+  NCR53C8XX driver.
+  
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+synchronous data transfers frequency
+CONFIG_SCSI_NCR53C8XX_SYNC
+  The SCSI Parallel Interface-2 Standard defines 5 classes of transfer
+  rates: FAST-5, FAST-10, FAST-20, FAST-40 and FAST-80. The numbers are
+  respectively the maximum data transfer rates in mega-transfers per
+  second for each class. For example, a FAST-20 Wide 16 device is able
+  to transfer data at 20 million 16 bit packets per second for a total
+  rate of 40 MB/s.
+
+  You may specify 0 if you want to only use asynchronous data
+  transfers. This is the safest and slowest option. Otherwise, specify
+  a value between 5 and 80, depending on the capability of your SCSI
+  controller. The higher the number, the faster the data transfer.
+  Note that 80 should normally be ok since the driver decreases the
+  value automatically according to the controller's capabilities.
+
+  Your answer to this question is ignored for controllers with NVRAM,
+  since the driver will get this information from the user set-up. It
+  also can be overridden using a boot setup option, as follows
+  (example): 'ncr53c8xx=sync:12' will allow the driver to negotiate
+  for FAST-20 synchronous data transfer (20 mega-transfers per
+  second).
+
+  The normal answer therefore is not to go with the default but to
+  select the maximum value 80 allowing the driver to use the maximum
+  value supported by each controller. If this causes problems with
+  your SCSI devices, you should come back and decrease the value.
+
+  There is no safe option other than using good cabling, right
+  terminations and SCSI conformant devices.
+
+use normal IO
+CONFIG_SCSI_NCR53C8XX_IOMAPPED
+  If you say Y here, the driver will use normal IO, as opposed to
+  memory mapped IO. Memory mapped IO has less latency than normal IO
+  and works for most Intel-based hardware. Under Linux/Alpha only
+  normal IO is currently supported by the driver and so, this option
+  has no effect on those systems. 
+
+  The normal answer therefore is N; try Y only if you encounter SCSI
+  related problems.
+
+not allow targets to disconnect
+CONFIG_SCSI_NCR53C8XX_NO_DISCONNECT
+  This option is only provided for safety if you suspect some SCSI
+  device of yours to not support properly the target-disconnect
+  feature. In that case, you would say Y here. In general however, to
+  not allow targets to disconnect is not reasonable if there is more
+  than 1 device on a SCSI bus. The normal answer therefore is N.
+
+default tagged command queue depth
+CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS
+  "Tagged command queuing" is a feature of SCSI-2 which improves
+  performance: the host adapter can send several SCSI commands to a
+  device's queue even if previous commands haven't finished yet. Some
+  SCSI devices don't implement this properly; if you want to disable
+  this feature, enter 0 or 1 here (it doesn't matter which).
+
+  The default value is 8 and should be supported by most hard disks.
+  This value can be overridden from the boot command line using the 
+  'tags' option as follows (example):
+  'ncr53c8xx=tags:4/t2t3q16/t0u2q10' will set default queue depth to
+  4, set queue depth to 16 for target 2 and target 3 on controller 0
+  and set queue depth to 10 for target 0 / lun 2 on controller 1.
+
+  The normal answer therefore is to go with the default 8 and to use 
+  a boot command line option for devices that need to use a different 
+  command queue depth.
+
+  There is no safe option other than using good SCSI devices.
+
+maximum number of queued commands
+CONFIG_SCSI_NCR53C8XX_MAX_TAGS
+  This option allows you to specify the maximum number of commands
+  that can be queued to any device, when tagged command queuing is
+  possible. The default value is 32. Minimum is 2, maximum is 64 for
+  the generic NCR53C8XX driver and 255 for the SYM53C8XX driver.
+  
+  Modern hard disks are able to support 64 tags and even more, but 
+  do not seem to be faster when more than 32 tags are being used.
+  
+  So, the normal answer here is to go with the default value 32 unless
+  you are using very large hard disks with large cache (>= 1 MB) that
+  are able to take advantage of more than 32 tagged commands.
+
+  There is no safe option and the default answer is recommended.
+
+assume boards are SYMBIOS compatible
+CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT
+  This option allows you to enable some features depending on GPIO
+  wiring. These General Purpose Input/Output pins can be used for
+  vendor specific features or implementation of the standard SYMBIOS
+  features. Genuine SYMBIOS controllers use GPIO0 in output for
+  controller LED and GPIO3 bit as a flag indicating
+  singled-ended/differential interface. The Tekram DC-390U/F boards
+  uses a different GPIO wiring.
+  
+  Your answer to this question is ignored if all your controllers have
+  NVRAM, since the driver is able to detect the board type from the
+  NVRAM format.
+
+  If all the controllers in your system are genuine SYMBIOS boards or
+  use BIOS and drivers from SYMBIOS, you would want to say Y here,
+  otherwise N. N is the safe answer.
+
+enable profiling statistics gathering
+CONFIG_SCSI_NCR53C8XX_PROFILE
+  This option allows you to enable profiling information gathering.
+  These statistics are not very accurate due to the low frequency 
+  of the kernel clock (100 Hz on i386) and have performance impact 
+  on systems that use very fast devices.
+
+  The normal answer therefore is N.
+
+include support for the NCR PQS/PDS SCSI card
+CONFIG_SCSI_NCR53C8XX_PQS_PDS
+  Say Y here if you have a special SCSI adapter produced by NCR
+  corporation called a PCI Quad SCSI or PCI Dual SCSI. You do not need
+  this if you do not have one of these adapters. However, since this
+  device is detected as a specific PCI device, this option is quite
+  safe.
+
+  The common answer here is N, but answering Y is safe.
+
+IBMMCA SCSI support
+CONFIG_SCSI_IBMMCA
+  This is support for the IBM SCSI adapter found in many of the PS/2
+  series computers. These machines have an MCA bus, so you need to
+  answer Y to "MCA support" as well and read Documentation/mca.txt.
+
+  If the adapter isn't found during boot (a common problem for models
+  56, 57, 76, and 77) you'll need to use the 'ibmmcascsi=<pun>' kernel
+  option, where <pun> is the id of the SCSI subsystem (usually 7, but
+  if that doesn't work check your reference diskette). Owners of model
+  95 with a LED-matrix-display can in addition activate some activity
+  info like under OS/2, but more informative, by setting
+  'ibmmcascsi=display' as an additional kernel parameter. Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel. The lilo procedure is also explained in
+  the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ibmmca.o.
+
+Standard SCSI-order
+CONFIG_IBMMCA_SCSI_ORDER_STANDARD
+  In the PC-world and in most modern SCSI-BIOS-setups, SCSI-hard disks
+  are assigned to the drive letters, starting with the lowest SCSI-id
+  (physical number -- pun) to be drive C:, as seen from DOS and
+  similar operating systems. When looking into papers describing the
+  ANSI-SCSI-standard, this assignment of drives appears to be wrong.
+  The SCSI-standard follows a hardware-hierarchy which says that id 7
+  has the highest priority and id 0 the lowest. Therefore, the host
+  adapters are still today everywhere placed as SCSI-id 7 by default.
+  In the SCSI-standard, the drive letters express the priority of the
+  disk. C: should be the hard disk, or a partition on it, with the
+  highest priority. This must therefore be the disk with the highest
+  SCSI-id (e.g. 6) and not the one with the lowest! IBM-BIOS kept the
+  original definition of the SCSI-standard as also industrial- and
+  process-control-machines, like VME-CPUs running under realtime-OSs
+  (e.g. LynxOS, OS9) do.
+
+  If you like to run Linux on your MCA-machine with the same
+  assignment of hard disks as seen from e.g. DOS or OS/2 on your
+  machine, which is in addition conformant to the SCSI-standard, you
+  must say Y here. This is also necessary for MCA-Linux users who want
+  to keep downward compatibility to older releases of the
+  IBM-MCA-SCSI-driver (older than driver-release 2.00 and older than
+  June 1997).
+
+  If you like to have the lowest SCSI-id assigned as drive C:, as
+  modern SCSI-BIOSes do, which does not conform to the standard, but
+  is widespread and common in the PC-world of today, you must say N
+  here. If unsure, say Y.
+
+Reset SCSI-devices at boot time
+CONFIG_IBMMCA_SCSI_DEV_RESET
+  By default, SCSI-devices are reset when the machine is powered on.
+  However, some devices exist, like special-control-devices,
+  SCSI-CNC-machines, SCSI-printer or scanners of older type, that do
+  not reset when switched on. If you say Y here, each device connected
+  to your SCSI-bus will be issued a reset-command after it has been
+  probed, while the kernel is booting. This may cause problems with
+  more modern devices, like hard disks, which do not appreciate these
+  reset commands, and can cause your system to hang. So say Y only if
+  you know that one of your older devices needs it; N is the safe
+  answer.
+
+NCR 53C9x MCA support
+CONFIG_SCSI_MCA_53C9X
+  Some Microchannel machines, notably the NCR 35xx line, use a SCSI
+  controller based on the NCR 53C94.  This driver will allow use of
+  the controller on the 3550, and very possibly others.   
+
+  If you want to compile this as a module (= code which can be
+  inserted and removed from the running kernel whenever you want), say
+  M here and read Documentation/modules.txt. The module will be called
+  mca_53c9x.o.
+ 
+Always IN2000 SCSI support
+CONFIG_SCSI_IN2000
+  This is support for an ISA bus SCSI host adapter. You'll find more
+  information in drivers/scsi/in2000.readme. If it doesn't work out of
+  the box, you may have to change the jumpers for IRQ or address
+  selection. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called in2000.o.
+
+Initio 91XXU(W) SCSI support
+CONFIG_SCSI_INITIO
+  This is support for the Initio 91XXU(W) SCSI host adapter.
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called initio.o
+
+PAS16 SCSI support
+CONFIG_SCSI_PAS16
+  This is support for a SCSI host adapter. It is explained in section
+  3.10 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/pas16.h.
+  
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pas16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Initio INI-A100U2W SCSI support
+CONFIG_SCSI_INIA100
+  This is support for the Initio INI-A100U2W SCSI host adapter.
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be 
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called a100u2w.o
+
+PCI2000 support
+CONFIG_SCSI_PCI2000
+  This is support for the PCI2000I EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called pci2000.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PCI2220i support
+CONFIG_SCSI_PCI2220I
+  This is support for the PCI2220i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called pci2220i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PSI240i support
+CONFIG_SCSI_PSI240I
+  This is support for the PSI240i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called psi240i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Qlogic FAS SCSI support
+CONFIG_SCSI_QLOGIC_FAS
+  This is a driver for the ISA, VLB, and PCMCIA versions of the Qlogic
+  FastSCSI! cards as well as any other card based on the FASXX chip
+  (including the Control Concepts SCSI/IDE/SIO/PIO/FDC cards).
+
+  This driver does NOT support the PCI versions of these cards. The
+  PCI versions are supported by the Qlogic ISP driver ("Qlogic ISP
+  SCSI support"), below.
+
+  Information about this driver is contained in
+  drivers/scsi/README.qlogicfas. You should also read the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfas.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP SCSI support (EXPERIMENTAL)
+CONFIG_SCSI_QLOGIC_ISP
+  This driver works for all QLogic PCI SCSI host adapters (IQ-PCI,
+  IQ-PCI-10, IQ_PCI-D) except for the PCI-basic card. (This latter
+  card is supported by the "AM53/79C974 PCI SCSI" driver). 
+
+  If you say Y here, make sure to choose "BIOS" at the question "PCI
+  access mode".
+
+  Please read the file drivers/scsi/README.qlogicisp. You should also
+  read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicisp.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP FC SCSI support
+CONFIG_SCSI_QLOGIC_FC
+  This is a driver for the QLogic ISP2100 SCSI-FCP host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfc.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Compaq 64-bit / 66MHz PCI Fibre Channel Host Adapter
+CONFIG_SCSI_CPQFCTS
+  This driver supports Compaq HBA part #120186-B21, the non-
+  intelligent Tachyon TL/TS (HPFC-5166A/1.2) based adapter.
+  Kernel linked or kernel module, SMP support.  Information at
+  /proc/scsi/cpqfcTS/*
+  
+  Only supports FC-AL (non-loop mode not supported). Supports Fabric 
+  (FL_Port, public device); tested on Brocade switches.  Supports hot-
+  plug of new devices and movement of devices across ports (i.e.,
+  dynamic re-assignment of 24-bit FC port_id).
+
+  Tested on Compaq RA4x00 (f/w ver 2.40 or newer), RA8000, with Vixel
+  Rapport 1000 (7-port non-managed), Gadzoox 12-port, Gadzoox Capellix
+  3000, Brocade 2010, 2400, 2800.  Selective Storage 
+  Presentation (SSP) on RA4x00 f/w 2.54 (no redundancy).
+
+Seagate ST-02 and Future Domain TMC-8xx SCSI support
+CONFIG_SCSI_SEAGATE
+  These are 8-bit SCSI controllers; the ST-01 is also supported by
+  this driver. It is explained in section 3.9 of the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/seagate.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called seagate.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Trantor T128/T128F/T228 SCSI support
+CONFIG_SCSI_T128
+  This is support for a SCSI host adapter. It is explained in section
+  3.11 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/t128.h. Note that Trantor was purchased by Adaptec, and
+  some former Trantor products are being sold under the Adaptec name.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called t128.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UltraStor SCSI support
+CONFIG_SCSI_ULTRASTOR
+  This is support for the UltraStor 14F, 24F and 34F SCSI-2 host
+  adapter family. This driver is explained in section 3.12 of the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/ultrastor.h.
+  
+  Note that there is also another driver for the same hardware:
+  "UltraStor 14F/34F support", above.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ultrastor.o. 
+
+7000FASST SCSI support
+CONFIG_SCSI_7000FASST
+  This driver supports the Western Digital 7000 SCSI host adapter
+  family. Some information is in the source: drivers/scsi/wd7000.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called wd7000.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+ACARD SCSI support
+CONFIG_SCSI_ACARD
+  This driver supports the ACARD 870U/W SCSI host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called atp870u.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA ISA/EISA/PCI (DPT and generic EATA/DMA-compliant boards) support
+CONFIG_SCSI_EATA
+  This driver supports all EATA/DMA-compliant SCSI host adapters. DPT
+  ISA and all EISA i/o addresses are probed looking for the "EATA"
+  signature. If you chose "BIOS" at the question "PCI access mode",
+  the addresses of all the PCI SCSI controllers reported by the PCI
+  subsystem are probed as well.
+
+  You want to read the start of drivers/scsi/eata.c and the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that there is also another driver for the same hardware
+  available: "EATA-DMA support". You should say Y to only one of them.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata.o.
+
+enable tagged command queuing
+CONFIG_SCSI_EATA_TAGGED_QUEUE
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Most EATA adapters negotiate
+  this feature automatically with the device, even if your answer is
+  N. The safe answer is N.
+        
+enable elevator sorting
+CONFIG_SCSI_EATA_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_EATA_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 16
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 62. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+NCR53c406a SCSI support
+CONFIG_SCSI_NCR53C406A
+  This is support for the NCR53c406a SCSI host adapter. For user
+  configurable parameters, check out drivers/scsi/NCR53c406.c in the
+  kernel source. Also read the SCSI-HOWTO, available via FTP (user:
+  anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called NCR53c406.o.
+
+Symbios Logic sym53c416 support
+CONFIG_SCSI_SYM53C416
+  This is support for the sym53c416 SCSI host adapter, the SCSI
+  adapter that comes with some HP scanners. This driver requires that
+  the sym53c416 is configured first using some sort of pnp
+  configuration program (e.g. isapnp) or by a PnP aware BIOS. If you
+  are using isapnp then you need to compile this driver as a module
+  and then load it using insmod after isapnp has run. The parameters
+  of the configured card(s) should be passed to the driver. The format
+  is:
+
+    insmod sym53c416 sym53c416=<base>,<irq> [sym53c416_1=<base>,<irq>]
+
+  There is support for up to four adapters. If you want to compile
+  this driver as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  sym53c416.o. 
+
+Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support
+CONFIG_SCSI_DC390T
+  This driver supports PCI SCSI host adapters based on the Am53C974A
+  chip, e.g. Tekram DC390(T), DawiControl 2974 and some onboard
+  PCscsi/PCnet (Am53/79C974) solutions.
+
+  Documentation can be found in linux/drivers/scsi/README.tmscsim.
+  
+  Note that this driver does NOT support Tekram DC390W/U/F, which are
+  based on NCR/Symbios chips. Use "NCR53C8XX SCSI support" for those.
+  Also note that there is another generic Am53C974 driver,
+  "AM53/79C974 PCI SCSI support" below. You can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called tmscsim.o.
+
+Omit support for other Am53/79C974 based SCSI adapters
+CONFIG_SCSI_DC390T_NOGENSUPP
+  If you say N here, the DC390(T) SCSI driver relies on the DC390
+  EEPROM to get initial values for its settings, such as speed,
+  termination, etc. If it can't find this EEPROM, it will use defaults
+  or the user supplied boot/module parameters. For details on driver
+  configuration see linux/drivers/scsi/README.tmscsim.
+
+  If you say Y here and if no EEPROM is found, the driver gives up and
+  thus only supports Tekram DC390(T) adapters. This can be useful if
+  you have a DC390(T) and another Am53C974 based adapter, which, for
+  some reason, you want to drive with the other AM53C974 driver.
+
+  If unsure, say N.
+
+AM53/79C974 PCI SCSI support
+CONFIG_SCSI_AM53C974
+  This is support for the AM53/79C974 SCSI host adapters. Please read
+  drivers/scsi/README.AM53C974 for details. Also, the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, is for you.
+
+  Note that there is another driver for AM53C974 based adapters:
+  "Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support", above. You
+  can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called AM53C974.o.
+
+AMI MegaRAID support
+CONFIG_SCSI_MEGARAID
+  This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
+  and 467 SCSI host adapters. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called megaraid.o.
+
+###
+### What is this?
+###
+#Concurrent IO commands on MegaRAID
+#CONFIG_MEGARAID_MULTI_IO
+
+GDT SCSI Disk Array Controller support
+CONFIG_SCSI_GDTH
+  This is a driver for all SCSI Disk Array Controllers (EISA/ISA/PCI) 
+  manufactured by ICP vortex. It is documented in the kernel source in
+  drivers/scsi/gdth.c and drivers/scsi/gdth.h. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+IOMEGA parallel port (ppa - older drives)
+CONFIG_SCSI_PPA
+  This driver supports older versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say N here and Y to "IOMEGA parallel port (imm -
+  newer drives)", below.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called ppa.o. 
+
+IOMEGA parallel port (imm - newer drives)
+CONFIG_SCSI_IMM
+  This driver supports newer versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say Y here; if you have an older ZIP drive, say N
+  here and Y to "IOMEGA Parallel Port (ppa - older drives)", above.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called imm.o. 
+
+Force the Iomega ZIP drivers to use EPP-16
+CONFIG_SCSI_IZIP_EPP16
+  EPP (Enhanced Parallel Port) is a standard for parallel ports which
+  allows them to act as expansion buses that can handle up to 64
+  peripheral devices.
+
+  Some parallel port chipsets are slower than their motherboard, and
+  so we have to control the state of the chipset's FIFO queue every
+  now and then to avoid data loss. This will be done if you say Y
+  here.
+  
+  Generally, saying Y is the safe option and slows things down a bit.
+
+Assume slow parallel port control register
+CONFIG_SCSI_IZIP_SLOW_CTR
+  Some parallel ports are known to have excessive delays between
+  changing the parallel port control register and good data being
+  available on the parallel port data/status register. This option
+  forces a small delay (1.0 usec to be exact) after changing the
+  control register to let things settle out. Enabling this option may
+  result in a big drop in performance but some very old parallel ports
+  (found in 386 vintage machines) will not work properly.
+
+  Generally, saying N is fine.
+
+SCSI Debug host simulator.
+CONFIG_SCSI_DEBUG
+  This is a host adapter simulator that can be programmed to simulate
+  a large number of conditions that could occur on a real bus. The
+  advantage is that many hard to reproduce problems can be tested in a
+  controlled environment where there is reduced risk of losing
+  important data. This is primarily of use to people trying to debug
+  the middle and upper layers of the SCSI subsystem. If unsure, say N.
+
+Fibre Channel support
+CONFIG_FC4
+  This is an experimental support for storage arrays connected to
+  the system using Fibre Optic and the "X3.269-199X Fibre Channel
+  Protocol for SCSI" specification. You'll also need the generic SCSI
+  support, as well as the drivers for the storage array itself and
+  for the interface adapter such as SOC. This subsystem could even
+  serve for IP networking, with some code extensions.
+
+  If unsure, say N.
+
+Sun SOC
+CONFIG_FC4_SOC
+  Serial Optical Channel is an interface card with one or two Fibre
+  Optic ports, each of which can be connected to a disk array. Only
+  the SBus incarnation of the adapter is supported at the moment.
+
+SparcSTORAGE Array 100 and 200 series
+CONFIG_SCSI_PLUTO
+  If you never bought a disk array made by Sun, go with N. 
+
+AcornSCSI support
+CONFIG_SCSI_ACORNSCSI_3
+  This enables support for the Acorn SCSI card (aka30). If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Acorn SCSI tagged queue support
+CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE
+  Say Y here to enable tagged queuing support on the Acorn SCSI card.
+
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Some SCSI devices don't
+  implement this properly, so the safe answer is N.
+
+Acorn SCSI Synchronous transfers support
+CONFIG_SCSI_ACORNSCSI_SYNC
+  Say Y here to enable synchronous transfer negotiation with all
+  targets on the Acorn SCSI card.
+
+  In general, this improves performance; however some SCSI devices
+  don't implement it properly, so the safe answer is N.
+
+Oak SCSI support
+CONFIG_SCSI_OAK1
+  This enables support for the Oak SCSI card. If you have an Acorn
+  system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI I support
+CONFIG_SCSI_CUMANA_1
+  This enables support for the Cumana SCSI I card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI II support
+CONFIG_SCSI_CUMANA_2
+  This enables support for the Cumana SCSI II card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+EcoSCSI support
+CONFIG_SCSI_ECOSCSI
+  This enables support for the EcoSCSI card -- a small card that sits
+  in the Econet socket. If you have an Acorn system with one of these,
+  say Y. If unsure, say N.
+
+EESOX SCSI support
+CONFIG_SCSI_EESOXSCSI
+  This enables support for the EESOX SCSI card. If you have an Acorn
+  system with one of these, say Y, otherwise say N.
+
+Powertec SCSI support
+CONFIG_SCSI_POWERTECSCSI
+  This enables support for the Powertec SCSI card on Acorn systems. If
+  you have one of these, say Y. If unsure, say N.
+
+Network device support?
+CONFIG_NETDEVICES
+  You can say N here if you don't intend to connect your Linux box to
+  any other computer at all or if all your connections will be over a
+  telephone line with a modem either via UUCP (UUCP is a protocol to
+  forward mail and news between unix hosts over telephone lines; read
+  the UUCP-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO) or dialing up a shell
+  account or a BBS, even using term (term is a program which gives you
+  almost full Internet connectivity if you have a regular dial up
+  shell account on some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)).
+
+  You'll have to say Y if your computer contains a network card that
+  you want to use under Linux (make sure you know its name because you
+  will be asked for it and read the Ethernet-HOWTO (especially if you
+  plan to use more than one network card under Linux), available from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini) or if you want to
+  use SLIP (Serial Line Internet Protocol is the protocol used to send
+  Internet traffic over telephone lines or null modem cables) or CSLIP
+  (compressed SLIP) or PPP (Point to Point Protocol, a better and
+  newer replacement for SLIP) or PLIP (Parallel Line Internet Protocol
+  is mainly used to create a mini network by connecting the parallel
+  ports of two local machines) or AX.25/KISS (protocol for sending
+  Internet traffic over amateur radio links).
+
+  Make sure to read the NET-3-HOWTO. Eventually, you will have to read
+  Olaf Kirch's excellent and free book "Network Administrator's
+  Guide", to be found in ftp://metalab.unc.edu/pub/Linux/docs/LDP. If
+  unsure, say Y.
+
+Dummy net driver support
+CONFIG_DUMMY
+  This is essentially a bit-bucket device (i.e. traffic you send to
+  this device is consigned into oblivion) with a configurable IP
+  address. It is most commonly used in order to make your currently
+  inactive SLIP address seem like a real address for local programs.
+  If you use SLIP or PPP, you might want to say Y here. Read about it
+  in the Network Administrator's Guide, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/LDP. Since this
+  thing often comes in handy, the default is Y. It won't enlarge your
+  kernel either. What a deal.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called dummy.o. If you want to use more than one dummy device at a
+  time, you need to compile this driver as a module. Instead of
+  'dummy', the devices will then be called 'dummy0', 'dummy1' etc.
+
+SLIP (serial line) support
+CONFIG_SLIP
+  Say Y if you intend to use SLIP or CSLIP (compressed SLIP) to
+  connect to your Internet service provider or to connect to some
+  other local Unix box or if you want to configure your Linux box as a
+  Slip/CSlip server for other people to dial in. SLIP (Serial Line
+  Internet Protocol) is a protocol used to send Internet traffic over
+  serial connections such as telephone lines or null modem cables;
+  nowadays, the protocol PPP is more commonly used for this same
+  purpose.
+
+  Normally, your access provider has to support SLIP in order for you
+  to be able to use it, but there is now a SLIP emulator called SLiRP
+  around (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ) which
+  allows you to use SLIP over a regular dial up shell connection. If
+  you plan to use SLiRP, make sure to say Y to CSLIP, below. The
+  NET-3-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, explains how to
+  configure SLIP. Note that you don't need this option if you just
+  want to run term (term is a program which gives you almost full
+  Internet connectivity if you have a regular dial up shell account on
+  some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)). SLIP support will enlarge
+  your kernel by about 4 KB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  slip.o.
+
+CSLIP compressed headers
+CONFIG_SLIP_COMPRESSED
+  This protocol is faster than SLIP because it uses compression on the
+  TCP/IP headers (not on the data itself), but it has to be supported
+  on both ends. Ask your access provider if you are not sure and
+  answer Y, just in case. You will still be able to use plain SLIP. If
+  you plan to use SLiRP, the SLIP emulator (available via FTP (user:
+  anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/) which allows
+  you to use SLIP over a regular dial up shell connection, you
+  definitely want to say Y here. The NET-3-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO,
+  explains how to configure CSLIP. This won't enlarge your kernel.
+
+Keepalive and linefill
+CONFIG_SLIP_SMART
+  Adds additional capabilities to the SLIP driver to support the
+  RELCOM line fill and keepalive monitoring. Ideal on poor quality
+  analogue lines.
+
+Six bit SLIP encapsulation
+CONFIG_SLIP_MODE_SLIP6
+  Just occasionally you may need to run IP over hostile serial
+  networks that don't pass all control characters or are only seven
+  bit. Saying Y here adds an extra mode you can use with SLIP:
+  "slip6". In this mode, SLIP will only send normal ASCII symbols over
+  the serial device. Naturally, this has to be supported at the other
+  end of the link as well. It's good enough, for example, to run IP
+  over the async ports of a Camtec JNT Pad. If unsure, say N.
+
+PPP (point-to-point) support
+CONFIG_PPP
+  PPP (Point to Point Protocol) is a newer and better SLIP. It serves
+  the same purpose: sending Internet traffic over telephone (and other
+  serial) lines. Ask your access provider if they support it, because
+  otherwise you can't use it (not quite true any more: the free
+  program SLiRP can emulate a PPP line if you just have a regular dial
+  up shell account on some UNIX computer; get it via FTP (user:
+  anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/). Note that
+  you don't need "PPP support" if you just want to run term (term is a
+  program which gives you almost full Internet connectivity if you
+  have a regular dial up shell account on some Internet connected UNIX
+  computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)).
+
+  To use PPP, you need an additional program called pppd as described
+  in Documentation/networking/ppp.txt and in the PPP-HOWTO, available
+  from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you upgrade
+  from an older kernel, you might need to upgrade pppd as well. The
+  PPP option enlarges your kernel by about 16 KB.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you said Y to "Version information on all symbols" above, then
+  you cannot compile the PPP driver into the kernel; you can then only
+  compile it as a module. The module will be called ppp.o. If you want
+  to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. Note that, no matter what
+  you do, the BSD compression code (used to compress the IP packets
+  sent over the serial line; has to be supported at the other end as
+  well) will always be compiled as a module; it is called bsd_comp.o
+  and will show up in the directory modules once you have said "make
+  modules". If unsure, say N.
+
+Wireless LAN (non-hamradio)
+CONFIG_NET_RADIO
+  Support for wireless LANs and everything having to do with radio,
+  but not with amateur radio. Note that the answer to this question
+  won't directly affect the kernel: saying N will just cause this
+  configure script to skip all the questions about radio
+  interfaces. 
+
+  Some user-level drivers for scarab devices which don't require
+  special kernel support are available via FTP (user: anonymous) from
+  ftp://shadow.cabi.net/pub/Linux.
+
+STRIP (Metricom Starmode radio IP)
+CONFIG_STRIP
+  Say Y if you have a Metricom radio and intend to use Starmode Radio
+  IP. STRIP is a radio protocol developed for the MosquitoNet project
+  (On the WWW at http://mosquitonet.stanford.edu/; to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) to send Internet traffic using
+  Metricom radios. Metricom radios are small, battery powered,
+  100kbit/sec packet radio transceivers, about the size and weight of
+  a cellular telephone. (You may also have heard them called
+  "Metricom modems" but we avoid the term "modem" because it misleads
+  many people into thinking that you can plug a Metricom modem into a
+  phone line and use it as a modem.)  
+
+  You can use STRIP on any Linux machine with a serial port, although
+  it is obviously most useful for people with laptop computers. If you
+  think you might get a Metricom radio in the future, there is no harm
+  in saying Y to STRIP now, except that it makes the kernel a bit
+  bigger. 
+
+  You can also compile this as a module ( = code which can be inserted
+  in and removed from the running kernel whenever you want), say M
+  here and read Documentation/modules.txt. The module will be called
+  strip.o.
+
+AT&T WaveLAN & DEC RoamAbout DS support
+CONFIG_WAVELAN
+  The Lucent WaveLAN (formerly NCR and AT&T; or DEC RoamAbout DS) is
+  a Radio LAN (wireless Ethernet-like Local Area Network) using the
+  radio frequencies 900 MHz and 2.4 GHz.
+  
+  This driver support the ISA version of the WaveLAN card. A separate
+  driver for the PCMCIA (PC-card) hardware is available in David
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for
+  location).
+
+  If you want to use an ISA WaveLAN card under Linux, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Some more specific
+  information is contained in Documentation/networking/wavelan.txt and
+  in the source code drivers/net/wavelan.p.h.
+
+  You will also need the wireless tools package available from
+  ftp://ftp.inka.de/pub/comp/Linux/networking/NetTools/contrib/.
+  Please read the man pages contained therein.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wavelan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Aironet Arlan 655 & IC2200 DS support
+CONFIG_ARLAN
+  Aironet makes Arlan. www.aironet.com. Uses www.Telxon.com chip, which is
+  used on several similar cards. Driver is tested on 655 and IC2200 series. 
+  Look for http://www.ylenurme.ee/~elmer/655/ for latest information. 
+  Driver is build as two modules, arlan and arlan-proc. The later is /proc
+  interface and not needed most of time.
+  On some computers the card ends up in non-valid state after some time.
+  Use a ping-reset script to clear it.
+   
+
+LAPB over Ethernet driver
+CONFIG_LAPBETHER
+  This is a driver for a pseudo device (typically called /dev/lapb0)
+  which allows you to open an LAPB point-to-point connection to some
+  other computer on your Ethernet network. In order to do this, you
+  need to say Y or M to the driver for your Ethernet card as well as
+  to "LAPB Data Link Driver". 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called lapbether.o. If unsure, say N.
+
+X.25 async driver
+CONFIG_X25_ASY
+  This is a driver for sending and receiving X.25 frames over regular
+  asynchronous serial lines such as telephone lines equipped with
+  ordinary modems. Experts should note that this driver doesn't
+  currently comply with the asynchronous HDLS framing protocols in
+  CCITT recommendation X.25. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25_asy.o. If unsure, say N.
+
+Shortwave radio modem driver
+CONFIG_HFMODEM
+  This experimental driver is used by a package (to be released)
+  that implements the shortwave radio protocols RTTY, Sitor (Amtor),
+  Pactor 1 and GTOR using a standard PC sound card. If unsure,
+  say N.
+
+Shortwave radio modem driver support for Sound Blaster and compatible cards
+CONFIG_HFMODEM_SBC
+  This option enables the hfmodem driver to use Sound Blaster and
+  compatible cards. It requires a 16bit capable card, i.e.
+  SB16 or better, or ESS1688 or newer.
+
+Shortwave radio modem driver support for WSS and Crystal cards
+CONFIG_HFMODEM_WSS
+  This option enables the hfmodem driver to use WindowsSoundSystem
+  compatible cards. These cards feature a codec chip from either
+  Analog Devices (such as AD1848, AD1845) or Crystal Semiconductors
+  (such as CS4248, CS423x).
+
+PLIP (parallel port) support
+CONFIG_PLIP
+  PLIP (Parallel Line Internet Protocol) is used to create a
+  reasonably fast mini network consisting of two (or, rarely, more)
+  local machines. A PLIP link from a Linux box is a popular means to
+  install a Linux distribution on a machine which doesn't have a CDROM
+  drive (a minimal system has to be transferred with floppies first).
+  The kernels on both machines need to have this PLIP option enabled
+  for this to work.
+
+  The PLIP driver has two modes, mode 0 and mode 1. The parallel ports
+  (the connectors at the computers with 25 holes) are connected with
+  "null printer" or "Turbo Laplink" cables which can transmit 4 bits
+  at a time (mode 0) or with special PLIP cables, to be used on
+  bidirectional parallel ports only, which can transmit 8 bits at a
+  time (mode 1); you can find the wiring of these cables in
+  Documentation/networking/PLIP.txt. The cables can be up to 15m long.
+  Mode 0 works also if one of the machines runs DOS/Windows and has
+  some PLIP software installed, e.g. the Crynwr PLIP packet driver
+  (http://oak.oakland.edu/simtel.net/msdos/pktdrvr-pre.html; to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape) and winsock or NCSA's telnet.
+
+  If you want to use PLIP, say Y and read the PLIP mini-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini as well as the
+  NET-3-HOWTO in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that
+  the PLIP protocol was changed and this PLIP driver won't work
+  together with the PLIP support in Linux versions 1.0.x. This option
+  enlarges your kernel by about 8 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  plip.o. If unsure, say Y or M, in case you buy a laptop later.
+
+EQL (serial line load balancing) support
+CONFIG_EQUALIZER
+  If you have two serial connections to some other computer (this
+  usually requires two modems and two telephone lines) and you use
+  SLIP (the protocol for sending Internet traffic over telephone
+  lines) or PPP (a better SLIP) on them, you can make them behave like
+  one double speed connection using this driver. Naturally, this has
+  to be supported at the other end as well, either with a similar EQL
+  Linux driver or with a Livingston Portmaster 2e. 
+
+  Say Y if you want this and read Documentation/networking/eql.txt.
+  You may also want to read section 6.2 of the NET-3-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eql.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Ethertap network tap
+CONFIG_ETHERTAP
+  If you say Y here (and have said Y to "Kernel/User network link
+  driver", above) and create a character special file /dev/tap0 with
+  major number 36 and minor number 16 using mknod ("man mknod"), you
+  will be able to have a user space program read and write raw
+  Ethernet frames from/to that special file. tap0 can be configured
+  with ifconfig and route like any other Ethernet device but it is not
+  connected to any physical LAN; everything written by the user to
+  /dev/tap0 is treated by the kernel as if it had come in from a LAN
+  to the device tap0; everything the kernel wants to send out over the
+  device tap0 can instead be read by the user from /dev/tap0: the user
+  mode program replaces the LAN that would be attached to an ordinary
+  Ethernet device. Please read the file
+  Documentation/networking/ethertap.txt for more information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ethertap.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If you don't
+  know what to use this for, you don't need it.
+
+Sealevel Systems 4021 support
+CONFIG_SEALEVEL_4021
+  This is a driver for the Sealevel Systems ACB 56 serial I/O adapter.
+  
+  This driver can only be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to do that, say M here. The module will be called
+  sealevel.o.
+
+SyncLink HDLC/SYNCPPP support
+CONFIG_SYNCLINK_SYNCPPP
+  Enables HDLC/SYNCPPP support for the SyncLink WAN driver.
+  Normally the SyncLink WAN driver works with the main PPP
+  driver (ppp.c) and pppd program. HDLC/SYNCPPP support allows use
+  of the Cisco HDLC/PPP driver (syncppp.c).
+  The SyncLink WAN driver (in character devices) must also be enabled.
+
+Frame Relay (DLCI) support
+CONFIG_DLCI
+  This is support for the frame relay protocol; frame relay is a fast
+  low-cost way to connect to a remote Internet access provider or to
+  form a private wide area network. The one physical line from your
+  box to the local "switch" (i.e. the entry point to the frame relay
+  network, usually at the phone company) can carry several logical
+  point-to-point connections to other computers connected to the frame
+  relay network. For a general explanation of the protocol, check out
+  http://www.frforum.com/ on the WWW. (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape.) To use frame relay, you need supporting hardware
+  (called FRAD) and certain programs from the net-tools package as
+  explained in Documentation/networking/framerelay.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dlci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Max open DLCI
+CONFIG_DLCI_COUNT
+  This is the maximal number of logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) that
+  the driver can handle. The default is probably fine.
+
+Max DLCI per device
+CONFIG_DLCI_MAX
+  You can specify here how many logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) should be
+  handled by each of your hardware frame relay access devices. Go with
+  the default.
+
+Sangoma S502A FRAD support
+CONFIG_SDLA
+  Say Y here if you need a driver for the Sangoma S502A, S502E, and
+  S508 Frame Relay Access Devices. These are multi-protocol cards, but
+  only frame relay is supported by the driver at this time. Please
+  read Documentation/framerelay.txt. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sdla.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Acorn Econet/AUN protocols (EXPERIMENTAL)
+CONFIG_ECONET
+  Econet is a fairly old and slow networking protocol mainly used by
+  Acorn computers to access file and print servers. It uses native
+  Econet network cards. AUN is an implementation of the higher level
+  parts of Econet that runs over ordinary Ethernet connections, on
+  top of the UDP packet protocol, which in turn runs on top of the
+  Internet protocol IP.
+
+  If you say Y here, you can choose with the next two options whether
+  to send Econet/AUN traffic over a UDP Ethernet connection or over
+  a native Econet network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called econet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AUN over UDP
+CONFIG_ECONET_AUNUDP
+  Say Y here if you want to send Econet/AUN traffic over a UDP
+  connection (UDP is a packet based protocol that runs on top of the
+  Internet protocol IP) using an ordinary Ethernet network card.
+
+Native Econet
+CONFIG_ECONET_NATIVE
+  Say Y here if you have a native Econet network card installed in
+  your computer.
+
+WAN Router
+CONFIG_WAN_ROUTER
+  Wide Area Networks (WANs), such as X.25, frame relay and leased
+  lines, are used to interconnect Local Area Networks (LANs) over vast
+  distances with data transfer rates significantly higher than those
+  achievable with commonly used asynchronous modem connections.
+  Usually, a quite expensive external device called a `WAN router' is
+  needed to connect to a WAN.
+
+  As an alternative, WAN routing can be built into the Linux kernel.
+  With relatively inexpensive WAN interface cards available on the
+  market, a perfectly usable router can be built for less than half
+  the price of an external router. If you have one of those cards and
+  wish to use your Linux box as a WAN router, say Y here and also to
+  the WAN driver for your card, below. You will then need the
+  wan-tools package which is available via FTP (user: anonymous) from
+  ftp://ftp.sangoma.com. Read Documentation/networking/wan-router.txt
+  for more information.
+
+  The WAN routing support is only available as a module called
+  wanrouter.o ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Fast switching (read help!)
+CONFIG_NET_FASTROUTE
+  Saying Y here enables direct NIC-to-NIC (NIC = Network Interface
+  Card) data transfers, which is fast.
+
+    *** This option is NOT COMPATIBLE with several important ***
+    *** networking options: especially CONFIG*FIREWALL.      ***
+    *** Say N here if you intend to use Linux as a firewall. ***
+
+  However, it will work with all options in CONFIG_IP_ADVANCED_ROUTER
+  section (except for CONFIG_IP_ROUTE_TOS and CONFIG_IP_ROUTE_FWMARK).
+  At the moment, few devices support fast switching (tulip is one of
+  them, modified 8390 can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz).
+
+  If unsure, say N.
+
+
+Forwarding between high speed interfaces
+CONFIG_NET_HW_FLOWCONTROL
+  This option enables NIC (Network Interface Card) hardware throttling
+  during periods of extremal congestion. At the moment only a couple
+  of device drivers support it (really only one -- tulip, modified
+  8390 can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz).
+  Really, this option is applicable to any machine attached to a fast enough
+  network, and even a 10 Mb NIC is able to kill a not very slow box,
+  such as a 120MHz Pentium.
+
+  However, do not say Y here if you did not experience any serious
+  problems.
+
+CPU is too slow to handle full bandwidth
+CONFIG_CPU_IS_SLOW
+  If you suspect that your CPU is not fast enough to handle the
+  full bandwidth of your network connection, try saying Y here. If
+  unsure, say N.
+
+QoS and/or fair queueing
+CONFIG_NET_SCHED
+  When the kernel has several packets to send out over the network
+  devices, it has to make a decision which one to send first. This is
+  especially important if some of the network devices are real time
+  devices that need a certain minimum data flow rate. There are
+  several different algorithms for how to do this "fairly"; they are
+  called packet schedulers. If you want to stick to the default
+  scheduling algorithm, say N here. If you want to experiment with a
+  couple of different algorithms, say Y. You can then attach different
+  schedulers to different network devices. Currently, this is only
+  recommended for experts.
+
+  To administer these schedulers, you'll need the user-level utilities
+  from the package iproute2+tc at ftp://ftp.inr.ac.ru/ip-routing/
+
+  If you say Y here and to "/proc filesystem" below, you will be able
+  to read status information about priority schedulers from the file
+  /proc/net/psched.
+  
+  The available schedulers are listed in the following questions; you
+  can say Y to as many as you like. If unsure, say N now.
+
+CBQ packet scheduler
+CONFIG_NET_SCH_CBQ
+  Say Y here if you want to use the Class-Based Queueing (CBQ) packet
+  scheduling algorithm for some of your network devices. This
+  algorithm classifies the waiting packets into a tree-like hierarchy
+  of classes; the leaves of this tree are in turn scheduled by
+  separate algorithms (called "disciplines" in this context) which you
+  can choose below from among the various queueing algorithms. See the
+  top of net/sched/sch_cbq.c for references about the CBQ algorithm.
+
+  This code is also available as a module called sch_cbq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+CSZ packet scheduler
+CONFIG_NET_SCH_CSZ
+  Say Y here if you want to use the Clark-Shenker-Zhang (CSZ) packet
+  scheduling algorithm for some of your network devices. At the
+  moment, this is the only algorithm that can guarantee service for
+  real-time applications (see the top of net/sched/sch_csz.c for
+  details and references about the algorithm). 
+  
+  Note: this scheduler is currently broken.
+
+  This code is also available as a module called sch_csz.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+The simplest PRIO pseudo scheduler
+CONFIG_NET_SCH_PRIO
+  Say Y here if you want to use an n-band priority queue packet
+  "scheduler" for some of your network devices or as a leaf discipline
+  for the CBQ scheduling algorithm. 
+
+  This code is also available as a module called sch_prio.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+RED queue
+CONFIG_NET_SCH_RED
+  Say Y here if you want to use the Random Early Detection (RED)
+  packet scheduling algorithm for some of your network devices (see
+  the top of net/sched/sch_red.c for details and references about the
+  algorithm). 
+
+  This code is also available as a module called sch_red.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SFQ queue
+CONFIG_NET_SCH_SFQ
+  Say Y here if you want to use the Stochastic Fairness Queueing (SFQ)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_sfq.c for details and references about the SFQ
+  algorithm). 
+
+  This code is also available as a module called sch_sfq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TEQL queue
+CONFIG_NET_SCH_TEQL
+  Say Y here if you want to use the True Link Equalizer (TLE) packet
+  scheduling algorithm for some of your network devices or as a leaf
+  discipline for the CBQ scheduling algorithm. This queueing
+  discipline allows the combination of several physical devices into
+  one virtual device. (see the top of net/sched/sch_teql.c for
+  details).
+
+  This code is also available as a module called sch_teql.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TBF queue
+CONFIG_NET_SCH_TBF
+  Say Y here if you want to use the Simple Token Bucket Filter (TBF)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_tbf.c for a description of the TBF algorithm). 
+
+  This code is also available as a module called sch_tbf.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+QoS support
+CONFIG_NET_QOS
+  Say Y here if you want to include Quality Of Service scheduling
+  features, which means that you will be able to request certain
+  rate-of-flow limits for your net devices.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about QoS support.
+
+Rate estimator
+CONFIG_NET_ESTIMATOR
+  In order for Quality of Service scheduling to work, the current
+  rate-of-flow for a network device has to be estimated; if you say Y
+  here, the kernel will do just that.
+
+Packet classifier API
+CONFIG_NET_CLS
+  The CBQ scheduling algorithm requires that network packets which are
+  scheduled to be sent out over a network device be classified in some
+  way. If you say Y here, you will get a choice of several different
+  packet classifiers with the following questions. 
+#
+# Routing tables based classifier
+# CONFIG_NET_CLS_ROUTE
+#
+# Firewall based classifier
+# CONFIG_NET_CLS_FW
+#
+# U32 classifier
+# CONFIG_NET_CLS_U32
+#
+# Special RSVP classifier
+# CONFIG_NET_CLS_RSVP
+#
+# Special RSVP classifier for IPv6
+# CONFIG_NET_CLS_RSVP6
+#
+# Ingres traffic policing
+# CONFIG_NET_CLS_POLICE
+###
+### Some expert please fill these in
+###
+
+Network code profiler
+CONFIG_NET_PROFILE
+  If you say Y here and to "/proc filesystem support" below, some
+  obscure and undocumented information about the network code's
+  performance will be written to /proc/net/profile. If you don't know
+  what it is about, you don't need it: say N.
+
+Comtrol Hostess SV-11 support
+CONFIG_HOSTESS_SV11
+  This is a network card for low speed synchronous serial links, at
+  up to 256Kbps. It supports both PPP and Cisco HDLC.
+  
+  At this point, the driver can only be compiled as a module.
+
+COSA/SRP sync serial boards support
+CONFIG_COSA
+  This is a driver for COSA and SRP synchronous serial boards. These
+  boards allow to connect synchronous serial devices (for example
+  base-band modems, or any other device with the X.21, V.24, V.35 or
+  V.36 interface) to your Linux box. The cards can work as the
+  character device, synchronous PPP network device, or the Cisco HDLC
+  network device.
+
+  To actually use the COSA or SRP board, you will need user-space
+  utilities for downloading the firmware to the cards and to set them
+  up. Look at the http://www.fi.muni.cz/~kas/cosa/ for more
+  information about the cards (including the pointer to the user-space
+  utilities). You can also read the comment at the top of the
+  drivers/net/cosa.c for details about the cards and the driver
+  itself.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cosa.o. For general information about
+  modules read Documentation/modules.txt.
+
+Lan Media sync serial boards support
+CONFIG_LANMEDIA
+  This is a driver for the following Lan Media family of serial boards.
+
+  LMC 1000 board allows you to connect synchronous serial devices (for
+  example base-band modems, or any other device with the X.21, V.24,
+  V.35 or V.36 interface) to your Linux box. 
+
+  LMC 1200 with on board DSU board allows you to connect your Linux
+  box dirrectly to a T1 or E1 circuit. 
+
+  LMC 5200 board provides a HSSI interface capable of runnig up to
+  52 mbits per second.
+
+  LMC 5245 board connects directly to a T3 circuit saving the
+  additional external hardware.
+
+  To change setting such as syncPPP vs cisco HDLC or clock source you
+  will need lmcctl.  It it available at ftp.lanmedia.com.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lmc.o. For general information about
+  modules read Documentation/modules.txt.
+
+Red Creek Hardware VPN (EXPERIMENTAL)
+CONFIG_RCPCI
+  This is a driver for hardware which provides a Virtual Private
+  Network (VPN). Say Y if you have it.
+
+  This code is also available as a module called rcpci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+  
+SBNI Leased Line Adapters
+CONFIG_SBNI
+  This is a driver for ISA SBNI12-xx cards that is a low cost
+  alternative to leased line modems. Say Y if you want to insert
+  driver into kernel or say M to compile driver as a module. 
+  
+  You can find more information and last versions of drivers and 
+  utilities at http://www.granch.ru. If you have any question you
+  can mail to sbni@granch.ru.
+  
+  Say N if unsure.
+  
+WAN Drivers
+CONFIG_WAN_DRIVERS
+  Say Y to this option if your Linux box contains a WAN card and you
+  are planning to use the box as a WAN ( = Wide Area Network) router 
+  ( = device used to interconnect local area networks over wide area
+  communication links, such as leased lines or public data networks,
+  e.g. X.25 or frame relay) and you will be offered a list of drivers
+  for WAN cards currently available. For more information, read
+  Documentation/networking/wan-router.txt.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about WAN card drivers. If unsure, say N.
+
+Sangoma WANPIPE(tm) multiprotocol cards
+CONFIG_VENDOR_SANGOMA
+  WANPIPE from Sangoma Technologies Inc. (http://www.sangoma.com; to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape) is a family of intelligent
+  multiprotocol WAN adapters with data transfer rates up to T1 (1.544
+  Mbps). They are also known as Synchronous Data Link Adapters (SDLA)
+  and designated S503 or S508. These cards support the X.25, Frame
+  Relay, PPP, Cisco HDLC protocols. The driver also offers API support
+  for protocols like HDLC (LAPB), HDLC Streaming and BiSync. 
+
+  If you have one or more of these cards, say M to this option; you
+  may then also want to read the file
+  Documentation/networking/wanpipe.txt. The next questions will ask
+  you about the protocols you want the driver to support.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wanpipe.o. For general information about
+  modules read Documentation/modules.txt.
+
+Maximum number of cards
+CONFIG_WANPIPE_CARDS
+  Enter number of WANPIPE adapters installed in your machine. The
+  driver can support up to 8 cards. You may enter more than you
+  actually have if you plan to add more cards in the future without
+  re-compiling the driver, but remember that in this case you'll waste
+  some kernel memory (about 1K per card).
+
+WANPIPE X.25 support
+CONFIG_WANPIPE_X25
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to an X.25 network. If you say N, the X.25 support will not be
+  included in the driver. The X.25 option is ONLY supported on S508
+  cards.
+
+WANPIPE Frame Relay support
+CONFIG_WANPIPE_FR
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a frame relay network. If you say N, the frame relay support will
+  not be included in the driver. The Frame Relay option is ONLY
+  supported on S508 cards.
+
+WANPIPE PPP support
+CONFIG_WANPIPE_PPP
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a leased line using Point-to-Point protocol (PPP). If you say N,
+  the PPP support will not be included in the driver. The PPP option
+  is ONLY supported on S508 cards.
+
+WANPIPE Cisco HDLC support
+CONFIG_WANPIPE_CHDLC
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a leased line using the Cisco HDLC protocol. This now supports
+  Dual Port Cisco HDLC on the S508 card ONLY. This support also allows
+  user to build applications using the HDLC streaming API. If you say
+  N, the Cisco HDLC support and HDLC streaming API will not be
+  included in the driver.
+
+MultiGate/COMX support
+CONFIG_COMX
+  Say Y if you want to use any board from the MultiGate (COMX) family. 
+  These boards are synchronous serial adapters for the PC, manufactured 
+  by ITConsult-Pro Co, Hungary. 
+
+  Read linux/Documentation/networking/comx.txt  for help on configuring 
+  and using COMX interfaces. Further info on these cards can be found at 
+  http://www.itc.hu or <info@itc.hu>.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx.o.
+
+COMX/CMX/HiCOMX board support
+CONFIG_COMX_HW_COMX
+  Hardware driver for the 'CMX', 'COMX' and 'HiCOMX' boards from the
+  MultiGate family. Say Y if you have one of these. 
+
+  You will need additional firmware to use these cards, which are
+  downloadable from ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-comx.o.
+
+LoCOMX board support
+CONFIG_COMX_HW_LOCOMX
+  Hardware driver for the 'LoCOMX' board from the MultiGate family. Say Y
+  if you have a board like this. 
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-locomx.o.
+
+MixCOM board support
+CONFIG_COMX_HW_MIXCOM
+  Hardware driver for the 'MixCOM' board from the MultiGate family. Say Y
+  if you have a board like this.
+
+  If you want to use the watchdog device on this card, you should
+  select it in the Watchdog Cards section of the Character Devices
+  configuration. The ISDN interface of this card is Teles 16.3 compatible,
+  you should enable it in the ISDN configuration menu. The driver for the 
+  flash ROM of this card is available separately on ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-mixcom.o.
+
+MultiGate Cisco-HDLC and synchronous PPP protocol support
+CONFIG_COMX_PROTO_PPP
+  Cisco-HDLC and synchronous PPP protocol driver for all MultiGate boards. 
+  Say Y if you want to use either protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called 
+  comx-proto-ppp.o.
+
+MultiGate LAPB protocol support
+CONFIG_COMX_PROTO_LAPB
+  LAPB protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-proto-lapb.o.
+
+MultiGate Frame Relay protocol support
+CONFIG_COMX_PROTO_FR
+  Frame Relay protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-proto-fr.o.
+
+Xpeed DSL NIC support
+CONFIG_XPEED
+  This driver supports Xpeed Inc. PCI network cards.
+  The following cards are supported with this driver:
+
+  Xpeed X200 IDSL NIC (http://www.xpeed.com/Products/x200/x200_c.html)
+  Xpeed X300 SDSL NIC (http://www.xpeed.com/Products/x300/x300_c.html)
+
+  This driver handles frame relay encapsulation of WAN link and presents
+  the card to the kernel as an ethernet-like device called dsl0, dsl1, etc.
+
+  Currently the driver only functions as a module. Detailed configuration
+  information can be found in Documentation/networking/README.xpeed
+
+Generic HDLC driver
+CONFIG_HDLC
+  Say Y to this option if your Linux box contains a WAN card supported
+  by this driver and you are planning to connect the box to a WAN
+  ( = Wide Area Network). You will need supporting software from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+
+  If unsure, say N here.
+
+SDL RISCom/N2 driver
+CONFIG_N2
+  This driver is for RISCom/N2 single or dual channel ISA cards
+  made by SDL Communications Inc.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+  Note that N2csu and N2dds cards are not supported by this driver.
+
+  If unsure, say N here.
+
+Moxa C101 driver
+CONFIG_C101
+  This driver is for C101 SuperSync ISA cards made by Moxa
+  Technologies Co., Ltd.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+
+  If unsure, say N here.
+
+SBE wanXL driver
+CONFIG_WANXL
+  This driver is for wanXL PCI cards made by SBE Inc.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/ and a firmware available
+  from SBE Inc.
+
+  If unsure, say N here.
+
+Cyclades-PC300 support
+CONFIG_PC300
+  This is a driver for the Cyclades-PC300 synchronous communication
+  boards. These boards provide synchronous serial interfaces to your
+  Linux box. All protocols supported by the HDLC generic driver
+  (currently synchronous PPP, Cisco HDLC and Frame Relay) are available
+  by default. If you wish to support other protocols, please select one
+  of the available options below this one.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pc300.o.
+
+  If unsure, say N here.
+
+Cyclades-PC300 X.25 Support
+CONFIG_PC300_X25
+  Say Y to this option if you intend to use the Cyclades-PC300 to
+  provide X.25 interfaces to your Linux box.
+
+  IMPORTANT: Additional X.25 support must be enabled in the kernel
+  for this support to be functional (say Y to "CCITT X.25 Packet Layer"
+  and "LAPB Data Link Driver", in the "Networking Options"
+  configuration section).
+
+  If unsure, say N here.
+
+Ethernet (10 or 100Mbit)
+CONFIG_NET_ETHERNET
+  Ethernet (also called IEEE 802.3 or ISO 8802-2) is the most common
+  type of Local Area Network (LAN) in universities and companies.
+
+  Common varieties of Ethernet are: 10BASE-2 or Thinnet (10 Mbps over
+  coaxial cable, linking computers in a chain), 10BASE-T or twisted
+  pair (10 Mbps over twisted pair cable, linking computers to central
+  hubs), 10BASE-F (10 Mbps over optical fiber links, using hubs),
+  100BASE-TX (100 Mbps over two twisted pair cables, using hubs),
+  100BASE-T4 (100 Mbps over 4 standard voice-grade twisted pair
+  cables, using hubs), 100BASE-FX (100 Mbps over optical fiber links)
+  [the 100BASE varieties are also known as Fast Ethernet], and Gigabit
+  Ethernet (1 Gbps over optical fiber or short copper links).
+
+  If your Linux machine will be connected to an Ethernet and you have
+  an Ethernet network interface card (NIC) installed in your computer,
+  say Y here and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You will
+  then also have to say Y to the driver for your particular NIC.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Ethernet network cards. If unsure, say N.
+
+Sun LANCE Ethernet support
+CONFIG_SUN_LANCE
+  This is support for lance Ethernet cards on Sun workstations such as
+  the SPARCstation IPC (any SPARC with a network interface 'le0' under
+  SunOS basically). 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lance.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sun Intel Ethernet support
+CONFIG_SUN_INTEL
+  This is support for the Intel Ethernet cards on some Sun
+  workstations (all those with a network interface 'ie0' under SunOS).
+
+Western Digital/SMC cards
+CONFIG_NET_VENDOR_SMC
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Western Digital cards. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+WD80*3 support
+CONFIG_WD80x3
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra MCA support
+CONFIG_ULTRAMCA
+  If you have a network (Ethernet) card of this type and are running
+  an MCA based system (PS/2), say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-mca.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra support
+CONFIG_ULTRA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+  
+  Important: There have been many reports that, with some motherboards
+  mixing an SMC Ultra and an Adaptec AHA154x SCSI card (or compatible,
+  such as some BusLogic models) causes corruption problems with many
+  operating systems. The Linux smc-ultra driver has a work-around for
+  this but keep it in mind if you have such a SCSI card and have
+  problems.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+SMC Ultra32 EISA support
+CONFIG_ULTRA32
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra32.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt as well
+  as Documentation/networking/net-modules.txt.
+
+SMC 9194 Support
+CONFIG_SMC9194
+  This is support for the SMC9xxx based Ethernet cards. Choose this
+  option if you have a DELL laptop with the docking station, or
+  another SMC9192/9194 based chipset. Say Y if you want it compiled
+  into the kernel, and read the file
+  Documentation/networking/smc9.txt and the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called smc9194.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+PCI NE2000 support
+CONFIG_NE2K_PCI
+  This driver is for NE2000 compatible PCI cards. It will not work
+  with ISA NE2000 cards (they have their own driver, "NE2000/NE1000
+  support" below). If you have a PCI NE2000 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2k-pci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+PCI DM9102 support
+CONFIG_DM9102
+  This driver is for DM9102 compatible PCI cards from Davicom 
+  (http://www.davicom.com.tw) 
+  If you have a PCI DM9102 network (Ethernet) card, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dmfe.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan (Micom) NI cards
+CONFIG_NET_VENDOR_RACAL
+  If you have a network (Ethernet) card belonging to this class, such
+  as the NI5010, NI5210 or NI6210, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about NI cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+NI5010 support
+CONFIG_NI5010
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that this is still
+  experimental code. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni5010.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI5210 support
+CONFIG_NI52
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni52.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI6510 support
+CONFIG_NI65
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni65.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+RealTek 8129/8139 (not 8019/8029!) support
+CONFIG_RTL8139
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the RTL8129 and RTL8139 chips. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called rtl8139.o.
+
+SiS 900/7016 support
+CONFIG_SIS900
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the SiS 900 and SiS 7016 chips. The SiS 900 core is also embedded in
+  SiS 630 and SiS 540 chipsets. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in   
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Please read 
+  Documentation/networking/sis900.txt and comments at the beginning
+  of drivers/net/sis900.c for more information.
+
+  This driver also supports AMD 79C901 HomePNA such that you can use
+  your phone line as network cable.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want), 
+  say M here and read Documentation/modules.txt. This is recommended. 
+  The module will be called sis900.o.
+
+Packet Engines Yellowfin Gigabit-NIC support
+CONFIG_YELLOWFIN
+  Say Y here if you have a Packet Engines G-NIC PCI Gigabit Ethernet
+  adapter. This adapter is used by the Beowulf Linux cluster project.
+  See http://cesdis.gsfc.nasa.gov/linux/drivers/yellowfin.html for
+  more information about this driver in particular and Beowulf in
+  general (to browse the WWW, you need to have access to a machine on
+  the Internet that has a program like lynx or netscape).
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called yellowfin.o.
+
+General Instruments Surfboard 1000
+CONFIG_NET_SB1000
+  This is a driver for the General Instrument SURFboard 1000 internal cable
+  modem.  This is an ISA card which is used by a number of cable TV companies
+  to provide cable modem access.  It's a one-way downstream-only cable modem,
+  meaning that your upstream net link is provided by your regular phone modem.
+
+  At present this driver only compiles as a module, so say M here if you
+  have this card.  Then read Documentation/networking/README.sb1000 for
+  information on how to use this module, as it needs special ppp scripts for
+  establishing a connection.  Further documentation and the necessary scripts
+  can be found at:
+
+  http://www.jacksonville.net/~fventuri/
+  http://home.adelphia.net/~siglercm/sb1000.html
+  http://linuxpower.cx/~cable/
+
+  If you don't have this card, of course say N.
+
+Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support
+CONFIG_ACENIC
+  Say Y here if you have an Alteon AceNIC or 3Com 3C985 PCI Gigabit
+  Ethernet adapter. The driver allows for using the Jumbo Frame
+  option (9000 bytes/frame) however it requires that your switches
+  can handle this as well. To enable Jumbo Frames, add `mtu 9000' to
+  your ifconfig line.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called acenic.o.
+
+SysKonnect SK-98xx support
+CONFIG_SK98LIN
+  Say Y here if you have a SysKonnect SK-98xx Gigabit Ethernet Server
+  Adapter. The following adapters are supported by this driver:
+  - SK-9841 (single link 1000Base-LX)
+  - SK-9842 (dual link   1000Base-LX)
+  - SK-9843 (single link 1000Base-SX)
+  - SK-9844 (dual link   1000Base-SX)
+  - SK-9821 (single link 1000Base-T)
+  - SK-9822 (dual link   1000Base-T)
+  The adapters support Jumbo Frames.
+  The dual link adapters support a link-failover feature.
+  Read Documentation/networking/sk98lin.txt for information about
+  optional driver parameters.
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called sk98lin.o.
+
+AMD LANCE and PCnet (AT1500 and NE2100) support
+CONFIG_LANCE
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Some LinkSys cards are
+  of this type.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called lance.o.
+
+3COM cards
+CONFIG_NET_VENDOR_3COM
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about 3COM cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+3c501 support
+CONFIG_EL1
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also, consider buying a
+  new card, since the 3c501 is slow, broken, and obsolete: you will
+  have problems. Some people suggest to ping ("man ping") a nearby
+  machine every minute ("man cron") when using this card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c501.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c503 support
+CONFIG_EL2
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c503.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c505 support
+CONFIG_ELPLUS
+  Information about this network (Ethernet) card can be found in
+  Documentation/networking/3c505.txt. If you have a card of this type,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c505.o.
+
+3c507 support
+CONFIG_EL16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c507.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c523 support 
+CONFIG_ELMC
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c523.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c527 support
+CONFIG_ELMC_II
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c527.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c509/3c579 support
+CONFIG_EL3
+  If you have a network (Ethernet) card belonging to the 3Com
+  EtherLinkIII series, say Y and read the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If your card is not working you may need to use the DOS
+  setup disk to disable Plug & Play mode, and to select the default
+  media type.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c509.o. 
+
+3c590 series (592/595/597) "Vortex" support
+CONFIG_VORTEX
+  If you have a 3Com "Vortex" (Fast EtherLink 3c590/3c592/3c595/3c597)
+  or "Boomerang" series (EtherLink XL 3c900 or 3c905) network
+  (Ethernet) card, say Y and read the Ethernet-HOWTO, available via
+  FTP (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is in Documentation/networking/vortex.txt
+  and in the comments at the beginning of drivers/net/3c59x.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Other ISA cards
+CONFIG_NET_ISA
+  If your network (Ethernet) card hasn't been mentioned yet and its
+  bus system (that's the way the cards talks to the other components
+  of your computer) is ISA (as opposed to EISA, VLB or PCI), say Y.
+  Make sure you know the name of your card. Read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If unsure, say Y.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the remaining ISA network card questions. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+Generic ARCnet support
+CONFIG_ARCNET
+  If you have a network card of this type, say Y and check out the
+  (arguably) beautiful poetry in Documentation/networking/arcnet.txt.
+
+  You need both this driver, and the driver for the particular ARCnet
+  chipset of your card. If you don't know, then it's probably a
+  COM90xx type card, so say Y (or M) to "ARCnet COM90xx chipset
+  support" below.
+
+  You might also want to have a look at the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO (even though ARCnet is
+  not really Ethernet).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called arcnet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Enable arc0e (ARCnet "ether-encap" packet format)
+CONFIG_ARCNET_ETH
+  This allows you to use "Ethernet encapsulation" with your ARCnet
+  card via the virtual arc0e device. You only need arc0e if you want
+  to talk to nonstandard ARCnet software, specifically,
+  DOS/Windows-style "NDIS" drivers. You do not need to say Y here to
+  communicate with industry-standard RFC1201 implementations, like the
+  arcether.com packet driver or most DOS/Windows ODI drivers. RFC1201
+  is included automatically as the arc0 device. Please read the
+  ARCnet documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+Enable arc0s (ARCnet RFC1051 packet format)
+CONFIG_ARCNET_1051
+  This allows you to use RFC1051 with your ARCnet card via the virtual
+  arc0s device. You only need arc0s if you want to talk to ARCnet
+  software complying with the "old" standard, specifically, the DOS
+  arcnet.com packet driver, Amigas running AmiTCP, and some variants
+  of NetBSD. You do not need to say Y here to communicate with
+  industry-standard RFC1201 implementations, like the arcether.com
+  packet driver or most DOS/Windows ODI drivers. RFC1201 is included
+  automatically as the arc0 device. Please read the ARCnet
+  documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+ARCnet COM90xx (normal) chipset driver
+CONFIG_ARCNET_COM90xx
+  This is the chipset driver for the standard COM90xx cards. If you
+  have always used the old ARCnet driver without knowing what type of
+  card you had, this is probably the one for you. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (IO mapped) chipset driver
+CONFIG_ARCNET_COM90xxIO
+  This is the chipset driver for the COM90xx cards, using them in
+  IO-mapped mode instead of memory-mapped mode. This is slower than
+  the normal driver. Only use it if your card doesn't support shared
+  memory. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90io.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (RIM I) chipset driver
+CONFIG_ARCNET_RIM_I
+  This is yet another chipset driver for the COM90xx cards, but this
+  time only using memory-mapped mode, and no IO ports at all. This
+  driver is completely untested, so if you have one of these cards,
+  please mail David.Woodhouse@mvhi.com, especially if it works!
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called arc-rimi.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+ARCnet COM20020 chipset driver
+CONFIG_ARCNET_COM20020
+  This is the driver for the new COM20020 chipset. It supports such
+  things as promiscuous mode, so packet sniffing is possible, and
+  extra diagnostic information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com20020.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Cabletron E21xx support
+CONFIG_E2100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called e2100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+CS89x0 support
+CONFIG_CS89x0
+  Support for CS89x0 chipset based Ethernet cards. If you have a
+  network (Ethernet) card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO as well as
+  Documentation/networking/cs89x0.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  cs89x.o.
+
+DEPCA support
+CONFIG_DEPCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO as well as
+  drivers/net/depca.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  depca.o.
+
+EtherWorks 3 support
+CONFIG_EWRK3
+  This driver supports the DE203, DE204 and DE205 network (Ethernet)
+  cards. If this is for you, say Y and read
+  Documentation/networking/ewrk3.txt in the kernel source as well as
+  the Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  ewrk3.o.
+
+SEEQ8005 support
+CONFIG_SEEQ8005
+  This is a driver for the SEEQ 8005 network (Ethernet) card. If this
+  is for you, read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+AT1700/1720 support
+CONFIG_AT1700
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  at1700.o.
+
+FMV-181/182/183/184 support
+CONFIG_FMV18X
+  If you have a Fujitsu FMV-181/182/183/184 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you use an FMV-183 or FMV-184 and it is not working, you may need
+  to disable Plug & Play mode of the card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fmv18x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+EtherExpress PRO support
+CONFIG_EEXPRESS_PRO
+  If you have a network (Ethernet) card of this type, say Y. This
+  driver supports intel i82595{FX,TX} based boards. Note however 
+  that the EtherExpress PRO/100 Ethernet card has its own separate
+  driver. Please read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress support
+CONFIG_EEXPRESS
+  If you have an EtherExpress16 network (Ethernet) card, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that the Intel
+  EtherExpress16 card used to be regarded as a very poor choice
+  because the driver was very unreliable. We now have a new driver
+  that should do better.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  eexpress.o.
+
+HP PCLAN+ (27247B and 27252A) support
+CONFIG_HPLAN_PLUS
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp-plus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP PCLAN (27245 and other 27xxx series) support
+CONFIG_HPLAN
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP 10/100VG PCLAN (ISA, EISA, PCI) support
+CONFIG_HP100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  hp100.o.
+
+NE2000/NE1000 support
+CONFIG_NE2000
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Many Ethernet cards
+  without a specific driver are compatible with NE2000. 
+
+  If you have a PCI NE2000 card however, say N here and Y to "PCI
+  NE2000 support", above. If you have a NE2000 card and are running on
+  an MCA system (a bus system used on some IBM PS/2 computers and
+  laptops), say N here and Y to "NE/2 (ne2000 MCA version) support",
+  below.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SK_G16 support
+CONFIG_SK_G16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+NE/2 (ne2000 MCA version) support
+CONFIG_NE2_MCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SKnet MCA support
+CONFIG_SKMC
+  This are Micro Channel ethernet adapters.  You need to set CONFIG_MCA
+  to use this driver.  It's both available as an in-kernel driver and
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. If you plan to use more than
+  one network card under linux, read the Multiple-Ethernet-mini-HOWTO,
+  available from sunsite.unc.edu:/pub/Linux/docs/HOWTO/mini.  Supported
+  cards are the SKnet Junior MC2 and the SKnet MC2(+).  Distinguishing
+  both cards is done automatically.  Note that using multiple boards
+  of different type hasn't been tested with this driver.
+
+EISA, VLB, PCI and on board controllers
+CONFIG_NET_EISA
+  This is another class of network cards which attach directly to the
+  bus. If you have one of those, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network cards. If you say Y, you
+  will be asked for your specific card in the following questions. If
+  you are unsure, say Y.
+
+AMD PCnet32 (VLB and PCI) support
+CONFIG_PCNET32
+  If you have a PCnet32 or PCnetPCI based network (Ethernet) card,
+  answer Y here and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pcnet32.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Ansel Communications EISA 3200 support
+CONFIG_AC3200
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ac3200.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Mylex EISA LNE390A/LNE390B support
+CONFIG_LNE390
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lne390.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Novell/Eagle/Microdyne NE3210 EISA support
+CONFIG_NE3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that this driver
+  will NOT WORK for NE3200 cards as they are completely different.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Apricot Xen-II on board Ethernet
+CONFIG_APRICOT
+  If you have a network (Ethernet) controller of this type, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  apricot.o.
+
+Generic DECchip & DIGITAL EtherWORKS PCI/EISA
+CONFIG_DE4X5
+  This is support for the DIGITAL series of PCI/EISA Ethernet cards.
+  These include the DE425, DE434, DE435, DE450 and DE500 models. If
+  you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. More specific
+  information is contained in Documentation/networking/de4x5.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called de4x5.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+DECchip Tulip (dc21x4x) PCI support
+CONFIG_DEC_ELCP
+  This driver is developed for the SMC EtherPower series Ethernet
+  cards and also works with cards based on the DECchip
+  21040/21041/21140 (Tulip series) chips. Some LinkSys PCI cards are
+  of this type. (If your card is NOT SMC EtherPower 10/100 PCI
+  (smc9332dst), you can also try the driver for "Generic DECchip"
+  cards, above. However, most people with a network card of this type
+  will say Y here.) Do read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is contained in
+  Documentation/networking/tulip.txt.
+
+  This is the new version of this driver. If it does not work for
+  you please try older version which is also available.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tulip.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Old DECchip Tulip (dc21x4x) PCI support
+CONFIG_DEC_ELCP_OLD
+  This driver is developed for the SMC EtherPower series Ethernet
+  cards and also works with cards based on the DECchip
+  21040/21041/21140 (Tulip series) chips. Some LinkSys PCI cards are
+  of this type. (If your card is NOT SMC EtherPower 10/100 PCI
+  (smc9332dst), you can also try the driver for "Generic DECchip"
+  cards, above. However, most people with a network card of this type
+  will say Y here.) Do read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is contained in
+  Documentation/networking/tulip.txt.
+
+  This an older version of the driver which supports some cards the
+  new version does not (yet) support. Use it if the new driver does
+  not work for you.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called old_tulip.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Digi Intl. RightSwitch support
+CONFIG_DGRS
+  This is support for the Digi International RightSwitch series of
+  PCI/EISA Ethernet switch cards. These include the SE-4 and the SE-6
+  models. If you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. More specific
+  information is contained in Documentation/networking/dgrs.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dgrs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress PRO/100 support
+CONFIG_EEXPRESS_PRO100
+  If you have an Intel EtherExpress PRO/100 PCI network (Ethernet)
+  card, say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ICL EtherTeam 16i/32 support
+CONFIG_ETH16I
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eth16i.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+TI ThunderLAN support (EXPERIMENTAL)
+CONFIG_TLAN
+  If you have a PCI Ethernet network card based on the ThunderLAN chip
+  which is supported by this driver, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Devices currently supported by this driver are Compaq Netelligent,
+  Compaq NetFlex and Olicom cards. Please read the file
+  Documentation/networking/tlan.txt for more details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tlan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+  Please email feedback to torben.mathiasen@compaq.com.
+
+VIA Rhine support
+CONFIG_VIA_RHINE
+  If you have a VIA "rhine" based network card (Rhine-I (3043) or
+  Rhine-2 (VT86c100A)), say Y here.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called via-rhine.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan EISA ES3210 support
+CONFIG_ES3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called es3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC EtherPower II (EXPERIMENTAL)
+CONFIG_EPIC100
+  If you have an SMC EtherPower II 9432 PCI Ethernet network card
+  which is based on the SMC83c170, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called epic100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SGI Seeq ethernet controller support
+CONFIG_SGISEEQ
+  Say Y here if you have an Seeq based Ethernet network card. This is
+  used in many Silicon Graphics machines.
+
+Zenith Z-Note support
+CONFIG_ZNET
+  The Zenith Z-Note notebook computer has a built-in network
+  (Ethernet) card, and this is the Linux driver for it. Note that the
+  IBM Thinkpad 300 is compatible with the Z-Note and is also supported
+  by this driver. Read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+Pocket and portable adapters
+CONFIG_NET_POCKET
+  Cute little network (Ethernet) devices which attach to the parallel
+  port ("pocket adapters"), commonly used with laptops. If you have
+  one of those, say Y and read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to plug a network (or some other) card into the PCMCIA
+  (or PC-card) slot of your laptop instead (PCMCIA is the standard for
+  credit card size extension cards used by all modern laptops), you
+  need the pcmcia-cs package (location contained in the file
+  Documentation/Changes) and you can say N here.
+
+  Laptop users should read the Linux Laptop home page at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape). 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network devices. If you say Y, you
+  will be asked for your specific device in the following questions.
+
+AT-LAN-TEC/RealTek pocket adapter support
+CONFIG_ATP
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read drivers/net/atp.c as well as the Ethernet-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  If you intend to use this driver, you should have said N to the
+  Parallel Printer support, because the two drivers don't like each
+  other.
+
+D-Link DE600 pocket adapter support
+CONFIG_DE600
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  It is possible to have several devices share a single parallel port
+  and it is safe to compile the corresponding drivers into the kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de600.o.
+
+D-Link DE620 pocket adapter support
+CONFIG_DE620
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  It is possible to have several devices share a single parallel port
+  and it is safe to compile the corresponding drivers into the kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de620.o.
+
+Token Ring driver support
+CONFIG_TR
+  Token Ring is IBM's way of communication on a local network; the
+  rest of the world uses Ethernet. To participate on a Token Ring
+  network, you need a special Token ring network card. If you are
+  connected to such a Token Ring network and want to use your Token
+  Ring card under Linux, say Y here and to the driver for your
+  particular card below and read the Token-Ring mini-HOWTO, available
+  via FTP (user:anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Most people can say N
+  here.
+
+IBM Tropic chipset based adapter support
+CONFIG_IBMTR
+  This is support for all IBM Token Ring cards that don't use DMA. If
+  you have such a beast, say Y and read the Token-Ring mini-HOWTO,
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Warning: this driver will almost definitely fail if more than one
+  active Token Ring card is present. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmtr.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IBM Olympic chipset PCI adapter support
+CONFIG_IBMOL
+  This is support for all non-Lanstreamer IBM PCI Token Ring Cards. 
+  Specifically this is all IBM PCI, PCI Wake On Lan, PCI II, PCI II
+  Wake On Lan, and PCI 100/16/4 adapters.
+
+  If you have such an adapter, say Y and read the Token-Ring mini-HOWTO,
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc/edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called olympic.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  Also read the linux/Documentation/networking/olympic.txt or check the 
+  Linux Token Ring Project site for the latest information at
+  http://www.linuxtr.net
+
+IBM Lanstreamer chipset PCI adapter support
+CONFIG_IBMLS
+  This is support for IBM Lanstreamer PCI Token Ring Cards.
+
+  If you have such an adapter, say Y and read the Token-Ring mini-HOWTO
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc/edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a modules ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The modules will be called lanstreamer.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+SysKonnect adapter support
+CONFIG_SKTR
+  This is support for all SysKonnect Token Ring cards, specifically
+  SysKonnect TR4/16(+) ISA (SK-4190), SysKonnect TR4/16(+) PCI
+  (SK-4590), SysKonnect TR4/16 PCI (SK-4591) adapters.
+  It also supports Compaq PCI Token Ring adapters and Proteon ISA
+  Token Ring adapters (1392 and 1392+).
+
+  If you have such an adapter and would like to use it, say Y or M and
+  read the Token-Ring mini-HOWTO, available via FTP (user: anonymous)
+  from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Also read the file linux/Documentation/networking/sktr.txt or check
+  the Linux-SNA WWW site for the latest information at
+  http://samba.anu.edu.au/linux-sna/documents/drivers/SysKonnect/
+
+Traffic Shaper (EXPERIMENTAL)
+CONFIG_SHAPER
+  The traffic shaper is a virtual network device that allows you to
+  limit the rate of outgoing data flow over some other network
+  device. See Documentation/networking/shaper.txt for more
+  information. To set up and configure shaper devices, you need the
+  shapecfg program, available via FTP (user: anonymous) from
+  ftp://shadow.cabi.net/pub/Linux in the shaper package. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called shaper.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+FDDI driver support
+CONFIG_FDDI
+  Fiber Distributed Data Interface is a high speed local area network
+  design; essentially a replacement for high speed Ethernet. FDDI can
+  run over copper or fiber. If you are connected to such a network and
+  want a driver for the FDDI card in your computer, say Y here (and
+  then also Y to the driver for your FDDI card, below). Most people
+  will say N.
+
+Digital DEFEA and DEFPA adapter support
+CONFIG_DEFXX
+  This is support for the DIGITAL series of EISA (DEFEA) and PCI
+  (DEFPA) controllers which can connect you to a local FDDI network.
+
+SysKonnect FDDI PCI support
+CONFIG_SKFP
+  Say Y here if you have a SysKonnect FDDI PCI adapter.
+  The following adapters are supported by this driver:
+  - SK-5521 (SK-NET FDDI-UP)
+  - SK-5522 (SK-NET FDDI-UP DAS)
+  - SK-5541 (SK-NET FDDI-FP)
+  - SK-5543 (SK-NET FDDI-LP)
+  - SK-5544 (SK-NET FDDI-LP DAS)
+  - SK-5821 (SK-NET FDDI-UP64)
+  - SK-5822 (SK-NET FDDI-UP64 DAS)
+  - SK-5841 (SK-NET FDDI-FP64)
+  - SK-5843 (SK-NET FDDI-LP64)
+  - SK-5844 (SK-NET FDDI-LP64 DAS)
+  - Netelligent 100 FDDI DAS Fibre SC
+  - Netelligent 100 FDDI SAS Fibre SC
+  - Netelligent 100 FDDI DAS UTP
+  - Netelligent 100 FDDI SAS UTP
+  - Netelligent 100 FDDI SAS Fibre MIC
+  Read Documentation/networking/skfp.txt for information about
+  the driver.
+  Questions concerning this driver can be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called skfp.o.
+
+HIgh Performance Parallel Interface support (EXPERIMENTAL)
+CONFIG_HIPPI
+  HIgh Performance Parallel Interface (HIPPI) is a 800Mbit/sec and
+  1600Mbit/sec dual-simplex switched or point-to-point network. HIPPI
+  can run over copper (25m) or fiber (300m on multi-mode or 10km on
+  single-mode). HIPPI networks are commonly used for clusters and to
+  connect to super computers. If you are connected to a HIPPI network
+  and have a HIPPI network card in your computer that you want to use
+  under Linux, say Y here (you must also remember to enable the driver
+  for your HIPPI card below). Most people will say N here.
+  
+Essential RoadRunner HIPPI PCI adapter support
+CONFIG_ROADRUNNER
+  Say Y here if this is your PCI HIPPI network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rrunner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Use large TX/RX rings
+CONFIG_ROADRUNNER_LARGE_RINGS
+  If you say Y here, the RoadRunner driver will preallocate up to 2 MB
+  of additional memory to allow for fastest operation, both for
+  transmitting and receiving. This memory cannot be used by any other
+  kernel code or by user space programs. Say Y here only if you have
+  the memory.
+
+Acorn Ether1 card
+CONFIG_ARM_ETHER1
+  If you have an Acorn system with one of these (AKA25) network cards,
+  you should say Y to this option if you wish to use it with Linux.
+
+Acorn/ANT Ether3 card
+CONFIG_ARM_ETHER3
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+I Cubed EtherH card
+CONFIG_ARM_ETHERH
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+EBSA-110 Ethernet interface
+CONFIG_ARM_AM79C961A
+  If you wish to compile a kernel for the EBSA-110, then you should
+  always answer Y to this.
+
+Support CDROM drives that are not SCSI or IDE/ATAPI
+CONFIG_CD_NO_IDESCSI
+  If you have a CDROM drive that is neither SCSI nor IDE/ATAPI, say Y
+  here, otherwise N. Read the CDROM-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these CDROM drives. If you are unsure what you
+  have, say Y and find out whether you have one of the following
+  drives. 
+
+  For each of these drivers, a file Documentation/cdrom/<driver_name>
+  exists. Especially in cases where you do not know exactly which kind
+  of drive you have you should read there. Most of these drivers use a
+  file drivers/cdrom/<driver_name>.h where you can define your
+  interface parameters and switch some internal goodies. 
+
+  All these CDROM drivers are also usable as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile them as module, say M instead of Y and
+  read Documentation/modules.txt. 
+
+  If you want to use any of these CDROM drivers, you also have to
+  answer Y or M to "ISO 9660 CDROM filesystem support" below (this
+  answer will get "defaulted" for you if you enable any of the Linux
+  CDROM drivers).
+
+Sony CDU31A/CDU33A CDROM support
+CONFIG_CDU31A
+  These CDROM drives have a spring-pop-out caddyless drawer, and a
+  rectangular green LED centered beneath it. NOTE: these CDROM drives
+  will not be auto detected by the kernel at boot time; you have to
+  provide the interface address as an option to the kernel at boot
+  time as described in Documentation/cdrom/cdu31a or fill in your
+  parameters into drivers/cdrom/cdu31a.c. Try "man bootparam" or
+  see the documentation of your boot loader (lilo or loadlin) about
+  how to pass options to the kernel. The lilo procedure is also
+  explained in the SCSI-HOWTO. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cdu31a.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Standard Mitsumi [no XA/Multisession] CDROM support
+CONFIG_MCD
+  This is the older of the two drivers for the older Mitsumi models
+  LU-005, FX-001 and FX-001D. This is not the right driver for the
+  FX-001DE and the triple or quad speed models (all these are
+  IDE/ATAPI models). Please also the file Documentation/cdrom/mcd.
+
+  With the old LU-005 model, the whole drive chassis slides out for cd
+  insertion. The FX-xxx models use a motorized tray type mechanism.
+  Note that this driver does not support XA or MultiSession CDs
+  (PhotoCDs). There is a new driver (next question) which can do
+  this. If you want that one, say N here.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IRQ channel for Mitsumi CD-ROM
+CONFIG_MCD_IRQ
+  This allows you to specify the default value of the IRQ used by the
+  driver. This setting can be overridden by passing the "mcd="
+  parameter to the kernel at boot time (or at module load time if you
+  said M to "Standard Mitsumi CDROM support").
+
+I/O base address for Mitsumi CD-ROM
+CONFIG_MCD_BASE
+  This allows you to specify the default value of the I/O base address
+  used by the driver. This setting can be overridden by passing the
+  "mcd=" parameter to the kernel at boot time (or at module load time
+  if you said M to "Standard Mitsumi CDROM support").
+
+Mitsumi [XA/MultiSession] support
+CONFIG_MCDX
+  Use this driver if you want to be able to read XA or MultiSession
+  CDs (PhotoCDs) as well as ordinary CDs with your Mitsumi LU-005,
+  FX-001 or FX-001D CDROM drive. In addition, this driver uses much
+  less kernel memory than the old one, if that is a concern. This
+  driver is able to support more than one drive, but each drive needs
+  a separate interface card. Please read the file
+  Documentation/cdrom/mcdx.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcdx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic/Creative, Longshine, TEAC CDROM support
+CONFIG_SBPCD
+  This driver supports most of the drives which use the Panasonic or
+  Sound Blaster interface. Please read the file
+  Documentation/cdrom/sbpcd.
+
+  The Matsushita CR-521, CR-522, CR-523, CR-562, CR-563 drives
+  (sometimes labeled "Creative"), the Creative Labs CD200, the
+  Longshine LCS-7260, the "IBM External ISA CDROM" (in fact a CR-56x
+  model), the TEAC CD-55A fall under this category. Some other
+  "electrically compatible" drives (Vertos, Genoa, some Funai models)
+  are currently not supported; for the Sanyo H94A drive currently a
+  separate driver (asked later) is responsible. Most drives have a
+  uniquely shaped faceplate, with a caddyless motorized drawer, but
+  without external brand markings. The older CR-52x drives have a
+  caddy and manual loading/eject, but still no external markings. The
+  driver is able to do an extended auto-probing for interface
+  addresses and drive types; this can help to find facts in cases you
+  are not sure, but can consume some time during the boot process if
+  none of the supported drives gets found. Once your drive got found,
+  you should enter the reported parameters into drivers/cdrom/sbpcd.h
+  and set "DISTRIBUTION 0" there.
+
+  This driver can support up to four CDROM controller cards, and each
+  card can support up to four CDROM drives; if you say Y here, you
+  will be asked how many controller cards you have. If compiled as a
+  module, only one controller card (but with up to four drives) is
+  usable.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sbpcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic, ... second CDROM controller support
+CONFIG_SBPCD2
+  Say Y here only if you have two CDROM controller cards of this type
+  (usually only if you have more than four drives). You should enter
+  the parameters for the second, third and fourth interface card into
+  linux/include/linux/sbpcd.h before compiling the new kernel. Read
+  the file Documentation/cdrom/sbpcd.
+
+Aztech/Orchid/Okano/Wearnes/TXC/CyDROM CDROM support
+CONFIG_AZTCD
+  This is your driver if you have an Aztech CDA268-01A, Orchid
+  CD-3110, Okano or Wearnes CDD110, Conrad TXC, or CyCDROM CR520 or
+  CR540 CDROM drive. This driver -- just like all these CDROM drivers
+  -- is NOT for CDROM drives with IDE/ATAPI interfaces, such as Aztech
+  CDA269-031SE. Please read the file Documentation/cdrom/aztcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aztcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sony CDU535 CDROM support
+CONFIG_CDU535
+  This is the driver for the older Sony CDU-535 and CDU-531 CDROM
+  drives. Please read the file Documentation/cdrom/sonycd535.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sonycd535.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Goldstar R420 CDROM support
+CONFIG_GSCD
+  If this is your CDROM drive, say Y here. As described in the file
+  linux/Documentation/cdrom/gscd, you might have to change a setting
+  in the file linux/drivers/cdrom/gscd.h before compiling the
+  kernel. Please read the file Documentation/cdrom/gscd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called gscd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Philips/LMS CM206 CDROM support
+CONFIG_CM206
+  If you have a Philips/LMS CDROM drive cm206 in combination with a
+  cm260 host adapter card, say Y here. Please also read the file
+  Documentation/cdrom/cm206. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cm206.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Optics Storage DOLPHIN 8000AT CDROM support
+CONFIG_OPTCD
+  This is the driver for the 'DOLPHIN' drive with a 34-pin Sony
+  compatible interface. It also works with the Lasermate CR328A. If
+  you have one of those, say Y. This driver does not work for the
+  Optics Storage 8001 drive; use the IDE-ATAPI CDROM driver for that
+  one. Please read the file Documentation/cdrom/optcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called optcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sanyo CDR-H94A CDROM support
+CONFIG_SJCD
+  If this is your CDROM drive, say Y here and read the file
+  Documentation/cdrom/sjcd. You should then also say Y or M to
+  "ISO 9660 CDROM filesystem support" below, because that's the
+  filesystem used on CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sjcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Soft configurable cdrom interface card support
+CONFIG_CDI_INIT
+  If you want to include boot-time initialization of any cdrom
+  interface card that is software configurable, say Y here. Currently
+  only the ISP16/MAD16/Mozart sound cards with built-in cdrom
+  interfaces are supported. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these CDROM drives.
+
+ISP16/MAD16/Mozart soft configurable cdrom interface support
+CONFIG_ISP16_CDI
+  These are sound cards with built-in cdrom interfaces using the OPTi
+  82C928 or 82C929 chips. Say Y here to have them detected and
+  possibly configured at boot time. In addition, You'll have to say Y
+  to a driver for the particular cdrom drive you have attached to the
+  card. Read Documentation/cdrom/isp16 for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called isp16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Quota support
+CONFIG_QUOTA
+  If you say Y here, you will be able to set per user limits for disk
+  usage (also called disk quotas). Currently, it works only for the
+  ext2 filesystem. You need additional software in order to use quota
+  support; for details, read the Quota mini-HOWTO, available via FTP
+  (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. Probably the quota
+  support is only useful for multi user systems. If unsure, say N.
+
+Acorn's ADFS filesystem support (read only) (EXPERIMENTAL)
+CONFIG_ADFS_FS
+  The Advanced Disk File System is the filesystem used on floppy and
+  hard disks by Acorn Systems.  Currently in development, as a read-
+  only driver for hard disks.  These should be the first partition
+  (eg. /dev/[sh]d?1) on each of your drives.  If unsure, say N.
+
+Support for USB
+CONFIG_USB
+  Universal Serial Bus (USB) is a specification for a serial bus
+  subsystem which offers higher speeds and more features than the
+  traditional PC serial port. The bus supplies power to peripherals
+  and allows for hot swapping. Up to 127 USB peripherals can be
+  connected to a single USB port in a tree structure. The USB port is
+  the root of the tree, the peripherals are the leaves and the inner
+  nodes are special USB devices called hubs. Many newer PC's have USB
+  ports and newer peripherals such as scanners, keyboards, mice,
+  modems, and printers support the USB protocol and can be connected
+  to the PC via those ports.
+
+  Say Y here if your computer has a USB port and you want to use USB
+  devices. You then need to say Y to at least one of "UHCI support" or
+  "OHCI support" below (the type of interface that the USB hardware in
+  your computer provides to the operating system) and then choose from
+  among the drivers for USB peripherals. You may want to check out the
+  information provided in Documentation/usb/ and especially the links
+  given in Documentation/usb/usb-help.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbcore.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB verbose debug messages
+CONFIG_USB_DEBUG
+  Say Y here if you want the USB core & hub drivers to produce a bunch
+  of debug messages to the system log. Select this if you are having a
+  problem with USB support and want to see more of what is going on.
+
+UHCI (intel PIIX4, VIA, ...) support?
+CONFIG_USB_UHCI
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133).
+
+  Currently there exist two drivers for UHCI host controllers: this
+  one and the so-called JE driver, which you can get from 
+  "UHCI alternate (JE) support", below. You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI (intel PIIX4, VIA, ...) alternate (JE) support?
+CONFIG_USB_UHCI_ALT
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133). If unsure, say Y.
+
+  Currently there exist two drivers for UHCI host controllers: this
+  so-called JE driver, and the one you get from "UHCI support", above.
+  You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI unlink optimizations (EXPERIMENTAL)
+CONFIG_USB_UHCI_ALT_UNLINK_OPTIMIZE
+  This option currently does nothing. You may say Y or N.
+
+OHCI (Compaq, iMacs, OPTi, SiS, ALi, ...) support
+CONFIG_USB_OHCI
+  The Open Host Controller Interface is a standard by
+  Compaq/Microsoft/National for accessing the USB PC hardware (also
+  called USB host controller). If your USB host controller conforms to
+  this standard, say Y. The USB host controllers on most non-Intel
+  architectures and on several x86 compatibles with non-Intel chipsets
+  -- like SiS (aktual 610, 610 and so on) or ALi (ALi IV, ALi V,
+  Aladdin Pro..) -- conform to this standard.
+
+  You may want to read the file Documentation/usb/ohci.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-ohci.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Human Interface Device (HID) support
+CONFIG_USB_HID
+  Say Y here if you want to connect keyboards, mice, joysticks,
+  graphic tablets, or any other HID based devices to your
+  computer via USB. More information is available:
+  Documentation/usb/input.txt.
+
+  If unsure, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hid.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB HIDBP Keyboard support
+CONFIG_USB_KBD
+  Say Y here if you don't want to use the generic HID driver for your
+  USB keyboard and prefer to use the keyboard in its limited Boot
+  Protocol mode. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbkbd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+USB HIDBP Mouse support
+CONFIG_USB_MOUSE
+  Say Y here if you don't want to use the generic HID driver for your
+  USB mouse and prefer to use the mouse in its limited Boot Protocol
+  mode. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbmouse.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Wacom Intuos/Graphire tablet support
+CONFIG_USB_WACOM
+  Say Y here if you want to use the USB version of the Wacom Intuos
+  or Graphire tablet. Make sure to say Y to "Mouse support"
+  (CONFIG_INPUT_MOUSEDEV) and/or "Event interface support"
+  (CONFIG_INPUT_EVDEV) as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wacom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Logitech WingMan Force joystick support
+CONFIG_USB_WMFORCE
+  Say Y here if you want to use the Logitech WingMan Force with Linux
+  on the USB port. No force-feedback support yet, but other than that
+  it should work like a normal joystick.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wmforce.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Keyboard support
+CONFIG_INPUT_KEYBDEV
+  Say Y here if you want your USB HID keyboard to be able to serve 
+  as a system keyboard.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keybdev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Mouse support
+CONFIG_INPUT_MOUSEDEV
+  Say Y here if you want your USB HID mouse (or ADB mouse handled by
+  the input layer) to be accessible as char devices 13:32+ -
+  /dev/input/mouseX and 13:63 - /dev/input/mice as an emulated ImPS/2
+  mouse.  That way, all user space programs will be able to use your
+  mouse.
+  
+  If unsure, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mousedev.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Horizontal screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_X
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Vertical screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Joystick support
+CONFIG_INPUT_JOYDEV
+  Say Y here if you want your USB HID joystick or gamepad to be
+  accessible as char device 13:0+ - /dev/input/jsX device. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called joydev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Event interface support
+CONFIG_INPUT_EVDEV
+  Say Y here if you want your USB or ADB HID device events be accessible
+  under char device 13:64+ - /dev/input/eventX in a generic way.
+  This is the future ...
+
+USB Scanner support
+CONFIG_USB_SCANNER
+  Say Y here if you want to connect a USB scanner to your computer's
+  USB port. Please read Documentation/usb/scanner.txt and
+  Documentation/usb/scanner-hp-sane.txt for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scanner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+USB Audio support
+CONFIG_USB_AUDIO
+  Say Y here if you want to connect UAB audio equipment such as
+  speakers to your computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called audio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Modem (CDC ACM) support
+CONFIG_USB_ACM
+  This driver supports USB modems and ISDN adapters which support the
+  Communication Device Class Abstract Control Model interface.
+  Please read Documentation/usb/acm.txt for details.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acm.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Serial converter support
+CONFIG_USB_SERIAL
+  Say Y here if you have a USB device that provides normal serial
+  ports, and you want to connect it to your USB bus. Supported devices
+  are the Tech WhiteHEAT multi-port USB to serial converter, and the
+  FTDI or Keyspan single port USB to serial converter Handspring
+  Visor. In addition to saying Y here, you need to say Y to the driver
+  for your specific hardware below. Some other devices may also be
+  used if you say Y to "USB Generic Serial Driver", below.
+
+  Please read Documentation/usb/usb-serial.txt for more information.
+  
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbserial.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Generic Serial Driver
+CONFIG_USB_SERIAL_GENERIC
+  Say Y here if you want to use the generic USB serial driver. Please
+  read Documentation/usb/usb-serial.txt for more information on using
+  this driver. It is recommended that the "USB Serial converter
+  support" be compiled as a module for this driver to be used
+  properly.
+
+USB ConnectTech WhiteHEAT Serial Driver
+CONFIG_USB_SERIAL_WHITEHEAT
+  Say Y here if you want to use a ConnectTech WhiteHEAT 4 port
+  USB to serial converter device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called whiteheat.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Handspring Visor Driver
+CONFIG_USB_SERIAL_VISOR
+  Say Y here if you want to connect to your HandSpring Visor through
+  its USB docking station. See http://usbvisor.sourceforge.net for
+  more information on using this driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called visor.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB FTDI Single Port Serial Driver
+CONFIG_USB_SERIAL_FTDI_SIO
+  Say Y here if you want to use a FTDI SIO single port USB to serial
+  converter device. The implementation I have is called the USC-1000.
+
+  See http://reality.sgi.com/bryder_wellington/ftdi_sio for more
+  information on this driver and the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ftdi_sio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan PDA Single Port Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN_PDA
+  Say Y here if you want to use a Keyspan PDA single port USB to
+  serial converter device.  This driver makes use of firmware
+  developed from scratch by Brian Warner.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan_pda.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-xxx Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN
+  Say Y here if you want to use Keyspan USB to serial converter
+  devices.  This driver makes use of Keyspan's official firmware
+  and was developed with their support.  You must also include
+  firmware to support your particular device(s). 
+
+  See http://www.linuxcare.com.au/hugh/keyspan.html for 
+  more information.
+ 
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-28 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28
+  Say Y here to include firmware for the USA-28 converter.
+
+USB Keyspan USA-28X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28X
+  Say Y here to include firmware for the USA-28X converter.
+
+USB Keyspan USA-19 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19
+  Say Y here to include firmware for the USA-19 converter.
+
+USB Keyspan USA-18X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA18X
+  Say Y here to include firmware for the USA-18X converter.
+
+USB Keyspan USA-19W Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19W
+  Say Y here to include firmware for the USA-19W converter.
+
+USB ZyXEL omni.net LCD Plus Driver
+CONFIG_USB_SERIAL_OMNINET
+  Say Y here if you want to use a ZyXEL omni.net LCD ISDN TA.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called omninet.o. If you want to compile it as a 
+  module, say M here and read Documentation/modules.txt.
+
+USB Digi International AccelePort USB Serial Driver
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT
+  Say Y here if you want to use Digi AccelePort USB 2 or 4 devices,
+  2 port (plus parallel port) and 4 port USB serial converters.  The
+  parallel port on the USB 2 appears as a third serial port on Linux.
+  The Digi Acceleport USB 8 is not yet supported by this driver.
+
+  This driver works under SMP with the usb-uhci driver.  It does not
+  work under SMP with the uhci driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called digi_acceleport.o. If you want to compile 
+  it as a module, say M here and read Documentation/modules.txt.
+
+USB Serial Converter verbose debug
+CONFIG_USB_SERIAL_DEBUG
+  Say Y here if you want verbose debug messages from the USB Serial
+  Converter. 
+
+USB Printer support
+CONFIG_USB_PRINTER
+  Say Y here if you want to connect a USB printer to your computer's
+  USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called printer.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB IBM (Xirlink) C-It Camera support
+CONFIG_USB_IBMCAM
+  Say Y here if you want to connect a IBM "C-It" camera, also known as
+  "Xirlink PC Camera" to your computer's USB port. For more
+  information, read Documentation/usb/ibmcam.txt.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmcam.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. This camera
+  has several configuration options which can be specified when you
+  load the module. Read Documentation/usb/ibmcam.txt to learn more.
+
+USB OV511 Camera support
+CONFIG_USB_OV511
+  Say Y here if you want to connect this type of camera to your
+  computer's USB port. See Documentation/usb/ov511.txt for more
+  information and for a list of supported cameras.
+  
+  This driver uses the Video For Linux API. You must say Y or M to
+  "Video For Linux" (under Character Devices) to use this driver.
+  Information on this API and pointers to "v4l" programs may be found
+  on the WWW at http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ov511.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB ADMtek Pegasus-based ethernet device support
+CONFIG_USB_PEGASUS
+  Say Y if you want to use your USB ethernet device. Supported
+  cards until now are:
+    ADMtek AN986 (eval. board)
+    Accton 10/100
+    Billington USB-100
+    Corega FEter USB-TX
+    MELCO/BUFFALO LUA-TX
+    D-Link DSB-650TX, DSB-650TX-PNA, DSB-650, DU-E10, DU-E100
+    Linksys USB100TX, USB10TX
+    LANEED Ethernet LD-USB/TX
+    SMC 202
+    SOHOware NUB Ethernet
+  If you have devices with vendor IDs other than noted above
+  you should add them in the driver code and send a message
+  to me (petkan@dce.bg) for update.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pegasus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Kodak DC-2xx Camera support
+CONFIG_USB_DC2XX
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port.  See Documentation/usb/dc2xx.txt for more
+  information; some non-Kodak cameras may also work with this
+  driver, given application support (such as www.gPhoto.org).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dc2xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mustek MDC800 Digital Camera Support
+CONFIG_USB_MDC800
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port. This driver can be used with gphoto 0.4.3
+  and higher (look at http://www.gphoto.org ).
+  To use it create a device node with "mknod /dev/mustek c 180 32" and
+  configure it in your software.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mdc800.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage support
+CONFIG_USB_STORAGE
+  Say Y here if you want to connect USB mass storage devices to your
+  computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-storage.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage verbose debug
+CONFIG_USB_STORAGE_DEBUG
+  Say Y here in order to have the USB Mass Storage code generate
+  verbose debugging messages.
+
+USS720 parport driver
+CONFIG_USB_USS720
+  This driver is for USB parallel port adapters that use the Lucent
+  Technologies USS-720 chip. These cables are plugged into your USB
+  port and provide USB compatibility to peripherals designed with
+  parallel port interfaces.
+  
+  The chip has two modes: automatic mode and manual mode. In automatic
+  mode, it looks to the computer like a standard USB printer. Only
+  printers may be connected to the USS-720 in this mode. The generic
+  USB printer driver ("USB Printer support", above) may be used in
+  that mode, and you can say N here if you want to use the chip only
+  in this mode.
+
+  Manual mode is not limited to printers, any parallel port
+  device should work. This driver utilizes manual mode.
+  Note however that some operations are three orders of magnitude
+  slower than on a PCI/ISA Parallel Port, so timing critical
+  applications might not work.
+
+  Say Y here if you own an USS-720 USB->Parport cable and intend to
+  connect anything other than a printer to it.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uss720.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+  
+USB device file system
+CONFIG_USB_DEVICEFS
+  If you say Y here (and to "/proc file system support" below), you
+  will get a file /proc/usb/devices which lists the devices currently
+  connected to your USB busses, a file /proc/usb/drivers which lists
+  the USB kernel client drivers currently loaded, and for every
+  connected device a file named "/proc/usb/xxx/yyy", where xxx is the
+  bus number and yyy the device number; the latter files can be used
+  by user space programs to talk directly to the device. These files
+  are "virtual", meaning they are generated on the fly and not stored
+  on the hard drive.
+  
+  For the format of the /proc/usb/ files, please read
+  Documentation/usb/proc_usb_info.txt. 
+
+  Please note that this code is completely unrelated to devfs, the
+  "/dev file system support".
+
+  Most users want to say Y here.
+
+Support for hot-pluggable USB devices
+CONFIG_HOTPLUG
+ Say Y here if you want to plug devices into your computer while
+ the system is running, and be able to use them quickly.  In many
+ cases, the devices can likewise be unplugged at any time too.
+
+ Enable this with KMOD, and your kernel will automatically
+ call out to a user mode "policy agent" to load drivers and other
+ modules needed to use USB devices you plug in.  With a bit of work,
+ it can invoke other device setup tasks.  Get such agent software
+ (at http://www.linux-usb.org/policy.html) and install it.
+
+USB Bandwidth allocation
+CONFIG_USB_BANDWIDTH
+  If you say Y here, the USB subsystem enforces USB bandwidth
+  allocation and will prevent some device opens from succeeding
+  if they would cause USB bandwidth usage to go above 90% of
+  the bus bandwidth.
+
+  If you say N here, these conditions will cause warning messages
+  about USB bandwidth usage to be logged and some devices or
+  drivers may not work correctly.
+
+DABUSB driver
+CONFIG_USB_DABUSB
+  A Digital Audio Broadcasting (DAB) Receiver for USB and Linux
+  brought to you by the DAB-Team (http://dab.in.tum.de). This driver
+  can be taken as an example for URB-based bulk, control, and
+  isochronous transactions. URB's are explained in
+  Documentation/usb/URB.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dabusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PLUSB driver
+CONFIG_USB_PLUSB
+  A driver for the Prolific PL-2302 USB-to-USB network device. This
+  'USB cable' connects two hosts via a point-to-point network with
+  bandwidth of 5 Mbit/s. Configure this driver after connecting the
+  USB cable via ifconfig plusb0 10.0.0.1 pointopoint 10.0.0.2 (and
+  vice versa on the other host).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called plusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Diamond Rio500 support
+CONFIG_USB_RIO500
+  Say Y here if you want to connect a USB Rio500 mp3 player to your
+  computer's USB port. Please read Documentation/usb/rio.txt
+  for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rio500.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+D-Link DSB-R100 FM radio support
+CONFIG_USB_DSBR
+  Say Y here if you want to connect this type of radio to your
+  computer's USB port. Note that the audio is not digital, and
+  you must connect the line out connector to a sound card or a
+  set of speakers.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dsbr100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Microtek USB scanner support
+CONFIG_USB_MICROTEK
+  Say Y here if you want support for the Microtek X6USB and possibly
+  some other scanners by that vendor. The scanner will appear as a
+  scsi generic device to the rest of the system.
+  A patched version of SANE is necessary to use the
+  scanner. It's available at 
+  http://fachschaft.cup.uni-muenchen.de/~neukum/scanner.html
+  This driver can be compiled as a module.
+
+USB Bluetooth support
+CONFIG_USB_BLUETOOTH
+  Say Y here if you want to connect a USB Bluetooth device to your
+  computer's USB port. You will need the Bluetooth stack (available
+  at http://developer.axis.com/software/index.shtml) to fully use
+  the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called bluetooth.o. If you want to compile it as 
+  a module, say M here and read Documentation/modules.txt.
+  
+Kawasaki USB ethernet controller support
+CONFIG_USB_KAWETH
+  Say Y here if you want support for devices based on the Kawasaki
+  LSI KL5KUSB100 USB to Ethernet 1-Chip Controller, such as the
+  NetGear EA101 USB to Ethernet Adapter.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called kaweth.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+ 
+Minix fs support
+CONFIG_MINIX_FS
+  Minix is a simple operating system used in many classes about OS's.
+  The minix filesystem (method to organize files on a hard disk
+  partition or a floppy disk) was the original filesystem for Linux,
+  but has been superseded by the second extended filesystem ext2fs.
+  You don't want to use the minix filesystem on your hard disk because
+  of certain built-in restrictions, but it is sometimes found on older
+  Linux floppy disks. This option will enlarge your kernel by about 
+  25 kB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called minix.o. Note that the filesystem of your root partition (the
+  one containing the directory /) cannot be compiled as a module.
+
+Second extended fs support
+CONFIG_EXT2_FS
+  This is the de facto standard Linux filesystem (method to organize
+  files on a storage device) for hard disks. 
+
+  You want to say Y here, unless you intend to use Linux exclusively
+  from inside a DOS partition using the umsdos filesystem. The
+  advantage of the latter is that you can get away without
+  repartitioning your hard drive (which often implies backing
+  everything up and restoring afterwards); the disadvantage is that
+  Linux becomes susceptible to DOS viruses and that umsdos is somewhat
+  slower than ext2fs. Even if you want to run Linux in this fashion,
+  it might be a good idea to have ext2fs around: it enables you to
+  read more floppy disks and facilitates the transition to a *real*
+  Linux partition later. Another (rare) case which doesn't require
+  ext2fs is a diskless Linux box which mounts all files over the
+  network using NFS (in this case it's sufficient to say Y to "NFS
+  filesystem support" below). Saying Y here will enlarge your kernel
+  by about 41 kB.
+
+  The Ext2fs-Undeletion mini-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini,
+  gives information about how to retrieve deleted files on ext2fs
+  filesystems.
+
+  To change the behavior of ext2 filesystems, you can use the tune2fs
+  utility ("man tune2fs"). To modify attributes of files and
+  directories on ext2 filesystems, use chattr ("man chattr").
+  
+  Ext2fs partitions can be read from within DOS using the ext2tool
+  command line tool package (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/ext2) and from
+  within Windows NT using the ext2nt command line tool package from
+  ftp://metalab.unc.edu/pub/Linux/utils/dos. Explore2fs is a graphical
+  explorer for ext2fs partitions which runs on Windows 95 and Windows
+  NT and includes experimental write support; it is available from
+  http://jnewbigin-pc.it.swin.edu.au/Linux/Explore2fs.htm.
+
+  If you want to compile this filesystem as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called ext2.o. Be aware however that the filesystem of your
+  root partition (the one containing the directory /) cannot be
+  compiled as a module, and so this could be dangerous. Most everyone
+  wants to say Y here.
+
+ISO 9660 CDROM filesystem support
+CONFIG_ISO9660_FS
+  This is the standard filesystem used on CDROMs. It was previously
+  known as "High Sierra Filesystem" and is called "hsfs" on other Unix
+  systems. The so-called Rock-Ridge extensions which allow for long
+  Unix filenames and symbolic links are also supported by this driver.
+  If you have a CDROM drive and want to do more with it than just
+  listen to audio CDs and watch its LEDs, say Y (and read
+  Documentation/filesystems/isofs.txt and the CDROM-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO), thereby enlarging your
+  kernel by about 27 kB; otherwise say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called isofs.o.
+
+Microsoft Joliet cdrom extensions
+CONFIG_JOLIET
+  Joliet is a Microsoft extension for the ISO 9660 CDROM filesystem
+  which allows for long filenames in unicode format (unicode is the
+  new 16 bit character code, successor to ASCII, which encodes the
+  characters of almost all languages of the world; see
+  http://www.unicode.org for more information; to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape). Say Y here if you want to be able to read
+  Joliet CDROMs under Linux.
+
+fat fs support
+CONFIG_FAT_FS
+  If you want to use one of the FAT-based filesystems (the MS-DOS,
+  VFAT (Windows 95) and UMSDOS (used to run Linux on top of an
+  ordinary DOS partition) filesystems), then you must say Y or M here
+  to include FAT support. You will then be able to mount partitions or
+  diskettes with FAT-based filesystems and transparently access the
+  files on them, i.e. MSDOS files will look and behave just like all
+  other Unix files.
+
+  This FAT support is not a filesystem in itself, it only provides the
+  foundation for the other filesystems. You will have to say Y or M to
+  at least one of "msdos fs support" or "vfat fs support" in order to
+  make use of it.
+
+  Another way to read and write MSDOS floppies and hard drive
+  partitions from within Linux (but not transparently) is with the
+  mtools ("man mtools") program suite. This doesn't require the FAT
+  filesystem support.
+
+  It is now also becoming possible to read and write compressed FAT
+  filesystems; read Documentation/filesystems/fat_cvf.txt for details.
+  
+  The FAT support will enlarge your kernel by about 24 kB. If unsure,
+  say Y.
+
+  If you want to compile this as a module however ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called fat.o. Note that if you compile the FAT support as a
+  module, you cannot compile any of the FAT-based filesystems into the
+  kernel -- they will have to be modules as well. The filesystem of
+  your root partition (the one containing the directory /) cannot be a
+  module, so don't say M here if you intend to use UMSDOS as your root
+  filesystem.
+
+msdos fs support
+CONFIG_MSDOS_FS
+  This allows you to mount MSDOS partitions of your hard drive (unless
+  they are compressed; to access compressed MSDOS partitions under
+  Linux, you can either use the DOS emulator DOSEMU, described in the
+  DOSEMU-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, or try dmsdosfs in
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/dosfs. If you
+  intend to use dosemu with a non-compressed MSDOS partition, say Y
+  here) and MSDOS floppies. This means that file access becomes
+  transparent, i.e. the MSDOS files look and behave just like all
+  other Unix files.
+
+  If you want to use umsdos, the Unix-like filesystem on top of DOS,
+  which allows you to run Linux from within a DOS partition without
+  repartitioning, you'll have to say Y or M here. 
+
+  If you have Windows 95 or Windows NT installed on your MSDOS
+  partitions, you should use the VFAT filesystem (say Y to "vfat fs
+  support" below), or you will not be able to see the long filenames
+  generated by Windows 95 / Windows NT.
+
+  This option will enlarge your kernel by about 7 kB. If unsure,
+  answer Y. This will only work if you said Y to "fat fs support" as
+  well. If you want to compile this as a module however ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called msdos.o.
+
+vfat fs support
+CONFIG_VFAT_FS
+  This option provides support for normal Windows filesystems with
+  long filenames. That includes non-compressed FAT-based filesystems
+  used by Windows 95, Windows 98, Windows NT 4.0, and mtools. 
+
+  You cannot use the VFAT filesystem for your Linux root partition
+  (the one containing the directory /); use UMSDOS instead if you
+  want to run Linux from within a DOS partition (i.e. say Y to
+  "umsdos: Unix like fs on top of std MSDOS fs", below).
+
+  The VFAT support enlarges your kernel by about 10 kB and it only
+  works if you said Y to the "fat fs support" above. Please read the
+  file Documentation/filesystems/vfat.txt for details. If unsure, 
+  say Y.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called vfat.o.
+
+umsdos: Unix like fs on top of std MSDOS fs
+CONFIG_UMSDOS_FS
+  Say Y here if you want to run Linux from within an existing DOS
+  partition of your hard drive. The advantage of this is that you can
+  get away without repartitioning your hard drive (which often implies
+  backing everything up and restoring afterwards) and hence you're
+  able to quickly try out Linux or show it to your friends; the
+  disadvantage is that Linux becomes susceptible to DOS viruses and
+  that UMSDOS is somewhat slower than ext2fs. Another use of UMSDOS
+  is to write files with long unix filenames to MSDOS floppies; it
+  also allows Unix-style softlinks and owner/permissions of files on
+  MSDOS floppies. You will need a program called umssync in order to
+  make use of umsdos; read Documentation/filesystems/umsdos.txt. 
+
+  This option enlarges your kernel by about 25 kB and it only works if
+  you said Y to both "fat fs support" and "msdos fs support" above. If
+  you want to compile this as a module ( = code which can be inserted
+  in and removed from the running kernel whenever you want), say M
+  here and read Documentation/modules.txt. The module will be called
+  umsdos.o. Note that the filesystem of your root partition (the one
+  containing the directory /) cannot be a module, so saying M could be
+  dangerous. If unsure, say N.
+
+/proc filesystem support
+CONFIG_PROC_FS
+  This is a virtual filesystem providing information about the status
+  of the system. "Virtual" means that it doesn't take up any space on
+  your hard disk: the files are created on the fly by the kernel when
+  you try to access them. Also, you cannot read the files with older
+  version of the program less: you need to use more or cat. 
+
+  It's totally cool; for example, "cat /proc/interrupts" gives
+  information about what the different IRQs are used for at the moment
+  (there is a small number of Interrupt ReQuest lines in your computer
+  that are used by the attached devices to gain the CPU's attention --
+  often a source of trouble if two devices are mistakenly configured
+  to use the same IRQ). 
+
+  The /proc filesystem is explained in the file
+  Documentation/proc.txt, in the Kernel Hacker's Guide at
+  http://www.redhat.com:8080/HyperNews/get/khg.html on the WWW (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape), and also on the proc(8)
+  manpage ("man 8 proc").
+
+  This option will enlarge your kernel by about 18 KB. Several
+  programs depend on this, so everyone should say Y here.
+
+NFS filesystem support
+CONFIG_NFS_FS
+  If you are connected to some other (usually local) Unix computer
+  (using SLIP, PLIP, PPP or Ethernet) and want to mount files residing
+  on that computer (the NFS server) using the Network File Sharing
+  protocol, say Y. "Mounting files" means that the client can access
+  the files with usual UNIX commands as if they were sitting on the
+  client's hard disk. For this to work, the server must run the
+  programs nfsd and mountd (but does not need to have NFS filesystem
+  support enabled in its kernel). NFS is explained in the Network
+  Administrator's Guide, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/LDP, on its man page: "man
+  nfs", and in the NFS-HOWTO.
+  
+  A superior but less widely used alternative to NFS is provided by
+  the Coda filesystem; see "Coda filesystem support" below.
+
+  If you say Y here, you should have said Y to TCP/IP networking also.
+  This option would enlarge your kernel by about 27 kB. 
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  If you are configuring a diskless machine which will mount its root
+  filesystem over NFS at boot time, say Y here and to "IP: kernel
+  level autoconfiguration" above and to "Root file system on NFS"
+  below. You cannot compile this driver as a module in this case.
+  There are two packages designed for booting diskless machines over
+  the net: netboot and etherboot, both available via FTP from
+  ftp://metalab.unc.edu/pub/Linux/system/boot/ethernet/ .
+
+  If you don't know what all this is about, say N.
+
+Root file system on NFS
+CONFIG_ROOT_NFS
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS (presumably because your box doesn't have a hard disk),
+  say Y. Read Documentation/nfsroot.txt for details. It is likely that
+  in this case, you also want to say Y to "IP: kernel level
+  autoconfiguration" so that your box can discover its network address
+  at boot time.
+  
+  Most people say N here. 
+
+NFS server support
+CONFIG_NFSD
+  If you want your Linux box to act as an NFS *server*, so that other
+  computers on your local network which support NFS can access certain
+  directories on your box transparently, you have two options: you can
+  use the self-contained user space program nfsd, in which case you
+  should say N here, or you can say Y and use the kernel based NFS
+  server. The kernel based solution is faster and is now the recommended
+  solution: no further development is occurring on the userspace server and
+  support of it may be discontinued in future.
+
+  In either case, you will need support software; the respective
+  locations are given in the file Documentation/Changes in the NFS
+  section.
+
+  Please read the NFS-HOWTO, available from
+  http://www.linuxdoc.org/HOWTO/NFS-HOWTO.html .
+
+
+  The NFS server is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfsd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Provide NFSv3 server support (EXPERIMENTAL)
+CONFIG_NFSD_V3
+  If you would like to include the NFSv3 server as well as the NFSv2
+  server, say Y here.  File locking, via the NLMv4 protocol, is now
+  supported. If unsure, say N.
+
+OS/2 HPFS filesystem support (read only)
+CONFIG_HPFS_FS
+  OS/2 is IBM's operating system for PC's, the same as Warp, and HPFS
+  is the filesystem used for organizing files on OS/2 hard disk
+  partitions. Say Y if you want to be able to read files from an OS/2
+  HPFS partition of your hard drive. OS/2 floppies however are in
+  regular MSDOS format, so you don't need this option in order to be
+  able to read them. Read Documentation/filesystems/hpfs.txt. 
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called hpfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Windows NT NTFS support (read only)
+CONFIG_NTFS_FS
+  NTFS is the file system of Microsoft Windows NT. Say Y if you want
+  to get read access to files on NTFS partitions of your hard drive.
+  The Linux NTFS driver supports most of the mount options of the VFAT
+  driver, see Documentation/filesystems/ntfs.txt. Saying Y here will
+  give you read-only access to NTFS partitions.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ntfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+NTFS read-write support (DANGEROUS)
+CONFIG_NTFS_RW
+  If you say Y here, you will (maybe) be able to write to NTFS file
+  systems as well as read from them. The read-write support in
+  NTFS is far from being complete and is not well tested. If you
+  enable this, back up your NTFS volume first since it may get
+  damaged. Also, make sure to run chkdsk from within Microsoft
+  Windows NT after having performed any writes to a NTFS partition
+  from Linux to detect any problems as early as possible.
+  Please note that write support is limited to Windows NT4 and
+  earlier versions.
+
+  If unsure, say N.
+
+System V, Version 7 and Coherent filesystem support
+CONFIG_SYSV_FS
+  SCO, Xenix and Coherent are commercial Unix systems for Intel
+  machines, and Version 7 was used on the DEC PDP-11. Saying Y here
+  would allow you to read to and write from their floppies and hard
+  disk partitions.
+
+  If you have floppies or hard disk partitions like that, it is likely
+  that they contain binaries from those other Unix systems; in order
+  to run these binaries, you will want to install iBCS2 (Intel Binary
+  Compatibility Standard is a kernel module which lets you run SCO,
+  Xenix, Wyse, UnixWare, Dell Unix and System V programs under Linux
+  and is often needed to run commercial software that's only available
+  for those systems. It's available via FTP (user: anonymous) from
+  ftp://tsx-11.mit.edu/pub/linux/BETA).
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the System V filesystem support
+  (but you need NFS filesystem support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar"). Note also that this option has
+  nothing whatsoever to do with the option "System V IPC". Read about
+  the System V filesystem in Documentation/filesystems/sysv-fs.txt.
+  Saying Y here will enlarge your kernel by about 34 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called sysv.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+Amiga FFS filesystem support
+CONFIG_AFFS_FS
+  The Fast File System (FFS) is the common filesystem used on hard
+  disks by Amiga(tm) systems since AmigaOS Version 1.3 (34.20). Say Y
+  if you want to be able to read and write files from and to an Amiga
+  FFS partition on your hard drive. Amiga floppies however cannot be
+  read with this driver due to an incompatibility of the floppy
+  controller used in an Amiga and the standard floppy controller in
+  PCs and workstations. Read Documentation/filesystems/affs.txt and
+  fs/affs/Changes. 
+
+  With this driver you can also mount disk files used by Bernd
+  Schmidt's Un*X Amiga Emulator (http://www.freiburg.linux.de/~uae/;
+  to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape). If you want to
+  do this, you will also need to say Y or M to "Loop device support",
+  above.
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called affs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Apple Macintosh filesystem support (experimental)
+CONFIG_HFS_FS
+  If you say Y here, you will be able to mount Macintosh-formatted
+  floppy disks and hard drive partitions with full read-write access.
+  Please read fs/hfs/HFS.txt to learn about the available mount
+  options. 
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called hfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+ROM filesystem support
+CONFIG_ROMFS_FS
+  This is a very small read-only filesystem mainly intended for
+  initial ram disks of installation disks, but it could be used for
+  other read-only media as well. Read
+  Documentation/filesystems/romfs.txt for details. 
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called romfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4 filesystem support (EXPERIMENTAL)
+CONFIG_QNX4FS_FS  
+  This is the filesystem used by the operating system QNX 4. Say Y if
+  you intend to mount QNX hard disks or floppies. Unless you say Y to
+  "QNX4FS write support" below, you will only be able to read
+  these filesystems.
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called qnx4.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4FS write support (DANGEROUS)
+CONFIG_QNX4FS_RW
+  Say Y if you want to test write support for QNX4 filesystems.
+
+Kernel automounter support
+CONFIG_AUTOFS_FS
+  The automounter is a tool to automatically mount remote filesystems
+  on demand. This implementation is partially kernel-based to reduce
+  overhead in the already-mounted case; this is unlike the BSD
+  automounter (amd), which is a pure user space daemon.
+
+  To use the automounter you need the user-space tools from
+  ftp://ftp.kernel.org/pub/linux/daemons/autofs; you also want to
+  answer Y to "NFS filesystem support", below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called autofs.o. 
+
+  If you are not a part of a fairly large, distributed network, you
+  probably do not need an automounter, and can say N here.
+
+UFS filesystem support
+CONFIG_UFS_FS
+  BSD and derivate versions of Unix (such as SunOS, FreeBSD, NetBSD,
+  OpenBSD and NeXTstep) use a filesystem called UFS. Some System V
+  Unixes can create and mount hard disk partitions and diskettes using
+  this filesystem as well. Saying Y here will allow you to read from
+  these partitions; if you also want to write to them, say Y to the
+  experimental "UFS filesystem write support", below. Please read the
+  file Documentation/filesystems/ufs.txt for more information.
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the UFS filesystem support (but
+  you need NFS filesystem support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar").
+
+  When accessing NeXTstep files, you may need to convert them from the
+  NeXT character set to the Latin1 character set; use the program
+  recode ("info recode") for this purpose. 
+
+  If you want to compile the UFS filesystem support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called ufs.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+UFS filesystem write support (experimental)
+CONFIG_UFS_FS_WRITE
+  Say Y here if you want to try writing to UFS partitions. This is
+  experimental, so you should back up your UFS partitions beforehand.
+
+EFS filesystem support (experimental)
+CONFIG_EFS_FS
+  EFS is the filesystem used for CDROMs and filesystems by SGI's IRIX.
+  This implementation only offers read-only access.  If you don't know
+  what all this is about, it's safe to say N.  For more information
+  about EFS see it's homepage at http://aeschi.ch.eu.org/efs.
+
+SGI disklabel support
+CONFIG_SGI_DISKLABEL
+  Say Y to this only if you plan on mounting disks with SGI disklabels.
+  This is not required to mount EFS-format CDROMs.
+
+BSD disklabel (FreeBSD partition tables) support
+CONFIG_BSD_DISKLABEL
+  FreeBSD uses its own hard disk partition scheme on your PC. It
+  requires only one entry in the primary partition table of your disk
+  and manages it similarly to DOS extended partitions, putting in its
+  first sector a new partition table in BSD disklabel format. Saying Y
+  here allows you to read these disklabels and further mount FreeBSD
+  partitions from within Linux if you have also said Y to "UFS
+  filesystem support", above. If you don't know what all this is
+  about, say N.
+
+SMD disklabel (Sun partition tables) support
+CONFIG_SMD_DISKLABEL
+  Like most systems, SunOS uses its own hard disk partition table
+  format, incompatible with all others. Saying Y here allows you to
+  read these partition tables and further mount SunOS disks from
+  within Linux if you have also said Y to "UFS filesystem support",
+  above. This is mainly used to carry data from a SPARC under SunOS to
+  your Linux box via a removable medium like magneto-optical or ZIP
+  drives; note however that a good portable way to transport files and
+  directories between unixes (and even other operating systems) is
+  given by the tar program ("man tar" or preferably "info tar"). If
+  you don't know what all this is about, say N.
+
+Solaris (x86) partition table support
+CONFIG_SOLARIS_X86_PARTITION
+  Like most systems, Solaris x86 uses its own hard disk partition
+  table format, incompatible with all others. Saying Y here allows you
+  to read these partition tables and further mount Solaris x86 disks
+  from within Linux if you have also said Y to "UFS filesystem
+  support", above.
+
+ADFS filesystem support (read only) (EXPERIMENTAL)
+CONFIG_ADFS_FS
+  The Acorn Disc Filing System is the standard filesystem of the
+  RiscOS operating system which runs on Acorn's ARM-based Risc PC
+  systems and the Acorn Archimedes range of machines. If you say Y
+  here, Linux will be able to read from ADFS partitions on hard drives
+  and from ADFS-formatted floppy discs.
+
+  The ADFS partition should be the first partition (i.e.,
+  /dev/[hs]d?1) on each of your drives.
+
+  This code is also available as a module called adfs.o ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say N.
+
+/dev/pts filesystem for Unix98 PTYs
+CONFIG_DEVPTS_FS
+  You should say Y here if you said Y to "Unix98 PTY support" above.
+  You'll then get a virtual filesystem which can be mounted on
+  /dev/pts with "mount -t devpts". This, together with the pseudo
+  terminal master multiplexer /dev/ptmx, is used for pseudo terminal
+  support as described in The Open Group's Unix98 standard: in order
+  to acquire a pseudo terminal, a process opens /dev/ptmx; the number
+  of the pseudo terminal is then made available to the process and the
+  pseudo terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example. 
+
+  The GNU C library glibc 2.1 contains the requisite support for this
+  mode of operation; you also need client programs that use the Unix98
+  API.
+
+UnixWare slices support (EXPERIMENTAL)
+CONFIG_UNIXWARE_DISKLABEL
+  Like some systems, UnixWare uses its own slice table inside a
+  partition (VTOC - Virtual Table of Contents). Its format is
+  incompatible with all other OSes. Saying Y here allows you to read
+  VTOC and further mount UnixWare partitions read-only from within
+  Linux if you have also said Y to "UFS filesystem support" or "System
+  V and Coherent filesystem support", above.
+
+  This is mainly used to carry data from a UnixWare box to your
+  Linux box via a removable medium like magneto-optical, ZIP or
+  removable IDE drives. Note, however, that a good portable way to
+  transport files and directories between unixes (and even other
+  operating systems) is given by the tar program ("man tar" or
+  preferably "info tar"). 
+
+  If you don't know what all this is about, say N.
+
+Macintosh partition map support
+CONFIG_MAC_PARTITION
+  Say Y here if you want your Linux system to be able to read the
+  partition tables of Macintosh hard drives, and thus use partitions
+  on those drives.
+
+SMB filesystem support (to mount Windows shares etc...)
+CONFIG_SMB_FS
+  SMB (Server Message Block) is the protocol Windows for Workgroups
+  (WfW), Windows 95/98, Windows NT and OS/2 Lan Manager use to share
+  files and printers over local networks. Saying Y here allows you to
+  mount their filesystems (often called "shares" in this context) and
+  access them just like any other Unix directory. Currently, this
+  works only if the Windows machines use TCP/IP as the underlying
+  transport protocol, and not NetBEUI. For details, read
+  Documentation/filesystems/smbfs.txt and the SMB-HOWTO, available via
+  FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note: if you just want your box to act as an SMB *server* and make
+  files and printing services available to Windows clients (which need
+  to have a TCP/IP stack), you don't need to say Y here; you can use
+  the program samba (available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/system/network/samba) for that.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  If you want to compile the SMB support as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called smbfs.o. Most people say N, however.
+
+use nls by default
+CONFIG_SMB_NLS_DEFAULT
+  Enabling this will make smbfs use nls translations by default. You
+  need to specify the local charset (CONFIG_NLS_DEFAULT) in the nls
+  settings and you need to give the default nls for the SMB server as
+  CONFIG_SMB_NLS_REMOTE.
+
+nls support setting
+CONFIG_SMB_NLS_REMOTE
+  This setting allows you to specify a default value for which
+  codepage the server uses. If this field is left blank no
+  translations will be done. The local codepage/charset default to
+  CONFIG_NLS_DEFAULT, you need to set that value in the NLS menu.
+
+Coda filesystem support
+CONFIG_CODA_FS
+  Coda is an advanced network filesystem, similar to NFS in that it
+  enables you to mount filesystems of a remote server and access them
+  with regular Unix commands as if they were sitting on your hard
+  disk. Coda has several advantages over NFS: support for disconnected
+  operation (e.g. for laptops), read/write server replication,
+  security model for authentication and encryption, persistent client
+  caches and write back caching.
+
+  If you say Y here, your Linux box will be able to act as a Coda
+  *client*. You will need user level code as well, both for the client
+  and server. Servers are currently user level, i.e. need no kernel
+  support. Please read Documentation/filesystems/coda.txt and check
+  out the Coda home page http://www.coda.cs.cmu.edu (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape).
+
+  If you want to compile the coda client support as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called coda.o. 
+
+NCP filesystem support (to mount NetWare volumes)
+CONFIG_NCP_FS
+  NCP (NetWare Core Protocol) is a protocol that runs over IPX and is
+  used by Novell NetWare clients to talk to file servers. It is to IPX
+  what NFS is to TCP/IP, if that helps. Saying Y here allows you to
+  mount NetWare file server volumes and to access them just like any
+  other Unix directory. For details, please read the file
+  Documentation/filesystems/ncpfs.txt in the kernel source and the
+  IPX-HOWTO on ftp://metalab.unc.edu/pub/Linux/docs/howto.
+
+  You do not have to say Y here if you want your Linux box to act as a
+  file *server* for Novell NetWare clients.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ncpfs.o. Say N unless you are connected to a Novell network.
+
+Packet signatures
+CONFIG_NCPFS_PACKET_SIGNING
+  NCP allows packets to be signed for stronger security. If you want
+  security, say Y. Normal users can leave it off. To be able to use
+  packet signing you must use ncpfs > 2.0.12.
+
+Proprietary file locking
+CONFIG_NCPFS_IOCTL_LOCKING
+  Allows locking of records on remote volumes. Say N unless you have
+  special applications which are able to utilize this locking scheme.
+
+Clear remove/delete inhibit when needed
+CONFIG_NCPFS_STRONG
+  Allows manipulation of files flagged as Delete or Rename Inhibit. To
+  use this feature you must mount volumes with the ncpmount parameter
+  "-s" (ncpfs-2.0.12 and newer). Say Y unless you are not mounting
+  volumes with -f 444.
+
+Use NFS namespace when available
+CONFIG_NCPFS_NFS_NS
+  Allows you to utilize NFS namespace on NetWare servers. It brings
+  you case sensitive filenames. Say Y. You can disable it at
+  mount-time with the `-N nfs' parameter of ncpmount.
+
+Use OS2/LONG namespace when available
+CONFIG_NCPFS_OS2_NS
+  Allows you to utilize OS2/LONG namespace on NetWare servers.
+  Filenames in this namespace are limited to 255 characters, they are
+  case insensitive, and case in names is preserved. Say Y. You can
+  disable it at mount time with the -N os2 parameter of ncpmount.
+
+Lowercase DOS filenames on LONG namespace volume
+CONFIG_NCPFS_SMALLDOS
+  If you say Y here, every filename on a NetWare server volume using
+  the OS2/LONG namespace will be converted to lowercase characters.
+  (For regular NetWare file server volumes with DOS namespace, this is
+  done automatically, even if you say N here.) Saying N here will give
+  you these filenames in uppercase.
+  
+  This is only a cosmetic option since the OS2/LONG namespace is case
+  insensitive. The only major reason for this option is backward
+  compatibility when moving from DOS to OS2/LONG namespace support.
+  Long filenames (created by Win95) will not be affected.
+
+  This option does not solve the problem that filenames appear
+  differently under Linux and under Windows, since Windows does an
+  additional conversions on the client side. You can achieve similar
+  effects by saying Y to "Allow using of Native Language Support"
+  below.
+
+Allow mounting of volume subdirectories
+CONFIG_NCPFS_MOUNT_SUBDIR
+  Allows you to mount not only whole servers or whole volumes, but
+  also subdirectories from a volume. It can be used to reexport data
+  and so on. There is no reason to say N, so Y is recommended unless
+  you count every byte.
+
+  To utilize this feature you must use ncpfs-2.0.12 or newer.
+
+NDS interserver authentication domains
+CONFIG_NCPFS_NDS_DOMAINS
+  This allows storing NDS private keys in kernel space where they
+  can be used to authenticate another server as interserver NDS
+  accesses need it. You must use ncpfs-2.0.12.1 or newer to utilize
+  this feature. Say Y if you are using NDS connections to NetWare
+  servers. Do not say Y if security is primary for you because root
+  can read your session key (from /proc/kcore).
+
+Allow using of Native Language Support
+CONFIG_NCPFS_NLS
+  Allows you to use codepages and I/O charsets for file name
+  translation between the server file system and input/output. This
+  may be useful, if you want to access the server with other operating
+  systems, e.g. Windows 95. See also NLS for more Information.
+
+  To select codepages and I/O charsets use ncpfs-2.2.0.13 or newer.
+
+Symbolic links and mode permission bits
+CONFIG_NCPFS_EXTRAS
+  This enables the use of symbolic links and an execute permission
+  bit on NCPFS. The file server need not have long name space or NFS
+  name space loaded for these to work.
+
+  To use the new attributes, it is recommended to use the flags
+  '-f 600 -d 755' on the ncpmount command line.
+
+nls default codepage
+CONFIG_NLS_DEFAULT
+  The default NLS used when mounting filesystem. Currently, the valid
+  values are cp437, cp737, cp775, cp850, cp852, cp855, cp857, cp860,
+  cp861, cp862, cp863, cp864, cp865, cp866, cp869, cp874, cp932, cp936,
+  cp949, cp950, iso8859-1, iso8859-2, iso8859-3, iso8859-4, iso8859-5,
+  iso8859-6, iso8859-7, iso8859-8, iso8859-9, iso8859-14, iso8859-15, 
+  koi8-r.  If you specify a wrong value, it will use the built-in NLS; 
+  compatible with iso8859-1.
+
+  If unsure, specify it as "cp437".
+
+nls codepage 437
+CONFIG_NLS_CODEPAGE_437
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used in
+  the United States and parts of Canada. This is recommended.
+
+nls codepage 737
+CONFIG_NLS_CODEPAGE_737
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  Greek. If unsure, say N.
+
+nls codepage 775
+CONFIG_NLS_CODEPAGE_775
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used
+  for the Baltic Rim Languages. If unsure, say N.
+
+nls codepage 850
+CONFIG_NLS_CODEPAGE_850
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  much of Europe -- United Kingdom, Germany, Spain, Italy, and [add
+  more countries here]. It has some characters useful to many European
+  languages that are not part of the US codepage 437. 
+
+  If unsure, say Y.
+
+nls codepage 852
+CONFIG_NLS_CODEPAGE_852
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the Latin 2 codepage used by DOS
+  for much of Central and Eastern Europe. It has all the required
+  characters for these languages: Albanian, Croatian, Czech, English,
+  Finnish, Hungarian, Irish, German, Polish, Romanian, Serbian (Latin
+  transcription), Slovak, Slovenian, and Sorbian.
+
+nls codepage 855
+CONFIG_NLS_CODEPAGE_855
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Cyrillic.
+
+nls codepage 857
+CONFIG_NLS_CODEPAGE_857
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Turkish.
+
+nls codepage 860
+CONFIG_NLS_CODEPAGE_860
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Portuguese.
+
+nls codepage 861
+CONFIG_NLS_CODEPAGE_861
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Icelandic.
+
+nls codepage 862
+CONFIG_NLS_CODEPAGE_862
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Hebrew.
+
+nls codepage 863
+CONFIG_NLS_CODEPAGE_863
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Canadian
+  French.
+
+nls codepage 864
+CONFIG_NLS_CODEPAGE_864
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Arabic.
+
+nls codepage 865
+CONFIG_NLS_CODEPAGE_865
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for the Nordic
+  European countries.
+
+nls codepage 866
+CONFIG_NLS_CODEPAGE_866
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for
+  Cyrillic/Russian.
+
+nls codepage 869
+CONFIG_NLS_CODEPAGE_869
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Greek.
+###
+### Why do we have two codepages for Greek and Cyrillic?
+###
+
+nls codepage 874
+CONFIG_NLS_CODEPAGE_874
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Thai.
+
+nls codepage 932
+CONFIG_NLS_CODEPAGE_932
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Shift-JIS.
+
+nls codepage 936
+CONFIG_NLS_CODEPAGE_936
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Simplified
+  Chinese(GBK).
+
+nls codepage 949
+CONFIG_NLS_CODEPAGE_949
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for UHC.
+
+nls codepage 950
+CONFIG_NLS_CODEPAGE_950
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Traditional
+  Chinese(Big5).
+
+nls iso8859-1
+CONFIG_NLS_ISO8859_1
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 1 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Faeroese, Finnish, French, German,
+  Galician, Irish, Icelandic, Italian, Norwegian, Portuguese, Spanish,
+  and Swedish. It is also the default for the US. If unsure, say Y.
+
+nls iso8859-2
+CONFIG_NLS_ISO8859_2
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 2 character
+  set, which works for most Latin-written Slavic and Central European
+  languages: Czech, German, Hungarian, Polish, Rumanian, Croatian,
+  Slovak, Slovene.
+
+nls iso8859-3
+CONFIG_NLS_ISO8859_3
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 3 character
+  set, which is popular with authors of Esperanto, Galician, Maltese,
+  and Turkish.
+
+nls iso8859-4
+CONFIG_NLS_ISO8859_4
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 4 character
+  set which introduces letters for Estonian, Latvian, and
+  Lithuanian. It is an incomplete predecessor of Latin 6.
+
+nls iso8859-5
+CONFIG_NLS_ISO8859_5
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-5, a Cyrillic
+  character set with which you can type Bulgarian, Byelorussian,
+  Macedonian, Russian, Serbian, and Ukrainian. Note that the charset
+  KOI8-R is preferred in Russia.
+
+nls iso8859-6
+CONFIG_NLS_ISO8859_6
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-6, the Arabic
+  character set.
+
+nls iso8859-7
+CONFIG_NLS_ISO8859_7
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-7, the Modern
+  Greek character set.
+
+nls iso8859-8
+CONFIG_NLS_ISO8859_8
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-8, the Hebrew
+  character set.
+
+nls iso8859-9
+CONFIG_NLS_ISO8859_9
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 5 character
+  set, and it replaces the rarely needed Icelandic letters in Latin 1
+  with the Turkish ones. Useful in Turkey.
+
+nls iso8859-10
+CONFIG_NLS_ISO8859_10
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 6 character
+  set, which adds the last Inuit (Greenlandic) and Sami (Lappish)
+  letters that were missing in Latin 4 to cover the entire Nordic
+  area.
+
+nls iso8859-14
+CONFIG_NLS_ISO8859_14
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 8 character
+  set, which adds the last accented vowels for Welsh (and Manx Gaelic)
+  that were missing in Latin 1. http://linux.speech.cymru.org/
+  has further information.
+
+nls iso8859-15
+CONFIG_NLS_ISO8859_15
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 9 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Estonian, Faeroese, Finnish,
+  French, German, Galician, Irish, Icelandic, Italian, Norwegian,
+  Portuguese, Spanish, and Swedish. Latin 9 is an update to
+  Latin 1 (ISO 8859-1) that removes a handful of rarely used
+  characters and instead adds support for Estonian, corrects the
+  support for French and Finnish, and adds the new Euro character.  If
+  unsure, say Y.
+
+nls koi8-r
+CONFIG_NLS_KOI8_R
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the preferred Russian
+  character set.
+
+Virtual terminal
+CONFIG_VT
+  If you say Y here, you will get support for terminal devices with
+  display and keyboard devices. These are called "virtual" because you
+  can run several virtual terminals (also called virtual consoles) on
+  one physical terminal. This is rather useful, for example one
+  virtual terminal can collect system messages and warnings, another
+  one can be used for a text-mode user session, and a third could run
+  an X session, all in parallel. Switching between virtual terminals
+  is done with certain key combinations, usually Alt-<function key>.
+
+  The setterm command ("man setterm") can be used to change the
+  properties (such as colors) of a virtual terminal.
+
+  You need at least one virtual terminal device in order to make use
+  of your keyboard and monitor. Therefore, only people configuring an
+  embedded system would want to say N here in order to save some
+  memory; the only way to log into such a system is then via a serial
+  or network connection.
+
+  If unsure, say Y, or else you won't be able to do much with your new
+  shiny Linux system :-)
+
+Support for console on virtual terminal
+CONFIG_VT_CONSOLE
+  The system console is the device which receives all kernel messages
+  and warnings and which allows logins in single user mode. If you
+  answer Y here, a virtual terminal (the device used to interact with
+  a physical terminal) can be used as system console. This is the most
+  common mode of operations, so you should say Y here unless you want
+  the kernel messages be output only to a serial port (in which case
+  you should say Y to "Console on serial port", below).
+
+  If you do say Y here, by default the currently visible virtual
+  terminal (/dev/tty0) will be used as system console. You can change
+  that with a kernel command line option such as "console=tty3" which
+  would use the third virtual terminal as system console. (Try "man
+  bootparam" or see the documentation of your boot loader (lilo or
+  loadlin) about how to pass options to the kernel at boot time. The
+  lilo procedure is also explained in the SCSI-HOWTO, available via
+  FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+
+  If unsure, say Y.
+
+Software generated cursor
+CONFIG_SOFTCURSOR
+  If you say Y here, you'll be able to do lots of nice things with the
+  cursors of your virtual consoles -- for example turn them into
+  non-blinking block cursors which are more visible on laptop screens,
+  or change their colors depending on the virtual console they're on.
+  See Documentation/VGA-softcursor.txt for more information.
+
+Support for PowerMac keyboard
+CONFIG_MAC_KEYBOARD
+  This option allows you to use an ADB keyboard attached to your
+  machine. Note that this disables any other (ie. PS/2) keyboard
+  support, even if your machine is physically capable of using both at
+  the same time.
+  
+  If you use an ADB keyboard (4 pin connector), say Y here.
+  If you use a PS/2 keyboard (6 pin connector), say N here.
+
+Standard/generic serial support
+CONFIG_SERIAL
+  This selects whether you want to include the driver for the standard
+  serial ports. The standard answer is Y. People who might say N here
+  are those that are setting up dedicated Ethernet WWW/FTP servers, or
+  users that have one of the various bus mice instead of a serial
+  mouse and don't intend to use their machine's standard serial port
+  for anything. (Note that the Cyclades and Stallion multi serial port
+  drivers do not need this driver built in for them to work.)
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called serial.o.
+  [WARNING: Do not compile this driver as a module if you are using
+  non-standard serial ports, since the configuration information will
+  be lost when the driver is unloaded. This limitation may be lifted
+  in the future.]
+
+  BTW1: If you have a mouseman serial mouse which is not recognized by
+  the X window system, try running gpm first. 
+  
+  BTW2: If you intend to connect a so-called Winmodem to your
+  machine's serial port, forget it. These modems are crippled and
+  require proprietary drivers which are only available under Windows.
+
+  Most people will say Y or M here, so that they can use serial mice,
+  modems and similar devices connecting to the standard serial ports.
+
+Support for console on serial port
+CONFIG_SERIAL_CONSOLE
+  If you say Y here, it will be possible to use a serial port as the
+  system console (the system console is the device which receives all
+  kernel messages and warnings and which allows logins in single user
+  mode). This could be useful if some terminal or printer is connected
+  to that serial port.
+
+  Even if you say Y here, the currently visible virtual console
+  (/dev/tty0) will still be used as the system console by default, but
+  you can alter that using a kernel command line option such as
+  "console=ttyS1". (Try "man bootparam" or see the documentation of
+  your boot loader (lilo or loadlin) about how to pass options to the
+  kernel at boot time. The lilo procedure is also explained in the
+  SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.) 
+
+  If you don't have a VGA card installed and you say Y here, the
+  kernel will automatically use the first serial line, /dev/ttyS0, as
+  system console.
+
+  If unsure, say N.
+
+Support for PowerMac serial ports
+CONFIG_MAC_SERIAL
+  If you have Macintosh style serial ports (8 pin mini-DIN), say Y
+  here. If you also have regular serial ports and enable the driver
+  for them, you can't currently use the serial console feature.
+
+Comtrol Rocketport support
+CONFIG_ROCKETPORT
+  This is a driver for the Comtrol Rocketport cards which provide
+  multiple serial ports. You would need something like this to connect
+  more than two modems to your Linux box, for instance in order to
+  become a dial-in server.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called rocket.o.
+
+Digiboard Intelligent async support
+CONFIG_DIGIEPCA
+  This is a driver for Digi International's Xx, Xeve, and Xem series
+  of cards which provide multiple serial ports. You would need
+  something like this to connect more than two modems to your Linux
+  box, for instance in order to become a dial-in server. This driver
+  supports the original PC (ISA) boards as well as PCI, and EISA. If
+  you have a card like this, say Y here and read the file
+  Documentation/digiepca.txt.
+
+  NOTE: There is another, separate driver for the Digiboard PC boards:
+  "Digiboard PC/Xx Support" below. You should (and can) only select
+  one of the two drivers. 
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called epca.o.
+
+Digiboard PC/Xx Support
+CONFIG_DIGI
+  This is a driver for the Digiboard PC/Xe, PC/Xi, and PC/Xeve cards
+  that give you many serial ports. You would need something like this
+  to connect more than two modems to your Linux box, for instance in
+  order to become a dial-in server. If you have a card like that, say
+  Y here and read the file Documentation/digiboard.txt.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called pcxx.o.
+
+SDL RISCom/8 card support
+CONFIG_RISCOM8
+  This is a driver for the SDL Communications RISCom/8 multiport card,
+  which gives you many serial ports. You would need something like
+  this to connect more than two modems to your Linux box, for instance
+  in order to become a dial-in server. If you have a card like that,
+  say Y here and read the file Documentation/riscom8.txt.
+
+  Also it's possible to say M here and compile this driver as kernel
+  loadable module; the module will be called riscom8.o.
+
+Specialix IO8+ card support
+CONFIG_SPECIALIX
+  This is a driver for the Specialix IO8+ multiport card (both the
+  ISA and the PCI version) which gives you many serial ports. You 
+  would need something like this to connect more than two modems to 
+  your Linux box, for instance in order to become a dial-in server.
+
+  If you have a card like that, say Y here and read the file
+  Documentation/specialix.txt. Also it's possible to say M here and
+  compile this driver as kernel loadable module which will be called
+  specialix.o.
+
+Specialix DTR/RTS pin is RTS
+CONFIG_SPECIALIX_RTSCTS
+  The Specialix card can only support either RTS or DTR. If you say N
+  here, the driver will use the pin as "DTR" when the tty is in
+  software handshake mode. If you say Y here or hardware handshake is
+  on, it will always be RTS. Read the file Documentation/specialix.txt
+  for more information.
+
+Specialix SX card support
+CONFIG_SX
+  This is a driver for the Specialix SX multiport card (both the
+  ISA and the PCI version of both the older SI/XIO and the newer SX
+  variants of the card) which gives you many serial ports. You
+  would need something like this to connect more than two modems to 
+  your Linux box, for instance in order to become a dial-in server.
+  You will also need the specialix_sxtools package to be able to 
+  initialize and use the SX system. This driver does NOT support 
+  the rev 1 cards (+/- 1990), or the EISA version of the card. Sorry.
+
+  If you have one of these cards, say Y here and read the file
+  Documentation/sx.txt. Also it's possible to say M here and
+  compile this driver as kernel loadable module which will be called
+  sx.o.
+
+Specialix RIO system support
+CONFIG_RIO
+  This is a driver for the Specialix RIO hostcard (both the
+  ISA and the PCI versions of the card). This hostcard allows you
+  to connect many remote terminal adapters, each supporting 8 or 16
+  serial ports. These cards are ideal if you have more than 100 
+  terminals that need to be connected to your server. (But don't 
+  worry if you have only 32 ports.... That works too). You will 
+  also need the specialix_riotools to be able to initialize and
+  configure your rio system.  
+
+  If you have one of these cards, say Y here. Also it's possible to 
+  say M here and compile this driver as kernel loadable module which 
+  will be called rio.o.
+
+Specialix OLD RIO/PCI support 
+CONFIG_RIO_OLDPCI
+  This turns on support for the older PCI card. If you include
+  this support, performance on the newer cards will suffer a bit.
+
+  If you have one of these cards, say Y here.
+
+Cyclades async mux support
+CONFIG_CYCLADES
+  This is a driver for a card that gives you many serial ports. You
+  would need something like this to connect more than two modems to
+  your Linux box, for instance in order to become a dial-in server.
+  For information about the Cyclades-Z card, read
+  drivers/char/README.cycladesZ.
+
+  As of 1.3.9x kernels, this driver's minor numbers start at 0 instead
+  of 32.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called cyclades.o. 
+
+  If you haven't heard about it, it's safe to say N.
+
+Cyclades-Z interrupt mode operation (EXPERIMENTAL)
+CONFIG_CYZ_INTR
+  The Cyclades-Z family of multiport cards allows 2 (two) driver
+  op modes: polling and interrupt. In polling mode, the driver will
+  check the status of the Cyclades-Z ports every certain amount of
+  time (which is called polling cycle and is configurable). In
+  interrupt mode, it will use an interrupt line (IRQ) in order to check
+  the status of the Cyclades-Z ports. The default op mode is polling.
+  If unsure, say N.
+
+Stallion multiport serial support 
+CONFIG_STALDRV
+  Stallion cards give you many serial ports. You would need something
+  like this to connect more than two modems to your Linux box, for
+  instance in order to become a dial-in server. If you say Y here, you
+  will be asked for your specific card model in the next questions.
+  Make sure to read drivers/char/README.stallion in this case. If you
+  have never heard about all this, it's safe to say N.
+
+Stallion EasyIO or EC8/32 support 
+CONFIG_STALLION
+  If you have an EasyIO or EasyConnection 8/32 multiport Stallion
+  card, then this is for you; say Y. Make sure to read
+  Documentation/stallion.txt. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called stallion.o.
+
+Stallion EC8/64, ONboard, Brumby support
+CONFIG_ISTALLION
+  If you have an EasyConnection 8/64, ONboard, Brumby or Stallion
+  serial multiport card, say Y here. Make sure to read
+  Documentation/stallion.txt. 
+
+  To compile it as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  istallion.o.
+
+Microgate SyncLink adapter support
+CONFIG_SYNCLINK
+  Provides support for the SyncLink ISA and PCI
+  multiprotocol serial adapters. These adapters
+  support asynchronous and HDLC bit synchronous
+  communication up to 10Mbps (PCI adapter).
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called synclink.o. If you want to do that, say M
+  here.
+
+Synchronous HDLC line discipline support
+CONFIG_N_HDLC
+  Allows synchronous HDLC communications with
+  tty device drivers that support synchronous
+  HDLC such as the Microgate SyncLink adapter.
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called n_hdlc.o. If you want to do that, say M
+  here.
+
+Hayes ESP serial port support
+CONFIG_ESPSERIAL
+  This is a driver which supports Hayes ESP serial ports. Both single
+  port cards and multiport cards are supported. Make sure to read
+  Documentation/hayes-esp.txt. 
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called esp.o.
+  If unsure, say N.
+
+Multi-Tech multiport card support
+CONFIG_ISI
+  This is a driver for the Multi-Tech cards which provide several
+  serial ports. The driver is experimental and can currently only be
+  built as a module ( = code which can be inserted in and removed from
+  the running kernel whenever you want). Please read
+  Documentation/modules.txt. The module will be called isicom.o
+
+Unix98 PTY support
+CONFIG_UNIX98_PTYS
+  A pseudo terminal (PTY) is a software device consisting of two
+  halves: a master and a slave. The slave device behaves identical to
+  a physical terminal; the master device is used by a process to
+  read data from and write data to the slave, thereby emulating a
+  terminal. Typical programs for the master side are telnet servers
+  and xterms.
+  
+  Linux has traditionally used the BSD-like names /dev/ptyxx for
+  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme
+  has a number of problems. The GNU C library glibc 2.1 and later,
+  however, supports the Unix98 naming standard: in order to acquire a
+  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo
+  terminal is then made available to the process and the pseudo
+  terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
+
+  The entries in /dev/pts/ are created on the fly by a virtual
+  filesystem; therefore, if you say Y here you should say Y to
+  "/dev/pts filesystem for Unix98 PTYs" as well.
+
+  If you want to say Y here, you need to have the C library glibc 2.1
+  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
+  Read the instructions in Documentation/Changes pertaining to pseudo
+  terminals. It's safe to say N.
+
+Maximum number of Unix98 PTYs in use (0-2048)
+CONFIG_UNIX98_PTY_COUNT
+  The maximum number of Unix98 PTYs that can be used at any one time.
+  The default is 256, and should be enough for desktop systems. Server
+  machines which support incoming telnet/rlogin/ssh connections and/or
+  serve several X terminals may want to increase this: every incoming
+  connection and every xterm uses up one PTY.
+
+  When not in use, each additional set of 256 PTYs occupy
+  approximately 8 KB of kernel memory on 32-bit architectures.
+
+Parallel printer support
+CONFIG_PRINTER
+  If you intend to attach a printer to the parallel port of your Linux
+  box (as opposed to using a serial printer; if the connector at the
+  printer has 9 or 25 holes ["female"], then it's serial), say Y. Also
+  read the Printing-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  It is possible to share one parallel port among several devices
+  (e.g. printer and ZIP drive) and it is safe to compile the
+  corresponding drivers into the kernel. If you want to compile this
+  driver as a module however ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called lp.o. 
+
+  If you have several parallel ports, you can specify which ports to
+  use with the "lp" kernel command line option. (Try "man bootparam"
+  or see the documentation of your boot loader (lilo or loadlin)
+  about how to pass options to the kernel at boot time. The lilo
+  procedure is also explained in the SCSI-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+  The syntax of the "lp" command line option can be found in
+  drivers/char/lp.c.
+
+  If you have more than 3 printers, you need to increase the LP_NO
+  variable in lp.c.
+
+Support IEEE1284 status readback
+CONFIG_PRINTER_READBACK
+  If your printer conforms to IEEE 1284, it may be able to provide a
+  status indication when you read from it (for example, with `cat
+  /dev/lp1'). To use this feature, say Y here.
+
+Mouse Support (not serial mice)
+CONFIG_MOUSE
+  This is for machines with a bus mouse or a PS/2 mouse as opposed to
+  a serial mouse. Most people have a regular serial MouseSystem or
+  Microsoft mouse (made by Logitech) that plugs into a COM port
+  (rectangular with 9 or 25 pins). These people say N here. If you
+  have something else, read the Busmouse-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and
+  say Y here.
+
+  If you have a laptop, you either have to check the documentation or
+  experiment a bit to find out whether the trackball is a serial mouse
+  or not; it's best to say Y here for you. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-serial mice. If unsure, say Y.
+
+Logitech busmouse support
+CONFIG_BUSMOUSE
+  Logitech mouse connected to a proprietary interface card. It's
+  generally a round connector with 9 pins. Note that the newer mice
+  made by Logitech don't use the Logitech protocol anymore; for those,
+  you don't need this option. You want to read the Busmouse-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called busmouse.o. If you are unsure, say N and read the HOWTO
+  nevertheless: it will tell you what you have.
+
+PS/2 mouse (aka "auxiliary device") support
+CONFIG_PSMOUSE
+  The PS/2 mouse connects to a special mouse port that looks much like
+  the keyboard port (small circular connector with 6 pins). This way,
+  the mouse does not use any serial ports. This port can also be used
+  for other input devices like light pens, tablets, keypads. Compaq,
+  AST and IBM all use this as their mouse port on currently shipping
+  machines. The trackballs of some laptops are PS/2 mice also. In
+  particular, the C&T 82C710 mouse on TI Travelmates is a PS/2 mouse.
+
+  Although PS/2 mice are not technically bus mice, they are explained
+  in detail in the Busmouse-HOWTO, available via FTP (user: anonymous)
+  in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  When using a PS/2 mouse, you can get problems if you want to use the
+  mouse both on the Linux console and under X. Using the "-R" option
+  of the Linux mouse managing program gpm (available from
+  ftp://metalab.unc.edu/pub/Linux/system/Daemons) solves this
+  problem, or you can get the "mconv" utility also from metalab.
+
+C&T 82C710 mouse port support (as on TI Travelmate)
+CONFIG_82C710_MOUSE
+  This is a certain kind of PS/2 mouse used on the TI Travelmate. If
+  you are unsure, try first to say N here and come back if the mouse
+  doesn't work. Read the Busmouse-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+PC110 digitizer pad support
+CONFIG_PC110_PAD
+  This drives the digitizer pad on the IBM PC110 palmtop (see
+  http://toy.cabi.net; to browse the WWW, you need to have access to a
+  machine on the Internet that has a program like lynx or
+  netscape). It can turn the digitizer pad into a PS/2 mouse emulation
+  with tap gestures or into an absolute pad. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pc110pad.o.
+
+Microsoft busmouse support
+CONFIG_MS_BUSMOUSE
+  These animals (also called Inport mice) are connected to an
+  expansion board using a round connector with 9 pins. If this is what
+  you have, say Y and read the Busmouse-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have. Also be aware that several vendors talk
+  about 'Microsoft busmouse' and actually mean PS/2 busmouse -- so
+  count the pins on the connector.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called msbusmouse.o. 
+
+ATIXL busmouse support
+CONFIG_ATIXL_BUSMOUSE
+  This is a rare type of busmouse that is connected to the back of an
+  ATI video card. Note that most ATI mice are actually Microsoft
+  busmice. Read the Busmouse-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called atixlmouse.o. 
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have.
+
+Support for PowerMac ADB mouse
+CONFIG_ADBMOUSE
+  If you have an ADB mouse (4 pin connector) as is common on
+  Macintoshes, say Y here.
+
+QIC-02 tape support
+CONFIG_QIC02_TAPE
+  If you have a non-SCSI tape drive like that, say Y. Or, if you want
+  to compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  tpqic02.o.
+
+Do you want runtime configuration for QIC-02
+CONFIG_QIC02_DYNCONF
+  You can either configure this driver once and for all by editing a
+  header file (include/linux/tpqic02.h), in which case you should
+  say N, or you can fetch a program via anonymous FTP which is able
+  to configure this driver during runtime. The program to do this is
+  called 'qic02conf' and it is part of the tpqic02-support-X.Y.tar.gz
+  support package.
+
+  If you want to use the qic02conf program, say Y.
+
+Floppy tape drive (QIC-80/40/3010/3020/TR-1/TR-2/TR-3) support
+CONFIG_FTAPE
+  If you have a tape drive that is connected to your floppy
+  controller, say Y here. 
+
+  Some tape drives (like the Seagate "Tape Store 3200" or the Iomega
+  "Ditto 3200" or the Exabyte "Eagle TR-3") come with a "high speed"
+  controller of their own. These drives (and their companion
+  controllers) are also supported if you say Y here. 
+
+  If you have a special controller (such as the CMS FC-10, FC-20,
+  Mountain Mach-II, or any controller that is based on the Intel 82078
+  FDC like the high speed controllers by Seagate and Exabyte and
+  Iomega's "Ditto Dash") you must configure it by selecting the
+  appropriate entries from the "Floppy tape controllers" sub-menu
+  below and possibly modify the default values for the IRQ and DMA
+  channel and the IO base in ftape's configuration menu. 
+
+  If you want to use your floppy tape drive on a PCI-bus based system,
+  please read the file drivers/char/ftape/README.PCI. 
+
+  The ftape kernel driver is also available as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. The module
+  will be called ftape.o. 
+
+  Note that the Ftape-HOWTO is out of date (sorry) and documents the
+  older version 2.08 of this software but still contains useful
+  information. There is a web page with more recent documentation at
+  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ . This page
+  always contains the latest release of the ftape driver and useful
+  information (backup software, ftape related patches and
+  documentation, FAQ). (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape.)
+  Note that the file system interface has changed quite a bit compared
+  to previous versions of ftape. Please read Documentation/ftape.txt.
+
+The file system interface for ftape
+CONFIG_ZFTAPE
+  Normally, you want to say Y or M. DON'T say N here or you
+  WON'T BE ABLE TO USE YOUR FLOPPY TAPE DRIVE.
+
+  The ftape module itself no longer contains the routines necessary
+  to interface with the kernel VFS layer (i.e. to actually write data
+  to and read data from the tape drive). Instead the file system
+  interface (i.e. the hardware independent part of the driver) has
+  been moved to a separate module.
+
+  If you say M zftape will be compiled as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). In this case you should read
+  Documentation/modules.txt. The module will be called zftape.o.
+
+  Regardless of whether you say Y or M here, an additional runtime
+  loadable module called `zft-compressor.o' which contains code to
+  support user transparent on-the-fly compression based on Ross
+  William's lzrw3 algorithm will be produced. If you have enabled the
+  kernel module loader (i.e. have said Y to "Kernel module loader
+  support", above) then `zft-compressor.o' will be loaded
+  automatically by zftape when needed.
+
+  Despite its name, zftape does NOT use compression by default. The
+  file Documentation/ftape.txt contains a short description of the
+  most important changes in the file system interface compared to
+  previous versions of ftape. The ftape home page
+  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ contains
+  further information (to browse the WWW, you need to have access to a
+  machine on the Internet that has a program like lynx or netscape).
+
+  IMPORTANT NOTE: zftape can read archives created by previous
+  versions of ftape and provide file mark support (i.e. fast skipping
+  between tape archives) but previous version of ftape will lack file
+  mark support when reading archives produced by zftape.
+
+Default block size for zftape
+CONFIG_ZFT_DFLT_BLK_SZ
+  If unsure leave this at its default value, i.e. 10240. Note that
+  you specify only the default block size here. The block size can be
+  changed at run time using the MTSETBLK tape operation with the
+  MTIOCTOP ioctl (i.e. with "mt -f /dev/qft0 setblk #BLKSZ" from the
+  shell command line).
+
+  The probably most striking difference between zftape and previous
+  versions of ftape is the fact that all data must be written or read
+  in multiples of a fixed block size. The block size defaults to
+  10240 which is what GNU tar uses. The values for the block size
+  should be either 1 or multiples of 1024 up to a maximum value of
+  63488 (i.e. 62 K). If you specify `1' then zftape's builtin
+  compression will be disabled.
+
+  Reasonable values are `10240' (GNU tar's default block size),
+  `5120' (afio's default block size), `32768' (default block size some
+  backup programs assume for SCSI tape drives) or `1' (no restriction
+  on block size, but disables builtin compression).
+
+Number of DMA buffers
+CONFIG_FT_NR_BUFFERS
+  Please leave this at `3' unless you REALLY know what you are doing.
+  It is not necessary to change this value. Values below 3 make the
+  proper use of ftape impossible, values greater than 3 are a waste of
+  memory. You can change the amount of DMA memory used by ftape at
+  runtime with "mt -f /dev/qft0 setdrvbuffer #NUMBUFFERS". Each buffer
+  wastes 32 KB of memory. Please note that this memory cannot be
+  swapped out.
+
+Procfs entry for ftape
+CONFIG_FT_PROC_FS
+  Optional. Saying Y will result in creation of a directory
+  `/proc/ftape' under the proc file system. The files can be viewed
+  with your favorite pager (i.e. use "more /proc/ftape/history" or
+  "less /proc/ftape/history" or simply "cat /proc/ftape/history"). The
+  file will contain some status information about the inserted
+  cartridge, the kernel driver, your tape drive, the floppy disk
+  controller and the error history for the most recent use of the
+  kernel driver. Saying Y will enlarge the size of the ftape driver
+  by approximately 2 KB.
+
+  WARNING: When compiling ftape as a module (i.e. saying M to
+  "Floppy tape drive") it is dangerous to use ftape's proc file system
+  interface. Accessing `/proc/ftape' while the module is unloaded will
+  result in a kernel Oops. This cannot be fixed from inside ftape.
+
+Controlling the amount of debugging output of ftape
+CONFIG_FT_NORMAL_DEBUG
+  This option controls the amount of debugging output the ftape driver
+  is ABLE to produce; it does not increase or diminish the debugging
+  level itself. If unsure, leave this at its default setting,
+  i.e. choose "Normal".
+
+  Ftape can print lots of debugging messages to the system console
+  resp. kernel log files. Reducing the amount of possible debugging
+  output reduces the size of the kernel module by some KB, so it might
+  be a good idea to use "None" for emergency boot floppies.
+
+  If you want to save memory then the following strategy is
+  recommended: leave this option at its default setting "Normal" until
+  you know that the driver works as expected, afterwards reconfigure
+  the kernel, this time specifying "Reduced" or "None" and recompile
+  and install the kernel as usual. Note that choosing "Excessive"
+  debugging output does not increase the amount of debugging output
+  printed to the console but only makes it possible to produce
+  "Excessive" debugging output.
+
+  Please read Documentation/ftape.txt for a short description
+  how to control the amount of debugging output.
+
+The floppy drive controller for ftape
+CONFIG_FT_STD_FDC
+  Only change this setting if you have a special controller. If you
+  didn't plug any add-on card into your computer system but just
+  plugged the floppy tape cable into the already existing floppy drive
+  controller then you don't want to change the default setting,
+  i.e. choose "Standard".
+
+  Choose "MACH-2" if you have a Mountain Mach-2 controller.
+  Choose "FC-10/FC-20" if you have a Colorado FC-10 or FC-20
+  controller.
+  Choose "Alt/82078" if you have another controller that is located at
+  an IO base address different from the standard floppy drive
+  controller's base address of `0x3f0', or uses an IRQ (interrupt)
+  channel different from `6', or a DMA channel different from
+  `2'. This is necessary for any controller card that is based on
+  Intel's 82078 FDC such as Seagate's, Exabyte's and Iomega's "high
+  speed" controllers.
+
+  If you choose something other than "Standard" then please make
+  sure that the settings for the IO base address and the IRQ and DMA
+  channel in the configuration menus below are correct. Use the manual
+  of your tape drive to determine the correct settings!
+
+  If you are already successfully using your tape drive with another
+  operating system then you definitely should use the same settings
+  for the IO base, the IRQ and DMA channel that have proven to work
+  with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the hardware setup. The hardware configuration can be changed at
+  boot time (when ftape is compiled into the kernel, i.e. if you
+  have said Y to "Floppy tape drive") or module load time (i.e. if you
+  have said M to "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which
+  contains a short description of the parameters that can be set at
+  boot or load time. If you want to use your floppy tape drive on a
+  PCI-bus based system, please read the file
+  drivers/char/ftape/README.PCI.
+
+IO base of the floppy disk controller used with Ftape
+CONFIG_FT_FDC_BASE
+  You don't need to specify a value if the following default
+  settings for the base IO address are correct:
+  <<< MACH-2     : 0x1E0 >>>
+  <<< FC-10/FC-20: 0x180 >>>
+  <<< Secondary  : 0x370 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IO base. The hardware configuration can be changed at boot time
+  (when ftape is compiled into the kernel, i.e. if you specified Y to
+  "Floppy tape drive") or module load time (i.e. if you have said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+IRQ channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_IRQ
+  You don't need to specify a value if the following default
+  settings for the interrupt channel are correct:
+  <<< MACH-2     : 6 >>>
+  <<< FC-10/FC-20: 9 >>>
+  <<< Secondary  : 6 >>>
+  Secondary refers to secondary a FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IRQ channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+DMA channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_DMA
+  You don't need to specify a value if the following default
+  settings for the DMA channel are correct:
+  <<< MACH-2     : 2 >>>
+  <<< FC-10/FC-20: 3 >>>
+  <<< Secondary  : 2 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the DMA channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+FDC FIFO Threshold before requesting DMA service
+CONFIG_FT_FDC_THR
+  Set the FIFO threshold of the FDC. If this is higher the DMA
+  controller may serve the FDC after a higher latency time. If this is
+  lower, fewer DMA transfers occur leading to less bus contention.
+  You may try to tune this if ftape annoys you with "reduced data
+  rate because of excessive overrun errors" messages. However, this
+  doesn't seem to have too much effect.
+
+  If unsure, don't touch the initial value, i.e. leave it at "8".
+
+FDC maximum data rate
+CONFIG_FT_FDC_MAX_RATE
+  With some motherboard/FDC combinations ftape will not be able to
+  run your FDC/tape drive combination at the highest available
+  speed. If this is the case you'll encounter "reduced data rate
+  because of excessive overrun errors" messages and lots of retries
+  before ftape finally decides to reduce the data rate.
+
+  In this case it might be desirable to tell ftape beforehand that
+  it need not try to run the tape drive at the highest available
+  speed. If unsure, leave this disabled, i.e. leave it at 2000
+  bits/sec.
+
+Direct Rendering Manager (XFree86 DRI support)
+CONFIG_DRM
+  Kernel-level support for the Direct Rendering Infrastructure (DRI)
+  introduced in XFree86 4.x. These modules provide support for
+  synchronization, security, and DMA transfers. Select the module that
+  provides support for your graphics card.
+
+3dfx Banshee/Voodoo3+
+CONFIG_DRM_TDFX
+  Choose M here if you have a 3dfx Banshee/Voodoo3 graphics card.
+
+3dlabs GMX 2000
+CONFIG_DRM_GAMMA
+  Choose M here if you have a 3dlabs GMX 2000 graphics card.
+
+ATI Rage 128
+CONFIG_DRM_R128
+  Choose M here if you have a ATI Rage 128 graphics card.
+
+Intel I810
+CONFIG_DRM_I810
+  Choose M here if you have an Intel I810 AGP graphics card.
+
+Matrox g200/g400
+CONFIG_DRM_MGA
+  Choose M here if you have a Matrox g200/g400 AGP graphics card.
+
+MTRR control and configuration
+CONFIG_MTRR
+  On Intel P6 family processors (Pentium Pro, Pentium II and later)
+  the Memory Type Range Registers (MTRRs) may be used to control
+  processor access to memory ranges. This is most useful when you have
+  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
+  allows bus write transfers to be combined into a larger transfer
+  before bursting over the PCI/AGP bus. This can increase performance
+  of image write operations 2.5 times or more. This option creates a
+  /proc/mtrr file which may be used to manipulate your
+  MTRRs. Typically the X server should use this. This should have a
+  reasonably generic interface so that similar control registers on
+  other processors can be easily supported.
+
+  The Cyrix 6x86, 6x86MX and M II processors have Address Range
+  Registers (ARRs) which provide a similar functionality to MTRRs. For
+  these, the ARRs are used to emulate the MTRRs.
+
+  The AMD K6-2 (stepping 8 and above) and K6-3 processors have two
+  MTRRs. These are supported.
+
+  The Centaur C6 (WinChip) and WinChip 2&3 processors have 8 MCRs. 
+  These are supported. Note that, due to the design of the WinChip 2&3, 
+  setting the access for normal memory to uncachable or write-combine
+  on these processors will result in instant kernel panic. It is okay 
+  to set this for non-cacheable (video) memory.
+
+  Saying Y here also fixes a problem with buggy SMP BIOSes which only
+  set the MTRRs for the boot CPU and not the secondary CPUs. This can
+  lead to all sorts of problems.
+
+  You can safely say Y even if your machine doesn't have MTRRs, you'll
+  just add about 3k to your kernel.
+
+  See Documentation/mtrr.txt for more information.
+
+Main CPU frequency, only for DEC alpha machine
+CONFIG_FT_ALPHA_CLOCK
+  On some DEC Alpha machines the CPU clock frequency cannot be
+  determined automatically, so you need to specify it here ONLY if
+  running a DEC Alpha, otherwise this setting has no effect.
+
+Zilog serial support
+CONFIG_SUN_ZS
+  If you are asked this question, something is wrong with config scripts.
+  Zilog serial driver is always enabled in sparc architecture.
+
+Double Talk PC internal speech card support
+CONFIG_DTLK
+  This driver is for the DoubleTalk PC, a speech synthesizer
+  manufactured by RC Systems (http://www.rcsys.com/).  It is also
+  called the `internal DoubleTalk'.  If you want to compile this as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called dtlk.o.
+
+Advanced Power Management
+CONFIG_APM
+  APM is a BIOS specification for saving power using several different
+  techniques. This is mostly useful for battery powered laptops with
+  APM compliant BIOSes. If you say Y here, the system time will be
+  reset after a RESUME operation, the /proc/apm device will provide
+  battery status information, and user-space programs will receive
+  notification of APM "events" (e.g. battery status change).
+
+  If you select "Y" here, you can disable actual use of the APM
+  BIOS by passing the "apm=off" option to the kernel at boot time.
+
+  Note that the APM support is almost completely disabled for
+  machines with more than one CPU.
+
+  Supporting software is available; for more information, read the
+  Battery Powered Linux mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver does not spin down disk drives (see the hdparm(8)
+  manpage ("man 8 hdparm") for that), and it doesn't turn off
+  VESA-compliant "green" monitors. 
+
+  This driver does not support the TI 4000M TravelMate and the ACER
+  486/DX4/75 because they don't have compliant BIOSes. Many "green"
+  desktop machines also don't have compliant BIOSes, and this driver
+  may cause those machines to panic during the boot phase.
+
+  If you are running Linux on a laptop, you may also want to read the
+  Linux Laptop home page on the WWW at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ .
+
+  Generally, if you don't have a battery in your machine, there isn't
+  much point in using this driver and you should say N. If you get
+  random kernel OOPSes or reboots that don't seem to be related to
+  anything, try disabling/enabling this option (or disabling/enabling
+  APM in your BIOS). 
+
+  Some other things you should try when experiencing seemingly random,
+  "weird" problems:
+
+   1) make sure that you have enough swap space and that it is
+      enabled. 
+   2) pass the "no-hlt" option to the kernel 
+   3) switch on floating point emulation in the kernel and pass
+      the "no387" option to the kernel
+   4) pass the "floppy=nodma" option to the kernel
+   5) pass the "mem=4M" option to the kernel (thereby disabling 
+      all but the first 4 MB of RAM)
+   6) make sure that the CPU is not over clocked.
+   7) read the sig11 FAQ at http://www.bitwizard.nl/sig11/
+   8) disable the cache from your BIOS settings
+   9) install a fan for the video card or exchange video RAM
+   10) install a better fan for the CPU
+   11) exchange RAM chips 
+   12) exchange the motherboard.
+
+Ignore USER SUSPEND
+CONFIG_APM_IGNORE_USER_SUSPEND
+  This option will ignore USER SUSPEND requests. On machines with a
+  compliant APM BIOS, you want to say N. However, on the NEC Versa M
+  series notebooks, it is necessary to say Y because of a BIOS bug.
+
+Enable APM at boot time
+CONFIG_APM_DO_ENABLE
+  Enable APM features at boot time. From page 36 of the APM BIOS
+  specification: "When disabled, the APM BIOS does not automatically
+  power manage devices, enter the Standby State, enter the Suspend
+  State, or take power saving steps in response to CPU Idle calls."
+  This driver will make CPU Idle calls when Linux is idle (unless this
+  feature is turned off -- see "Do CPU IDLE calls", below). This
+  should always save battery power, but more complicated APM features
+  will be dependent on your BIOS implementation. You may need to turn
+  this option off if your computer hangs at boot time when using APM
+  support, or if it beeps continuously instead of suspending. Turn
+  this off if you have a NEC UltraLite Versa 33/C or a Toshiba
+  T400CDT. This is off by default since most machines do fine without
+  this feature.
+
+Do CPU IDLE calls
+CONFIG_APM_CPU_IDLE
+  Enable calls to APM CPU Idle/CPU Busy inside the kernel's idle loop.
+  On some machines, this can activate improved power savings, such as
+  a slowed CPU clock rate, when the machine is idle. These idle calls
+  are made after the idle loop has run for some length of time (e.g.,
+  333 mS). On some machines, this will cause a hang at boot time or
+  whenever the CPU becomes idle. (On machines with more than one CPU,
+  this option does nothing.)
+
+Enable console blanking using APM
+CONFIG_APM_DISPLAY_BLANK
+  Enable console blanking using the APM. Some laptops can use this to
+  turn off the LCD backlight when the screen blanker of the Linux
+  virtual console blanks the screen. Note that this is only used by
+  the virtual console screen blanker, and won't turn off the backlight
+  when using the X Window system. This also doesn't have anything to
+  do with your VESA-compliant power-saving monitor. Further, this
+  option doesn't work for all laptops -- it might not turn off your
+  backlight at all, or it might print a lot of errors to the console,
+  especially if you are using gpm.
+
+Ignore multiple suspend/resume cycles
+CONFIG_APM_IGNORE_SUSPEND_BOUNCE
+  This option is necessary on the Dell Inspiron 3200 and others, but
+  should be safe for all other laptops. When enabled, a system suspend
+  event that occurs within three seconds of a resume is ignored.
+  Without this the Inspiron will shut itself off a few seconds after
+  you open the lid, requiring you to press the power button to resume
+  it a second time. Say Y.
+
+RTC stores time in GMT
+CONFIG_APM_RTC_IS_GMT
+  Say Y here if your RTC (Real Time Clock a.k.a. hardware clock)
+  stores the time in GMT (Greenwich Mean Time). Say N if your RTC
+  stores localtime.
+
+  It is in fact recommended to store GMT in your RTC, because then you
+  don't have to worry about daylight savings time changes. The only
+  reason not to use GMT in your RTC is if you also run a broken OS
+  that doesn't understand GMT.
+
+Allow interrupts during APM BIOS calls
+CONFIG_APM_ALLOW_INTS
+  Normally we disable external interrupts while we are making calls to
+  the APM BIOS as a measure to lessen the effects of a badly behaving
+  BIOS implementation.  The BIOS should reenable interrupts if it
+  needs to.  Unfortunately, some BIOSes do not - especially those in
+  many of the newer IBM Thinkpads.  If you experience hangs when you
+  suspend, try setting this to Y.  Otherwise, say N.
+
+Use real mode APM BIOS call to power off
+CONFIG_APM_REAL_MODE_POWER_OFF
+  Use real mode APM BIOS calls to switch off the computer. This is
+  a work-around for a number of buggy BIOSes. Switch this option on if
+  your computer crashes instead of powering off properly.
+
+Watchdog Timer Support 
+CONFIG_WATCHDOG
+  If you say Y here (and to one of the following options) and create a
+  character special file /dev/watchdog with major number 10 and minor
+  number 130 using mknod ("man mknod"), you will get a watchdog, i.e.:
+  subsequently opening the file and then failing to write to it for
+  longer than 1 minute will result in rebooting the machine. This
+  could be useful for a networked machine that needs to come back
+  online as fast as possible after a lock-up. There's both a watchdog
+  implementation entirely in software (which can sometimes fail to
+  reboot the machine) and a driver for hardware watchdog boards, which
+  are more robust and can also keep track of the temperature inside
+  your computer. For details, read Documentation/watchdog.txt in the
+  kernel source.
+
+  The watchdog is usually used together with the watchdog daemon which is
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/linux/system/daemons/watchdog. This daemon can
+  check a larger part of the system. For instance it can monitor NFS
+  connections and reboot the machine when the process table is full or the
+  workload exceeds a predefined value.
+
+  If unsure, say N.
+
+Disable watchdog shutdown on close
+CONFIG_WATCHDOG_NOWAYOUT
+  The default watchdog behaviour (which you get if you say N here) is
+  to stop the timer if the process managing it closes the file
+  /dev/watchdog. It's always remotely possible that this process might
+  get killed. If you say Y here, the watchdog cannot be stopped once
+  it has been started.
+
+WDT Watchdog timer
+CONFIG_WDT
+  If you have a WDT500P or WDT501P watchdog board, say Y here,
+  otherwise N. It is not possible to probe for this board, which means
+  that you have to set the IO port and IRQ it uses in the kernel
+  source at the top of drivers/char/wdt.c. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called wdt.o.
+
+WDT501 features
+CONFIG_WDT_501
+  Saying Y here and creating a character special file /dev/temperature
+  with major number 10 and minor number 131 ("man mknod") will give
+  you a thermometer inside your computer: reading from
+  /dev/temperature yields one byte, the temperature in degrees
+  Fahrenheit. This works only if you have a WDT501P watchdog board
+  installed.
+
+Fan Tachometer
+CONFIG_WDT_501_FAN
+  Enable the Fan Tachometer on the WDT501. Only do this if you have a
+  fan tachometer actually set up.
+
+Software Watchdog
+CONFIG_SOFT_WATCHDOG
+  A software monitoring watchdog. This will fail to reboot your system
+  from some situations that the hardware watchdog will recover
+  from. Equally it's a lot cheaper to install. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called softdog.o.
+
+Berkshire Products PC Watchdog
+CONFIG_PCWATCHDOG
+  This is the driver for the Berkshire Products PC Watchdog card.
+  This card simply watches your kernel to make sure it doesn't freeze,
+  and if it does, it reboots your computer after a certain amount of
+  time. This driver is like the WDT501 driver but for different
+  hardware. Please read Documentation/pcwd-watchdog.txt. The PC
+  watchdog cards can be ordered from http://www.berkprod.com. Some
+  example rc.local files are available from ftp://ftp.bitgate.com. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pcwd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  Most people will say N.
+
+Acquire SBC Watchdog Timer
+CONFIG_ACQUIRE_WDT
+  This is the driver for the hardware watchdog on the PSC-6x86 Single
+  Board Computer produced by Acquire Inc (and others). This watchdog
+  simply watches your kernel to make sure it doesn't freeze, and if
+  it does, it reboots your computer after a certain amount of time.
+
+  This driver is like the WDT501 driver but for different hardware.
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pscwdt.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. Most people
+  will say N.
+
+SBC-60XX Watchdog Timer
+CONFIG_60XX_WDT
+ This driver can be used with the watchdog timer found on some
+ single board computers, namely the 6010 PII based computer.
+ It may well work with other cards.  It reads port 0x443 to enable
+ and re-set the watchdog timer, and reads port 0x45 to disable
+ the watchdog.  If you have a card that behave in similar ways,
+ you can probably make this driver work with your card as well.
+
+ You can compile this driver directly into the kernel, or use
+ it as a module.  The module will be called sbc60xxwdt.o.
+
+CONFIG_MICROCODE
+  /dev/cpu/microcode - Intel P6 CPU microcode support
+
+  If you say Y here you will be able to update the microcode on
+  Intel processors in the P6 family, e.g. Pentium Pro, Pentium II,
+  Pentium III, Xeon etc. You will obviously need the actual microcode
+  binary data itself which is not shipped with the Linux kernel.
+ 
+  For latest news and information on obtaining all the required
+  ingredients for this driver, check:
+  http://www.urbanmyth.org/microcode/
+ 
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called microcode.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+/dev/cpu/*/msr - Model-specific register support
+CONFIG_X86_MSR
+  This device gives privileged processes access to the x86
+  Model-Specific Registers (MSRs).  It is a character device with
+  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
+  MSR accesses are directed to a specific CPU on multi-processor
+  systems.
+
+/dev/cpu/*/cpuid - CPU information support
+CONFIG_X86_CPUID
+  This device gives processes access to the x86 CPUID instruction to
+  be executed on a specific processor.  It is a character device
+  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
+  /dev/cpu/31/cpuid.
+
+Enhanced Real Time Clock Support
+CONFIG_RTC
+  If you say Y here and create a character special file /dev/rtc with
+  major number 10 and minor number 135 using mknod ("man mknod"), you
+  will get access to the real time clock built into your computer.
+  Every PC has such a clock built in. It can be used to generate
+  signals from as low as 1Hz up to 8192Hz, and can also be used as a
+  24 hour alarm. It reports status information via the file /proc/rtc
+  and its behaviour is set by various ioctls on /dev/rtc.
+
+  If you run Linux on a multiprocessor machine and said Y to
+  "Symmetric Multi Processing" above, you should say Y here to read
+  and set the RTC clock in an SMP compatible fashion.
+
+  If you think you have a use for such a device (such as periodic data
+  sampling), then say Y here, and read Documentation/rtc.txt for
+  details.
+
+AGP/GART support
+CONFIG_AGP
+  This provides a kernel interface (/dev/agpgart) for programming AGP
+  transfers on motherboards that support them. Primarily, this is used
+  for hardware-accelerated 3d graphics, though any other AGP device
+  could take advantage of it.
+
+  If you have a 3d-capable AGP video card say 'M' or 'Y' here.
+  Otherwise, say 'N'.
+
+  You will also have to indicate support for your specific chipset.
+  Consult the output of lspci, your motherboard manual, or the inside
+  of your computer if unsure what to choose. Multiple selections are ok.
+
+Intel 440LX/BX/GX support
+CONFIG_AGP_INTEL
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Intel 440LX/BX/GX chipsets.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Intel I810/I810 DC100/I810e support
+CONFIG_AGP_I810
+  This option give you AGP support for the Xserver for the intel
+  810 chipset boards. This is required to do any useful video
+  modes.
+
+VIA VP3/MVP3/Apollo Pro support
+CONFIG_AGP_VIA
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on VIA MPV3/Apollo Pro chipsets.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+AMD Irongate support
+CONFIG_AGP_AMD
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Intel AMD Irongate chipset.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Generic SiS support
+CONFIG_AGP_SIS
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Silicon Integrated Systems [SiS]
+  chipsets.
+
+  Note than 5591/5592 AGP chipsets are NOT supported.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+ALI M1541 support
+CONFIG_AGP_ALI
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on ALI M1541 chipset.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Tadpole ANA H8 Support
+CONFIG_H8
+  The Hitachi H8/337 is a microcontroller used to deal with the power
+  and thermal environment. If you say Y here, you will be able to
+  communicate with it via a character special device. 
+
+  If unsure, say N.
+
+/dev/nvram support
+CONFIG_NVRAM
+  If you say Y here and create a character special file /dev/nvram
+  with major number 10 and minor number 144 using mknod ("man mknod"),
+  you get read and write access to the 50 bytes of non-volatile memory
+  in the real time clock (RTC), which is contained in every PC and
+  most Ataris. 
+
+  This memory is conventionally called "CMOS RAM" on PCs and "NVRAM"
+  on Ataris. /dev/nvram may be used to view settings there, or to
+  change them (with some utility). It could also be used to frequently
+  save a few bits of very important data that may not be lost over
+  power-off and for which writing to disk is too insecure. Note
+  however that most NVRAM space in a PC belongs to the BIOS and you
+  should NEVER idly tamper with it. See Ralf Brown's interrupt list
+  for a guide to the use of CMOS bytes by your BIOS.
+
+  On Atari machines, /dev/nvram is always configured and does not need
+  to be selected.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called nvram.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atomwide Serial Support
+CONFIG_ATOMWIDE_SERIAL
+  If you have an Atomwide Serial card for an Acorn system, say Y to
+  this option.  The driver can handle 1, 2, or 3 port cards.
+  If unsure, say N
+
+The Serial Port Dual Serial Port
+CONFIG_DUALSP_SERIAL
+  If you have the Serial Port's dual serial card for an Acorn system,
+  say Y to this option.  If unsure, say N
+
+Joystick support
+CONFIG_JOYSTICK
+  If you have a joystick, 6dof controller, gamepad, steering wheel,
+  weapon control system or something like that you can say Y here to
+  enable generic support for these controllers. You will also need to
+  say Y or M to at least one of the hardware specific drivers. This
+  will make the controllers available as /dev/jsX devices. Please read
+  the file Documentation/joystick.txt which contains more information
+  and the location of the joystick package that you'll need.
+
+Classic PC analog
+CONFIG_JOY_ANALOG
+  Say Y here if you have a controller that connects to the PC
+  gameport. This supports many different types, including joysticks
+  with throttle control, with rudders, or with extensions like
+  additional hats and buttons compatible with CH Flightstick Pro,
+  ThrustMaster FCS or 6 and 8 button gamepads. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+FPGaming and MadCatz A3D
+CONFIG_JOY_ASSASSIN
+  Say Y here if you have an FPGaming or MadCatz controller using the
+  A3D protocol over the PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Gravis GrIP
+CONFIG_JOY_GRAVIS
+  Say Y here if you have a Gravis controller using the GrIP protocol
+  over the PC gameport. For more information on how to use the driver
+  please read Documentation/joystick.txt
+
+Logitech ADI
+CONFIG_JOY_LOGITECH
+  Say Y here if you have a Logitech controller using the ADI
+  protocol over the PC gameport. For more information on how to use
+  the driver please read Documentation/joystick.txt
+
+Microsoft SideWinder
+CONFIG_JOY_SIDEWINDER
+  Say Y here if you have a Microsoft controller using the Digital
+  Overdrive protocol over PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+ThrustMaster DirectConnect
+CONFIG_JOY_THRUSTMASTER
+  Say Y here if you have a ThrustMaster controller using the
+  DirectConnect (BSP) protocol over the PC gameport. For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Creative Labs Blaster
+CONFIG_JOY_CREATIVE
+  Say Y here if you have a Creative Labs controller using the
+  Blaster protocol over the PC gameport. For more information on how
+  to use the driver please read Documentation/joystick.txt
+
+PDPI Lightning 4 card
+CONFIG_JOY_LIGHTNING
+  Say Y here if you have a PDPI Lightning 4 gamecard and an analog
+  joystick or gamepad connected to it. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Trident 4DWave and Aureal Vortex gameport
+CONFIG_JOY_PCI
+  Say Y here if you have a Trident 4DWave DX/NX or Aureal Vortex 1/2
+  card and want to use its gameport in its enhanced digital mode
+  with and ordinary analog joystick. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Magellan and Space Mouse
+CONFIG_JOY_MAGELLAN
+  Say Y here if you have a Magellan or Space Mouse 6DOF controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+SpaceTec SpaceOrb 360 and SpaceBall Avenger
+CONFIG_JOY_SPACEORB
+  Say Y here if you have a SpaceOrb 360 or SpaceBall Avenger 6DOF
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+SpaceTec SpaceBall 4000 FLX
+CONFIG_JOY_SPACEBALL
+  Say Y here if you have a SpaceTec SpaceBall 4000 FLX
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Logitech WingMan Warrior
+CONFIG_JOY_WARRIOR
+  Say Y here if you have a Logitech WingMan Warrior controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+NES, SNES, N64, PSX, Multi
+CONFIG_JOY_CONSOLE
+  Say Y here if you have a Nintendo Entertainment System gamepad,
+  Super Nintendo Entertainment System gamepad, Nintendo 64 gamepad,
+  Sony PlayStation gamepad or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port.
+  For more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+Sega, Multi
+CONFIG_JOY_DB9
+  Say Y here if you have a Sega Master System gamepad, Sega Genesis
+  gamepad, Sega Saturn gamepad, or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port. For
+  more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+TurboGraFX interface
+CONFIG_JOY_TURBOGRAFX
+  Say Y here if you have the TurboGraFX interface by Steffen Schwenke,
+  and want to use it with Multiststem -- Atari, Amiga, Commodore,
+  Amstrad CPC joystick. For more information on how to use the driver
+  please read Documentation/joystick.txt and
+  Documentation/joystick-parport.txt
+
+Amiga joysticks
+CONFIG_JOY_AMIGA
+  Say Y here if you have an Amiga with a digital joystick connected
+  to it. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+Atomwide Serial Support
+CONFIG_ATOMWIDE_SERIAL
+  If you have an Atomwide Serial card for an Acorn system, say Y to
+  this option. The driver can handle 1, 2, or 3 port cards.
+  If unsure, say N
+
+The Serial Port Dual Serial Port
+CONFIG_DUALSP_SERIAL
+  If you have the Serial Port's dual serial card for an Acorn system,
+  say Y to this option. If unsure, say N
+
+NetWinder Button
+CONFIG_NWBUTTON
+  If you enable this driver and create a character device node
+  /dev/nwbutton with major and minor numbers 10 and 158 ("man mknod"),
+  then every time the orange button is pressed a number of times, the
+  number of times the button was pressed will be written to that device.
+  This is most useful for applications, as yet unwritten, which perform
+  actions based on how many times the button is pressed in a row.
+  Do not hold the button down for too long, as the driver does not alter
+  the behaviour of the hardware reset circuitry attached to the button;
+  it will still execute a hard reset if the button is held down for
+  longer than approximately five seconds.
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called nwbutton.o.
+  Most people will answer Y to this question and "Reboot Using Button"
+  below to be able to initiate a system shutdown from the button.
+
+Reboot Using Button
+CONFIG_NWBUTTON_REBOOT
+  If you enable this option, then you will be able to initiate a system
+  shutdown and reboot by pressing the orange button a number of times.
+  The number of presses to initiate the shutdown is two by default, but
+  this can be altered by modifying the value of NUM_PRESSES_REBOOT in
+  nwbutton.h and recompiling the driver or, if you compile the driver as
+  a module, you can specify the number of presses at load time with
+  "insmod button reboot_count=<something>".
+
+Sound card support
+CONFIG_SOUND
+  If you have a sound card in your computer, i.e. if it can say more
+  than an occasional beep, say Y. Be sure to have all the information
+  about your sound card and its configuration down (I/O port,
+  interrupt and DMA channel), because you will be asked for it. 
+
+  You want to read the Sound-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. General
+  information about the modular sound system is contained in the files
+  Documentation/sound/Introduction. The file
+  Documentation/sound/README.OSS contains some slightly outdated but
+  still useful information as well.
+
+  If you have a PnP sound card and you want to configure it at boot
+  time using the ISA PnP tools (read
+  http://www.roestock.demon.co.uk/isapnptools/ (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape)), then you need to compile the sound card
+  support as a module ( = code which can be inserted in and removed
+  from the running kernel whenever you want) and load that module
+  after the PnP configuration is finished. To do this, say M here and
+  read Documentation/modules.txt as well as
+  Documentation/sound/README.modules; the module will be called
+  soundcore.o.
+
+  I'm told that even without a sound card, you can make your computer
+  say more than an occasional beep, by programming the PC speaker.
+  Kernel patches and supporting utilities to do that are in the pcsp
+  package, available at ftp://ftp.infradead.org/pub/pcsp/.
+
+OSS sound modules
+CONFIG_SOUND_OSS
+  OSS is the Open Sound System suite of sound card drivers. They make
+  sound programming easier since they provide a common API. Say Y or M
+  here (the module will be called sound.o) if you haven't found a
+  driver for your sound card above, then pick your driver from the
+  list below.
+
+Persistent DMA buffers
+CONFIG_SOUND_DMAP
+  Linux can often have problems allocating DMA buffers for ISA sound
+  cards on machines with more than 16MB of RAM. This is because ISA
+  DMA buffers must exist below the 16MB boundary and it is quite
+  possible that a large enough free block in this region cannot be
+  found after the machine has been running for a while. If you say Y
+  here the DMA buffers (64Kb) will be allocated at boot time and kept
+  until the shutdown. This option is only useful if you said Y to
+  "OSS sound modules", above. If you said M to "OSS sound modules"
+  then you can get the persistent DMA buffer functionality by passing
+  the command-line argument "dmabuf=1" to the sound.o module.
+
+  Say Y unless you have 16MB or less RAM or a PCI sound card.
+
+Crystal SoundFusion (CS461x)
+CONFIG_SOUND_FUSION
+  This module drives the Crystal SoundFusion devices (CS46xx series) when
+  wired as native sound drivers with AC97 codecs. If this driver does not
+  work try the CS4232 driver.
+
+Support for Aztech Sound Galaxy (non-PnP) cards
+CONFIG_SOUND_SGALAXY
+  This module initializes the older non Plug and Play sound galaxy
+  cards from Aztech. It supports the Waverider Pro 32 - 3D and the
+  Galaxy Washington 16.
+
+Support for AD1816(A) based cards (EXPERIMENTAL)
+CONFIG_SOUND_AD1816
+  Say M here if you have a sound card based on the Analog Devices 
+  AD1816(A) chip.
+
+  NOTE: This driver is still EXPERIMENTAL. 
+        See Documentation/sound/AD1816 for further information.
+
+Yamaha OPL3-SA1 audio controller
+CONFIG_SOUND_OPL3SA1
+  Say Y or M if you have a Yamaha OPL3-SA1 sound chip, which is
+  usually built into motherboards. Read Documentation/sound/OPL3-SA
+  for details.
+
+ProAudioSpectrum 16 support
+CONFIG_SOUND_PAS
+  Answer Y only if you have a Pro Audio Spectrum 16, ProAudio Studio
+  16 or Logitech SoundMan 16 sound card. Don't answer Y if you have
+  some other card made by Media Vision or Logitech since they are not
+  PAS16 compatible.
+
+100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support
+CONFIG_SOUND_SB
+  Answer Y if you have an original Sound Blaster card made by Creative
+  Labs or a 100% hardware compatible clone (like the Thunderboard or
+  SM Games). For an unknown card you may answer Y if the card claims
+  to be Sound Blaster-compatible.
+
+  Please read the file Documentation/sound/Soundblaster.
+
+  You should also say Y here for cards based on the Avance Logic
+  ALS-007 chip (read Documentation/sound/ALS007) and for cards based
+  on ESS chips (read Documentation/sound/ESS1868 and
+  Documentation/sound/ESS). If you have an SB AWE 32 or SB AWE 64, say
+  Y here and also to "Additional lowlevel drivers" and to "SB32/AWE
+  support" below and read Documentation/sound/INSTALL.awe. If you have
+  an IBM Mwave card, say Y here and read Documentation/sound/mwave.
+  
+  You can say M here to compile this driver as a module; the module is
+  called sb.o.
+
+#Loopback MIDI device support
+#CONFIG_SOUND_VMIDI
+###
+### somebody please fill this in.
+###
+#
+Gravis Ultrasound support
+CONFIG_SOUND_GUS
+  Say Y here for any type of Gravis Ultrasound card, including
+  the GUS or GUS MAX. See also Documentation/sound/ultrasound for
+  more information on configuring this card with modules.
+
+MPU-401 support (NOT for SB16)
+CONFIG_SOUND_MPU401
+  Be careful with this question. The MPU401 interface is supported by
+  all sound cards. However, some natively supported cards have their
+  own driver for MPU401. Enabling this MPU401 option with these cards
+  will cause a conflict. Also, enabling MPU401 on a system that
+  doesn't really have a MPU401 could cause some trouble. If your card
+  was in the list of supported cards, look at the card specific
+  instructions in the drivers/sound/Readme.cards file. It's safe to
+  answer Y if you have a true MPU401 MIDI interface card.
+
+6850 UART support
+CONFIG_SOUND_UART6850
+  This option enables support for MIDI interfaces based on the 6850
+  UART chip. This interface is rarely found on sound cards. It's safe
+  to answer N to this question.
+
+VIDC Sound
+CONFIG_VIDC_SOUND
+  Say Y here for ARM systems with the VIDC video controller and 16-bit
+  Linear sound DACs. If unsure, say N.
+
+PSS (AD1848, ADSP-2115, ESC614) support
+CONFIG_SOUND_PSS
+  Answer Y or M if you have an Orchid SW32, Cardinal DSP16, Beethoven
+  ADSP-16 or some other card based on the PSS chipset (AD1848 codec +
+  ADSP-2115 DSP chip + Echo ESC614 ASIC CHIP). For more information on
+  how to compile it into the kernel or as a module see the file
+  Documentation/sound/PSS.
+
+Enable PSS mixer (Beethoven ADSP-16 and other compatible)
+CONFIG_PSS_MIXER
+  Answer Y for Beethoven ADSP-16. You may try to say Y also for other
+  cards if they have master volume, bass, treble, and you can't
+  control it under Linux. If you answer N for Beethoven ADSP-16, you
+  can't control master volume, bass, treble and synth volume.
+
+  If you said M to "PSS support" above, you may enable or disable this
+  PSS mixer with the module parameter pss_mixer. For more information
+  see the file Documentation/sound/PSS.
+
+Have DSPxxx.LD firmware file
+CONFIG_PSS_HAVE_BOOT
+  If you have the DSPxxx.LD file or SYNTH.LD file for you card, say Y
+  to include this file. Without this file the synth device (OPL) may
+  not work.
+
+Full pathname of DSPxxx.LD firmware file
+CONFIG_PSS_BOOT_FILE
+  Enter the full pathname of your DSPxxx.LD file or SYNTH.LD file,
+  starting from /.
+
+16 bit sampling option of GUS (_NOT_ GUS MAX)
+CONFIG_SOUND_GUS16
+  Answer Y if you have installed the 16 bit sampling daughtercard on
+  your GUS. Answer N if you have a GUS MAX, since saying Y here
+  disables GUS MAX support.
+
+GUS MAX support
+CONFIG_SOUND_GUSMAX
+  Answer Y only if you have a Gravis Ultrasound MAX.
+
+Microsoft Sound System support
+CONFIG_SOUND_MSS
+  Again think carefully before answering Y to this question. It's safe
+  to answer Y if you have the original Windows Sound System card made
+  by Microsoft or Aztech SG 16 Pro (or NX16 Pro). Also you may say Y
+  in case your card is NOT among these:
+
+     ATI Stereo F/X, AdLib, Audio Excell DSP16, Cardinal DSP16,
+     Ensoniq SoundScape (and compatibles made by Reveal and Spea),
+     Gravis Ultrasound, Gravis Ultrasound ACE, Gravis Ultrasound Max,
+     Gravis Ultrasound with 16 bit option, Logitech Sound Man 16,
+     Logitech SoundMan Games, Logitech SoundMan Wave, MAD16 Pro (OPTi
+     82C929), Media Vision Jazz16, MediaTriX AudioTriX Pro, Microsoft
+     Windows Sound System (MSS/WSS), Mozart (OAK OTI-601), Orchid
+     SW32, Personal Sound System (PSS), Pro Audio Spectrum 16, Pro
+     Audio Studio 16, Pro Sonic 16, Roland MPU-401 MIDI interface,
+     Sound Blaster 1.0, Sound Blaster 16, Sound Blaster 16ASP, Sound
+     Blaster 2.0, Sound Blaster AWE32, Sound Blaster Pro, TI TM4000M
+     notebook, ThunderBoard, Turtle Beach Tropez, Yamaha FM
+     synthesizers (OPL2, OPL3 and OPL4), 6850 UART MIDI Interface.
+
+  For cards having native support in VoxWare, consult the card
+  specific instructions in drivers/sound/Readme.cards. Some drivers
+  have their own MSS support and saying Y to this option will cause a
+  conflict.
+
+SoundPro chip support
+CONFIG_SOUND_SPRO
+  If you have a (usually Taiwanese) motherboard with the SoundPro chip
+  on board, say Y here. Otherwise say N.
+
+Ensoniq Soundscape support
+CONFIG_SOUND_SSCAPE
+  Answer Y if you have a sound card based on the Ensoniq SoundScape
+  chipset. Such cards are being manufactured at least by Ensoniq, Spea
+  and Reveal (Reveal makes also other cards).
+
+MediaTriX AudioTriX Pro support
+CONFIG_SOUND_TRIX
+  Answer Y if you have the AudioTriX Pro sound card manufactured
+  by MediaTrix.
+
+Have TRXPRO.HEX firmware file
+CONFIG_TRIX_HAVE_BOOT
+  The MediaTrix AudioTrix Pro has an on-board microcontroller which
+  needs to be initialized by downloading the code from the file
+  TRXPRO.HEX in the DOS driver directory. If you don't have the
+  TRXPRO.HEX file handy you may skip this step. However, the SB and
+  MPU-401 modes of AudioTrix Pro will not work without this file!
+
+Full pathname of TRXPRO.HEX firmware file
+CONFIG_TRIX_BOOT_FILE
+  Enter the full pathname of your TRXPRO.HEX file, starting from /.
+
+Support for OPTi MAD16 and/or Mozart based cards
+CONFIG_SOUND_MAD16
+  Answer Y if your card has a Mozart (OAK OTI-601) or MAD16 (OPTi
+  82C928 or 82C929 or 82C931) audio interface chip. For the 82C931,
+  please read drivers/sound/README.C931. These chips are currently
+  quite common so it's possible that many no-name cards have one of
+  them. In addition the MAD16 chip is used in some cards made by known
+  manufacturers such as Turtle Beach (Tropez), Reveal (some models)
+  and Diamond (latest ones). Note however that the Tropez sound cards
+  have their own driver; if you have one of those, say N here and Y or
+  M to "Full support for Turtle Beach WaveFront", below. 
+
+  See also Documentation/sound/Opti and Documentation/sound/MAD16 for
+  more information on setting these cards up as modules.
+
+VIA 82Cxxx audio support
+CONFIG_SOUND_VIA82CXXX
+  Answer Y if you have a VIA82C686 chip, typically found built
+  onto a motherboard.
+
+Full support for Turtle Beach WaveFront synth/sound cards
+CONFIG_SOUND_WAVEFRONT
+  Answer Y or M if you have a Tropez Plus, Tropez or Maui sound card
+  and read the files Documentation/sound/Wavefront and
+  Documentation/sound/Tropez+.
+  
+Support MIDI in older MAD16 based cards (requires SB)
+CONFIG_MAD16_OLDCARD
+  Answer Y (or M) if you have an older card based on the C928 or
+  Mozart chipset and you want to have MIDI support. If you enable this
+  option you also need to enable support for Sound Blaster.
+
+Support for Crystal CS4232 based (PnP) cards
+CONFIG_SOUND_CS4232
+  Say Y here if you have a card based on the Crystal CS4232 chip set,
+  which uses its own Plug and Play protocol. 
+
+  See Documentation/sound/CS4232 for more information on configuring
+  this card.
+
+Support for Yamaha OPL3-SA2, SA3, and SAx based PnP cards
+CONFIG_SOUND_OPL3SA2
+  Say Y or M if you have a card based on one of these Yamaha
+  sound chipsets. Read Documentation/sound/OPL3-SA2 for more
+  information on configuring these cards.
+
+Support for Turtle Beach Wave Front (Maui, Tropez) synthesizers
+CONFIG_SOUND_MAUI
+  Say Y here if you have a Turtle Beach Wave Front, Maui, or Tropez
+  sound card.
+
+Have OSWF.MOT firmware file
+CONFIG_MAUI_HAVE_BOOT
+  Turtle Beach Maui and Tropez sound cards have a microcontroller
+  which needs to be initialized prior to use. OSWF.MOT is a file
+  distributed with the card's DOS/Windows drivers. Answer Y if you
+  have this file.
+
+Full pathname of OSWF.MOT firmware file
+CONFIG_MAUI_BOOT_FILE
+  Enter the full pathname of your OSWF.MOT file, starting from /.
+
+Support for Turtle Beach MultiSound Classic, Tahiti, Monterey
+CONFIG_SOUND_MSNDCLAS
+  Say M here if you have a Turtle Beach MultiSound Classic, Tahiti or
+  Monterey (not for the Pinnacle or Fiji). 
+
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of MSNDINIT.BIN firmware file
+CONFIG_MSNDCLAS_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of MSNDPERM.BIN firmware file
+CONFIG_MSNDCLAS_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Support for Turtle Beach MultiSound Pinnacle, Fiji
+CONFIG_SOUND_MSNDPIN
+  Say M here if you have a Turtle Beach MultiSound Pinnacle or Fiji.
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of PNDSPINI.BIN firmware file
+CONFIG_MSNDPIN_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of PNDSPERM.BIN firmware file
+CONFIG_MSNDPIN_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+MSND Pinnacle have S/PDIF I/O
+CONFIG_MSNDPIN_DIGITAL
+  If you have the S/PDIF daughter board for the Pinnacle or Fiji,
+  answer Y here; otherwise, say N. If you have this, you will be able
+  to play and record from the S/PDIF port (digital signal). See
+  Documentation/sound/MultiSound for information on how to make use of
+  this capability.
+
+MSND Pinnacle non-PnP Mode
+CONFIG_MSNDPIN_NONPNP
+  The Pinnacle and Fiji card resources can be configured either with
+  PnP, or through a configuration port. Say Y here if your card is NOT
+  in PnP mode. For the Pinnacle, configuration in non-PnP mode allows
+  use of the IDE and joystick peripherals on the card as well; these
+  do not show up when the card is in PnP mode. Specifying zero for any
+  resource of a device will disable the device. If you are running the
+  card in PnP mode, you must say N here and use isapnptools to
+  configure the card's resources.
+
+MSND Pinnacle config port
+CONFIG_MSNDPIN_CFG
+  This is the port which the Pinnacle and Fiji uses to configure the
+  card's resources when not in PnP mode. If your card is in PnP mode,
+  then be sure to say N to the previous option, "MSND Pinnacle Non-PnP
+  Mode".
+
+MSND buffer size (kB)
+CONFIG_MSND_FIFOSIZE
+  Configures the size of each audio buffer, in kilobytes, for
+  recording and playing in the MultiSound drivers (both the Classic
+  and Pinnacle). Larger values reduce the chance of data overruns at
+  the expense of overall latency. If unsure, use the default.
+
+/dev/dsp and /dev/audio support
+CONFIG_SOUND_AUDIO
+  If you say Y here, you will get the /dev/dsp and /dev/audio devices;
+  these are the analog-digital and digital-analog converter devices
+  and are very useful, so say Y.
+
+MIDI interface support
+CONFIG_SOUND_MIDI
+  Answering N disables /dev/midixx devices and access to any MIDI
+  ports using /dev/sequencer and /dev/music. This option also affects
+  any MPU401 and/or General MIDI compatible devices. Answer Y.
+
+FM synthesizer (YM3812/OPL-3) support
+CONFIG_SOUND_YM3812
+  Answer Y if your card has a FM chip made by Yamaha (OPL2/OPL3/OPL4).
+  Answering Y is usually a safe and recommended choice, however some
+  cards may have software (TSR) FM emulation. Enabling FM support with
+  these cards may cause trouble (I don't currently know of any such
+  cards, however).
+  Please read the file Documentation/sound/OPL3 if your card has an
+  OPL3 chip.
+
+  If unsure, say Y.
+
+Sun Audio support
+CONFIG_SUN_AUDIO
+  This is support for the sound cards on Sun workstations. The code
+  does not exist yet, so you might as well say N here.
+
+Additional low level drivers
+CONFIG_LOWLEVEL_SOUND
+  If you need additional low level sound drivers which have not yet
+  appeared, say Y. The answer to this question does not directly
+  affect the kernel; saying Y will simply cause this configure script
+  to present you with more options. If unsure, say Y.
+
+ACI mixer (miroPCM12/PCM20)
+CONFIG_ACI_MIXER
+  ACI (Audio Command Interface) is a protocol used to communicate with
+  the microcontroller on some sound cards produced by miro, e.g. the
+  miroSOUND PCM12 and PCM20. The main function of the ACI is to
+  control the mixer and to get a product identification. 
+
+  This Voxware ACI driver currently only supports the ACI functions on
+  the miroSOUND PCM12 and PCM20 cards. On the PCM20, ACI also controls
+  the radio tuner. This is supported in the video4linux
+  radio-miropcm20 driver.
+
+Micronas Intermetall MSP 3400 support
+CONFIG_VIDEO_MSP3400
+  This option enables the driver for the Micronas Intermetall MSP 3400 
+  series sound decoder/mixer chips often found on BT848-style TV cards.
+
+  Say Y here if your sound card has a MSP 3400 series sound decoder or 
+  mixer chip.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called msp3400.o.
+
+SB32/AWE support
+CONFIG_AWE32_SYNTH
+  Say Y here if you have a Sound Blaster SB32, AWE32-PnP, SB AWE64 or
+  similar sound card. See Documentation/sound/README.awe,
+  Documentation/sound/AWE32 and the Soundblaster-AWE mini-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini for more info.
+
+Gallant's Audio Excel DSP 16 support (SC-6000 and SC-6600)
+CONFIG_AEDSP16
+  Answer Y if you have a Gallant's Audio Excel DSP 16 card. This
+  driver supports Audio Excel DSP 16 but not the III nor PnP versions
+  of this card.
+
+  The Gallant's Audio Excel DSP 16 card can emulate either an SBPro or
+  a Microsoft Sound System card, so you should have said Y to either
+  "100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support"
+  or "Microsoft Sound System support", above, and you need to answer
+  the "MSS emulation" and "SBPro emulation" questions below
+  accordingly. You should say Y to one and only one of these two
+  questions.
+
+  Read the drivers/sound/lowlevel/README.aedsp16 file and the head of
+  drivers/sound/lowlevel/aedsp16.c as well as
+  Documentation/sound/AudioExcelDSP16 to get more information about
+  this driver and its configuration.
+
+I/O base for Audio Excel DSP 16
+CONFIG_AEDSP16_BASE
+  This is the base I/O address of the Audio Excel DSP 16 card. It must
+  be 220 or 240. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'io=0xNNN'.
+
+Audio Excel DSP 16 (SBPro emulation)
+CONFIG_AEDSP16_SBPRO
+  Answer Y if you want your audio card to emulate Sound Blaster Pro.
+  You should then say Y to "100% Sound Blaster compatibles
+  (SB16/32/64, ESS, Jazz16) support" and N to "Audio Excel DSP 16 (MSS
+  emulation)".
+
+Audio Excel DSP 16 IRQ
+CONFIG_AEDSP16_SB_IRQ
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 5, 7, 9,
+  10 or 11. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'irq=NN'.
+
+Audio Excel DSP 16 DMA
+CONFIG_AEDSP16_SB_DMA
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 0, 1 or 3.
+  If you compiled aedsp16.o as a module you can specify this parameter
+  as 'dma=NN'.
+
+Audio Excel DSP 16 (MSS emulation)
+CONFIG_AEDSP16_MSS
+  Answer Y if you want your audio card to emulate Microsoft Sound
+  System. You should then say Y to "Microsoft Sound System support"
+  and say N to "Audio Excel DSP 16 (SBPro emulation)".
+
+Audio Excel DSP 16 IRQ
+CONFIG_AEDSP16_MSS_IRQ
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 5, 7, 9,
+  10 or 11. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'irq=NN'.
+
+Audio Excel DSP 16 DMA
+CONFIG_AEDSP16_MSS_DMA
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 0, 1 
+  or 3. If you compiled aedsp16.o as a module you can specify this
+  parameter as 'dma=NN'.
+
+SC-6600 based audio cards (new Audio Excel DSP 16)
+CONFIG_SC6600
+  The SC6600 is the new version of DSP mounted on the Audio Excel DSP
+  16 cards. Find in the manual the FCC ID of your audio card and
+  answer Y if you have an SC6600 DSP.
+
+SC-6600 Joystick Interface
+CONFIG_SC6600_JOY
+  Say Y here in order to use the joystick interface of the Audio Excel
+  DSP 16 card.
+
+SC-6600 CDROM Interface
+CONFIG_SC6600_CDROM
+  This is used to activate the the CDROM interface of the Audio Excel
+  DSP 16 card. Enter: 0 for Sony, 1 for Panasonic, 2 for IDE, 4 for no
+  CDROM present.
+
+Audio Excel DSP 16 (MPU401 emulation)
+CONFIG_AEDSP16_MPU401
+  Answer Y if you want your audio card to emulate the MPU-401 midi
+  interface. You should then also say Y to "MPU-401 support".
+  
+  Note that the I/O base for MPU-401 support of aedsp16 is the same
+  you have selected for "MPU-401 support". If you are using this
+  driver as a module you have to specify the MPU I/O base address with
+  the parameter 'mpu_base=0xNNN'.
+
+MPU401 IRQ for Audio Excel DSP 16
+CONFIG_AEDSP16_MPU_IRQ
+  This is the IRQ of the MPU-401 emulation of your Audio Excel DSP 16
+  card. It must be 5, 7, 9, 10 or 0 (to disable MPU-401 interface). If
+  you compiled aedsp16.o as a module you can specify this parameter as
+  'mpu_irq=NN'.
+
+SGI Visual Workstation on-board audio
+CONFIG_SOUND_VWSND
+  Say Y or M if you have an SGI Visual Workstation and you want to
+  be able to use its on-board audio.  Read Documentation/sound/visws
+  for more info on this driver's capabilities.
+
+Creative EMU10K1 based PCI sound cards
+CONFIG_SOUND_EMU10K1
+  Say Y or M if you have a PCI sound card using the EMU10K1
+  chipset, such as the Creative SBLive!,  SB PCI512 or Emu-APS.
+
+Ensoniq ES1370 based PCI sound cards
+CONFIG_SOUND_ES1370
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1370 chipset, such as Ensoniq's AudioPCI (non-97). To find
+  out if your sound card uses an ES1370 without removing your
+  computer's cover, use lspci -n and look for the PCI ID 
+  1274:5000. Since Ensoniq was bought by Creative Labs,
+  Sound Blaster 64/PCI models are either ES1370 or ES1371 based.
+  This driver differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/es1370.
+
+Joystick support at boot time
+CONFIG_SOUND_ES1370_JOYPORT_BOOT
+  Say Y here to use the joystick port of your sound card.
+
+Ensoniq ES1371 based PCI sound cards
+CONFIG_SOUND_ES1371
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1371 chipset, such as Ensoniq's AudioPCI97. To find out if
+  your sound card uses an ES1371 without removing your computer's
+  cover, use lspci -n and look for the PCI ID 1274:1371. Since
+  Ensoniq was bought by Creative Labs, Sound Blaster 64/PCI
+  models are either ES1370 or ES1371 based. This driver differs
+  slightly from OSS/Free, so PLEASE READ Documentation/sound/es1371.
+
+Joystick support at boot time
+CONFIG_SOUND_ES1371_JOYPORT_BOOT
+  Say Y here to use the joystick port of your sound card.
+
+Gameport I/O-range selection
+CONFIG_SOUND_ES1371_GAMEPORT
+  Select the I/O-range of the gameport on a ES1371 based sound card.
+  The card uses 8 ioports and the gameport is available at all eight
+  ioports. Legal hexadecimal values are 200, 208, 210 and 218.
+  The joystick driver will by default use 0x201. 
+  Leave the default 200 unless you have a joystick not attached
+  to your sound card.
+
+ESS Solo1 based PCI sound cards (eg. SC1938)
+CONFIG_SOUND_ESSSOLO1
+  Say Y or M if you have a PCI sound card utilizing the ESS Technology
+  Solo1 chip. To find out if your sound card uses a
+  Solo1 chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 125D:1969. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/solo1.
+
+S3 SonicVibes based PCI sound cards
+CONFIG_SOUND_SONICVIBES
+  Say Y or M if you have a PCI sound card utilizing the S3
+  SonicVibes chipset. To find out if your sound card uses a
+  SonicVibes chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 5333:CA00. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/sonicvibes.
+  
+Trident 4DWave DX/NX or SiS 7018 PCI Audio Core or ALi 5451
+CONFIG_SOUND_TRIDENT
+  Say Y or M if you have a PCI sound card utilizing the Trident
+  4DWave-DX/NX chipset or your mother board chipset has SiS 7018
+  built-in, or if you have an ALi 5451. The SiS 7018 PCI Audio Core
+  is embedded in SiS960 Super South Bridge and SiS540/630 Single
+  Chipset.
+
+  Use lspci -n to find out if your sound card or chipset uses
+  Trident 4DWave or SiS 7018. PCI ID 1023:2000 or 1023:2001 stands
+  for Trident 4Dwave. PCI ID 1039:7018 stands for SiS7018.
+  PCI ID 10b9:5451 stands for ALi 5451.
+
+  This driver differs slightly from OSS/Free, so PLEASE READ the
+  comments at the beginning of driver/sound/trident.c
+
+Rockwell WaveArtist
+CONFIG_SOUND_WAVEARTIST
+  Say Y here to include support for the Rockwell WaveArtist sound
+  system.  This driver is mainly for the NetWinder.
+
+NeoMagic 256AV/256ZX sound chipsets
+CONFIG_SOUND_NM256
+  Say M here to include audio support for the NeoMagic 256AV/256ZX
+  chipsets.  These are the audio chipsets found in the Sony Z505S/SX/DX,
+  some Sony F-series, and the Dell Latitude CPi and CPt laptops. It includes 
+  support for an AC97-compatible mixer and an apparently proprietary sound 
+  engine.
+
+  See Documentation/sound/NM256 for further information.
+
+ESS Maestro sound chipsets
+CONFIG_SOUND_MAESTRO
+  Say Y or M if you have a sound system driven by ESS's Maestro line
+  of PCI sound chips.  These include the Maestro 1, Maestro 2, and
+  Maestro 2E.  See Documentation/sound/Maestro for more details.
+
+Are you using a crosscompiler
+CONFIG_CROSSCOMPILE
+  Say Y here if you are compiling the kernel on a different
+  architecture than the one it is intended to run on.
+
+Build fp exception handler module
+CONFIG_MIPS_FPE_MODULE
+  Build the floating point exception handler module. This option is
+  only useful for people working on the floating point exception
+  handler. If you don't, say N.
+
+Remote GDB kernel debugging
+CONFIG_REMOTE_DEBUG
+  If you say Y here, it will be possible to remotely debug the MIPS
+  kernel using gdb. This enlarges your kernel image disk size by
+  several megabytes and requires a machine with more than 16 MB,
+  better 32 MB RAM to avoid excessive linking time. This is only
+  useful for kernel hackers. If unsure, say N.
+
+Magic System Request Key support
+CONFIG_MAGIC_SYSRQ
+  If you say Y here, you will have some control over the system even
+  if the system crashes for example during kernel debugging (e.g., you
+  will be able to flush the buffer cache to disk, reboot the system
+  immediately or dump some status information). This is accomplished
+  by pressing various keys while holding SysRq (Alt+PrintScreen). The
+  keys are documented in Documentation/sysrq.txt. Don't say Y unless
+  you really know what this hack does.
+
+ISDN subsystem
+CONFIG_ISDN
+  ISDN ("Integrated Services Digital Networks", called RNIS in France)
+  is a special type of fully digital telephone service; it's mostly
+  used to connect to your Internet service provider (with SLIP or
+  PPP). The main advantage is that the speed is higher than ordinary
+  modem/telephone connections, and that you can have voice
+  conversations while downloading stuff. It only works if your
+  computer is equipped with an ISDN card and both you and your service
+  provider purchased an ISDN line from the phone company. For details,
+  read http://alumni.caltech.edu/~dank/isdn/ on the WWW.
+
+  This driver allows you to use an ISDN-card for networking
+  connections and as dialin/out device. The isdn-tty's have a built in
+  AT-compatible modem emulator. Network devices support autodial,
+  channel-bundling, callback and caller-authentication without having
+  a daemon running. A reduced T.70 protocol is supported with tty's
+  suitable for German BTX. On D-Channel, the protocols EDSS1
+  (Euro-ISDN) and 1TR6 (German style) are supported. See
+  Documentation/isdn/README for more information. 
+
+  If you want to compile the ISDN code as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called isdn.o. If unsure, say N.
+
+Support synchronous PPP
+CONFIG_ISDN_PPP
+  Over digital connections such as ISDN, there is no need to
+  synchronize sender and recipient's clocks with start and stop bits
+  as is done over analog telephone lines. Instead, one can use
+  "synchronous PPP". Saying Y here will include this protocol. This
+  protocol is used by Cisco and Sun for example. So you want to say Y
+  here if the other end of your ISDN connection supports it. You will
+  need a special version of pppd (called ipppd) for using this
+  feature. See Documentation/isdn/README.syncppp and
+  Documentation/isdn/syncPPP.FAQ for more information.
+
+Support generic MP (RFC 1717)
+CONFIG_ISDN_MPP
+  With synchronous PPP enabled, it is possible to increase throughput
+  by bundling several ISDN-connections, using this protocol. See
+  Documentation/isdn/README.syncppp for more information.
+
+Use VJ-compression with synchronous PPP
+CONFIG_ISDN_PPP_VJ
+  This enables Van Jacobson header compression for synchronous PPP.
+  Say Y if the other end of the connection supports it.
+
+Support audio via ISDN
+CONFIG_ISDN_AUDIO
+  If you say Y here, the modem-emulator will support a subset of the
+  EIA Class 8 Voice commands. Using a getty with voice-support
+  (mgetty+sendfax by gert@greenie.muc.de with an extension, available
+  with the ISDN utility package for example), you will be able to use
+  your Linux box as an ISDN-answering machine. Of course, this must be
+  supported by the lowlevel driver also. Currently, the HiSax driver
+  is the only voice-supporting driver. See
+  Documentation/isdn/README.audio for more information.
+
+X.25 PLP on top of ISDN
+CONFIG_ISDN_X25
+  This feature provides the X.25 protocol over ISDN connections.
+  See Documentation/isdn/README.x25 for more information
+  if you are thinking about using this.
+
+ISDN diversion services support
+CONFIG_ISDN_DIVERSION
+  This option allows you to use some supplementary diversion
+  services in conjunction with the HiSax driver on an EURO/DSS1
+  line. 
+
+  Supported options are CD (call deflection), CFU (Call forward
+  unconditional), CFB (Call forward when busy) and CFNR (call forward
+  not reachable). Additionally the actual CFU, CFB and CFNR state may
+  be interrogated.
+
+  The use of CFU, CFB, CFNR and interrogation may be limited to some
+  countries. The keypad protocol is still not implemented. CD should
+  work in all countries if the service has been subscribed to.
+
+  Please read the file Documentation/isdn/README.diversion.
+
+ICN 2B and 4B support
+CONFIG_ISDN_DRV_ICN
+  This enables support for two kinds of ISDN-cards made by a German
+  company called ICN. 2B is the standard version for a single ISDN
+  line with two B-channels, 4B supports two ISDN lines. For running
+  this card, additional firmware is necessary, which has to be
+  downloaded into the card using a utility which is distributed
+  separately. See Documentation/isdn/README and README.icn for more
+  information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called icn.o.
+
+isdnloop support
+CONFIG_ISDN_DRV_LOOP
+  This driver provides a virtual ISDN card. Its primary purpose is
+  testing of linklevel features or configuration without getting
+  charged by your service-provider for lots of phone calls.
+  You need will need the loopctrl utility from the latest isdn4k-utils
+  package to set up this driver.
+
+HiSax SiemensChipSet driver support
+CONFIG_ISDN_DRV_HISAX
+  This is a driver supporting the Siemens chipset on various
+  ISDN-cards (like AVM A1, Elsa ISDN cards, Teles S0-16.0, Teles
+  S0-16.3, Teles S0-8, Teles/Creatix PnP, ITK micro ix1 and many
+  compatibles). 
+
+  HiSax is just the name of this driver, not the name of any hardware.
+  
+  If you have a card with such a chipset, you should say Y here and
+  also to the configuration option of the driver for your particular
+  card, below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called hisax.o. See Documentation/isdn/README.HiSax for more
+  information on using this driver.
+
+HiSax Support for EURO/DSS1
+CONFIG_HISAX_EURO
+  Enable this if you have a EURO ISDN line.
+
+Support for german chargeinfo
+CONFIG_DE_AOC
+  If you have german AOC, you can enable this to get the charginfo.
+
+Disable sending complete
+CONFIG_HISAX_NO_SENDCOMPLETE
+  If you have trouble with some ugly exchanges or you live in
+  Australia select this option.
+
+Disable sending low layer compatibility
+CONFIG_HISAX_NO_LLC
+  If you have trouble with some ugly exchanges try to select this
+  option.
+
+Disable keypad protocol option
+CONFIG_HISAX_NO_KEYPAD
+  If you like to send special dialstrings including * or # without
+  using the keypad protocol, select this option.
+
+HiSax Support for german 1TR6
+CONFIG_HISAX_1TR6
+  Enable this if you have a old german 1TR6 line.
+
+Teles 16.0/8.0
+CONFIG_HISAX_16_0
+  This enables HiSax support for the Teles ISDN-cards S0-16.0, S0-8
+  and many compatibles. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port/shmem settings.
+
+Teles 16.3 or PNP or PCMCIA
+CONFIG_HISAX_16_3
+  This enables HiSax support for the Teles ISDN-cards S0-16.3 the
+  Teles/Creatix PnP and the Teles PCMCIA.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Teles PCI
+CONFIG_HISAX_TELESPCI
+  This enables HiSax support for the Teles PCI.
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+Teles S0Box
+CONFIG_HISAX_S0BOX
+  This enables HiSax support for the Teles/Creatix parallel port
+  S0BOX.  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 (Fritz)
+CONFIG_HISAX_AVM_A1
+  This enables HiSax support for the AVM A1 (aka "Fritz").
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+AVM PnP/PCI (Fritz!PNP/PCI)
+CONFIG_HISAX_FRITZPCI
+  This enables HiSax support for the AVM "Fritz!PnP" and "Fritz!PCI".
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 PCMCIA (Fritz)
+CONFIG_HISAX_AVM_A1_PCMCIA
+  This enables HiSax support for the AVM A1 "Fritz!PCMCIA").
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+Elsa cards
+CONFIG_HISAX_ELSA
+  This enables HiSax support for the Elsa Mircolink ISA cards, for the
+  Elsa Quickstep series cards and Elsa PCMCIA.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ITK ix1-micro Revision 2
+CONFIG_HISAX_IX1MICROR2
+  This enables HiSax support for the ITK ix1-micro Revision 2 card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Eicon.Diehl Diva cards
+CONFIG_HISAX_DIEHLDIVA
+  This enables HiSax support for the Eicon.Diehl Diva none PRO
+  versions passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ASUSCOM ISA cards
+CONFIG_HISAX_ASUSCOM
+  This enables HiSax support for the AsusCom and their OEM versions
+  passive ISDN ISA cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+TELEINT cards
+CONFIG_HISAX_TELEINT
+  This enables HiSax support for the TELEINT SA1 semiactiv ISDN card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+HFC-S based cards
+CONFIG_HISAX_HFCS
+  This enables HiSax support for the HFC-S 2BDS0 based cards, like
+  teles 16.3c.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Sedlbauer cards
+CONFIG_HISAX_SEDLBAUER
+  This enables HiSax support for the Sedlbauer passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+USR Sportster internal TA
+CONFIG_HISAX_SPORTSTER
+  This enables HiSax support for the USR Sportster internal TA card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+MIC card
+CONFIG_HISAX_MIC
+  This enables HiSax support for the ITH MIC card. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+NETjet card
+CONFIG_HISAX_NETJET
+  This enables HiSax support for the NetJet from Traverse
+  Technologies.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Niccy PnP/PCI card
+CONFIG_HISAX_NICCY
+  This enables HiSax support for the Dr. Neuhaus Niccy PnP or PCI. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Siemens I-Surf card
+CONFIG_HISAX_ISURF
+  This enables HiSax support for the Siemens I-Talk/I-Surf card with
+  ISAR chip.
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HST Saphir card
+CONFIG_HISAX_HSTSAPHIR
+  This enables HiSax support for the HST Saphir card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Telekom A4T card
+CONFIG_HISAX_BKM_A4T
+  This enables HiSax support for the Telekom A4T card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Scitel Quadro card
+CONFIG_HISAX_SCT_QUADRO
+  This enables HiSax support for the Scitel Quadro card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Gazel cards
+CONFIG_HISAX_GAZEL
+  This enables HiSax support for the Gazel cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC PCI-Bus cards
+CONFIG_HISAX_HFC_PCI
+  This enables HiSax support for the HFC-S PCI 2BDS0 based cards.
+  
+  For more informations see under Documentation/isdn/README.hfc-pci.
+
+Winbond W6692 based cards
+CONFIG_HISAX_W6692
+  This enables HiSax support for Winbond W6692 based PCI ISDN cards.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC-S+, HFC-SP, HFC-PCMCIA cards (EXPERIMENTAL)
+CONFIG_HISAX_HFC_SX
+  This enables HiSax support for the HFC-S+, HFC-SP and HFC-PCMCIA cards.
+  This code is not finished yet.
+
+Am7930 (EXPERIMENTAL)
+CONFIG_HISAX_AMD7930
+  This enables HiSax support for the AMD7930 chips on some SPARCs.
+  This code is not finished yet.
+
+PCBIT-D support
+CONFIG_ISDN_DRV_PCBIT
+  This enables support for the PCBIT ISDN-card. This card is
+  manufactured in Portugal by Octal. For running this card, additional
+  firmware is necessary, which has to be downloaded into the card
+  using a utility which is distributed separately. See
+  Documentation/isdn/README and Documentation/isdn/README.pcbit for
+  more information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pcbit.o.
+
+Spellcaster support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_SC
+  This enables support for the Spellcaster BRI ISDN boards. This
+  driver currently builds only in a modularized version ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want, details in Documentation/modules.txt); the module will be
+  called sc.o. See Documentation/isdn/README.sc and
+  http://www.spellcast.com for more information.
+
+Eicon.Diehl active card support
+CONFIG_ISDN_DRV_EICON
+  Say Y here if you have an Eicon active ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using the eiconctrl utility which is part of the
+  latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+  
+Eicon old-type card support
+CONFIG_ISDN_DRV_EICON_ISA
+  Say Y here if you have an old-type Eicon active ISDN card. In order
+  to use this card, additional firmware is necessary, which has to be
+  loaded into the card using the eiconctrl utility which is part of
+  the latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+
+Support AT-Fax Class 2 commands
+CONFIG_ISDN_TTY_FAX
+  If you say Y here, the modem-emulator will support a subset of the
+  Fax Class 2 commands. Using a getty with fax-support
+  (mgetty+sendfax, hylafax), you will be able to use your Linux box as
+  an ISDN-fax-machine. This must be supported by the lowlevel driver
+  also. See Documentation/isdn/README.fax for more information.
+
+AVM CAPI2.0 support
+CONFIG_ISDN_DRV_AVMB1
+  This enables support for the AVM B1/T1 ISDN networking cards.In
+  addition, a CAPI (Common ISDN Application Programming Interface, a
+  standard making it easy for programs to access ISDN hardware, see
+  http://www.capi.org/; to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape)
+  interface for this card is provided. In order to use this card,
+  additional firmware is necessary, which has to be downloaded into
+  the card using a utility which is distributed separately. Please
+  read the file Documentation/isdn/README.avmb1. 
+  
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called avmb1.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AVM B1 ISA support
+CONFIG_ISDN_DRV_AVMB1_B1ISA
+  Enable support for the ISA version of the AVM B1 card.
+
+AVM B1 PCI support
+CONFIG_ISDN_DRV_AVMB1_B1PCI
+  Enable support for the PCI version of the AVM B1 card.
+
+AVM B1 PCI V4 support
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4
+  Enable support for the V4 version of AVM B1 PCI card.
+
+AVM T1/T1-B ISA support
+CONFIG_ISDN_DRV_AVMB1_T1ISA
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM B1/M1/M2 PCMCIA support
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA
+  Enable support for the PCMCIA version of the AVM B1 card.
+
+AVM T1/T1-B PCI support
+CONFIG_ISDN_DRV_AVMB1_T1PCI
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM C4 support
+CONFIG_ISDN_DRV_AVMB1_C4
+  Enable support for the AVM C4 PCI card.
+  This card handle 4 BRI ISDN lines (8 channels).
+
+Verbose reason code reporting (kernel size +=7K)
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
+  If you say Y here, the AVM B1 driver will give verbose reasons for
+  disconnecting. This will increase the size of the kernel by 7 KB. If
+  unsure, say Y.
+
+
+IBM Active 2000 support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_ACT2000
+  Say Y here if you have an IBM Active 2000 ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using a utility which is part of the latest
+  isdn4k-utils package. Please read the file
+  Documentation/isdn/README.act2000 for more information.
+
+Support for AP1000 multicomputer
+CONFIG_AP1000
+  This enables support for a SPARC based parallel multi-computer
+  called AP1000+. For details on our efforts to port Linux to this
+  machine see http://cap.anu.edu.au/cap/projects/linux (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) or mail to hackers@cafe.anu.edu.au
+
+Support for Sun4 architecture
+CONFIG_SUN4
+  Say Y here if, and only if, your machine is a Sun4. Note that
+  a kernel compiled with this option will run only on Sun4.
+  (And the current version will probably work only on sun4/330.)
+
+SPARC ESP SCSI support
+CONFIG_SCSI_SUNESP
+  This is the driver for the Sun ESP SCSI host adapter. The ESP
+  chipset is present in most SPARC-based computers.
+
+SPARC /dev/openprom compatibility driver
+CONFIG_SUN_OPENPROMIO
+  This driver provides user programs with an interface to the SPARC
+  PROM device tree. The driver implements a SunOS-compatible
+  interface and a NetBSD-compatible interface. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. If unsure, say Y.
+
+Mostek real time clock support
+CONFIG_SUN_MOSTEK_RTC
+  The Mostek RTC chip is used on all knows Sun computers except
+  some JavaStation-s. For a JavaStation you need to say Y both here
+  and to CONFIG_RTC.
+
+  Say Y here unless you are building a special purpose kernel.
+
+#
+#Siemens SAB82532 serial support
+#CONFIG_SAB82532
+###
+### Please someone fill these in.
+###
+
+#
+# m68k-specific kernel options
+# Documented by Chris Lawrence <quango@themall.net> et al.
+#
+Amiga support
+CONFIG_AMIGA
+  This option enables support for the Amiga series of computers. If
+  you plan to use this kernel on an Amiga, say Y here and browse the
+  material available in Documentation/m68k; otherwise say N.
+
+Atari support
+CONFIG_ATARI
+  This option enables support for the 68000-based Atari series of
+  computers (including the TT, Falcon and Medusa). If you plan to use
+  this kernel on an Atari, say Y here and browse the material
+  available in Documentation/m68k; otherwise say N.
+
+Hades support
+CONFIG_HADES
+  This option enables support for the Hades Atari clone. If you plan
+  to use this kernel on a Hades, say Y here; otherwise say N.
+
+Macintosh support
+CONFIG_MAC
+  This option enables support for the Apple Macintosh series of
+  computers (yes, there is experimental support now, at least for part
+  of the series).
+  
+  Say N unless you're willing to code the remaining necessary support.
+  ;)
+
+HP9000/300 support
+CONFIG_HP300
+  This option enables support for the HP9000/300 series of
+  workstations. Support for these machines is still very experimental.
+  If you plan to try to use the kernel on such a machine say Y here.
+  Everybody else says N.
+
+68020 support
+CONFIG_M68020
+  If you anticipate running this kernel on a computer with a MC68020
+  processor, say Y. Otherwise, say N. Note that the 68020 requires a
+  68851 MMU (Memory Management Unit) to run Linux/m68k.
+
+68030 support
+CONFIG_M68030
+  If you anticipate running this kernel on a computer with a MC68030
+  processor, say Y. Otherwise, say N. Note that a MC68EC030 will not
+  work, as it does not include an MMU (Memory Management Unit).
+
+68040 support
+CONFIG_M68040
+  If you anticipate running this kernel on a computer with a MC68LC040
+  or MC68040 processor, say Y. Otherwise, say N. Note that an
+  MC68EC040 will not work, as it does not include an MMU (Memory
+  Management Unit).
+
+68060 support
+CONFIG_M68060
+  If you anticipate running this kernel on a computer with a MC68060
+  processor, say Y. Otherwise, say N.
+
+Math emulation support
+CONFIG_FPU_EMU
+  At some point in the future, this will cause floating-point math
+  instructions to be emulated by the kernel on machines that lack a
+  floating-point math coprocessor.  Thrill-seekers and chronically
+  sleep-deprived psychotic hacker types can say Y now, everyone else
+  should probably wait a while.
+
+Math emulation only kernel
+CONFIG_FPU_EMU_ONLY
+  This option prevents any floating-point instructions from being
+  compiled into the kernel, thereby the kernel doesn't save any
+  floating point context anymore during task switches, so this
+  kernel will only be usable on machines without a floating-point
+  math coprocessor. This makes the kernel a bit faster as no tests
+  needs to be executed whether a floating-point instruction in the
+  kernel should be executed or not.
+
+Math emulation extra precision
+CONFIG_FPU_EMU_EXTRAPREC
+  The fpu uses normally a few bit more during calculations for
+  correct rounding, the emulator can (often) do the same but this
+  extra calculation can cost quite some time, so you can disable
+  it here. The emulator will then only calculate with a 64 bit
+  mantissa and round slightly incorrect.
+
+Advanced processor options
+CONFIG_ADVANCED_CPU
+  This gives you access to some advanced options for the CPU. The
+  defaults should be fine for most users, but these options may make
+  it possible for you to improve performance somewhat if you know what
+  you are doing. Most users should say N to this question.
+
+Use read-modify-write instructions
+CONFIG_RMW_INSNS
+  This allows to use certain instructions that work with indivisible
+  read-modify-write bus cycles. While this is faster than the
+  workaround of disabling interrupts, it can conflict with DMA 
+  ( = direct memory access) on many Amiga systems, and it is also said
+  to destabilize other machines. It is very likely that this will
+  cause serious problems on any Amiga or Atari Medusa if set. The only
+  configuration where it should work are 68030-based Ataris, where it
+  apparently improves performance. But you've been warned! Unless you
+  really know what you are doing, say N. Try Y only if you're quite
+  adventurous.
+
+Amiga AutoConfig Identification
+CONFIG_ZORRO
+  This enables support for automatic identification of Amiga expansion
+  cards that obey the AutoConfig(tm) specification.
+  Say Y if you want your expansion cards to be identified on bootup;
+  it will enlarge your kernel by about 10 KB. The identification
+  information is also available through /proc/zorro (say Y to
+  "/proc filesystem support"!).
+
+  Note that even if you say N here, you can still use your expansion
+  cards. If in doubt, say Y.
+
+Amiga 1200/600 PCMCIA support
+CONFIG_AMIGA_PCMCIA
+  Include support in the kernel for pcmcia on Amiga 1200 and Amiga 600.
+  If you intend to use pcmcia cards say Y; otherwise say N.
+
+Amiga GSP (TMS340x0) support
+CONFIG_AMIGA_GSP
+  Include support for Amiga graphics cards that use the Texas
+  Instruments TMS340x0 GSP (Graphics Signal Processor) chips. Say Y
+  if you want to use a DMI Resolver or Commodore A2410 (Lowell)
+  graphics card on an Amiga; otherwise, say N.
+
+DMI Resolver support
+CONFIG_GSP_RESOLVER
+  Include support in the kernel for the DMI Resolver graphics card. If
+  you have one, say Y; otherwise, say N.
+
+A2410 support
+CONFIG_GSP_A2410
+  Include support in the kernel for the Commodore/University of Lowell
+  A2410 graphics card. If you have one, say Y; otherwise, say N.
+
+Amiga Zorro II ramdisk support
+CONFIG_AMIGA_Z2RAM
+  This enables support for using Chip RAM and Zorro II RAM as a
+  ramdisk or as a swap partition. Say Y if you want to include this
+  driver in the kernel. This driver is also available as a module 
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). The module is called z2ram.o. If you want
+  to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari ST-RAM swap support
+CONFIG_STRAM_SWAP
+  This enables support for using (parts of) ST-RAM as swap space,
+  instead of as normal system memory. This can first enhance system
+  performance if you have lots of alternate RAM (compared to the size
+  of ST-RAM), because executable code always will reside in faster
+  memory. ST-RAM will remain as ultra-fast swap space. On the other
+  hand, it allows much improved dynamic allocations of ST-RAM buffers
+  for device driver modules (e.g. floppy, ACSI, SLM printer, DMA
+  sound). The probability that such allocations at module load time
+  fail is drastically reduced.
+
+Atari ACSI support
+CONFIG_ATARI_ACSI
+  This enables support for the Atari ACSI interface. The driver
+  supports hard disks and CD-ROMs, which have 512-byte sectors, or can
+  be switched to that mode. Due to the ACSI command format, only disks
+  up to 1 GB are supported. Special support for certain ACSI to SCSI
+  adapters, which could relax that, isn't included yet. The ACSI
+  driver is also the basis for certain other drivers for devices
+  attached to the ACSI bus: Atari SLM laser printer, BioNet-100
+  Ethernet, and PAMsNet Ethernet. If you want to use one of these
+  devices, you need ACSI support, too. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acsi.o.
+
+Probe all LUNs on each ACSI device
+CONFIG_ACSI_MULTI_LUN
+  If you have a ACSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, you should say Y here so that all
+  will be found by the ACSI driver. An ACSI device with multiple LUNs
+  acts logically like multiple ACSI devices. The vast majority of ACSI
+  devices have only one LUN, and so most people can say N here and
+  should in fact do so, because it is safer.
+
+Atari SLM laser printer support
+CONFIG_ATARI_SLM
+  If you have an Atari SLM laser printer, say Y to include support for
+  it in the kernel. Otherwise, say N. This driver is also available as
+  a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). The module will be called
+  acsi_slm.o. Be warned: the driver needs much ST-RAM and can cause
+  problems due to that fact!
+
+A3000 WD33C93A support
+CONFIG_A3000_SCSI
+  If you have an Amiga 3000 and have SCSI devices connected to the
+  built-in SCSI controller, say Y. Otherwise, say N. This driver is
+  also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module is
+  called wd33c93.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+A2091 WD33C93A support
+CONFIG_A2091_SCSI
+  If you have a Commodore A2091 SCSI controller, say Y. Otherwise,
+  say N. This driver is also available as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). The module is called wd33c93.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+GVP Series II WD33C93A support
+CONFIG_GVP11_SCSI
+  If you have a Great Valley Products Series II SCSI controller,
+  answer Y. Also say Y if you have a later model of GVP SCSI
+  controller (such as the GVP A4008 or a Combo board). Otherwise,
+  answer N. This driver does NOT work for the T-Rex series of
+  accelerators from TekMagic and GVP-M.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called gvp11.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Cyberstorm SCSI support
+CONFIG_CYBERSTORM_SCSI
+  If you have an Amiga with an original (MkI) Phase5 Cyberstorm
+  accelerator board and the optional Cyberstorm SCSI controller,
+  answer Y. Otherwise, say N.
+
+Cyberstorm II SCSI support
+CONFIG_CYBERSTORMII_SCSI
+  If you have an Amiga with a Phase5 Cyberstorm MkII accelerator board
+  and the optional Cyberstorm SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 2060 SCSI support
+CONFIG_BLZ2060_SCSI
+  If you have an Amiga with a Phase5 Blizzard 2060 accelerator board
+  and want to use the onboard SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 1230IV/1260 SCSI support
+CONFIG_BLZ1230_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard 1230IV or Blizzard
+  1260 accelerator, and the optional SCSI module, say Y. Otherwise,
+  say N.
+
+Blizzard PowerUP 603e+ SCSI support
+CONFIG_BLZ603EPLUS_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard PowerUP 603e+
+  accelerator, say Y. Otherwise, say N.
+
+Fastlane SCSI support
+CONFIG_FASTLANE_SCSI
+  If you have the Phase5 Fastlane Z3 SCSI controller, or plan to use
+  one in the near future, say Y to this question. Otherwise, say N.
+
+Atari native SCSI support
+CONFIG_ATARI_SCSI
+  If you have an Atari with built-in NCR5380 SCSI controller (TT,
+  Falcon, ...) say Y to get it supported. Of course also, if you have
+  a compatible SCSI controller (e.g. for Medusa). This driver is also
+  available as a module ( = code which can be inserted in and removed
+  from the running kernel whenever you want). The module is called
+  atari_scsi.o. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. This driver supports both styles of
+  NCR integration into the system: the TT style (separate DMA), and
+  the Falcon style (via ST-DMA, replacing ACSI). It does NOT support
+  other schemes, like in the Hades (without DMA).
+
+Long delays for Toshiba CD-ROMs
+CONFIG_ATARI_SCSI_TOSHIBA_DELAY
+  This option increases the delay after a SCSI arbitration to
+  accommodate some flaky Toshiba CD-ROM drives. Say Y if you intend to
+  use a Toshiba CD-ROM drive; otherwise, the option is not needed and
+  would impact performance a bit, so say N.
+
+Hades SCSI DMA emulator (EXPERIMENTAL)
+CONFIG_TT_DMA_EMUL
+  This option enables code which emulates the TT SCSI DMA chip on the
+  Hades. This increases the SCSI transfer rates at least ten times
+  compared to PIO transfers. Note that this code is experimental and
+  has only been tested on a Hades with a 68060 processor. Before you
+  use this, make backups of your entire hard disk.
+
+Macintosh NCR5380 (II-series) SCSI
+CONFIG_MAC_SCSI
+  If you have a Macintosh with NCR5380-based SCSI, say Y.  Otherwise,
+  say N.  This SCSI adaptor is found on all 68030-based Macs,
+  including the II, IIx, IIcx, IIci, IIsi, IIvx, IIvi, Color Classic,
+  Classic II, LC II, LC III, and their associated Performa models, as
+  well as the 68030-based PowerBooks and Duos.
+
+Macintosh NCR53c9[46] (Quadra/Centris) SCSI
+CONFIG_SCSI_MAC_ESP
+  If you have a Macintosh with NCR53c96 or NCR53c94-based SCSI, say
+  Y.  Otherwise, say N.  These SCSI adaptors are found on all
+  68040-based Macs, including all Quadra and Centris models, the LC
+  475/476 and 575, and the Performa 575, 580, and 630.
+
+Ariadne support
+CONFIG_ARIADNE
+  If you have a Village Tronic Ariadne Ethernet adapter, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called ariadne.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Ariadne II support
+CONFIG_ARIADNE2
+  If you have a Village Tronic Ariadne II Ethernet adapter, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called ariadne2.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+A2065 support
+CONFIG_A2065
+  If you have a Commodore A2065 Ethernet adapter, say Y. Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called a2065.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Hydra support
+CONFIG_HYDRA
+  If you have a Hydra Ethernet adapter, say Y. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called hydra.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Pcmcia NE2000 compatible support
+CONFIG_APNE
+  If you have a pcmcia ne2000 compatible adapter, say Y.  Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called apne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari Lance support
+CONFIG_ATARILANCE
+  Say Y to include support for several Atari Ethernet adapters based
+  on the AMD Lance chipset: RieblCard (with or without battery), or
+  PAMCard VME (also the version by Rhotron, with different addresses).
+
+BioNet-100 support
+CONFIG_ATARI_BIONET
+  Say Y to include support for BioData's BioNet-100 Ethernet adapter
+  for the ACSI port. The driver works (has to work...) with a polled
+  I/O scheme, so it's rather slow :-(
+
+PAMsNet support
+CONFIG_ATARI_PAMSNET
+  Say Y to include support for the PAMsNet Ethernet adapter for the
+  ACSI port ("ACSI node"). The driver works (has to work...) with a
+  polled I/O scheme, so it's rather slow :-(
+
+Macintosh NS 8390 based ethernet cards
+CONFIG_DAYNAPORT
+  Say Y to include support for Macintosh ethernet adaptors based on
+  the National Semiconductor 8390 and ST-NIC chips.  This family of
+  cards includes the majority of NuBus ethernet cards, as well as many
+  LC-PDS slot cards, from Apple, Asante, Cabletron, Farallon, and
+  other manufacturers.
+
+Macintosh SONIC based ethernet
+CONFIG_MACSONIC
+  Say Y to include support for Macintosh ethernet adaptors based on
+  the National Semiconductor SONIC chip (83932 and 83934).  If you
+  have a Quadra with onboard SONIC ethernet, say Y here.  Onboard
+  SONIC ethernet chips are found on all Quadra 605, 610, 650, 700,
+  800, 900, and 950 models, all Centris 650, most Centris 610, and all
+  LC475/476 models.  It is also found in the DuoDock Plus and DuoDock
+  II, as well as many NuBus, LC-PDS, and comm-slot cards. 
+
+Macintosh (AV) onboard MACE ethernet
+CONFIG_MACMACE
+  Say Y here if you have a Centris 660AV, a Quadra 660AV, or a Quadra
+  840AV, and you would like to use the onboard MACE Ethernet adaptor.
+
+
+Multiface Card III parallel support
+CONFIG_MULTIFACE_III_LP
+  If you have a Multiface III card for your Amiga, and want to use its
+  parallel port in Linux, say Y. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called lp_m68k.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amiga mouse support
+CONFIG_AMIGAMOUSE
+  If you want to be able to use an Amiga mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called amigamouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amiga Copper Console
+CONFIG_COPCON
+  This configures the console to use the Amiga's graphics coprocessor
+  for scrolling, instead of using the CPU. This option markedly
+  improves response times in the high color modes (5 bitplanes and
+  up). If you would like to use this, say Y; otherwise, say N.
+
+Atari mouse support
+CONFIG_ATARIMOUSE
+  If you want to be able to use an Atari mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called atarimouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari MFP serial support
+CONFIG_ATARI_MFPSER
+  If you like to use the MFP serial ports ("Modem1", "Serial1") under
+  Linux, say Y. The driver equally supports all kinds of MFP serial
+  ports and automatically detects whether Serial1 is available. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. 
+
+  Note for Falcon users: You also have an MFP port, it's just not
+  wired to the outside... But you could use the port under Linux.
+
+Atari SCC serial support
+CONFIG_ATARI_SCC
+  If you have serial ports based on a Zilog SCC chip (Modem2, Serial2,
+  LAN) and like to use them under Linux, say Y. All built-in SCC's are
+  supported (TT, MegaSTE, Falcon), and also the ST-ESCC. If you have
+  two connectors for channel A (Serial2 and LAN), they are visible as
+  two separate devices.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari SCC serial DMA support
+CONFIG_ATARI_SCC_DMA
+  This enables DMA support for receiving data on channel A of the SCC.
+  If you have a TT you may say Y here and read
+  drivers/char/atari_SCC.README. All other users should say N here,
+  because only the TT has SCC-DMA, even if your machine keeps claiming
+  so at boot time.
+
+Atari MIDI serial support
+CONFIG_ATARI_MIDI
+  If you want to use your Atari's MIDI port in Linux, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari DSP56k Digital Signal Processor support
+CONFIG_ATARI_DSP56K
+  If you want to be able to use the DSP56001 in Falcons, say Y. This
+  driver is still experimental, and if you don't know what it is, or
+  if you don't have this processor, just say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Amiga builtin serial support
+CONFIG_AMIGA_BUILTIN_SERIAL
+  If you want to use your Amiga's built-in serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+GVP IO-Extender support
+CONFIG_GVPIOEXT
+  If you want to use a GVP IO-Extender serial card in Linux, say Y.
+  Otherwise, say N.
+
+Multiface Card III serial support
+CONFIG_MULTIFACE_III_TTY
+  If you want to use a Multiface III card's serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Macintosh SCC serial support
+CONFIG_MAC_SCC
+  If you have a Macintosh and would like to use its serial
+  ("Printer" and "Modem") ports in Linux, say Y.  Otherwise, say N.
+
+Amiga or Atari DMA sound support
+CONFIG_DMASOUND
+  If you want to use the internal audio of your Atari or Amiga in
+  Linux, answer Y to this question. This will provide a Sun-like
+  /dev/audio, compatible with the Linux/i386 sound system. Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+HP DCA serial support
+CONFIG_HPDCA
+  If you want to use the internal "DCA" serial ports on an HP300
+  machine, say Y here.
+
+HP on-board LANCE support
+CONFIG_HPLANCE
+  If you want to use the builtin "LANCE" Ethernet controller on an
+  HP300 machine, say Y here.
+
+DIO bus support
+CONFIG_DIO
+  Say Y here to enable support for the "DIO" expansion bus used in
+  HP300 machines. If you are using such a system you almost certainly
+  want this.
+
+MSDOS partition support
+CONFIG_MSDOS_PARTITION
+  This option enables support for using hard disks that were
+  partitioned on an MS-DOS system. This may be useful if you are
+  sharing a hard disk between i386 and m68k Linux boxes, for example.
+  Say Y if you need this feature; users who are only using their
+  system-native partitioning scheme can say N here.
+
+Processor Type
+CONFIG_6xx
+  There are two types of PowerPC chips supported. The more common
+  types (601,603,604,740,750) and the embedded versions (821 and 860).
+  Unless you are building a kernel for one of the embedded boards
+  using the 821 or 860 choose 6xx.
+
+Machine Type
+CONFIG_PMAC
+  Linux currently supports several different kinds of PowerPC-based
+  machines: Apple Power Macintoshes and clones (such as the Motorola
+  Starmax series), PReP (PowerPC Reference Platform) machines such as
+  the Motorola PowerStack, Amiga Power-Up systems (APUS), CHRP and the
+  embedded MBX boards from Motorola. Currently, a single kernel binary
+  only supports one type or the other. However, there is very early
+  work on support for CHRP, PReP and PowerMac's from a single binary.
+
+Support for Open Firmware device tree in /proc
+CONFIG_PROC_DEVICETREE
+  This option adds a device-tree directory under /proc which contains
+  an image of the device tree that the kernel copies from Open
+  Firmware. If unsure, say Y here.
+
+MESH (Power Mac internal SCSI) support
+CONFIG_SCSI_MESH
+  Many Power Macintoshes and clones have a MESH (Macintosh Enhanced
+  SCSI Hardware) SCSI bus adaptor (the 7200 doesn't, but all of the
+  other Power Macintoshes do). Say Y to include support for this SCSI
+  adaptor. This driver is also available as a module called mesh.o
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+
+Maximum synchronous transfer rate
+CONFIG_SCSI_MESH_SYNC_RATE
+  On Power Macintoshes (and clones) where the MESH SCSI bus adaptor
+  drives a bus which is entirely internal to the machine (such as the
+  7500, 7600, 8500, etc.), the MESH is capable of synchronous
+  operation at up to 10 MB/s. On machines where the SCSI bus
+  controlled by the MESH can have external devices connected, it is
+  usually rated at 5 MB/s. 5 is a safe value here unless you know the
+  MESH SCSI bus is internal only; in that case you can say 10. Say 0
+  to disable synchronous operation.
+
+53C94 (Power Mac external SCSI) support
+CONFIG_SCSI_MAC53C94
+  On Power Macintoshes (and clones) with two SCSI buses, the external
+  SCSI bus is usually controlled by a 53C94 SCSI bus adaptor. Older
+  machines which only have one SCSI bus, such as the 7200, also use
+  the 53C94. Say Y to include support for the 53C94. 
+
+  This driver is also available as a module called mac53c94.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+MACE (Power Mac Ethernet) support
+CONFIG_MACE
+  Power Macintoshes and clones with Ethernet built-in on the
+  motherboard will usually use a MACE (Medium Access Control for
+  Ethernet) interface. Say Y to include support for the MACE chip.
+
+  This driver is also available as a module called mace.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Use AAUI port instead of TP by default
+CONFIG_MACE_AAUI_PORT
+  Some Apple machines (notably the Apple Network Server) which use the
+  MACE ethernet chip have an Apple AUI port (small 15-pin connector),
+  instead of an 8-pin RJ45 connector for twisted-pair ethernet.  Say
+  Y here if you have such a machine.  If unsure, say N.
+
+BMAC (G3/G4 ethernet) support
+CONFIG_BMAC
+  Say Y for support of BMAC and BMAC+ Ethernet interfaces. These
+  are used on G3 and G4 computers (Apple Power Macintoshes and
+  PowerBooks).
+
+  This driver is also available as a module called bmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+GMAC (Core99 ethernet) support
+CONFIG_GMAC
+  Say Y for support of the GMAC Ethernet interfaces. This interface
+  is used on some Apple G4 PowerMacs (recent ones), new iMacs, iBooks
+  and PowerBook 2000 (aka "Pismo").
+
+  This driver is also available as a module called gmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Video For Linux
+CONFIG_VIDEO_DEV
+  Support for audio/video capture and overlay devices and FM radio
+  cards. The exact capabilities of each device vary. User tools for
+  this are available from
+  ftp://ftp.uk.linux.org/pub/linux/video4linux.
+
+  If you are interested in writing a driver for such an audio/video
+  device or user software interacting with such a driver, please read
+  the file Documentation/video4linux/API.html.
+
+  This driver is also available as a module called videodev.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+AIMSlab RadioTrack (aka RadioReveal) support
+CONFIG_RADIO_RTRACK
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  Note that newer AIMSlab RadioTrack cards have a different chipset
+  and are not supported by this driver. For these cards, use the
+  RadioTrack II driver below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape. More information is contained in the
+  file Documentation/video4linux/radiotrack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aimslab.o.
+
+RadioTrack i/o port
+CONFIG_RADIO_RTRACK_PORT
+  Enter either 0x30f or 0x20f here. The card default is 0x30f, if you
+  haven't changed the jumper setting on the card.
+
+AIMSlab RadioTrack II support
+CONFIG_RADIO_RTRACK2
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-rtrack2.o.
+
+RadioTrack II i/o port
+CONFIG_RADIO_RTRACK2_PORT
+  Enter either 0x30c or 0x20c here. The card default is 0x30c, if you
+  haven't changed the jumper setting on the card.
+
+Aztech/Packard Bell Radio
+CONFIG_RADIO_AZTECH
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aztech.o.
+
+Aztech/Packard Bell radio card i/o port
+CONFIG_RADIO_AZTECH_PORT
+  Enter either 0x350 or 0x358 here. The card default is 0x350, if you
+  haven't changed the setting of jumper JP3 on the card. Removing the
+  jumper sets the card to 0x358.
+
+ADS Cadet AM/FM Radio Tuner Card
+CONFIG_RADIO_CADET
+  Choose Y here if you have one of these AM/FM radio cards, and then fill
+  in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  Further documentation on this driver can be found on the WWW at
+  http://linux.blackhawke.net/cadet.html. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-cadet.o.
+
+ADS Cadet AM/FM Radio Tuner Card I/O Port
+CONFIG_RADIO_CADET_PORT
+  Enter the I/O address of the card here (most commonly 330). 
+
+Maestro Radio
+CONFIG_RADIO_MAESTRO
+  Choose Y here if you have one of these Maestro sound cards
+  with FM radio included.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-maestro.o
+
+SF16FMI Radio
+CONFIG_RADIO_SF16FMI
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-sf16fmi.o
+
+SF16FMI I/O port (0x284 or 0x384)
+CONFIG_RADIO_SF16FMI_PORT
+  Enter the I/O port of your SF16FMI radio card.
+
+Typhoon Radio
+CONFIG_RADIO_TYPHOON
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address and the frequency used for muting below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-typhoon.o
+
+Support for /proc/radio-typhoon
+CONFIG_RADIO_TYPHOON_PROC_FS
+  Say Y here if you want the typhoon radio card driver to write
+  status information (frequency, volume, muted, mute frequency,
+  base address) to /proc/radio-typhoon. The file can be viewed with
+  your favorite pager (i.e. use "more /proc/radio-typhoon" or "less
+  /proc/radio-typhoon" or simply "cat /proc/radio-typhoon").
+
+Typhoon I/O port (0x316 or 0x336)
+CONFIG_RADIO_TYPHOON_PORT
+  Enter the I/O port of your Typhoon or EcoRadio radio card.
+
+Typhoon frequency set when muting the device (kHz)
+CONFIG_RADIO_TYPHOON_MUTEFREQ
+  Enter the frequency used for muting the radio. The device is never
+  completely silent. If the volume is just turned down, you can still
+  hear silent voices and music. For that reason, the frequency of the
+  radio device is set to the frequency you can enter here whenever
+  the device is muted. There should be no local radio station at that
+  frequency.
+
+Zoltrix Radio
+CONFIG_RADIO_ZOLTRIX
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-zoltrix.o
+
+ZOLTRIX I/O port (0x20c or 0x30c)
+CONFIG_RADIO_ZOLTRIX_PORT
+  Enter the I/O port of your Zoltrix radio card.
+
+ADS Cadet AM/FM Tuner
+CONFIG_RADIO_CADET
+  Say Y here if this is your AM/FM radio card.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-cadet.o
+
+Miro PCM20 Radio
+CONFIG_RADIO_MIROPCM20
+  Choose Y here if you have this FM radio card. You also need to say Y
+  to "ACI mixer (miroPCM12/PCM20)" (in "additional low level sound
+  drivers") for this to work.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-miropcm20.o
+
+GemTek Radio Card
+CONFIG_RADIO_GEMTEK
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  If you have GemTeks combined (PnP) sound- and radio card you might want
+  to use this driver as a module and setup the card with isapnptools. You
+  must also pass the module a suitable io parameter. If you have trouble
+  getting the driver to work with the card as a module, please try building
+  it into the kernel by answering Y.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-gemtek.o.
+
+GemTek i/o port
+CONFIG_RADIO_GEMTEK_PORT
+  Enter either 0x20c, 0x30c, 0x24c or 0x34c here. 0x20c and 0x248 have
+  been reported to work with the combined sound/radio card. The card
+  default is 0x34c, if you haven't changed the jumper setting on the card.
+
+Trust FM Radio Card
+CONFIG_RADIO_TRUST
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-trust.o.
+
+Trust FM Radio I/O port
+CONFIG_RADIO_TRUST_PORT
+  Enter the I/O port of your card (usually 0x350 or 0x358).
+
+BT848 Video For Linux
+CONFIG_VIDEO_BT848
+  Support for BT848 based frame grabber/overlay boards. This includes
+  the Miro, Hauppauge and STB boards. Please read the material in
+  Documentation/video4linux/bttv for more information.
+
+  This driver is also available as a module called bttv.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SAA5249 Teletext processor
+CONFIG_VIDEO_SAA5249
+  Support for I2C bus based teletext using the SAA5249 chip. At the
+  moment this is only useful on some European WinTV cards.
+
+  This driver is also available as a module called saa5249.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Quickcam BW Video For Linux
+CONFIG_VIDEO_BWQCAM
+  Say Y have if you the black and white version of the QuickCam
+  camera. See the next option for the color version. 
+
+  This driver is also available as a module called bw-qcam.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Colour QuickCam Video For Linux
+CONFIG_VIDEO_CQCAM
+  This is the video4linux driver for the colour version of the
+  Connectix Quickcam. If you have one of these cameras, say Y here,
+  otherwise say N. This driver does not work with the original
+  monochrome Quickcam, Quickcam VC or QuickClip. It is also available
+  as a module (c-qcam.o).
+
+Mediavision Pro Movie Studio Video For Linux
+CONFIG_VIDEO_PMS
+  Say Y if you have such a thing. This driver is also available as a
+  module called pms.o ( = code which can be inserted in and removed
+  from the running kernel whenever you want). If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+PlanB Video-In for PowerMacs
+CONFIG_VIDEO_PLANB
+  PlanB is the V4L driver for the PowerMac 7x00/8x00 series video
+  input hardware. If you want to experiment with this, say Y.
+  Otherwise, or if you don't understand a word, say N.
+  See http://www.cpu.lu/~mlan/planb.html for more info.
+
+  Saying M will compile this driver as a module (planb.o).
+
+#
+# ARM options
+#
+CPU Optimization
+CONFIG_CPU_ARM2
+  This selects the processor type of your CPU. This is only used to
+  determine C compiler optimization options, and can affect the
+  compatibility of the kernel on other processors. If you specify
+  ARM6, the kernel should work on all 32-bit processors. If you
+  specify ARM2, ARM250 or ARM3, it should work on all 26-bit
+  processors. If you're not sure, set it to "None".
+
+ARM System type
+CONFIG_ARCH_ARC
+  This selects what ARM system you wish to build the kernel for. It
+  also selects to some extent the CPU type. If you are unsure what
+  to set this option to, please consult any information supplied with
+  your system.
+
+Include support for Chalice CATS boards
+CONFIG_CATS
+  Say Y here if you intend to run this kernel on a CATS system.
+
+Include support for Intel EBSA285
+CONFIG_ARCH_EBSA285
+  Say Y here if you intend to run this kernel on an EBSA-285 evaluation
+  board.
+
+Include support for the NetWinder
+CONFIG_ARCH_NETWINDER
+  Say Y here if you intend to run this kernel on the NetWinder.
+
+Math emulation
+CONFIG_NWFPE
+  Say Y to include the NWFPE floating point emulator in the kernel. This
+  is necessary to run most binaries. Linux does not currently support
+  floating point hardware so you need to say Y here even if your machine
+  has an FPA or floating point co-processor podule.
+
+  It is also possible to say M to build the emulator as a module
+  (nwfpe.o) or indeed to leave it out altogether. However, unless you
+  know what you are doing this can easily render your machine unbootable.
+  Saying Y is the safe option.
+
+  You may say N here if you are going to load the Acorn FPEmulator
+  early in the bootup.
+
+DS1620 Thermometer support
+CONFIG_DS1620
+  Say Y here to include support for the thermal management hardware
+  found in the NetWinder. This driver allows the user to control the
+  temperature set points and to read the current temperature.
+
+  It is also possible to say M here to build it as a module (ds1620.o)
+  It is recommended to be used on a NetWinder, but it is not a
+  necessity.
+
+Verbose kernel error messages
+CONFIG_DEBUG_ERRORS
+  This option controls verbose debugging information which can be
+  printed when the kernel detects an internal error. This debugging
+  information is useful to kernel hackers when tracking down problems,
+  but mostly meaningless to other people. It's safe to say Y unless
+  you are concerned with the code size or don't want to see these
+  messages.
+
+Compile kernel with frame pointer
+CONFIG_FRAME_POINTER
+  If you say Y here, the resulting kernel will be slightly larger and
+  slower, but it will give useful debugging information. If you don't
+  debug the kernel, you can say N.
+
+User fault debugging
+CONFIG_DEBUG_USER
+  When a user program crashes due to an exception, the kernel can print
+  a brief message explaining what the problem was. This is sometimes
+  helpful for debugging but serves no purpose on a production system.
+  Most people should say N here.
+
+Include gdb debugging information in kernel binary
+CONFIG_DEBUG_INFO
+  Say Y here to include source-level debugging information in the
+  `vmlinux' binary image. This is handy if you want to use gdb or
+  addr2line to debug the kernel. It has no impact on the in-memory
+  footprint of the running kernel but it can increase the amount of
+  time and disk space needed for compilation. If in doubt say N.
+
+Split initialisation functions into discardable section
+CONFIG_TEXT_SECTIONS
+  Normally code that is only used during initialisation is collected
+  into a special area of the kernel so that it can be discarded and
+  the memory reclaimed when initialisation is complete. In addition,
+  if the kernel you wish to build is able to run on multiple
+  architectures, it allows the unused code to be discarded. Some
+  versions of binutils, however, have a bug that causes the kernel
+  to crash during startup when this option is enabled. Say Y unless
+  you experience problems that you suspect may be caused by this.
+
+Disable pgtable cache
+CONFIG_NO_PGT_CACHE
+  Normally the kernel maintains a `quicklist' of preallocated pagetable
+  structures in order to increase performance. On machines with very
+  few pages this may however be a loss. Say Y here to disable the pgtable
+  cache.
+
+RISC OS personality
+CONFIG_ARTHUR
+  Say Y here to include the kernel code necessary if you want to run
+  Acorn RISC OS/Arthur binaries under Linux. This code is still very 
+  experimental; if this sounds frightening, say N and sleep in peace.
+  You can also say M here to compile this support as a module (which
+  will be called arthur.o).
+
+Initial kernel command line
+CONFIG_CMDLINE
+  On some architectures (EBSA110 and CATS), there is currently no way
+  for the boot loader to pass arguments to the kernel. For these
+  architectures, you should supply some command-line options at build
+  time by entering them here. As a minimum, you should specify the
+  memory size and the root device (eg, mem=64M root=/dev/nfs)
+
+Hardware alignment trap
+CONFIG_ALIGNMENT_TRAP
+  ARM processors can not fetch/store information which is not naturally
+  aligned on the bus, ie, a 4 byte fetch must start at an address divisable
+  by 4.  On 32-bit ARM processors, these instructions can be emulated in
+  software with a severe performance impact. This is necessary for correct
+  operation of some network protocols.  With an IP-only configuration
+  it is safe to say N, otherwise say Y.
+
+21285 serial port support
+CONFIG_SERIAL_21285
+  If you have a machine based on a 21285 (Footbridge) StrongARM/PCI
+  bridge you can enable its onboard serial port by enabling this
+  option. The device has major ID 4, minor 64.
+
+Console on 21285 serial port
+CONFIG_SERIAL_21285_CONSOLE
+  If you have enabled the serial port on the 21285 footbridge you can
+  make it the console by answering 'Y' to this option.
+
+Footbridge Mode
+CONFIG_HOST_FOOTBRIDGE
+  The 21285 Footbridge chip can operate in either `host mode' or
+  `add-in' mode.  Say Y if your 21285 is in host mode, and therefore
+  is the configuration master, otherwise say N.
+
+MFM harddisk support
+CONFIG_BLK_DEV_MFM
+  Support the MFM hard drives on the Acorn Archimedes both
+  on-board the A4x0 motherboards and via the Acorn MFM podules.
+  Drives upto 64MB are supported. If you haven't got one of these
+  machines or drives just say 'N'.
+
+Old Archimedes floppy (1772) support
+CONFIG_BLK_DEV_FD1772
+  Support the floppy drive on the Acorn Archimedes (A300, A4x0, A540,
+  R140 and R260) series of computers; it supports only 720K floppies
+  at the moment. If you don't have one of these machines just answer
+  'N'.
+
+Autodetect hard drive geometry
+CONFIG_BLK_DEV_MFM_AUTODETECT
+  If you answer 'Y' the MFM code will attempt to automatically detect
+  the cylinders/heads/sectors count on your hard drive. WARNING: This
+  sometimes doesn't work and it also does some dodgy stuff which
+  potentially might damage your drive.
+
+IrDA Protocols
+CONFIG_IRDA
+  Say Y here if you want to build support for the IrDA (TM) protocols.
+  The Infrared Data Associations (tm) specifies standards for wireless
+  infrared communication and is supported by most laptops and PDA's.
+
+  To use Linux support for the IrDA (tm) protocols, you will also need
+  some user-space utilities like the irmanager and probably irattach
+  as well. For more information, see the file
+  Documentation/networking/irda.txt. You also want to read the
+  IR-HOWTO, available from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called 
+
+IrDA Cache last LSAP
+CONFIG_IRDA_CACHE_LAST_LSAP
+  Say Y here if you want IrLMP to cache the last LSAP used. This makes
+  sense since most frames will be sent/received on the same
+  connection. Enabling this option will save a hash-lookup per frame.
+
+  If unsure, say Y.
+
+IrDA Fast RR's
+CONFIG_IRDA_FAST_RR
+  Say Y here is you want IrLAP to send fast RR (Receive Ready) frames
+  when acting as a primary station. This will make IrLAP send out a RR
+  frame immediately when receiving a frame if its own transmit queue
+  is currently empty. This will give a lot of speed improvement when
+  receiving much data since the secondary station will not have to
+  wait the max. turn around time before it is allowed to transmit the
+  next time. If the transmit queue of the secondary is also empty the
+  primary will back off waiting longer for sending out the RR frame
+  until the timeout reaches the normal value. Enabling this option
+  will make the IR-diode burn more power and thus reduce your battery
+  life.
+
+  If unsure, say N.
+
+IrDA Debug
+CONFIG_IRDA_DEBUG
+  Say Y here if you want the IrDA subsystem to write debug information
+  to your syslog. You can change the debug level in
+  /proc/sys/net/irda/debug
+
+  If unsure, say Y (since it makes it easier to find the bugs).
+
+IrLAP Compression support
+CONFIG_IRDA_COMPRESSION
+  Compression is _not_ part of the IrDA(tm) protocol specification,
+  but it's working great! Linux is the first to try out compression
+  support at the IrLAP layer. This means that you will only benefit
+  from compression if you are running a Linux <-> Linux configuration.
+  
+  If you say Y here, you also need to say Y or M to a compression
+  protocol below.
+
+IrLAP Deflate Compression Protocol
+CONFIG_IRDA_DEFLATE
+  Say Y here if you want to build support for the Deflate compression
+  protocol. The deflate compression (GZIP) is exactly
+  the same as the one used by the PPP protocol. 
+
+  If you want to compile this compression support as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  irda_deflate.o.
+
+IrLAN Protocol 
+CONFIG_IRLAN
+  Say Y here if you want to build support for the IrLAN protocol. If
+  you want to compile it as a module, say M here and read
+  Documentation/modules.txt. IrLAN emulates an Ethernet and makes it
+  possible to put up a wireless LAN using infrared beams.
+
+  The IrLAN protocol can be used to talk with infrared access points 
+  like the HP NetbeamIR, or the ESI JetEye NET. You can also connect 
+  to another Linux machine running the IrLAN protocol for ad-hoc 
+  networking!
+
+IrCOMM Protocol
+CONFIG_IRCOMM
+  Say Y here if you want to build support for the IrCOMM protocol. If
+  you want to compile it as a module, say M here and read
+  Documentation/modules.txt. IrCOMM implements serial port emulation,
+  and makes it possible to use all existing applications that
+  understands TTY's with an infrared link. Thus you should be able to
+  use application like PPP, minicom and others. Enabling this option
+  will create two modules called ircomm and ircomm-tty.
+
+IrTTY IrDA Device Driver
+CONFIG_IRTTY_SIR
+  Say Y here if you want to build support for the IrTTY line
+  discipline. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. IrTTY makes it possible to use
+  Linux's own serial driver for all IrDA ports that are 16550
+  compatible. Most IrDA chips are 16550 compatible so you should
+  probably say Y to this option. Using IrTTY will however limit the
+  speed of the connection to 115200 bps (IrDA SIR mode)
+
+  If unsure, say Y.
+
+IrPORT IrDA Device Driver
+CONFIG_IRPORT_SIR
+  Say Y here if you want to build support for the IrPORT IrDA device
+  driver. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. IrPORT can be used instead of
+  IrTTY and sometimes this can be better. One example is if your
+  IrDA port does not have echo-canceling, which will work OK with
+  IrPORT since this driver is working in half-duplex mode only. You
+  don't need to use irattach with IrPORT, but you just insert it 
+  the same way as FIR drivers (insmod irport io=0x3e8 irq=11).
+  Notice that IrPORT is a SIR device driver which means that speed
+  is limited to 115200 bps.
+
+  If unsure, say Y.
+
+Winbond W83977AF IrDA Device Driver
+CONFIG_WINBOND_FIR
+  Say Y here if you want to build IrDA support for the Winbond
+  W83977AF super-io chipset. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. This driver should be
+  used for the IrDA chipset in the Corel NetWinder. The driver
+  supports SIR, MIR and FIR (4Mbps) speeds.
+
+NSC IrDA Device Driver
+CONFIG_NSC_FIR
+  Say Y here if you want to build support for the NSC PC87108 and
+  PC87338 IrDA chipsets. If you want to compile it as a module, say M 
+  here and read Documentation/modules.txt. This driver supports SIR, 
+  MIR and FIR (4Mbps) speeds.
+
+Toshiba Type-O IR Port Device Driver
+CONFIG_TOSHIBA_FIR
+  Say Y here if you want to build support for the Toshiba Type-O IR
+  chipset. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. This chipset is used by the Toshiba
+  Libretto 100CT, and many more laptops.
+
+ESI JetEye PC Dongle
+CONFIG_ESI_DONGLE
+  Say Y here if you want to build support for the Extended Systems
+  JetEye PC dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The ESI dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for ESI dongles you will have to
+  start irattach like this: "irattach -d esi".
+
+ACTiSYS IR-220L and IR220L+ dongle
+CONFIG_ACTISYS_DONGLE
+  Say Y here if you want to build support for the ACTiSYS
+  IR-220L and IR220L+ dongles. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. The ACTiSYS dongles
+  attaches to the normal 9-pin serial port connector, and can
+  currently only be used by IrTTY. To activate support for ACTiSYS
+  dongles you will have to start irattach like this: 
+  "irattach -d actisys" or "irattach -d actisys+".
+
+Tekram IrMate 210B dongle
+CONFIG_TEKRAM_DONGLE
+  Say Y here if you want to build support for the Tekram IrMate 210B 
+  dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The Tekram dongle attaches to
+  the normal 9-pin serial port connector, and can currently only be
+  used by IrTTY. To activate support for Tekram dongles you will have
+  to start irattach like this: "irattach -d tekram".
+
+Greenwich GIrBIL dongle
+CONFIG_GIRBIL_DONGLE
+  Say Y here if you want to build support for the Greenwich GIrBIL
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Greenwich dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Greenwich dongles you will have to
+  insert "irattach -d girbil" in the /etc/irda/drivers script.
+
+Parallax Litelink dongle
+CONFIG_LITELINK_DONGLE
+  Say Y here if you want to build support for the Parallax Litelink
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Parallax dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Parallax dongles you will have to
+  start irattach like this "irattach -d litelink".
+
+Old Belking dongle
+CONFIG_OLD_BELKING_DONGLE
+  Say Y here if you want to build support for the old Belkin SmartBeam
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Belkin SmartBeam dongle (F5F500) come 
+  in two variants. The only way to distinguish those is to open the 
+  dongle and check the presence of a jumper (the jumper, on the new 
+  dongle, toggle between IrDA and ASK modes). This driver only support 
+  the old dongle. The old dongle is also limited to 9600 b/s (which is 
+  not very fun). To activate support for old Belkin dongles you will 
+  have to start irattach like this: "irattach -d old_dongle".
+
+VME (Motorola and BVM) support
+CONFIG_VME
+  Say Y here if you want to build a kernel for a 680x0 based VME
+  board.  Boards currently supported include Motorola boards MVME162,
+  MVME166, MVME167, MVME172, and MVME177.  BVME4000 and BVME6000
+  boards from BVM Ltd are also supported.
+
+MVME162, 166 and 167 support
+CONFIG_MVME16x
+  Say Y to include support for Motorola VME boards.  This will build a
+  kernel which can run on MVME162, MVME166, MVME167, MVME172, and
+  MVME177 boards.  If you select this option you will have to select
+  the appropriate drivers for SCSI, Ethernet and serial ports later
+  on.
+
+BVME4000 and BVME6000 support
+CONFIG_BVME6000
+  Say Y to include support for VME boards from BVM Ltd.  This will
+  build a kernel which can run on BVME4000 and BVME6000 boards.  If
+  you select this option you will have to select the appropriate
+  drivers for SCSI, Ethernet and serial ports later on.
+
+Use write-through caching for 68060 supervisor accesses
+CONFIG_060_WRITETHROUGH
+  The 68060 generally uses copyback caching of recently accessed data.
+  Copyback caching means that memory writes will be held in an on-chip
+  cache and only written back to memory some time later.  Saying Y
+  here will force supervisor (kernel) accesses to use writethrough
+  caching.  Writethrough caching means that data is written to memory
+  straight away, so that cache and memory data always agree.
+  Writethrough caching is less efficient, but is needed for some
+  drivers on 68060 based systems where the 68060 bus snooping signal
+  is hardwired on.  The 53c710 SCSI driver is known to suffer from
+  this problem.
+
+NCR53C710 SCSI driver for MVME16x
+CONFIG_MVME16x_SCSI
+  The Motorola MVME162, 166, 167, 172 and 177 boards use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+NCR53C710 SCSI driver for BVME6000
+CONFIG_BVME6000_SCSI
+  The BVME4000 and BVME6000 boards from BVM Ltd use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+Simple 53c710 SCSI support (Compaq, NCR machines)
+CONFIG_SCSI_SIM710
+  This is a driver for the NCR53C710 chip commonly found in Compaq and
+  NCR machines.  If you are looking for 53C710 support for an Amiga or
+  some 680x0 based VME card then you probably want the other NCR53C710
+  driver.
+
+MVME16x Ethernet support
+CONFIG_MVME16x_NET
+  This is the driver for the Ethernet interface on the Motorola
+  MVME162, 166, 167, 172 and 177 boards.  Say Y here to include the
+  driver for this chip in your kernel.   If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+BVME6000 Ethernet support
+CONFIG_BVME6000_NET
+  This is the driver for the Ethernet interface on BVME4000 and
+  BVME6000 VME boards.  Say Y here to include the driver for this chip
+  in your kernel.   If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+CD2401 support for MVME166/7 serial ports
+CONFIG_SERIAL167
+  This is the driver for the serial ports on the Motorola MVME166,
+  167, and 172 boards.  Everyone using one of these boards should say
+  Y here.
+
+SCC support for MVME162 serial ports
+CONFIG_MVME162_SCC
+  This is the driver for the serial ports on the Motorola MVME162 and
+  172 boards.  Everyone using one of these boards should say Y here.
+
+SCC support for BVME6000 serial ports
+CONFIG_BVME6000_SCC
+  This is the driver for the serial ports on the BVME4000 and BVME6000
+  boards from BVM Ltd.  Everyone using one of these boards should say
+  Y here.
+
+IBM's S/390 architecture
+CONFIG_ARCH_S390
+  Select this option, if you want to run the Kernel on one of IBM's
+  mainframes of the S/390 generation. You should have installed the
+  s390-compiler released by IBM (based on gcc-2.95.1) before.
+
+Merge some code into the kernel to make the image IPLable
+CONFIG_IPLABLE
+  If you want to use the produced kernel to IPL directly from a
+  device, you have to merge a bootsector specific to the device
+  into the first bytes of the kernel. You will have to select the
+  IPL device on another question, that pops up, when you select
+  CONFIG_IPLABE.
+
+IPL from a S/390 tape unit
+CONFIG_IPL_TAPE
+  Select this option if you want to IPL the image from a tape.
+
+IPL from a virtual card reader emulated by VM/ESA
+CONFIG_IPL_RDR_VM
+  Select this option if you are running under VM/ESA and want 
+  to IPL the image from the emulated card reader.
+
+IPL from a real card reader
+CONFIG_IPL_RDR
+  Select this option if you want to IPL the image from a real
+  card reader. Maybe you still got one and want to try. We didn't
+  test.
+
+IBMs S/390 Harddisks (DASDs)
+CONFIG_DASD
+  Enable this option if you want to access DASDs directly utilizing
+  S/390s channel subsystem commands. This is necessary for running
+  natively on a single image or an LPAR.
+
+Enable DASD fast write
+CONFIG_DASD_FAST_IO
+  Enable fast I/O for DASDs. That means that the next I/O command
+  is already issued at interrupt time, if an I/O request is pending.
+  This option gives significant speedup of I/O, because we don't
+  schedule the bottom-halves as often as Intel.
+
+Support for IBM-style disk-labels (S/390)
+CONFIG_S390_PARTITION
+  Enable this option to assure standard IBM labels on the DASDs.
+  You must enable it, if you are planning to access DASDs also
+  attached to another IBM mainframe operation system (OS/390, 
+  VM/ESA, VSE/ESA).
+
+ECKD devices
+CONFIG_DASD_ECKD
+  ECKD devices are the most commonly used devices. you should enable
+  this option unless you are very sure to have no ECKD device.
+
+CKD devices
+CONFIG_DASD_CKD
+  CKD devices are currently unsupported.
+
+FBA devices
+CONFIG_DASD_FBA
+  FBA devices are e.g. the Vitual disk in storage under VM/ESA and others.
+
+Diag access to CMS formatted minidisk
+CONFIG_DASD_MDSK
+  By using this access method you can acess any disk supported by VM/ESA.
+  You have to format the disk using CMS and then specify the parameter
+  dasd_force_diag=<devno> in the parameter line of the kernel.
+
+Compaq SMART2 support
+CONFIG_BLK_CPQ_DA
+   This is the driver for Compaq Smart Array controllers.  
+   Everyone using these boards should say Y here.  
+   See "linux/Documentation/cpqarray.txt" for the current list of 
+   boards supported by this driver, and for further information 
+   on the use of this driver. 
+
+Compaq Smart Array support
+CONFIG_BLK_CPQ_CISS_DA
+   This is the driver for Compaq Smart Array controllers.
+   Everyone using these boards should say Y here.
+   See "linux/Documentation/cciss.txt" for the current list of
+   boards supported by this driver, and for further information
+   on the use of this driver.
+
+QuickNet Internet LineJack/PhoneJack support
+CONFIG_PHONE_IXJ
+  Say M if you have a telephony card manufactured by Quicknet
+  Technologies, Inc.  These include the Internet PhoneJACK and
+  Internet LineJACK Telephony Cards.
+
+  For the ISA versions of these products, you can configure the
+  cards using the isapnp tools (pnpdump/isapnp) or you can use the
+  backported isapnp module.  Please read:
+
+  /usr/src/linux/Documentation/telephony/ixj.txt.
+
+  For more information on these cards, see Quicknet's website at:
+  http://www.quicknet.net/
+
+  If you do not have any Quicknet telephony cards, you can safely
+  ignore this option.
+
+Toshiba Laptop support
+CONFIG_TOSHIBA	
+  If you intend to run this the kernel on a Toshiba portable say yes
+  here. This adds a driver to safely access the System Management
+  Mode of the CPU on Toshiba portables. The System Management Mode
+  is used to set the BIOS and power saving options on Toshiba portables.
+
+  For information on utilities to make use of this driver see the
+  Toshiba Linux utilities website at:
+  http://www.buzzard.org.uk/toshiba/
+ 
+CPiA Video For Linux
+CONFIG_VIDEO_CPIA
+  This is the video4linux driver for cameras based on Vision's CPiA
+  (Colour Processor Interface ASIC), such as the Creative Labs Video
+  Blaster Webcam II. If you have one of these cameras, say Y here
+  and select parallel port lowlevel support below (the USB-version,
+  is not supported on this kernel-version) otherwise say N. This will
+  not work with the Creative Webcam III. It is also available as a
+  module (cpia.o).
+
+  For more information (supported camera models, module autoloading, DMA
+  interrupt settings, supported applications, etc.) read
+  Documentation/video4linux/README.cpia.
+
+CPiA Parallel Port Lowlevel Support
+CONFIG_VIDEO_CPIA_PP
+  This is the lowlevel parallel port support for cameras based on
+  Vision's CPiA (Colour Processor Interface ASIC), such as the
+  Creative Webcam II. If you have the parallel port version of one
+  of these cameras, say Y here, otherwise say N. It is also available
+  as a module (cpia_pp.o).
+
+CPiA Parallel Port DMA Support
+CONFIG_VIDEO_CPIA_PP_DMA
+  This will use DMA if possible to reduce CPU usage.  If in doubt,
+  say Y here.
+
+7-Segment Display support
+CONFIG_DISPLAY7SEG
+  This is the driver for the digital display and LED present on
+  Sun Microsystems CompactPCI models CP1400 and CP1500.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called display7seg.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+  If you do not have a CompactPCI model CP1400 or CP1500, or 
+  another UltraSPARC-IIi-cEngine boardset with digital display,
+  you should say N to this option.
+   
+#
+# A couple of things I keep forgetting:
+#   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet, 
+#               Intel, IRQ, Linux, MSDOS, NetWare, NetWinder, NFS, 
+#               PCI, SCSI, SPARC
+#   two words:  hard drive, hard disk, sound card, home page
+#   other:      it's safe to save; daemon; use --, not - or ---
+#
+#
+# This is used by Emacs' spell checker ispell.el:
+#
+# LocalWords:  CONFIG coprocessor DX Pentium SX lilo loadlin HOWTO ftp metalab
+# LocalWords:  unc edu docs emu README kB BLK DEV FD Thinkpad fd MFM RLL IDE gz
+# LocalWords:  cdrom diskless netboot nfs xzvf ATAPI MB ide pavia pl pd
+# LocalWords:  HD CDROMs IDECD NEC MITSUMI filesystem XT XD PCI BIOS cezar ATEN
+# LocalWords:  ISA EISA Microchannel VESA BIOSes IPC SYSVIPC ipc Ctrl dmesg hlt
+# LocalWords:  BINFMT Linkable http ac uk jo html GCC SPARC AVANTI CABRIOLET EB
+# LocalWords:  netscape gcc LD CC toplevel MODVERSIONS insmod rmmod modprobe IP
+# LocalWords:  genksyms INET loopback gatewaying ethernet PPP ARP Arp MEMSIZE
+# LocalWords:  howto multicasting MULTICAST MBONE firewalling ipfw ACCT resp ip
+# LocalWords:  proc acct IPIP encapsulator decapsulator klogd PCTCP RARP EXT PS
+# LocalWords:  telnetting subnetted NAGLE rlogin NOSR ttyS TGA techinfo mbone nl
+# LocalWords:  Mb SKB IPX Novell dosemu Appletalk DDP ATALK vmalloc visar ehome
+# LocalWords:  SD CHR scsi thingy SG CD LUNs LUN jukebox Adaptec BusLogic EATA
+# LocalWords:  buslogic DMA DPT ATT eata dma PIO UltraStor fdomain umsdos ext
+# LocalWords:  QLOGIC qlogic TMC seagate Trantor ultrastor FASST wd NETDEVICES
+# LocalWords:  unix BBS linux CSLIP PLIP Kirch's LDP CSlip SL SCC IRQ csustan
+# LocalWords:  Turbo Laplink plip NCSA port's ReQuest IRQs EQL SMC AMD PCnet NE
+# LocalWords:  COM ELPLUS Com EtherLinkIII VLB Arcnet Cabletron DEPCA DE carlos
+# LocalWords:  depca EtherWorks EWRK ewrk SEEQ EtherExpress EEXPRESS NI xxx dia
+# LocalWords:  EtherExpress WaveLAN wavelan PCLAN HPLAN VG SK Ansel Xen de ZNET
+# LocalWords:  PCMCIA cb stanford LAN TEC RealTek ATP atp DLINK NetTools VISWS
+# LocalWords:  TR Sony CDU caddyless cdu Mitsumi MCD cd mcd XA MultiSession CDA
+# LocalWords:  Matsushita Panasonic SBPCD Soundblaster Longshine sbpcd Aztech
+# LocalWords:  Okano Wearnes AZTCD CDD SE aztcd sonycd Goldstar GSCD Philips fs
+# LocalWords:  LMS OPTCD Sanyo SJCD minix faqs xiafs XIA msdos mtools Cichocki
+# LocalWords:  std softlinks umssync NetworkFileSharing nfsd mountd CDs HPFS TI
+# LocalWords:  hpfs SYSV SCO iBCS Wyse WordPerfect tsx mit unixes sysv NR irisa
+# LocalWords:  SMB WfW Cyclades async mux Logitech busmouse MouseSystem aka AST
+# LocalWords:  PSMOUSE Compaq trackballs Travelmate Inport ATIXL ATI busmice ld
+# LocalWords:  gpm config QIC DYNCONF FTAPE Stor Ftape ftape pcsndrv manpage NT
+# LocalWords:  readprofile diskdrives org com masq EtherTalk tcp netrom sunacm
+# LocalWords:  misc AIC aic pio scc Portmaster eql GIS PhotoCDs MCDX Perell PG
+# LocalWords:  mcdx gscd optcd sjcd ISP hdparm Workgroups Lan samba PARIDE PCD
+# LocalWords:  filesystems smbfs ATA ppp PCTech RZ www powerquest txt CMD ESDI
+# LocalWords:  chipset FB multicast MROUTE appletalk ifconfig IBMTR multiport
+# LocalWords:  Multisession STALDRV EasyIO EC EasyConnection ISTALLION ONboard
+# LocalWords:  Brumby pci TNC cis ohio faq usenet NETLINK dev hydra ca Tyne mem
+# LocalWords:  carleton Deskstation DECstation SUNFD JENSEN Noname XXXM SLiRP
+# LocalWords:  pppd Zilog ZS SRM bootloader ez mainmenu rarp ipfwadm paride pcd
+# LocalWords:  RTNETLINK mknod xos MTU lwared Macs mac netatalk macs cs Wolff
+# LocalWords:  dartmouth flowerpt MultiMaster FlashPoint tudelft etherexpress
+# LocalWords:  ICL EtherTeam ETH IDESCSI TXC SmartRAID SmartCache httpd sjc dlp
+# LocalWords:  thesphere TwoServers BOOTP DHCP ncpfs BPQETHER BPQ MG HIPPI cern
+# LocalWords:  bsd comp SPARCstation le SunOS ie Gracilis PackeTwin PT pt LU FX
+# LocalWords:  FX TEAC CR LCS mS ramdisk IDETAPE cmd fperllo encis tcfs unisa
+# LocalWords:  Vertos Genoa Funai hsfs NCP NetWare tgz APM apm ioctls UltraLite
+# LocalWords:  TravelMate CDT LCD backlight VC RPC Mips AXP barlow cdrecord pg
+# LocalWords:  PMAX MILO Alphas Multia Tseng linuxelf endian mipsel mips drv HT
+# LocalWords:  kerneld callouts AdvanSys advansys Admin WDT DataStor EP verden
+# LocalWords:  wdt hdb hdc bugfix SiS vlb Acculogic CSA DTC dtc Holtek ht QDI
+# LocalWords:  QD qd UMC umc ALI ali lena fnet fr azstarnet cdr fb MDA ps esdi
+# LocalWords:  Avanti XL AlphaStations Jensen DECpc AXPpci UDB Cabriolet MCA RC
+# LocalWords:  AlphaPC mca AOUT OUTput PPro sipx gwdg lo nwe FourPort Boca unm
+# LocalWords:  Keepalive linefill RELCOM keepalive analogue CDR conf CDI INIT
+# LocalWords:  OPTi isp irq noisp VFAT vfat NTFS losetup dmsdosfs dosfs ISDN MP
+# LocalWords:  NOWAYOUT behaviour dialin isdn callback BTX Teles ICN EDSS Cisco
+# LocalWords:  ipppd syncppp RFC MPP VJ downloaded icn NICCY Creatix shmem ufr
+# LocalWords:  ibp md ARCnet ether encap NDIS arcether ODI Amigas AmiTCP NetBSD
+# LocalWords:  initrd tue util DES funet des OnNet BIOSP smc Travan Iomega CMS
+# LocalWords:  FC DC dc PPA IOMEGA's ppa RNFS FMV Fujitsu ARPD arpd loran layes
+# LocalWords:  FRAD indiana framerelay DLCI DCLIs Sangoma SDLA mrouted sync sec
+# LocalWords:  Starmode Metricom MosquitoNet mosquitonet kbit nfsroot Digiboard
+# LocalWords:  DIGI Xe Xeve digiboard UMISC touchscreens mtu ethernets HBAs MEX
+# LocalWords:  Shifflett netcom js jshiffle WIC DECchip ELCP EtherPower dst RTC
+# LocalWords:  rtc SMP lp Digi Intl RightSwitch DGRS dgrs AFFS Amiga UFS SDL AP
+# LocalWords:  Solaris RISCom riscom syncPPP PCBIT pcbit sparc anu au artoo MFB
+# LocalWords:  hitchcock Crynwr cnam pktdrvr NCSA's CyDROM CyCDROM FreeBSD NeXT
+# LocalWords:  NeXTstep disklabel disklabels SMD FFS tm AmigaOS diskfiles Un IQ
+# LocalWords:  Bernd informatik rwth aachen uae affs multihosting bytecode java
+# LocalWords:  applets applet JDK ncsa cabi SNI Alphatronix readme LANs scarab
+# LocalWords:  winsock RNIS caltech OSPF honour Honouring Mbit LocalTalk DEFRAG
+# LocalWords:  localtalk download Packetwin Baycom baycom interwork ASCII JNT
+# LocalWords:  Camtec proxying indyramp defragment defragmented UDP FAS FASXX
+# LocalWords:  FastSCSI SIO FDC qlogicfas QLogic qlogicisp setbaycom ife ee LJ
+# LocalWords:  ethz ch Travelmates ProAudioSpectrum ProAudio SoundMan SB SBPro
+# LocalWords:  Thunderboard SM OPL FM ADLIB TSR Gravis MPU PSS ADI SW DSP codec
+# LocalWords:  ADSP ESC ASIC daughtercard GUSMAX MSS NX AdLib Excell Ensoniq YM
+# LocalWords:  SoundScape Spea MediaTriX AudioTriX WSS OTI ThunderBoard VoxWare
+# LocalWords:  Soundscape SSCAPE TRIX MediaTrix PnP Maui dsp midixx EIA getty
+# LocalWords:  mgetty sendfax gert greenie muc lowlevel Lasermate LanManager io
+# LocalWords:  OOPSes trackball binghamton mobileip ncr IOMAPPED settags ns ser
+# LocalWords:  setsync NEGO MPARITY autotuning prefetch PIIX cdwrite utils rc
+# LocalWords:  PCWATCHDOG berkprod bitgate boldt ucsb jf kyoto jp euc Tetsuyasu 
+# LocalWords:  YAMADA tetsu cauchy nslab ntt nevod perm su doc kaf kheops wsc
+# LocalWords:  traduc Bourgin dbourgin menuconfig kfill READMEs HOWTOs Virge WA
+# LocalWords:  IDEDISK IDEFLOPPY EIDE firewalls QMAGIC ZMAGIC LocalWords opti
+# LocalWords:  SVGATextMode vga svga Xkernel syr jmwobus comfaqs dhcp flakey GD
+# LocalWords:  IPv IPng interoperability ipng ipv radio's tapr pkthome PLP nano
+# LocalWords:  Ses Mhz sethdlc SOUNDMODEM WindowsSoundSystem smdiag pcf inka ES
+# LocalWords:  smmixer ptt circ soundmodem MKISS FDDI DEFEA DEFPA DEFXX redhat
+# LocalWords:  HyperNews khg mconv sed lina wuftpd MicroChannel netlink irc cum
+# LocalWords:  raudio RealAudio PPROP NETBIOS GUI IBMMCA ELMC Racal Interlan fi
+# LocalWords:  eth shapecfg src esp PCWD PREVSTAT bootparam sig bitwizard SBC
+# LocalWords:  downloads AFSK TCM FP Karn KA FSK RUH LinkSys cron mouseman LLC
+# LocalWords:  SyQuest SyQuest's CCITT MicroSolutions BPCD bpcd ESPSERIAL PROM
+# LocalWords:  SUNESP openprom OPENPROMIO quango themall al TT MC MMU LC RMW AA
+# LocalWords:  INSNS Ataris AutoConfig ZORRO OCS AMIFB Agnus Denise ECS CDTV GB
+# LocalWords:  AGA Cybervision CYBER GSP TMS DMI Zorro ACSI ROMs SLM BioNet GVP
+# LocalWords:  PAMsNet TekMagic Cyberstorm MkI CYBERSTORMII MkII BLZ onboard cx
+# LocalWords:  Village Tronic ATARILANCE RieblCard PAMCard VME MFP sangoma LAPB
+# LocalWords:  Rhotron BioData's Multiface AMIGAMOUSE COPCON Amiga's bitplanes
+# LocalWords:  ATARIMOUSE MFPSER SCC's MegaSTE ESCC Atari's GVPIOEXT DMASOUND
+# LocalWords:  fdutils cisco univercd rpcg htm iface lapb LAPBETHER tpqic qic
+# LocalWords:  SYNTH xd en binfmt aout ipip terra ipx sd sr sg wic framebuffer
+# LocalWords:  ibmmca lapbether mkiss dlci sdla fmv eepro eexpress ni hp ne es
+# LocalWords:  ibmtr isofs ROMFS romfs pcxx cyclades istallion psaux msbusmouse
+# LocalWords:  atixlmouse sbin softdog pcwd USS Lite ACI miroSOUND PCM miroPCM
+# LocalWords:  microcontroller miro Voxware downloading teles acsi slm gvp ltpc
+# LocalWords:  atari ariadne amigamouse atarimouse builtin IPDDP maths bradford
+# LocalWords:  AppleTalk Farallon PhoneNet Zubkoff lnz SCCB HAPN WANs vesafb nt
+# LocalWords:  wanrouter WANPIPE multiprotocol Mbps wanpipe EtherWORKS nodma SC
+# LocalWords:  smp HiSax SiemensChipSet Siemens AVM Elsa ITK hisax PCC MICROR
+# LocalWords:  Mircolink EURO DSS Spellcaster BRI sc spellcast Digiboards GPIO
+# LocalWords:  SYMBIOS COMPAT SDMS rev ASUS Tekram HX VX API ibmmcascsi ASY asy
+# LocalWords:  loader's PCnetPCI automounter AUTOFS amd autofs VT Gallant's Pnp
+# LocalWords:  AEDSP aedsp enskip tik Sysctl sysctl PARPORT parport pnp IDs EPP
+# LocalWords:  Autoprobe bart patrickr HDLS READBACK AB usr DAMA DS SparQ aten
+# LocalWords:  Symbios PCscsi tmscsim RoamAbout GHz Hinds contrib mathematik ok
+# LocalWords:  darmstadt okir DIGIEPCA International's Xem digiepca epca bootup
+# LocalWords:  zorro CAPI AVMB capi avmb VP SYN syncookies EM em pc Ethertalk
+# LocalWords:  Dayna DL Daynatalk LT PhoneNET ATB Daystar queueing CMDS SCBs ls
+# LocalWords:  SCB STATS Thinnet ThunderLAN TLAN Netelligent NetFlex tlan james
+# LocalWords:  caldera Preload Preloading slowdowns schoebel uni NBD nbd prog
+# LocalWords:  stuttgart rdist TRANS hostnames mango jukeboxes ESS userland PD
+# LocalWords:  hardlinked NAMETRANS env mtab fstab umount nologin runlevel gid
+# LocalWords:  transname filespace adm Nodename hostname uname Kernelname bootp
+# LocalWords:  KERNNAME kname ktype kernelname Kerneltype KERNTYPE Alt RX mdafb
+# LocalWords:  dataless kerneltype SYSNAME Comtrol Rocketport palmtop fbset EGS
+# LocalWords:  nvram SYSRQ SysRq PrintScreen sysrq NVRAMs NvRAM Shortwave RTTY
+# LocalWords:  HFMODEM shortwave Sitor Amtor Pactor GTOR hfmodem hayes TX TMOUT
+# LocalWords:  IDEPCI IDEDMA idedma PDC pdc TRM trm raidtools luthien nuclecu
+# LocalWords:  unam mx miguel koobera uic EMUL solaris pp ieee lpsg co DMAs TOS
+# LocalWords:  BLDCONFIG preloading jumperless BOOTINIT modutils multipath GRE
+# LocalWords:  misconfigured autoconfiguration IPGRE ICMP tracert ipautofw PIM
+# LocalWords:  netis rlynch autofw ipportfw monmouth ipsubs portforwarding pimd
+# LocalWords:  portfw PIMSM netweb usc pim pf EUI aggregatable PB decapsulate
+# LocalWords:  ipddp Decapsulation DECAP bool HAMRADIO tcpdump af CDs tx FBCON
+# LocalWords:  ethertap multisession PPC MMIO GDT GDTH ICP gdth hamradio  bpp
+# LocalWords:  lmh weejock AIMSlab RadioTrack RTRACK HZP OptoSCC TRX rx TRXECHO
+# LocalWords:  DMASCC paccomm dmascc addr cfg oevsv oe kib picpar FDX baudrate
+# LocalWords:  baudrates fdx HDX hdx PSK kanren frforum QoS SCHED CBQ SCH sched
+# LocalWords:  sch cbq CSZ Shenker Zhang csz SFQ sfq TBF tbf PFIFO fifo PRIO RW
+# LocalWords:  prio Micom xIO dwmw rimi OMIRR omirr omirrd unicode ntfs cmu NIC
+# LocalWords:  Braam braam Schmidt's freiburg nls codepages codepage Romanian
+# LocalWords:  Slovak Slovenian Sorbian Nordic iso Catalan Faeroese Galician SZ
+# LocalWords:  Valencian Slovene Esperanto Estonian Latvian Byelorussian KOI mt
+# LocalWords:  charset Inuit Greenlandic Sami Lappish koi SOFTCURSOR softcursor
+# LocalWords:  Specialix specialix DTR RTS RTSCTS cycladesZ Exabyte ftape's inr
+# LocalWords:  Iomega's LBFM claus ZFTAPE VFS zftape zft William's lzrw DFLT kb
+# LocalWords:  MTSETBLK MTIOCTOP qft setblk zftape's tar's afio's setdrvbuffer
+# LocalWords:  Procfs Exabyte's THR FCD sysvinit init PSC pscwdt VMIDI Euro SAB
+# LocalWords:  Mostek Fastlane PowerMac PReP PMAC PowerPC Macintoshes Starmax
+# LocalWords:  PowerStack Starmaxes MCOMMON DEVICETREE ATY IMS IMSTT videodev
+# LocalWords:  BT Hauppauge STB bttv Quickcam BW BWQCAM bw qcam Mediavision PMS
+# LocalWords:  pms Avatar Freecom Imation Superdisk BPCK bpck COMM comm DSTR ru
+# LocalWords:  dstr EPAT EPEZ epat EPIA epia FreeCom FRPW frpw KingByte KBIC HW
+# LocalWords:  KingByte's kbic OnSpec ValuStore FASTROUTE fastroute FLOWCONTROL
+# LocalWords:  struct APIC realtime OSs LynxOS CNC tmp cvf HFS hfs ADFS Risc os
+# LocalWords:  adfs ncpmount namespace SUBDIR reexport NDS kcore FT SPX spx DAT
+# LocalWords:  interserver BLKSZ NUMBUFFERS apmd Tadpole ANA roestock QuickCam
+# LocalWords:  isapnptools Colour CQCAM colour Connectix QuickClip prive mentre
+# LocalWords:  KMOD kmod conformant utexas kharker UnixWare Mwave cgi cl ts ibm
+# LocalWords:  eXchange threepio oakland simtel pre ULTRAMCA EtherLink isa luik
+# LocalWords:  EtherLink OpenBSD pts DEVPTS devpts ptmx ttyp glibc readback SA
+# LocalWords:  mwave OLDCARD isdnloop linklevel loopctrl Eicon Diehl DIEHLDIVA
+# LocalWords:  ASUSCOM AsusCom TELEINT semiactiv Sedlbauer Sportster TA MIC ITH
+# LocalWords:  NETjet NetJet Niccy Neuhaus sparcs AOC AOCD AOCE Microlink SAA
+# LocalWords:  teletext WinTV saa iproute tc Quadra Performa PowerBook tor AUN
+# LocalWords:  setserial compsoc steve Econet econet AUNUDP psched TEQL TLE CLS
+# LocalWords:  teql FW Ingres TwistedPair MTRR MTRRs mtrr cfs crypto TD ktti KT
+# LocalWords:  PHd ICS ipchains adelaide rustcorp syslog Cumana steganography
+# LocalWords:  AcornSCSI EcoSCSI EESOX EESOXSCSI Powertec POWERTECSCSI dec SF
+# LocalWords:  RadioReveal gatekeeper aimslab aztech FMI sf fmi RTL rtl cesdis
+# LocalWords:  Yellowfin gsfc nasa gov yellowfin pcnet Mylex LNE lne EtherH hs
+# LocalWords:  EBSA chattr RiscOS Winmodem AGP Atomwide DUALSP pcsp robinson CT
+# LocalWords:  SGALAXY Waverider DSPxxx TRXPRO AudioTrix OSWF MOT CFB DSY kbps
+# LocalWords:  tuwien kkudielk LVD mega lun MAXTAGS Gbps arcnet Olicom SKTR SNA
+# LocalWords:  SysKonnect sktr sna etherboot ufs NetBEUI MultiSound MSNDCLAS GX
+# LocalWords:  MSNDINIT MSNDPERM MSNDPIN PNDSPINI PNDSPERM Ensoniq's RetinaZ SS
+# LocalWords:  AudioPCI lspci SonicVibes sonicvibes SPARCs roadrunner CLgen UPA
+# LocalWords:  swansea shtml Zoltrix zoltrix BINUTILS EGCS binutils VIDC DACs
+# LocalWords:  CyberVision Cirrus PowerBooks Topcat SBUS CGsix TurboGX BWtwo SS
+# LocalWords:  CGthree TCX unswapable vfb fbcon hicolor truecolor AFB ILBM SOC
+# LocalWords:  IPLAN gracilis Fibre SBus SparcSTORAGE SV jnewbigin swin QNX qnx
+# LocalWords:  PTY PTYS ptyxx ttyxx PTYs ssh sb Avance ALS pss pvv kerneli hd
+# LocalWords:  synth WaveFront MSND NONPNP AudioExcelDSP STRAM APUS CHRP MBX Nx
+# LocalWords:  PowerMac's BMAC radiotrack rtrack miropcm OFFBOARD HPT UDMA DVD
+# LocalWords:  hpt fokus gmd Cyrix DXL SLC DLC NexGen MediaGX GXm IDT WinChip
+# LocalWords:  MMX MII valkyrie mdacon vdolive VDOLive cuseeme CU hippi rrunner
+# LocalWords:  SeeMe ipmasqadm juanjox ipmarkfw markfw TNCs Microdyne rhine lib
+# LocalWords:  libc jsX gamepad gameport CHF FCS FPGaming MadCatz ASSASIN GrIP
+# LocalWords:  Assasin gamepads GamePad PDPI gamecards gamecard WingMan BSP WCS
+# LocalWords:  ThunderPad CyberMan SideWinder ThrustMaster DirectConnect NES XF
+# LocalWords:  Millenium SNES PSX Multisystem Nintendo PlayStation Amstrad CPC
+# LocalWords:  Sega TurboGraFX Steffen Schwenke Multiststem PDIF FIFOSIZE EPLUS
+# LocalWords:  PowerUP RoadRunner tahallah dos functionkey setterm imladris Woz
+# LocalWords:  PowerMacs Winbond Algorithmics ALGOR algor ECOFF IRIX SGI SGI's
+# LocalWords:  gfx virtualized Xpmac mklinux XFree FBDev Woodhouse mvhi Seeq fp
+# LocalWords:  SGISEEQ HIgh ADB ADBMOUSE crosscompiler CROSSCOMPILE FPE GDB gdb
+# LocalWords:  JOYPORT rp spoofing DawiControl NOGENSUPP EEPROM HSSI Alessandro
+# LocalWords:  singleprocessor tex MATHEMU FRIQ Maxell friq Alcor XLT AlphaBook
+# LocalWords:  AlphaPCI DP LX Miata Mikasa Noritake RPX UX BX Takara EV PRIMO
+# LocalWords:  TSC Matrox Productiva matroxfb matrox multihead ia linuxhq MFW
+# LocalWords:  mfw AAA MCS Initio XXU initio imm AutoDetect IZIP CTR usec HDLC
+# LocalWords:  COSA SRP muni cz kas cosa Alteon AceNIC acenic VTOC OSes GMT SAx
+# LocalWords:  Inspiron localtime INTS Thinkpads Ralf Brown's Flightstick NNN
+# LocalWords:  Xterminator Blackhawk NN mpu ioports DCA HPDCA HPLANCE DIO Corel
+# LocalWords:  GemTek gemtek CMDLINE IrDA PDA's irmanager irattach RR AVA DN rg
+# LocalWords:  uit dagb irda LSAP IrLMP RR's IrLAP IR alloc skb's kfree skb's
+# LocalWords:  GZIP IrLAN NetbeamIR ESI JetEye IrOBEX IrCOMM TTY's minicom dti
+# LocalWords:  ircomm ircomm pluto thiguchi IrTTY Linux's bps NetWinder MIR NSC
+# LocalWords:  ACTiSYS Dongle dongle dongles esi actisys IrMate tekram BVM MVME
+# LocalWords:  BVME BVME WRITETHROUGH copyback writethrough fwmark syncookie tu
+# LocalWords:  alphalinux GOBIOS csn chemnitz nat ACARD AMI MegaRAID megaraid
+# LocalWords:  QNX4FS ISI isicom xterms Apollos VPN RCPCI rcpci sgi visws pcmcia
+# LocalWords:  IrLPT UIRCC Tecra
+
diff -druN linux-noipsec/Documentation/Configure.help~ linux/Documentation/Configure.help~
--- linux-noipsec/Documentation/Configure.help~	Thu Jan  1 01:00:00 1970
+++ linux/Documentation/Configure.help~	Mon Dec 11 01:49:41 2000
@@ -0,0 +1,13736 @@
+# Maintained by Axel Boldt (boldt@math.ucsb.edu)
+#
+# This version of the Linux kernel configuration help texts
+# corresponds to the kernel versions 2.2.x.
+#
+# Translations of this file available on the WWW:
+#
+#   - Japanese, maintained by the JF Project (JF@linux.or.jp), at
+#     http://www.linux.or.jp/JF/JFdocs/Configure.help/
+#   - Russian, by kaf@linux.nevod.perm.su, at
+#     http://nevod.perm.su/service/linux/doc/kernel/Configure.help
+#   - French, by Pierre Tane (tanep@bigfoot.com), at
+#     http://www.traduc.org/kernelfr
+#   - Spanish, by Carlos Perelló Marín (fperllo@ehome.encis.es), at
+#     http://visar.csustan.edu/~carlos/
+#   - Polish, by Cezar Cichocki (cezar@cs.net.pl), at
+#     http://www.cs.net.pl/~cezar/Kernel
+#   - German, by Jörg Strebel (jstrebel@suse.de) and Karl Eichwalder
+#     (ke@suse.de), at http://www.suse.de/~ke/kernel/Configure.de.help.gz
+#
+# Information about what a kernel is, what it does, how to patch and
+# compile it and much more is contained in the Kernel-HOWTO, available
+# via FTP (user: anonymous) from metalab.unc.edu in the directory
+# /pub/Linux/docs/HOWTO. Before you start compiling, make sure that
+# you have the necessary versions of all programs and libraries
+# required to compile and run this kernel; they are listed in the file
+# Documentation/Changes. Make sure to read the toplevel kernel README 
+# file as well.
+#
+# Format of this file: description<nl>variable<nl>help text<nl><nl>. If
+# the question being documented is of type "choice", we list only the
+# first occurring config variable. The help texts may contain empty
+# lines, but every non-empty line must be indented two positions.
+# Order of the help texts does not matter, however, no variable should
+# be documented twice: if it is, only the first occurrence will be
+# used by Configure. We try to keep the help texts of related variables
+# close together. Lines starting with `#' are ignored. To be nice to
+# menuconfig, limit your line length to 70 characters. Use emacs'
+# kfill.el to edit and ispell.el to spell check this file or you lose.
+#
+# If you add a help text to this file, please try to be as gentle as
+# possible. Don't use unexplained acronyms and generally write for the
+# hypothetical ignorant but intelligent user who has just bought a PC,
+# removed Windows, installed Linux and is now recompiling the kernel
+# for the first time. Tell them what to do if they're unsure. Technical 
+# information should go in a README in the Documentation directory.
+# Mention all the relevant READMEs and HOWTOs in the help text.
+# Repetitions are fine since the help texts are not meant to be read
+# in sequence.
+#
+# All this was shamelessly stolen from several different sources. Many
+# thanks to all the contributors. Feel free to use these help texts in
+# your own kernel configuration tools. The texts are copyrighted (c)
+# 1995-1999 by Axel Boldt and many others and are governed by the GNU
+# General Public License.
+
+Prompt for development and/or incomplete code/drivers
+CONFIG_EXPERIMENTAL
+  Some of the various things that Linux supports (such as network 
+  drivers, filesystems, network protocols, etc.) can be in a state 
+  of development where the functionality, stability, or the level of 
+  testing is not yet high enough for general use. This is usually
+  known as the "alpha-test" phase amongst developers. If a feature is
+  currently in alpha-test, then the developers usually discourage 
+  uninformed widespread use of this feature by the general public to
+  avoid "Why doesn't this work?" type mail messages. However, active
+  testing and use of these systems is welcomed. Just be aware that it
+  may not meet the normal level of reliability or it may fail to work
+  in some special cases. Detailed bug reports from people familiar
+  with the kernel internals are usually welcomed by the developers
+  (before submitting bug reports, please read the documents README,
+  MAINTAINERS, REPORTING_BUGS, Documentation/BUG-HUNTING, and
+  Documentation/oops-tracing.txt in the kernel source). 
+
+  Unless you intend to help test and develop a feature or driver that
+  falls into this category, or you have a situation that requires
+  using these features you should probably say N here, which will
+  cause this configure script to present you with fewer choices. If
+  you say Y here, you will be offered the choice of using features or
+  drivers that are currently considered to be in the alpha-test phase.
+
+Symmetric Multi Processing
+CONFIG_SMP
+  This enables support for systems with more than one CPU. If you have
+  a system with only one CPU, like most personal computers, say N. If
+  you have a system with more than one CPU, say Y.
+
+  If you say N here, the kernel will run on single and multiprocessor
+  machines, but will use only one CPU of a multiprocessor machine. If
+  you say Y here, the kernel will run on many, but not all,
+  singleprocessor machines. On a singleprocessor machine, the kernel
+  will run faster if you say N here.
+
+  Note that if you say Y here and choose architecture "586" or
+  "Pentium" under "Processor family", the kernel will not work on 486
+  architectures. Similarly, multiprocessor kernels for the "PPro"
+  architecture may not work on all Pentium based boards.
+
+  People using multiprocessor machines who say Y here should also say
+  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
+  Management" code will be disabled if you say Y here.
+
+  See also: Documentation/SMP.txt, Documentation/smp.tex,
+  Documentation/smp.txt, and Documentation/IO-APIC.txt.  Also see the
+  SMP-FAQ on the WWW at http://www.irisa.fr/prive/mentre/smp-faq/ (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape).
+  
+  If you don't know what to do here, say N.
+  
+Kernel math emulation
+CONFIG_MATH_EMULATION
+  Linux can emulate a math coprocessor (used for floating point
+  operations) if you don't have one. 486DX and Pentium processors have
+  a math coprocessor built in, 486SX and 386 do not, unless you added
+  a 487DX or 387, respectively. (The messages during boot time can
+  give you some hints here ["man dmesg"].) Everyone needs either a
+  coprocessor or this emulation. 
+
+  If you don't have a math coprocessor, you need to say Y here; if you
+  say Y here even though you have a coprocessor, the coprocessor will
+  be used nevertheless. (This behavior can be changed with the kernel
+  command line option "no387", which comes handy if your coprocessor
+  is broken. Try "man bootparam" or see the documentation of your boot
+  loader (lilo or loadlin) about how to pass options to the kernel at
+  boot time. The lilo procedure is also explained in the SCSI-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.) This means that it is a
+  good idea to say Y here if you intend to use this kernel on
+  different machines. 
+
+  More information about the internals of the Linux math coprocessor
+  emulation can be found in arch/i386/math-emu/README.
+
+  If you are not sure, say Y; apart from resulting in a 45 KB bigger
+  kernel, it won't hurt.
+  
+Timer and CPU usage LEDs
+CONFIG_LEDS
+  If you define this option, the LEDs on your machine will be used
+  to provide useful information about your current system status.
+
+  If you are compiling a kernel for a NetWinder or EBSA-285, you
+  will be able to select which LEDs are active using the options
+  below. If you are compiling a kernel for the EBSA-110 however,
+  the red LED will simply flash regularly to indicate that the
+  system is still functional. It is still safe to say yes here if
+  you have a CATS system, but the driver will do nothing.
+
+Timer LED
+CONFIG_LEDS_TIMER
+  If you say yes here, one of the system LEDs (the green one on the
+  NetWinder or the amber one on the EBSA285) will flash regularly to
+  indicate that the system is still operational. This is mainly
+  useful to kernel hackers who are debugging unstable kernels.
+
+CPU usage LED
+CONFIG_LEDS_CPU
+  If you say yes here, the red LED will be used to give a good real
+  time indication of CPU usage, by lighting whenever the idle task
+  is not currently executing.
+
+Kernel FP software completion
+CONFIG_MATHEMU
+  This option is required for IEEE compliant floating point arithmetic
+  on the Alpha. The only time you would ever not say Y is to say M in
+  order to debug the code. Say Y unless you know what you are doing.
+
+Normal PC floppy disk support
+CONFIG_BLK_DEV_FD
+  If you want to use the floppy disk drive(s) of your PC under Linux,
+  say Y. Information about this driver, especially important for IBM
+  Thinkpad users, is contained in drivers/block/README.fd. This file
+  also contains the location of the Floppy driver FAQ as well as
+  location of the fdutils package used to configure additional
+  parameters of the driver at run time.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called floppy.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Support for PowerMac floppy
+CONFIG_MAC_FLOPPY
+  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)
+  floppy controller, say Y here. Most commonly found in PowerMacs.
+
+RAM disk support
+CONFIG_BLK_DEV_RAM
+  Saying Y here will allow you to use a portion of your RAM memory as
+  a block device, so that you can make filesystems on it, read and
+  write to it and do all the other things that you can do with normal
+  block devices (such as hard drives). It is usually used to load and
+  store a copy of a minimal root file system off of a floppy into RAM
+  during the initial install of Linux. 
+
+  Note that the kernel command line option "ramdisk=XX" is now
+  obsolete. For details, read Documentation/ramdisk.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. The module will be called
+  rd.o. 
+
+  Most normal users won't need the RAM disk functionality, and can
+  thus say N here.
+
+Default RAM disk size
+CONFIG_BLK_DEV_RAM_SIZE
+  The default value is 4096. Only change this if you know what are
+  you doing. If you are using IBM S/390, then set this to 8192.
+
+Initial RAM disk (initrd) support
+CONFIG_BLK_DEV_INITRD
+  The initial RAM disk is a RAM disk that is loaded by the boot loader
+  (loadlin or lilo) and that is mounted as root before the normal boot
+  procedure. It is typically used to load modules needed to mount the
+  "real" root file system, etc. See Documentation/initrd.txt for
+  details.
+
+Loop device support
+CONFIG_BLK_DEV_LOOP
+  Saying Y here will allow you to use a regular file as a block
+  device; you can then create a file system on that block device and
+  mount it just as you would mount other block devices such as hard
+  drive partitions, CDROM drives or floppy drives.
+
+  This is useful if you want to check an ISO 9660 file system before
+  burning the CD, or if you want to use floppy images without first
+  writing them to floppy.
+
+  The loop device driver can also be used to "hide" a filesystem in a
+  disk partition, floppy, or regular file, either using encryption
+  (scrambling the data) or steganography (hiding the data in the low
+  bits of, say, a sound file). This is also safe if the file resides
+  on a remote file server. If you want to do this, you will first have
+  to acquire and install a kernel patch from
+  ftp://ftp.replay.com/pub/crypto/linux/all or
+  ftp://verden.pvv.org/pub/linux/kerneli/v2.1/, and then you need to
+  say Y to this option.
+
+  Note that alternative ways to use encrypted filesystems are provided
+  by the cfs package, which can be gotten via FTP (user: anonymous)
+  from ftp://ftp.replay.com/pub/crypto/disk/, and the newer tcfs
+  package, available at http://tcfs.dia.unisa.it/. You do not need to
+  say Y here if you want to use one of these. However, using cfs
+  requires saying Y to "NFS filesystem support" below while using tcfs
+  requires applying a kernel patch.
+
+  To use the loop device, you need the losetup utility and a recent
+  version of the mount program, both contained in the util-linux
+  package. The location and current version number of util-linux is
+  contained in the file Documentation/Changes.
+
+  Note that this loop device has nothing to do with the loopback
+  device used for network connections from the machine to itself.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called loop.o.
+
+  Most users will answer N here.
+
+Network Block Device support
+CONFIG_BLK_DEV_NBD
+  Saying Y here will allow your computer to be a client for network
+  block devices, i.e. it will be able to use block devices exported by
+  servers (mount filesystems on them etc.). Communication between
+  client and server works over TCP/IP networking, but to the client
+  program this is hidden: it looks like a regular local file access to
+  a block device special file such as /dev/nd0. 
+
+  Network block devices also allows you to run a block-device in
+  userland (making server and client physically the same computer,
+  communicating using the loopback network device).
+  
+  Read Documentation/nbd.txt for more information, especially about
+  where to find the server code, which runs in user space and does not
+  need special kernel support.
+
+  Note that this has nothing to do with the network file systems NFS
+  or Coda; you can say N here even if you intend to use NFS or Coda.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called nbd.o.
+
+  If unsure, say N.
+
+Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
+CONFIG_BLK_DEV_IDE
+  If you say Y here, you will use the full-featured IDE driver to
+  control up to four IDE interfaces, each being able to serve a
+  "master" and a "slave" device, for a total of up to eight IDE
+  disk/cdrom/tape/floppy drives. People with SCSI-only systems
+  can say N here.
+
+  Useful information about large (>540 MB) IDE disks, multiple
+  interfaces, what to do if IDE devices are not automatically
+  detected, sound card IDE ports, module support, and other topics, is
+  contained in Documentation/ide.txt. For detailed information about
+  hard drives, consult the Disk-HOWTO and the Multi-Disk-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  To fine-tune IDE drive/interface parameters for improved
+  performance, look for the hdparm package at
+  ftp://metalab.unc.edu/pub/Linux/kernel/patches/diskdrives/
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/ide.txt. The module will be called ide.o. Do not
+  compile this driver as a module if your root filesystem (the one
+  containing the directory /) is located on an IDE device.
+
+  If you have one or more IDE drives, say Y or M here. If your system
+  has no IDE drives, or if memory requirements are really tight, you
+  could say N here, and select the "Old hard disk driver" below
+  instead to save about 13 KB of memory in the kernel.
+
+Old hard disk (MFM/RLL/IDE) driver
+CONFIG_BLK_DEV_HD_ONLY
+  There are two drivers for MFM/RLL/IDE hard disks. Most people use
+  the newer enhanced driver, but this old one is still around for two
+  reasons. Some older systems have strange timing problems and seem to
+  work only with the old driver (which itself does not work with some
+  newer systems). The other reason is that the old driver is smaller,
+  since it lacks the enhanced functionality of the new one. This makes
+  it a good choice for systems with very tight memory restrictions, or
+  for systems with only older MFM/RLL/ESDI drives. Choosing the old
+  driver can save 13 KB or so of kernel memory. 
+
+  If you are unsure, then just choose the Enhanced IDE/MFM/RLL driver
+  instead of this one. For more detailed information, read the
+  Disk-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  People with SCSI-only systems can say N here.
+
+Use old disk-only driver on primary interface
+CONFIG_BLK_DEV_HD_IDE
+  There are two drivers for MFM/RLL/IDE disks. Most people use just
+  the new enhanced driver by itself. This option however installs the
+  old hard disk driver to control the primary IDE/disk interface in
+  the system, leaving the new enhanced IDE driver to take care of only
+  the 2nd/3rd/4th IDE interfaces. Doing this will prevent you from
+  having an IDE/ATAPI CDROM or tape drive connected to the primary IDE
+  interface. Choosing this option may be useful for older systems
+  which have MFM/RLL/ESDI controller+drives at the primary port
+  address (0x1f0), along with IDE drives at the secondary/3rd/4th port
+  addresses. 
+
+  Normally, just say N here; you will then use the new driver for all
+  4 interfaces.
+
+  People with SCSI-only systems don't need this and can say N here as
+  well.
+
+Include IDE/ATA-2 DISK support
+CONFIG_BLK_DEV_IDEDISK
+  This will include enhanced support for MFM/RLL/IDE hard disks. If
+  you have a MFM/RLL/IDE disk, and there is no special reason to use
+  the old hard disk driver instead, say Y. If you have an SCSI-only
+  system, you can say N here.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-disk.o. Do not compile this driver as a module if your
+  root filesystem (the one containing the directory /) is located on
+  the IDE disk. If unsure, say Y.
+
+Include IDE/ATAPI CDROM support
+CONFIG_BLK_DEV_IDECD
+  If you have a CDROM drive using the ATAPI protocol, say Y. ATAPI is
+  a newer protocol used by IDE CDROM and TAPE drives, similar to the
+  SCSI protocol. Most new CDROM drives use ATAPI, including the
+  NEC-260, Mitsumi FX400, Sony 55E, and just about all non-SCSI
+  double(2X) or better speed drives.
+
+  If you say Y here, the CDROM drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar (check the boot messages with dmesg). If this is your only
+  CDROM drive, you can say N to all other CDROM options, but be sure
+  to say Y or M to "ISO 9660 CDROM filesystem support".
+
+  Read the CDROM-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and the file
+  Documentation/cdrom/ide-cd. Note that older versions of lilo (the
+  Linux boot loader) cannot properly deal with IDE/ATAPI CDROMs, so
+  install lilo-16 or higher, available from
+  ftp://metalab.unc.edu/pub/Linux/system/Linux-boot/lilo.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-cd.o.
+
+Include IDE/ATAPI TAPE support
+CONFIG_BLK_DEV_IDETAPE
+  If you have an IDE tape drive using the ATAPI protocol, say Y.
+  ATAPI is a newer protocol used by IDE tape and CDROM drives, similar
+  to the SCSI protocol. If you have an SCSI tape drive however, you
+  can say N here.
+
+  If you say Y here, the tape drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar, and will be mapped to a character device such as "ht0"
+  (check the boot messages with dmesg). Be sure to consult the
+  drivers/block/ide-tape.c and Documentation/ide.txt files for usage
+  information.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-tape.o.
+
+Include IDE/ATAPI FLOPPY support
+CONFIG_BLK_DEV_IDEFLOPPY
+  If you have an IDE floppy drive which uses the ATAPI protocol,
+  answer Y. ATAPI is a newer protocol used by IDE CDROM/tape/floppy
+  drives, similar to the SCSI protocol. 
+
+  The LS-120 and the IDE/ATAPI Iomega ZIP drive are also supported by
+  this driver. (ATAPI PD-CD/CDR drives are not supported by this
+  driver; support for PD-CD/CDR drives is available if you answer Y to
+  "SCSI emulation support", below).
+
+  If you say Y here, the FLOPPY drive will be identified along with
+  other IDE devices, as "hdb" or "hdc", or something similar (check
+  the boot messages with dmesg).
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-floppy.o.
+
+SCSI emulation support
+CONFIG_BLK_DEV_IDESCSI
+  This will provide SCSI host adapter emulation for IDE ATAPI devices,
+  and will allow you to use a SCSI device driver instead of a native
+  ATAPI driver.
+
+  This is useful if you have an ATAPI device for which no native
+  driver has been written (for example, an ATAPI PD-CD or CDR drive);
+  you can then use this emulation together with an appropriate SCSI
+  device driver. In order to do this, say Y here and to "SCSI support"
+  and "SCSI generic support", below.
+
+  Note that this option does NOT allow you to attach SCSI devices to a
+  box that doesn't have a SCSI host adapter installed.
+
+  If both this SCSI emulation and native ATAPI support are compiled
+  into the kernel, the native support will be used.
+
+  People with SCSI-only systems can say N here. If unsure, say N.
+
+CMD640 chipset bugfix/support
+CONFIG_BLK_DEV_CMD640
+  The CMD-Technologies CMD640 IDE chip is used on many common 486 and
+  Pentium motherboards, usually in combination with a "Neptune" or
+  "SiS" chipset. Unfortunately, it has a number of rather nasty
+  design flaws that can cause severe data corruption under many common
+  conditions. Say Y here to include code which tries to automatically
+  detect and correct the problems under Linux. This option also
+  enables access to the secondary IDE ports in some CMD640 based
+  systems. 
+
+  This driver will work automatically in PCI based systems (most new
+  systems have PCI slots). But if your system uses VESA local bus
+  (VLB) instead of PCI, you must also supply a kernel boot parameter
+  to enable the CMD640 bugfix/support: "ide0=cmd640_vlb". (Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel. The lilo procedure is also explained in
+  the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+
+  The CMD640 chip is also used on add-in cards by Acculogic, and on
+  the "CSA-6400E PCI to IDE controller" that some people have. For
+  details, read Documentation/ide.txt. 
+
+  People with SCSI-only systems should say N here. If unsure, say Y.
+
+CMD640 enhanced support
+CONFIG_BLK_DEV_CMD640_ENHANCED
+  This option includes support for setting/autotuning PIO modes and
+  prefetch on CMD640 IDE interfaces. For details, read
+  Documentation/ide.txt. If you have a CMD640 IDE interface and your
+  BIOS does not already do this for you, then say Y here. Otherwise
+  say N.
+
+RZ1000 chipset bugfix/support
+CONFIG_BLK_DEV_RZ1000
+  The PC-Technologies RZ1000 IDE chip is used on many common 486 and
+  Pentium motherboards, usually along with the "Neptune" chipset.
+  Unfortunately, it has a rather nasty design flaw that can cause
+  severe data corruption under many conditions. Say Y here to include
+  code which automatically detects and corrects the problem under
+  Linux. This may slow disk throughput by a few percent, but at least
+  things will operate 100% reliably. 
+
+  People with SCSI-only systems should say N here. If unsure, say Y.
+
+Generic PCI IDE chipset support
+CONFIG_BLK_DEV_IDEPCI
+  Say Y here for PCI systems which use IDE drive(s).
+  This option helps the IDE driver to automatically detect and
+  configure all PCI-based IDE interfaces in your system.
+  
+  People with SCSI-only systems should say N here; if unsure say Y.
+
+Generic PCI bus-master DMA support
+CONFIG_BLK_DEV_IDEDMA
+  If your PCI system uses IDE drive(s) (as opposed to SCSI, say) and
+  is capable of bus-master DMA operation (most Pentium PCI systems),
+  you will want to say Y here to reduce CPU overhead. You can then use
+  the "hdparm" utility to enable DMA for drives for which it was not
+  enabled automatically. By default, DMA is not enabled automatically
+  for these drives, but you can change that by saying Y to the
+  following question "Use DMA by default when available". You can get
+  the latest version of the hdparm utility via anonymous FTP from
+  ftp://metalab.unc.edu/pub/Linux/system/hardware/.
+
+  Read the comments at the beginning of drivers/block/idedma.c and the
+  file Documentation/ide.txt for more information. 
+
+  It is safe to say Y to this question.
+
+Winbond SL82c105 support
+CONFIG_BLK_DEV_SL82C105
+  If you have a Winbond SL82c105 IDE controller, say Y here to enable
+  special configuration for this chip. This is common on various CHRP
+  motherboards, but could be used elsewhere. If in doubt, say Y.
+
+Boot off-board chipsets first support
+CONFIG_BLK_DEV_OFFBOARD
+  Normally, IDE controllers built into the motherboard (on-board
+  controllers) are assigned to ide0 and ide1 while those on add-in PCI
+  cards (off-board controllers) are relegated to ide2 and ide3.
+  Answering Y here will reverse the situation, with off-board
+  controllers on ide0/1 and on-board controllers on ide2/3. This can
+  improve the usability of some boot managers such as LILO when
+  booting from a drive on an off-board controller.
+
+  Note that, if you say Y here, the order of the hd* devices will be
+  rearranged which may require modification of fstab and other files.
+
+  If in doubt, say N.
+
+Use DMA by default when available
+CONFIG_IDEDMA_AUTO
+  Prior to kernel version 2.1.112, Linux used to automatically use
+  DMA for IDE drives and chipsets which support it. Due to concerns
+  about a couple of cases where buggy hardware may have caused damage,
+  the default is now to NOT use DMA automatically. To revert to the
+  previous behaviour, say Y to this question.
+
+  If you suspect your hardware is at all flakey, say N here.
+  Do NOT email the IDE kernel people regarding this issue!
+
+  It is normally safe to answer Y to this question unless your
+  motherboard uses a VIA VP2 chipset, in which case you should say N.
+
+Other IDE chipset support
+CONFIG_IDE_CHIPSETS
+  Say Y here if you want to include enhanced support for various IDE
+  interface chipsets used on motherboards and add-on cards. You can
+  then pick your particular IDE chip from among the following options.
+  This enhanced support may be necessary for Linux to be able to
+  access the 3rd/4th drives in some systems. It may also enable
+  setting of higher speed I/O rates to improve system performance with
+  these chipsets. Most of these also require special kernel boot
+  parameters to actually turn on the support at runtime; you can find
+  a list of these in the file Documentation/ide.txt.
+  
+  People with SCSI-only systems can say N here. 
+
+Generic 4 drives/port support
+CONFIG_BLK_DEV_4DRIVES
+  Certain older chipsets, including the Tekram 690CD, use a single set
+  of I/O ports at 0x1f0 to control up to four drives, instead of the
+  customary two drives per port. Support for this can be enabled at
+  runtime using the "ide0=four" kernel boot parameter if you say Y
+  here.
+
+DTC-2278 support
+CONFIG_BLK_DEV_DTC2278
+  This driver is enabled at runtime using the "ide0=dtc2278" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the DTC-2278 card, and permits faster I/O speeds to be set as
+  well. See the Documentation/ide.txt and drivers/block/dtc2278.c
+  files for more info.
+
+Holtek HT6560B support
+CONFIG_BLK_DEV_HT6560B
+  This driver is enabled at runtime using the "ide0=ht6560b" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the Holtek card, and permits faster I/O speeds to be set as well.
+  See the Documentation/ide.txt and drivers/block/ht6560b.c files for
+  more info.
+
+PROMISE DC4030 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_PDC4030
+  This driver provides support for the secondary IDE interface and
+  cache of Promise IDE chipsets, e.g. DC4030 and DC5030. This driver
+  is known to incur timeouts/retries during heavy I/O to drives
+  attached to the secondary interface. CDROM and TAPE devices are not
+  supported yet. This driver is enabled at runtime using the
+  "ide0=dc4030" kernel boot parameter. See the Documentation/ide.txt
+  and drivers/block/pdc4030.c files for more info.
+
+PS/2 ESDI hard disk support
+CONFIG_BLK_DEV_PS2
+  Say Y here if you have a PS/2 machine with a MCA bus and an ESDI
+  hard disk.
+  
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ps2esdi.o.
+
+ALI M15X3 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_ALI15X3
+  This driver ensures (U)DMA support for ALI 1543 and 1543C,
+  1535, 1535D onboard chipsets.
+
+Tekram TRM290 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_TRM290
+  This driver adds support for bus master DMA transfers
+  using the Tekram TRM290 PCI IDE chip. Volunteers are
+  needed for further tweaking and development.
+  Please read the comments at the top of drivers/block/trm290.c.
+
+OPTi 82C621 enhanced support (EXPERIMENTAL)
+CONFIG_BLK_DEV_OPTI621
+  This is a driver for the OPTi 82C621 EIDE controller.
+  Please read the comments at the top of drivers/block/opti621.c.
+
+NS87415 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_NS87415
+  This driver adds detection and support for the NS87415 chip
+  (used in SPARC64, among others).
+
+  Please read the comments at the top of drivers/block/ns87415.c.
+
+VIA82C586 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_VIA82C586
+  This adds initial timing settings for VIA (U)DMA onboard ide
+  controllers that are ATA3 compliant. May work with ATA4 systems, but
+  not tested to date.
+
+  If you say Y here, you also need to say Y to "Use DMA by default
+  when available", above.
+
+  If unsure, say N.
+
+CMD646 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_CMD646
+  Say Y here if you have an IDE controller like this.
+
+Cyrix CS5530 MediaGX chipset support
+CONFIG_BLK_DEV_CS5530
+  Include support for UDMA on the Cyrix MediaGX 5530 chipset. This
+  will automatically be detected and configured if found.
+
+  It is safe to say Y to this question.
+
+QDI QD6580 support
+CONFIG_BLK_DEV_QD6580
+  This driver is enabled at runtime using the "ide0=qd6580" kernel
+  boot parameter. It permits faster I/O speeds to be set. See the
+  files Documentation/ide.txt and drivers/block/qd6580.c for more
+  info.
+
+UMC 8672 support
+CONFIG_BLK_DEV_UMC8672
+  This driver is enabled at runtime using the "ide0=umc8672" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the UMC-8672, and permits faster I/O speeds to be set as well.
+  See the files Documentation/ide.txt and drivers/block/umc8672.c for
+  more info.
+
+ALI M14xx support
+CONFIG_BLK_DEV_ALI14XX
+  This driver is enabled at runtime using the "ide0=ali14xx" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the ALI M1439/1443/1445/1487/1489 chipsets, and permits faster
+  I/O speeds to be set as well. See the files Documentation/ide.txt
+  and drivers/block/ali14xx.c for more info.
+
+Generic PC I/O port IDE interface support
+CONFIG_BLK_DEV_PCIDE
+  This is the IDE driver for most generic PC style IDE interfaces.
+  Say Y if you have a PC and want to use IDE devices (hard disks, CD-ROM
+  drives, etc.) that are connected to the builtin IDE interface.
+
+Amiga builtin Gayle IDE interface support
+CONFIG_BLK_DEV_GAYLE
+  This is the IDE driver for the builtin IDE interface on some Amiga
+  models.  It supports both the `A1200 style' (used in A600 and A1200)
+  and `A4000 style' (used in A4000 and A4000T) of the Gayle IDE
+  interface.
+  Say Y if you have such an Amiga model and want to use IDE devices
+  (hard disks, CD-ROM drives, etc.) that are connected to the builtin
+  IDE interface.
+
+Falcon IDE interface support
+CONFIG_BLK_DEV_FALCON_IDE
+  This is the IDE driver for the builtin IDE interface on the Atari
+  Falcon.
+  Say Y if you have a Falcon and want to use IDE devices (hard disks,
+  CD-ROM drives, etc.) that are connected to the builtin IDE interface.
+
+Amiga Buddha/Catweasel IDE interface support (EXPERIMENTAL)
+CONFIG_BLK_DEV_BUDDHA
+  This is the IDE driver for the IDE interfaces on the Buddha and
+  Catweasel expansion boards.  It supports up to two interfaces on the
+  Buddha and three on the Catweasel.
+  Say Y if you have a Buddha or Catweasel expansion board and want to
+  use IDE devices (hard disks, CD-ROM drives, etc.) that are connected
+  to one of its IDE interfaces.
+
+Amiga IDE Doubler support (EXPERIMENTAL)
+CONFIG_BLK_DEV_IDEDOUBLER
+  This driver provides support for the so called `IDE doublers' (made by
+  various manufacturers, e.g. Eyetech) that can be connected to the
+  builtin IDE interface of some Amiga models. Using such an IDE doubler,
+  you can connect up to four instead of two IDE devices on the Amiga's
+  builtin IDE interface.
+  Note that the normal Amiga Gayle IDE driver may not work correctly if
+  you have an IDE doubler and don't enable this driver!
+  Say Y if you have an IDE doubler.  The driver is enabled at kernel
+  runtime using the "ide=doubler" kernel boot parameter.
+
+XT hard disk support
+CONFIG_BLK_DEV_XD
+  Very old 8 bit hard disk controllers used in the IBM XT computer
+  will be supported if you say Y here. 
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called xd.o. 
+
+  It's pretty unlikely that you have one of these: say N.
+
+Mylex DAC960/DAC1100 PCI RAID Controller support
+CONFIG_BLK_DEV_DAC960
+  This driver adds support for the Mylex DAC960, AcceleRAID, and
+  eXtremeRAID PCI RAID controllers.  See README.DAC960 for further
+  information about this driver.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt.  The module will be
+  called DAC960.o. 
+
+Parallel port IDE device support
+CONFIG_PARIDE
+  There are many external CD-ROM and disk devices that connect through
+  your computer's parallel port. Most of them are actually IDE devices
+  using a parallel port IDE adapter. This option enables the PARIDE
+  subsystem which contains drivers for many of these external drives.
+  Read linux/Documentation/paride.txt for more information.
+
+  If you have said Y to the "Parallel-port support" configuration
+  option, you may share a single port between your printer and other
+  parallel port devices. Answer Y to build PARIDE support into your
+  kernel, or M if you would like to build it as a loadable module. If
+  your parallel port support is in a loadable module, you must build
+  PARIDE as a module. If you built PARIDE support into your kernel,
+  you may still build the individual protocol modules and high-level
+  drivers as loadable modules. If you build this support as a module,
+  it will be called paride.o.
+
+  To use the PARIDE support, you must say Y or M here and also to at
+  least one high-level driver (e.g. "Parallel port IDE disks",
+  "Parallel port ATAPI CD-ROMs", "Parallel port ATAPI disks" etc.) and
+  to at least one protocol driver (e.g. "ATEN EH-100 protocol",
+  "MicroSolutions backpack protocol", "DataStor Commuter protocol"
+  etc.).
+
+Parallel port IDE disks
+CONFIG_PARIDE_PD
+  This option enables the high-level driver for IDE-type disk devices 
+  connected through a parallel port. If you chose to build PARIDE 
+  support into your kernel, you may answer Y here to build in the 
+  parallel port IDE driver, otherwise you should answer M to build 
+  it as a loadable module. The module will be called pd.o. You 
+  must also have at least one parallel port protocol driver in your 
+  system. Among the devices supported by this driver are the SyQuest 
+  EZ-135, EZ-230 and SparQ drives, the Avatar Shark and the backpack
+  hard drives from MicroSolutions.
+
+Parallel port ATAPI CD-ROMs
+CONFIG_PARIDE_PCD
+  This option enables the high-level driver for ATAPI CD-ROM devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI CD-ROM driver, otherwise you should answer M to
+  build it as a loadable module. The module will be called pcd.o. You
+  must also have at least one parallel port protocol driver in your
+  system. Among the devices supported by this driver are the
+  MicroSolutions backpack CD-ROM drives and the Freecom Power CD. If
+  you have such a CD-ROM drive, you should also say Y or M to "ISO
+  9660 CDROM filesystem support" below, because that's the filesystem
+  used on CDROMs.
+
+Parallel port ATAPI disks
+CONFIG_PARIDE_PF
+  This option enables the high-level driver for ATAPI disk devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pf.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver are the
+  MicroSolutions backpack PD/CD drive and the Imation Superdisk
+  LS-120 drive.
+
+Parallel port ATAPI tapes
+CONFIG_PARIDE_PT
+  This option enables the high-level driver for ATAPI tape devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pt.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver is the
+  parallel port version of the HP 5GB drive.
+
+Parallel port generic ATAPI devices
+CONFIG_PARIDE_PG
+  This option enables a special high-level driver for generic ATAPI
+  devices connected through a parallel port. The driver allows user
+  programs, such as cdrecord, to send ATAPI commands directly to a
+  device. 
+
+  If you chose to build PARIDE support into your kernel, you may
+  answer Y here to build in the parallel port generic ATAPI driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called pg.o.
+
+  You must also have at least one parallel port protocol driver in
+  your system.
+
+  This driver implements an API loosely related to the generic SCSI
+  driver. See /usr/include/linux/pg.h for details.
+
+  You can obtain the most recent version of cdrecord from
+  ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/ . Versions 1.6.1a3 and
+  later fully support this driver.
+
+ATEN EH-100 protocol
+CONFIG_PARIDE_ATEN
+  This option enables support for the ATEN EH-100 parallel port IDE
+  protocol. This protocol is used in some inexpensive low performance
+  parallel port kits made in Hong Kong. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called aten.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+MicroSolutions backpack protocol
+CONFIG_PARIDE_BPCK
+  This option enables support for the MicroSolutions backpack parallel
+  port IDE protocol. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called bpck.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+DataStor Commuter protocol
+CONFIG_PARIDE_COMM
+  This option enables support for the Commuter parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called comm.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+DataStor EP-2000 protocol
+CONFIG_PARIDE_DSTR
+  This option enables support for the EP-2000 parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called dstr.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+Shuttle EPAT/EPEZ protocol
+CONFIG_PARIDE_EPAT
+  This option enables support for the EPAT parallel port IDE protocol.
+  EPAT is a parallel port IDE adapter manufactured by Shuttle
+  Technology and widely used in devices from major vendors such as
+  Hewlett-Packard, SyQuest, Imation and Avatar. If you chose to build
+  PARIDE support into your kernel, you may answer Y here to build in
+  the protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called epat.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+Shuttle EPIA protocol
+CONFIG_PARIDE_EPIA
+  This option enables support for the (obsolete) EPIA parallel port
+  IDE protocol from Shuttle Technology. This adapter can still be
+  found in some no-name kits. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called epia.o. You must also have a
+  high-level driver for the type of device that you want to support.
+
+FIT TD-2000 protocol
+CONFIG_PARIDE_FIT2
+  This option enables support for the TD-2000 parallel port IDE
+  protocol from Fidelity International Technology. This is a simple
+  (low speed) adapter that is used in some portable hard drives. If
+  you chose to build PARIDE support into your kernel, you may answer Y
+  here to build in the protocol driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called ktti.o.
+  You must also have a high-level driver for the type of device that
+  you want to support.
+
+FIT TD-3000 protocol
+CONFIG_PARIDE_FIT3
+  This option enables support for the TD-3000 parallel port IDE
+  protocol from Fidelity International Technology. This protocol is
+  used in newer models of their portable disk, CD-ROM and PD/CD
+  devices. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called fit3.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Freecom IQ ASIC-2 protocol
+CONFIG_PARIDE_FRIQ
+  This option enables support for version 2 of the Freecom IQ parallel
+  port IDE adapter.  This adapter is used by the Maxell Superdisk 
+  drive.  If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called friq.o. You must also have a high-level driver for the type
+  of device that you want to support. 
+
+FreeCom power protocol
+CONFIG_PARIDE_FRPW
+  This option enables support for the Freecom power parallel port IDE
+  protocol. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called frpw.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+KingByte KBIC-951A/971A protocols
+CONFIG_PARIDE_KBIC
+  This option enables support for the KBIC-951A and KBIC-971A parallel
+  port IDE protocols from KingByte Information Corp. KingByte's
+  adapters appear in many no-name portable disk and CD-ROM products,
+  especially in Europe. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called kbic.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+KT PHd protocol
+CONFIG_PARIDE_KTTI
+  This option enables support for the "PHd" parallel port IDE protocol
+  from KT Technology. This is a simple (low speed) adapter that is
+  used in some 2.5" portable hard drives. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called ktti.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+OnSpec 90c20 protocol
+CONFIG_PARIDE_ON20
+  This option enables support for the (obsolete) 90c20 parallel port 
+  IDE protocol from OnSpec (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you 
+  may answer Y here to build in the protocol driver, otherwise you 
+  should answer M to build it as a loadable module. The module will 
+  be called on20.o. You must also have a high-level driver for the 
+  type of device that you want to support.
+
+OnSpec 90c26 protocol
+CONFIG_PARIDE_ON26
+  This option enables support for the 90c26 parallel port IDE protocol
+  from OnSpec Electronics (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called on26.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Multiple devices driver support
+CONFIG_BLK_DEV_MD
+  This driver lets you combine several hard disk partitions into one
+  logical block device. This can be used to simply append one
+  partition to another one or to combine several redundant
+  hard disks to a RAID1/4/5 device so as to provide protection against
+  hard disk failures. This is called "Software RAID" since the
+  combining of the partitions is done by the kernel. "Hardware RAID"
+  means that the combining is done by a dedicated controller; if you
+  have such a controller, you do not need to say Y here.
+
+  More information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If unsure, say N.
+
+Linear (append) mode
+CONFIG_MD_LINEAR
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called linear mode, i.e. it will combine the hard disk
+  partitions by simply appending one to the other. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called linear.o.
+
+  If unsure, say Y.
+
+RAID-0 (striping) mode
+CONFIG_MD_STRIPED
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called raid0 mode, i.e. it will combine the hard disk
+  partitions into one logical device in such a fashion as to fill them
+  up evenly, one chunk here and one chunk there. This will increase
+  the throughput rate if the partitions reside on distinct disks. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called raid0.o.
+
+  If unsure, say Y.
+
+RAID-1 (mirroring) mode
+CONFIG_MD_MIRRORING
+  A RAID-1 set consists of several disk drives which are exact copies
+  of each other. In the event of a mirror failure, the RAID driver
+  will continue to use the operational mirrors in the set, providing
+  an error free MD (multiple device) to the higher levels of the
+  kernel. In a set with N drives, the available space is the capacity
+  of a single drive, and the set protects against a failure of (N - 1)
+  drives. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-1 set, say Y. This code is also
+  available as a module called raid1.o ( = code which can be inserted
+  in and removed from the running kernel whenever you want). If you
+  want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+RAID-4/RAID-5 mode
+CONFIG_MD_RAID5
+  A RAID-5 set of N drives with a capacity of C MB per drive provides
+  the capacity of C * (N - 1) drives, and protects against a failure
+  of a single drive. For a given sector (row) number, (N - 1) drives
+  contain data sectors, and one drive contains the parity protection.
+  For a RAID-4 set, the parity blocks are present on a single drive,
+  while a RAID-5 set distributes the parity across the drives in one
+  of the available parity distribution methods.
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-4/RAID-5 set, say Y. This code is
+  also available as a module called raid5.o ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+Boot support (linear, striped)
+CONFIG_MD_BOOT
+  To boot with an initial linear or striped md device you have to
+  answer Y here. For lilo and loadlin options see the file
+  Documentation/md.txt.
+
+Support for Deskstation RPC44 
+CONFIG_DESKSTATION_RPC44
+  This is a machine with a R4400 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux
+  on the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).
+
+Support for Acer PICA 1 chipset
+CONFIG_ACER_PICA_61
+  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+Support for Algorithmics P4032
+CONFIG_ALGOR_P4032
+  This is an evaluation board of the British company Algorithmics. The
+  board uses the R4300 and a R5230 CPUs. For more information about
+  this board see http://www.algor.co.uk.
+
+IDE card support
+CONFIG_BLK_DEV_IDE_CARDS
+  On Acorn systems, enable this if you wish to use an IDE interface
+  expansion card. If you do not or are unsure, say N to this.
+
+ICS IDE interface
+CONFIG_BLK_DEV_IDE_ICS
+  On Acorn systems, enable this if you wish to use the ICS IDE
+  interface card.  This is not required for ICS partition support.
+  If you are unsure, say N to this.
+
+ADFS partition support
+CONFIG_BLK_DEV_PART
+  This allows Linux on Acorn systems to determine its partitions in
+  the 'non-ADFS' partition area of the hard disk - usually located
+  after the ADFS partition.  You are probably using this system, so
+  you should enable it.
+
+Support for Mips Magnum 4000
+CONFIG_MIPS_MAGNUM_4000
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+Support for Olivetti M700
+CONFIG_OLIVETTI_M700
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://lena.fnet.fr/ (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape).
+
+CPU type
+CONFIG_CPU_R3000
+  Give the type of your machine's MIPS CPU. For this question, it
+  suffices to give a unique prefix of the option you want to choose.
+  In case of doubt select the R3000 CPU. The kernel will then run on
+  other MIPS machines but with slightly reduced performance.
+
+Compile the kernel into the ECOFF object format
+CONFIG_ECOFF_KERNEL
+  Some machines require a kernel in the ECOFF format. You will have to
+  say Y here for example if you want to use a Mips Magnum 3000 or a
+  DECstation.
+
+Generate little endian code
+CONFIG_CPU_LITTLE_ENDIAN
+  Some MIPS machines can be configured for either little or big endian
+  byte order. These modes require different kernels. Say Y if your
+  machine is little endian, N if it's a big endian machine.
+
+Kernel support for IRIX binaries
+CONFIG_BINFMT_IRIX
+  If you say Y here, the kernel will support running of IRIX binaries.
+  You will need IRIX libraries for this to work.
+
+Networking support
+CONFIG_NET
+  Unless you really know what you are doing, you should say Y here.
+  The reason is that some programs need kernel networking support even
+  when running on a stand-alone machine that isn't connected to any
+  other computer. If you are upgrading from an older kernel, you
+  should consider updating your networking tools too because changes
+  in the kernel and the tools often go hand in hand. The tools are
+  contained in the package net-tools, the location and version number
+  of which are given in Documentation/Changes.
+
+  For a general introduction to Linux networking, it is highly
+  recommended to read the NET-3-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+Socket filtering
+CONFIG_FILTER
+  The Linux Socket Filter is derived from the Berkeley Packet Filter.
+  If you say Y here, user-space programs can attach a filter to any
+  socket and thereby tell the kernel that it should allow or disallow
+  certain types of data to get through the socket. Linux Socket
+  Filtering works on all socket types except TCP for now. See the text
+  file linux/Documentation/networking/filter.txt for more information.
+  If unsure, say N.
+
+Network firewalls
+CONFIG_FIREWALL
+  A firewall is a computer which protects a local network from the
+  rest of the world: all traffic to and from computers on the local
+  net is inspected by the firewall first, and sometimes blocked or
+  modified. The type of firewall you'll get if you say Y here is
+  called a "packet filter": it can block network traffic based on
+  type, origin and destination. By contrast, "proxy-based" firewalls
+  are more secure but more intrusive and more bothersome to set up;
+  they inspect the network traffic much more closely, modify it and
+  have knowledge about the higher level protocols, which packet
+  filters lack. They also often require changes in the programs
+  running on the local clients. Proxy-based firewalls don't need
+  support by the kernel, but they are often combined with packet
+  filters, which only works if you say Y here.
+
+  If you want to configure your Linux box as a packet filter firewall
+  for a local network, say Y here. If your local network is TCP/IP
+  based, you will then also have to say Y to "IP: firewalling", below.
+
+  You also need to say Y here and to "IP firewalling" below in order
+  to be able to use IP masquerading (i.e. local computers can chat
+  with an outside host, but that outside host is made to think that it
+  is talking to the firewall box -- makes the local network completely
+  invisible to the outside world and avoids the need to allocate
+  globally valid IP host addresses for the machines on the local net)
+  and IP transparent proxying (makes the computers on the local
+  network think they're talking to a remote computer, while in reality
+  the traffic is redirected by your Linux firewall to a local proxy
+  server).
+
+  Make sure to say N to "Fast switching" below if you intend to say Y
+  here.
+
+  Chances are that you should say Y here for every machine which is
+  run as a router and N for every regular host. If unsure, say N.
+
+SYN flood protection
+CONFIG_SYN_COOKIES
+  Normal TCP/IP networking is open to an attack known as "SYN
+  flooding". This denial-of-service attack prevents legitimate remote
+  users from being able to connect to your computer during an ongoing
+  attack and requires very little work from the attacker, who can
+  operate from anywhere on the Internet.
+
+  SYN cookies provide protection against this type of attack. If you
+  say Y here, the TCP/IP stack will use a cryptographic challenge
+  protocol known as "SYN cookies" to enable legitimate users to
+  continue to connect, even when your machine is under attack. There
+  is no need for the legitimate users to change their TCP/IP software;
+  SYN cookies work transparently to them. For technical information
+  about SYN cookies, check out
+  ftp://koobera.math.uic.edu/syncookies.html .
+
+  If you are SYN flooded, the source address reported by the kernel is
+  likely to have been forged by the attacker; it is only reported as
+  an aid in tracing the packets to their actual source and should not
+  be taken as absolute truth.
+
+  SYN cookies may prevent correct error reporting on clients when the
+  server is really overloaded. If this happens frequently better turn
+  them off.
+
+  If you say Y here, note that SYN cookies aren't enabled by default;
+  you can enable them by saying Y to "/proc filesystem support" and
+  "Sysctl support" below and executing the command
+
+    echo 1 >/proc/sys/net/ipv4/tcp_syncookies 
+
+  at boot time after the proc filesystem has been mounted.
+  
+  If unsure, say Y.
+
+Sun floppy controller support
+CONFIG_BLK_DEV_SUNFD
+  This is support for floppy drives on Sun SPARC workstations. Say Y
+  if you have a floppy drive, otherwise N. Easy.
+
+Alpha system type
+CONFIG_ALPHA_GENERIC
+  This is the system type of your hardware.  A "generic" kernel will
+  run on any supported Alpha system. However, if you configure a
+  kernel for your specific system, it will be faster and smaller.
+
+  To find out what type of Alpha system you have, you may want to
+  check out the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).  In summary:
+
+  Alcor/Alpha-XLT     AS 600
+  Alpha-XL            XL-233, XL-266
+  AlphaBook1          Alpha laptop
+  Avanti              AS 200, AS 205, AS 250, AS 255, AS 300, AS 400
+  Cabriolet           AlphaPC64, AlphaPCI64
+  DP264               DP264
+  EB164               EB164 21164 evaluation board
+  EB64+               EB64+ 21064 evaluation board
+  EB66                EB66 21066 evaluation board
+  EB66+               EB66+ 21066 evaluation board
+  Jensen              DECpc 150, DEC 2000 model 300, 
+                      DEC 2000 model 500
+  LX164               AlphaPC164-LX
+  Miata               Personal Workstation 433a, 433au, 500a,
+                      500au, 600a, or 600au
+  Mikasa              AS 1000
+  Noname              AXPpci33, UDB (Multia)
+  Noritake            AS 1000A, AS 600A, AS 800
+  PC164               AlphaPC164
+  Rawhide             AS 1200, AS 4000, AS 4100
+  Ruffian             RPX164-2, AlphaPC164-UX, AlphaPC164-BX
+  SX164               AlphaPC164-SX
+  Sable               AS 2000, AS 2100
+  Takara              Takara
+
+  If you don't know what to do, choose "generic".
+
+EV5 CPU daughtercard
+CONFIG_ALPHA_PRIMO
+  Say Y if you have an AS 1000 5/xxx or an AS 1000A 5/xxx.
+
+EV5 CPU(s)
+CONFIG_ALPHA_GAMMA
+  Say Y if you have an AS 2000 5/xxx or an AS 2100 5/xxx.
+
+Using SRM as bootloader
+CONFIG_ALPHA_SRM
+  There are two different types of booting firmware on Alphas: SRM,
+  which is command line driven, and ARC, which uses menus and arrow
+  keys. Details about the Linux/Alpha booting process are contained in
+  the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape).
+
+  The usual way to load Linux on an Alpha machine is to use MILO
+  (a bootloader that lets you pass command line parameters to the
+  kernel just like lilo does for the x86 architecture) which can be
+  loaded either from ARC or can be installed directly as a permanent
+  firmware replacement from floppy (which requires changing a certain
+  jumper on the motherboard). If you want to do either of these, say N
+  here. If MILO doesn't work on your system (true for Jensen
+  motherboards), you can bypass it altogether and boot Linux directly
+  from an SRM console; say Y here in order to do that. Note that you
+  won't be able to boot from an IDE disk using SRM. 
+
+  If unsure, say N.
+
+Use SRM PCI setup
+CONFIG_ALPHA_SRM_SETUP
+  This option controls whether or not the PCI configuration set up by
+  SRM is modified.  If you say Y, the existing PCI configuration will
+  be left intact.
+
+Non-standard serial port support
+CONFIG_SERIAL_NONSTANDARD
+  Say Y here if you have any non-standard serial boards -- boards
+  which aren't supported using the standard "dumb" serial driver.
+  This includes intelligent serial boards such as Cyclades,
+  Digiboards, etc. These are usually used for systems that need many
+  serial ports because they serve many terminals or dial-in
+  connections. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-standard serial boards. 
+
+  Most people can say N here.
+
+Extended dumb serial driver options
+CONFIG_SERIAL_EXTENDED
+  If you wish to use any non-standard features of the standard "dumb"
+  driver, say Y here. This includes HUB6 support, shared serial
+  interrupts, special multiport support, support for more than the
+  four COM 1/2/3/4 boards, etc. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about serial driver options. If unsure, say N.
+
+Support more than 4 serial ports
+CONFIG_SERIAL_MANY_PORTS
+  Say Y here if you have dumb serial boards other than the four
+  standard COM 1/2/3/4 ports. This may happen if you have an AST
+  FourPort, Accent Async, Boca (read the Boca mini-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini), or other custom
+  serial port hardware which acts similar to standard serial port
+  hardware. If you only use the standard COM 1/2/3/4 ports, you can
+  say N here to save some memory. You can also say Y if you have an
+  "intelligent" multiport card such as Cyclades, Digiboards, etc.
+
+Support for sharing serial interrupts
+CONFIG_SERIAL_SHARE_IRQ
+  Some serial boards have hardware support which allows multiple dumb
+  serial ports on the same board to share a single IRQ. To enable
+  support for this in the serial driver, say Y here.
+
+Auto detect IRQ on standard ports (unsafe)
+CONFIG_SERIAL_DETECT_IRQ
+  Say Y here if you want the kernel to try to guess which IRQ
+  to use for your serial port. 
+
+  This is considered unsafe; it is far better to configure the IRQ in
+  a boot script using the setserial command.
+
+  If unsure, say N.
+
+Support special multiport boards
+CONFIG_SERIAL_MULTIPORT
+  Some multiport serial ports have special ports which are used to
+  signal when there are any serial ports on the board which need
+  servicing. Say Y here to enable the serial driver to take advantage
+  of those special I/O ports.
+
+SGI Zilog85C30 serial support
+CONFIG_SGI_SERIAL
+  If you want to use your SGI's built-in serial ports under Linux,
+  answer Y.
+
+SGI graphics support
+CONFIG_SGI_GRAPHICS
+  If you have an SGI machine and you want to compile the graphics
+  drivers, say Y here. This will include the code for the
+  /dev/graphics and /dev/gfx drivers into the kernel for supporting
+  virtualized access to your graphics hardware.
+
+Support the Bell Technologies HUB6 card
+CONFIG_HUB6
+  Say Y here to enable support in the dumb serial driver to support
+  the HUB6 card.
+
+PCI support
+CONFIG_PCI
+  Find out whether you have a PCI motherboard. PCI is the name of a
+  bus system, i.e. the way the CPU talks to the other stuff inside
+  your box. Other bus systems are ISA, EISA, Microchannel (MCA) or
+  VESA. If you have PCI, say Y, otherwise N. 
+
+  The PCI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, contains valuable
+  information about which PCI hardware does work under Linux and which
+  doesn't.
+
+PCI access mode
+CONFIG_PCI_GOBIOS
+  On PCI systems, the BIOS can be used to detect the PCI devices and
+  determine their configuration. However, some old PCI motherboards
+  have BIOS bugs and may crash if this is done. Also, some embedded
+  PCI-based systems don't have any BIOS at all. Linux can also try to
+  detect the PCI hardware directly without using the BIOS.
+
+  With this option, you can specify how Linux should detect the PCI
+  devices. If you choose "BIOS", the BIOS will be used, if you choose
+  "Direct", the BIOS won't be used, and if you choose "Any", the
+  kernel will try the direct access method and falls back to the BIOS
+  if that doesn't work. If unsure, go with the default.
+
+PCI quirks
+CONFIG_PCI_QUIRKS
+  If you have a broken BIOS, it may fail to set up the PCI bus in a
+  correct or optimal fashion. Saying Y here will correct that problem.
+  If your BIOS is fine you can say N here for a very slightly smaller
+  kernel. If unsure, say Y.
+
+PCI bridge optimization (experimental)
+CONFIG_PCI_OPTIMIZE
+  This can improve access times for some hardware devices if you have
+  a really broken BIOS and your computer uses a PCI bus system. Say Y
+  if you think it might help, but try turning it off if you experience
+  any problems with the PCI bus. N is the safe answer.
+
+Backward-compatible /proc/pci
+CONFIG_PCI_OLD_PROC
+  Older kernels supported a /proc/pci file containing brief textual
+  descriptions of all PCI devices in the system. Several programs
+  tried to parse this file, so it became almost impossible to add new
+  fields without breaking compatibility. So a new /proc interface to
+  PCI (/proc/bus/pci) has been implemented and the old one is
+  supported for compatibility reasons only; you'll get the old one (in
+  addition to the new one) if you say Y here and to "/proc filesystem
+  support", below. If unsure, say Y. If you say N, you'll only get the
+  new /proc/bus/pci interface.
+
+MCA support
+CONFIG_MCA
+  MicroChannel Architecture is found in some IBM PS/2 machines and
+  laptops. It is a bus system similar to PCI or ISA. See
+  Documentation/mca.txt (and especially the web page given there)
+  before attempting to build an MCA bus kernel.
+
+SGI Visual Workstation support
+CONFIG_VISWS
+  The SGI Visual Workstation series is an IA32-based workstation
+  based on SGI systems chips with some legacy PC hardware attached.
+  Say Y here to create a kernel to run on the SGI 320 or 540.
+  A kernel compiled for the Visual Workstation will not run on other
+  PC boards and vice versa.
+  See Documentation/sgi-visws.txt for more.
+
+SGI Visual Workstation framebuffer support
+CONFIG_FB_SGIVW
+  SGI Visual Workstation support for framebuffer graphics.
+
+I2O support
+CONFIG_I2O
+  The Intelligent Input/Output (I2O) architecture allows hardware
+  drivers to be split into two parts: an operating system specific
+  module called the OSM and an hardware specific module called the
+  HDM. The OSM can talk to a whole range of HDM's, and ideally the
+  HDM's are not OS dependent. This allows for the same HDM driver to
+  be used under different operating systems if the relevant OSM is in
+  place. In order for this to work, you need to have an I2O interface
+  adapter card in your computer. This card contains a special I/O
+  processor (IOP), thus allowing high speeds since the CPU does not
+  have to deal with I/O.
+
+  If you say Y here, you will get a choice of interface adapter
+  drivers and OSM's with the following questions.
+
+  This support is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. You will get modules called i2o_core.o
+  and i20_config.o. 
+
+  If unsure, say N.
+
+I2O PCI support
+CONFIG_I2O_PCI
+  Say Y for support of PCI bus I2O interface adapters. Currently this
+  is the only variety supported, so you should say Y.
+
+  This support is also available as a module called i2o_pci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O Block OSM
+CONFIG_I2O_BLOCK
+  Include support for the I2O Block OSM. The Block OSM presents disk
+  and other structured block devices to the operating system.
+
+  This support is also available as a module called i2o_block.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O SCSI OSM
+CONFIG_I2O_SCSI
+  Allows direct SCSI access to SCSI devices on a SCSI or FibreChannel
+  I2O controller. You can use both the SCSI and Block OSM together if
+  you wish.
+
+  This support is also available as a module called i2o_scsi.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+System V IPC
+CONFIG_SYSVIPC
+  Inter Process Communication is a suite of library functions and
+  system calls which let processes (running programs) synchronize
+  and exchange information. It is generally considered to be a good
+  thing, and some programs won't run unless you say Y here. In
+  particular, if you want to run the DOS emulator dosemu under Linux
+  (read the DOSEMU-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO), you'll need to say Y
+  here.
+  
+  You can find documentation about IPC with "info ipc" and also in
+  section 6.4 of the Linux Programmer's Guide, available via FTP
+  (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/LDP/programmers-guide.
+
+  Saying Y here enlarges your kernel by about 7 KB. Just say Y.
+
+BSD Process Accounting
+CONFIG_BSD_PROCESS_ACCT
+  If you say Y here, a user level program will be able to instruct the
+  kernel (via a special system call) to write process accounting
+  information to a file: whenever a process exits, information about
+  that process will be appended to the file by the kernel. The
+  information includes things such as creation time, owning user,
+  command name, memory usage, controlling terminal etc. (the complete
+  list is in the struct acct in include/linux/acct.h). It is up to the
+  user level program to do useful things with this information. This
+  is generally a good idea, so say Y.
+  
+Sysctl support
+CONFIG_SYSCTL
+  The sysctl interface provides a means of dynamically changing
+  certain kernel parameters and variables on the fly without requiring
+  a recompile of the kernel or reboot of the system. The primary
+  interface consists of a system call, but if the /proc filesystem is
+  enabled, a tree of modifiable sysctl entries will be generated
+  beneath the /proc/sys directory. They are explained in the files in
+  Documentation/sysctl/. Note that enabling this option will enlarge
+  the kernel by at least 8 KB. 
+
+  As it is generally a good thing, you should say Y here unless
+  building a kernel for install/rescue disks or your system is very
+  limited in memory.
+
+Kernel support for ELF binaries
+CONFIG_BINFMT_ELF
+  ELF (Executable and Linkable Format) is a format for libraries and
+  executables used across different architectures and operating
+  systems. Saying Y here will enable your kernel to run ELF binaries
+  and enlarge it by about 2 KB. ELF support under Linux has now all
+  but replaced the traditional Linux a.out formats (QMAGIC and ZMAGIC)
+  because it is portable (this does *not* mean that you will be able
+  to run executables from different architectures or operating systems
+  however) and makes building run-time libraries very easy. Many new
+  executables are distributed solely in ELF format. You definitely
+  want to say Y here.
+
+  Information about ELF is contained in the ELF HOWTO available via
+  FTP (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you find that after upgrading from Linux kernel 1.2 and saying Y
+  here, you still can't run any ELF binaries (they just crash), then
+  you'll have to install the newest ELF runtime libraries, including
+  ld.so (check the file Documentation/Changes for location and latest
+  version).
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called binfmt_elf.o. Saying M or N here is dangerous because some
+  crucial programs on your system might be in ELF format.
+
+Kernel support for A.OUT binaries
+CONFIG_BINFMT_AOUT
+  A.out (Assembler.OUTput) is a set of formats for libraries and
+  executables used in the earliest versions of UNIX. Linux used the
+  a.out formats QMAGIC and ZMAGIC until they were replaced with the
+  ELF format.
+
+  As more and more programs are converted to ELF, the use for a.out
+  will gradually diminish. If you disable this option it will reduce
+  your kernel by one page. This is not much and by itself does not
+  warrant removing support. However its removal is a good idea if you
+  wish to ensure that absolutely none of your programs will use this
+  older executable format. If you don't know what to answer at this
+  point then answer Y. If someone told you "You need a kernel with
+  QMAGIC support" then you'll have to say Y here. You may answer M to
+  compile a.out support as a module and later load the module when you
+  want to use a program or library in a.out format. The module will be
+  called binfmt_aout.o. Saying M or N here is dangerous though,
+  because some crucial programs on your system might still be in A.OUT
+  format.
+
+Kernel support for JAVA binaries (obsolete)
+CONFIG_BINFMT_JAVA
+  JAVA(tm) is an object oriented programming language developed by
+  SUN; JAVA programs are compiled into "JAVA bytecode" binaries which
+  can then be interpreted by run time systems on many different
+  architectures and operating systems. These JAVA binaries are
+  becoming a universal executable format.
+
+  If you want to execute JAVA binaries, read the Java on Linux HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You will then need to
+  install the run time system contained in the Java Developers Kit
+  (JDK) as described in the HOWTO. This is completely independent of
+  the Linux kernel and you do NOT need to say Y here for this to work.
+
+  Saying Y here allows you to execute a JAVA bytecode binary just like
+  any other Linux program: by simply typing in its name. (You also
+  need to have the JDK installed for this to work). As more and more
+  Java programs become available, the use for this will gradually
+  increase. You can even execute HTML files containing JAVA applets
+  (little embedded JAVA binaries) if those files start with the string
+  "<!--applet-->". If you want to use this, say Y here and read
+  Documentation/java.txt.
+
+  If you disable this option it will reduce your kernel by about 4 KB.
+  This is not much and by itself does not warrant removing support.
+  However its removal is a good idea if you do not have the JDK
+  installed. You may answer M for module support and later load the
+  module when you install the JDK or find an interesting Java program
+  that you can't live without. The module will be called
+  binfmt_java.o.
+
+  The complete functionality of this Java support is also provided by
+  the more general option "Kernel support for MISC binaries",
+  below. This option is therefore considered obsolete and you should
+  say N here and Y to "Kernel support for MISC binaries" if you're 
+  interested in transparently executing Java programs.
+
+Kernel support for Linux/Intel ELF binaries
+CONFIG_BINFMT_EM86
+  Say Y here if you want to be able to execute Linux/Intel ELF
+  binaries just like native Alpha binaries on your Alpha machine. For
+  this to work, you need to have the emulator /usr/bin/em86 in place.
+  You may answer M to compile the emulation support as a module and
+  later load the module when you want to use a Linux/Intel binary. The
+  module will be called binfmt_em86.o. If unsure, say Y.
+
+Kernel support for MISC binaries
+CONFIG_BINFMT_MISC
+  If you say Y here, it will be possible to plug wrapper-driven binary
+  formats into the kernel. You will like this especially when you use
+  programs that need an interpreter to run like Java, Python or
+  Emacs-Lisp. It's also useful if you often run DOS executables under
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO). Once you have
+  registered such a binary class with the kernel, you can start one of
+  those programs simply by typing in its name at a shell prompt; Linux
+  will automatically feed it to the correct interpreter.
+
+  If you say Y here, you won't need "Kernel support for JAVA binaries"
+  (CONFIG_BINFMT_JAVA) or "Kernel support for Linux/Intel ELF
+  binaries" (CONFIG_BINFMT_EM86), as this is a more general solution.
+
+  You can do other nice things, too. Read
+  Documentation/binfmt_misc.txt to learn how to use this feature, and
+  Documentation/java.txt for information about how to include Java
+  support.
+
+  You must say Y to "proc filesystem support" (CONFIG_PROC_FS) to
+  use this part of the kernel.
+
+  You may say M here for module support and later load the module when
+  you have use for it; the module is called binfmt_misc.o. If you
+  don't know what to answer at this point, say Y.
+
+Solaris binary emulation
+CONFIG_SOLARIS_EMUL
+  This is experimental code which will enable you to run (many)
+  Solaris binaries on your SPARC Linux machine. 
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called solaris.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Processor family
+CONFIG_M386
+  This is the processor type of your CPU. This information is used for
+  optimizing purposes. In order to compile a kernel that can run on
+  all x86 CPU types (albeit not optimally fast), you can specify
+  "386" here.
+
+  If you specify one of "486" or "586" or "Pentium" or "PPro", then
+  the kernel will not necessarily run on earlier architectures (e.g. a
+  Pentium optimized kernel will run on a PPro, but not necessarily on
+  a i486).
+
+  Here are the settings recommended for greatest speed:
+   - "386" for the AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI
+     486DLC/DLC2 and UMC 486SX-S. Only "386" kernels will run on a 386
+     class machine.
+   - "486" for the AMD/Cyrix/IBM/Intel DX4 or 486DX/DX2/SL/SX/SX2,
+     AMD/Cyrix 5x86, NexGen Nx586 and UMC U5D or U5S.
+   - "586" for generic Pentium CPUs, possibly lacking the TSC 
+     (time stamp counter) register.
+   - "Pentium" for the Intel Pentium/Pentium MMX, AMD K5, K6 and 
+     K6-3D.
+   - "PPro" for the Cyrix/IBM/National Semiconductor 6x86MX, MII and
+     Intel Pentium II/Pentium Pro.
+
+  If you don't know what to do, choose "386".
+
+VGA text console
+CONFIG_VGA_CONSOLE
+  Saying Y here will allow you to use Linux in text mode through a
+  display that complies with the generic VGA standard. Virtually
+  everyone wants that. 
+
+  The program SVGATextMode can be used to utilize SVGA video cards to
+  their full potential in text mode. Download it via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/utils/console.
+
+  Say Y.
+
+Video mode selection support
+CONFIG_VIDEO_SELECT
+  This enables support for text mode selection on kernel startup. If
+  you want to take advantage of some high-resolution text mode your
+  card's BIOS offers, but the traditional Linux utilities like
+  SVGATextMode don't, you can say Y here and set the mode using the
+  "vga=" option from your boot loader (lilo or loadlin) or set
+  "vga=ask" which brings up a video mode menu on kernel startup. Try
+  "man bootparam" or see the documentation of your boot loader about
+  how to pass options to the kernel. The lilo procedure is also
+  explained in the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Read
+  Documentation/svga.txt for more information about the Video mode
+  selection support. If unsure, say N.
+
+Support for frame buffer devices (EXPERIMENTAL)
+CONFIG_FB
+  The frame buffer device provides an abstraction for the graphics
+  hardware. It represents the frame buffer of some video hardware and
+  allows application software to access the graphics hardware through
+  a well-defined interface, so the software doesn't need to know
+  anything about the low-level (hardware register) stuff. 
+
+  Frame buffer devices work identically across the different
+  architectures supported by Linux and make the implementation of
+  application programs easier and more portable; at this point, an X
+  server exists which uses the frame buffer device exclusively.
+  On several non-X86 architectures, the frame buffer device is the
+  only way to use the graphics hardware.
+ 
+  The device is accessed through special device nodes, usually located
+  in the /dev directory, i.e. /dev/fb*.
+
+  You need an utility program called fbset to make full use of frame
+  buffer devices. Please read Documentation/fb/framebuffer.txt and the
+  Framebuffer-HOWTO at
+  http://www.tahallah.demon.co.uk/programming/prog.html for more
+  information.
+
+  Say Y here and to the driver for your graphics board below if you
+  are compiling a kernel for a non-x86 architecture.
+
+  If you are compiling for the x86 architecture, you can say Y if you
+  want to play with it, but it is not essential. Please note that
+  running graphical applications that directly touch the hardware
+  (e.g. an accelerated X server) and that are not frame buffer
+  device-aware may cause unexpected results. If unsure, say N.
+
+Acorn VIDC support
+CONFIG_FB_ACORN
+  This is the frame buffer device driver for the Acorn VIDC graphics
+  chipset.
+
+Apollo frame buffer device
+CONFIG_FB_APOLLO
+  This is the frame buffer device driver for the monochrome graphics
+  hardware found in some Apollo workstations.
+
+Amiga native chipset support
+CONFIG_FB_AMIGA
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Amigas.
+
+Amiga OCS chipset support
+CONFIG_FB_AMIGA_OCS
+  This enables support for the original Agnus and Denise video chips,
+  found in the Amiga 1000 and most A500's and A2000's. If you intend
+  to run Linux on any of these systems, say Y; otherwise say N.
+
+Amiga ECS chipset support
+CONFIG_FB_AMIGA_ECS
+  This enables support for the Enhanced Chip Set, found in later
+  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
+  you intend to run Linux on any of these systems, say Y; otherwise
+  say N.
+
+Amiga AGA chipset support
+CONFIG_FB_AMIGA_AGA
+  This enables support for the Advanced Graphics Architecture (also
+  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
+  and CD32. If you intend to run Linux on any of these systems, say Y;
+  otherwise say N.
+
+Amiga CyberVision support
+CONFIG_FB_CYBER
+  This enables support for the Cybervision 64 graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64 or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the
+  Cybervision 64 3D card, as they use incompatible video chips.
+
+Amiga CyberVision3D support (EXPERIMENTAL)
+CONFIG_FB_VIRGE
+  This enables support for the Cybervision 64/3D graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64/3D or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the older
+  Cybervision 64 card, as they use incompatible video chips.
+
+Amiga RetinaZ3 support (EXPERIMENTAL)
+CONFIG_FB_RETINAZ3
+  This enables support for the Retina Z3 graphics card. Say N unless
+  you have a Retina Z3 or plan to get one before you next recompile
+  the kernel.
+
+Amiga CLgen driver (EXPERIMENTAL)
+CONFIG_FB_CLGEN
+  This enables support for Cirrus Logic GD542x/543x based boards on
+  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.
+  Say N unless you have such a graphics board or plan to get one
+  before you next recompile the kernel.
+
+Apollo support
+CONFIG_APOLLO
+  Say Y here if you want to run Linux on an MC680x0-based Apollo
+  Domain workstation such as the DN3500.
+
+Apollo 3c505 support
+CONFIG_APOLLO_ELPLUS
+  Say Y or M here if your Apollo has a 3Com 3c505 ISA Ethernet card.
+  If you don't have one made for Apollos, you can use one from a PC,
+  except that your Apollo won't be able to boot from it (because the
+  code in the ROM will be for a PC).
+
+Atari native chipset support
+CONFIG_FB_ATARI
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Ataris.
+
+Open Firmware frame buffer device support 
+CONFIG_FB_OF
+  Say Y if you want support with Open Firmware for your graphics
+  board.
+
+S3 Trio frame buffer device support 
+CONFIG_FB_S3TRIO
+  If you have a S3 Trio say Y. Say N for S3 Virge. 
+
+ATI Mach64 display support
+CONFIG_FB_ATY
+  This driver supports graphics boards with the ATI Mach64 chips.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called atyfb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+ATI Rage128 display support (EXPERIMENTAL)
+CONFIG_FB_ATY128
+  This driver supports graphics boards with the ATI Rage128 chips.
+  Say Y if you have such a graphics board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called aty128fb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PowerMac "control" frame buffer device support
+CONFIG_FB_CONTROL
+  This driver supports a frame buffer for the graphics adapter in the
+  Power Macintosh 7300 and others.
+
+PowerMac "platinum" frame buffer device support
+CONFIG_FB_PLATINUM
+  This driver supports a frame buffer for the "platinum" graphics
+  adapter in some Power Macintoshes.
+
+PowerMac "valkyrie" frame buffer device support
+CONFIG_FB_VALKYRIE
+  This driver supports a frame buffer for the "valkyrie" graphics
+  adapter found in some Power Macintoshes, as well as the 580 and 630
+  series 68k Macintoshes.
+
+Chips 65550 display support
+CONFIG_FB_CT65550
+  This is the frame buffer device driver for the Chips & Technologies
+  65550 graphics chip in PowerBooks.
+
+Mac frame buffer device
+CONFIG_FB_MAC
+  This is the a generic frame buffer device driver for the graphics
+  hardware in m68k Macintoshes.  It can only use the video mode set
+  by MacOS at boot time.  You should probably say Y here.
+
+HP300 frame buffer device
+CONFIG_FB_HP300
+  This is the frame buffer device driver for the Topcat graphics
+  hardware found in HP300 workstations.
+
+TGA frame buffer support
+CONFIG_FB_TGA
+  This is the frame buffer device driver for generic TGA graphic
+  cards. Say Y if you have one of those.
+
+VESA VGA graphics console
+CONFIG_FB_VESA
+  This is the frame buffer device driver for generic VESA 2.0
+  compliant graphic cards. The older VESA 1.2 cards are not supported.
+  You will get a boot time penguin logo at no additional cost. Please
+  read Documentation/fb/vesafb.txt. If unsure, say Y.
+
+VGA 16-color graphics console
+CONFIG_FB_VGA16
+  This is the frame buffer device driver for VGA 16 color graphic
+  cards. Say Y if you have such a card.
+
+Backward compatibility mode for Xpmac
+CONFIG_FB_COMPAT_XPMAC
+  If you use the Xpmac X server (common with mklinux), you'll need to
+  say Y here to use X. You should consider changing to XFree86 which
+  includes a server that supports the frame buffer device directly
+  (XF68_FBDev).
+
+Matrox unified accelerated driver
+CONFIG_FB_MATROX
+  Say Y here if you have Matrox Millennium, Matrox Millennium II,
+  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
+  Mystique G200, Matrox Millennium G200 or Matrox Marvel G200 video
+  card in your box. At this time, support for the G100, Mystique G200
+  and Marvel G200 is untested.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called matroxfb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  You can pass several parameters to the driver at boot time or at
+  module load time. The parameters look like "video=matrox:XXX", where
+  the meaning of XXX can be found at the end of the main source file
+  (drivers/video/matroxfb.c). Please see the file
+  Documentation/fb/matroxfb.txt. 
+
+Matrox Millennium support
+CONFIG_FB_MATROX_MILLENIUM
+  Say Y here if you have a Matrox Millennium or Matrox Millennium II
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
+  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
+  also use font widths different from 8.
+
+Matrox Mystique support
+CONFIG_FB_MATROX_MYSTIQUE
+  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
+  packed pixel and 32 bpp packed pixel. You can also use font widths
+  different from 8.
+
+Matrox G100/G200 support
+CONFIG_FB_MATROX_G100
+  Say Y here if you have a Matrox Productiva G100, Matrox Mystique
+  G200, Matrox Marvel G200 or Matrox Millennium G200 video card. If
+  you select "Advanced lowlevel driver options", you should check 8
+  bpp packed pixel, 16 bpp packed pixel, 24 bpp packed pixel and 32
+  bpp packed pixel. You can also use font widths different from 8.
+
+Matrox unified driver multihead support
+CONFIG_FB_MATROX_MULTIHEAD
+  Say Y here if you have more than one (supported) Matrox device in
+  your computer and you want to use all of them. If you have only one
+  device, you should say N because the driver compiled with Y is
+  larger and a bit slower, especially on ia32 (ix86). 
+
+  If you said M to "Matrox unified accelerated driver" and N here, you
+  will still be able to use several Matrox devices simultaneously.
+  This is slightly faster but uses 40 KB of kernel memory per Matrox
+  card. You do this by inserting several instances of the module 
+  matroxfb.o into the kernel with insmod, supplying the parameter
+  "dev=N" where N is 0, 1, etc. for the different Matrox devices.
+
+MDA text console (dual-headed)
+CONFIG_MDA_CONSOLE
+  Say Y here if you have an old MDA or monochrome Hercules graphics
+  adapter in your system acting as a second head ( = video card). You
+  will then be able to use two monitors with your Linux system. Do not
+  say Y here if your MDA card is the primary card in your system; the
+  normal VGA driver will handle it.
+  
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called mdacon.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+SBUS and UPA frame buffers
+CONFIG_FB_SBUS
+  Say Y if you want support for SBUS or UPA based frame buffer device.
+
+Creator/Creator3D support
+CONFIG_FB_CREATOR
+  This is the frame buffer device driver for the Creator and Creator3D
+  graphics boards.
+
+CGsix (GX,TurboGX) support
+CONFIG_FB_CGSIX
+  This is the frame buffer device driver for the CGsix (GX, TurboGX)
+  frame buffer.
+
+BWtwo support
+CONFIG_FB_BWTWO
+  This is the frame buffer device driver for the BWtwo frame buffer.
+
+CGthree support
+CONFIG_FB_CGTHREE
+  This is the frame buffer device driver for the CGthree frame buffer.
+
+TCX (SS4/SS5 only) support
+CONFIG_FB_TCX
+  This is the frame buffer device driver for the TCX 24/8bit frame
+  buffer.
+
+Virtual Frame Buffer support (ONLY FOR TESTING!)
+CONFIG_FB_VIRTUAL
+  This is a `virtual' frame buffer device. It operates on a chunk of
+  unswapable kernel memory instead of on the memory of a graphics
+  board. This means you cannot see any output sent to this frame
+  buffer device, while it does consume precious memory. The main use
+  of this frame buffer device is testing and debugging the frame
+  buffer subsystem. Do NOT enable it for normal systems! To protect
+  the innocent, it has to be enabled explicitly at boot time using the
+  kernel option `video=vfb:'.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called vfb.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+ 
+  If unsure, say N.
+
+Advanced low level driver options
+CONFIG_FBCON_ADVANCED
+  The frame buffer console uses character drawing routines that are
+  tailored to the specific organization of pixels in the memory of
+  your graphics hardware. These are called the low level frame buffer
+  console drivers. Note that they are used for text console output
+  only; they are NOT needed for graphical applications.
+
+  If you say N here, the needed low level drivers are automatically
+  enabled, depending on what frame buffer devices you selected above.
+  This is recommended for most users.
+
+  If you say Y here, you have more fine-grained control over which low
+  level drivers are enabled. You can e.g. leave out low level drivers
+  for color depths you do not intend to use for text consoles.
+
+  Low level frame buffer console drivers can be modules ( = code which
+  can be inserted and removed from the running kernel whenever you
+  want). The modules will be called fbcon-*.o. If you want to compile
+  (some of) them as modules, read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+Monochrome support
+CONFIG_FBCON_MFB
+  This is the low level frame buffer console driver for monochrome
+  (2 colors) packed pixels.
+
+2 bpp packed pixels support
+CONFIG_FBCON_CFB2
+  This is the low level frame buffer console driver for 2 bits per
+  pixel (4 colors) packed pixels.
+
+4 bpp packed pixels support
+CONFIG_FBCON_CFB4
+  This is the low level frame buffer console driver for 4 bits per
+  pixel (16 colors) packed pixels.
+
+8 bpp packed pixels support
+CONFIG_FBCON_CFB8
+  This is the low level frame buffer console driver for 8 bits per
+  pixel (256 colors) packed pixels.
+
+16 bpp packed pixels support
+CONFIG_FBCON_CFB16
+  This is the low level frame buffer console driver for 15 or 16 bits
+  per pixel (32K or 64K colors, also known as `hicolor') packed
+  pixels.
+
+24 bpp packed pixels support
+CONFIG_FBCON_CFB24
+  This is the low level frame buffer console driver for 24 bits per
+  pixel (16M colors, also known as `truecolor') packed pixels. It is
+  NOT for `sparse' 32 bits per pixel mode.
+
+32 bpp packed pixels support
+CONFIG_FBCON_CFB32
+  This is the low level frame buffer console driver for 32 bits per
+  pixel (16M colors, also known as `truecolor') sparse packed pixels.
+
+Amiga bitplanes support
+CONFIG_FBCON_AFB
+  This is the low level frame buffer console driver for 1 to 8
+  bitplanes (2 to 256 colors) on Amiga.
+
+Amiga interleaved bitplanes support
+CONFIG_FBCON_ILBM
+  This is the low level frame buffer console driver for 1 to 8
+  interleaved bitplanes (2 to 256 colors) on Amiga.
+
+Atari interleaved bitplanes (2 planes) support
+CONFIG_FBCON_IPLAN2P2
+  This is the low level frame buffer console driver for 2 interleaved
+  bitplanes (4 colors) on Atari.
+
+Atari interleaved bitplanes (4 planes) support
+CONFIG_FBCON_IPLAN2P4
+  This is the low level frame buffer console driver for 4 interleaved
+  bitplanes (16 colors) on Atari.
+
+Atari interleaved bitplanes (8 planes) support
+CONFIG_FBCON_IPLAN2P8
+  This is the low level frame buffer console driver for 8 interleaved
+  bitplanes (256 colors) on Atari.
+
+Mac variable bpp packed pixels support
+CONFIG_FBCON_MAC
+  This is the low level frame buffer console driver for 1/2/4/8/16/32
+  bits per pixel packed pixels on Mac. It supports variable font
+  widths for low resolution screens.
+  
+VGA characters/attributes support
+CONFIG_FBCON_VGA
+  This is the low level frame buffer console driver for VGA text mode;
+  it is used if you said Y to "VGA chipset support (text only)" above.
+
+Parallel-port support
+CONFIG_PARPORT
+  If you want to use devices connected to your machine's parallel port
+  (the connector at the computer with 25 holes), e.g. printer, ZIP
+  drive, PLIP link (Parallel Line Internet Protocol is mainly used to
+  create a mini network by connecting the parallel ports of two local
+  machines) etc., then you need to say Y here; please read
+  Documentation/parport.txt and drivers/misc/BUGS-parport.
+
+  For extensive information about drivers for many devices attaching
+  to the parallel port see http://www.torque.net/linux-pp.html on the
+  WWW (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape).
+
+  It is possible to share a single parallel port among several devices
+  and it is safe to compile all the corresponding drivers into the
+  kernel. If you want to compile parallel port support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called parport.o. If you have more than one
+  parallel port and want to specify which port and IRQ to be used by
+  this driver at module load time, read
+  Documentation/networking/net-modules.txt.
+
+  If unsure, say Y.
+
+PC-style hardware 
+CONFIG_PARPORT_PC
+  You should say Y here if you have a PC-style parallel port. All IBM
+  PC compatible computers and some Alphas have PC-style parallel
+  ports. 
+
+  This code is also available as a module. If you want to compile it
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called parport_pc.o.
+  
+  If unsure, say Y.
+
+Support foreign hardware
+CONFIG_PARPORT_OTHER
+  Say Y here if you want to be able to load driver modules to support
+  other non-standard types of parallel ports. This causes a
+  performance loss, so most people say N.
+
+Sun Ultra/AX-style hardware 
+CONFIG_PARPORT_AX
+  Say Y here if you need support for the parallel port hardware on Sun
+  Ultra/AX machines. This code is also available as a module (say M),
+  called parport_ax.o. If in doubt, saying N is the safe plan.
+
+Plug and Play support
+CONFIG_PNP
+  Plug and Play support allows the kernel to automatically configure
+  some peripheral devices. Say Y to enable PnP.
+
+Auto-probe for parallel devices
+CONFIG_PNP_PARPORT
+  Some IEEE-1284 conforming parallel-port devices can identify
+  themselves when requested. Say Y to enable this feature, or M to
+  compile it as a module (parport_probe.o). If in doubt, say N.
+
+Enable loadable module support
+CONFIG_MODULES
+  Kernel modules are small pieces of compiled code which can be
+  inserted in or removed from the running kernel, using the programs
+  insmod and rmmod. This is described in the file
+  Documentation/modules.txt, including the fact that you have to say
+  "make modules" in order to compile the modules that you chose during
+  kernel configuration. Modules can be device drivers, file systems,
+  binary executable formats, and so on. If you think that you may want
+  to make use of modules with this kernel in the future, then say Y
+  here. If unsure, say Y.
+
+Set version information on all symbols for modules
+CONFIG_MODVERSIONS
+  Usually, modules have to be recompiled whenever you switch to a new
+  kernel. Saying Y here makes it possible, and safe, to use the
+  same modules even after compiling a new kernel; this requires the
+  program modprobe. All the software needed for module support is in
+  the modutils package (check the file Documentation/Changes for
+  location and latest version). NOTE: if you say Y here but don't
+  have the program genksyms (which is also contained in the above
+  mentioned modutils package), then the building of your kernel will
+  fail. If you are going to use modules that are generated from
+  non-kernel sources, you would benefit from this option. Otherwise
+  it's not that important. So, N ought to be a safe bet.
+
+Kernel module loader support
+CONFIG_KMOD
+  Normally when you have selected some drivers and/or filesystems to
+  be created as loadable modules, you also have the responsibility to
+  load the corresponding modules (using the programs insmod or
+  modprobe) before you can use them. If you say Y here however, the
+  kernel will be able to load modules for itself: when a part of the
+  kernel needs a module, it runs modprobe with the appropriate
+  arguments, thereby loading the module if it is available. (This is a
+  replacement for kerneld.) Say Y here and read about configuring it
+  in Documentation/kmod.txt.
+
+ARP daemon support (EXPERIMENTAL)
+CONFIG_ARPD
+  Normally, the kernel maintains an internal cache which maps IP 
+  addresses to hardware addresses on the local network, so that
+  Ethernet/Token Ring/ etc. frames are sent to the proper address on
+  the physical networking layer. For small networks having a few
+  hundred directly connected hosts or less, keeping this address
+  resolution (ARP) cache inside the kernel works well. However,
+  maintaining an internal ARP cache does not work well for very large
+  switched networks, and will use a lot of kernel memory if TCP/IP
+  connections are made to many machines on the network. 
+
+  If you say Y here, the kernel's internal ARP cache will never grow
+  to more than 256 entries (the oldest entries are expired in a LIFO
+  manner) and communication will be attempted with the user space ARP
+  daemon arpd. Arpd then answers the address resolution request either
+  from its own cache or by asking the net.
+
+  This code is experimental. If you do say Y here, you should obtain a
+  copy of arpd from http://www.loran.com/~layes/arpd/index.html, and
+  you should also say Y to "Kernel/User network link driver", below.
+  If unsure, say N.
+
+TCP/IP networking
+CONFIG_INET
+  These are the protocols used on the Internet and on most local
+  Ethernets. It is highly recommended to say Y here (this will enlarge
+  your kernel by about 35 KB), since some programs (e.g. the X window
+  system) use TCP/IP even if your machine is not connected to any
+  other computer. You will get the so-called loopback device which
+  allows you to ping yourself (great fun, that!).
+
+  For an excellent introduction to Linux networking, please read the
+  NET-3-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This option is also necessary if you want to use the full power of
+  term (term is a program which gives you almost full Internet
+  connectivity if you have a regular dial up shell account on some
+  Internet connected Unix computer; for more information, read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html).
+  
+  If you say Y here and also to "/proc filesystem support" and "Sysctl
+  support" below, you can change various aspects of the behavior of
+  the TCP/IP code by writing to the (virtual) files in
+  /proc/sys/net/ipv4/*; the options are explained in the file
+  Documentation/Networking/ip-sysctl.txt.
+
+  Short answer: say Y.
+
+IP: multicasting
+CONFIG_IP_MULTICAST
+  This is code for addressing several networked computers at once,
+  enlarging your kernel by about 2 kB. You need multicasting if you
+  intend to participate in the MBONE, a high bandwidth network on top
+  of the Internet which carries audio and video broadcasts. More
+  information about the MBONE is on the WWW at
+  http://www.best.com/~prince/techinfo/mbone.html (to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape). Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. For most people, it's safe
+  to say N.
+
+IP: advanced router
+CONFIG_IP_ADVANCED_ROUTER
+  If you intend to run your Linux box mostly as a router, i.e. as a
+  computer that forwards and redistributes network packets, say Y; you
+  will then be presented with several options that allow more precise
+  control about the routing process.
+
+  The answer to this question won't directly affect the kernel:
+  answering N will just cause this configure script to skip all the
+  questions about advanced routing.
+
+  Note that your box can only act as a router if you enable IP
+  forwarding in your kernel; you can do that by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and executing the
+  line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. 
+
+  If you turn on IP forwarding, you will also get the rp_filter, which
+  automatically rejects incoming packets if the routing table entry
+  for their source address doesn't match the network interface they're
+  arriving on. This has security advantages because it prevents the
+  so-called IP spoofing, however it can pose problems if you use
+  asymmetric routing (packets from you to a host take a different path
+  than packets from that host to you) or if you operate a non-routing
+  host which has several IP addresses on different interfaces. To turn
+  rp_filter off use:
+
+        echo 0 > /proc/sys/net/ipv4/conf/<device>/rp_filter
+  or
+        echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
+
+  If unsure, say N here.
+
+IP: policy routing
+CONFIG_IP_MULTIPLE_TABLES
+  Normally, a router decides what to do with a received packet based
+  solely on the packet's final destination address. If you say Y here,
+  the Linux router will also be able to take the packet's source
+  address into account. Furthermore, if you also say Y to "IP: use TOS
+  value as routing key" below, the TOS (Type-Of-Service) field of the
+  packet can be used for routing decisions as well. In addition, if
+  you say Y here and to "IP: fast network address translation" below,
+  the router will also be able to modify source and destination
+  addresses of forwarded packets.
+
+  If you are interested in this, please see the preliminary
+  documentation at http://www.compendium.com.ar/policy-routing.txt and
+  ftp://post.tepkom.ru/pub/vol2/Linux/docs/advanced-routing.tex. You
+  will need supporting software from ftp://ftp.inr.ac.ru/ip-routing/
+  
+  If unsure, say N.
+  
+IP: equal cost multipath
+CONFIG_IP_ROUTE_MULTIPATH
+  Normally, the routing tables specify a single action to be taken in
+  a deterministic manner for a given packet. If you say Y here
+  however, it becomes possible to attach several actions to a packet
+  pattern, in effect specifying several alternative paths to travel
+  for those packets. The router considers all these paths to be of
+  equal "cost" and chooses one of them in a non-deterministic fashion
+  if a matching packet arrives.
+
+IP: use TOS value as routing key
+CONFIG_IP_ROUTE_TOS
+  The header of every IP packet carries a TOS (Type of Service) value
+  with which the packet requests a certain treatment, e.g. low latency
+  (for interactive traffic), high throughput, or high reliability. If
+  you say Y here, you will be able to specify different routes for
+  packets with different TOS values.
+
+IP: use FWMARK value as routing key
+CONFIG_IP_ROUTE_FWMARK
+  If you say Y here, you will be able to specify different routes for
+  packets with different FWMARK ("firewalling mark") values
+  (see ipchains(8), "-m" argument).
+
+IP: verbose route monitoring
+CONFIG_IP_ROUTE_VERBOSE
+  If you say Y here, which is recommended, then the kernel will print
+  verbose messages regarding the routing, for example warnings about
+  received packets which look strange and could be evidence of an
+  attack or a misconfigured system somewhere. The information is
+  handled by the klogd daemon which is responsible for kernel messages
+  ("man klogd").
+
+IP: large routing tables
+CONFIG_IP_ROUTE_LARGE_TABLES
+  If you have routing zones that grow to more than about 64 entries,
+  you may want to say Y here to speed up the routing process.
+
+IP: fast network address translation
+CONFIG_IP_ROUTE_NAT
+  If you say Y here, your router will be able to modify source and
+  destination addresses of packets that pass through it, in a manner
+  you specify. General information about Network Address Translation
+  can be gotten from the document
+  http://www.csn.tu-chemnitz.de/~mha/linux-ip-nat/diplom/nat.html
+
+IP: optimize as router not host
+CONFIG_IP_ROUTER
+  Some Linux network drivers use a technique called copy and checksum
+  to optimize host performance. For a machine which acts as a router
+  most of the time and is forwarding most packets to another host this
+  is however a loss. If you say Y here, copy and checksum will be
+  switched off. In the future, it may make other changes which
+  optimize for router operation.
+
+  Note that your box can only act as a router if you enable IP
+  forwarding in your kernel; you can do that by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and executing the
+  line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. You can do
+  that even if you say N here.
+
+  If unsure, say N here.
+
+IP: firewalling
+CONFIG_IP_FIREWALL
+  If you want to configure your Linux box as a packet filter firewall
+  for a local TCP/IP based network, say Y here. You may want to read
+  the FIREWALL-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Also, you will need the ipchains tool (available on the WWW at
+  http://netfilter.kernelnotes.org/ipchains/) to allow selective blocking
+  of Internet traffic based on type, origin and destination. 
+  Note that the Linux firewall code has changed and the old program
+  called ipfwadm won't work anymore. Please read the IPCHAINS-HOWTO.
+
+  The type of firewall provided by ipchains and this kernel support is
+  called a "packet filter". The other type of firewall, a
+  "proxy-based" one, is more secure but more intrusive and more
+  bothersome to set up; it inspects the network traffic much more
+  closely, modifies it and has knowledge about the higher level
+  protocols, which a packet filter lacks. Moreover, proxy-based
+  firewalls often require changes to the programs running on the local
+  clients. Proxy-based firewalls don't need support by the kernel, but
+  they are often combined with a packet filter, which only works if
+  you say Y here.
+
+  The firewalling code will only work if IP forwarding is enabled in
+  your kernel. You can do that by saying Y to "/proc filesystem
+  support" and "Sysctl support" below and executing the line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc filesystem has been mounted. 
+
+  You need to say Y to "IP firewalling" in order to be able to use IP
+  masquerading (masquerading means that local computers can chat with
+  an outside host, but that outside host is made to think that it is
+  talking to the firewall box -- makes the local network completely
+  invisible to the outside world and avoids the need to allocate
+  globally valid IP host addresses for the machines on the local net)
+  and IP packet logging and accounting (keeping track of what is using
+  all your network bandwidth) and IP transparent proxying (makes the
+  computers on the local network think they're talking to a remote
+  computer, while in reality the traffic is redirected by your Linux
+  firewall to a local proxy server).
+
+  If in doubt, say N here.
+
+IP: firewall packet netlink device
+CONFIG_IP_FIREWALL_NETLINK
+  If you say Y here, you can use the ipchains tool to copy all or part
+  of any packet you specify that hits your Linux firewall to optional
+  user space monitoring software that can then look for attacks and
+  take actions such as paging the administrator of the site.
+
+  To use this, you need to create a character special file under /dev
+  with major number 36 and minor number 3 using mknod ("man mknod"),
+  and you need (to write) a program that reads from that device and
+  takes appropriate action.
+
+IP: kernel level autoconfiguration
+CONFIG_IP_PNP
+  This enables automatic configuration of IP addresses of devices and
+  of the routing table during kernel boot, based on either information
+  supplied at the kernel command line or by BOOTP or RARP protocols.
+  You need to say Y only for diskless machines requiring network
+  access to boot (in which case you want to say Y to "Root file system
+  on NFS" as well), because all other machines configure the network
+  in their startup scripts.
+
+BOOTP support
+CONFIG_IP_PNP_BOOTP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the BOOTP protocol (a
+  special protocol designed for doing this job), say Y here. In case
+  the boot ROM of your network card was designed for booting Linux and
+  does BOOTP itself, providing all necessary information on the kernel
+  command line, you can say N here.
+
+  If unsure, say Y. Note that if you want to use BOOTP, a BOOTP server
+  must be operating on your network.  Read Documentation/nfsroot.txt
+  for details.
+
+DHCP support
+CONFIG_IP_PNP_DHCP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the DHCP protocol (a
+  special protocol designed for doing this job), say Y here. In case
+  the boot ROM of your network card was designed for booting Linux and
+  does DHCP itself, providing all necessary information on the kernel
+  command line, you can say N here.
+
+  If unsure, say Y. Note that if you want to use DHCP, a DHCP server
+  must be operating on your network.  Read Documentation/nfsroot.txt
+  for details.
+
+RARP support
+CONFIG_IP_PNP_RARP
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the RARP protocol (an
+  older protocol which is being obsoleted by BOOTP and DHCP), say Y
+  here. Note that if you want to use RARP, a RARP server must be
+  operating on your network. Read Documentation/nfsroot.txt for
+  details.
+
+IP: tunneling
+CONFIG_NET_IPIP
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  encapsulation of IP within IP, which sounds kind of pointless, but
+  can be useful if you want to make your (or some other) machine
+  appear on a different network than it physically is, or to use
+  mobile-IP facilities (allowing laptops to seamlessly move between
+  networks without changing their IP addresses; check out
+  http://anchor.cs.binghamton.edu/~mobileip/LJ/index.html). 
+
+  Saying Y to this option will produce two modules ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). Most people won't need this and can say N.
+
+IP: GRE tunnels over IP
+CONFIG_NET_IPGRE
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  GRE (Generic Routing Encapsulation) and at this time allows
+  encapsulating of IPv4 or IPv6 over existing IPv4 infrastructure.
+  This driver is useful if the other endpoint is a Cisco router: Cisco
+  likes GRE much better than the other Linux tunneling driver ("IP:
+  tunneling" above). In addition, GRE allows multicast redistribution
+  through the tunnel.
+
+IP: broadcast GRE over IP
+CONFIG_NET_IPGRE_BROADCAST
+  One application of GRE/IP is to construct a broadcast WAN (Wide Area
+  Network), which looks like a normal Ethernet LAN (Local Area
+  Network), but can be distributed all over the Internet. If you want
+  to do that, say Y here and to "IP: multicast routing" below.
+
+IP: transparent proxying
+CONFIG_IP_TRANSPARENT_PROXY
+  This enables your Linux firewall to transparently redirect any
+  network traffic originating from the local network and destined
+  for a remote host to a local server, called a "transparent proxy
+  server". This makes the local computers think they are talking to
+  the remote end, while in fact they are connected to the local
+  proxy. Redirection is activated by defining special input firewall
+  rules (using the ipchains utility) and/or by doing an appropriate
+  bind() system call.
+
+IP: masquerading
+CONFIG_IP_MASQUERADE
+  If one of the computers on your local network for which your Linux
+  box acts as a firewall wants to send something to the outside, your
+  box can "masquerade" as that computer, i.e. it forwards the traffic
+  to the intended outside destination, but makes it look like it came
+  from the firewall box itself. It works both ways: if the outside
+  host replies, the Linux firewall will silently forward the traffic
+  to the corresponding local computer. This way, the computers on your
+  local net are completely invisible to the outside world, even though
+  they can reach the outside and can receive replies. This makes it
+  possible to have the computers on the local network participate on
+  the Internet even if they don't have officially registered IP
+  addresses. (This last problem can also be solved by connecting the
+  Linux box to the Internet using SLiRP [SLiRP is a SLIP/PPP emulator
+  that works if you have a regular dial up shell account on some UNIX
+  computer; get it via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ].) 
+
+  The IP masquerading code will only work if IP forwarding is enabled
+  in your kernel; you can do this by saying Y to "/proc
+  filesystem support" and "Sysctl support" below and then executing a
+  line like
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  from a boot time script after the /proc filesystem has been mounted.
+
+  Enabling masquerading automagically enables ip_always_defrag too.
+
+  Details on how to set things up are contained in the IP Masquerade
+  mini-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini; there's also some
+  information on the WWW at
+  http://www.tor.shaw.wave.ca/~ambrose/kernel21.html. 
+
+  If you say Y here, then the modules ip_masq_ftp.o (for ftp file
+  transfers), ip_masq_irc.o (for irc chats), ip_masq_quake.o (you
+  guessed it), ip_masq_vdolive.o (for VDOLive video connections),
+  ip_masq_cuseeme.o (for CU-SeeMe broadcasts) and ip_masq_raudio.o
+  (for RealAudio downloads) will automatically be compiled. They are
+  needed to make masquerading for these protocols work. Modules are
+  pieces of code which can be inserted in and removed from the running
+  kernel whenever you want; read Documentation/modules.txt for
+  details.
+
+IP: UDP masquerading loose checking
+CONFIG_IP_MASQUERADE_UDP_LOOSE
+  Whether UDP masquerading does address checking in a loose fashion.
+
+  If you say Y here, then UDP masqueraded connections will allow
+  any external system to be connect back through the firewall to the
+  port on the internal machine.  However it will allow the more
+  efficient use of masqueraded ports, and may be required for some
+  gaming uses.
+
+  You should only say Y here if you understand the consequences since
+  it will open your internal network to external probing and potential
+  attacks.  In all other cases choose N
+
+IP: ICMP masquerading
+CONFIG_IP_MASQUERADE_ICMP
+  The basic masquerade code described for "IP: masquerading" above
+  only handles TCP or UDP packets (and ICMP errors for existing
+  connections). This option adds additional support for masquerading
+  ICMP packets, such as ping or the probes used by the Windows 95
+  tracert program.
+
+  If you want this, say Y. 
+
+IP: masquerading special modules support
+CONFIG_IP_MASQUERADE_MOD
+  This provides support for special modules that can modify the
+  rewriting rules used when masquerading. Please note that this
+  feature adds a little overhead in the input packet processing chain.
+
+  Examples of such modules are ipautofw (allowing the masquerading of
+  protocols which don't have their own protocol helpers) and port
+  forwarding (making an incoming port of a local computer visible
+  through the masquerading host).
+
+  You will need the user space program "ipmasqadm" to use these
+  additional modules; you can download it from
+  http://juanjox.kernelnotes.org/
+
+  All this additional code is still under development and so is
+  currently marked EXPERIMENTAL.
+  
+  If you want to try, for example, PORT FORWARDING, say Y.
+
+IP: ipautofw masquerade support (Experimental)
+CONFIG_IP_MASQUERADE_IPAUTOFW
+  ipautofw is a program which allows the masquerading of protocols
+  which do not (as yet) have their own protocol helpers. Information
+  and source for ipautofw is available via FTP (user: anonymous) from
+  ftp://ftp.netis.com/pub/members/rlynch/
+
+  You will also need the ipmasqadm tool available from
+  http://juanjox.kernelnotes.org/ .
+
+  The ipautofw code is still under development and so is currently
+  marked EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_autofw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: ipportfw masquerade support
+CONFIG_IP_MASQUERADE_IPPORTFW
+  Port Forwarding is an addition to IP Masquerading which allows some
+  forwarding of packets from outside to inside a firewall on given
+  ports. This could be useful if, for example, you want to run a web
+  server behind the firewall or masquerading host and that web server
+  should be accessible from the outside world. An external client
+  sends a request to port 80 of the firewall, the firewall forwards
+  this request to the web server, the web server handles the request
+  and the results are sent through the firewall to the original
+  client. The client thinks that the firewall machine itself is
+  running the web server. This can also be used for load balancing if
+  you have a farm of identical web servers behind the firewall.
+
+  Information about this feature is available from
+  http://www.monmouth.demon.co.uk/ipsubs/portforwarding.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). For general info, please
+  see ftp://ftp.compsoc.net/users/steve/ipportfw/linux21/
+
+  You will need the user space program "ipmasqadm" which can be
+  downloaded from http://juanjox.kernelnotes.org/
+
+  The portfw code is still under development and so is currently
+  marked EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_portfw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: ipmarkfw masquerade support
+CONFIG_IP_MASQUERADE_MFW
+  Firewall Mark Forwarding provides functionality similar to port
+  forwarding (see "IP: ipportfw masquerade support", above), the
+  difference being that Firewall Mark Forwarding uses "firewalling
+  mark" to select which packets must be forwarded (see ipchains(8),
+  "-m" argument).
+
+  This code is still under development and so is currently marked
+  EXPERIMENTAL. If you want to try it, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ip_masq_markfw.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+IP: aliasing support
+CONFIG_IP_ALIAS
+  Sometimes it is useful to give several IP addresses to a single
+  physical network interface (serial port or Ethernet card). The most
+  common case is that you want to serve different WWW or ftp documents
+  to the outside depending on which of your host names was used to
+  connect to you. This is called "multihosting" or "virtual domains"
+  or "virtual hosting services" and is explained in detail on the WWW
+  at http://www.thesphere.com/~dlp/TwoServers/ (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape) and also in the Virtual-Services-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Another scenario would be that there are two logical networks living
+  on your local Ethernet and you want to access them both with the
+  same Ethernet card. This can also be done if you say Y here.
+
+  The configuration of these alias addresses is done with a special
+  name syntax explained in Documentation/networking/alias.txt and in
+  the IP-Alias mini-HOWTO. If you want this, say Y. Most people don't
+  need it and say N.
+
+IP: multicast routing
+CONFIG_IP_MROUTE
+  This is used if you want your machine to act as a router for IP
+  packets that have several destination addresses. It is needed on the
+  MBONE, a high bandwidth network on top of the Internet which carries
+  audio and video broadcasts. In order to do that, you would most
+  likely run the program mrouted. Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. If you haven't heard about
+  it, you don't need it.
+
+IP: PIM-SM version 1 support
+CONFIG_IP_PIMSM_V1
+  Kernel side support for Sparse Mode PIM (Protocol Independent
+  Multicast) version 1. This multicast routing protocol is used widely
+  because Cisco supports it. You need special software to use it
+  (pimd-v1). Please see http://netweb.usc.edu/pim/ for more
+  information about PIM (to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or
+  netscape). 
+
+  Say Y if you want to use PIM-SM v1. Note that you can say N here if
+  you just want to use Dense Mode PIM.
+
+IP: PIM-SM version 2 support
+CONFIG_IP_PIMSM_V2
+  Kernel side support for Sparse Mode PIM version 2. In order to use
+  this, you need an experimental routing daemon supporting it (pimd or
+  gated-5). This routing protocol is not used widely, so say N unless
+  you want to play with it.
+
+PC/TCP compatibility mode
+CONFIG_INET_PCTCP
+  If you have been having difficulties telnetting to your Linux
+  machine from a DOS system that uses (broken) PC/TCP networking
+  software (all versions up to OnNet 2.0) over your local Ethernet try
+  saying Y here. Everyone else says N. 
+
+  People having problems with NCSA telnet should see the file
+  linux/Documentation/networking/ncsa-telnet.
+
+Reverse ARP server
+CONFIG_INET_RARP
+  If there are (usually diskless or portable) machines on your local
+  network that know their hardware Ethernet addresses but don't know
+  their IP addresses upon startup, they can send out a Reverse Address
+  Resolution Protocol (RARP) request to find out their own IP
+  addresses. Diskless Sun 3 machines use this procedure at boot time,
+  and diskless Linux boxes can be configured to do it as well.
+  
+  If you want your Linux box to be able to *answer* such requests,
+  answer Y here; you'll then have to run the program rarp ("man rarp")
+  on your box.
+
+  If you actually want to use a diskless Sun 3 machine as an X
+  terminal to Linux, say Y here and fetch Linux-Xkernel from
+  ftp://metalab.unc.edu/pub/Linux/system/network/boot.net/.
+
+  Superior solutions to the problem of booting and configuring
+  machines over a net connection are given by the protocol BOOTP and
+  its successor DHCP. See the DHCP FAQ
+  http://web.syr.edu/~jmwobus/comfaqs/dhcp.faq.html for details (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape).
+
+  If you want to compile RARP support as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called rarp.o. 
+
+  If you don't understand a word of the above, say N and rest in
+  peace.
+
+Assume subnets are local
+CONFIG_INET_SNARL
+  Say Y if you are on a subnetted network with all machines connected
+  by Ethernet segments only, as this option optimizes network access
+  for this special case. If there are other connections, e.g. SLIP
+  links, between machines of your IP network, say N. If in doubt,
+  answer N. The PATH mtu discovery facility will cover most cases
+  anyway.
+
+Path MTU Discovery (normally enabled)
+CONFIG_PATH_MTU_DISCOVERY
+  MTU (maximal transfer unit) is the size of the chunks we send out
+  over the net. "Path MTU Discovery" means that, instead of always
+  sending very small chunks, we start out sending big ones and if we
+  then discover that some host along the way likes its chunks smaller,
+  we adjust to a smaller size. This is good, so most people say Y
+  here.
+
+  However, some DOS software (versions of DOS NCSA telnet and Trumpet
+  Winsock in PPP mode) is broken and won't be able to connect to your
+  Linux machine correctly in all cases (especially through a terminal
+  server) unless you say N here. See
+  Documentation/networking/ncsa-telnet for the location of fixed NCSA
+  telnet clients. If in doubt, say Y.
+
+Disable NAGLE algorithm (normally enabled)
+CONFIG_TCP_NAGLE_OFF
+  The NAGLE algorithm works by requiring an acknowledgment before
+  sending small IP frames (packets). This keeps tiny telnet and
+  rlogin packets from congesting Wide Area Networks. Most people
+  strongly recommend to say N here, thereby leaving NAGLE
+  enabled. Those programs that would benefit from disabling this
+  facility can do it on a per connection basis themselves.
+
+IP: Allow large windows (not recommended if <16 MB of memory)
+CONFIG_SKB_LARGE
+  On high speed, long distance networks the performance limit on
+  networking becomes the amount of data the sending machine can buffer
+  until the other end confirms its reception. (At 45 Mbit/second there
+  are a lot of bits between New York and London ...). If you say Y
+  here, bigger buffers can be used which allows larger amounts of data
+  to be "in flight" at any given time. It also means a user process
+  can require a lot more memory for network buffers and thus this
+  option is best used only on machines with 16 MB of memory or higher.
+  Unless you are using long links with end to end speeds of over 2
+  Mbit a second or satellite links this option will make no difference
+  to performance.
+
+Unix domain sockets
+CONFIG_UNIX
+  If you say Y here, you will include support for Unix domain sockets;
+  sockets are the standard Unix mechanism for establishing and
+  accessing network connections. Many commonly used programs such as
+  the X Window system and syslog use these sockets even if your
+  machine is not connected to any network. Unless you are working on
+  an embedded system or something similar, you therefore definitely
+  want to say Y here.
+
+  However, the socket support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  unix.o. If you try building this as a module and you have said Y to
+  "Kernel module loader support" above, be sure to add 'alias net-pf-1
+  unix' to your /etc/conf.modules file. Note that several important
+  services won't work correctly if you say M here and then neglect to
+  load the module.
+
+  Say Y unless you know what you are doing.
+
+The IPv6 protocol
+CONFIG_IPV6
+  This is experimental support for the next version of the Internet
+  Protocol: IP version 6 (also called IPng "IP next generation"). 
+  Features of this new protocol include: expanded address space,
+  authentication and privacy, and seamless interoperability with the
+  current version of IP (IP version 4). For general information about
+  IPv6, see http://playground.sun.com/pub/ipng/html/ipng-main.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape); for specific information
+  about IPv6 under Linux read the file net/ipv6/README in the kernel source. 
+
+  If you want to use IPv6, please upgrade to the newest net-tools as
+  given in Documentation/Changes. You will still be able to do regular
+  IPv4 networking as well.
+
+  This protocol support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module will be called ipv6.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+  It is safe to say N here for now.
+
+IPv6: enable EUI-64 token format
+CONFIG_IPV6_EUI64
+  6bone, the network of computers using the IPv6 protocol, is moving
+  to a new aggregatable address format and a new link local address
+  assignment (EUI-64). Say Y if your site has upgraded already, or
+  has started to upgrade.
+
+IPv6: disable provider based addresses
+CONFIG_IPV6_NO_PB
+  Linux tries to operate correctly when your site has moved to EUI-64
+  only partially. Unfortunately, the two address formats (old:
+  "provider based" and new: "aggregatable") are incompatible. Say Y if
+  your site finished the upgrade to EUI-64, and/or you encountered
+  some problems caused by the presence of two link-local addresses on
+  an interface.
+
+IPv6: routing messages via old netlink
+CONFIG_IPV6_NETLINK
+  You can say Y here to receive routing messages from the IPv6 code
+  through the old netlink interface. However, a better option is to
+  say Y to "Kernel/User network link driver" and to "Routing
+  messages" instead.
+  
+IPX networking
+CONFIG_IPX
+  This is support for the Novell networking protocol, IPX, commonly
+  used for local networks of Windows machines. You need it if you want
+  to access Novell NetWare file or print servers using the Linux
+  Novell client ncpfs (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/) or from within
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO). In order to do the
+  former, you'll also have to say Y to "NCP filesystem support",
+  below.
+
+  IPX is similar in scope to IP, while SPX, which runs on top of IPX,
+  is similar to TCP. There is also experimental support for SPX in
+  Linux (see "SPX networking", below).
+
+  To turn your Linux box into a fully featured NetWare file server and
+  IPX router, say Y here and fetch either lwared from
+  ftp://metalab.unc.edu/pub/Linux/system/network/daemons/ or mars_nwe
+  from ftp://ftp.gwdg.de/pub/linux/misc/ncpfs. For more information,
+  read the IPX-HOWTO in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  The IPX driver would enlarge your kernel by about 5 kB. This driver
+  is also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module will
+  be called ipx.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. Unless you want to integrate
+  your Linux box with a local Novell network, say N.
+
+IPX: Full internal IPX network
+CONFIG_IPX_INTERN
+  Every IPX network has an address that identifies it. Sometimes it is
+  useful to give an IPX "network" address to your Linux box as well
+  (for example if your box is acting as a file server for different
+  IPX networks: it will then be accessible from everywhere using the
+  same address). The way this is done is to create a virtual internal
+  "network" inside your box and to assign an IPX address to this
+  network. Say Y here if you want to do this; read the IPX-HOWTO at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO for details.
+
+  The full internal IPX network enables you to allocate sockets on
+  different virtual nodes of the internal network. This is done by
+  evaluating the field sipx_node of the socket address given to the
+  bind call. So applications should always initialize the node field
+  to 0 when binding a socket on the primary network. In this case the
+  socket is assigned the default node that has been given to the
+  kernel when the internal network was created. By enabling the full
+  internal IPX network the cross-forwarding of packets targeted at
+  'special' sockets to sockets listening on the primary network is
+  disabled. This might break existing applications, especially RIP/SAP
+  daemons. A RIP/SAP daemon that works well with the full internal net
+  can be found on ftp://ftp.gwdg.de/pub/linux/misc/ncpfs. 
+
+  If you don't know what you are doing, say N.
+
+IPX: SPX networking (EXPERIMENTAL)
+CONFIG_SPX
+  The Sequenced Packet eXchange protocol is a transport layer protocol
+  built on top of IPX. It is used in Novell NetWare systems for
+  client-server applications and is similar to TCP (which runs on top
+  of IP).
+
+  Note that Novell NetWare file sharing does not use SPX; it uses a
+  protocol called NCP, for which separate Linux support is available
+  ("NCP filesystem support" below for the client side, and the user
+  space programs lwared or mars_nwe for the server side).
+
+  Say Y here if you have use for SPX; read the IPX-HOWTO at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called af_spx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AppleTalk DDP
+CONFIG_ATALK
+  AppleTalk is the way Apple computers speak to each other on a
+  network. If your Linux box is connected to such a network and you
+  want to join the conversation, say Y. You will need to use the
+  netatalk package so that your Linux box can act as a print and file
+  server for Macs as well as access AppleTalk printers. Check out
+  http://threepio.hitchcock.org/cgi-bin/faq/netatalk/faq.pl on the WWW
+  for details (to browse the WWW, you need to have access to a machine
+  on the Internet that has a program like lynx or netscape). EtherTalk
+  is the name used for AppleTalk over Ethernet and the cheaper and
+  slower LocalTalk is AppleTalk over a proprietary Apple network using
+  serial links. EtherTalk and LocalTalk are fully supported by Linux.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html
+  The NET-3-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO contains valuable
+  information as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called appletalk.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. I hear that
+  the GNU boycott of Apple is over, so even politically correct people
+  are allowed to say Y here.
+
+AppleTalk-IP driver support
+CONFIG_IPDDP
+  This allows IP networking for users who only have AppleTalk
+  networking available. This feature is experimental. With this
+  driver, you can encapsulate IP inside AppleTalk (e.g. if your Linux
+  box is stuck on an AppleTalk only network) or decapsulate (e.g. if
+  you want your Linux box to act as an Internet gateway for a zoo of
+  AppleTalk connected Macs). Please see the file
+  Documentation/networking/ipddp.txt for more information.
+
+  If you say Y here, the AppleTalk-IP support will be compiled into
+  the kernel. In this case, you can either use encapsulation or
+  decapsulation, but not both. With the following two questions, you
+  decide which one you want.
+
+  If you say M here, the AppleTalk-IP support will be compiled as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want, read Documentation/modules.txt).
+  The module is called ipddp.o. In this case, you will be able to use
+  both encapsulation and decapsulation simultaneously, by loading two
+  copies of the module and specifying different values for the module
+  option ipddp_mode. 
+
+IP to AppleTalk-IP Encapsulation support
+CONFIG_IPDDP_ENCAP
+  If you say Y here, the AppleTalk-IP code will be able to encapsulate
+  IP packets inside AppleTalk frames; this is useful if your Linux box
+  is stuck on an AppleTalk network (which hopefully contains a
+  decapsulator somewhere). Please see
+  Documentation/networking/ipddp.txt for more information. If you said
+  Y to "AppleTalk-IP driver support" above and you say Y here, then
+  you cannot say Y to "AppleTalk-IP to IP Decapsulation support",
+  below.
+
+AppleTalk-IP to IP Decapsulation support
+CONFIG_IPDDP_DECAP
+  If you say Y here, the AppleTalk-IP code will be able to decapsulate
+  AppleTalk-IP frames to IP packets; this is useful if you want your
+  Linux box to act as an Internet gateway for an AppleTalk network.
+  Please see Documentation/networking/ipddp.txt for more information.
+  If you said Y to "AppleTalk-IP driver support" above and you say Y
+  here, then you cannot say Y to "IP to AppleTalk-IP Encapsulation
+  support", above.
+
+Apple/Farallon LocalTalk PC card support
+CONFIG_LTPC
+  This allows you to use the AppleTalk PC card to connect to LocalTalk
+  networks. The card is also known as the Farallon PhoneNet PC card.
+  If you are in doubt, this card is the one with the 65C02 chip on it.
+  You also need version 1.3.3 or later of the netatalk package.
+  This driver is experimental, which means that it may not work.
+  See the file Documentation/networking/ltpc.txt.
+
+COPS LocalTalk PC card support
+CONFIG_COPS
+  This allows you to use COPS AppleTalk cards to connect to LocalTalk
+  networks. You also need version 1.3.3 or later of the netatalk
+  package. This driver is experimental, which means that it may not
+  work. This driver will only work if you choose "AppleTalk DDP"
+  networking support, above.
+  Please read the file Documentation/networking/cops.txt. 
+
+Dayna firmware support
+CONFIG_COPS_DAYNA
+  Support COPS compatible cards with Dayna style firmware (Dayna
+  DL2000/ Daynatalk/PC (half length), COPS LT-95, Farallon PhoneNET PC
+  III, Farallon PhoneNET PC II).
+
+Tangent firmware support
+CONFIG_COPS_TANGENT
+  Support COPS compatible cards with Tangent style firmware (Tangent
+  ATB_II, Novell NL-1000, Daystar Digital LT-200.
+
+Amateur Radio support
+CONFIG_HAMRADIO
+  If you want to connect your Linux box to an amateur radio, answer Y
+  here. You want to read http://www.tapr.org/tapr/html/pkthome.html
+  (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape) and the HAM-HOWTO
+  and the AX25-HOWTO, both available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about amateur radio.
+
+Amateur Radio AX.25 Level 2
+CONFIG_AX25
+  This is the protocol used for computer communication over amateur
+  radio. It is either used by itself for point-to-point links, or to
+  carry other protocols such as tcp/ip. To use it, you need a device
+  that connects your Linux box to your amateur radio. You can either
+  use a low speed TNC (a Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output) supporting the KISS protocol or
+  one of the various SCC cards that are supported by the generic Z8530
+  or the DMA SCC driver. Another option are the Baycom modem serial
+  and parallel port hacks or the sound card modem (supported by their
+  own drivers). If you say Y here, you also have to say Y to one of
+  those drivers.
+
+  Information about where to get supporting software for Linux amateur
+  radio as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You might also want to
+  check out the file Documentation/networking/ax25.txt in the kernel
+  source. More information about digital amateur radio in general is
+  on the WWW at http://www.tapr.org/tapr/html/pkthome.html. (To browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ax25.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AX.25 DAMA Slave support
+CONFIG_AX25_DAMA_SLAVE
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other slaves.
+  If you say Y here, your Linux box will act as a DAMA slave; this is
+  transparent in that you don't have to do any special DAMA
+  configuration. (Linux cannot yet act as a DAMA server.) If unsure,
+  say N.
+
+AX.25 DAMA Master support
+CONFIG_AX25_DAMA_MASTER
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other
+  slaves. If you say Y here, your Linux box will act as a DAMA server.
+  If unsure, say N.
+
+Amateur Radio NET/ROM
+CONFIG_NETROM
+  NET/ROM is a network layer protocol on top of AX.25 useful for
+  routing.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called netrom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amateur Radio X.25 PLP (Rose)
+CONFIG_ROSE
+  The Packet Layer Protocol (PLP) is a way to route packets over X.25
+  connections in general and amateur radio AX.25 connections in
+  particular, essentially an alternative to NET/ROM.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rose.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Serial port KISS driver for AX.25
+CONFIG_MKISS
+  KISS is a protocol used for the exchange of data between a computer
+  and a Terminal Node Controller (a small embedded system commonly
+  used for networking over AX.25 amateur radio connections; it
+  connects the computer's serial port with the radio's microphone
+  input and speaker output).
+
+  Although KISS is less advanced than the 6pack protocol, it has
+  the advantage that it is already supported by most modern TNCs
+  without the need for a firmware upgrade.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called mkiss.o.
+
+Serial port 6PACK driver for AX.25
+CONFIG_6PACK
+  6pack is a transmission protocol for the data exchange between your
+  PC and your TNC (the Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output). This protocol can be used as
+  an alternative to KISS for networking over AX.25 amateur radio
+  connections, but it has some extended functionality.
+
+  Note that this driver is still experimental and might cause
+  problems. For details about the features and the usage of the
+  driver, read Documentation/networking/6pack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called 6pack.o.
+
+BPQ Ethernet driver
+CONFIG_BPQETHER
+  AX.25 is the protocol used for computer communication over amateur
+  radio. If you say Y here, you will be able to send and receive AX.25
+  traffic over Ethernet (also called "BPQ AX.25"), which could be
+  useful if some other computer on your local network has a direct
+  amateur radio connection.
+
+High-speed (DMA) SCC driver for AX.25
+CONFIG_DMASCC
+  This is a driver for high-speed SCC boards, i.e. those supporting
+  DMA on one port. You usually use those boards to connect your
+  computer to an amateur radio modem (such as the WA4DSY 56kbps
+  modem), in order to send and receive AX.25 packet radio network
+  traffic.
+
+  Currently, this driver supports Ottawa PI/PI2
+  (http://hydra.carleton.ca/info/pi2.html) and Gracilis PackeTwin
+  (http://www.paccomm.com/gracilis.html) boards. They are detected
+  automatically. If you have one of these cards, say Y here and read
+  the AX25-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/.
+
+  This driver can operate multiple boards simultaneously. If you
+  compile it as a module (by saying M instead of Y), it will be called
+  dmascc.o. If you don't pass any parameter to the driver, all
+  possible I/O addresses are probed. This could irritate other devices
+  that are currently not in use. You may specify the list of addresses
+  to be probed by "dmascc=addr1,addr2,..." (when compiled into the
+  kernel image) or "io=addr1,addr2,..." (when loaded as a module). The
+  network interfaces will be called dmascc0 and dmascc1 for the board
+  detected first, dmascc2 and dmascc3 for the second one, and so on.
+
+  Before you configure each interface with ifconfig, you MUST set
+  certain parameters, such as channel access timing, clock mode, and
+  DMA channel. This is accomplished with a small utility program,
+  dmascc_cfg, available at
+  http://www.nt.tuwien.ac.at/~kkudielk/Linux/. (To browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape).
+
+Z8530 SCC driver for AX.25
+CONFIG_SCC
+  These cards are used to connect your Linux box to an amateur radio
+  in order to communicate with other computers. If you want to use
+  this, read Documentation/networking/z8530drv.txt and the
+  AX25-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also make sure to say Y
+  to "Amateur Radio AX.25 Level 2" support.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called scc.o.
+
+additional delay for PA0HZP OptoSCC compatible boards
+CONFIG_SCC_DELAY
+  Say Y here if you experience problems with the SCC driver not
+  working properly; please read Documentation/networking/z8530drv.txt
+  for details. If unsure, say N.
+
+#support for TRX that feedback the tx signal to rx
+#CONFIG_SCC_TRXECHO
+###
+### Don't know what's going on here.
+###
+#
+YAM driver for AX.25
+CONFIG_YAM
+  Support for the YAM modem on serial port. If you want to compile this
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt.
+
+BAYCOM picpar and par96 driver for AX.25
+CONFIG_BAYCOM_PAR
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the picpar and
+  par96 designs. To configure the driver, use the sethdlc utility
+  available in the standard ax25 utilities package. For information on
+  the modems, see http://www.baycom.de (to browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape) and Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM EPP driver for AX.25
+CONFIG_BAYCOM_EPP
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the EPP
+  designs. To configure the driver, use the sethdlc utility available
+  in the standard ax25 utilities package. For information on the
+  modems, see http://www.baycom.de (to browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape) and Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM ser12 full duplex driver for AX.25
+CONFIG_BAYCOM_SER_FDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. In addition, it allows the
+  baudrate to be set between 300 and 4800 baud (however not all modems
+  support all baudrates). This is the preferred driver. The next
+  driver, "BAYCOM ser12 half duplex driver for AX.25" is the old
+  driver and still provided in case this driver does not work with
+  your serial interface chip. To configure the driver, use the sethdlc
+  utility available in the standard ax25 utilities package. For
+  information on the modems, see http://www.baycom.de (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) and
+  Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_fdx.o.
+
+BAYCOM ser12 half duplex driver for AX.25
+CONFIG_BAYCOM_SER_HDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. This is the old driver. It is
+  still provided in case your serial interface chip does not work with
+  the full duplex driver. This driver is depreciated. To configure
+  the driver, use the sethdlc utility available in the standard ax25
+  utilities package. For information on the modems, see
+  http://www.baycom.de (to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape)
+  and Documentation/networking/baycom.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_hdx.o.
+
+Sound card modem driver for AX.25
+CONFIG_SOUNDMODEM
+  This experimental driver allows a standard Sound Blaster or
+  WindowsSoundSystem compatible sound card to be used as a packet
+  radio modem (NOT as a telephone modem!), to send digital traffic
+  over amateur radio.
+
+  To configure the driver, use the sethdlc, smdiag and smmixer
+  utilities available in the standard ax25 utilities package. For
+  information on how to key the transmitter, see
+  http://www.ife.ee.ethz.ch/~sailer/pcf/ptt_circ/ptt.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape) and
+  Documentation/networking/soundmodem.txt. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called soundmodem.o.
+
+Sound card modem support for Sound Blaster and compatible cards
+CONFIG_SOUNDMODEM_SBC
+  This option enables the soundmodem driver to use Sound Blaster and
+  compatible cards. If you have a dual mode card (i.e. a WSS cards
+  with a Sound Blaster emulation) you should say N here and Y to
+  "Sound card modem support for WSS and Crystal cards", below, because
+  this usually results in better performance. This option also
+  supports SB16/32/64 in full duplex mode.
+
+Sound card modem support for WSS and Crystal cards
+CONFIG_SOUNDMODEM_WSS
+  This option enables the soundmodem driver to use WindowsSoundSystem
+  compatible cards. These cards feature a codec chip from either
+  Analog Devices (such as AD1848, AD1845, AD1812) or Crystal
+  Semiconductors (such as CS4248, CS423x). This option also supports
+  the WSS full duplex operation which currently works with Crystal
+  CS423x chips. If you don't need full duplex operation, do not enable
+  it to save performance.
+
+Sound card modem support for 1200 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK1200
+  This option enables the soundmodem driver 1200 baud AFSK modem,
+  compatible to popular modems using TCM3105 or AM7911. The
+  demodulator requires about 12% of the CPU power of a Pentium 75 CPU
+  per channel.
+
+Sound card modem support for 2400 baud AFSK modulation (7.3728MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_7
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with a 7.3728MHz
+  crystal. Note that the availability of this driver does _not_ imply
+  that I recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2400 baud AFSK modulation (8MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_8
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with an 8MHz crystal.
+  Note that the availability of this driver does _not_ imply that I
+  recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2666 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK2666
+  This option enables the soundmodem driver 2666 baud AFSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud 8PSK modulation
+CONFIG_SOUNDMODEM_PSK4800
+  This option enables the soundmodem driver 4800 baud 8PSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud HAPN-1 modulation
+CONFIG_SOUNDMODEM_HAPN4800
+  This option enables the soundmodem driver 4800 baud HAPN-1
+  compatible modem. This modulation seems to be widely used 'down
+  under' and in the Netherlands. Here, nobody uses it, so I could not
+  test if it works. It is compatible to itself, however :-)
+
+Sound card modem support for 9600 baud FSK G3RUH modulation
+CONFIG_SOUNDMODEM_FSK9600
+  This option enables the soundmodem driver 9600 baud FSK modem,
+  compatible to the G3RUH standard. The demodulator requires about 4%
+  of the CPU power of a Pentium 75 CPU per channel. You can say Y to
+  both 1200 baud AFSK and 9600 baud FSK if you want (but obviously you
+  can only use one protocol at a time, depending on what the other end
+  can understand).
+
+CCITT X.25 Packet Layer
+CONFIG_X25
+  X.25 is a set of standardized network protocols, similar in scope to
+  frame relay; the one physical line from your box to the X.25 network
+  entry point can carry several logical point-to-point connections
+  (called "virtual circuits") to other computers connected to the X.25
+  network. Governments, banks, and other organizations tend to use it
+  to connect to each other or to form Wide Area Networks (WANs). Many
+  countries have public X.25 networks. X.25 consists of two
+  protocols: the higher level Packet Layer Protocol (PLP) (say Y here
+  if you want that) and the lower level data link layer protocol LAPB
+  (say Y to "LAPB Data Link Driver" below if you want that). 
+
+  You can read more about X.25 at http://www.sangoma.com/x25.html and
+  http://www.cisco.com/univercd/data/doc/software/11_0/rpcg/cx25.htm
+  (to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape). Information
+  about X.25 for Linux is contained in the files
+  Documentation/networking/x25.txt and
+  Documentation/networking/x25-iface.txt. 
+
+  One connects to an X.25 network either with a dedicated network card
+  using the X.21 protocol (not yet supported by Linux) or one can do
+  X.25 over a standard telephone line using an ordinary modem (say Y
+  to "X.25 async driver" below) or over Ethernet using an ordinary
+  Ethernet card and either the 802.2 LLC protocol (say Y to "802.2
+  LLC" below) or LAPB over Ethernet (say Y to "LAPB Data Link Driver"
+  and "LAPB over Ethernet driver" below). 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25.o. If unsure, say N.
+
+LAPB Data Link Driver (EXPERIMENTAL) 
+CONFIG_LAPB
+  Link Access Procedure, Balanced (LAPB) is the data link layer (i.e.
+  the lower) part of the X.25 protocol. It offers a reliable
+  connection service to exchange data frames with one other host, and
+  it is used to transport higher level protocols (mostly X.25 Packet
+  Layer, the higher part of X.25, but others are possible as well).
+  Usually, LAPB is used with specialized X.21 network cards, but Linux
+  currently supports LAPB only over Ethernet connections. If you want
+  to use LAPB connections over Ethernet, say Y here and to "LAPB over
+  Ethernet driver" below. Read
+  Documentation/networking/lapb-module.txt for technical details.
+
+  If you want to compile this driver as a module though ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called lapb.o. If unsure, say N.
+
+802.2 LLC (VERY EXPERIMENTAL)
+CONFIG_LLC
+  This is a Logical Link Layer protocol used for X.25 connections over
+  Ethernet, using ordinary Ethernet cards. 
+
+Bridging (EXPERIMENTAL)
+CONFIG_BRIDGE
+  If you say Y here, then your Linux box will be able to act as an
+  Ethernet bridge, which means that the different Ethernet segments it
+  is connected to will appear as one Ethernet to the participants.
+  Several such bridges can work together to create even larger
+  networks of Ethernets using the IEEE802.1 spanning tree algorithm.
+  As this is a standard, Linux bridges will interwork properly with
+  other third party bridge products. 
+
+  In order to use this, you'll need the bridge configuration tools
+  available from http://lrp.plain.co.nz/tarballs/bridgex-0.30.tar.gz
+  Note that if your box acts as a bridge, it probably contains several
+  Ethernet devices, but the kernel is not able to recognize more than 
+  one ISA ethernet card at boot time without help; for  details read 
+  the Ethernet-HOWTO, available via FTP (user: anonymous)
+  in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. The Bridging code is
+  still in test. If unsure, say N.
+
+Frame Diverter (EXPERIMENTAL)
+CONFIG_NET_DIVERT
+  The Frame Diverter allows you to divert packets from the
+  network, that are not aimed at the interface receiving it (in 
+  promisc. mode). Typically, a Linux box setup as an ethernet bridge
+  with the Frames Diverter on, can do some *really* transparent www 
+  caching using a Squid proxy for example.
+
+  This is very useful when you don't want to change your router's
+  config (or if you simply don't have access to it).
+
+  The other possible usages of diverting Ethernet Frames are numberous:
+   - reroute smtp traffic to another interface
+   - traffic-shape certain network streams
+   - transparently proxy smtp connections
+   - etc...
+
+  For more informations, please refer to:
+    http://www.freshmeat.net/projects/etherdivert
+    http://perso.wanadoo.fr/magpie/EtherDivert.html
+
+  If unsure, say N
+
+Packet socket
+CONFIG_PACKET
+  The Packet protocol is used by applications which communicate
+  directly with network devices without an intermediate network
+  protocol implemented in the kernel, e.g. tcpdump. If you want them
+  to work, choose Y. This driver is also available as a module called
+  af_packet.o ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.  You will
+  need to add 'alias net-pf-17 af_packet' to your /etc/conf.modules
+  file for the module version to function automatically.  If unsure, say Y.
+
+Kernel/User network link driver
+CONFIG_NETLINK
+  This driver allows for two-way communication between certain parts
+  of the kernel or modules and user processes; the user processes are
+  able to read from and write to character special files in the /dev
+  directory having major mode 36. So far, the kernel uses it to
+  publish some network related information if you say Y to "Routing
+  messages", below. It is also used by the firewall code to publish
+  information about possible attacks if you say Y to "IP: firewall
+  packet netlink device" further down. You also need to say Y here if
+  you want to use arpd, a daemon that helps keep the internal ARP
+  cache (a mapping between IP addresses and hardware addresses on the
+  local network) small. The ethertap device, which lets user space
+  programs read and write raw Ethernet frames, also needs the network
+  link driver. If unsure, say Y.
+
+Routing messages
+CONFIG_RTNETLINK
+  If you say Y here and create a character special file /dev/route
+  with major number 36 and minor number 0 using mknod ("man mknod"),
+  you (or some user space utility) can read some network related
+  routing information from that file. Everything you write to that
+  file will be discarded.
+
+Netlink device emulation
+CONFIG_NETLINK_DEV
+  This is a backward compatibility option, choose Y for now.
+  This option will be removed soon.
+
+SCSI support?
+CONFIG_SCSI
+  If you want to use a SCSI hard disk, SCSI tape drive, SCSI CDROM or
+  any other SCSI device under Linux, say Y and make sure that you know
+  the name of your SCSI host adapter (the card inside your computer
+  that "speaks" the SCSI protocol, also called SCSI controller),
+  because you will be asked for it. 
+
+  You also need to say Y here if you want support for the parallel
+  port version of the 100 MB IOMEGA ZIP drive.
+
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. The
+  SCSI-Programming-HOWTO contains information about how to add or
+  remove an SCSI device from a running Linux machine without
+  rebooting.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scsi_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. However, do not compile this as a module if
+  your root filesystem (the one containing the directory /) is located
+  on a SCSI device.
+
+SCSI disk support
+CONFIG_BLK_DEV_SD
+  If you want to use a SCSI hard disk or the SCSI or parallel port
+  version of the IOMEGA ZIP drive under Linux, say Y and read the
+  SCSI-HOWTO, the Disk-HOWTO and the Multi-Disk-HOWTO, available via
+  FTP (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  This is NOT for SCSI CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sd_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. Do not compile this driver as a module if
+  your root filesystem (the one containing the directory /) is located
+  on a SCSI disk. In this case, do not compile the driver for your
+  SCSI host adapter (below) as a module either.
+
+SCSI tape support
+CONFIG_CHR_DEV_ST
+  If you want to use a SCSI tape drive under Linux, say Y and read the
+  SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and
+  drivers/scsi/README.st in the kernel source. This is NOT for SCSI
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called st.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+SCSI CDROM support
+CONFIG_BLK_DEV_SR
+  If you want to use a SCSI CDROM under Linux, say Y and read the
+  SCSI-HOWTO and the CDROM-HOWTO from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also make sure to say Y
+  or M to "ISO 9660 CDROM filesystem support" later.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sr_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+Enable vendor-specific extensions (for SCSI CDROM)
+CONFIG_BLK_DEV_SR_VENDOR
+  This enables the usage of vendor specific SCSI commands. This is
+  required to support multisession CDs with old NEC/TOSHIBA cdrom
+  drives (and HP Writers). If you have such a drive and get the first
+  session only, try saying Y here; everybody else says N.
+
+SCSI generic support
+CONFIG_CHR_DEV_SG
+  If you want to use SCSI scanners, synthesizers or CD-writers or just
+  about anything having "SCSI" in its name other than hard disks,
+  CDROMs or tapes, say Y here. These won't be supported by the kernel
+  directly, so you need some additional software which knows how to
+  talk to these devices using the SCSI protocol. For scanners, look at
+  SANE (www.mostang.com/sane). For CD writer software look at cdrecord
+  (www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private
+  /cdrecord.html) and for burning a "disk at once": cdrdao
+  (www.ping.de/sites/daneb/cdrdao.html). Cdparanoia is a high quality
+  digital reader of audio CDs (www.xiph.org/paranoia).
+  For other devices, it's possible that you'll have to write the driver
+  software yourself. Please read the file Documentation/scsi-generic.txt
+  for more information.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. The module will be called sg.o. If unsure,
+  say N.
+
+Probe all LUNs on each SCSI device
+CONFIG_SCSI_MULTI_LUN
+  If you have a SCSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, and only one LUN is detected, you
+  can say Y here to force the SCSI driver to probe for multiple LUNs. 
+  A SCSI device with multiple LUNs acts logically like multiple SCSI
+  devices. The vast majority of SCSI devices have only one LUN, and
+  so most people can say N here and should in fact do so, because it
+  is safer.
+
+Verbose SCSI error reporting (kernel size +=12K)
+CONFIG_SCSI_CONSTANTS
+  The error messages regarding your SCSI hardware will be easier to
+  understand if you say Y here; it will enlarge your kernel by about
+  12 KB. If in doubt, say Y.
+
+SCSI logging facility
+CONFIG_SCSI_LOGGING
+  This turns on a logging facility that can be used to debug a number
+  of SCSI related problems. 
+
+  If you say Y here, no logging output will appear by default, but you
+  can enable logging by saying Y to "/proc filesystem support" and
+  "Sysctl support" below and executing the command
+
+     echo "scsi log token [level]" > /proc/scsi/scsi
+
+  at boot time after the /proc filesystem has been mounted.
+
+  There are a number of things that can be used for 'token' (you can
+  find them in the source: drivers/scsi/scsi.c), and this allows you
+  to select the types of information you want, and the level allows
+  you to select the level of verbosity. 
+
+  If you say N here, it may be harder to track down some types of SCSI
+  problems. If you say Y here your kernel will be somewhat larger, but
+  there should be no noticeable performance impact as long as you have
+  logging turned off.
+
+AdvanSys SCSI support
+CONFIG_SCSI_ADVANSYS
+  This is a driver for all SCSI host adapters manufactured by
+  AdvanSys. It is documented in the kernel source in
+  drivers/scsi/advansys.c. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called advansys.o.
+
+Adaptec AHA152X/2825 support
+CONFIG_SCSI_AHA152X
+  This is a driver for the AHA-1510, AHA-1520, AHA-1522, and AHA-2825
+  SCSI host adapters. It also works for the AVA-1505, but the IRQ etc.
+  must be manually specified in this case.
+
+  It is explained in section 3.3 of the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You
+  might also want to read the comments at the top of
+  drivers/scsi/aha152x.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha152x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AHA1542 support
+CONFIG_SCSI_AHA1542
+  This is support for a SCSI host adapter. It is explained in section
+  3.4 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that Trantor was
+  recently purchased by Adaptec, and some former Trantor products are
+  being sold under the Adaptec name. If it doesn't work out of the
+  box, you may have to change some settings in drivers/scsi/aha1542.h.
+  
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aha1542.o.
+
+Adaptec AHA1740 support
+CONFIG_SCSI_AHA1740
+  This is support for a SCSI host adapter. It is explained in section
+  3.5 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/aha1740.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha1740.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AIC7xxx chipset SCSI controller support
+CONFIG_SCSI_AIC7XXX
+  This is support for the various aic7xxx based Adaptec SCSI
+  controllers. These include the 274x EISA cards; 284x VLB cards;
+  2902, 2910, 293x, 294x, 394x, 3985 and several other PCI and
+  motherboard based SCSI controllers from Adaptec. It does not support
+  the AAA-13x RAID controllers from Adaptec, nor will it likely ever
+  support them. It does not support the 2920 cards from Adaptec that
+  use the Future Domain SCSI controller chip. For those cards, you
+  need the "Future Domain 16xx SCSI support" driver.
+
+  In general, if the controller is based on an Adaptec SCSI controller
+  chip from the aic777x series or the aic78xx series, this driver
+  should work. The only exception is the 7810 which is specifically
+  not supported (that's the RAID controller chip on the AAA-13x
+  cards).
+
+  Note that the AHA2920 SCSI host adapter is *not* supported by this
+  driver; choose "Future Domain 16xx SCSI support" instead if you have
+  one of those.
+
+  Information on the configuration options for this controller can be
+  found by checking the help file for each of the available
+  configuration options. You should read drivers/scsi/README.aic7xxx
+  at a minimum before contacting the maintainer with any questions.  
+  The SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO can also be of great
+  help.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aic7xxx.o.
+
+Enable or Disable Tagged Command Queueing by default
+CONFIG_AIC7XXX_TCQ_ON_BY_DEFAULT
+  This option causes the aic7xxx driver to attempt to use tagged command
+  queueing on any devices that claim to support it.  If this is set to yes,
+  you can still turn off TCQ on troublesome devices with the use of the
+  tag_info boot parameter.  See /usr/src/linux/drivers/scsi/README.aic7xxx
+  for more information on that and other aic7xxx setup commands.  If this
+  option is turned off, you may still enable TCQ on known good devices by
+  use of the tag_info boot parameter.
+  
+  If you are unsure about your devices then it is safest to say N here.
+  
+  However, TCQ can increase performance on some hard drives by as much
+  as 50% or more, so I would recommend that if you say N here, that you
+  at least read the README.aic7xxx file so you will know how to enable
+  this option manually should your drives prove to be safe in regards
+  to TCQ.
+
+  Conversely, certain drives are known to lock up or cause bus resets when
+  TCQ is enabled on them.  If you have a Western Digital Enterprise SCSI
+  drive for instance, then don't even bother to enable TCQ on it as the
+  drive will become unreliable, and it will actually reduce performance.
+
+Default number of TCQ commands per device
+CONFIG_AIC7XXX_CMDS_PER_DEVICE
+  Specify the number of commands you would like to allocate per SCSI
+  device when Tagged Command Queueing (TCQ) is enabled on that device.
+
+  Reasonable figures are in the range of 8 to 24 commands per device,
+  but depending on hardware could be increased or decreased from that
+  figure. If the number is too high for any particular device, the
+  driver will automatically compensate usually after only 10 minutes
+  of uptime. It will not hinder performance if some of your devices
+  eventually have their command depth reduced, but is a waste of memory
+  if all of your devices end up reducing this number down to a more
+  reasonable figure.
+  
+  NOTE: Certain very broken drives are known to lock up when given more
+  commands than they like to deal with.  Quantum Fireball drives are the
+  most common in this category.  For the Quantum Fireball drives I would
+  suggest no more than 8 commands per device.
+
+  Default: 8
+
+Collect statistics to report in /proc
+CONFIG_AIC7XXX_PROC_STATS
+  This option tells the driver to keep track of how many commands have
+  been sent to each particular device and report that information to
+  the user via the /proc/scsi/aic7xxx/n file, where n is the number of
+  the aic7xxx controller you want the information on. This adds a
+  small amount of overhead to each and every SCSI command the aic7xxx
+  driver handles, so if you aren't really interested in this
+  information, it is best to leave it disabled. This will only work if
+  you also say Y to "/proc filesystem support", below. 
+
+  If unsure, say N.
+
+Delay in seconds after SCSI bus reset
+CONFIG_AIC7XXX_RESET_DELAY
+  This sets how long the driver will wait after resetting the SCSI bus
+  before attempting to communicate with the devices on the SCSI bus
+  again. This delay will be used during the reset phase at bootup time
+  as well as after any reset that might occur during normal operation.
+  Reasonable numbers range anywhere from 5 to 15 seconds depending on
+  your devices. DAT tape drives are notorious for needing more time
+  after a bus reset to be ready for the next command, but most hard
+  drives and CD-ROM devices are ready in only a few seconds. This
+  option has a maximum upper limit of 20 seconds to avoid bad
+  interactions between the aic7xxx driver and the rest of the linux
+  kernel. The default value has been reduced to 5 seconds. If this
+  doesn't work with your hardware, try increasing this value.
+
+IBM ServeRAID Support
+CONFIG_SCSI_IPS
+  This is support for the IBM ServeRAID hardware RAID controllers.
+  See http://www.developer.ibm.com/welcome/netfinity/serveraid.html
+  for more information.  If this driver does not work correctly
+  without modification please contact the author by email at
+  ipslinux@us.ibm.com.
+
+BusLogic SCSI support
+CONFIG_SCSI_BUSLOGIC
+  This is support for BusLogic MultiMaster and FlashPoint SCSI Host
+  Adapters. Consult the SCSI-HOWTO, available via anonymous FTP from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, and the files
+  README.BusLogic and README.FlashPoint in drivers/scsi for more
+  information. If this driver does not work correctly without
+  modification, please contact the author, Leonard N. Zubkoff, by
+  email to lnz@dandelion.com. 
+
+  You can also build this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  but only a single instance may be loaded. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. The
+  module will be called BusLogic.o.
+
+Omit BusLogic SCSI FlashPoint support
+CONFIG_SCSI_OMIT_FLASHPOINT
+  This option allows you to omit the FlashPoint support from the
+  BusLogic SCSI driver. The FlashPoint SCCB Manager code is
+  substantial, so users of MultiMaster Host Adapters may wish to omit
+  it.
+
+DTC3180/3280 SCSI support
+CONFIG_SCSI_DTC3280
+  This is support for DTC 3180/3280 SCSI Host Adapters. Please read
+  the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and the file
+  drivers/scsi/README.dtc3x80. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dtc.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-DMA [Obsolete] (DPT, NEC, AT&T, SNI, AST, Olivetti, Alphatronix) support
+CONFIG_SCSI_EATA_DMA
+  This is support for the EATA-DMA protocol compliant SCSI Host
+  Adapters like the SmartCache III/IV, SmartRAID controller families
+  and the DPT PM2011B and PM2012B controllers. 
+
+  Note that this driver is obsolete; if you have one of the above SCSI
+  Host Adapters, you should normally say N here and Y to "EATA
+  ISA/EISA/PCI support", below. Please read the SCSI-HOWTO, available
+  via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eata_dma.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-PIO (old DPT PM2001, PM2012A) support
+CONFIG_SCSI_EATA_PIO
+  This driver supports all EATA-PIO protocol compliant SCSI Host
+  Adapters like the DPT PM2001 and the PM2012A. EATA-DMA compliant
+  host adapters could also use this driver but are discouraged from
+  doing so, since this driver only supports hard disks and lacks
+  numerous features. You might want to have a look at the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata_pio.o.
+
+UltraStor 14F/34F support
+CONFIG_SCSI_U14_34F
+  This is support for the UltraStor 14F and 34F SCSI-2 host adapters.
+  The source at drivers/scsi/u14-34f.c contains some information about
+  this hardware. If the driver doesn't work out of the box, you may
+  have to change some settings in drivers/scsi/u14-34f.c. Read the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that there is also
+  another driver for the same hardware: "UltraStor SCSI support",
+  below. You should say Y to both only if you want 24F support as
+  well. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called u14-34f.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+enable elevator sorting
+CONFIG_SCSI_U14_34F_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_U14_34F_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 8
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 14. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+Future Domain 16xx SCSI/AHA-2920A support
+CONFIG_SCSI_FUTURE_DOMAIN
+  This is support for Future Domain's 16-bit SCSI host adapters
+  (TMC-1660/1680, TMC-1650/1670, TMC-3260, TMC-1610M/MER/MEX) and
+  other adapters based on the Future Domain chipsets (Quantum
+  ISA-200S, ISA-250MG; Adaptec AHA-2920A; and at least one IBM board).
+  It is explained in section 3.7 of the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  NOTE: Newer Adaptec AHA-2920C boards use the Adaptec AIC-7850 chip
+  and should use the aic7xxx driver ("Adaptec AIC7xxx chipset SCSI
+  controller support"). This Future Domain driver works with the older
+  Adaptec AHA-2920A boards with a Future Domain chip on them.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fdomain.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Future Domain MCS-600/700 SCSI support
+CONFIG_SCSI_FD_MCS
+ This is support for Future Domain MCS 600/700 MCA SCSI adapters. Some
+ PS/2 computers are equipped with IBM Fast SCSI Adapter/A which is
+ identical to the MCS 700 and hence also supported by this driver.
+ This driver also supports the Reply SB16/SCSI card (the SCSI part).
+ It supports multiple adapters in the same system.
+
+Generic NCR5380/53c400 SCSI support
+CONFIG_SCSI_GENERIC_NCR5380
+  This is the generic NCR family of SCSI controllers, not to be
+  confused with the NCR 53c7 or 8xx controllers. It is explained in
+  section 3.8 of the SCSI-HOWTO, available via FTP (user: anonymous)
+  at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work
+  out of the box, you may have to change some settings in
+  drivers/scsi/g_NCR5380.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called g_NCR5380.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Enable NCR53c400 extensions
+CONFIG_SCSI_GENERIC_NCR53C400
+  This enables certain optimizations for the NCR53c400 SCSI cards. You
+  might as well try it out. Note that this driver will only probe for
+  the Trantor T130B in its default configuration; you might have to
+  pass a command line option to the kernel at boot time if it doesn't
+  detect your card. See the file drivers/scsi/README.g_NCR5380 for
+  details.
+
+NCR5380/53c400 mapping method (use Port for T130B)
+CONFIG_SCSI_G_NCR5380_PORT
+  The NCR5380 and NCR53c400 SCSI controllers come in two varieties:
+  port or memory mapped. You should know what you have. The most
+  common card, Trantor T130B, uses port mapped mode.
+
+NCR53c7,8xx SCSI support
+CONFIG_SCSI_NCR53C7xx
+  This is a driver for the 53c7 and 8xx NCR family of SCSI
+  controllers, not to be confused with the NCR 5380 controllers. It is
+  explained in section 3.8 of the SCSI-HOWTO, available via FTP (user:
+  anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it
+  doesn't work out of the box, you may have to change some settings in
+  drivers/scsi/53c7,8xx.h. Please read drivers/scsi/README.ncr53c7xx
+  for the available boot time command line options.
+
+  Note: there is another driver for the 53c8xx family of controllers
+  ("NCR53C8XX SCSI support" below). If you want to use them both, you
+  need to say M to both and build them as modules, but only one may be
+  active at a time. If you have a 53c8xx board, it's better to use the
+  other driver.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 53c7,8xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+always negotiate synchronous transfers
+CONFIG_SCSI_NCR53C7xx_sync
+  In general, this is good; however, it is a bit dangerous since there
+  are some broken SCSI devices out there. Take your chances. Safe bet
+  is N.
+
+allow FAST-SCSI [10MHz]
+CONFIG_SCSI_NCR53C7xx_FAST
+  This will enable 10MHz FAST-SCSI transfers with your host
+  adapter. Some systems have problems with that speed, so it's safest
+  to say N here.
+
+allow DISCONNECT
+CONFIG_SCSI_NCR53C7xx_DISCONNECT
+  This enables the disconnect/reconnect feature of the NCR SCSI
+  controller. When you say Y here, a slow SCSI device will not lock
+  the SCSI bus while processing a request, allowing simultaneous use
+  of e.g. a SCSI hard disk and SCSI tape or CD-ROM drive, and
+  providing much better performance when using slow and fast SCSI
+  devices at the same time. Some devices, however, do not operate
+  properly with this option enabled, and will cause your SCSI system
+  to hang, which might cause a system crash. The safe answer
+  therefore is to say N.
+
+NCR53C8XX SCSI support
+CONFIG_SCSI_NCR53C8XX
+  This is the BSD ncr driver adapted to Linux for the NCR53C8XX family
+  of PCI-SCSI controllers. This driver supports parity checking,
+  tagged command queuing and fast synchronous data transfers up to 80
+  MB/s with wide FAST-40 LVD devices and controllers.
+
+  This driver does not support SYM53C1010 Ultra-160 PCI-SCSI chips.
+  Support for SYM53C1010 chips requires the "SYM53C8XX SCSI option" to
+  be configured. This option will configure a different driver.
+  Recent versions of the 53C8XX chips are better supported by the
+  option "SYM53C8XX SCSI support", below.
+
+  If you want the kernel to select the recommended driver for each of 
+  of your NCR/SYM53C8XX controllers you may just configure both the 
+  NCR53C8XX and the SYM53C8XX options to Y, or if modules are preferred, 
+  load first the sym53c8xx.o module and then the ncr53c8xx.o module.
+
+  Note: there is yet another driver for the 53c8xx family of controllers
+  ("NCR53c7,8xx SCSI support" above). If you want to use them both,
+  you need to say M to both and build them as modules, but only one
+  may be active at a time. If you have a 53c8xx board, you probably do
+  not want to use the "NCR53c7,8xx SCSI support".
+
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+SYM53C8XX SCSI support
+CONFIG_SCSI_SYM53C8XX
+  This driver supports all the features of recent 53C8XX chips (used
+  in PCI SCSI controllers), notably the hardware phase mismatch
+  feature of the SYM53C896, SYM53C895A and SYM53C1010.
+  It also supports Ultra-160 SCSI data transfers for the SYM53C1010.
+
+  Older versions of the 53C8XX chips are not supported by this
+  driver. If your system uses either a 810 rev. < 16, a 815, or a 825
+  rev. < 16 PCI SCSI processor, you must use the generic NCR53C8XX
+  driver ("NCR53C8XX SCSI support" above) or configure both the
+  NCR53C8XX and this SYM53C8XX drivers either as module or linked to
+  the kernel image.
+
+  When both drivers are linked to the kernel, the SYM53C8XX driver is 
+  called first at initialization and you can use the 'excl=ioaddr' 
+  driver boot option to exclude attachment of adapters by the SYM53C8XX 
+  driver. For instance, entering 'sym53c8xx=excl:0xb400,excl=0xc000' at 
+  lilo prompt prevents adapters at io address 0xb400 and 0xc000 from 
+  being attached by the SYM53C8XX driver, thus allowing the NCR53C8XX 
+  driver to attach them. The 'excl' option is also supported by the 
+  NCR53C8XX driver.
+  
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+synchronous data transfers frequency
+CONFIG_SCSI_NCR53C8XX_SYNC
+  The SCSI Parallel Interface-2 Standard defines 5 classes of transfer
+  rates: FAST-5, FAST-10, FAST-20, FAST-40 and FAST-80. The numbers are
+  respectively the maximum data transfer rates in mega-transfers per
+  second for each class. For example, a FAST-20 Wide 16 device is able
+  to transfer data at 20 million 16 bit packets per second for a total
+  rate of 40 MB/s.
+
+  You may specify 0 if you want to only use asynchronous data
+  transfers. This is the safest and slowest option. Otherwise, specify
+  a value between 5 and 80, depending on the capability of your SCSI
+  controller. The higher the number, the faster the data transfer.
+  Note that 80 should normally be ok since the driver decreases the
+  value automatically according to the controller's capabilities.
+
+  Your answer to this question is ignored for controllers with NVRAM,
+  since the driver will get this information from the user set-up. It
+  also can be overridden using a boot setup option, as follows
+  (example): 'ncr53c8xx=sync:12' will allow the driver to negotiate
+  for FAST-20 synchronous data transfer (20 mega-transfers per
+  second).
+
+  The normal answer therefore is not to go with the default but to
+  select the maximum value 80 allowing the driver to use the maximum
+  value supported by each controller. If this causes problems with
+  your SCSI devices, you should come back and decrease the value.
+
+  There is no safe option other than using good cabling, right
+  terminations and SCSI conformant devices.
+
+use normal IO
+CONFIG_SCSI_NCR53C8XX_IOMAPPED
+  If you say Y here, the driver will use normal IO, as opposed to
+  memory mapped IO. Memory mapped IO has less latency than normal IO
+  and works for most Intel-based hardware. Under Linux/Alpha only
+  normal IO is currently supported by the driver and so, this option
+  has no effect on those systems. 
+
+  The normal answer therefore is N; try Y only if you encounter SCSI
+  related problems.
+
+not allow targets to disconnect
+CONFIG_SCSI_NCR53C8XX_NO_DISCONNECT
+  This option is only provided for safety if you suspect some SCSI
+  device of yours to not support properly the target-disconnect
+  feature. In that case, you would say Y here. In general however, to
+  not allow targets to disconnect is not reasonable if there is more
+  than 1 device on a SCSI bus. The normal answer therefore is N.
+
+default tagged command queue depth
+CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS
+  "Tagged command queuing" is a feature of SCSI-2 which improves
+  performance: the host adapter can send several SCSI commands to a
+  device's queue even if previous commands haven't finished yet. Some
+  SCSI devices don't implement this properly; if you want to disable
+  this feature, enter 0 or 1 here (it doesn't matter which).
+
+  The default value is 8 and should be supported by most hard disks.
+  This value can be overridden from the boot command line using the 
+  'tags' option as follows (example):
+  'ncr53c8xx=tags:4/t2t3q16/t0u2q10' will set default queue depth to
+  4, set queue depth to 16 for target 2 and target 3 on controller 0
+  and set queue depth to 10 for target 0 / lun 2 on controller 1.
+
+  The normal answer therefore is to go with the default 8 and to use 
+  a boot command line option for devices that need to use a different 
+  command queue depth.
+
+  There is no safe option other than using good SCSI devices.
+
+maximum number of queued commands
+CONFIG_SCSI_NCR53C8XX_MAX_TAGS
+  This option allows you to specify the maximum number of commands
+  that can be queued to any device, when tagged command queuing is
+  possible. The default value is 32. Minimum is 2, maximum is 64 for
+  the generic NCR53C8XX driver and 255 for the SYM53C8XX driver.
+  
+  Modern hard disks are able to support 64 tags and even more, but 
+  do not seem to be faster when more than 32 tags are being used.
+  
+  So, the normal answer here is to go with the default value 32 unless
+  you are using very large hard disks with large cache (>= 1 MB) that
+  are able to take advantage of more than 32 tagged commands.
+
+  There is no safe option and the default answer is recommended.
+
+assume boards are SYMBIOS compatible
+CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT
+  This option allows you to enable some features depending on GPIO
+  wiring. These General Purpose Input/Output pins can be used for
+  vendor specific features or implementation of the standard SYMBIOS
+  features. Genuine SYMBIOS controllers use GPIO0 in output for
+  controller LED and GPIO3 bit as a flag indicating
+  singled-ended/differential interface. The Tekram DC-390U/F boards
+  uses a different GPIO wiring.
+  
+  Your answer to this question is ignored if all your controllers have
+  NVRAM, since the driver is able to detect the board type from the
+  NVRAM format.
+
+  If all the controllers in your system are genuine SYMBIOS boards or
+  use BIOS and drivers from SYMBIOS, you would want to say Y here,
+  otherwise N. N is the safe answer.
+
+enable profiling statistics gathering
+CONFIG_SCSI_NCR53C8XX_PROFILE
+  This option allows you to enable profiling information gathering.
+  These statistics are not very accurate due to the low frequency 
+  of the kernel clock (100 Hz on i386) and have performance impact 
+  on systems that use very fast devices.
+
+  The normal answer therefore is N.
+
+include support for the NCR PQS/PDS SCSI card
+CONFIG_SCSI_NCR53C8XX_PQS_PDS
+  Say Y here if you have a special SCSI adapter produced by NCR
+  corporation called a PCI Quad SCSI or PCI Dual SCSI. You do not need
+  this if you do not have one of these adapters. However, since this
+  device is detected as a specific PCI device, this option is quite
+  safe.
+
+  The common answer here is N, but answering Y is safe.
+
+IBMMCA SCSI support
+CONFIG_SCSI_IBMMCA
+  This is support for the IBM SCSI adapter found in many of the PS/2
+  series computers. These machines have an MCA bus, so you need to
+  answer Y to "MCA support" as well and read Documentation/mca.txt.
+
+  If the adapter isn't found during boot (a common problem for models
+  56, 57, 76, and 77) you'll need to use the 'ibmmcascsi=<pun>' kernel
+  option, where <pun> is the id of the SCSI subsystem (usually 7, but
+  if that doesn't work check your reference diskette). Owners of model
+  95 with a LED-matrix-display can in addition activate some activity
+  info like under OS/2, but more informative, by setting
+  'ibmmcascsi=display' as an additional kernel parameter. Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel. The lilo procedure is also explained in
+  the SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ibmmca.o.
+
+Standard SCSI-order
+CONFIG_IBMMCA_SCSI_ORDER_STANDARD
+  In the PC-world and in most modern SCSI-BIOS-setups, SCSI-hard disks
+  are assigned to the drive letters, starting with the lowest SCSI-id
+  (physical number -- pun) to be drive C:, as seen from DOS and
+  similar operating systems. When looking into papers describing the
+  ANSI-SCSI-standard, this assignment of drives appears to be wrong.
+  The SCSI-standard follows a hardware-hierarchy which says that id 7
+  has the highest priority and id 0 the lowest. Therefore, the host
+  adapters are still today everywhere placed as SCSI-id 7 by default.
+  In the SCSI-standard, the drive letters express the priority of the
+  disk. C: should be the hard disk, or a partition on it, with the
+  highest priority. This must therefore be the disk with the highest
+  SCSI-id (e.g. 6) and not the one with the lowest! IBM-BIOS kept the
+  original definition of the SCSI-standard as also industrial- and
+  process-control-machines, like VME-CPUs running under realtime-OSs
+  (e.g. LynxOS, OS9) do.
+
+  If you like to run Linux on your MCA-machine with the same
+  assignment of hard disks as seen from e.g. DOS or OS/2 on your
+  machine, which is in addition conformant to the SCSI-standard, you
+  must say Y here. This is also necessary for MCA-Linux users who want
+  to keep downward compatibility to older releases of the
+  IBM-MCA-SCSI-driver (older than driver-release 2.00 and older than
+  June 1997).
+
+  If you like to have the lowest SCSI-id assigned as drive C:, as
+  modern SCSI-BIOSes do, which does not conform to the standard, but
+  is widespread and common in the PC-world of today, you must say N
+  here. If unsure, say Y.
+
+Reset SCSI-devices at boot time
+CONFIG_IBMMCA_SCSI_DEV_RESET
+  By default, SCSI-devices are reset when the machine is powered on.
+  However, some devices exist, like special-control-devices,
+  SCSI-CNC-machines, SCSI-printer or scanners of older type, that do
+  not reset when switched on. If you say Y here, each device connected
+  to your SCSI-bus will be issued a reset-command after it has been
+  probed, while the kernel is booting. This may cause problems with
+  more modern devices, like hard disks, which do not appreciate these
+  reset commands, and can cause your system to hang. So say Y only if
+  you know that one of your older devices needs it; N is the safe
+  answer.
+
+NCR 53C9x MCA support
+CONFIG_SCSI_MCA_53C9X
+  Some Microchannel machines, notably the NCR 35xx line, use a SCSI
+  controller based on the NCR 53C94.  This driver will allow use of
+  the controller on the 3550, and very possibly others.   
+
+  If you want to compile this as a module (= code which can be
+  inserted and removed from the running kernel whenever you want), say
+  M here and read Documentation/modules.txt. The module will be called
+  mca_53c9x.o.
+ 
+Always IN2000 SCSI support
+CONFIG_SCSI_IN2000
+  This is support for an ISA bus SCSI host adapter. You'll find more
+  information in drivers/scsi/in2000.readme. If it doesn't work out of
+  the box, you may have to change the jumpers for IRQ or address
+  selection. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called in2000.o.
+
+Initio 91XXU(W) SCSI support
+CONFIG_SCSI_INITIO
+  This is support for the Initio 91XXU(W) SCSI host adapter.
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called initio.o
+
+PAS16 SCSI support
+CONFIG_SCSI_PAS16
+  This is support for a SCSI host adapter. It is explained in section
+  3.10 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/pas16.h.
+  
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pas16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Initio INI-A100U2W SCSI support
+CONFIG_SCSI_INIA100
+  This is support for the Initio INI-A100U2W SCSI host adapter.
+  Please read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be 
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called a100u2w.o
+
+PCI2000 support
+CONFIG_SCSI_PCI2000
+  This is support for the PCI2000I EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called pci2000.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PCI2220i support
+CONFIG_SCSI_PCI2220I
+  This is support for the PCI2220i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called pci2220i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PSI240i support
+CONFIG_SCSI_PSI240I
+  This is support for the PSI240i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available via FTP
+  (user: anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module called psi240i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Qlogic FAS SCSI support
+CONFIG_SCSI_QLOGIC_FAS
+  This is a driver for the ISA, VLB, and PCMCIA versions of the Qlogic
+  FastSCSI! cards as well as any other card based on the FASXX chip
+  (including the Control Concepts SCSI/IDE/SIO/PIO/FDC cards).
+
+  This driver does NOT support the PCI versions of these cards. The
+  PCI versions are supported by the Qlogic ISP driver ("Qlogic ISP
+  SCSI support"), below.
+
+  Information about this driver is contained in
+  drivers/scsi/README.qlogicfas. You should also read the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfas.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP SCSI support (EXPERIMENTAL)
+CONFIG_SCSI_QLOGIC_ISP
+  This driver works for all QLogic PCI SCSI host adapters (IQ-PCI,
+  IQ-PCI-10, IQ_PCI-D) except for the PCI-basic card. (This latter
+  card is supported by the "AM53/79C974 PCI SCSI" driver). 
+
+  If you say Y here, make sure to choose "BIOS" at the question "PCI
+  access mode".
+
+  Please read the file drivers/scsi/README.qlogicisp. You should also
+  read the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicisp.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP FC SCSI support
+CONFIG_SCSI_QLOGIC_FC
+  This is a driver for the QLogic ISP2100 SCSI-FCP host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfc.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Compaq 64-bit / 66MHz PCI Fibre Channel Host Adapter
+CONFIG_SCSI_CPQFCTS
+  This driver supports Compaq HBA part #120186-B21, the non-
+  intelligent Tachyon TL/TS (HPFC-5166A/1.2) based adapter.
+  Kernel linked or kernel module, SMP support.  Information at
+  /proc/scsi/cpqfcTS/*
+  
+  Only supports FC-AL (non-loop mode not supported). Supports Fabric 
+  (FL_Port, public device); tested on Brocade switches.  Supports hot-
+  plug of new devices and movement of devices across ports (i.e.,
+  dynamic re-assignment of 24-bit FC port_id).
+
+  Tested on Compaq RA4x00 (f/w ver 2.40 or newer), RA8000, with Vixel
+  Rapport 1000 (7-port non-managed), Gadzoox 12-port, Gadzoox Capellix
+  3000, Brocade 2010, 2400, 2800.  Selective Storage 
+  Presentation (SSP) on RA4x00 f/w 2.54 (no redundancy).
+
+Seagate ST-02 and Future Domain TMC-8xx SCSI support
+CONFIG_SCSI_SEAGATE
+  These are 8-bit SCSI controllers; the ST-01 is also supported by
+  this driver. It is explained in section 3.9 of the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/seagate.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called seagate.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Trantor T128/T128F/T228 SCSI support
+CONFIG_SCSI_T128
+  This is support for a SCSI host adapter. It is explained in section
+  3.11 of the SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/t128.h. Note that Trantor was purchased by Adaptec, and
+  some former Trantor products are being sold under the Adaptec name.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called t128.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UltraStor SCSI support
+CONFIG_SCSI_ULTRASTOR
+  This is support for the UltraStor 14F, 24F and 34F SCSI-2 host
+  adapter family. This driver is explained in section 3.12 of the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/ultrastor.h.
+  
+  Note that there is also another driver for the same hardware:
+  "UltraStor 14F/34F support", above.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ultrastor.o. 
+
+7000FASST SCSI support
+CONFIG_SCSI_7000FASST
+  This driver supports the Western Digital 7000 SCSI host adapter
+  family. Some information is in the source: drivers/scsi/wd7000.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called wd7000.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+ACARD SCSI support
+CONFIG_SCSI_ACARD
+  This driver supports the ACARD 870U/W SCSI host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called atp870u.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA ISA/EISA/PCI (DPT and generic EATA/DMA-compliant boards) support
+CONFIG_SCSI_EATA
+  This driver supports all EATA/DMA-compliant SCSI host adapters. DPT
+  ISA and all EISA i/o addresses are probed looking for the "EATA"
+  signature. If you chose "BIOS" at the question "PCI access mode",
+  the addresses of all the PCI SCSI controllers reported by the PCI
+  subsystem are probed as well.
+
+  You want to read the start of drivers/scsi/eata.c and the
+  SCSI-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that there is also another driver for the same hardware
+  available: "EATA-DMA support". You should say Y to only one of them.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata.o.
+
+enable tagged command queuing
+CONFIG_SCSI_EATA_TAGGED_QUEUE
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Most EATA adapters negotiate
+  this feature automatically with the device, even if your answer is
+  N. The safe answer is N.
+        
+enable elevator sorting
+CONFIG_SCSI_EATA_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_EATA_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 16
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 62. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+NCR53c406a SCSI support
+CONFIG_SCSI_NCR53C406A
+  This is support for the NCR53c406a SCSI host adapter. For user
+  configurable parameters, check out drivers/scsi/NCR53c406.c in the
+  kernel source. Also read the SCSI-HOWTO, available via FTP (user:
+  anonymous) at ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called NCR53c406.o.
+
+Symbios Logic sym53c416 support
+CONFIG_SCSI_SYM53C416
+  This is support for the sym53c416 SCSI host adapter, the SCSI
+  adapter that comes with some HP scanners. This driver requires that
+  the sym53c416 is configured first using some sort of pnp
+  configuration program (e.g. isapnp) or by a PnP aware BIOS. If you
+  are using isapnp then you need to compile this driver as a module
+  and then load it using insmod after isapnp has run. The parameters
+  of the configured card(s) should be passed to the driver. The format
+  is:
+
+    insmod sym53c416 sym53c416=<base>,<irq> [sym53c416_1=<base>,<irq>]
+
+  There is support for up to four adapters. If you want to compile
+  this driver as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  sym53c416.o. 
+
+Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support
+CONFIG_SCSI_DC390T
+  This driver supports PCI SCSI host adapters based on the Am53C974A
+  chip, e.g. Tekram DC390(T), DawiControl 2974 and some onboard
+  PCscsi/PCnet (Am53/79C974) solutions.
+
+  Documentation can be found in linux/drivers/scsi/README.tmscsim.
+  
+  Note that this driver does NOT support Tekram DC390W/U/F, which are
+  based on NCR/Symbios chips. Use "NCR53C8XX SCSI support" for those.
+  Also note that there is another generic Am53C974 driver,
+  "AM53/79C974 PCI SCSI support" below. You can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called tmscsim.o.
+
+Omit support for other Am53/79C974 based SCSI adapters
+CONFIG_SCSI_DC390T_NOGENSUPP
+  If you say N here, the DC390(T) SCSI driver relies on the DC390
+  EEPROM to get initial values for its settings, such as speed,
+  termination, etc. If it can't find this EEPROM, it will use defaults
+  or the user supplied boot/module parameters. For details on driver
+  configuration see linux/drivers/scsi/README.tmscsim.
+
+  If you say Y here and if no EEPROM is found, the driver gives up and
+  thus only supports Tekram DC390(T) adapters. This can be useful if
+  you have a DC390(T) and another Am53C974 based adapter, which, for
+  some reason, you want to drive with the other AM53C974 driver.
+
+  If unsure, say N.
+
+AM53/79C974 PCI SCSI support
+CONFIG_SCSI_AM53C974
+  This is support for the AM53/79C974 SCSI host adapters. Please read
+  drivers/scsi/README.AM53C974 for details. Also, the SCSI-HOWTO,
+  available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, is for you.
+
+  Note that there is another driver for AM53C974 based adapters:
+  "Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support", above. You
+  can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called AM53C974.o.
+
+AMI MegaRAID support
+CONFIG_SCSI_MEGARAID
+  This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
+  and 467 SCSI host adapters. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called megaraid.o.
+
+###
+### What is this?
+###
+#Concurrent IO commands on MegaRAID
+#CONFIG_MEGARAID_MULTI_IO
+
+GDT SCSI Disk Array Controller support
+CONFIG_SCSI_GDTH
+  This is a driver for all SCSI Disk Array Controllers (EISA/ISA/PCI) 
+  manufactured by ICP vortex. It is documented in the kernel source in
+  drivers/scsi/gdth.c and drivers/scsi/gdth.h. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+IOMEGA parallel port (ppa - older drives)
+CONFIG_SCSI_PPA
+  This driver supports older versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say N here and Y to "IOMEGA parallel port (imm -
+  newer drives)", below.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called ppa.o. 
+
+IOMEGA parallel port (imm - newer drives)
+CONFIG_SCSI_IMM
+  This driver supports newer versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say Y here; if you have an older ZIP drive, say N
+  here and Y to "IOMEGA Parallel Port (ppa - older drives)", above.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called imm.o. 
+
+Force the Iomega ZIP drivers to use EPP-16
+CONFIG_SCSI_IZIP_EPP16
+  EPP (Enhanced Parallel Port) is a standard for parallel ports which
+  allows them to act as expansion buses that can handle up to 64
+  peripheral devices.
+
+  Some parallel port chipsets are slower than their motherboard, and
+  so we have to control the state of the chipset's FIFO queue every
+  now and then to avoid data loss. This will be done if you say Y
+  here.
+  
+  Generally, saying Y is the safe option and slows things down a bit.
+
+Assume slow parallel port control register
+CONFIG_SCSI_IZIP_SLOW_CTR
+  Some parallel ports are known to have excessive delays between
+  changing the parallel port control register and good data being
+  available on the parallel port data/status register. This option
+  forces a small delay (1.0 usec to be exact) after changing the
+  control register to let things settle out. Enabling this option may
+  result in a big drop in performance but some very old parallel ports
+  (found in 386 vintage machines) will not work properly.
+
+  Generally, saying N is fine.
+
+SCSI Debug host simulator.
+CONFIG_SCSI_DEBUG
+  This is a host adapter simulator that can be programmed to simulate
+  a large number of conditions that could occur on a real bus. The
+  advantage is that many hard to reproduce problems can be tested in a
+  controlled environment where there is reduced risk of losing
+  important data. This is primarily of use to people trying to debug
+  the middle and upper layers of the SCSI subsystem. If unsure, say N.
+
+Fibre Channel support
+CONFIG_FC4
+  This is an experimental support for storage arrays connected to
+  the system using Fibre Optic and the "X3.269-199X Fibre Channel
+  Protocol for SCSI" specification. You'll also need the generic SCSI
+  support, as well as the drivers for the storage array itself and
+  for the interface adapter such as SOC. This subsystem could even
+  serve for IP networking, with some code extensions.
+
+  If unsure, say N.
+
+Sun SOC
+CONFIG_FC4_SOC
+  Serial Optical Channel is an interface card with one or two Fibre
+  Optic ports, each of which can be connected to a disk array. Only
+  the SBus incarnation of the adapter is supported at the moment.
+
+SparcSTORAGE Array 100 and 200 series
+CONFIG_SCSI_PLUTO
+  If you never bought a disk array made by Sun, go with N. 
+
+AcornSCSI support
+CONFIG_SCSI_ACORNSCSI_3
+  This enables support for the Acorn SCSI card (aka30). If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Acorn SCSI tagged queue support
+CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE
+  Say Y here to enable tagged queuing support on the Acorn SCSI card.
+
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Some SCSI devices don't
+  implement this properly, so the safe answer is N.
+
+Acorn SCSI Synchronous transfers support
+CONFIG_SCSI_ACORNSCSI_SYNC
+  Say Y here to enable synchronous transfer negotiation with all
+  targets on the Acorn SCSI card.
+
+  In general, this improves performance; however some SCSI devices
+  don't implement it properly, so the safe answer is N.
+
+Oak SCSI support
+CONFIG_SCSI_OAK1
+  This enables support for the Oak SCSI card. If you have an Acorn
+  system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI I support
+CONFIG_SCSI_CUMANA_1
+  This enables support for the Cumana SCSI I card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI II support
+CONFIG_SCSI_CUMANA_2
+  This enables support for the Cumana SCSI II card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+EcoSCSI support
+CONFIG_SCSI_ECOSCSI
+  This enables support for the EcoSCSI card -- a small card that sits
+  in the Econet socket. If you have an Acorn system with one of these,
+  say Y. If unsure, say N.
+
+EESOX SCSI support
+CONFIG_SCSI_EESOXSCSI
+  This enables support for the EESOX SCSI card. If you have an Acorn
+  system with one of these, say Y, otherwise say N.
+
+Powertec SCSI support
+CONFIG_SCSI_POWERTECSCSI
+  This enables support for the Powertec SCSI card on Acorn systems. If
+  you have one of these, say Y. If unsure, say N.
+
+Network device support?
+CONFIG_NETDEVICES
+  You can say N here if you don't intend to connect your Linux box to
+  any other computer at all or if all your connections will be over a
+  telephone line with a modem either via UUCP (UUCP is a protocol to
+  forward mail and news between unix hosts over telephone lines; read
+  the UUCP-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO) or dialing up a shell
+  account or a BBS, even using term (term is a program which gives you
+  almost full Internet connectivity if you have a regular dial up
+  shell account on some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)).
+
+  You'll have to say Y if your computer contains a network card that
+  you want to use under Linux (make sure you know its name because you
+  will be asked for it and read the Ethernet-HOWTO (especially if you
+  plan to use more than one network card under Linux), available from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini) or if you want to
+  use SLIP (Serial Line Internet Protocol is the protocol used to send
+  Internet traffic over telephone lines or null modem cables) or CSLIP
+  (compressed SLIP) or PPP (Point to Point Protocol, a better and
+  newer replacement for SLIP) or PLIP (Parallel Line Internet Protocol
+  is mainly used to create a mini network by connecting the parallel
+  ports of two local machines) or AX.25/KISS (protocol for sending
+  Internet traffic over amateur radio links).
+
+  Make sure to read the NET-3-HOWTO. Eventually, you will have to read
+  Olaf Kirch's excellent and free book "Network Administrator's
+  Guide", to be found in ftp://metalab.unc.edu/pub/Linux/docs/LDP. If
+  unsure, say Y.
+
+Dummy net driver support
+CONFIG_DUMMY
+  This is essentially a bit-bucket device (i.e. traffic you send to
+  this device is consigned into oblivion) with a configurable IP
+  address. It is most commonly used in order to make your currently
+  inactive SLIP address seem like a real address for local programs.
+  If you use SLIP or PPP, you might want to say Y here. Read about it
+  in the Network Administrator's Guide, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/LDP. Since this
+  thing often comes in handy, the default is Y. It won't enlarge your
+  kernel either. What a deal.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called dummy.o. If you want to use more than one dummy device at a
+  time, you need to compile this driver as a module. Instead of
+  'dummy', the devices will then be called 'dummy0', 'dummy1' etc.
+
+SLIP (serial line) support
+CONFIG_SLIP
+  Say Y if you intend to use SLIP or CSLIP (compressed SLIP) to
+  connect to your Internet service provider or to connect to some
+  other local Unix box or if you want to configure your Linux box as a
+  Slip/CSlip server for other people to dial in. SLIP (Serial Line
+  Internet Protocol) is a protocol used to send Internet traffic over
+  serial connections such as telephone lines or null modem cables;
+  nowadays, the protocol PPP is more commonly used for this same
+  purpose.
+
+  Normally, your access provider has to support SLIP in order for you
+  to be able to use it, but there is now a SLIP emulator called SLiRP
+  around (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ) which
+  allows you to use SLIP over a regular dial up shell connection. If
+  you plan to use SLiRP, make sure to say Y to CSLIP, below. The
+  NET-3-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, explains how to
+  configure SLIP. Note that you don't need this option if you just
+  want to run term (term is a program which gives you almost full
+  Internet connectivity if you have a regular dial up shell account on
+  some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)). SLIP support will enlarge
+  your kernel by about 4 KB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  slip.o.
+
+CSLIP compressed headers
+CONFIG_SLIP_COMPRESSED
+  This protocol is faster than SLIP because it uses compression on the
+  TCP/IP headers (not on the data itself), but it has to be supported
+  on both ends. Ask your access provider if you are not sure and
+  answer Y, just in case. You will still be able to use plain SLIP. If
+  you plan to use SLiRP, the SLIP emulator (available via FTP (user:
+  anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/) which allows
+  you to use SLIP over a regular dial up shell connection, you
+  definitely want to say Y here. The NET-3-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO,
+  explains how to configure CSLIP. This won't enlarge your kernel.
+
+Keepalive and linefill
+CONFIG_SLIP_SMART
+  Adds additional capabilities to the SLIP driver to support the
+  RELCOM line fill and keepalive monitoring. Ideal on poor quality
+  analogue lines.
+
+Six bit SLIP encapsulation
+CONFIG_SLIP_MODE_SLIP6
+  Just occasionally you may need to run IP over hostile serial
+  networks that don't pass all control characters or are only seven
+  bit. Saying Y here adds an extra mode you can use with SLIP:
+  "slip6". In this mode, SLIP will only send normal ASCII symbols over
+  the serial device. Naturally, this has to be supported at the other
+  end of the link as well. It's good enough, for example, to run IP
+  over the async ports of a Camtec JNT Pad. If unsure, say N.
+
+PPP (point-to-point) support
+CONFIG_PPP
+  PPP (Point to Point Protocol) is a newer and better SLIP. It serves
+  the same purpose: sending Internet traffic over telephone (and other
+  serial) lines. Ask your access provider if they support it, because
+  otherwise you can't use it (not quite true any more: the free
+  program SLiRP can emulate a PPP line if you just have a regular dial
+  up shell account on some UNIX computer; get it via FTP (user:
+  anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/). Note that
+  you don't need "PPP support" if you just want to run term (term is a
+  program which gives you almost full Internet connectivity if you
+  have a regular dial up shell account on some Internet connected UNIX
+  computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html (to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape)).
+
+  To use PPP, you need an additional program called pppd as described
+  in Documentation/networking/ppp.txt and in the PPP-HOWTO, available
+  from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If you upgrade
+  from an older kernel, you might need to upgrade pppd as well. The
+  PPP option enlarges your kernel by about 16 KB.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you said Y to "Version information on all symbols" above, then
+  you cannot compile the PPP driver into the kernel; you can then only
+  compile it as a module. The module will be called ppp.o. If you want
+  to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. Note that, no matter what
+  you do, the BSD compression code (used to compress the IP packets
+  sent over the serial line; has to be supported at the other end as
+  well) will always be compiled as a module; it is called bsd_comp.o
+  and will show up in the directory modules once you have said "make
+  modules". If unsure, say N.
+
+Wireless LAN (non-hamradio)
+CONFIG_NET_RADIO
+  Support for wireless LANs and everything having to do with radio,
+  but not with amateur radio. Note that the answer to this question
+  won't directly affect the kernel: saying N will just cause this
+  configure script to skip all the questions about radio
+  interfaces. 
+
+  Some user-level drivers for scarab devices which don't require
+  special kernel support are available via FTP (user: anonymous) from
+  ftp://shadow.cabi.net/pub/Linux.
+
+STRIP (Metricom Starmode radio IP)
+CONFIG_STRIP
+  Say Y if you have a Metricom radio and intend to use Starmode Radio
+  IP. STRIP is a radio protocol developed for the MosquitoNet project
+  (On the WWW at http://mosquitonet.stanford.edu/; to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) to send Internet traffic using
+  Metricom radios. Metricom radios are small, battery powered,
+  100kbit/sec packet radio transceivers, about the size and weight of
+  a cellular telephone. (You may also have heard them called
+  "Metricom modems" but we avoid the term "modem" because it misleads
+  many people into thinking that you can plug a Metricom modem into a
+  phone line and use it as a modem.)  
+
+  You can use STRIP on any Linux machine with a serial port, although
+  it is obviously most useful for people with laptop computers. If you
+  think you might get a Metricom radio in the future, there is no harm
+  in saying Y to STRIP now, except that it makes the kernel a bit
+  bigger. 
+
+  You can also compile this as a module ( = code which can be inserted
+  in and removed from the running kernel whenever you want), say M
+  here and read Documentation/modules.txt. The module will be called
+  strip.o.
+
+AT&T WaveLAN & DEC RoamAbout DS support
+CONFIG_WAVELAN
+  The Lucent WaveLAN (formerly NCR and AT&T; or DEC RoamAbout DS) is
+  a Radio LAN (wireless Ethernet-like Local Area Network) using the
+  radio frequencies 900 MHz and 2.4 GHz.
+  
+  This driver support the ISA version of the WaveLAN card. A separate
+  driver for the PCMCIA (PC-card) hardware is available in David
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for
+  location).
+
+  If you want to use an ISA WaveLAN card under Linux, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Some more specific
+  information is contained in Documentation/networking/wavelan.txt and
+  in the source code drivers/net/wavelan.p.h.
+
+  You will also need the wireless tools package available from
+  ftp://ftp.inka.de/pub/comp/Linux/networking/NetTools/contrib/.
+  Please read the man pages contained therein.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wavelan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Aironet Arlan 655 & IC2200 DS support
+CONFIG_ARLAN
+  Aironet makes Arlan. www.aironet.com. Uses www.Telxon.com chip, which is
+  used on several similar cards. Driver is tested on 655 and IC2200 series. 
+  Look for http://www.ylenurme.ee/~elmer/655/ for latest information. 
+  Driver is build as two modules, arlan and arlan-proc. The later is /proc
+  interface and not needed most of time.
+  On some computers the card ends up in non-valid state after some time.
+  Use a ping-reset script to clear it.
+   
+
+LAPB over Ethernet driver
+CONFIG_LAPBETHER
+  This is a driver for a pseudo device (typically called /dev/lapb0)
+  which allows you to open an LAPB point-to-point connection to some
+  other computer on your Ethernet network. In order to do this, you
+  need to say Y or M to the driver for your Ethernet card as well as
+  to "LAPB Data Link Driver". 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called lapbether.o. If unsure, say N.
+
+X.25 async driver
+CONFIG_X25_ASY
+  This is a driver for sending and receiving X.25 frames over regular
+  asynchronous serial lines such as telephone lines equipped with
+  ordinary modems. Experts should note that this driver doesn't
+  currently comply with the asynchronous HDLS framing protocols in
+  CCITT recommendation X.25. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25_asy.o. If unsure, say N.
+
+Shortwave radio modem driver
+CONFIG_HFMODEM
+  This experimental driver is used by a package (to be released)
+  that implements the shortwave radio protocols RTTY, Sitor (Amtor),
+  Pactor 1 and GTOR using a standard PC sound card. If unsure,
+  say N.
+
+Shortwave radio modem driver support for Sound Blaster and compatible cards
+CONFIG_HFMODEM_SBC
+  This option enables the hfmodem driver to use Sound Blaster and
+  compatible cards. It requires a 16bit capable card, i.e.
+  SB16 or better, or ESS1688 or newer.
+
+Shortwave radio modem driver support for WSS and Crystal cards
+CONFIG_HFMODEM_WSS
+  This option enables the hfmodem driver to use WindowsSoundSystem
+  compatible cards. These cards feature a codec chip from either
+  Analog Devices (such as AD1848, AD1845) or Crystal Semiconductors
+  (such as CS4248, CS423x).
+
+PLIP (parallel port) support
+CONFIG_PLIP
+  PLIP (Parallel Line Internet Protocol) is used to create a
+  reasonably fast mini network consisting of two (or, rarely, more)
+  local machines. A PLIP link from a Linux box is a popular means to
+  install a Linux distribution on a machine which doesn't have a CDROM
+  drive (a minimal system has to be transferred with floppies first).
+  The kernels on both machines need to have this PLIP option enabled
+  for this to work.
+
+  The PLIP driver has two modes, mode 0 and mode 1. The parallel ports
+  (the connectors at the computers with 25 holes) are connected with
+  "null printer" or "Turbo Laplink" cables which can transmit 4 bits
+  at a time (mode 0) or with special PLIP cables, to be used on
+  bidirectional parallel ports only, which can transmit 8 bits at a
+  time (mode 1); you can find the wiring of these cables in
+  Documentation/networking/PLIP.txt. The cables can be up to 15m long.
+  Mode 0 works also if one of the machines runs DOS/Windows and has
+  some PLIP software installed, e.g. the Crynwr PLIP packet driver
+  (http://oak.oakland.edu/simtel.net/msdos/pktdrvr-pre.html; to browse
+  the WWW, you need to have access to a machine on the Internet that
+  has a program like lynx or netscape) and winsock or NCSA's telnet.
+
+  If you want to use PLIP, say Y and read the PLIP mini-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini as well as the
+  NET-3-HOWTO in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that
+  the PLIP protocol was changed and this PLIP driver won't work
+  together with the PLIP support in Linux versions 1.0.x. This option
+  enlarges your kernel by about 8 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  plip.o. If unsure, say Y or M, in case you buy a laptop later.
+
+EQL (serial line load balancing) support
+CONFIG_EQUALIZER
+  If you have two serial connections to some other computer (this
+  usually requires two modems and two telephone lines) and you use
+  SLIP (the protocol for sending Internet traffic over telephone
+  lines) or PPP (a better SLIP) on them, you can make them behave like
+  one double speed connection using this driver. Naturally, this has
+  to be supported at the other end as well, either with a similar EQL
+  Linux driver or with a Livingston Portmaster 2e. 
+
+  Say Y if you want this and read Documentation/networking/eql.txt.
+  You may also want to read section 6.2 of the NET-3-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eql.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Ethertap network tap
+CONFIG_ETHERTAP
+  If you say Y here (and have said Y to "Kernel/User network link
+  driver", above) and create a character special file /dev/tap0 with
+  major number 36 and minor number 16 using mknod ("man mknod"), you
+  will be able to have a user space program read and write raw
+  Ethernet frames from/to that special file. tap0 can be configured
+  with ifconfig and route like any other Ethernet device but it is not
+  connected to any physical LAN; everything written by the user to
+  /dev/tap0 is treated by the kernel as if it had come in from a LAN
+  to the device tap0; everything the kernel wants to send out over the
+  device tap0 can instead be read by the user from /dev/tap0: the user
+  mode program replaces the LAN that would be attached to an ordinary
+  Ethernet device. Please read the file
+  Documentation/networking/ethertap.txt for more information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ethertap.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If you don't
+  know what to use this for, you don't need it.
+
+Sealevel Systems 4021 support
+CONFIG_SEALEVEL_4021
+  This is a driver for the Sealevel Systems ACB 56 serial I/O adapter.
+  
+  This driver can only be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to do that, say M here. The module will be called
+  sealevel.o.
+
+SyncLink HDLC/SYNCPPP support
+CONFIG_SYNCLINK_SYNCPPP
+  Enables HDLC/SYNCPPP support for the SyncLink WAN driver.
+  Normally the SyncLink WAN driver works with the main PPP
+  driver (ppp.c) and pppd program. HDLC/SYNCPPP support allows use
+  of the Cisco HDLC/PPP driver (syncppp.c).
+  The SyncLink WAN driver (in character devices) must also be enabled.
+
+Frame Relay (DLCI) support
+CONFIG_DLCI
+  This is support for the frame relay protocol; frame relay is a fast
+  low-cost way to connect to a remote Internet access provider or to
+  form a private wide area network. The one physical line from your
+  box to the local "switch" (i.e. the entry point to the frame relay
+  network, usually at the phone company) can carry several logical
+  point-to-point connections to other computers connected to the frame
+  relay network. For a general explanation of the protocol, check out
+  http://www.frforum.com/ on the WWW. (To browse the WWW, you need to
+  have access to a machine on the Internet that has a program like
+  lynx or netscape.) To use frame relay, you need supporting hardware
+  (called FRAD) and certain programs from the net-tools package as
+  explained in Documentation/networking/framerelay.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dlci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Max open DLCI
+CONFIG_DLCI_COUNT
+  This is the maximal number of logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) that
+  the driver can handle. The default is probably fine.
+
+Max DLCI per device
+CONFIG_DLCI_MAX
+  You can specify here how many logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) should be
+  handled by each of your hardware frame relay access devices. Go with
+  the default.
+
+Sangoma S502A FRAD support
+CONFIG_SDLA
+  Say Y here if you need a driver for the Sangoma S502A, S502E, and
+  S508 Frame Relay Access Devices. These are multi-protocol cards, but
+  only frame relay is supported by the driver at this time. Please
+  read Documentation/framerelay.txt. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sdla.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Acorn Econet/AUN protocols (EXPERIMENTAL)
+CONFIG_ECONET
+  Econet is a fairly old and slow networking protocol mainly used by
+  Acorn computers to access file and print servers. It uses native
+  Econet network cards. AUN is an implementation of the higher level
+  parts of Econet that runs over ordinary Ethernet connections, on
+  top of the UDP packet protocol, which in turn runs on top of the
+  Internet protocol IP.
+
+  If you say Y here, you can choose with the next two options whether
+  to send Econet/AUN traffic over a UDP Ethernet connection or over
+  a native Econet network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called econet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AUN over UDP
+CONFIG_ECONET_AUNUDP
+  Say Y here if you want to send Econet/AUN traffic over a UDP
+  connection (UDP is a packet based protocol that runs on top of the
+  Internet protocol IP) using an ordinary Ethernet network card.
+
+Native Econet
+CONFIG_ECONET_NATIVE
+  Say Y here if you have a native Econet network card installed in
+  your computer.
+
+WAN Router
+CONFIG_WAN_ROUTER
+  Wide Area Networks (WANs), such as X.25, frame relay and leased
+  lines, are used to interconnect Local Area Networks (LANs) over vast
+  distances with data transfer rates significantly higher than those
+  achievable with commonly used asynchronous modem connections.
+  Usually, a quite expensive external device called a `WAN router' is
+  needed to connect to a WAN.
+
+  As an alternative, WAN routing can be built into the Linux kernel.
+  With relatively inexpensive WAN interface cards available on the
+  market, a perfectly usable router can be built for less than half
+  the price of an external router. If you have one of those cards and
+  wish to use your Linux box as a WAN router, say Y here and also to
+  the WAN driver for your card, below. You will then need the
+  wan-tools package which is available via FTP (user: anonymous) from
+  ftp://ftp.sangoma.com. Read Documentation/networking/wan-router.txt
+  for more information.
+
+  The WAN routing support is only available as a module called
+  wanrouter.o ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Fast switching (read help!)
+CONFIG_NET_FASTROUTE
+  Saying Y here enables direct NIC-to-NIC (NIC = Network Interface
+  Card) data transfers, which is fast.
+
+    *** This option is NOT COMPATIBLE with several important ***
+    *** networking options: especially CONFIG*FIREWALL.      ***
+    *** Say N here if you intend to use Linux as a firewall. ***
+
+  However, it will work with all options in CONFIG_IP_ADVANCED_ROUTER
+  section (except for CONFIG_IP_ROUTE_TOS and CONFIG_IP_ROUTE_FWMARK).
+  At the moment, few devices support fast switching (tulip is one of
+  them, modified 8390 can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz).
+
+  If unsure, say N.
+
+
+Forwarding between high speed interfaces
+CONFIG_NET_HW_FLOWCONTROL
+  This option enables NIC (Network Interface Card) hardware throttling
+  during periods of extremal congestion. At the moment only a couple
+  of device drivers support it (really only one -- tulip, modified
+  8390 can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz).
+  Really, this option is applicable to any machine attached to a fast enough
+  network, and even a 10 Mb NIC is able to kill a not very slow box,
+  such as a 120MHz Pentium.
+
+  However, do not say Y here if you did not experience any serious
+  problems.
+
+CPU is too slow to handle full bandwidth
+CONFIG_CPU_IS_SLOW
+  If you suspect that your CPU is not fast enough to handle the
+  full bandwidth of your network connection, try saying Y here. If
+  unsure, say N.
+
+QoS and/or fair queueing
+CONFIG_NET_SCHED
+  When the kernel has several packets to send out over the network
+  devices, it has to make a decision which one to send first. This is
+  especially important if some of the network devices are real time
+  devices that need a certain minimum data flow rate. There are
+  several different algorithms for how to do this "fairly"; they are
+  called packet schedulers. If you want to stick to the default
+  scheduling algorithm, say N here. If you want to experiment with a
+  couple of different algorithms, say Y. You can then attach different
+  schedulers to different network devices. Currently, this is only
+  recommended for experts.
+
+  To administer these schedulers, you'll need the user-level utilities
+  from the package iproute2+tc at ftp://ftp.inr.ac.ru/ip-routing/
+
+  If you say Y here and to "/proc filesystem" below, you will be able
+  to read status information about priority schedulers from the file
+  /proc/net/psched.
+  
+  The available schedulers are listed in the following questions; you
+  can say Y to as many as you like. If unsure, say N now.
+
+CBQ packet scheduler
+CONFIG_NET_SCH_CBQ
+  Say Y here if you want to use the Class-Based Queueing (CBQ) packet
+  scheduling algorithm for some of your network devices. This
+  algorithm classifies the waiting packets into a tree-like hierarchy
+  of classes; the leaves of this tree are in turn scheduled by
+  separate algorithms (called "disciplines" in this context) which you
+  can choose below from among the various queueing algorithms. See the
+  top of net/sched/sch_cbq.c for references about the CBQ algorithm.
+
+  This code is also available as a module called sch_cbq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+CSZ packet scheduler
+CONFIG_NET_SCH_CSZ
+  Say Y here if you want to use the Clark-Shenker-Zhang (CSZ) packet
+  scheduling algorithm for some of your network devices. At the
+  moment, this is the only algorithm that can guarantee service for
+  real-time applications (see the top of net/sched/sch_csz.c for
+  details and references about the algorithm). 
+  
+  Note: this scheduler is currently broken.
+
+  This code is also available as a module called sch_csz.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+The simplest PRIO pseudo scheduler
+CONFIG_NET_SCH_PRIO
+  Say Y here if you want to use an n-band priority queue packet
+  "scheduler" for some of your network devices or as a leaf discipline
+  for the CBQ scheduling algorithm. 
+
+  This code is also available as a module called sch_prio.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+RED queue
+CONFIG_NET_SCH_RED
+  Say Y here if you want to use the Random Early Detection (RED)
+  packet scheduling algorithm for some of your network devices (see
+  the top of net/sched/sch_red.c for details and references about the
+  algorithm). 
+
+  This code is also available as a module called sch_red.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SFQ queue
+CONFIG_NET_SCH_SFQ
+  Say Y here if you want to use the Stochastic Fairness Queueing (SFQ)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_sfq.c for details and references about the SFQ
+  algorithm). 
+
+  This code is also available as a module called sch_sfq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TEQL queue
+CONFIG_NET_SCH_TEQL
+  Say Y here if you want to use the True Link Equalizer (TLE) packet
+  scheduling algorithm for some of your network devices or as a leaf
+  discipline for the CBQ scheduling algorithm. This queueing
+  discipline allows the combination of several physical devices into
+  one virtual device. (see the top of net/sched/sch_teql.c for
+  details).
+
+  This code is also available as a module called sch_teql.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TBF queue
+CONFIG_NET_SCH_TBF
+  Say Y here if you want to use the Simple Token Bucket Filter (TBF)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_tbf.c for a description of the TBF algorithm). 
+
+  This code is also available as a module called sch_tbf.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+QoS support
+CONFIG_NET_QOS
+  Say Y here if you want to include Quality Of Service scheduling
+  features, which means that you will be able to request certain
+  rate-of-flow limits for your net devices.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about QoS support.
+
+Rate estimator
+CONFIG_NET_ESTIMATOR
+  In order for Quality of Service scheduling to work, the current
+  rate-of-flow for a network device has to be estimated; if you say Y
+  here, the kernel will do just that.
+
+Packet classifier API
+CONFIG_NET_CLS
+  The CBQ scheduling algorithm requires that network packets which are
+  scheduled to be sent out over a network device be classified in some
+  way. If you say Y here, you will get a choice of several different
+  packet classifiers with the following questions. 
+#
+# Routing tables based classifier
+# CONFIG_NET_CLS_ROUTE
+#
+# Firewall based classifier
+# CONFIG_NET_CLS_FW
+#
+# U32 classifier
+# CONFIG_NET_CLS_U32
+#
+# Special RSVP classifier
+# CONFIG_NET_CLS_RSVP
+#
+# Special RSVP classifier for IPv6
+# CONFIG_NET_CLS_RSVP6
+#
+# Ingres traffic policing
+# CONFIG_NET_CLS_POLICE
+###
+### Some expert please fill these in
+###
+
+Network code profiler
+CONFIG_NET_PROFILE
+  If you say Y here and to "/proc filesystem support" below, some
+  obscure and undocumented information about the network code's
+  performance will be written to /proc/net/profile. If you don't know
+  what it is about, you don't need it: say N.
+
+Comtrol Hostess SV-11 support
+CONFIG_HOSTESS_SV11
+  This is a network card for low speed synchronous serial links, at
+  up to 256Kbps. It supports both PPP and Cisco HDLC.
+  
+  At this point, the driver can only be compiled as a module.
+
+COSA/SRP sync serial boards support
+CONFIG_COSA
+  This is a driver for COSA and SRP synchronous serial boards. These
+  boards allow to connect synchronous serial devices (for example
+  base-band modems, or any other device with the X.21, V.24, V.35 or
+  V.36 interface) to your Linux box. The cards can work as the
+  character device, synchronous PPP network device, or the Cisco HDLC
+  network device.
+
+  To actually use the COSA or SRP board, you will need user-space
+  utilities for downloading the firmware to the cards and to set them
+  up. Look at the http://www.fi.muni.cz/~kas/cosa/ for more
+  information about the cards (including the pointer to the user-space
+  utilities). You can also read the comment at the top of the
+  drivers/net/cosa.c for details about the cards and the driver
+  itself.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cosa.o. For general information about
+  modules read Documentation/modules.txt.
+
+Lan Media sync serial boards support
+CONFIG_LANMEDIA
+  This is a driver for the following Lan Media family of serial boards.
+
+  LMC 1000 board allows you to connect synchronous serial devices (for
+  example base-band modems, or any other device with the X.21, V.24,
+  V.35 or V.36 interface) to your Linux box. 
+
+  LMC 1200 with on board DSU board allows you to connect your Linux
+  box dirrectly to a T1 or E1 circuit. 
+
+  LMC 5200 board provides a HSSI interface capable of runnig up to
+  52 mbits per second.
+
+  LMC 5245 board connects directly to a T3 circuit saving the
+  additional external hardware.
+
+  To change setting such as syncPPP vs cisco HDLC or clock source you
+  will need lmcctl.  It it available at ftp.lanmedia.com.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lmc.o. For general information about
+  modules read Documentation/modules.txt.
+
+Red Creek Hardware VPN (EXPERIMENTAL)
+CONFIG_RCPCI
+  This is a driver for hardware which provides a Virtual Private
+  Network (VPN). Say Y if you have it.
+
+  This code is also available as a module called rcpci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+  
+SBNI Leased Line Adapters
+CONFIG_SBNI
+  This is a driver for ISA SBNI12-xx cards that is a low cost
+  alternative to leased line modems. Say Y if you want to insert
+  driver into kernel or say M to compile driver as a module. 
+  
+  You can find more information and last versions of drivers and 
+  utilities at http://www.granch.ru. If you have any question you
+  can mail to sbni@granch.ru.
+  
+  Say N if unsure.
+  
+WAN Drivers
+CONFIG_WAN_DRIVERS
+  Say Y to this option if your Linux box contains a WAN card and you
+  are planning to use the box as a WAN ( = Wide Area Network) router 
+  ( = device used to interconnect local area networks over wide area
+  communication links, such as leased lines or public data networks,
+  e.g. X.25 or frame relay) and you will be offered a list of drivers
+  for WAN cards currently available. For more information, read
+  Documentation/networking/wan-router.txt.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about WAN card drivers. If unsure, say N.
+
+Sangoma WANPIPE(tm) multiprotocol cards
+CONFIG_VENDOR_SANGOMA
+  WANPIPE from Sangoma Technologies Inc. (http://www.sangoma.com; to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape) is a family of intelligent
+  multiprotocol WAN adapters with data transfer rates up to T1 (1.544
+  Mbps). They are also known as Synchronous Data Link Adapters (SDLA)
+  and designated S503 or S508. These cards support the X.25, Frame
+  Relay, PPP, Cisco HDLC protocols. The driver also offers API support
+  for protocols like HDLC (LAPB), HDLC Streaming and BiSync. 
+
+  If you have one or more of these cards, say M to this option; you
+  may then also want to read the file
+  Documentation/networking/wanpipe.txt. The next questions will ask
+  you about the protocols you want the driver to support.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wanpipe.o. For general information about
+  modules read Documentation/modules.txt.
+
+Maximum number of cards
+CONFIG_WANPIPE_CARDS
+  Enter number of WANPIPE adapters installed in your machine. The
+  driver can support up to 8 cards. You may enter more than you
+  actually have if you plan to add more cards in the future without
+  re-compiling the driver, but remember that in this case you'll waste
+  some kernel memory (about 1K per card).
+
+WANPIPE X.25 support
+CONFIG_WANPIPE_X25
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to an X.25 network. If you say N, the X.25 support will not be
+  included in the driver. The X.25 option is ONLY supported on S508
+  cards.
+
+WANPIPE Frame Relay support
+CONFIG_WANPIPE_FR
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a frame relay network. If you say N, the frame relay support will
+  not be included in the driver. The Frame Relay option is ONLY
+  supported on S508 cards.
+
+WANPIPE PPP support
+CONFIG_WANPIPE_PPP
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a leased line using Point-to-Point protocol (PPP). If you say N,
+  the PPP support will not be included in the driver. The PPP option
+  is ONLY supported on S508 cards.
+
+WANPIPE Cisco HDLC support
+CONFIG_WANPIPE_CHDLC
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a leased line using the Cisco HDLC protocol. This now supports
+  Dual Port Cisco HDLC on the S508 card ONLY. This support also allows
+  user to build applications using the HDLC streaming API. If you say
+  N, the Cisco HDLC support and HDLC streaming API will not be
+  included in the driver.
+
+MultiGate/COMX support
+CONFIG_COMX
+  Say Y if you want to use any board from the MultiGate (COMX) family. 
+  These boards are synchronous serial adapters for the PC, manufactured 
+  by ITConsult-Pro Co, Hungary. 
+
+  Read linux/Documentation/networking/comx.txt  for help on configuring 
+  and using COMX interfaces. Further info on these cards can be found at 
+  http://www.itc.hu or <info@itc.hu>.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx.o.
+
+COMX/CMX/HiCOMX board support
+CONFIG_COMX_HW_COMX
+  Hardware driver for the 'CMX', 'COMX' and 'HiCOMX' boards from the
+  MultiGate family. Say Y if you have one of these. 
+
+  You will need additional firmware to use these cards, which are
+  downloadable from ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-comx.o.
+
+LoCOMX board support
+CONFIG_COMX_HW_LOCOMX
+  Hardware driver for the 'LoCOMX' board from the MultiGate family. Say Y
+  if you have a board like this. 
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-locomx.o.
+
+MixCOM board support
+CONFIG_COMX_HW_MIXCOM
+  Hardware driver for the 'MixCOM' board from the MultiGate family. Say Y
+  if you have a board like this.
+
+  If you want to use the watchdog device on this card, you should
+  select it in the Watchdog Cards section of the Character Devices
+  configuration. The ISDN interface of this card is Teles 16.3 compatible,
+  you should enable it in the ISDN configuration menu. The driver for the 
+  flash ROM of this card is available separately on ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-mixcom.o.
+
+MultiGate Cisco-HDLC and synchronous PPP protocol support
+CONFIG_COMX_PROTO_PPP
+  Cisco-HDLC and synchronous PPP protocol driver for all MultiGate boards. 
+  Say Y if you want to use either protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called 
+  comx-proto-ppp.o.
+
+MultiGate LAPB protocol support
+CONFIG_COMX_PROTO_LAPB
+  LAPB protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-proto-lapb.o.
+
+MultiGate Frame Relay protocol support
+CONFIG_COMX_PROTO_FR
+  Frame Relay protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-proto-fr.o.
+
+Xpeed DSL NIC support
+CONFIG_XPEED
+  This driver supports Xpeed Inc. PCI network cards.
+  The following cards are supported with this driver:
+
+  Xpeed X200 IDSL NIC (http://www.xpeed.com/Products/x200/x200_c.html)
+  Xpeed X300 SDSL NIC (http://www.xpeed.com/Products/x300/x300_c.html)
+
+  This driver handles frame relay encapsulation of WAN link and presents
+  the card to the kernel as an ethernet-like device called dsl0, dsl1, etc.
+
+  Currently the driver only functions as a module. Detailed configuration
+  information can be found in Documentation/networking/README.xpeed
+
+Generic HDLC driver
+CONFIG_HDLC
+  Say Y to this option if your Linux box contains a WAN card supported
+  by this driver and you are planning to connect the box to a WAN
+  ( = Wide Area Network). You will need supporting software from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+
+  If unsure, say N here.
+
+SDL RISCom/N2 driver
+CONFIG_N2
+  This driver is for RISCom/N2 single or dual channel ISA cards
+  made by SDL Communications Inc.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+  Note that N2csu and N2dds cards are not supported by this driver.
+
+  If unsure, say N here.
+
+Moxa C101 driver
+CONFIG_C101
+  This driver is for C101 SuperSync ISA cards made by Moxa
+  Technologies Co., Ltd.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/
+
+  If unsure, say N here.
+
+SBE wanXL driver
+CONFIG_WANXL
+  This driver is for wanXL PCI cards made by SBE Inc.
+  If you have such a card, say Y here. This driver requires
+  Generic HDLC driver and its supporting utility available from
+  ftp://ftp.pm.waw.pl/pub/Linux/hdlc/ and a firmware available
+  from SBE Inc.
+
+  If unsure, say N here.
+
+Cyclades-PC300 support
+CONFIG_PC300
+  This is a driver for the Cyclades-PC300 synchronous communication
+  boards. These boards provide synchronous serial interfaces to your
+  Linux box. All protocols supported by the HDLC generic driver
+  (currently synchronous PPP, Cisco HDLC and Frame Relay) are available
+  by default. If you wish to support other protocols, please select one
+  of the available options below this one.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pc300.o.
+
+  If unsure, say N here.
+
+Cyclades-PC300 X.25 Support
+CONFIG_PC300_X25
+  Say Y to this option if you intend to use the Cyclades-PC300 to
+  provide X.25 interfaces to your Linux box.
+
+  IMPORTANT: Additional X.25 support must be enabled in the kernel
+  for this support to be functional (say Y to "CCITT X.25 Packet Layer"
+  and "LAPB Data Link Driver", in the "Networking Options"
+  configuration section).
+
+  If unsure, say N here.
+
+Ethernet (10 or 100Mbit)
+CONFIG_NET_ETHERNET
+  Ethernet (also called IEEE 802.3 or ISO 8802-2) is the most common
+  type of Local Area Network (LAN) in universities and companies.
+
+  Common varieties of Ethernet are: 10BASE-2 or Thinnet (10 Mbps over
+  coaxial cable, linking computers in a chain), 10BASE-T or twisted
+  pair (10 Mbps over twisted pair cable, linking computers to central
+  hubs), 10BASE-F (10 Mbps over optical fiber links, using hubs),
+  100BASE-TX (100 Mbps over two twisted pair cables, using hubs),
+  100BASE-T4 (100 Mbps over 4 standard voice-grade twisted pair
+  cables, using hubs), 100BASE-FX (100 Mbps over optical fiber links)
+  [the 100BASE varieties are also known as Fast Ethernet], and Gigabit
+  Ethernet (1 Gbps over optical fiber or short copper links).
+
+  If your Linux machine will be connected to an Ethernet and you have
+  an Ethernet network interface card (NIC) installed in your computer,
+  say Y here and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. You will
+  then also have to say Y to the driver for your particular NIC.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Ethernet network cards. If unsure, say N.
+
+Sun LANCE Ethernet support
+CONFIG_SUN_LANCE
+  This is support for lance Ethernet cards on Sun workstations such as
+  the SPARCstation IPC (any SPARC with a network interface 'le0' under
+  SunOS basically). 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lance.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sun Intel Ethernet support
+CONFIG_SUN_INTEL
+  This is support for the Intel Ethernet cards on some Sun
+  workstations (all those with a network interface 'ie0' under SunOS).
+
+Western Digital/SMC cards
+CONFIG_NET_VENDOR_SMC
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Western Digital cards. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+WD80*3 support
+CONFIG_WD80x3
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra MCA support
+CONFIG_ULTRAMCA
+  If you have a network (Ethernet) card of this type and are running
+  an MCA based system (PS/2), say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-mca.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra support
+CONFIG_ULTRA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+  
+  Important: There have been many reports that, with some motherboards
+  mixing an SMC Ultra and an Adaptec AHA154x SCSI card (or compatible,
+  such as some BusLogic models) causes corruption problems with many
+  operating systems. The Linux smc-ultra driver has a work-around for
+  this but keep it in mind if you have such a SCSI card and have
+  problems.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+SMC Ultra32 EISA support
+CONFIG_ULTRA32
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra32.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt as well
+  as Documentation/networking/net-modules.txt.
+
+SMC 9194 Support
+CONFIG_SMC9194
+  This is support for the SMC9xxx based Ethernet cards. Choose this
+  option if you have a DELL laptop with the docking station, or
+  another SMC9192/9194 based chipset. Say Y if you want it compiled
+  into the kernel, and read the file
+  Documentation/networking/smc9.txt and the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called smc9194.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+PCI NE2000 support
+CONFIG_NE2K_PCI
+  This driver is for NE2000 compatible PCI cards. It will not work
+  with ISA NE2000 cards (they have their own driver, "NE2000/NE1000
+  support" below). If you have a PCI NE2000 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2k-pci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+PCI DM9102 support
+CONFIG_DM9102
+  This driver is for DM9102 compatible PCI cards from Davicom 
+  (http://www.davicom.com.tw) 
+  If you have a PCI DM9102 network (Ethernet) card, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dmfe.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan (Micom) NI cards
+CONFIG_NET_VENDOR_RACAL
+  If you have a network (Ethernet) card belonging to this class, such
+  as the NI5010, NI5210 or NI6210, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about NI cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+NI5010 support
+CONFIG_NI5010
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that this is still
+  experimental code. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni5010.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI5210 support
+CONFIG_NI52
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni52.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI6510 support
+CONFIG_NI65
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni65.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+RealTek 8129/8139 (not 8019/8029!) support
+CONFIG_RTL8139
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the RTL8129 and RTL8139 chips. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called rtl8139.o.
+
+SiS 900/7016 support
+CONFIG_SIS900
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the SiS 900 and SiS 7016 chips. The SiS 900 core is also embedded in
+  SiS 630 and SiS 540 chipsets. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in   
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Please read 
+  Documentation/networking/sis900.txt and comments at the beginning
+  of drivers/net/sis900.c for more information.
+
+  This driver also supports AMD 79C901 HomePNA such that you can use
+  your phone line as network cable.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want), 
+  say M here and read Documentation/modules.txt. This is recommended. 
+  The module will be called sis900.o.
+
+Packet Engines Yellowfin Gigabit-NIC support
+CONFIG_YELLOWFIN
+  Say Y here if you have a Packet Engines G-NIC PCI Gigabit Ethernet
+  adapter. This adapter is used by the Beowulf Linux cluster project.
+  See http://cesdis.gsfc.nasa.gov/linux/drivers/yellowfin.html for
+  more information about this driver in particular and Beowulf in
+  general (to browse the WWW, you need to have access to a machine on
+  the Internet that has a program like lynx or netscape).
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called yellowfin.o.
+
+General Instruments Surfboard 1000
+CONFIG_NET_SB1000
+  This is a driver for the General Instrument SURFboard 1000 internal cable
+  modem.  This is an ISA card which is used by a number of cable TV companies
+  to provide cable modem access.  It's a one-way downstream-only cable modem,
+  meaning that your upstream net link is provided by your regular phone modem.
+
+  At present this driver only compiles as a module, so say M here if you
+  have this card.  Then read Documentation/networking/README.sb1000 for
+  information on how to use this module, as it needs special ppp scripts for
+  establishing a connection.  Further documentation and the necessary scripts
+  can be found at:
+
+  http://www.jacksonville.net/~fventuri/
+  http://home.adelphia.net/~siglercm/sb1000.html
+  http://linuxpower.cx/~cable/
+
+  If you don't have this card, of course say N.
+
+Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support
+CONFIG_ACENIC
+  Say Y here if you have an Alteon AceNIC or 3Com 3C985 PCI Gigabit
+  Ethernet adapter. The driver allows for using the Jumbo Frame
+  option (9000 bytes/frame) however it requires that your switches
+  can handle this as well. To enable Jumbo Frames, add `mtu 9000' to
+  your ifconfig line.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called acenic.o.
+
+SysKonnect SK-98xx support
+CONFIG_SK98LIN
+  Say Y here if you have a SysKonnect SK-98xx Gigabit Ethernet Server
+  Adapter. The following adapters are supported by this driver:
+  - SK-9841 (single link 1000Base-LX)
+  - SK-9842 (dual link   1000Base-LX)
+  - SK-9843 (single link 1000Base-SX)
+  - SK-9844 (dual link   1000Base-SX)
+  - SK-9821 (single link 1000Base-T)
+  - SK-9822 (dual link   1000Base-T)
+  The adapters support Jumbo Frames.
+  The dual link adapters support a link-failover feature.
+  Read Documentation/networking/sk98lin.txt for information about
+  optional driver parameters.
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called sk98lin.o.
+
+AMD LANCE and PCnet (AT1500 and NE2100) support
+CONFIG_LANCE
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Some LinkSys cards are
+  of this type.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called lance.o.
+
+3COM cards
+CONFIG_NET_VENDOR_3COM
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about 3COM cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+3c501 support
+CONFIG_EL1
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Also, consider buying a
+  new card, since the 3c501 is slow, broken, and obsolete: you will
+  have problems. Some people suggest to ping ("man ping") a nearby
+  machine every minute ("man cron") when using this card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c501.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c503 support
+CONFIG_EL2
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c503.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c505 support
+CONFIG_ELPLUS
+  Information about this network (Ethernet) card can be found in
+  Documentation/networking/3c505.txt. If you have a card of this type,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c505.o.
+
+3c507 support
+CONFIG_EL16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c507.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c523 support 
+CONFIG_ELMC
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c523.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c527 support
+CONFIG_ELMC_II
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c527.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c509/3c579 support
+CONFIG_EL3
+  If you have a network (Ethernet) card belonging to the 3Com
+  EtherLinkIII series, say Y and read the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If your card is not working you may need to use the DOS
+  setup disk to disable Plug & Play mode, and to select the default
+  media type.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c509.o. 
+
+3c590 series (592/595/597) "Vortex" support
+CONFIG_VORTEX
+  If you have a 3Com "Vortex" (Fast EtherLink 3c590/3c592/3c595/3c597)
+  or "Boomerang" series (EtherLink XL 3c900 or 3c905) network
+  (Ethernet) card, say Y and read the Ethernet-HOWTO, available via
+  FTP (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is in Documentation/networking/vortex.txt
+  and in the comments at the beginning of drivers/net/3c59x.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Other ISA cards
+CONFIG_NET_ISA
+  If your network (Ethernet) card hasn't been mentioned yet and its
+  bus system (that's the way the cards talks to the other components
+  of your computer) is ISA (as opposed to EISA, VLB or PCI), say Y.
+  Make sure you know the name of your card. Read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. If unsure, say Y.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the remaining ISA network card questions. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+Generic ARCnet support
+CONFIG_ARCNET
+  If you have a network card of this type, say Y and check out the
+  (arguably) beautiful poetry in Documentation/networking/arcnet.txt.
+
+  You need both this driver, and the driver for the particular ARCnet
+  chipset of your card. If you don't know, then it's probably a
+  COM90xx type card, so say Y (or M) to "ARCnet COM90xx chipset
+  support" below.
+
+  You might also want to have a look at the Ethernet-HOWTO, available
+  via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO (even though ARCnet is
+  not really Ethernet).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called arcnet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Enable arc0e (ARCnet "ether-encap" packet format)
+CONFIG_ARCNET_ETH
+  This allows you to use "Ethernet encapsulation" with your ARCnet
+  card via the virtual arc0e device. You only need arc0e if you want
+  to talk to nonstandard ARCnet software, specifically,
+  DOS/Windows-style "NDIS" drivers. You do not need to say Y here to
+  communicate with industry-standard RFC1201 implementations, like the
+  arcether.com packet driver or most DOS/Windows ODI drivers. RFC1201
+  is included automatically as the arc0 device. Please read the
+  ARCnet documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+Enable arc0s (ARCnet RFC1051 packet format)
+CONFIG_ARCNET_1051
+  This allows you to use RFC1051 with your ARCnet card via the virtual
+  arc0s device. You only need arc0s if you want to talk to ARCnet
+  software complying with the "old" standard, specifically, the DOS
+  arcnet.com packet driver, Amigas running AmiTCP, and some variants
+  of NetBSD. You do not need to say Y here to communicate with
+  industry-standard RFC1201 implementations, like the arcether.com
+  packet driver or most DOS/Windows ODI drivers. RFC1201 is included
+  automatically as the arc0 device. Please read the ARCnet
+  documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+ARCnet COM90xx (normal) chipset driver
+CONFIG_ARCNET_COM90xx
+  This is the chipset driver for the standard COM90xx cards. If you
+  have always used the old ARCnet driver without knowing what type of
+  card you had, this is probably the one for you. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (IO mapped) chipset driver
+CONFIG_ARCNET_COM90xxIO
+  This is the chipset driver for the COM90xx cards, using them in
+  IO-mapped mode instead of memory-mapped mode. This is slower than
+  the normal driver. Only use it if your card doesn't support shared
+  memory. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90io.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (RIM I) chipset driver
+CONFIG_ARCNET_RIM_I
+  This is yet another chipset driver for the COM90xx cards, but this
+  time only using memory-mapped mode, and no IO ports at all. This
+  driver is completely untested, so if you have one of these cards,
+  please mail David.Woodhouse@mvhi.com, especially if it works!
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called arc-rimi.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+ARCnet COM20020 chipset driver
+CONFIG_ARCNET_COM20020
+  This is the driver for the new COM20020 chipset. It supports such
+  things as promiscuous mode, so packet sniffing is possible, and
+  extra diagnostic information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com20020.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Cabletron E21xx support
+CONFIG_E2100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called e2100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+CS89x0 support
+CONFIG_CS89x0
+  Support for CS89x0 chipset based Ethernet cards. If you have a
+  network (Ethernet) card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO as well as
+  Documentation/networking/cs89x0.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  cs89x.o.
+
+DEPCA support
+CONFIG_DEPCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO as well as
+  drivers/net/depca.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  depca.o.
+
+EtherWorks 3 support
+CONFIG_EWRK3
+  This driver supports the DE203, DE204 and DE205 network (Ethernet)
+  cards. If this is for you, say Y and read
+  Documentation/networking/ewrk3.txt in the kernel source as well as
+  the Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  ewrk3.o.
+
+SEEQ8005 support
+CONFIG_SEEQ8005
+  This is a driver for the SEEQ 8005 network (Ethernet) card. If this
+  is for you, read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+AT1700/1720 support
+CONFIG_AT1700
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  at1700.o.
+
+FMV-181/182/183/184 support
+CONFIG_FMV18X
+  If you have a Fujitsu FMV-181/182/183/184 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you use an FMV-183 or FMV-184 and it is not working, you may need
+  to disable Plug & Play mode of the card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fmv18x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+EtherExpress PRO support
+CONFIG_EEXPRESS_PRO
+  If you have a network (Ethernet) card of this type, say Y. This
+  driver supports intel i82595{FX,TX} based boards. Note however 
+  that the EtherExpress PRO/100 Ethernet card has its own separate
+  driver. Please read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress support
+CONFIG_EEXPRESS
+  If you have an EtherExpress16 network (Ethernet) card, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that the Intel
+  EtherExpress16 card used to be regarded as a very poor choice
+  because the driver was very unreliable. We now have a new driver
+  that should do better.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  eexpress.o.
+
+HP PCLAN+ (27247B and 27252A) support
+CONFIG_HPLAN_PLUS
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp-plus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP PCLAN (27245 and other 27xxx series) support
+CONFIG_HPLAN
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP 10/100VG PCLAN (ISA, EISA, PCI) support
+CONFIG_HP100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  hp100.o.
+
+NE2000/NE1000 support
+CONFIG_NE2000
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Many Ethernet cards
+  without a specific driver are compatible with NE2000. 
+
+  If you have a PCI NE2000 card however, say N here and Y to "PCI
+  NE2000 support", above. If you have a NE2000 card and are running on
+  an MCA system (a bus system used on some IBM PS/2 computers and
+  laptops), say N here and Y to "NE/2 (ne2000 MCA version) support",
+  below.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SK_G16 support
+CONFIG_SK_G16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+NE/2 (ne2000 MCA version) support
+CONFIG_NE2_MCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SKnet MCA support
+CONFIG_SKMC
+  This are Micro Channel ethernet adapters.  You need to set CONFIG_MCA
+  to use this driver.  It's both available as an in-kernel driver and
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. If you plan to use more than
+  one network card under linux, read the Multiple-Ethernet-mini-HOWTO,
+  available from sunsite.unc.edu:/pub/Linux/docs/HOWTO/mini.  Supported
+  cards are the SKnet Junior MC2 and the SKnet MC2(+).  Distinguishing
+  both cards is done automatically.  Note that using multiple boards
+  of different type hasn't been tested with this driver.
+
+EISA, VLB, PCI and on board controllers
+CONFIG_NET_EISA
+  This is another class of network cards which attach directly to the
+  bus. If you have one of those, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network cards. If you say Y, you
+  will be asked for your specific card in the following questions. If
+  you are unsure, say Y.
+
+AMD PCnet32 (VLB and PCI) support
+CONFIG_PCNET32
+  If you have a PCnet32 or PCnetPCI based network (Ethernet) card,
+  answer Y here and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pcnet32.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Ansel Communications EISA 3200 support
+CONFIG_AC3200
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ac3200.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Mylex EISA LNE390A/LNE390B support
+CONFIG_LNE390
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lne390.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Novell/Eagle/Microdyne NE3210 EISA support
+CONFIG_NE3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Note that this driver
+  will NOT WORK for NE3200 cards as they are completely different.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Apricot Xen-II on board Ethernet
+CONFIG_APRICOT
+  If you have a network (Ethernet) controller of this type, say Y and
+  read the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  apricot.o.
+
+Generic DECchip & DIGITAL EtherWORKS PCI/EISA
+CONFIG_DE4X5
+  This is support for the DIGITAL series of PCI/EISA Ethernet cards.
+  These include the DE425, DE434, DE435, DE450 and DE500 models. If
+  you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. More specific
+  information is contained in Documentation/networking/de4x5.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called de4x5.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+DECchip Tulip (dc21x4x) PCI support
+CONFIG_DEC_ELCP
+  This driver is developed for the SMC EtherPower series Ethernet
+  cards and also works with cards based on the DECchip
+  21040/21041/21140 (Tulip series) chips. Some LinkSys PCI cards are
+  of this type. (If your card is NOT SMC EtherPower 10/100 PCI
+  (smc9332dst), you can also try the driver for "Generic DECchip"
+  cards, above. However, most people with a network card of this type
+  will say Y here.) Do read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is contained in
+  Documentation/networking/tulip.txt.
+
+  This is the new version of this driver. If it does not work for
+  you please try older version which is also available.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tulip.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Old DECchip Tulip (dc21x4x) PCI support
+CONFIG_DEC_ELCP_OLD
+  This driver is developed for the SMC EtherPower series Ethernet
+  cards and also works with cards based on the DECchip
+  21040/21041/21140 (Tulip series) chips. Some LinkSys PCI cards are
+  of this type. (If your card is NOT SMC EtherPower 10/100 PCI
+  (smc9332dst), you can also try the driver for "Generic DECchip"
+  cards, above. However, most people with a network card of this type
+  will say Y here.) Do read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+  More specific information is contained in
+  Documentation/networking/tulip.txt.
+
+  This an older version of the driver which supports some cards the
+  new version does not (yet) support. Use it if the new driver does
+  not work for you.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called old_tulip.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Digi Intl. RightSwitch support
+CONFIG_DGRS
+  This is support for the Digi International RightSwitch series of
+  PCI/EISA Ethernet switch cards. These include the SE-4 and the SE-6
+  models. If you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. More specific
+  information is contained in Documentation/networking/dgrs.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dgrs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress PRO/100 support
+CONFIG_EEXPRESS_PRO100
+  If you have an Intel EtherExpress PRO/100 PCI network (Ethernet)
+  card, say Y and read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ICL EtherTeam 16i/32 support
+CONFIG_ETH16I
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eth16i.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+TI ThunderLAN support (EXPERIMENTAL)
+CONFIG_TLAN
+  If you have a PCI Ethernet network card based on the ThunderLAN chip
+  which is supported by this driver, say Y and read the
+  Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Devices currently supported by this driver are Compaq Netelligent,
+  Compaq NetFlex and Olicom cards. Please read the file
+  Documentation/networking/tlan.txt for more details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tlan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+  Please email feedback to torben.mathiasen@compaq.com.
+
+VIA Rhine support
+CONFIG_VIA_RHINE
+  If you have a VIA "rhine" based network card (Rhine-I (3043) or
+  Rhine-2 (VT86c100A)), say Y here.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called via-rhine.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan EISA ES3210 support
+CONFIG_ES3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called es3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC EtherPower II (EXPERIMENTAL)
+CONFIG_EPIC100
+  If you have an SMC EtherPower II 9432 PCI Ethernet network card
+  which is based on the SMC83c170, say Y and read the Ethernet-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called epic100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SGI Seeq ethernet controller support
+CONFIG_SGISEEQ
+  Say Y here if you have an Seeq based Ethernet network card. This is
+  used in many Silicon Graphics machines.
+
+Zenith Z-Note support
+CONFIG_ZNET
+  The Zenith Z-Note notebook computer has a built-in network
+  (Ethernet) card, and this is the Linux driver for it. Note that the
+  IBM Thinkpad 300 is compatible with the Z-Note and is also supported
+  by this driver. Read the Ethernet-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+Pocket and portable adapters
+CONFIG_NET_POCKET
+  Cute little network (Ethernet) devices which attach to the parallel
+  port ("pocket adapters"), commonly used with laptops. If you have
+  one of those, say Y and read the Ethernet-HOWTO, available via FTP
+  (user: anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to plug a network (or some other) card into the PCMCIA
+  (or PC-card) slot of your laptop instead (PCMCIA is the standard for
+  credit card size extension cards used by all modern laptops), you
+  need the pcmcia-cs package (location contained in the file
+  Documentation/Changes) and you can say N here.
+
+  Laptop users should read the Linux Laptop home page at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape). 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network devices. If you say Y, you
+  will be asked for your specific device in the following questions.
+
+AT-LAN-TEC/RealTek pocket adapter support
+CONFIG_ATP
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read drivers/net/atp.c as well as the Ethernet-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  If you intend to use this driver, you should have said N to the
+  Parallel Printer support, because the two drivers don't like each
+  other.
+
+D-Link DE600 pocket adapter support
+CONFIG_DE600
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  It is possible to have several devices share a single parallel port
+  and it is safe to compile the corresponding drivers into the kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de600.o.
+
+D-Link DE620 pocket adapter support
+CONFIG_DE620
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO if you want to use this.
+  It is possible to have several devices share a single parallel port
+  and it is safe to compile the corresponding drivers into the kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de620.o.
+
+Token Ring driver support
+CONFIG_TR
+  Token Ring is IBM's way of communication on a local network; the
+  rest of the world uses Ethernet. To participate on a Token Ring
+  network, you need a special Token ring network card. If you are
+  connected to such a Token Ring network and want to use your Token
+  Ring card under Linux, say Y here and to the driver for your
+  particular card below and read the Token-Ring mini-HOWTO, available
+  via FTP (user:anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. Most people can say N
+  here.
+
+IBM Tropic chipset based adapter support
+CONFIG_IBMTR
+  This is support for all IBM Token Ring cards that don't use DMA. If
+  you have such a beast, say Y and read the Token-Ring mini-HOWTO,
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Warning: this driver will almost definitely fail if more than one
+  active Token Ring card is present. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmtr.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IBM Olympic chipset PCI adapter support
+CONFIG_IBMOL
+  This is support for all non-Lanstreamer IBM PCI Token Ring Cards. 
+  Specifically this is all IBM PCI, PCI Wake On Lan, PCI II, PCI II
+  Wake On Lan, and PCI 100/16/4 adapters.
+
+  If you have such an adapter, say Y and read the Token-Ring mini-HOWTO,
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc/edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called olympic.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  Also read the linux/Documentation/networking/olympic.txt or check the 
+  Linux Token Ring Project site for the latest information at
+  http://www.linuxtr.net
+
+IBM Lanstreamer chipset PCI adapter support
+CONFIG_IBMLS
+  This is support for IBM Lanstreamer PCI Token Ring Cards.
+
+  If you have such an adapter, say Y and read the Token-Ring mini-HOWTO
+  available via FTP (user:anonymous) from
+  ftp://metalab.unc/edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a modules ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The modules will be called lanstreamer.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+SysKonnect adapter support
+CONFIG_SKTR
+  This is support for all SysKonnect Token Ring cards, specifically
+  SysKonnect TR4/16(+) ISA (SK-4190), SysKonnect TR4/16(+) PCI
+  (SK-4590), SysKonnect TR4/16 PCI (SK-4591) adapters.
+  It also supports Compaq PCI Token Ring adapters and Proteon ISA
+  Token Ring adapters (1392 and 1392+).
+
+  If you have such an adapter and would like to use it, say Y or M and
+  read the Token-Ring mini-HOWTO, available via FTP (user: anonymous)
+  from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Also read the file linux/Documentation/networking/sktr.txt or check
+  the Linux-SNA WWW site for the latest information at
+  http://samba.anu.edu.au/linux-sna/documents/drivers/SysKonnect/
+
+Traffic Shaper (EXPERIMENTAL)
+CONFIG_SHAPER
+  The traffic shaper is a virtual network device that allows you to
+  limit the rate of outgoing data flow over some other network
+  device. See Documentation/networking/shaper.txt for more
+  information. To set up and configure shaper devices, you need the
+  shapecfg program, available via FTP (user: anonymous) from
+  ftp://shadow.cabi.net/pub/Linux in the shaper package. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called shaper.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+FDDI driver support
+CONFIG_FDDI
+  Fiber Distributed Data Interface is a high speed local area network
+  design; essentially a replacement for high speed Ethernet. FDDI can
+  run over copper or fiber. If you are connected to such a network and
+  want a driver for the FDDI card in your computer, say Y here (and
+  then also Y to the driver for your FDDI card, below). Most people
+  will say N.
+
+Digital DEFEA and DEFPA adapter support
+CONFIG_DEFXX
+  This is support for the DIGITAL series of EISA (DEFEA) and PCI
+  (DEFPA) controllers which can connect you to a local FDDI network.
+
+SysKonnect FDDI PCI support
+CONFIG_SKFP
+  Say Y here if you have a SysKonnect FDDI PCI adapter.
+  The following adapters are supported by this driver:
+  - SK-5521 (SK-NET FDDI-UP)
+  - SK-5522 (SK-NET FDDI-UP DAS)
+  - SK-5541 (SK-NET FDDI-FP)
+  - SK-5543 (SK-NET FDDI-LP)
+  - SK-5544 (SK-NET FDDI-LP DAS)
+  - SK-5821 (SK-NET FDDI-UP64)
+  - SK-5822 (SK-NET FDDI-UP64 DAS)
+  - SK-5841 (SK-NET FDDI-FP64)
+  - SK-5843 (SK-NET FDDI-LP64)
+  - SK-5844 (SK-NET FDDI-LP64 DAS)
+  - Netelligent 100 FDDI DAS Fibre SC
+  - Netelligent 100 FDDI SAS Fibre SC
+  - Netelligent 100 FDDI DAS UTP
+  - Netelligent 100 FDDI SAS UTP
+  - Netelligent 100 FDDI SAS Fibre MIC
+  Read Documentation/networking/skfp.txt for information about
+  the driver.
+  Questions concerning this driver can be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called skfp.o.
+
+HIgh Performance Parallel Interface support (EXPERIMENTAL)
+CONFIG_HIPPI
+  HIgh Performance Parallel Interface (HIPPI) is a 800Mbit/sec and
+  1600Mbit/sec dual-simplex switched or point-to-point network. HIPPI
+  can run over copper (25m) or fiber (300m on multi-mode or 10km on
+  single-mode). HIPPI networks are commonly used for clusters and to
+  connect to super computers. If you are connected to a HIPPI network
+  and have a HIPPI network card in your computer that you want to use
+  under Linux, say Y here (you must also remember to enable the driver
+  for your HIPPI card below). Most people will say N here.
+  
+Essential RoadRunner HIPPI PCI adapter support
+CONFIG_ROADRUNNER
+  Say Y here if this is your PCI HIPPI network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rrunner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Use large TX/RX rings
+CONFIG_ROADRUNNER_LARGE_RINGS
+  If you say Y here, the RoadRunner driver will preallocate up to 2 MB
+  of additional memory to allow for fastest operation, both for
+  transmitting and receiving. This memory cannot be used by any other
+  kernel code or by user space programs. Say Y here only if you have
+  the memory.
+
+Acorn Ether1 card
+CONFIG_ARM_ETHER1
+  If you have an Acorn system with one of these (AKA25) network cards,
+  you should say Y to this option if you wish to use it with Linux.
+
+Acorn/ANT Ether3 card
+CONFIG_ARM_ETHER3
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+I Cubed EtherH card
+CONFIG_ARM_ETHERH
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+EBSA-110 Ethernet interface
+CONFIG_ARM_AM79C961A
+  If you wish to compile a kernel for the EBSA-110, then you should
+  always answer Y to this.
+
+Support CDROM drives that are not SCSI or IDE/ATAPI
+CONFIG_CD_NO_IDESCSI
+  If you have a CDROM drive that is neither SCSI nor IDE/ATAPI, say Y
+  here, otherwise N. Read the CDROM-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these CDROM drives. If you are unsure what you
+  have, say Y and find out whether you have one of the following
+  drives. 
+
+  For each of these drivers, a file Documentation/cdrom/<driver_name>
+  exists. Especially in cases where you do not know exactly which kind
+  of drive you have you should read there. Most of these drivers use a
+  file drivers/cdrom/<driver_name>.h where you can define your
+  interface parameters and switch some internal goodies. 
+
+  All these CDROM drivers are also usable as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile them as module, say M instead of Y and
+  read Documentation/modules.txt. 
+
+  If you want to use any of these CDROM drivers, you also have to
+  answer Y or M to "ISO 9660 CDROM filesystem support" below (this
+  answer will get "defaulted" for you if you enable any of the Linux
+  CDROM drivers).
+
+Sony CDU31A/CDU33A CDROM support
+CONFIG_CDU31A
+  These CDROM drives have a spring-pop-out caddyless drawer, and a
+  rectangular green LED centered beneath it. NOTE: these CDROM drives
+  will not be auto detected by the kernel at boot time; you have to
+  provide the interface address as an option to the kernel at boot
+  time as described in Documentation/cdrom/cdu31a or fill in your
+  parameters into drivers/cdrom/cdu31a.c. Try "man bootparam" or
+  see the documentation of your boot loader (lilo or loadlin) about
+  how to pass options to the kernel. The lilo procedure is also
+  explained in the SCSI-HOWTO. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cdu31a.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Standard Mitsumi [no XA/Multisession] CDROM support
+CONFIG_MCD
+  This is the older of the two drivers for the older Mitsumi models
+  LU-005, FX-001 and FX-001D. This is not the right driver for the
+  FX-001DE and the triple or quad speed models (all these are
+  IDE/ATAPI models). Please also the file Documentation/cdrom/mcd.
+
+  With the old LU-005 model, the whole drive chassis slides out for cd
+  insertion. The FX-xxx models use a motorized tray type mechanism.
+  Note that this driver does not support XA or MultiSession CDs
+  (PhotoCDs). There is a new driver (next question) which can do
+  this. If you want that one, say N here.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IRQ channel for Mitsumi CD-ROM
+CONFIG_MCD_IRQ
+  This allows you to specify the default value of the IRQ used by the
+  driver. This setting can be overridden by passing the "mcd="
+  parameter to the kernel at boot time (or at module load time if you
+  said M to "Standard Mitsumi CDROM support").
+
+I/O base address for Mitsumi CD-ROM
+CONFIG_MCD_BASE
+  This allows you to specify the default value of the I/O base address
+  used by the driver. This setting can be overridden by passing the
+  "mcd=" parameter to the kernel at boot time (or at module load time
+  if you said M to "Standard Mitsumi CDROM support").
+
+Mitsumi [XA/MultiSession] support
+CONFIG_MCDX
+  Use this driver if you want to be able to read XA or MultiSession
+  CDs (PhotoCDs) as well as ordinary CDs with your Mitsumi LU-005,
+  FX-001 or FX-001D CDROM drive. In addition, this driver uses much
+  less kernel memory than the old one, if that is a concern. This
+  driver is able to support more than one drive, but each drive needs
+  a separate interface card. Please read the file
+  Documentation/cdrom/mcdx.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcdx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic/Creative, Longshine, TEAC CDROM support
+CONFIG_SBPCD
+  This driver supports most of the drives which use the Panasonic or
+  Sound Blaster interface. Please read the file
+  Documentation/cdrom/sbpcd.
+
+  The Matsushita CR-521, CR-522, CR-523, CR-562, CR-563 drives
+  (sometimes labeled "Creative"), the Creative Labs CD200, the
+  Longshine LCS-7260, the "IBM External ISA CDROM" (in fact a CR-56x
+  model), the TEAC CD-55A fall under this category. Some other
+  "electrically compatible" drives (Vertos, Genoa, some Funai models)
+  are currently not supported; for the Sanyo H94A drive currently a
+  separate driver (asked later) is responsible. Most drives have a
+  uniquely shaped faceplate, with a caddyless motorized drawer, but
+  without external brand markings. The older CR-52x drives have a
+  caddy and manual loading/eject, but still no external markings. The
+  driver is able to do an extended auto-probing for interface
+  addresses and drive types; this can help to find facts in cases you
+  are not sure, but can consume some time during the boot process if
+  none of the supported drives gets found. Once your drive got found,
+  you should enter the reported parameters into drivers/cdrom/sbpcd.h
+  and set "DISTRIBUTION 0" there.
+
+  This driver can support up to four CDROM controller cards, and each
+  card can support up to four CDROM drives; if you say Y here, you
+  will be asked how many controller cards you have. If compiled as a
+  module, only one controller card (but with up to four drives) is
+  usable.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sbpcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic, ... second CDROM controller support
+CONFIG_SBPCD2
+  Say Y here only if you have two CDROM controller cards of this type
+  (usually only if you have more than four drives). You should enter
+  the parameters for the second, third and fourth interface card into
+  linux/include/linux/sbpcd.h before compiling the new kernel. Read
+  the file Documentation/cdrom/sbpcd.
+
+Aztech/Orchid/Okano/Wearnes/TXC/CyDROM CDROM support
+CONFIG_AZTCD
+  This is your driver if you have an Aztech CDA268-01A, Orchid
+  CD-3110, Okano or Wearnes CDD110, Conrad TXC, or CyCDROM CR520 or
+  CR540 CDROM drive. This driver -- just like all these CDROM drivers
+  -- is NOT for CDROM drives with IDE/ATAPI interfaces, such as Aztech
+  CDA269-031SE. Please read the file Documentation/cdrom/aztcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aztcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sony CDU535 CDROM support
+CONFIG_CDU535
+  This is the driver for the older Sony CDU-535 and CDU-531 CDROM
+  drives. Please read the file Documentation/cdrom/sonycd535.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sonycd535.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Goldstar R420 CDROM support
+CONFIG_GSCD
+  If this is your CDROM drive, say Y here. As described in the file
+  linux/Documentation/cdrom/gscd, you might have to change a setting
+  in the file linux/drivers/cdrom/gscd.h before compiling the
+  kernel. Please read the file Documentation/cdrom/gscd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called gscd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Philips/LMS CM206 CDROM support
+CONFIG_CM206
+  If you have a Philips/LMS CDROM drive cm206 in combination with a
+  cm260 host adapter card, say Y here. Please also read the file
+  Documentation/cdrom/cm206. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cm206.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Optics Storage DOLPHIN 8000AT CDROM support
+CONFIG_OPTCD
+  This is the driver for the 'DOLPHIN' drive with a 34-pin Sony
+  compatible interface. It also works with the Lasermate CR328A. If
+  you have one of those, say Y. This driver does not work for the
+  Optics Storage 8001 drive; use the IDE-ATAPI CDROM driver for that
+  one. Please read the file Documentation/cdrom/optcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  filesystem support" below, because that's the filesystem used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called optcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sanyo CDR-H94A CDROM support
+CONFIG_SJCD
+  If this is your CDROM drive, say Y here and read the file
+  Documentation/cdrom/sjcd. You should then also say Y or M to
+  "ISO 9660 CDROM filesystem support" below, because that's the
+  filesystem used on CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sjcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Soft configurable cdrom interface card support
+CONFIG_CDI_INIT
+  If you want to include boot-time initialization of any cdrom
+  interface card that is software configurable, say Y here. Currently
+  only the ISP16/MAD16/Mozart sound cards with built-in cdrom
+  interfaces are supported. 
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these CDROM drives.
+
+ISP16/MAD16/Mozart soft configurable cdrom interface support
+CONFIG_ISP16_CDI
+  These are sound cards with built-in cdrom interfaces using the OPTi
+  82C928 or 82C929 chips. Say Y here to have them detected and
+  possibly configured at boot time. In addition, You'll have to say Y
+  to a driver for the particular cdrom drive you have attached to the
+  card. Read Documentation/cdrom/isp16 for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called isp16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Quota support
+CONFIG_QUOTA
+  If you say Y here, you will be able to set per user limits for disk
+  usage (also called disk quotas). Currently, it works only for the
+  ext2 filesystem. You need additional software in order to use quota
+  support; for details, read the Quota mini-HOWTO, available via FTP
+  (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini. Probably the quota
+  support is only useful for multi user systems. If unsure, say N.
+
+Acorn's ADFS filesystem support (read only) (EXPERIMENTAL)
+CONFIG_ADFS_FS
+  The Advanced Disk File System is the filesystem used on floppy and
+  hard disks by Acorn Systems.  Currently in development, as a read-
+  only driver for hard disks.  These should be the first partition
+  (eg. /dev/[sh]d?1) on each of your drives.  If unsure, say N.
+
+Support for USB
+CONFIG_USB
+  Universal Serial Bus (USB) is a specification for a serial bus
+  subsystem which offers higher speeds and more features than the
+  traditional PC serial port. The bus supplies power to peripherals
+  and allows for hot swapping. Up to 127 USB peripherals can be
+  connected to a single USB port in a tree structure. The USB port is
+  the root of the tree, the peripherals are the leaves and the inner
+  nodes are special USB devices called hubs. Many newer PC's have USB
+  ports and newer peripherals such as scanners, keyboards, mice,
+  modems, and printers support the USB protocol and can be connected
+  to the PC via those ports.
+
+  Say Y here if your computer has a USB port and you want to use USB
+  devices. You then need to say Y to at least one of "UHCI support" or
+  "OHCI support" below (the type of interface that the USB hardware in
+  your computer provides to the operating system) and then choose from
+  among the drivers for USB peripherals. You may want to check out the
+  information provided in Documentation/usb/ and especially the links
+  given in Documentation/usb/usb-help.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbcore.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB verbose debug messages
+CONFIG_USB_DEBUG
+  Say Y here if you want the USB core & hub drivers to produce a bunch
+  of debug messages to the system log. Select this if you are having a
+  problem with USB support and want to see more of what is going on.
+
+UHCI (intel PIIX4, VIA, ...) support?
+CONFIG_USB_UHCI
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133).
+
+  Currently there exist two drivers for UHCI host controllers: this
+  one and the so-called JE driver, which you can get from 
+  "UHCI alternate (JE) support", below. You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI (intel PIIX4, VIA, ...) alternate (JE) support?
+CONFIG_USB_UHCI_ALT
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133). If unsure, say Y.
+
+  Currently there exist two drivers for UHCI host controllers: this
+  so-called JE driver, and the one you get from "UHCI support", above.
+  You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI unlink optimizations (EXPERIMENTAL)
+CONFIG_USB_UHCI_ALT_UNLINK_OPTIMIZE
+  This option currently does nothing. You may say Y or N.
+
+OHCI (Compaq, iMacs, OPTi, SiS, ALi, ...) support
+CONFIG_USB_OHCI
+  The Open Host Controller Interface is a standard by
+  Compaq/Microsoft/National for accessing the USB PC hardware (also
+  called USB host controller). If your USB host controller conforms to
+  this standard, say Y. The USB host controllers on most non-Intel
+  architectures and on several x86 compatibles with non-Intel chipsets
+  -- like SiS (aktual 610, 610 and so on) or ALi (ALi IV, ALi V,
+  Aladdin Pro..) -- conform to this standard.
+
+  You may want to read the file Documentation/usb/ohci.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-ohci.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Human Interface Device (HID) support
+CONFIG_USB_HID
+  Say Y here if you want to connect keyboards, mice, joysticks,
+  graphic tablets, or any other HID based devices to your
+  computer via USB. More information is available:
+  Documentation/usb/input.txt.
+
+  If unsure, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hid.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB HIDBP Keyboard support
+CONFIG_USB_KBD
+  Say Y here if you don't want to use the generic HID driver for your
+  USB keyboard and prefer to use the keyboard in its limited Boot
+  Protocol mode. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbkbd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+USB HIDBP Mouse support
+CONFIG_USB_MOUSE
+  Say Y here if you don't want to use the generic HID driver for your
+  USB mouse and prefer to use the mouse in its limited Boot Protocol
+  mode. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbmouse.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Wacom Intuos/Graphire tablet support
+CONFIG_USB_WACOM
+  Say Y here if you want to use the USB version of the Wacom Intuos
+  or Graphire tablet. Make sure to say Y to "Mouse support"
+  (CONFIG_INPUT_MOUSEDEV) and/or "Event interface support"
+  (CONFIG_INPUT_EVDEV) as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wacom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Logitech WingMan Force joystick support
+CONFIG_USB_WMFORCE
+  Say Y here if you want to use the Logitech WingMan Force with Linux
+  on the USB port. No force-feedback support yet, but other than that
+  it should work like a normal joystick.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wmforce.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Keyboard support
+CONFIG_INPUT_KEYBDEV
+  Say Y here if you want your USB HID keyboard to be able to serve 
+  as a system keyboard.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keybdev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Mouse support
+CONFIG_INPUT_MOUSEDEV
+  Say Y here if you want your USB HID mouse (or ADB mouse handled by
+  the input layer) to be accessible as char devices 13:32+ -
+  /dev/input/mouseX and 13:63 - /dev/input/mice as an emulated ImPS/2
+  mouse.  That way, all user space programs will be able to use your
+  mouse.
+  
+  If unsure, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mousedev.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Horizontal screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_X
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Vertical screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Joystick support
+CONFIG_INPUT_JOYDEV
+  Say Y here if you want your USB HID joystick or gamepad to be
+  accessible as char device 13:0+ - /dev/input/jsX device. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called joydev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Event interface support
+CONFIG_INPUT_EVDEV
+  Say Y here if you want your USB or ADB HID device events be accessible
+  under char device 13:64+ - /dev/input/eventX in a generic way.
+  This is the future ...
+
+USB Scanner support
+CONFIG_USB_SCANNER
+  Say Y here if you want to connect a USB scanner to your computer's
+  USB port. Please read Documentation/usb/scanner.txt and
+  Documentation/usb/scanner-hp-sane.txt for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scanner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+USB Audio support
+CONFIG_USB_AUDIO
+  Say Y here if you want to connect UAB audio equipment such as
+  speakers to your computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called audio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Modem (CDC ACM) support
+CONFIG_USB_ACM
+  This driver supports USB modems and ISDN adapters which support the
+  Communication Device Class Abstract Control Model interface.
+  Please read Documentation/usb/acm.txt for details.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acm.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Serial converter support
+CONFIG_USB_SERIAL
+  Say Y here if you have a USB device that provides normal serial
+  ports, and you want to connect it to your USB bus. Supported devices
+  are the Tech WhiteHEAT multi-port USB to serial converter, and the
+  FTDI or Keyspan single port USB to serial converter Handspring
+  Visor. In addition to saying Y here, you need to say Y to the driver
+  for your specific hardware below. Some other devices may also be
+  used if you say Y to "USB Generic Serial Driver", below.
+
+  Please read Documentation/usb/usb-serial.txt for more information.
+  
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbserial.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Generic Serial Driver
+CONFIG_USB_SERIAL_GENERIC
+  Say Y here if you want to use the generic USB serial driver. Please
+  read Documentation/usb/usb-serial.txt for more information on using
+  this driver. It is recommended that the "USB Serial converter
+  support" be compiled as a module for this driver to be used
+  properly.
+
+USB ConnectTech WhiteHEAT Serial Driver
+CONFIG_USB_SERIAL_WHITEHEAT
+  Say Y here if you want to use a ConnectTech WhiteHEAT 4 port
+  USB to serial converter device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called whiteheat.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Handspring Visor Driver
+CONFIG_USB_SERIAL_VISOR
+  Say Y here if you want to connect to your HandSpring Visor through
+  its USB docking station. See http://usbvisor.sourceforge.net for
+  more information on using this driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called visor.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB FTDI Single Port Serial Driver
+CONFIG_USB_SERIAL_FTDI_SIO
+  Say Y here if you want to use a FTDI SIO single port USB to serial
+  converter device. The implementation I have is called the USC-1000.
+
+  See http://reality.sgi.com/bryder_wellington/ftdi_sio for more
+  information on this driver and the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ftdi_sio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan PDA Single Port Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN_PDA
+  Say Y here if you want to use a Keyspan PDA single port USB to
+  serial converter device.  This driver makes use of firmware
+  developed from scratch by Brian Warner.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan_pda.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-xxx Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN
+  Say Y here if you want to use Keyspan USB to serial converter
+  devices.  This driver makes use of Keyspan's official firmware
+  and was developed with their support.  You must also include
+  firmware to support your particular device(s). 
+
+  See http://www.linuxcare.com.au/hugh/keyspan.html for 
+  more information.
+ 
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-28 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28
+  Say Y here to include firmware for the USA-28 converter.
+
+USB Keyspan USA-28X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28X
+  Say Y here to include firmware for the USA-28X converter.
+
+USB Keyspan USA-19 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19
+  Say Y here to include firmware for the USA-19 converter.
+
+USB Keyspan USA-18X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA18X
+  Say Y here to include firmware for the USA-18X converter.
+
+USB Keyspan USA-19W Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19W
+  Say Y here to include firmware for the USA-19W converter.
+
+USB ZyXEL omni.net LCD Plus Driver
+CONFIG_USB_SERIAL_OMNINET
+  Say Y here if you want to use a ZyXEL omni.net LCD ISDN TA.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called omninet.o. If you want to compile it as a 
+  module, say M here and read Documentation/modules.txt.
+
+USB Digi International AccelePort USB Serial Driver
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT
+  Say Y here if you want to use Digi AccelePort USB 2 or 4 devices,
+  2 port (plus parallel port) and 4 port USB serial converters.  The
+  parallel port on the USB 2 appears as a third serial port on Linux.
+  The Digi Acceleport USB 8 is not yet supported by this driver.
+
+  This driver works under SMP with the usb-uhci driver.  It does not
+  work under SMP with the uhci driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called digi_acceleport.o. If you want to compile 
+  it as a module, say M here and read Documentation/modules.txt.
+
+USB Serial Converter verbose debug
+CONFIG_USB_SERIAL_DEBUG
+  Say Y here if you want verbose debug messages from the USB Serial
+  Converter. 
+
+USB Printer support
+CONFIG_USB_PRINTER
+  Say Y here if you want to connect a USB printer to your computer's
+  USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called printer.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB IBM (Xirlink) C-It Camera support
+CONFIG_USB_IBMCAM
+  Say Y here if you want to connect a IBM "C-It" camera, also known as
+  "Xirlink PC Camera" to your computer's USB port. For more
+  information, read Documentation/usb/ibmcam.txt.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmcam.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. This camera
+  has several configuration options which can be specified when you
+  load the module. Read Documentation/usb/ibmcam.txt to learn more.
+
+USB OV511 Camera support
+CONFIG_USB_OV511
+  Say Y here if you want to connect this type of camera to your
+  computer's USB port. See Documentation/usb/ov511.txt for more
+  information and for a list of supported cameras.
+  
+  This driver uses the Video For Linux API. You must say Y or M to
+  "Video For Linux" (under Character Devices) to use this driver.
+  Information on this API and pointers to "v4l" programs may be found
+  on the WWW at http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ov511.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB ADMtek Pegasus-based ethernet device support
+CONFIG_USB_PEGASUS
+  Say Y if you want to use your USB ethernet device. Supported
+  cards until now are:
+    ADMtek AN986 (eval. board)
+    Accton 10/100
+    Billington USB-100
+    Corega FEter USB-TX
+    MELCO/BUFFALO LUA-TX
+    D-Link DSB-650TX, DSB-650TX-PNA, DSB-650, DU-E10, DU-E100
+    Linksys USB100TX, USB10TX
+    LANEED Ethernet LD-USB/TX
+    SMC 202
+    SOHOware NUB Ethernet
+  If you have devices with vendor IDs other than noted above
+  you should add them in the driver code and send a message
+  to me (petkan@dce.bg) for update.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pegasus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Kodak DC-2xx Camera support
+CONFIG_USB_DC2XX
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port.  See Documentation/usb/dc2xx.txt for more
+  information; some non-Kodak cameras may also work with this
+  driver, given application support (such as www.gPhoto.org).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dc2xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mustek MDC800 Digital Camera Support
+CONFIG_USB_MDC800
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port. This driver can be used with gphoto 0.4.3
+  and higher (look at http://www.gphoto.org ).
+  To use it create a device node with "mknod /dev/mustek c 180 32" and
+  configure it in your software.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mdc800.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage support
+CONFIG_USB_STORAGE
+  Say Y here if you want to connect USB mass storage devices to your
+  computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-storage.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage verbose debug
+CONFIG_USB_STORAGE_DEBUG
+  Say Y here in order to have the USB Mass Storage code generate
+  verbose debugging messages.
+
+USS720 parport driver
+CONFIG_USB_USS720
+  This driver is for USB parallel port adapters that use the Lucent
+  Technologies USS-720 chip. These cables are plugged into your USB
+  port and provide USB compatibility to peripherals designed with
+  parallel port interfaces.
+  
+  The chip has two modes: automatic mode and manual mode. In automatic
+  mode, it looks to the computer like a standard USB printer. Only
+  printers may be connected to the USS-720 in this mode. The generic
+  USB printer driver ("USB Printer support", above) may be used in
+  that mode, and you can say N here if you want to use the chip only
+  in this mode.
+
+  Manual mode is not limited to printers, any parallel port
+  device should work. This driver utilizes manual mode.
+  Note however that some operations are three orders of magnitude
+  slower than on a PCI/ISA Parallel Port, so timing critical
+  applications might not work.
+
+  Say Y here if you own an USS-720 USB->Parport cable and intend to
+  connect anything other than a printer to it.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uss720.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+  
+USB device file system
+CONFIG_USB_DEVICEFS
+  If you say Y here (and to "/proc file system support" below), you
+  will get a file /proc/usb/devices which lists the devices currently
+  connected to your USB busses, a file /proc/usb/drivers which lists
+  the USB kernel client drivers currently loaded, and for every
+  connected device a file named "/proc/usb/xxx/yyy", where xxx is the
+  bus number and yyy the device number; the latter files can be used
+  by user space programs to talk directly to the device. These files
+  are "virtual", meaning they are generated on the fly and not stored
+  on the hard drive.
+  
+  For the format of the /proc/usb/ files, please read
+  Documentation/usb/proc_usb_info.txt. 
+
+  Please note that this code is completely unrelated to devfs, the
+  "/dev file system support".
+
+  Most users want to say Y here.
+
+Support for hot-pluggable USB devices
+CONFIG_HOTPLUG
+ Say Y here if you want to plug devices into your computer while
+ the system is running, and be able to use them quickly.  In many
+ cases, the devices can likewise be unplugged at any time too.
+
+ Enable this with KMOD, and your kernel will automatically
+ call out to a user mode "policy agent" to load drivers and other
+ modules needed to use USB devices you plug in.  With a bit of work,
+ it can invoke other device setup tasks.  Get such agent software
+ (at http://www.linux-usb.org/policy.html) and install it.
+
+USB Bandwidth allocation
+CONFIG_USB_BANDWIDTH
+  If you say Y here, the USB subsystem enforces USB bandwidth
+  allocation and will prevent some device opens from succeeding
+  if they would cause USB bandwidth usage to go above 90% of
+  the bus bandwidth.
+
+  If you say N here, these conditions will cause warning messages
+  about USB bandwidth usage to be logged and some devices or
+  drivers may not work correctly.
+
+DABUSB driver
+CONFIG_USB_DABUSB
+  A Digital Audio Broadcasting (DAB) Receiver for USB and Linux
+  brought to you by the DAB-Team (http://dab.in.tum.de). This driver
+  can be taken as an example for URB-based bulk, control, and
+  isochronous transactions. URB's are explained in
+  Documentation/usb/URB.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dabusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PLUSB driver
+CONFIG_USB_PLUSB
+  A driver for the Prolific PL-2302 USB-to-USB network device. This
+  'USB cable' connects two hosts via a point-to-point network with
+  bandwidth of 5 Mbit/s. Configure this driver after connecting the
+  USB cable via ifconfig plusb0 10.0.0.1 pointopoint 10.0.0.2 (and
+  vice versa on the other host).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called plusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Diamond Rio500 support
+CONFIG_USB_RIO500
+  Say Y here if you want to connect a USB Rio500 mp3 player to your
+  computer's USB port. Please read Documentation/usb/rio.txt
+  for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rio500.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+D-Link DSB-R100 FM radio support
+CONFIG_USB_DSBR
+  Say Y here if you want to connect this type of radio to your
+  computer's USB port. Note that the audio is not digital, and
+  you must connect the line out connector to a sound card or a
+  set of speakers.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dsbr100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Microtek USB scanner support
+CONFIG_USB_MICROTEK
+  Say Y here if you want support for the Microtek X6USB and possibly
+  some other scanners by that vendor. The scanner will appear as a
+  scsi generic device to the rest of the system.
+  A patched version of SANE is necessary to use the
+  scanner. It's available at 
+  http://fachschaft.cup.uni-muenchen.de/~neukum/scanner.html
+  This driver can be compiled as a module.
+
+USB Bluetooth support
+CONFIG_USB_BLUETOOTH
+  Say Y here if you want to connect a USB Bluetooth device to your
+  computer's USB port. You will need the Bluetooth stack (available
+  at http://developer.axis.com/software/index.shtml) to fully use
+  the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called bluetooth.o. If you want to compile it as 
+  a module, say M here and read Documentation/modules.txt.
+  
+Kawasaki USB ethernet controller support
+CONFIG_USB_KAWETH
+  Say Y here if you want support for devices based on the Kawasaki
+  LSI KL5KUSB100 USB to Ethernet 1-Chip Controller, such as the
+  NetGear EA101 USB to Ethernet Adapter.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called kaweth.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+ 
+Minix fs support
+CONFIG_MINIX_FS
+  Minix is a simple operating system used in many classes about OS's.
+  The minix filesystem (method to organize files on a hard disk
+  partition or a floppy disk) was the original filesystem for Linux,
+  but has been superseded by the second extended filesystem ext2fs.
+  You don't want to use the minix filesystem on your hard disk because
+  of certain built-in restrictions, but it is sometimes found on older
+  Linux floppy disks. This option will enlarge your kernel by about 
+  25 kB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called minix.o. Note that the filesystem of your root partition (the
+  one containing the directory /) cannot be compiled as a module.
+
+Second extended fs support
+CONFIG_EXT2_FS
+  This is the de facto standard Linux filesystem (method to organize
+  files on a storage device) for hard disks. 
+
+  You want to say Y here, unless you intend to use Linux exclusively
+  from inside a DOS partition using the umsdos filesystem. The
+  advantage of the latter is that you can get away without
+  repartitioning your hard drive (which often implies backing
+  everything up and restoring afterwards); the disadvantage is that
+  Linux becomes susceptible to DOS viruses and that umsdos is somewhat
+  slower than ext2fs. Even if you want to run Linux in this fashion,
+  it might be a good idea to have ext2fs around: it enables you to
+  read more floppy disks and facilitates the transition to a *real*
+  Linux partition later. Another (rare) case which doesn't require
+  ext2fs is a diskless Linux box which mounts all files over the
+  network using NFS (in this case it's sufficient to say Y to "NFS
+  filesystem support" below). Saying Y here will enlarge your kernel
+  by about 41 kB.
+
+  The Ext2fs-Undeletion mini-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini,
+  gives information about how to retrieve deleted files on ext2fs
+  filesystems.
+
+  To change the behavior of ext2 filesystems, you can use the tune2fs
+  utility ("man tune2fs"). To modify attributes of files and
+  directories on ext2 filesystems, use chattr ("man chattr").
+  
+  Ext2fs partitions can be read from within DOS using the ext2tool
+  command line tool package (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/ext2) and from
+  within Windows NT using the ext2nt command line tool package from
+  ftp://metalab.unc.edu/pub/Linux/utils/dos. Explore2fs is a graphical
+  explorer for ext2fs partitions which runs on Windows 95 and Windows
+  NT and includes experimental write support; it is available from
+  http://jnewbigin-pc.it.swin.edu.au/Linux/Explore2fs.htm.
+
+  If you want to compile this filesystem as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called ext2.o. Be aware however that the filesystem of your
+  root partition (the one containing the directory /) cannot be
+  compiled as a module, and so this could be dangerous. Most everyone
+  wants to say Y here.
+
+ISO 9660 CDROM filesystem support
+CONFIG_ISO9660_FS
+  This is the standard filesystem used on CDROMs. It was previously
+  known as "High Sierra Filesystem" and is called "hsfs" on other Unix
+  systems. The so-called Rock-Ridge extensions which allow for long
+  Unix filenames and symbolic links are also supported by this driver.
+  If you have a CDROM drive and want to do more with it than just
+  listen to audio CDs and watch its LEDs, say Y (and read
+  Documentation/filesystems/isofs.txt and the CDROM-HOWTO, available
+  via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO), thereby enlarging your
+  kernel by about 27 kB; otherwise say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called isofs.o.
+
+Microsoft Joliet cdrom extensions
+CONFIG_JOLIET
+  Joliet is a Microsoft extension for the ISO 9660 CDROM filesystem
+  which allows for long filenames in unicode format (unicode is the
+  new 16 bit character code, successor to ASCII, which encodes the
+  characters of almost all languages of the world; see
+  http://www.unicode.org for more information; to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape). Say Y here if you want to be able to read
+  Joliet CDROMs under Linux.
+
+fat fs support
+CONFIG_FAT_FS
+  If you want to use one of the FAT-based filesystems (the MS-DOS,
+  VFAT (Windows 95) and UMSDOS (used to run Linux on top of an
+  ordinary DOS partition) filesystems), then you must say Y or M here
+  to include FAT support. You will then be able to mount partitions or
+  diskettes with FAT-based filesystems and transparently access the
+  files on them, i.e. MSDOS files will look and behave just like all
+  other Unix files.
+
+  This FAT support is not a filesystem in itself, it only provides the
+  foundation for the other filesystems. You will have to say Y or M to
+  at least one of "msdos fs support" or "vfat fs support" in order to
+  make use of it.
+
+  Another way to read and write MSDOS floppies and hard drive
+  partitions from within Linux (but not transparently) is with the
+  mtools ("man mtools") program suite. This doesn't require the FAT
+  filesystem support.
+
+  It is now also becoming possible to read and write compressed FAT
+  filesystems; read Documentation/filesystems/fat_cvf.txt for details.
+  
+  The FAT support will enlarge your kernel by about 24 kB. If unsure,
+  say Y.
+
+  If you want to compile this as a module however ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called fat.o. Note that if you compile the FAT support as a
+  module, you cannot compile any of the FAT-based filesystems into the
+  kernel -- they will have to be modules as well. The filesystem of
+  your root partition (the one containing the directory /) cannot be a
+  module, so don't say M here if you intend to use UMSDOS as your root
+  filesystem.
+
+msdos fs support
+CONFIG_MSDOS_FS
+  This allows you to mount MSDOS partitions of your hard drive (unless
+  they are compressed; to access compressed MSDOS partitions under
+  Linux, you can either use the DOS emulator DOSEMU, described in the
+  DOSEMU-HOWTO, available via FTP (user: anonymous) at
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO, or try dmsdosfs in
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/dosfs. If you
+  intend to use dosemu with a non-compressed MSDOS partition, say Y
+  here) and MSDOS floppies. This means that file access becomes
+  transparent, i.e. the MSDOS files look and behave just like all
+  other Unix files.
+
+  If you want to use umsdos, the Unix-like filesystem on top of DOS,
+  which allows you to run Linux from within a DOS partition without
+  repartitioning, you'll have to say Y or M here. 
+
+  If you have Windows 95 or Windows NT installed on your MSDOS
+  partitions, you should use the VFAT filesystem (say Y to "vfat fs
+  support" below), or you will not be able to see the long filenames
+  generated by Windows 95 / Windows NT.
+
+  This option will enlarge your kernel by about 7 kB. If unsure,
+  answer Y. This will only work if you said Y to "fat fs support" as
+  well. If you want to compile this as a module however ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called msdos.o.
+
+vfat fs support
+CONFIG_VFAT_FS
+  This option provides support for normal Windows filesystems with
+  long filenames. That includes non-compressed FAT-based filesystems
+  used by Windows 95, Windows 98, Windows NT 4.0, and mtools. 
+
+  You cannot use the VFAT filesystem for your Linux root partition
+  (the one containing the directory /); use UMSDOS instead if you
+  want to run Linux from within a DOS partition (i.e. say Y to
+  "umsdos: Unix like fs on top of std MSDOS fs", below).
+
+  The VFAT support enlarges your kernel by about 10 kB and it only
+  works if you said Y to the "fat fs support" above. Please read the
+  file Documentation/filesystems/vfat.txt for details. If unsure, 
+  say Y.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called vfat.o.
+
+umsdos: Unix like fs on top of std MSDOS fs
+CONFIG_UMSDOS_FS
+  Say Y here if you want to run Linux from within an existing DOS
+  partition of your hard drive. The advantage of this is that you can
+  get away without repartitioning your hard drive (which often implies
+  backing everything up and restoring afterwards) and hence you're
+  able to quickly try out Linux or show it to your friends; the
+  disadvantage is that Linux becomes susceptible to DOS viruses and
+  that UMSDOS is somewhat slower than ext2fs. Another use of UMSDOS
+  is to write files with long unix filenames to MSDOS floppies; it
+  also allows Unix-style softlinks and owner/permissions of files on
+  MSDOS floppies. You will need a program called umssync in order to
+  make use of umsdos; read Documentation/filesystems/umsdos.txt. 
+
+  This option enlarges your kernel by about 25 kB and it only works if
+  you said Y to both "fat fs support" and "msdos fs support" above. If
+  you want to compile this as a module ( = code which can be inserted
+  in and removed from the running kernel whenever you want), say M
+  here and read Documentation/modules.txt. The module will be called
+  umsdos.o. Note that the filesystem of your root partition (the one
+  containing the directory /) cannot be a module, so saying M could be
+  dangerous. If unsure, say N.
+
+/proc filesystem support
+CONFIG_PROC_FS
+  This is a virtual filesystem providing information about the status
+  of the system. "Virtual" means that it doesn't take up any space on
+  your hard disk: the files are created on the fly by the kernel when
+  you try to access them. Also, you cannot read the files with older
+  version of the program less: you need to use more or cat. 
+
+  It's totally cool; for example, "cat /proc/interrupts" gives
+  information about what the different IRQs are used for at the moment
+  (there is a small number of Interrupt ReQuest lines in your computer
+  that are used by the attached devices to gain the CPU's attention --
+  often a source of trouble if two devices are mistakenly configured
+  to use the same IRQ). 
+
+  The /proc filesystem is explained in the file
+  Documentation/proc.txt, in the Kernel Hacker's Guide at
+  http://www.redhat.com:8080/HyperNews/get/khg.html on the WWW (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape), and also on the proc(8)
+  manpage ("man 8 proc").
+
+  This option will enlarge your kernel by about 18 KB. Several
+  programs depend on this, so everyone should say Y here.
+
+NFS filesystem support
+CONFIG_NFS_FS
+  If you are connected to some other (usually local) Unix computer
+  (using SLIP, PLIP, PPP or Ethernet) and want to mount files residing
+  on that computer (the NFS server) using the Network File Sharing
+  protocol, say Y. "Mounting files" means that the client can access
+  the files with usual UNIX commands as if they were sitting on the
+  client's hard disk. For this to work, the server must run the
+  programs nfsd and mountd (but does not need to have NFS filesystem
+  support enabled in its kernel). NFS is explained in the Network
+  Administrator's Guide, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/LDP, on its man page: "man
+  nfs", and in the NFS-HOWTO.
+  
+  A superior but less widely used alternative to NFS is provided by
+  the Coda filesystem; see "Coda filesystem support" below.
+
+  If you say Y here, you should have said Y to TCP/IP networking also.
+  This option would enlarge your kernel by about 27 kB. 
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  If you are configuring a diskless machine which will mount its root
+  filesystem over NFS at boot time, say Y here and to "IP: kernel
+  level autoconfiguration" above and to "Root file system on NFS"
+  below. You cannot compile this driver as a module in this case.
+  There are two packages designed for booting diskless machines over
+  the net: netboot and etherboot, both available via FTP from
+  ftp://metalab.unc.edu/pub/Linux/system/boot/ethernet/ .
+
+  If you don't know what all this is about, say N.
+
+Root file system on NFS
+CONFIG_ROOT_NFS
+  If you want your Linux box to mount its whole root filesystem (the
+  one containing the directory /) from some other computer over the
+  net via NFS (presumably because your box doesn't have a hard disk),
+  say Y. Read Documentation/nfsroot.txt for details. It is likely that
+  in this case, you also want to say Y to "IP: kernel level
+  autoconfiguration" so that your box can discover its network address
+  at boot time.
+  
+  Most people say N here. 
+
+NFS server support
+CONFIG_NFSD
+  If you want your Linux box to act as an NFS *server*, so that other
+  computers on your local network which support NFS can access certain
+  directories on your box transparently, you have two options: you can
+  use the self-contained user space program nfsd, in which case you
+  should say N here, or you can say Y and use the kernel based NFS
+  server. The kernel based solution is faster and is now the recommended
+  solution: no further development is occurring on the userspace server and
+  support of it may be discontinued in future.
+
+  In either case, you will need support software; the respective
+  locations are given in the file Documentation/Changes in the NFS
+  section.
+
+  Please read the NFS-HOWTO, available from
+  http://www.linuxdoc.org/HOWTO/NFS-HOWTO.html .
+
+
+  The NFS server is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfsd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Provide NFSv3 server support (EXPERIMENTAL)
+CONFIG_NFSD_V3
+  If you would like to include the NFSv3 server as well as the NFSv2
+  server, say Y here.  File locking, via the NLMv4 protocol, is now
+  supported. If unsure, say N.
+
+OS/2 HPFS filesystem support (read only)
+CONFIG_HPFS_FS
+  OS/2 is IBM's operating system for PC's, the same as Warp, and HPFS
+  is the filesystem used for organizing files on OS/2 hard disk
+  partitions. Say Y if you want to be able to read files from an OS/2
+  HPFS partition of your hard drive. OS/2 floppies however are in
+  regular MSDOS format, so you don't need this option in order to be
+  able to read them. Read Documentation/filesystems/hpfs.txt. 
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called hpfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Windows NT NTFS support (read only)
+CONFIG_NTFS_FS
+  NTFS is the file system of Microsoft Windows NT. Say Y if you want
+  to get read access to files on NTFS partitions of your hard drive.
+  The Linux NTFS driver supports most of the mount options of the VFAT
+  driver, see Documentation/filesystems/ntfs.txt. Saying Y here will
+  give you read-only access to NTFS partitions.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ntfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+NTFS read-write support (DANGEROUS)
+CONFIG_NTFS_RW
+  If you say Y here, you will (maybe) be able to write to NTFS file
+  systems as well as read from them. The read-write support in
+  NTFS is far from being complete and is not well tested. If you
+  enable this, back up your NTFS volume first since it may get
+  damaged. Also, make sure to run chkdsk from within Microsoft
+  Windows NT after having performed any writes to a NTFS partition
+  from Linux to detect any problems as early as possible.
+  Please note that write support is limited to Windows NT4 and
+  earlier versions.
+
+  If unsure, say N.
+
+System V, Version 7 and Coherent filesystem support
+CONFIG_SYSV_FS
+  SCO, Xenix and Coherent are commercial Unix systems for Intel
+  machines, and Version 7 was used on the DEC PDP-11. Saying Y here
+  would allow you to read to and write from their floppies and hard
+  disk partitions.
+
+  If you have floppies or hard disk partitions like that, it is likely
+  that they contain binaries from those other Unix systems; in order
+  to run these binaries, you will want to install iBCS2 (Intel Binary
+  Compatibility Standard is a kernel module which lets you run SCO,
+  Xenix, Wyse, UnixWare, Dell Unix and System V programs under Linux
+  and is often needed to run commercial software that's only available
+  for those systems. It's available via FTP (user: anonymous) from
+  ftp://tsx-11.mit.edu/pub/linux/BETA).
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the System V filesystem support
+  (but you need NFS filesystem support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar"). Note also that this option has
+  nothing whatsoever to do with the option "System V IPC". Read about
+  the System V filesystem in Documentation/filesystems/sysv-fs.txt.
+  Saying Y here will enlarge your kernel by about 34 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called sysv.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+Amiga FFS filesystem support
+CONFIG_AFFS_FS
+  The Fast File System (FFS) is the common filesystem used on hard
+  disks by Amiga(tm) systems since AmigaOS Version 1.3 (34.20). Say Y
+  if you want to be able to read and write files from and to an Amiga
+  FFS partition on your hard drive. Amiga floppies however cannot be
+  read with this driver due to an incompatibility of the floppy
+  controller used in an Amiga and the standard floppy controller in
+  PCs and workstations. Read Documentation/filesystems/affs.txt and
+  fs/affs/Changes. 
+
+  With this driver you can also mount disk files used by Bernd
+  Schmidt's Un*X Amiga Emulator (http://www.freiburg.linux.de/~uae/;
+  to browse the WWW, you need to have access to a machine on the
+  Internet that has a program like lynx or netscape). If you want to
+  do this, you will also need to say Y or M to "Loop device support",
+  above.
+
+  This filesystem is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called affs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Apple Macintosh filesystem support (experimental)
+CONFIG_HFS_FS
+  If you say Y here, you will be able to mount Macintosh-formatted
+  floppy disks and hard drive partitions with full read-write access.
+  Please read fs/hfs/HFS.txt to learn about the available mount
+  options. 
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called hfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+ROM filesystem support
+CONFIG_ROMFS_FS
+  This is a very small read-only filesystem mainly intended for
+  initial ram disks of installation disks, but it could be used for
+  other read-only media as well. Read
+  Documentation/filesystems/romfs.txt for details. 
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called romfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4 filesystem support (EXPERIMENTAL)
+CONFIG_QNX4FS_FS  
+  This is the filesystem used by the operating system QNX 4. Say Y if
+  you intend to mount QNX hard disks or floppies. Unless you say Y to
+  "QNX4FS write support" below, you will only be able to read
+  these filesystems.
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called qnx4.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4FS write support (DANGEROUS)
+CONFIG_QNX4FS_RW
+  Say Y if you want to test write support for QNX4 filesystems.
+
+Kernel automounter support
+CONFIG_AUTOFS_FS
+  The automounter is a tool to automatically mount remote filesystems
+  on demand. This implementation is partially kernel-based to reduce
+  overhead in the already-mounted case; this is unlike the BSD
+  automounter (amd), which is a pure user space daemon.
+
+  To use the automounter you need the user-space tools from
+  ftp://ftp.kernel.org/pub/linux/daemons/autofs; you also want to
+  answer Y to "NFS filesystem support", below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called autofs.o. 
+
+  If you are not a part of a fairly large, distributed network, you
+  probably do not need an automounter, and can say N here.
+
+UFS filesystem support
+CONFIG_UFS_FS
+  BSD and derivate versions of Unix (such as SunOS, FreeBSD, NetBSD,
+  OpenBSD and NeXTstep) use a filesystem called UFS. Some System V
+  Unixes can create and mount hard disk partitions and diskettes using
+  this filesystem as well. Saying Y here will allow you to read from
+  these partitions; if you also want to write to them, say Y to the
+  experimental "UFS filesystem write support", below. Please read the
+  file Documentation/filesystems/ufs.txt for more information.
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the UFS filesystem support (but
+  you need NFS filesystem support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar").
+
+  When accessing NeXTstep files, you may need to convert them from the
+  NeXT character set to the Latin1 character set; use the program
+  recode ("info recode") for this purpose. 
+
+  If you want to compile the UFS filesystem support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called ufs.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+UFS filesystem write support (experimental)
+CONFIG_UFS_FS_WRITE
+  Say Y here if you want to try writing to UFS partitions. This is
+  experimental, so you should back up your UFS partitions beforehand.
+
+EFS filesystem support (experimental)
+CONFIG_EFS_FS
+  EFS is the filesystem used for CDROMs and filesystems by SGI's IRIX.
+  This implementation only offers read-only access.  If you don't know
+  what all this is about, it's safe to say N.  For more information
+  about EFS see it's homepage at http://aeschi.ch.eu.org/efs.
+
+SGI disklabel support
+CONFIG_SGI_DISKLABEL
+  Say Y to this only if you plan on mounting disks with SGI disklabels.
+  This is not required to mount EFS-format CDROMs.
+
+BSD disklabel (FreeBSD partition tables) support
+CONFIG_BSD_DISKLABEL
+  FreeBSD uses its own hard disk partition scheme on your PC. It
+  requires only one entry in the primary partition table of your disk
+  and manages it similarly to DOS extended partitions, putting in its
+  first sector a new partition table in BSD disklabel format. Saying Y
+  here allows you to read these disklabels and further mount FreeBSD
+  partitions from within Linux if you have also said Y to "UFS
+  filesystem support", above. If you don't know what all this is
+  about, say N.
+
+SMD disklabel (Sun partition tables) support
+CONFIG_SMD_DISKLABEL
+  Like most systems, SunOS uses its own hard disk partition table
+  format, incompatible with all others. Saying Y here allows you to
+  read these partition tables and further mount SunOS disks from
+  within Linux if you have also said Y to "UFS filesystem support",
+  above. This is mainly used to carry data from a SPARC under SunOS to
+  your Linux box via a removable medium like magneto-optical or ZIP
+  drives; note however that a good portable way to transport files and
+  directories between unixes (and even other operating systems) is
+  given by the tar program ("man tar" or preferably "info tar"). If
+  you don't know what all this is about, say N.
+
+Solaris (x86) partition table support
+CONFIG_SOLARIS_X86_PARTITION
+  Like most systems, Solaris x86 uses its own hard disk partition
+  table format, incompatible with all others. Saying Y here allows you
+  to read these partition tables and further mount Solaris x86 disks
+  from within Linux if you have also said Y to "UFS filesystem
+  support", above.
+
+ADFS filesystem support (read only) (EXPERIMENTAL)
+CONFIG_ADFS_FS
+  The Acorn Disc Filing System is the standard filesystem of the
+  RiscOS operating system which runs on Acorn's ARM-based Risc PC
+  systems and the Acorn Archimedes range of machines. If you say Y
+  here, Linux will be able to read from ADFS partitions on hard drives
+  and from ADFS-formatted floppy discs.
+
+  The ADFS partition should be the first partition (i.e.,
+  /dev/[hs]d?1) on each of your drives.
+
+  This code is also available as a module called adfs.o ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say N.
+
+/dev/pts filesystem for Unix98 PTYs
+CONFIG_DEVPTS_FS
+  You should say Y here if you said Y to "Unix98 PTY support" above.
+  You'll then get a virtual filesystem which can be mounted on
+  /dev/pts with "mount -t devpts". This, together with the pseudo
+  terminal master multiplexer /dev/ptmx, is used for pseudo terminal
+  support as described in The Open Group's Unix98 standard: in order
+  to acquire a pseudo terminal, a process opens /dev/ptmx; the number
+  of the pseudo terminal is then made available to the process and the
+  pseudo terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example. 
+
+  The GNU C library glibc 2.1 contains the requisite support for this
+  mode of operation; you also need client programs that use the Unix98
+  API.
+
+UnixWare slices support (EXPERIMENTAL)
+CONFIG_UNIXWARE_DISKLABEL
+  Like some systems, UnixWare uses its own slice table inside a
+  partition (VTOC - Virtual Table of Contents). Its format is
+  incompatible with all other OSes. Saying Y here allows you to read
+  VTOC and further mount UnixWare partitions read-only from within
+  Linux if you have also said Y to "UFS filesystem support" or "System
+  V and Coherent filesystem support", above.
+
+  This is mainly used to carry data from a UnixWare box to your
+  Linux box via a removable medium like magneto-optical, ZIP or
+  removable IDE drives. Note, however, that a good portable way to
+  transport files and directories between unixes (and even other
+  operating systems) is given by the tar program ("man tar" or
+  preferably "info tar"). 
+
+  If you don't know what all this is about, say N.
+
+Macintosh partition map support
+CONFIG_MAC_PARTITION
+  Say Y here if you want your Linux system to be able to read the
+  partition tables of Macintosh hard drives, and thus use partitions
+  on those drives.
+
+SMB filesystem support (to mount Windows shares etc...)
+CONFIG_SMB_FS
+  SMB (Server Message Block) is the protocol Windows for Workgroups
+  (WfW), Windows 95/98, Windows NT and OS/2 Lan Manager use to share
+  files and printers over local networks. Saying Y here allows you to
+  mount their filesystems (often called "shares" in this context) and
+  access them just like any other Unix directory. Currently, this
+  works only if the Windows machines use TCP/IP as the underlying
+  transport protocol, and not NetBEUI. For details, read
+  Documentation/filesystems/smbfs.txt and the SMB-HOWTO, available via
+  FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  Note: if you just want your box to act as an SMB *server* and make
+  files and printing services available to Windows clients (which need
+  to have a TCP/IP stack), you don't need to say Y here; you can use
+  the program samba (available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/system/network/samba) for that.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  If you want to compile the SMB support as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called smbfs.o. Most people say N, however.
+
+use nls by default
+CONFIG_SMB_NLS_DEFAULT
+  Enabling this will make smbfs use nls translations by default. You
+  need to specify the local charset (CONFIG_NLS_DEFAULT) in the nls
+  settings and you need to give the default nls for the SMB server as
+  CONFIG_SMB_NLS_REMOTE.
+
+nls support setting
+CONFIG_SMB_NLS_REMOTE
+  This setting allows you to specify a default value for which
+  codepage the server uses. If this field is left blank no
+  translations will be done. The local codepage/charset default to
+  CONFIG_NLS_DEFAULT, you need to set that value in the NLS menu.
+
+Coda filesystem support
+CONFIG_CODA_FS
+  Coda is an advanced network filesystem, similar to NFS in that it
+  enables you to mount filesystems of a remote server and access them
+  with regular Unix commands as if they were sitting on your hard
+  disk. Coda has several advantages over NFS: support for disconnected
+  operation (e.g. for laptops), read/write server replication,
+  security model for authentication and encryption, persistent client
+  caches and write back caching.
+
+  If you say Y here, your Linux box will be able to act as a Coda
+  *client*. You will need user level code as well, both for the client
+  and server. Servers are currently user level, i.e. need no kernel
+  support. Please read Documentation/filesystems/coda.txt and check
+  out the Coda home page http://www.coda.cs.cmu.edu (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape).
+
+  If you want to compile the coda client support as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called coda.o. 
+
+NCP filesystem support (to mount NetWare volumes)
+CONFIG_NCP_FS
+  NCP (NetWare Core Protocol) is a protocol that runs over IPX and is
+  used by Novell NetWare clients to talk to file servers. It is to IPX
+  what NFS is to TCP/IP, if that helps. Saying Y here allows you to
+  mount NetWare file server volumes and to access them just like any
+  other Unix directory. For details, please read the file
+  Documentation/filesystems/ncpfs.txt in the kernel source and the
+  IPX-HOWTO on ftp://metalab.unc.edu/pub/Linux/docs/howto.
+
+  You do not have to say Y here if you want your Linux box to act as a
+  file *server* for Novell NetWare clients.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html (to
+  browse the WWW, you need to have access to a machine on the Internet
+  that has a program like lynx or netscape). 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ncpfs.o. Say N unless you are connected to a Novell network.
+
+Packet signatures
+CONFIG_NCPFS_PACKET_SIGNING
+  NCP allows packets to be signed for stronger security. If you want
+  security, say Y. Normal users can leave it off. To be able to use
+  packet signing you must use ncpfs > 2.0.12.
+
+Proprietary file locking
+CONFIG_NCPFS_IOCTL_LOCKING
+  Allows locking of records on remote volumes. Say N unless you have
+  special applications which are able to utilize this locking scheme.
+
+Clear remove/delete inhibit when needed
+CONFIG_NCPFS_STRONG
+  Allows manipulation of files flagged as Delete or Rename Inhibit. To
+  use this feature you must mount volumes with the ncpmount parameter
+  "-s" (ncpfs-2.0.12 and newer). Say Y unless you are not mounting
+  volumes with -f 444.
+
+Use NFS namespace when available
+CONFIG_NCPFS_NFS_NS
+  Allows you to utilize NFS namespace on NetWare servers. It brings
+  you case sensitive filenames. Say Y. You can disable it at
+  mount-time with the `-N nfs' parameter of ncpmount.
+
+Use OS2/LONG namespace when available
+CONFIG_NCPFS_OS2_NS
+  Allows you to utilize OS2/LONG namespace on NetWare servers.
+  Filenames in this namespace are limited to 255 characters, they are
+  case insensitive, and case in names is preserved. Say Y. You can
+  disable it at mount time with the -N os2 parameter of ncpmount.
+
+Lowercase DOS filenames on LONG namespace volume
+CONFIG_NCPFS_SMALLDOS
+  If you say Y here, every filename on a NetWare server volume using
+  the OS2/LONG namespace will be converted to lowercase characters.
+  (For regular NetWare file server volumes with DOS namespace, this is
+  done automatically, even if you say N here.) Saying N here will give
+  you these filenames in uppercase.
+  
+  This is only a cosmetic option since the OS2/LONG namespace is case
+  insensitive. The only major reason for this option is backward
+  compatibility when moving from DOS to OS2/LONG namespace support.
+  Long filenames (created by Win95) will not be affected.
+
+  This option does not solve the problem that filenames appear
+  differently under Linux and under Windows, since Windows does an
+  additional conversions on the client side. You can achieve similar
+  effects by saying Y to "Allow using of Native Language Support"
+  below.
+
+Allow mounting of volume subdirectories
+CONFIG_NCPFS_MOUNT_SUBDIR
+  Allows you to mount not only whole servers or whole volumes, but
+  also subdirectories from a volume. It can be used to reexport data
+  and so on. There is no reason to say N, so Y is recommended unless
+  you count every byte.
+
+  To utilize this feature you must use ncpfs-2.0.12 or newer.
+
+NDS interserver authentication domains
+CONFIG_NCPFS_NDS_DOMAINS
+  This allows storing NDS private keys in kernel space where they
+  can be used to authenticate another server as interserver NDS
+  accesses need it. You must use ncpfs-2.0.12.1 or newer to utilize
+  this feature. Say Y if you are using NDS connections to NetWare
+  servers. Do not say Y if security is primary for you because root
+  can read your session key (from /proc/kcore).
+
+Allow using of Native Language Support
+CONFIG_NCPFS_NLS
+  Allows you to use codepages and I/O charsets for file name
+  translation between the server file system and input/output. This
+  may be useful, if you want to access the server with other operating
+  systems, e.g. Windows 95. See also NLS for more Information.
+
+  To select codepages and I/O charsets use ncpfs-2.2.0.13 or newer.
+
+Symbolic links and mode permission bits
+CONFIG_NCPFS_EXTRAS
+  This enables the use of symbolic links and an execute permission
+  bit on NCPFS. The file server need not have long name space or NFS
+  name space loaded for these to work.
+
+  To use the new attributes, it is recommended to use the flags
+  '-f 600 -d 755' on the ncpmount command line.
+
+nls default codepage
+CONFIG_NLS_DEFAULT
+  The default NLS used when mounting filesystem. Currently, the valid
+  values are cp437, cp737, cp775, cp850, cp852, cp855, cp857, cp860,
+  cp861, cp862, cp863, cp864, cp865, cp866, cp869, cp874, cp932, cp936,
+  cp949, cp950, iso8859-1, iso8859-2, iso8859-3, iso8859-4, iso8859-5,
+  iso8859-6, iso8859-7, iso8859-8, iso8859-9, iso8859-14, iso8859-15, 
+  koi8-r.  If you specify a wrong value, it will use the built-in NLS; 
+  compatible with iso8859-1.
+
+  If unsure, specify it as "cp437".
+
+nls codepage 437
+CONFIG_NLS_CODEPAGE_437
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used in
+  the United States and parts of Canada. This is recommended.
+
+nls codepage 737
+CONFIG_NLS_CODEPAGE_737
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  Greek. If unsure, say N.
+
+nls codepage 775
+CONFIG_NLS_CODEPAGE_775
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used
+  for the Baltic Rim Languages. If unsure, say N.
+
+nls codepage 850
+CONFIG_NLS_CODEPAGE_850
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  much of Europe -- United Kingdom, Germany, Spain, Italy, and [add
+  more countries here]. It has some characters useful to many European
+  languages that are not part of the US codepage 437. 
+
+  If unsure, say Y.
+
+nls codepage 852
+CONFIG_NLS_CODEPAGE_852
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the Latin 2 codepage used by DOS
+  for much of Central and Eastern Europe. It has all the required
+  characters for these languages: Albanian, Croatian, Czech, English,
+  Finnish, Hungarian, Irish, German, Polish, Romanian, Serbian (Latin
+  transcription), Slovak, Slovenian, and Sorbian.
+
+nls codepage 855
+CONFIG_NLS_CODEPAGE_855
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Cyrillic.
+
+nls codepage 857
+CONFIG_NLS_CODEPAGE_857
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Turkish.
+
+nls codepage 860
+CONFIG_NLS_CODEPAGE_860
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Portuguese.
+
+nls codepage 861
+CONFIG_NLS_CODEPAGE_861
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Icelandic.
+
+nls codepage 862
+CONFIG_NLS_CODEPAGE_862
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Hebrew.
+
+nls codepage 863
+CONFIG_NLS_CODEPAGE_863
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Canadian
+  French.
+
+nls codepage 864
+CONFIG_NLS_CODEPAGE_864
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Arabic.
+
+nls codepage 865
+CONFIG_NLS_CODEPAGE_865
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for the Nordic
+  European countries.
+
+nls codepage 866
+CONFIG_NLS_CODEPAGE_866
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for
+  Cyrillic/Russian.
+
+nls codepage 869
+CONFIG_NLS_CODEPAGE_869
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Greek.
+###
+### Why do we have two codepages for Greek and Cyrillic?
+###
+
+nls codepage 874
+CONFIG_NLS_CODEPAGE_874
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Thai.
+
+nls codepage 932
+CONFIG_NLS_CODEPAGE_932
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Shift-JIS.
+
+nls codepage 936
+CONFIG_NLS_CODEPAGE_936
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Simplified
+  Chinese(GBK).
+
+nls codepage 949
+CONFIG_NLS_CODEPAGE_949
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for UHC.
+
+nls codepage 950
+CONFIG_NLS_CODEPAGE_950
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Traditional
+  Chinese(Big5).
+
+nls iso8859-1
+CONFIG_NLS_ISO8859_1
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 1 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Faeroese, Finnish, French, German,
+  Galician, Irish, Icelandic, Italian, Norwegian, Portuguese, Spanish,
+  and Swedish. It is also the default for the US. If unsure, say Y.
+
+nls iso8859-2
+CONFIG_NLS_ISO8859_2
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 2 character
+  set, which works for most Latin-written Slavic and Central European
+  languages: Czech, German, Hungarian, Polish, Rumanian, Croatian,
+  Slovak, Slovene.
+
+nls iso8859-3
+CONFIG_NLS_ISO8859_3
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 3 character
+  set, which is popular with authors of Esperanto, Galician, Maltese,
+  and Turkish.
+
+nls iso8859-4
+CONFIG_NLS_ISO8859_4
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 4 character
+  set which introduces letters for Estonian, Latvian, and
+  Lithuanian. It is an incomplete predecessor of Latin 6.
+
+nls iso8859-5
+CONFIG_NLS_ISO8859_5
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-5, a Cyrillic
+  character set with which you can type Bulgarian, Byelorussian,
+  Macedonian, Russian, Serbian, and Ukrainian. Note that the charset
+  KOI8-R is preferred in Russia.
+
+nls iso8859-6
+CONFIG_NLS_ISO8859_6
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-6, the Arabic
+  character set.
+
+nls iso8859-7
+CONFIG_NLS_ISO8859_7
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-7, the Modern
+  Greek character set.
+
+nls iso8859-8
+CONFIG_NLS_ISO8859_8
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-8, the Hebrew
+  character set.
+
+nls iso8859-9
+CONFIG_NLS_ISO8859_9
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 5 character
+  set, and it replaces the rarely needed Icelandic letters in Latin 1
+  with the Turkish ones. Useful in Turkey.
+
+nls iso8859-10
+CONFIG_NLS_ISO8859_10
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 6 character
+  set, which adds the last Inuit (Greenlandic) and Sami (Lappish)
+  letters that were missing in Latin 4 to cover the entire Nordic
+  area.
+
+nls iso8859-14
+CONFIG_NLS_ISO8859_14
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 8 character
+  set, which adds the last accented vowels for Welsh (and Manx Gaelic)
+  that were missing in Latin 1. http://linux.speech.cymru.org/
+  has further information.
+
+nls iso8859-15
+CONFIG_NLS_ISO8859_15
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 9 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Estonian, Faeroese, Finnish,
+  French, German, Galician, Irish, Icelandic, Italian, Norwegian,
+  Portuguese, Spanish, and Swedish. Latin 9 is an update to
+  Latin 1 (ISO 8859-1) that removes a handful of rarely used
+  characters and instead adds support for Estonian, corrects the
+  support for French and Finnish, and adds the new Euro character.  If
+  unsure, say Y.
+
+nls koi8-r
+CONFIG_NLS_KOI8_R
+  If you want to display filenames with native language characters
+  from the Microsoft fat filesystem family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the preferred Russian
+  character set.
+
+Virtual terminal
+CONFIG_VT
+  If you say Y here, you will get support for terminal devices with
+  display and keyboard devices. These are called "virtual" because you
+  can run several virtual terminals (also called virtual consoles) on
+  one physical terminal. This is rather useful, for example one
+  virtual terminal can collect system messages and warnings, another
+  one can be used for a text-mode user session, and a third could run
+  an X session, all in parallel. Switching between virtual terminals
+  is done with certain key combinations, usually Alt-<function key>.
+
+  The setterm command ("man setterm") can be used to change the
+  properties (such as colors) of a virtual terminal.
+
+  You need at least one virtual terminal device in order to make use
+  of your keyboard and monitor. Therefore, only people configuring an
+  embedded system would want to say N here in order to save some
+  memory; the only way to log into such a system is then via a serial
+  or network connection.
+
+  If unsure, say Y, or else you won't be able to do much with your new
+  shiny Linux system :-)
+
+Support for console on virtual terminal
+CONFIG_VT_CONSOLE
+  The system console is the device which receives all kernel messages
+  and warnings and which allows logins in single user mode. If you
+  answer Y here, a virtual terminal (the device used to interact with
+  a physical terminal) can be used as system console. This is the most
+  common mode of operations, so you should say Y here unless you want
+  the kernel messages be output only to a serial port (in which case
+  you should say Y to "Console on serial port", below).
+
+  If you do say Y here, by default the currently visible virtual
+  terminal (/dev/tty0) will be used as system console. You can change
+  that with a kernel command line option such as "console=tty3" which
+  would use the third virtual terminal as system console. (Try "man
+  bootparam" or see the documentation of your boot loader (lilo or
+  loadlin) about how to pass options to the kernel at boot time. The
+  lilo procedure is also explained in the SCSI-HOWTO, available via
+  FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+
+  If unsure, say Y.
+
+Software generated cursor
+CONFIG_SOFTCURSOR
+  If you say Y here, you'll be able to do lots of nice things with the
+  cursors of your virtual consoles -- for example turn them into
+  non-blinking block cursors which are more visible on laptop screens,
+  or change their colors depending on the virtual console they're on.
+  See Documentation/VGA-softcursor.txt for more information.
+
+Support for PowerMac keyboard
+CONFIG_MAC_KEYBOARD
+  This option allows you to use an ADB keyboard attached to your
+  machine. Note that this disables any other (ie. PS/2) keyboard
+  support, even if your machine is physically capable of using both at
+  the same time.
+  
+  If you use an ADB keyboard (4 pin connector), say Y here.
+  If you use a PS/2 keyboard (6 pin connector), say N here.
+
+Standard/generic serial support
+CONFIG_SERIAL
+  This selects whether you want to include the driver for the standard
+  serial ports. The standard answer is Y. People who might say N here
+  are those that are setting up dedicated Ethernet WWW/FTP servers, or
+  users that have one of the various bus mice instead of a serial
+  mouse and don't intend to use their machine's standard serial port
+  for anything. (Note that the Cyclades and Stallion multi serial port
+  drivers do not need this driver built in for them to work.)
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called serial.o.
+  [WARNING: Do not compile this driver as a module if you are using
+  non-standard serial ports, since the configuration information will
+  be lost when the driver is unloaded. This limitation may be lifted
+  in the future.]
+
+  BTW1: If you have a mouseman serial mouse which is not recognized by
+  the X window system, try running gpm first. 
+  
+  BTW2: If you intend to connect a so-called Winmodem to your
+  machine's serial port, forget it. These modems are crippled and
+  require proprietary drivers which are only available under Windows.
+
+  Most people will say Y or M here, so that they can use serial mice,
+  modems and similar devices connecting to the standard serial ports.
+
+Support for console on serial port
+CONFIG_SERIAL_CONSOLE
+  If you say Y here, it will be possible to use a serial port as the
+  system console (the system console is the device which receives all
+  kernel messages and warnings and which allows logins in single user
+  mode). This could be useful if some terminal or printer is connected
+  to that serial port.
+
+  Even if you say Y here, the currently visible virtual console
+  (/dev/tty0) will still be used as the system console by default, but
+  you can alter that using a kernel command line option such as
+  "console=ttyS1". (Try "man bootparam" or see the documentation of
+  your boot loader (lilo or loadlin) about how to pass options to the
+  kernel at boot time. The lilo procedure is also explained in the
+  SCSI-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.) 
+
+  If you don't have a VGA card installed and you say Y here, the
+  kernel will automatically use the first serial line, /dev/ttyS0, as
+  system console.
+
+  If unsure, say N.
+
+Support for PowerMac serial ports
+CONFIG_MAC_SERIAL
+  If you have Macintosh style serial ports (8 pin mini-DIN), say Y
+  here. If you also have regular serial ports and enable the driver
+  for them, you can't currently use the serial console feature.
+
+Comtrol Rocketport support
+CONFIG_ROCKETPORT
+  This is a driver for the Comtrol Rocketport cards which provide
+  multiple serial ports. You would need something like this to connect
+  more than two modems to your Linux box, for instance in order to
+  become a dial-in server.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called rocket.o.
+
+Digiboard Intelligent async support
+CONFIG_DIGIEPCA
+  This is a driver for Digi International's Xx, Xeve, and Xem series
+  of cards which provide multiple serial ports. You would need
+  something like this to connect more than two modems to your Linux
+  box, for instance in order to become a dial-in server. This driver
+  supports the original PC (ISA) boards as well as PCI, and EISA. If
+  you have a card like this, say Y here and read the file
+  Documentation/digiepca.txt.
+
+  NOTE: There is another, separate driver for the Digiboard PC boards:
+  "Digiboard PC/Xx Support" below. You should (and can) only select
+  one of the two drivers. 
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called epca.o.
+
+Digiboard PC/Xx Support
+CONFIG_DIGI
+  This is a driver for the Digiboard PC/Xe, PC/Xi, and PC/Xeve cards
+  that give you many serial ports. You would need something like this
+  to connect more than two modems to your Linux box, for instance in
+  order to become a dial-in server. If you have a card like that, say
+  Y here and read the file Documentation/digiboard.txt.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called pcxx.o.
+
+SDL RISCom/8 card support
+CONFIG_RISCOM8
+  This is a driver for the SDL Communications RISCom/8 multiport card,
+  which gives you many serial ports. You would need something like
+  this to connect more than two modems to your Linux box, for instance
+  in order to become a dial-in server. If you have a card like that,
+  say Y here and read the file Documentation/riscom8.txt.
+
+  Also it's possible to say M here and compile this driver as kernel
+  loadable module; the module will be called riscom8.o.
+
+Specialix IO8+ card support
+CONFIG_SPECIALIX
+  This is a driver for the Specialix IO8+ multiport card (both the
+  ISA and the PCI version) which gives you many serial ports. You 
+  would need something like this to connect more than two modems to 
+  your Linux box, for instance in order to become a dial-in server.
+
+  If you have a card like that, say Y here and read the file
+  Documentation/specialix.txt. Also it's possible to say M here and
+  compile this driver as kernel loadable module which will be called
+  specialix.o.
+
+Specialix DTR/RTS pin is RTS
+CONFIG_SPECIALIX_RTSCTS
+  The Specialix card can only support either RTS or DTR. If you say N
+  here, the driver will use the pin as "DTR" when the tty is in
+  software handshake mode. If you say Y here or hardware handshake is
+  on, it will always be RTS. Read the file Documentation/specialix.txt
+  for more information.
+
+Specialix SX card support
+CONFIG_SX
+  This is a driver for the Specialix SX multiport card (both the
+  ISA and the PCI version of both the older SI/XIO and the newer SX
+  variants of the card) which gives you many serial ports. You
+  would need something like this to connect more than two modems to 
+  your Linux box, for instance in order to become a dial-in server.
+  You will also need the specialix_sxtools package to be able to 
+  initialize and use the SX system. This driver does NOT support 
+  the rev 1 cards (+/- 1990), or the EISA version of the card. Sorry.
+
+  If you have one of these cards, say Y here and read the file
+  Documentation/sx.txt. Also it's possible to say M here and
+  compile this driver as kernel loadable module which will be called
+  sx.o.
+
+Specialix RIO system support
+CONFIG_RIO
+  This is a driver for the Specialix RIO hostcard (both the
+  ISA and the PCI versions of the card). This hostcard allows you
+  to connect many remote terminal adapters, each supporting 8 or 16
+  serial ports. These cards are ideal if you have more than 100 
+  terminals that need to be connected to your server. (But don't 
+  worry if you have only 32 ports.... That works too). You will 
+  also need the specialix_riotools to be able to initialize and
+  configure your rio system.  
+
+  If you have one of these cards, say Y here. Also it's possible to 
+  say M here and compile this driver as kernel loadable module which 
+  will be called rio.o.
+
+Specialix OLD RIO/PCI support 
+CONFIG_RIO_OLDPCI
+  This turns on support for the older PCI card. If you include
+  this support, performance on the newer cards will suffer a bit.
+
+  If you have one of these cards, say Y here.
+
+Cyclades async mux support
+CONFIG_CYCLADES
+  This is a driver for a card that gives you many serial ports. You
+  would need something like this to connect more than two modems to
+  your Linux box, for instance in order to become a dial-in server.
+  For information about the Cyclades-Z card, read
+  drivers/char/README.cycladesZ.
+
+  As of 1.3.9x kernels, this driver's minor numbers start at 0 instead
+  of 32.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called cyclades.o. 
+
+  If you haven't heard about it, it's safe to say N.
+
+Cyclades-Z interrupt mode operation (EXPERIMENTAL)
+CONFIG_CYZ_INTR
+  The Cyclades-Z family of multiport cards allows 2 (two) driver
+  op modes: polling and interrupt. In polling mode, the driver will
+  check the status of the Cyclades-Z ports every certain amount of
+  time (which is called polling cycle and is configurable). In
+  interrupt mode, it will use an interrupt line (IRQ) in order to check
+  the status of the Cyclades-Z ports. The default op mode is polling.
+  If unsure, say N.
+
+Stallion multiport serial support 
+CONFIG_STALDRV
+  Stallion cards give you many serial ports. You would need something
+  like this to connect more than two modems to your Linux box, for
+  instance in order to become a dial-in server. If you say Y here, you
+  will be asked for your specific card model in the next questions.
+  Make sure to read drivers/char/README.stallion in this case. If you
+  have never heard about all this, it's safe to say N.
+
+Stallion EasyIO or EC8/32 support 
+CONFIG_STALLION
+  If you have an EasyIO or EasyConnection 8/32 multiport Stallion
+  card, then this is for you; say Y. Make sure to read
+  Documentation/stallion.txt. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called stallion.o.
+
+Stallion EC8/64, ONboard, Brumby support
+CONFIG_ISTALLION
+  If you have an EasyConnection 8/64, ONboard, Brumby or Stallion
+  serial multiport card, say Y here. Make sure to read
+  Documentation/stallion.txt. 
+
+  To compile it as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  istallion.o.
+
+Microgate SyncLink adapter support
+CONFIG_SYNCLINK
+  Provides support for the SyncLink ISA and PCI
+  multiprotocol serial adapters. These adapters
+  support asynchronous and HDLC bit synchronous
+  communication up to 10Mbps (PCI adapter).
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called synclink.o. If you want to do that, say M
+  here.
+
+Synchronous HDLC line discipline support
+CONFIG_N_HDLC
+  Allows synchronous HDLC communications with
+  tty device drivers that support synchronous
+  HDLC such as the Microgate SyncLink adapter.
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called n_hdlc.o. If you want to do that, say M
+  here.
+
+Hayes ESP serial port support
+CONFIG_ESPSERIAL
+  This is a driver which supports Hayes ESP serial ports. Both single
+  port cards and multiport cards are supported. Make sure to read
+  Documentation/hayes-esp.txt. 
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called esp.o.
+  If unsure, say N.
+
+Multi-Tech multiport card support
+CONFIG_ISI
+  This is a driver for the Multi-Tech cards which provide several
+  serial ports. The driver is experimental and can currently only be
+  built as a module ( = code which can be inserted in and removed from
+  the running kernel whenever you want). Please read
+  Documentation/modules.txt. The module will be called isicom.o
+
+Unix98 PTY support
+CONFIG_UNIX98_PTYS
+  A pseudo terminal (PTY) is a software device consisting of two
+  halves: a master and a slave. The slave device behaves identical to
+  a physical terminal; the master device is used by a process to
+  read data from and write data to the slave, thereby emulating a
+  terminal. Typical programs for the master side are telnet servers
+  and xterms.
+  
+  Linux has traditionally used the BSD-like names /dev/ptyxx for
+  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme
+  has a number of problems. The GNU C library glibc 2.1 and later,
+  however, supports the Unix98 naming standard: in order to acquire a
+  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo
+  terminal is then made available to the process and the pseudo
+  terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
+
+  The entries in /dev/pts/ are created on the fly by a virtual
+  filesystem; therefore, if you say Y here you should say Y to
+  "/dev/pts filesystem for Unix98 PTYs" as well.
+
+  If you want to say Y here, you need to have the C library glibc 2.1
+  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
+  Read the instructions in Documentation/Changes pertaining to pseudo
+  terminals. It's safe to say N.
+
+Maximum number of Unix98 PTYs in use (0-2048)
+CONFIG_UNIX98_PTY_COUNT
+  The maximum number of Unix98 PTYs that can be used at any one time.
+  The default is 256, and should be enough for desktop systems. Server
+  machines which support incoming telnet/rlogin/ssh connections and/or
+  serve several X terminals may want to increase this: every incoming
+  connection and every xterm uses up one PTY.
+
+  When not in use, each additional set of 256 PTYs occupy
+  approximately 8 KB of kernel memory on 32-bit architectures.
+
+Parallel printer support
+CONFIG_PRINTER
+  If you intend to attach a printer to the parallel port of your Linux
+  box (as opposed to using a serial printer; if the connector at the
+  printer has 9 or 25 holes ["female"], then it's serial), say Y. Also
+  read the Printing-HOWTO, available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  It is possible to share one parallel port among several devices
+  (e.g. printer and ZIP drive) and it is safe to compile the
+  corresponding drivers into the kernel. If you want to compile this
+  driver as a module however ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called lp.o. 
+
+  If you have several parallel ports, you can specify which ports to
+  use with the "lp" kernel command line option. (Try "man bootparam"
+  or see the documentation of your boot loader (lilo or loadlin)
+  about how to pass options to the kernel at boot time. The lilo
+  procedure is also explained in the SCSI-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.)
+  The syntax of the "lp" command line option can be found in
+  drivers/char/lp.c.
+
+  If you have more than 3 printers, you need to increase the LP_NO
+  variable in lp.c.
+
+Support IEEE1284 status readback
+CONFIG_PRINTER_READBACK
+  If your printer conforms to IEEE 1284, it may be able to provide a
+  status indication when you read from it (for example, with `cat
+  /dev/lp1'). To use this feature, say Y here.
+
+Mouse Support (not serial mice)
+CONFIG_MOUSE
+  This is for machines with a bus mouse or a PS/2 mouse as opposed to
+  a serial mouse. Most people have a regular serial MouseSystem or
+  Microsoft mouse (made by Logitech) that plugs into a COM port
+  (rectangular with 9 or 25 pins). These people say N here. If you
+  have something else, read the Busmouse-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO and
+  say Y here.
+
+  If you have a laptop, you either have to check the documentation or
+  experiment a bit to find out whether the trackball is a serial mouse
+  or not; it's best to say Y here for you. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-serial mice. If unsure, say Y.
+
+Logitech busmouse support
+CONFIG_BUSMOUSE
+  Logitech mouse connected to a proprietary interface card. It's
+  generally a round connector with 9 pins. Note that the newer mice
+  made by Logitech don't use the Logitech protocol anymore; for those,
+  you don't need this option. You want to read the Busmouse-HOWTO,
+  available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called busmouse.o. If you are unsure, say N and read the HOWTO
+  nevertheless: it will tell you what you have.
+
+PS/2 mouse (aka "auxiliary device") support
+CONFIG_PSMOUSE
+  The PS/2 mouse connects to a special mouse port that looks much like
+  the keyboard port (small circular connector with 6 pins). This way,
+  the mouse does not use any serial ports. This port can also be used
+  for other input devices like light pens, tablets, keypads. Compaq,
+  AST and IBM all use this as their mouse port on currently shipping
+  machines. The trackballs of some laptops are PS/2 mice also. In
+  particular, the C&T 82C710 mouse on TI Travelmates is a PS/2 mouse.
+
+  Although PS/2 mice are not technically bus mice, they are explained
+  in detail in the Busmouse-HOWTO, available via FTP (user: anonymous)
+  in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. 
+
+  When using a PS/2 mouse, you can get problems if you want to use the
+  mouse both on the Linux console and under X. Using the "-R" option
+  of the Linux mouse managing program gpm (available from
+  ftp://metalab.unc.edu/pub/Linux/system/Daemons) solves this
+  problem, or you can get the "mconv" utility also from metalab.
+
+C&T 82C710 mouse port support (as on TI Travelmate)
+CONFIG_82C710_MOUSE
+  This is a certain kind of PS/2 mouse used on the TI Travelmate. If
+  you are unsure, try first to say N here and come back if the mouse
+  doesn't work. Read the Busmouse-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+PC110 digitizer pad support
+CONFIG_PC110_PAD
+  This drives the digitizer pad on the IBM PC110 palmtop (see
+  http://toy.cabi.net; to browse the WWW, you need to have access to a
+  machine on the Internet that has a program like lynx or
+  netscape). It can turn the digitizer pad into a PS/2 mouse emulation
+  with tap gestures or into an absolute pad. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pc110pad.o.
+
+Microsoft busmouse support
+CONFIG_MS_BUSMOUSE
+  These animals (also called Inport mice) are connected to an
+  expansion board using a round connector with 9 pins. If this is what
+  you have, say Y and read the Busmouse-HOWTO, available via FTP
+  (user: anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have. Also be aware that several vendors talk
+  about 'Microsoft busmouse' and actually mean PS/2 busmouse -- so
+  count the pins on the connector.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called msbusmouse.o. 
+
+ATIXL busmouse support
+CONFIG_ATIXL_BUSMOUSE
+  This is a rare type of busmouse that is connected to the back of an
+  ATI video card. Note that most ATI mice are actually Microsoft
+  busmice. Read the Busmouse-HOWTO, available via FTP (user:
+  anonymous) in ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called atixlmouse.o. 
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have.
+
+Support for PowerMac ADB mouse
+CONFIG_ADBMOUSE
+  If you have an ADB mouse (4 pin connector) as is common on
+  Macintoshes, say Y here.
+
+QIC-02 tape support
+CONFIG_QIC02_TAPE
+  If you have a non-SCSI tape drive like that, say Y. Or, if you want
+  to compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  tpqic02.o.
+
+Do you want runtime configuration for QIC-02
+CONFIG_QIC02_DYNCONF
+  You can either configure this driver once and for all by editing a
+  header file (include/linux/tpqic02.h), in which case you should
+  say N, or you can fetch a program via anonymous FTP which is able
+  to configure this driver during runtime. The program to do this is
+  called 'qic02conf' and it is part of the tpqic02-support-X.Y.tar.gz
+  support package.
+
+  If you want to use the qic02conf program, say Y.
+
+Floppy tape drive (QIC-80/40/3010/3020/TR-1/TR-2/TR-3) support
+CONFIG_FTAPE
+  If you have a tape drive that is connected to your floppy
+  controller, say Y here. 
+
+  Some tape drives (like the Seagate "Tape Store 3200" or the Iomega
+  "Ditto 3200" or the Exabyte "Eagle TR-3") come with a "high speed"
+  controller of their own. These drives (and their companion
+  controllers) are also supported if you say Y here. 
+
+  If you have a special controller (such as the CMS FC-10, FC-20,
+  Mountain Mach-II, or any controller that is based on the Intel 82078
+  FDC like the high speed controllers by Seagate and Exabyte and
+  Iomega's "Ditto Dash") you must configure it by selecting the
+  appropriate entries from the "Floppy tape controllers" sub-menu
+  below and possibly modify the default values for the IRQ and DMA
+  channel and the IO base in ftape's configuration menu. 
+
+  If you want to use your floppy tape drive on a PCI-bus based system,
+  please read the file drivers/char/ftape/README.PCI. 
+
+  The ftape kernel driver is also available as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. The module
+  will be called ftape.o. 
+
+  Note that the Ftape-HOWTO is out of date (sorry) and documents the
+  older version 2.08 of this software but still contains useful
+  information. There is a web page with more recent documentation at
+  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ . This page
+  always contains the latest release of the ftape driver and useful
+  information (backup software, ftape related patches and
+  documentation, FAQ). (To browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape.)
+  Note that the file system interface has changed quite a bit compared
+  to previous versions of ftape. Please read Documentation/ftape.txt.
+
+The file system interface for ftape
+CONFIG_ZFTAPE
+  Normally, you want to say Y or M. DON'T say N here or you
+  WON'T BE ABLE TO USE YOUR FLOPPY TAPE DRIVE.
+
+  The ftape module itself no longer contains the routines necessary
+  to interface with the kernel VFS layer (i.e. to actually write data
+  to and read data from the tape drive). Instead the file system
+  interface (i.e. the hardware independent part of the driver) has
+  been moved to a separate module.
+
+  If you say M zftape will be compiled as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). In this case you should read
+  Documentation/modules.txt. The module will be called zftape.o.
+
+  Regardless of whether you say Y or M here, an additional runtime
+  loadable module called `zft-compressor.o' which contains code to
+  support user transparent on-the-fly compression based on Ross
+  William's lzrw3 algorithm will be produced. If you have enabled the
+  kernel module loader (i.e. have said Y to "Kernel module loader
+  support", above) then `zft-compressor.o' will be loaded
+  automatically by zftape when needed.
+
+  Despite its name, zftape does NOT use compression by default. The
+  file Documentation/ftape.txt contains a short description of the
+  most important changes in the file system interface compared to
+  previous versions of ftape. The ftape home page
+  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ contains
+  further information (to browse the WWW, you need to have access to a
+  machine on the Internet that has a program like lynx or netscape).
+
+  IMPORTANT NOTE: zftape can read archives created by previous
+  versions of ftape and provide file mark support (i.e. fast skipping
+  between tape archives) but previous version of ftape will lack file
+  mark support when reading archives produced by zftape.
+
+Default block size for zftape
+CONFIG_ZFT_DFLT_BLK_SZ
+  If unsure leave this at its default value, i.e. 10240. Note that
+  you specify only the default block size here. The block size can be
+  changed at run time using the MTSETBLK tape operation with the
+  MTIOCTOP ioctl (i.e. with "mt -f /dev/qft0 setblk #BLKSZ" from the
+  shell command line).
+
+  The probably most striking difference between zftape and previous
+  versions of ftape is the fact that all data must be written or read
+  in multiples of a fixed block size. The block size defaults to
+  10240 which is what GNU tar uses. The values for the block size
+  should be either 1 or multiples of 1024 up to a maximum value of
+  63488 (i.e. 62 K). If you specify `1' then zftape's builtin
+  compression will be disabled.
+
+  Reasonable values are `10240' (GNU tar's default block size),
+  `5120' (afio's default block size), `32768' (default block size some
+  backup programs assume for SCSI tape drives) or `1' (no restriction
+  on block size, but disables builtin compression).
+
+Number of DMA buffers
+CONFIG_FT_NR_BUFFERS
+  Please leave this at `3' unless you REALLY know what you are doing.
+  It is not necessary to change this value. Values below 3 make the
+  proper use of ftape impossible, values greater than 3 are a waste of
+  memory. You can change the amount of DMA memory used by ftape at
+  runtime with "mt -f /dev/qft0 setdrvbuffer #NUMBUFFERS". Each buffer
+  wastes 32 KB of memory. Please note that this memory cannot be
+  swapped out.
+
+Procfs entry for ftape
+CONFIG_FT_PROC_FS
+  Optional. Saying Y will result in creation of a directory
+  `/proc/ftape' under the proc file system. The files can be viewed
+  with your favorite pager (i.e. use "more /proc/ftape/history" or
+  "less /proc/ftape/history" or simply "cat /proc/ftape/history"). The
+  file will contain some status information about the inserted
+  cartridge, the kernel driver, your tape drive, the floppy disk
+  controller and the error history for the most recent use of the
+  kernel driver. Saying Y will enlarge the size of the ftape driver
+  by approximately 2 KB.
+
+  WARNING: When compiling ftape as a module (i.e. saying M to
+  "Floppy tape drive") it is dangerous to use ftape's proc file system
+  interface. Accessing `/proc/ftape' while the module is unloaded will
+  result in a kernel Oops. This cannot be fixed from inside ftape.
+
+Controlling the amount of debugging output of ftape
+CONFIG_FT_NORMAL_DEBUG
+  This option controls the amount of debugging output the ftape driver
+  is ABLE to produce; it does not increase or diminish the debugging
+  level itself. If unsure, leave this at its default setting,
+  i.e. choose "Normal".
+
+  Ftape can print lots of debugging messages to the system console
+  resp. kernel log files. Reducing the amount of possible debugging
+  output reduces the size of the kernel module by some KB, so it might
+  be a good idea to use "None" for emergency boot floppies.
+
+  If you want to save memory then the following strategy is
+  recommended: leave this option at its default setting "Normal" until
+  you know that the driver works as expected, afterwards reconfigure
+  the kernel, this time specifying "Reduced" or "None" and recompile
+  and install the kernel as usual. Note that choosing "Excessive"
+  debugging output does not increase the amount of debugging output
+  printed to the console but only makes it possible to produce
+  "Excessive" debugging output.
+
+  Please read Documentation/ftape.txt for a short description
+  how to control the amount of debugging output.
+
+The floppy drive controller for ftape
+CONFIG_FT_STD_FDC
+  Only change this setting if you have a special controller. If you
+  didn't plug any add-on card into your computer system but just
+  plugged the floppy tape cable into the already existing floppy drive
+  controller then you don't want to change the default setting,
+  i.e. choose "Standard".
+
+  Choose "MACH-2" if you have a Mountain Mach-2 controller.
+  Choose "FC-10/FC-20" if you have a Colorado FC-10 or FC-20
+  controller.
+  Choose "Alt/82078" if you have another controller that is located at
+  an IO base address different from the standard floppy drive
+  controller's base address of `0x3f0', or uses an IRQ (interrupt)
+  channel different from `6', or a DMA channel different from
+  `2'. This is necessary for any controller card that is based on
+  Intel's 82078 FDC such as Seagate's, Exabyte's and Iomega's "high
+  speed" controllers.
+
+  If you choose something other than "Standard" then please make
+  sure that the settings for the IO base address and the IRQ and DMA
+  channel in the configuration menus below are correct. Use the manual
+  of your tape drive to determine the correct settings!
+
+  If you are already successfully using your tape drive with another
+  operating system then you definitely should use the same settings
+  for the IO base, the IRQ and DMA channel that have proven to work
+  with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the hardware setup. The hardware configuration can be changed at
+  boot time (when ftape is compiled into the kernel, i.e. if you
+  have said Y to "Floppy tape drive") or module load time (i.e. if you
+  have said M to "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which
+  contains a short description of the parameters that can be set at
+  boot or load time. If you want to use your floppy tape drive on a
+  PCI-bus based system, please read the file
+  drivers/char/ftape/README.PCI.
+
+IO base of the floppy disk controller used with Ftape
+CONFIG_FT_FDC_BASE
+  You don't need to specify a value if the following default
+  settings for the base IO address are correct:
+  <<< MACH-2     : 0x1E0 >>>
+  <<< FC-10/FC-20: 0x180 >>>
+  <<< Secondary  : 0x370 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IO base. The hardware configuration can be changed at boot time
+  (when ftape is compiled into the kernel, i.e. if you specified Y to
+  "Floppy tape drive") or module load time (i.e. if you have said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+IRQ channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_IRQ
+  You don't need to specify a value if the following default
+  settings for the interrupt channel are correct:
+  <<< MACH-2     : 6 >>>
+  <<< FC-10/FC-20: 9 >>>
+  <<< Secondary  : 6 >>>
+  Secondary refers to secondary a FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IRQ channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+DMA channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_DMA
+  You don't need to specify a value if the following default
+  settings for the DMA channel are correct:
+  <<< MACH-2     : 2 >>>
+  <<< FC-10/FC-20: 3 >>>
+  <<< Secondary  : 2 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the DMA channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+FDC FIFO Threshold before requesting DMA service
+CONFIG_FT_FDC_THR
+  Set the FIFO threshold of the FDC. If this is higher the DMA
+  controller may serve the FDC after a higher latency time. If this is
+  lower, fewer DMA transfers occur leading to less bus contention.
+  You may try to tune this if ftape annoys you with "reduced data
+  rate because of excessive overrun errors" messages. However, this
+  doesn't seem to have too much effect.
+
+  If unsure, don't touch the initial value, i.e. leave it at "8".
+
+FDC maximum data rate
+CONFIG_FT_FDC_MAX_RATE
+  With some motherboard/FDC combinations ftape will not be able to
+  run your FDC/tape drive combination at the highest available
+  speed. If this is the case you'll encounter "reduced data rate
+  because of excessive overrun errors" messages and lots of retries
+  before ftape finally decides to reduce the data rate.
+
+  In this case it might be desirable to tell ftape beforehand that
+  it need not try to run the tape drive at the highest available
+  speed. If unsure, leave this disabled, i.e. leave it at 2000
+  bits/sec.
+
+Direct Rendering Manager (XFree86 DRI support)
+CONFIG_DRM
+  Kernel-level support for the Direct Rendering Infrastructure (DRI)
+  introduced in XFree86 4.x. These modules provide support for
+  synchronization, security, and DMA transfers. Select the module that
+  provides support for your graphics card.
+
+3dfx Banshee/Voodoo3+
+CONFIG_DRM_TDFX
+  Choose M here if you have a 3dfx Banshee/Voodoo3 graphics card.
+
+3dlabs GMX 2000
+CONFIG_DRM_GAMMA
+  Choose M here if you have a 3dlabs GMX 2000 graphics card.
+
+ATI Rage 128
+CONFIG_DRM_R128
+  Choose M here if you have a ATI Rage 128 graphics card.
+
+Intel I810
+CONFIG_DRM_I810
+  Choose M here if you have an Intel I810 AGP graphics card.
+
+Matrox g200/g400
+CONFIG_DRM_MGA
+  Choose M here if you have a Matrox g200/g400 AGP graphics card.
+
+MTRR control and configuration
+CONFIG_MTRR
+  On Intel P6 family processors (Pentium Pro, Pentium II and later)
+  the Memory Type Range Registers (MTRRs) may be used to control
+  processor access to memory ranges. This is most useful when you have
+  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
+  allows bus write transfers to be combined into a larger transfer
+  before bursting over the PCI/AGP bus. This can increase performance
+  of image write operations 2.5 times or more. This option creates a
+  /proc/mtrr file which may be used to manipulate your
+  MTRRs. Typically the X server should use this. This should have a
+  reasonably generic interface so that similar control registers on
+  other processors can be easily supported.
+
+  The Cyrix 6x86, 6x86MX and M II processors have Address Range
+  Registers (ARRs) which provide a similar functionality to MTRRs. For
+  these, the ARRs are used to emulate the MTRRs.
+
+  The AMD K6-2 (stepping 8 and above) and K6-3 processors have two
+  MTRRs. These are supported.
+
+  The Centaur C6 (WinChip) and WinChip 2&3 processors have 8 MCRs. 
+  These are supported. Note that, due to the design of the WinChip 2&3, 
+  setting the access for normal memory to uncachable or write-combine
+  on these processors will result in instant kernel panic. It is okay 
+  to set this for non-cacheable (video) memory.
+
+  Saying Y here also fixes a problem with buggy SMP BIOSes which only
+  set the MTRRs for the boot CPU and not the secondary CPUs. This can
+  lead to all sorts of problems.
+
+  You can safely say Y even if your machine doesn't have MTRRs, you'll
+  just add about 3k to your kernel.
+
+  See Documentation/mtrr.txt for more information.
+
+Main CPU frequency, only for DEC alpha machine
+CONFIG_FT_ALPHA_CLOCK
+  On some DEC Alpha machines the CPU clock frequency cannot be
+  determined automatically, so you need to specify it here ONLY if
+  running a DEC Alpha, otherwise this setting has no effect.
+
+Zilog serial support
+CONFIG_SUN_ZS
+  If you are asked this question, something is wrong with config scripts.
+  Zilog serial driver is always enabled in sparc architecture.
+
+Double Talk PC internal speech card support
+CONFIG_DTLK
+  This driver is for the DoubleTalk PC, a speech synthesizer
+  manufactured by RC Systems (http://www.rcsys.com/).  It is also
+  called the `internal DoubleTalk'.  If you want to compile this as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called dtlk.o.
+
+Advanced Power Management
+CONFIG_APM
+  APM is a BIOS specification for saving power using several different
+  techniques. This is mostly useful for battery powered laptops with
+  APM compliant BIOSes. If you say Y here, the system time will be
+  reset after a RESUME operation, the /proc/apm device will provide
+  battery status information, and user-space programs will receive
+  notification of APM "events" (e.g. battery status change).
+
+  If you select "Y" here, you can disable actual use of the APM
+  BIOS by passing the "apm=off" option to the kernel at boot time.
+
+  Note that the APM support is almost completely disabled for
+  machines with more than one CPU.
+
+  Supporting software is available; for more information, read the
+  Battery Powered Linux mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver does not spin down disk drives (see the hdparm(8)
+  manpage ("man 8 hdparm") for that), and it doesn't turn off
+  VESA-compliant "green" monitors. 
+
+  This driver does not support the TI 4000M TravelMate and the ACER
+  486/DX4/75 because they don't have compliant BIOSes. Many "green"
+  desktop machines also don't have compliant BIOSes, and this driver
+  may cause those machines to panic during the boot phase.
+
+  If you are running Linux on a laptop, you may also want to read the
+  Linux Laptop home page on the WWW at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ .
+
+  Generally, if you don't have a battery in your machine, there isn't
+  much point in using this driver and you should say N. If you get
+  random kernel OOPSes or reboots that don't seem to be related to
+  anything, try disabling/enabling this option (or disabling/enabling
+  APM in your BIOS). 
+
+  Some other things you should try when experiencing seemingly random,
+  "weird" problems:
+
+   1) make sure that you have enough swap space and that it is
+      enabled. 
+   2) pass the "no-hlt" option to the kernel 
+   3) switch on floating point emulation in the kernel and pass
+      the "no387" option to the kernel
+   4) pass the "floppy=nodma" option to the kernel
+   5) pass the "mem=4M" option to the kernel (thereby disabling 
+      all but the first 4 MB of RAM)
+   6) make sure that the CPU is not over clocked.
+   7) read the sig11 FAQ at http://www.bitwizard.nl/sig11/
+   8) disable the cache from your BIOS settings
+   9) install a fan for the video card or exchange video RAM
+   10) install a better fan for the CPU
+   11) exchange RAM chips 
+   12) exchange the motherboard.
+
+Ignore USER SUSPEND
+CONFIG_APM_IGNORE_USER_SUSPEND
+  This option will ignore USER SUSPEND requests. On machines with a
+  compliant APM BIOS, you want to say N. However, on the NEC Versa M
+  series notebooks, it is necessary to say Y because of a BIOS bug.
+
+Enable APM at boot time
+CONFIG_APM_DO_ENABLE
+  Enable APM features at boot time. From page 36 of the APM BIOS
+  specification: "When disabled, the APM BIOS does not automatically
+  power manage devices, enter the Standby State, enter the Suspend
+  State, or take power saving steps in response to CPU Idle calls."
+  This driver will make CPU Idle calls when Linux is idle (unless this
+  feature is turned off -- see "Do CPU IDLE calls", below). This
+  should always save battery power, but more complicated APM features
+  will be dependent on your BIOS implementation. You may need to turn
+  this option off if your computer hangs at boot time when using APM
+  support, or if it beeps continuously instead of suspending. Turn
+  this off if you have a NEC UltraLite Versa 33/C or a Toshiba
+  T400CDT. This is off by default since most machines do fine without
+  this feature.
+
+Do CPU IDLE calls
+CONFIG_APM_CPU_IDLE
+  Enable calls to APM CPU Idle/CPU Busy inside the kernel's idle loop.
+  On some machines, this can activate improved power savings, such as
+  a slowed CPU clock rate, when the machine is idle. These idle calls
+  are made after the idle loop has run for some length of time (e.g.,
+  333 mS). On some machines, this will cause a hang at boot time or
+  whenever the CPU becomes idle. (On machines with more than one CPU,
+  this option does nothing.)
+
+Enable console blanking using APM
+CONFIG_APM_DISPLAY_BLANK
+  Enable console blanking using the APM. Some laptops can use this to
+  turn off the LCD backlight when the screen blanker of the Linux
+  virtual console blanks the screen. Note that this is only used by
+  the virtual console screen blanker, and won't turn off the backlight
+  when using the X Window system. This also doesn't have anything to
+  do with your VESA-compliant power-saving monitor. Further, this
+  option doesn't work for all laptops -- it might not turn off your
+  backlight at all, or it might print a lot of errors to the console,
+  especially if you are using gpm.
+
+Ignore multiple suspend/resume cycles
+CONFIG_APM_IGNORE_SUSPEND_BOUNCE
+  This option is necessary on the Dell Inspiron 3200 and others, but
+  should be safe for all other laptops. When enabled, a system suspend
+  event that occurs within three seconds of a resume is ignored.
+  Without this the Inspiron will shut itself off a few seconds after
+  you open the lid, requiring you to press the power button to resume
+  it a second time. Say Y.
+
+RTC stores time in GMT
+CONFIG_APM_RTC_IS_GMT
+  Say Y here if your RTC (Real Time Clock a.k.a. hardware clock)
+  stores the time in GMT (Greenwich Mean Time). Say N if your RTC
+  stores localtime.
+
+  It is in fact recommended to store GMT in your RTC, because then you
+  don't have to worry about daylight savings time changes. The only
+  reason not to use GMT in your RTC is if you also run a broken OS
+  that doesn't understand GMT.
+
+Allow interrupts during APM BIOS calls
+CONFIG_APM_ALLOW_INTS
+  Normally we disable external interrupts while we are making calls to
+  the APM BIOS as a measure to lessen the effects of a badly behaving
+  BIOS implementation.  The BIOS should reenable interrupts if it
+  needs to.  Unfortunately, some BIOSes do not - especially those in
+  many of the newer IBM Thinkpads.  If you experience hangs when you
+  suspend, try setting this to Y.  Otherwise, say N.
+
+Use real mode APM BIOS call to power off
+CONFIG_APM_REAL_MODE_POWER_OFF
+  Use real mode APM BIOS calls to switch off the computer. This is
+  a work-around for a number of buggy BIOSes. Switch this option on if
+  your computer crashes instead of powering off properly.
+
+Watchdog Timer Support 
+CONFIG_WATCHDOG
+  If you say Y here (and to one of the following options) and create a
+  character special file /dev/watchdog with major number 10 and minor
+  number 130 using mknod ("man mknod"), you will get a watchdog, i.e.:
+  subsequently opening the file and then failing to write to it for
+  longer than 1 minute will result in rebooting the machine. This
+  could be useful for a networked machine that needs to come back
+  online as fast as possible after a lock-up. There's both a watchdog
+  implementation entirely in software (which can sometimes fail to
+  reboot the machine) and a driver for hardware watchdog boards, which
+  are more robust and can also keep track of the temperature inside
+  your computer. For details, read Documentation/watchdog.txt in the
+  kernel source.
+
+  The watchdog is usually used together with the watchdog daemon which is
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/linux/system/daemons/watchdog. This daemon can
+  check a larger part of the system. For instance it can monitor NFS
+  connections and reboot the machine when the process table is full or the
+  workload exceeds a predefined value.
+
+  If unsure, say N.
+
+Disable watchdog shutdown on close
+CONFIG_WATCHDOG_NOWAYOUT
+  The default watchdog behaviour (which you get if you say N here) is
+  to stop the timer if the process managing it closes the file
+  /dev/watchdog. It's always remotely possible that this process might
+  get killed. If you say Y here, the watchdog cannot be stopped once
+  it has been started.
+
+WDT Watchdog timer
+CONFIG_WDT
+  If you have a WDT500P or WDT501P watchdog board, say Y here,
+  otherwise N. It is not possible to probe for this board, which means
+  that you have to set the IO port and IRQ it uses in the kernel
+  source at the top of drivers/char/wdt.c. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called wdt.o.
+
+WDT501 features
+CONFIG_WDT_501
+  Saying Y here and creating a character special file /dev/temperature
+  with major number 10 and minor number 131 ("man mknod") will give
+  you a thermometer inside your computer: reading from
+  /dev/temperature yields one byte, the temperature in degrees
+  Fahrenheit. This works only if you have a WDT501P watchdog board
+  installed.
+
+Fan Tachometer
+CONFIG_WDT_501_FAN
+  Enable the Fan Tachometer on the WDT501. Only do this if you have a
+  fan tachometer actually set up.
+
+Software Watchdog
+CONFIG_SOFT_WATCHDOG
+  A software monitoring watchdog. This will fail to reboot your system
+  from some situations that the hardware watchdog will recover
+  from. Equally it's a lot cheaper to install. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called softdog.o.
+
+Berkshire Products PC Watchdog
+CONFIG_PCWATCHDOG
+  This is the driver for the Berkshire Products PC Watchdog card.
+  This card simply watches your kernel to make sure it doesn't freeze,
+  and if it does, it reboots your computer after a certain amount of
+  time. This driver is like the WDT501 driver but for different
+  hardware. Please read Documentation/pcwd-watchdog.txt. The PC
+  watchdog cards can be ordered from http://www.berkprod.com. Some
+  example rc.local files are available from ftp://ftp.bitgate.com. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pcwd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  Most people will say N.
+
+Acquire SBC Watchdog Timer
+CONFIG_ACQUIRE_WDT
+  This is the driver for the hardware watchdog on the PSC-6x86 Single
+  Board Computer produced by Acquire Inc (and others). This watchdog
+  simply watches your kernel to make sure it doesn't freeze, and if
+  it does, it reboots your computer after a certain amount of time.
+
+  This driver is like the WDT501 driver but for different hardware.
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pscwdt.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. Most people
+  will say N.
+
+SBC-60XX Watchdog Timer
+CONFIG_60XX_WDT
+ This driver can be used with the watchdog timer found on some
+ single board computers, namely the 6010 PII based computer.
+ It may well work with other cards.  It reads port 0x443 to enable
+ and re-set the watchdog timer, and reads port 0x45 to disable
+ the watchdog.  If you have a card that behave in similar ways,
+ you can probably make this driver work with your card as well.
+
+ You can compile this driver directly into the kernel, or use
+ it as a module.  The module will be called sbc60xxwdt.o.
+
+CONFIG_MICROCODE
+  /dev/cpu/microcode - Intel P6 CPU microcode support
+
+  If you say Y here you will be able to update the microcode on
+  Intel processors in the P6 family, e.g. Pentium Pro, Pentium II,
+  Pentium III, Xeon etc. You will obviously need the actual microcode
+  binary data itself which is not shipped with the Linux kernel.
+ 
+  For latest news and information on obtaining all the required
+  ingredients for this driver, check:
+  http://www.urbanmyth.org/microcode/
+ 
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called microcode.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+/dev/cpu/*/msr - Model-specific register support
+CONFIG_X86_MSR
+  This device gives privileged processes access to the x86
+  Model-Specific Registers (MSRs).  It is a character device with
+  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
+  MSR accesses are directed to a specific CPU on multi-processor
+  systems.
+
+/dev/cpu/*/cpuid - CPU information support
+CONFIG_X86_CPUID
+  This device gives processes access to the x86 CPUID instruction to
+  be executed on a specific processor.  It is a character device
+  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
+  /dev/cpu/31/cpuid.
+
+Enhanced Real Time Clock Support
+CONFIG_RTC
+  If you say Y here and create a character special file /dev/rtc with
+  major number 10 and minor number 135 using mknod ("man mknod"), you
+  will get access to the real time clock built into your computer.
+  Every PC has such a clock built in. It can be used to generate
+  signals from as low as 1Hz up to 8192Hz, and can also be used as a
+  24 hour alarm. It reports status information via the file /proc/rtc
+  and its behaviour is set by various ioctls on /dev/rtc.
+
+  If you run Linux on a multiprocessor machine and said Y to
+  "Symmetric Multi Processing" above, you should say Y here to read
+  and set the RTC clock in an SMP compatible fashion.
+
+  If you think you have a use for such a device (such as periodic data
+  sampling), then say Y here, and read Documentation/rtc.txt for
+  details.
+
+AGP/GART support
+CONFIG_AGP
+  This provides a kernel interface (/dev/agpgart) for programming AGP
+  transfers on motherboards that support them. Primarily, this is used
+  for hardware-accelerated 3d graphics, though any other AGP device
+  could take advantage of it.
+
+  If you have a 3d-capable AGP video card say 'M' or 'Y' here.
+  Otherwise, say 'N'.
+
+  You will also have to indicate support for your specific chipset.
+  Consult the output of lspci, your motherboard manual, or the inside
+  of your computer if unsure what to choose. Multiple selections are ok.
+
+Intel 440LX/BX/GX support
+CONFIG_AGP_INTEL
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Intel 440LX/BX/GX chipsets.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Intel I810/I810 DC100/I810e support
+CONFIG_AGP_I810
+  This option give you AGP support for the Xserver for the intel
+  810 chipset boards. This is required to do any useful video
+  modes.
+
+VIA VP3/MVP3/Apollo Pro support
+CONFIG_AGP_VIA
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on VIA MPV3/Apollo Pro chipsets.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+AMD Irongate support
+CONFIG_AGP_AMD
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Intel AMD Irongate chipset.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Generic SiS support
+CONFIG_AGP_SIS
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on Silicon Integrated Systems [SiS]
+  chipsets.
+
+  Note than 5591/5592 AGP chipsets are NOT supported.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+ALI M1541 support
+CONFIG_AGP_ALI
+  This option give you AGP support for the GLX component of the
+  "soon to be released" XFree86-4 on ALI M1541 chipset.
+
+  For the moment, most people should say no, unless you want to
+  test the GLX component which can be downloaded from
+       http://glx.on.openprojects.net/
+
+Tadpole ANA H8 Support
+CONFIG_H8
+  The Hitachi H8/337 is a microcontroller used to deal with the power
+  and thermal environment. If you say Y here, you will be able to
+  communicate with it via a character special device. 
+
+  If unsure, say N.
+
+/dev/nvram support
+CONFIG_NVRAM
+  If you say Y here and create a character special file /dev/nvram
+  with major number 10 and minor number 144 using mknod ("man mknod"),
+  you get read and write access to the 50 bytes of non-volatile memory
+  in the real time clock (RTC), which is contained in every PC and
+  most Ataris. 
+
+  This memory is conventionally called "CMOS RAM" on PCs and "NVRAM"
+  on Ataris. /dev/nvram may be used to view settings there, or to
+  change them (with some utility). It could also be used to frequently
+  save a few bits of very important data that may not be lost over
+  power-off and for which writing to disk is too insecure. Note
+  however that most NVRAM space in a PC belongs to the BIOS and you
+  should NEVER idly tamper with it. See Ralf Brown's interrupt list
+  for a guide to the use of CMOS bytes by your BIOS.
+
+  On Atari machines, /dev/nvram is always configured and does not need
+  to be selected.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called nvram.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atomwide Serial Support
+CONFIG_ATOMWIDE_SERIAL
+  If you have an Atomwide Serial card for an Acorn system, say Y to
+  this option.  The driver can handle 1, 2, or 3 port cards.
+  If unsure, say N
+
+The Serial Port Dual Serial Port
+CONFIG_DUALSP_SERIAL
+  If you have the Serial Port's dual serial card for an Acorn system,
+  say Y to this option.  If unsure, say N
+
+Joystick support
+CONFIG_JOYSTICK
+  If you have a joystick, 6dof controller, gamepad, steering wheel,
+  weapon control system or something like that you can say Y here to
+  enable generic support for these controllers. You will also need to
+  say Y or M to at least one of the hardware specific drivers. This
+  will make the controllers available as /dev/jsX devices. Please read
+  the file Documentation/joystick.txt which contains more information
+  and the location of the joystick package that you'll need.
+
+Classic PC analog
+CONFIG_JOY_ANALOG
+  Say Y here if you have a controller that connects to the PC
+  gameport. This supports many different types, including joysticks
+  with throttle control, with rudders, or with extensions like
+  additional hats and buttons compatible with CH Flightstick Pro,
+  ThrustMaster FCS or 6 and 8 button gamepads. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+FPGaming and MadCatz A3D
+CONFIG_JOY_ASSASSIN
+  Say Y here if you have an FPGaming or MadCatz controller using the
+  A3D protocol over the PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Gravis GrIP
+CONFIG_JOY_GRAVIS
+  Say Y here if you have a Gravis controller using the GrIP protocol
+  over the PC gameport. For more information on how to use the driver
+  please read Documentation/joystick.txt
+
+Logitech ADI
+CONFIG_JOY_LOGITECH
+  Say Y here if you have a Logitech controller using the ADI
+  protocol over the PC gameport. For more information on how to use
+  the driver please read Documentation/joystick.txt
+
+Microsoft SideWinder
+CONFIG_JOY_SIDEWINDER
+  Say Y here if you have a Microsoft controller using the Digital
+  Overdrive protocol over PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+ThrustMaster DirectConnect
+CONFIG_JOY_THRUSTMASTER
+  Say Y here if you have a ThrustMaster controller using the
+  DirectConnect (BSP) protocol over the PC gameport. For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Creative Labs Blaster
+CONFIG_JOY_CREATIVE
+  Say Y here if you have a Creative Labs controller using the
+  Blaster protocol over the PC gameport. For more information on how
+  to use the driver please read Documentation/joystick.txt
+
+PDPI Lightning 4 card
+CONFIG_JOY_LIGHTNING
+  Say Y here if you have a PDPI Lightning 4 gamecard and an analog
+  joystick or gamepad connected to it. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Trident 4DWave and Aureal Vortex gameport
+CONFIG_JOY_PCI
+  Say Y here if you have a Trident 4DWave DX/NX or Aureal Vortex 1/2
+  card and want to use its gameport in its enhanced digital mode
+  with and ordinary analog joystick. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+Magellan and Space Mouse
+CONFIG_JOY_MAGELLAN
+  Say Y here if you have a Magellan or Space Mouse 6DOF controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+SpaceTec SpaceOrb 360 and SpaceBall Avenger
+CONFIG_JOY_SPACEORB
+  Say Y here if you have a SpaceOrb 360 or SpaceBall Avenger 6DOF
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+SpaceTec SpaceBall 4000 FLX
+CONFIG_JOY_SPACEBALL
+  Say Y here if you have a SpaceTec SpaceBall 4000 FLX
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+Logitech WingMan Warrior
+CONFIG_JOY_WARRIOR
+  Say Y here if you have a Logitech WingMan Warrior controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+NES, SNES, N64, PSX, Multi
+CONFIG_JOY_CONSOLE
+  Say Y here if you have a Nintendo Entertainment System gamepad,
+  Super Nintendo Entertainment System gamepad, Nintendo 64 gamepad,
+  Sony PlayStation gamepad or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port.
+  For more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+Sega, Multi
+CONFIG_JOY_DB9
+  Say Y here if you have a Sega Master System gamepad, Sega Genesis
+  gamepad, Sega Saturn gamepad, or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port. For
+  more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+TurboGraFX interface
+CONFIG_JOY_TURBOGRAFX
+  Say Y here if you have the TurboGraFX interface by Steffen Schwenke,
+  and want to use it with Multiststem -- Atari, Amiga, Commodore,
+  Amstrad CPC joystick. For more information on how to use the driver
+  please read Documentation/joystick.txt and
+  Documentation/joystick-parport.txt
+
+Amiga joysticks
+CONFIG_JOY_AMIGA
+  Say Y here if you have an Amiga with a digital joystick connected
+  to it. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+Atomwide Serial Support
+CONFIG_ATOMWIDE_SERIAL
+  If you have an Atomwide Serial card for an Acorn system, say Y to
+  this option. The driver can handle 1, 2, or 3 port cards.
+  If unsure, say N
+
+The Serial Port Dual Serial Port
+CONFIG_DUALSP_SERIAL
+  If you have the Serial Port's dual serial card for an Acorn system,
+  say Y to this option. If unsure, say N
+
+NetWinder Button
+CONFIG_NWBUTTON
+  If you enable this driver and create a character device node
+  /dev/nwbutton with major and minor numbers 10 and 158 ("man mknod"),
+  then every time the orange button is pressed a number of times, the
+  number of times the button was pressed will be written to that device.
+  This is most useful for applications, as yet unwritten, which perform
+  actions based on how many times the button is pressed in a row.
+  Do not hold the button down for too long, as the driver does not alter
+  the behaviour of the hardware reset circuitry attached to the button;
+  it will still execute a hard reset if the button is held down for
+  longer than approximately five seconds.
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called nwbutton.o.
+  Most people will answer Y to this question and "Reboot Using Button"
+  below to be able to initiate a system shutdown from the button.
+
+Reboot Using Button
+CONFIG_NWBUTTON_REBOOT
+  If you enable this option, then you will be able to initiate a system
+  shutdown and reboot by pressing the orange button a number of times.
+  The number of presses to initiate the shutdown is two by default, but
+  this can be altered by modifying the value of NUM_PRESSES_REBOOT in
+  nwbutton.h and recompiling the driver or, if you compile the driver as
+  a module, you can specify the number of presses at load time with
+  "insmod button reboot_count=<something>".
+
+Sound card support
+CONFIG_SOUND
+  If you have a sound card in your computer, i.e. if it can say more
+  than an occasional beep, say Y. Be sure to have all the information
+  about your sound card and its configuration down (I/O port,
+  interrupt and DMA channel), because you will be asked for it. 
+
+  You want to read the Sound-HOWTO, available via FTP (user:
+  anonymous) from ftp://metalab.unc.edu/pub/Linux/docs/HOWTO. General
+  information about the modular sound system is contained in the files
+  Documentation/sound/Introduction. The file
+  Documentation/sound/README.OSS contains some slightly outdated but
+  still useful information as well.
+
+  If you have a PnP sound card and you want to configure it at boot
+  time using the ISA PnP tools (read
+  http://www.roestock.demon.co.uk/isapnptools/ (to browse the WWW, you
+  need to have access to a machine on the Internet that has a program
+  like lynx or netscape)), then you need to compile the sound card
+  support as a module ( = code which can be inserted in and removed
+  from the running kernel whenever you want) and load that module
+  after the PnP configuration is finished. To do this, say M here and
+  read Documentation/modules.txt as well as
+  Documentation/sound/README.modules; the module will be called
+  soundcore.o.
+
+  I'm told that even without a sound card, you can make your computer
+  say more than an occasional beep, by programming the PC speaker.
+  Kernel patches and supporting utilities to do that are in the pcsp
+  package, available at ftp://ftp.infradead.org/pub/pcsp/.
+
+OSS sound modules
+CONFIG_SOUND_OSS
+  OSS is the Open Sound System suite of sound card drivers. They make
+  sound programming easier since they provide a common API. Say Y or M
+  here (the module will be called sound.o) if you haven't found a
+  driver for your sound card above, then pick your driver from the
+  list below.
+
+Persistent DMA buffers
+CONFIG_SOUND_DMAP
+  Linux can often have problems allocating DMA buffers for ISA sound
+  cards on machines with more than 16MB of RAM. This is because ISA
+  DMA buffers must exist below the 16MB boundary and it is quite
+  possible that a large enough free block in this region cannot be
+  found after the machine has been running for a while. If you say Y
+  here the DMA buffers (64Kb) will be allocated at boot time and kept
+  until the shutdown. This option is only useful if you said Y to
+  "OSS sound modules", above. If you said M to "OSS sound modules"
+  then you can get the persistent DMA buffer functionality by passing
+  the command-line argument "dmabuf=1" to the sound.o module.
+
+  Say Y unless you have 16MB or less RAM or a PCI sound card.
+
+Crystal SoundFusion (CS461x)
+CONFIG_SOUND_FUSION
+  This module drives the Crystal SoundFusion devices (CS46xx series) when
+  wired as native sound drivers with AC97 codecs. If this driver does not
+  work try the CS4232 driver.
+
+Support for Aztech Sound Galaxy (non-PnP) cards
+CONFIG_SOUND_SGALAXY
+  This module initializes the older non Plug and Play sound galaxy
+  cards from Aztech. It supports the Waverider Pro 32 - 3D and the
+  Galaxy Washington 16.
+
+Support for AD1816(A) based cards (EXPERIMENTAL)
+CONFIG_SOUND_AD1816
+  Say M here if you have a sound card based on the Analog Devices 
+  AD1816(A) chip.
+
+  NOTE: This driver is still EXPERIMENTAL. 
+        See Documentation/sound/AD1816 for further information.
+
+Yamaha OPL3-SA1 audio controller
+CONFIG_SOUND_OPL3SA1
+  Say Y or M if you have a Yamaha OPL3-SA1 sound chip, which is
+  usually built into motherboards. Read Documentation/sound/OPL3-SA
+  for details.
+
+ProAudioSpectrum 16 support
+CONFIG_SOUND_PAS
+  Answer Y only if you have a Pro Audio Spectrum 16, ProAudio Studio
+  16 or Logitech SoundMan 16 sound card. Don't answer Y if you have
+  some other card made by Media Vision or Logitech since they are not
+  PAS16 compatible.
+
+100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support
+CONFIG_SOUND_SB
+  Answer Y if you have an original Sound Blaster card made by Creative
+  Labs or a 100% hardware compatible clone (like the Thunderboard or
+  SM Games). For an unknown card you may answer Y if the card claims
+  to be Sound Blaster-compatible.
+
+  Please read the file Documentation/sound/Soundblaster.
+
+  You should also say Y here for cards based on the Avance Logic
+  ALS-007 chip (read Documentation/sound/ALS007) and for cards based
+  on ESS chips (read Documentation/sound/ESS1868 and
+  Documentation/sound/ESS). If you have an SB AWE 32 or SB AWE 64, say
+  Y here and also to "Additional lowlevel drivers" and to "SB32/AWE
+  support" below and read Documentation/sound/INSTALL.awe. If you have
+  an IBM Mwave card, say Y here and read Documentation/sound/mwave.
+  
+  You can say M here to compile this driver as a module; the module is
+  called sb.o.
+
+#Loopback MIDI device support
+#CONFIG_SOUND_VMIDI
+###
+### somebody please fill this in.
+###
+#
+Gravis Ultrasound support
+CONFIG_SOUND_GUS
+  Say Y here for any type of Gravis Ultrasound card, including
+  the GUS or GUS MAX. See also Documentation/sound/ultrasound for
+  more information on configuring this card with modules.
+
+MPU-401 support (NOT for SB16)
+CONFIG_SOUND_MPU401
+  Be careful with this question. The MPU401 interface is supported by
+  all sound cards. However, some natively supported cards have their
+  own driver for MPU401. Enabling this MPU401 option with these cards
+  will cause a conflict. Also, enabling MPU401 on a system that
+  doesn't really have a MPU401 could cause some trouble. If your card
+  was in the list of supported cards, look at the card specific
+  instructions in the drivers/sound/Readme.cards file. It's safe to
+  answer Y if you have a true MPU401 MIDI interface card.
+
+6850 UART support
+CONFIG_SOUND_UART6850
+  This option enables support for MIDI interfaces based on the 6850
+  UART chip. This interface is rarely found on sound cards. It's safe
+  to answer N to this question.
+
+VIDC Sound
+CONFIG_VIDC_SOUND
+  Say Y here for ARM systems with the VIDC video controller and 16-bit
+  Linear sound DACs. If unsure, say N.
+
+PSS (AD1848, ADSP-2115, ESC614) support
+CONFIG_SOUND_PSS
+  Answer Y or M if you have an Orchid SW32, Cardinal DSP16, Beethoven
+  ADSP-16 or some other card based on the PSS chipset (AD1848 codec +
+  ADSP-2115 DSP chip + Echo ESC614 ASIC CHIP). For more information on
+  how to compile it into the kernel or as a module see the file
+  Documentation/sound/PSS.
+
+Enable PSS mixer (Beethoven ADSP-16 and other compatible)
+CONFIG_PSS_MIXER
+  Answer Y for Beethoven ADSP-16. You may try to say Y also for other
+  cards if they have master volume, bass, treble, and you can't
+  control it under Linux. If you answer N for Beethoven ADSP-16, you
+  can't control master volume, bass, treble and synth volume.
+
+  If you said M to "PSS support" above, you may enable or disable this
+  PSS mixer with the module parameter pss_mixer. For more information
+  see the file Documentation/sound/PSS.
+
+Have DSPxxx.LD firmware file
+CONFIG_PSS_HAVE_BOOT
+  If you have the DSPxxx.LD file or SYNTH.LD file for you card, say Y
+  to include this file. Without this file the synth device (OPL) may
+  not work.
+
+Full pathname of DSPxxx.LD firmware file
+CONFIG_PSS_BOOT_FILE
+  Enter the full pathname of your DSPxxx.LD file or SYNTH.LD file,
+  starting from /.
+
+16 bit sampling option of GUS (_NOT_ GUS MAX)
+CONFIG_SOUND_GUS16
+  Answer Y if you have installed the 16 bit sampling daughtercard on
+  your GUS. Answer N if you have a GUS MAX, since saying Y here
+  disables GUS MAX support.
+
+GUS MAX support
+CONFIG_SOUND_GUSMAX
+  Answer Y only if you have a Gravis Ultrasound MAX.
+
+Microsoft Sound System support
+CONFIG_SOUND_MSS
+  Again think carefully before answering Y to this question. It's safe
+  to answer Y if you have the original Windows Sound System card made
+  by Microsoft or Aztech SG 16 Pro (or NX16 Pro). Also you may say Y
+  in case your card is NOT among these:
+
+     ATI Stereo F/X, AdLib, Audio Excell DSP16, Cardinal DSP16,
+     Ensoniq SoundScape (and compatibles made by Reveal and Spea),
+     Gravis Ultrasound, Gravis Ultrasound ACE, Gravis Ultrasound Max,
+     Gravis Ultrasound with 16 bit option, Logitech Sound Man 16,
+     Logitech SoundMan Games, Logitech SoundMan Wave, MAD16 Pro (OPTi
+     82C929), Media Vision Jazz16, MediaTriX AudioTriX Pro, Microsoft
+     Windows Sound System (MSS/WSS), Mozart (OAK OTI-601), Orchid
+     SW32, Personal Sound System (PSS), Pro Audio Spectrum 16, Pro
+     Audio Studio 16, Pro Sonic 16, Roland MPU-401 MIDI interface,
+     Sound Blaster 1.0, Sound Blaster 16, Sound Blaster 16ASP, Sound
+     Blaster 2.0, Sound Blaster AWE32, Sound Blaster Pro, TI TM4000M
+     notebook, ThunderBoard, Turtle Beach Tropez, Yamaha FM
+     synthesizers (OPL2, OPL3 and OPL4), 6850 UART MIDI Interface.
+
+  For cards having native support in VoxWare, consult the card
+  specific instructions in drivers/sound/Readme.cards. Some drivers
+  have their own MSS support and saying Y to this option will cause a
+  conflict.
+
+SoundPro chip support
+CONFIG_SOUND_SPRO
+  If you have a (usually Taiwanese) motherboard with the SoundPro chip
+  on board, say Y here. Otherwise say N.
+
+Ensoniq Soundscape support
+CONFIG_SOUND_SSCAPE
+  Answer Y if you have a sound card based on the Ensoniq SoundScape
+  chipset. Such cards are being manufactured at least by Ensoniq, Spea
+  and Reveal (Reveal makes also other cards).
+
+MediaTriX AudioTriX Pro support
+CONFIG_SOUND_TRIX
+  Answer Y if you have the AudioTriX Pro sound card manufactured
+  by MediaTrix.
+
+Have TRXPRO.HEX firmware file
+CONFIG_TRIX_HAVE_BOOT
+  The MediaTrix AudioTrix Pro has an on-board microcontroller which
+  needs to be initialized by downloading the code from the file
+  TRXPRO.HEX in the DOS driver directory. If you don't have the
+  TRXPRO.HEX file handy you may skip this step. However, the SB and
+  MPU-401 modes of AudioTrix Pro will not work without this file!
+
+Full pathname of TRXPRO.HEX firmware file
+CONFIG_TRIX_BOOT_FILE
+  Enter the full pathname of your TRXPRO.HEX file, starting from /.
+
+Support for OPTi MAD16 and/or Mozart based cards
+CONFIG_SOUND_MAD16
+  Answer Y if your card has a Mozart (OAK OTI-601) or MAD16 (OPTi
+  82C928 or 82C929 or 82C931) audio interface chip. For the 82C931,
+  please read drivers/sound/README.C931. These chips are currently
+  quite common so it's possible that many no-name cards have one of
+  them. In addition the MAD16 chip is used in some cards made by known
+  manufacturers such as Turtle Beach (Tropez), Reveal (some models)
+  and Diamond (latest ones). Note however that the Tropez sound cards
+  have their own driver; if you have one of those, say N here and Y or
+  M to "Full support for Turtle Beach WaveFront", below. 
+
+  See also Documentation/sound/Opti and Documentation/sound/MAD16 for
+  more information on setting these cards up as modules.
+
+VIA 82Cxxx audio support
+CONFIG_SOUND_VIA82CXXX
+  Answer Y if you have a VIA82C686 chip, typically found built
+  onto a motherboard.
+
+Full support for Turtle Beach WaveFront synth/sound cards
+CONFIG_SOUND_WAVEFRONT
+  Answer Y or M if you have a Tropez Plus, Tropez or Maui sound card
+  and read the files Documentation/sound/Wavefront and
+  Documentation/sound/Tropez+.
+  
+Support MIDI in older MAD16 based cards (requires SB)
+CONFIG_MAD16_OLDCARD
+  Answer Y (or M) if you have an older card based on the C928 or
+  Mozart chipset and you want to have MIDI support. If you enable this
+  option you also need to enable support for Sound Blaster.
+
+Support for Crystal CS4232 based (PnP) cards
+CONFIG_SOUND_CS4232
+  Say Y here if you have a card based on the Crystal CS4232 chip set,
+  which uses its own Plug and Play protocol. 
+
+  See Documentation/sound/CS4232 for more information on configuring
+  this card.
+
+Support for Yamaha OPL3-SA2, SA3, and SAx based PnP cards
+CONFIG_SOUND_OPL3SA2
+  Say Y or M if you have a card based on one of these Yamaha
+  sound chipsets. Read Documentation/sound/OPL3-SA2 for more
+  information on configuring these cards.
+
+Support for Turtle Beach Wave Front (Maui, Tropez) synthesizers
+CONFIG_SOUND_MAUI
+  Say Y here if you have a Turtle Beach Wave Front, Maui, or Tropez
+  sound card.
+
+Have OSWF.MOT firmware file
+CONFIG_MAUI_HAVE_BOOT
+  Turtle Beach Maui and Tropez sound cards have a microcontroller
+  which needs to be initialized prior to use. OSWF.MOT is a file
+  distributed with the card's DOS/Windows drivers. Answer Y if you
+  have this file.
+
+Full pathname of OSWF.MOT firmware file
+CONFIG_MAUI_BOOT_FILE
+  Enter the full pathname of your OSWF.MOT file, starting from /.
+
+Support for Turtle Beach MultiSound Classic, Tahiti, Monterey
+CONFIG_SOUND_MSNDCLAS
+  Say M here if you have a Turtle Beach MultiSound Classic, Tahiti or
+  Monterey (not for the Pinnacle or Fiji). 
+
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of MSNDINIT.BIN firmware file
+CONFIG_MSNDCLAS_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of MSNDPERM.BIN firmware file
+CONFIG_MSNDCLAS_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Support for Turtle Beach MultiSound Pinnacle, Fiji
+CONFIG_SOUND_MSNDPIN
+  Say M here if you have a Turtle Beach MultiSound Pinnacle or Fiji.
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of PNDSPINI.BIN firmware file
+CONFIG_MSNDPIN_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of PNDSPERM.BIN firmware file
+CONFIG_MSNDPIN_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+MSND Pinnacle have S/PDIF I/O
+CONFIG_MSNDPIN_DIGITAL
+  If you have the S/PDIF daughter board for the Pinnacle or Fiji,
+  answer Y here; otherwise, say N. If you have this, you will be able
+  to play and record from the S/PDIF port (digital signal). See
+  Documentation/sound/MultiSound for information on how to make use of
+  this capability.
+
+MSND Pinnacle non-PnP Mode
+CONFIG_MSNDPIN_NONPNP
+  The Pinnacle and Fiji card resources can be configured either with
+  PnP, or through a configuration port. Say Y here if your card is NOT
+  in PnP mode. For the Pinnacle, configuration in non-PnP mode allows
+  use of the IDE and joystick peripherals on the card as well; these
+  do not show up when the card is in PnP mode. Specifying zero for any
+  resource of a device will disable the device. If you are running the
+  card in PnP mode, you must say N here and use isapnptools to
+  configure the card's resources.
+
+MSND Pinnacle config port
+CONFIG_MSNDPIN_CFG
+  This is the port which the Pinnacle and Fiji uses to configure the
+  card's resources when not in PnP mode. If your card is in PnP mode,
+  then be sure to say N to the previous option, "MSND Pinnacle Non-PnP
+  Mode".
+
+MSND buffer size (kB)
+CONFIG_MSND_FIFOSIZE
+  Configures the size of each audio buffer, in kilobytes, for
+  recording and playing in the MultiSound drivers (both the Classic
+  and Pinnacle). Larger values reduce the chance of data overruns at
+  the expense of overall latency. If unsure, use the default.
+
+/dev/dsp and /dev/audio support
+CONFIG_SOUND_AUDIO
+  If you say Y here, you will get the /dev/dsp and /dev/audio devices;
+  these are the analog-digital and digital-analog converter devices
+  and are very useful, so say Y.
+
+MIDI interface support
+CONFIG_SOUND_MIDI
+  Answering N disables /dev/midixx devices and access to any MIDI
+  ports using /dev/sequencer and /dev/music. This option also affects
+  any MPU401 and/or General MIDI compatible devices. Answer Y.
+
+FM synthesizer (YM3812/OPL-3) support
+CONFIG_SOUND_YM3812
+  Answer Y if your card has a FM chip made by Yamaha (OPL2/OPL3/OPL4).
+  Answering Y is usually a safe and recommended choice, however some
+  cards may have software (TSR) FM emulation. Enabling FM support with
+  these cards may cause trouble (I don't currently know of any such
+  cards, however).
+  Please read the file Documentation/sound/OPL3 if your card has an
+  OPL3 chip.
+
+  If unsure, say Y.
+
+Sun Audio support
+CONFIG_SUN_AUDIO
+  This is support for the sound cards on Sun workstations. The code
+  does not exist yet, so you might as well say N here.
+
+Additional low level drivers
+CONFIG_LOWLEVEL_SOUND
+  If you need additional low level sound drivers which have not yet
+  appeared, say Y. The answer to this question does not directly
+  affect the kernel; saying Y will simply cause this configure script
+  to present you with more options. If unsure, say Y.
+
+ACI mixer (miroPCM12/PCM20)
+CONFIG_ACI_MIXER
+  ACI (Audio Command Interface) is a protocol used to communicate with
+  the microcontroller on some sound cards produced by miro, e.g. the
+  miroSOUND PCM12 and PCM20. The main function of the ACI is to
+  control the mixer and to get a product identification. 
+
+  This Voxware ACI driver currently only supports the ACI functions on
+  the miroSOUND PCM12 and PCM20 cards. On the PCM20, ACI also controls
+  the radio tuner. This is supported in the video4linux
+  radio-miropcm20 driver.
+
+Micronas Intermetall MSP 3400 support
+CONFIG_VIDEO_MSP3400
+  This option enables the driver for the Micronas Intermetall MSP 3400 
+  series sound decoder/mixer chips often found on BT848-style TV cards.
+
+  Say Y here if your sound card has a MSP 3400 series sound decoder or 
+  mixer chip.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called msp3400.o.
+
+SB32/AWE support
+CONFIG_AWE32_SYNTH
+  Say Y here if you have a Sound Blaster SB32, AWE32-PnP, SB AWE64 or
+  similar sound card. See Documentation/sound/README.awe,
+  Documentation/sound/AWE32 and the Soundblaster-AWE mini-HOWTO,
+  available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/mini for more info.
+
+Gallant's Audio Excel DSP 16 support (SC-6000 and SC-6600)
+CONFIG_AEDSP16
+  Answer Y if you have a Gallant's Audio Excel DSP 16 card. This
+  driver supports Audio Excel DSP 16 but not the III nor PnP versions
+  of this card.
+
+  The Gallant's Audio Excel DSP 16 card can emulate either an SBPro or
+  a Microsoft Sound System card, so you should have said Y to either
+  "100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support"
+  or "Microsoft Sound System support", above, and you need to answer
+  the "MSS emulation" and "SBPro emulation" questions below
+  accordingly. You should say Y to one and only one of these two
+  questions.
+
+  Read the drivers/sound/lowlevel/README.aedsp16 file and the head of
+  drivers/sound/lowlevel/aedsp16.c as well as
+  Documentation/sound/AudioExcelDSP16 to get more information about
+  this driver and its configuration.
+
+I/O base for Audio Excel DSP 16
+CONFIG_AEDSP16_BASE
+  This is the base I/O address of the Audio Excel DSP 16 card. It must
+  be 220 or 240. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'io=0xNNN'.
+
+Audio Excel DSP 16 (SBPro emulation)
+CONFIG_AEDSP16_SBPRO
+  Answer Y if you want your audio card to emulate Sound Blaster Pro.
+  You should then say Y to "100% Sound Blaster compatibles
+  (SB16/32/64, ESS, Jazz16) support" and N to "Audio Excel DSP 16 (MSS
+  emulation)".
+
+Audio Excel DSP 16 IRQ
+CONFIG_AEDSP16_SB_IRQ
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 5, 7, 9,
+  10 or 11. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'irq=NN'.
+
+Audio Excel DSP 16 DMA
+CONFIG_AEDSP16_SB_DMA
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 0, 1 or 3.
+  If you compiled aedsp16.o as a module you can specify this parameter
+  as 'dma=NN'.
+
+Audio Excel DSP 16 (MSS emulation)
+CONFIG_AEDSP16_MSS
+  Answer Y if you want your audio card to emulate Microsoft Sound
+  System. You should then say Y to "Microsoft Sound System support"
+  and say N to "Audio Excel DSP 16 (SBPro emulation)".
+
+Audio Excel DSP 16 IRQ
+CONFIG_AEDSP16_MSS_IRQ
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 5, 7, 9,
+  10 or 11. If you compiled aedsp16.o as a module you can specify
+  this parameter as 'irq=NN'.
+
+Audio Excel DSP 16 DMA
+CONFIG_AEDSP16_MSS_DMA
+  This is the IRQ of the Audio Excel DSP 16 card. It must be 0, 1 
+  or 3. If you compiled aedsp16.o as a module you can specify this
+  parameter as 'dma=NN'.
+
+SC-6600 based audio cards (new Audio Excel DSP 16)
+CONFIG_SC6600
+  The SC6600 is the new version of DSP mounted on the Audio Excel DSP
+  16 cards. Find in the manual the FCC ID of your audio card and
+  answer Y if you have an SC6600 DSP.
+
+SC-6600 Joystick Interface
+CONFIG_SC6600_JOY
+  Say Y here in order to use the joystick interface of the Audio Excel
+  DSP 16 card.
+
+SC-6600 CDROM Interface
+CONFIG_SC6600_CDROM
+  This is used to activate the the CDROM interface of the Audio Excel
+  DSP 16 card. Enter: 0 for Sony, 1 for Panasonic, 2 for IDE, 4 for no
+  CDROM present.
+
+Audio Excel DSP 16 (MPU401 emulation)
+CONFIG_AEDSP16_MPU401
+  Answer Y if you want your audio card to emulate the MPU-401 midi
+  interface. You should then also say Y to "MPU-401 support".
+  
+  Note that the I/O base for MPU-401 support of aedsp16 is the same
+  you have selected for "MPU-401 support". If you are using this
+  driver as a module you have to specify the MPU I/O base address with
+  the parameter 'mpu_base=0xNNN'.
+
+MPU401 IRQ for Audio Excel DSP 16
+CONFIG_AEDSP16_MPU_IRQ
+  This is the IRQ of the MPU-401 emulation of your Audio Excel DSP 16
+  card. It must be 5, 7, 9, 10 or 0 (to disable MPU-401 interface). If
+  you compiled aedsp16.o as a module you can specify this parameter as
+  'mpu_irq=NN'.
+
+SGI Visual Workstation on-board audio
+CONFIG_SOUND_VWSND
+  Say Y or M if you have an SGI Visual Workstation and you want to
+  be able to use its on-board audio.  Read Documentation/sound/visws
+  for more info on this driver's capabilities.
+
+Creative EMU10K1 based PCI sound cards
+CONFIG_SOUND_EMU10K1
+  Say Y or M if you have a PCI sound card using the EMU10K1
+  chipset, such as the Creative SBLive!,  SB PCI512 or Emu-APS.
+
+Ensoniq ES1370 based PCI sound cards
+CONFIG_SOUND_ES1370
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1370 chipset, such as Ensoniq's AudioPCI (non-97). To find
+  out if your sound card uses an ES1370 without removing your
+  computer's cover, use lspci -n and look for the PCI ID 
+  1274:5000. Since Ensoniq was bought by Creative Labs,
+  Sound Blaster 64/PCI models are either ES1370 or ES1371 based.
+  This driver differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/es1370.
+
+Joystick support at boot time
+CONFIG_SOUND_ES1370_JOYPORT_BOOT
+  Say Y here to use the joystick port of your sound card.
+
+Ensoniq ES1371 based PCI sound cards
+CONFIG_SOUND_ES1371
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1371 chipset, such as Ensoniq's AudioPCI97. To find out if
+  your sound card uses an ES1371 without removing your computer's
+  cover, use lspci -n and look for the PCI ID 1274:1371. Since
+  Ensoniq was bought by Creative Labs, Sound Blaster 64/PCI
+  models are either ES1370 or ES1371 based. This driver differs
+  slightly from OSS/Free, so PLEASE READ Documentation/sound/es1371.
+
+Joystick support at boot time
+CONFIG_SOUND_ES1371_JOYPORT_BOOT
+  Say Y here to use the joystick port of your sound card.
+
+Gameport I/O-range selection
+CONFIG_SOUND_ES1371_GAMEPORT
+  Select the I/O-range of the gameport on a ES1371 based sound card.
+  The card uses 8 ioports and the gameport is available at all eight
+  ioports. Legal hexadecimal values are 200, 208, 210 and 218.
+  The joystick driver will by default use 0x201. 
+  Leave the default 200 unless you have a joystick not attached
+  to your sound card.
+
+ESS Solo1 based PCI sound cards (eg. SC1938)
+CONFIG_SOUND_ESSSOLO1
+  Say Y or M if you have a PCI sound card utilizing the ESS Technology
+  Solo1 chip. To find out if your sound card uses a
+  Solo1 chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 125D:1969. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/solo1.
+
+S3 SonicVibes based PCI sound cards
+CONFIG_SOUND_SONICVIBES
+  Say Y or M if you have a PCI sound card utilizing the S3
+  SonicVibes chipset. To find out if your sound card uses a
+  SonicVibes chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 5333:CA00. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/sonicvibes.
+  
+Trident 4DWave DX/NX or SiS 7018 PCI Audio Core or ALi 5451
+CONFIG_SOUND_TRIDENT
+  Say Y or M if you have a PCI sound card utilizing the Trident
+  4DWave-DX/NX chipset or your mother board chipset has SiS 7018
+  built-in, or if you have an ALi 5451. The SiS 7018 PCI Audio Core
+  is embedded in SiS960 Super South Bridge and SiS540/630 Single
+  Chipset.
+
+  Use lspci -n to find out if your sound card or chipset uses
+  Trident 4DWave or SiS 7018. PCI ID 1023:2000 or 1023:2001 stands
+  for Trident 4Dwave. PCI ID 1039:7018 stands for SiS7018.
+  PCI ID 10b9:5451 stands for ALi 5451.
+
+  This driver differs slightly from OSS/Free, so PLEASE READ the
+  comments at the beginning of driver/sound/trident.c
+
+Rockwell WaveArtist
+CONFIG_SOUND_WAVEARTIST
+  Say Y here to include support for the Rockwell WaveArtist sound
+  system.  This driver is mainly for the NetWinder.
+
+NeoMagic 256AV/256ZX sound chipsets
+CONFIG_SOUND_NM256
+  Say M here to include audio support for the NeoMagic 256AV/256ZX
+  chipsets.  These are the audio chipsets found in the Sony Z505S/SX/DX,
+  some Sony F-series, and the Dell Latitude CPi and CPt laptops. It includes 
+  support for an AC97-compatible mixer and an apparently proprietary sound 
+  engine.
+
+  See Documentation/sound/NM256 for further information.
+
+ESS Maestro sound chipsets
+CONFIG_SOUND_MAESTRO
+  Say Y or M if you have a sound system driven by ESS's Maestro line
+  of PCI sound chips.  These include the Maestro 1, Maestro 2, and
+  Maestro 2E.  See Documentation/sound/Maestro for more details.
+
+Are you using a crosscompiler
+CONFIG_CROSSCOMPILE
+  Say Y here if you are compiling the kernel on a different
+  architecture than the one it is intended to run on.
+
+Build fp exception handler module
+CONFIG_MIPS_FPE_MODULE
+  Build the floating point exception handler module. This option is
+  only useful for people working on the floating point exception
+  handler. If you don't, say N.
+
+Remote GDB kernel debugging
+CONFIG_REMOTE_DEBUG
+  If you say Y here, it will be possible to remotely debug the MIPS
+  kernel using gdb. This enlarges your kernel image disk size by
+  several megabytes and requires a machine with more than 16 MB,
+  better 32 MB RAM to avoid excessive linking time. This is only
+  useful for kernel hackers. If unsure, say N.
+
+Magic System Request Key support
+CONFIG_MAGIC_SYSRQ
+  If you say Y here, you will have some control over the system even
+  if the system crashes for example during kernel debugging (e.g., you
+  will be able to flush the buffer cache to disk, reboot the system
+  immediately or dump some status information). This is accomplished
+  by pressing various keys while holding SysRq (Alt+PrintScreen). The
+  keys are documented in Documentation/sysrq.txt. Don't say Y unless
+  you really know what this hack does.
+
+ISDN subsystem
+CONFIG_ISDN
+  ISDN ("Integrated Services Digital Networks", called RNIS in France)
+  is a special type of fully digital telephone service; it's mostly
+  used to connect to your Internet service provider (with SLIP or
+  PPP). The main advantage is that the speed is higher than ordinary
+  modem/telephone connections, and that you can have voice
+  conversations while downloading stuff. It only works if your
+  computer is equipped with an ISDN card and both you and your service
+  provider purchased an ISDN line from the phone company. For details,
+  read http://alumni.caltech.edu/~dank/isdn/ on the WWW.
+
+  This driver allows you to use an ISDN-card for networking
+  connections and as dialin/out device. The isdn-tty's have a built in
+  AT-compatible modem emulator. Network devices support autodial,
+  channel-bundling, callback and caller-authentication without having
+  a daemon running. A reduced T.70 protocol is supported with tty's
+  suitable for German BTX. On D-Channel, the protocols EDSS1
+  (Euro-ISDN) and 1TR6 (German style) are supported. See
+  Documentation/isdn/README for more information. 
+
+  If you want to compile the ISDN code as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called isdn.o. If unsure, say N.
+
+Support synchronous PPP
+CONFIG_ISDN_PPP
+  Over digital connections such as ISDN, there is no need to
+  synchronize sender and recipient's clocks with start and stop bits
+  as is done over analog telephone lines. Instead, one can use
+  "synchronous PPP". Saying Y here will include this protocol. This
+  protocol is used by Cisco and Sun for example. So you want to say Y
+  here if the other end of your ISDN connection supports it. You will
+  need a special version of pppd (called ipppd) for using this
+  feature. See Documentation/isdn/README.syncppp and
+  Documentation/isdn/syncPPP.FAQ for more information.
+
+Support generic MP (RFC 1717)
+CONFIG_ISDN_MPP
+  With synchronous PPP enabled, it is possible to increase throughput
+  by bundling several ISDN-connections, using this protocol. See
+  Documentation/isdn/README.syncppp for more information.
+
+Use VJ-compression with synchronous PPP
+CONFIG_ISDN_PPP_VJ
+  This enables Van Jacobson header compression for synchronous PPP.
+  Say Y if the other end of the connection supports it.
+
+Support audio via ISDN
+CONFIG_ISDN_AUDIO
+  If you say Y here, the modem-emulator will support a subset of the
+  EIA Class 8 Voice commands. Using a getty with voice-support
+  (mgetty+sendfax by gert@greenie.muc.de with an extension, available
+  with the ISDN utility package for example), you will be able to use
+  your Linux box as an ISDN-answering machine. Of course, this must be
+  supported by the lowlevel driver also. Currently, the HiSax driver
+  is the only voice-supporting driver. See
+  Documentation/isdn/README.audio for more information.
+
+X.25 PLP on top of ISDN
+CONFIG_ISDN_X25
+  This feature provides the X.25 protocol over ISDN connections.
+  See Documentation/isdn/README.x25 for more information
+  if you are thinking about using this.
+
+ISDN diversion services support
+CONFIG_ISDN_DIVERSION
+  This option allows you to use some supplementary diversion
+  services in conjunction with the HiSax driver on an EURO/DSS1
+  line. 
+
+  Supported options are CD (call deflection), CFU (Call forward
+  unconditional), CFB (Call forward when busy) and CFNR (call forward
+  not reachable). Additionally the actual CFU, CFB and CFNR state may
+  be interrogated.
+
+  The use of CFU, CFB, CFNR and interrogation may be limited to some
+  countries. The keypad protocol is still not implemented. CD should
+  work in all countries if the service has been subscribed to.
+
+  Please read the file Documentation/isdn/README.diversion.
+
+ICN 2B and 4B support
+CONFIG_ISDN_DRV_ICN
+  This enables support for two kinds of ISDN-cards made by a German
+  company called ICN. 2B is the standard version for a single ISDN
+  line with two B-channels, 4B supports two ISDN lines. For running
+  this card, additional firmware is necessary, which has to be
+  downloaded into the card using a utility which is distributed
+  separately. See Documentation/isdn/README and README.icn for more
+  information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called icn.o.
+
+isdnloop support
+CONFIG_ISDN_DRV_LOOP
+  This driver provides a virtual ISDN card. Its primary purpose is
+  testing of linklevel features or configuration without getting
+  charged by your service-provider for lots of phone calls.
+  You need will need the loopctrl utility from the latest isdn4k-utils
+  package to set up this driver.
+
+HiSax SiemensChipSet driver support
+CONFIG_ISDN_DRV_HISAX
+  This is a driver supporting the Siemens chipset on various
+  ISDN-cards (like AVM A1, Elsa ISDN cards, Teles S0-16.0, Teles
+  S0-16.3, Teles S0-8, Teles/Creatix PnP, ITK micro ix1 and many
+  compatibles). 
+
+  HiSax is just the name of this driver, not the name of any hardware.
+  
+  If you have a card with such a chipset, you should say Y here and
+  also to the configuration option of the driver for your particular
+  card, below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called hisax.o. See Documentation/isdn/README.HiSax for more
+  information on using this driver.
+
+HiSax Support for EURO/DSS1
+CONFIG_HISAX_EURO
+  Enable this if you have a EURO ISDN line.
+
+Support for german chargeinfo
+CONFIG_DE_AOC
+  If you have german AOC, you can enable this to get the charginfo.
+
+Disable sending complete
+CONFIG_HISAX_NO_SENDCOMPLETE
+  If you have trouble with some ugly exchanges or you live in
+  Australia select this option.
+
+Disable sending low layer compatibility
+CONFIG_HISAX_NO_LLC
+  If you have trouble with some ugly exchanges try to select this
+  option.
+
+Disable keypad protocol option
+CONFIG_HISAX_NO_KEYPAD
+  If you like to send special dialstrings including * or # without
+  using the keypad protocol, select this option.
+
+HiSax Support for german 1TR6
+CONFIG_HISAX_1TR6
+  Enable this if you have a old german 1TR6 line.
+
+Teles 16.0/8.0
+CONFIG_HISAX_16_0
+  This enables HiSax support for the Teles ISDN-cards S0-16.0, S0-8
+  and many compatibles. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port/shmem settings.
+
+Teles 16.3 or PNP or PCMCIA
+CONFIG_HISAX_16_3
+  This enables HiSax support for the Teles ISDN-cards S0-16.3 the
+  Teles/Creatix PnP and the Teles PCMCIA.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Teles PCI
+CONFIG_HISAX_TELESPCI
+  This enables HiSax support for the Teles PCI.
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+Teles S0Box
+CONFIG_HISAX_S0BOX
+  This enables HiSax support for the Teles/Creatix parallel port
+  S0BOX.  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 (Fritz)
+CONFIG_HISAX_AVM_A1
+  This enables HiSax support for the AVM A1 (aka "Fritz").
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+AVM PnP/PCI (Fritz!PNP/PCI)
+CONFIG_HISAX_FRITZPCI
+  This enables HiSax support for the AVM "Fritz!PnP" and "Fritz!PCI".
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 PCMCIA (Fritz)
+CONFIG_HISAX_AVM_A1_PCMCIA
+  This enables HiSax support for the AVM A1 "Fritz!PCMCIA").
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+Elsa cards
+CONFIG_HISAX_ELSA
+  This enables HiSax support for the Elsa Mircolink ISA cards, for the
+  Elsa Quickstep series cards and Elsa PCMCIA.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ITK ix1-micro Revision 2
+CONFIG_HISAX_IX1MICROR2
+  This enables HiSax support for the ITK ix1-micro Revision 2 card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Eicon.Diehl Diva cards
+CONFIG_HISAX_DIEHLDIVA
+  This enables HiSax support for the Eicon.Diehl Diva none PRO
+  versions passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ASUSCOM ISA cards
+CONFIG_HISAX_ASUSCOM
+  This enables HiSax support for the AsusCom and their OEM versions
+  passive ISDN ISA cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+TELEINT cards
+CONFIG_HISAX_TELEINT
+  This enables HiSax support for the TELEINT SA1 semiactiv ISDN card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+HFC-S based cards
+CONFIG_HISAX_HFCS
+  This enables HiSax support for the HFC-S 2BDS0 based cards, like
+  teles 16.3c.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Sedlbauer cards
+CONFIG_HISAX_SEDLBAUER
+  This enables HiSax support for the Sedlbauer passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+USR Sportster internal TA
+CONFIG_HISAX_SPORTSTER
+  This enables HiSax support for the USR Sportster internal TA card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+MIC card
+CONFIG_HISAX_MIC
+  This enables HiSax support for the ITH MIC card. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+NETjet card
+CONFIG_HISAX_NETJET
+  This enables HiSax support for the NetJet from Traverse
+  Technologies.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Niccy PnP/PCI card
+CONFIG_HISAX_NICCY
+  This enables HiSax support for the Dr. Neuhaus Niccy PnP or PCI. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Siemens I-Surf card
+CONFIG_HISAX_ISURF
+  This enables HiSax support for the Siemens I-Talk/I-Surf card with
+  ISAR chip.
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HST Saphir card
+CONFIG_HISAX_HSTSAPHIR
+  This enables HiSax support for the HST Saphir card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Telekom A4T card
+CONFIG_HISAX_BKM_A4T
+  This enables HiSax support for the Telekom A4T card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Scitel Quadro card
+CONFIG_HISAX_SCT_QUADRO
+  This enables HiSax support for the Scitel Quadro card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Gazel cards
+CONFIG_HISAX_GAZEL
+  This enables HiSax support for the Gazel cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC PCI-Bus cards
+CONFIG_HISAX_HFC_PCI
+  This enables HiSax support for the HFC-S PCI 2BDS0 based cards.
+  
+  For more informations see under Documentation/isdn/README.hfc-pci.
+
+Winbond W6692 based cards
+CONFIG_HISAX_W6692
+  This enables HiSax support for Winbond W6692 based PCI ISDN cards.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC-S+, HFC-SP, HFC-PCMCIA cards (EXPERIMENTAL)
+CONFIG_HISAX_HFC_SX
+  This enables HiSax support for the HFC-S+, HFC-SP and HFC-PCMCIA cards.
+  This code is not finished yet.
+
+Am7930 (EXPERIMENTAL)
+CONFIG_HISAX_AMD7930
+  This enables HiSax support for the AMD7930 chips on some SPARCs.
+  This code is not finished yet.
+
+PCBIT-D support
+CONFIG_ISDN_DRV_PCBIT
+  This enables support for the PCBIT ISDN-card. This card is
+  manufactured in Portugal by Octal. For running this card, additional
+  firmware is necessary, which has to be downloaded into the card
+  using a utility which is distributed separately. See
+  Documentation/isdn/README and Documentation/isdn/README.pcbit for
+  more information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pcbit.o.
+
+Spellcaster support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_SC
+  This enables support for the Spellcaster BRI ISDN boards. This
+  driver currently builds only in a modularized version ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want, details in Documentation/modules.txt); the module will be
+  called sc.o. See Documentation/isdn/README.sc and
+  http://www.spellcast.com for more information.
+
+Eicon.Diehl active card support
+CONFIG_ISDN_DRV_EICON
+  Say Y here if you have an Eicon active ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using the eiconctrl utility which is part of the
+  latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+  
+Eicon old-type card support
+CONFIG_ISDN_DRV_EICON_ISA
+  Say Y here if you have an old-type Eicon active ISDN card. In order
+  to use this card, additional firmware is necessary, which has to be
+  loaded into the card using the eiconctrl utility which is part of
+  the latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+
+Support AT-Fax Class 2 commands
+CONFIG_ISDN_TTY_FAX
+  If you say Y here, the modem-emulator will support a subset of the
+  Fax Class 2 commands. Using a getty with fax-support
+  (mgetty+sendfax, hylafax), you will be able to use your Linux box as
+  an ISDN-fax-machine. This must be supported by the lowlevel driver
+  also. See Documentation/isdn/README.fax for more information.
+
+AVM CAPI2.0 support
+CONFIG_ISDN_DRV_AVMB1
+  This enables support for the AVM B1/T1 ISDN networking cards.In
+  addition, a CAPI (Common ISDN Application Programming Interface, a
+  standard making it easy for programs to access ISDN hardware, see
+  http://www.capi.org/; to browse the WWW, you need to have access to
+  a machine on the Internet that has a program like lynx or netscape)
+  interface for this card is provided. In order to use this card,
+  additional firmware is necessary, which has to be downloaded into
+  the card using a utility which is distributed separately. Please
+  read the file Documentation/isdn/README.avmb1. 
+  
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called avmb1.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AVM B1 ISA support
+CONFIG_ISDN_DRV_AVMB1_B1ISA
+  Enable support for the ISA version of the AVM B1 card.
+
+AVM B1 PCI support
+CONFIG_ISDN_DRV_AVMB1_B1PCI
+  Enable support for the PCI version of the AVM B1 card.
+
+AVM B1 PCI V4 support
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4
+  Enable support for the V4 version of AVM B1 PCI card.
+
+AVM T1/T1-B ISA support
+CONFIG_ISDN_DRV_AVMB1_T1ISA
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM B1/M1/M2 PCMCIA support
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA
+  Enable support for the PCMCIA version of the AVM B1 card.
+
+AVM T1/T1-B PCI support
+CONFIG_ISDN_DRV_AVMB1_T1PCI
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM C4 support
+CONFIG_ISDN_DRV_AVMB1_C4
+  Enable support for the AVM C4 PCI card.
+  This card handle 4 BRI ISDN lines (8 channels).
+
+Verbose reason code reporting (kernel size +=7K)
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
+  If you say Y here, the AVM B1 driver will give verbose reasons for
+  disconnecting. This will increase the size of the kernel by 7 KB. If
+  unsure, say Y.
+
+
+IBM Active 2000 support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_ACT2000
+  Say Y here if you have an IBM Active 2000 ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using a utility which is part of the latest
+  isdn4k-utils package. Please read the file
+  Documentation/isdn/README.act2000 for more information.
+
+Support for AP1000 multicomputer
+CONFIG_AP1000
+  This enables support for a SPARC based parallel multi-computer
+  called AP1000+. For details on our efforts to port Linux to this
+  machine see http://cap.anu.edu.au/cap/projects/linux (to browse the
+  WWW, you need to have access to a machine on the Internet that has a
+  program like lynx or netscape) or mail to hackers@cafe.anu.edu.au
+
+Support for Sun4 architecture
+CONFIG_SUN4
+  Say Y here if, and only if, your machine is a Sun4. Note that
+  a kernel compiled with this option will run only on Sun4.
+  (And the current version will probably work only on sun4/330.)
+
+SPARC ESP SCSI support
+CONFIG_SCSI_SUNESP
+  This is the driver for the Sun ESP SCSI host adapter. The ESP
+  chipset is present in most SPARC-based computers.
+
+SPARC /dev/openprom compatibility driver
+CONFIG_SUN_OPENPROMIO
+  This driver provides user programs with an interface to the SPARC
+  PROM device tree. The driver implements a SunOS-compatible
+  interface and a NetBSD-compatible interface. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. If unsure, say Y.
+
+Mostek real time clock support
+CONFIG_SUN_MOSTEK_RTC
+  The Mostek RTC chip is used on all knows Sun computers except
+  some JavaStation-s. For a JavaStation you need to say Y both here
+  and to CONFIG_RTC.
+
+  Say Y here unless you are building a special purpose kernel.
+
+#
+#Siemens SAB82532 serial support
+#CONFIG_SAB82532
+###
+### Please someone fill these in.
+###
+
+#
+# m68k-specific kernel options
+# Documented by Chris Lawrence <quango@themall.net> et al.
+#
+Amiga support
+CONFIG_AMIGA
+  This option enables support for the Amiga series of computers. If
+  you plan to use this kernel on an Amiga, say Y here and browse the
+  material available in Documentation/m68k; otherwise say N.
+
+Atari support
+CONFIG_ATARI
+  This option enables support for the 68000-based Atari series of
+  computers (including the TT, Falcon and Medusa). If you plan to use
+  this kernel on an Atari, say Y here and browse the material
+  available in Documentation/m68k; otherwise say N.
+
+Hades support
+CONFIG_HADES
+  This option enables support for the Hades Atari clone. If you plan
+  to use this kernel on a Hades, say Y here; otherwise say N.
+
+Macintosh support
+CONFIG_MAC
+  This option enables support for the Apple Macintosh series of
+  computers (yes, there is experimental support now, at least for part
+  of the series).
+  
+  Say N unless you're willing to code the remaining necessary support.
+  ;)
+
+HP9000/300 support
+CONFIG_HP300
+  This option enables support for the HP9000/300 series of
+  workstations. Support for these machines is still very experimental.
+  If you plan to try to use the kernel on such a machine say Y here.
+  Everybody else says N.
+
+68020 support
+CONFIG_M68020
+  If you anticipate running this kernel on a computer with a MC68020
+  processor, say Y. Otherwise, say N. Note that the 68020 requires a
+  68851 MMU (Memory Management Unit) to run Linux/m68k.
+
+68030 support
+CONFIG_M68030
+  If you anticipate running this kernel on a computer with a MC68030
+  processor, say Y. Otherwise, say N. Note that a MC68EC030 will not
+  work, as it does not include an MMU (Memory Management Unit).
+
+68040 support
+CONFIG_M68040
+  If you anticipate running this kernel on a computer with a MC68LC040
+  or MC68040 processor, say Y. Otherwise, say N. Note that an
+  MC68EC040 will not work, as it does not include an MMU (Memory
+  Management Unit).
+
+68060 support
+CONFIG_M68060
+  If you anticipate running this kernel on a computer with a MC68060
+  processor, say Y. Otherwise, say N.
+
+Math emulation support
+CONFIG_FPU_EMU
+  At some point in the future, this will cause floating-point math
+  instructions to be emulated by the kernel on machines that lack a
+  floating-point math coprocessor.  Thrill-seekers and chronically
+  sleep-deprived psychotic hacker types can say Y now, everyone else
+  should probably wait a while.
+
+Math emulation only kernel
+CONFIG_FPU_EMU_ONLY
+  This option prevents any floating-point instructions from being
+  compiled into the kernel, thereby the kernel doesn't save any
+  floating point context anymore during task switches, so this
+  kernel will only be usable on machines without a floating-point
+  math coprocessor. This makes the kernel a bit faster as no tests
+  needs to be executed whether a floating-point instruction in the
+  kernel should be executed or not.
+
+Math emulation extra precision
+CONFIG_FPU_EMU_EXTRAPREC
+  The fpu uses normally a few bit more during calculations for
+  correct rounding, the emulator can (often) do the same but this
+  extra calculation can cost quite some time, so you can disable
+  it here. The emulator will then only calculate with a 64 bit
+  mantissa and round slightly incorrect.
+
+Advanced processor options
+CONFIG_ADVANCED_CPU
+  This gives you access to some advanced options for the CPU. The
+  defaults should be fine for most users, but these options may make
+  it possible for you to improve performance somewhat if you know what
+  you are doing. Most users should say N to this question.
+
+Use read-modify-write instructions
+CONFIG_RMW_INSNS
+  This allows to use certain instructions that work with indivisible
+  read-modify-write bus cycles. While this is faster than the
+  workaround of disabling interrupts, it can conflict with DMA 
+  ( = direct memory access) on many Amiga systems, and it is also said
+  to destabilize other machines. It is very likely that this will
+  cause serious problems on any Amiga or Atari Medusa if set. The only
+  configuration where it should work are 68030-based Ataris, where it
+  apparently improves performance. But you've been warned! Unless you
+  really know what you are doing, say N. Try Y only if you're quite
+  adventurous.
+
+Amiga AutoConfig Identification
+CONFIG_ZORRO
+  This enables support for automatic identification of Amiga expansion
+  cards that obey the AutoConfig(tm) specification.
+  Say Y if you want your expansion cards to be identified on bootup;
+  it will enlarge your kernel by about 10 KB. The identification
+  information is also available through /proc/zorro (say Y to
+  "/proc filesystem support"!).
+
+  Note that even if you say N here, you can still use your expansion
+  cards. If in doubt, say Y.
+
+Amiga 1200/600 PCMCIA support
+CONFIG_AMIGA_PCMCIA
+  Include support in the kernel for pcmcia on Amiga 1200 and Amiga 600.
+  If you intend to use pcmcia cards say Y; otherwise say N.
+
+Amiga GSP (TMS340x0) support
+CONFIG_AMIGA_GSP
+  Include support for Amiga graphics cards that use the Texas
+  Instruments TMS340x0 GSP (Graphics Signal Processor) chips. Say Y
+  if you want to use a DMI Resolver or Commodore A2410 (Lowell)
+  graphics card on an Amiga; otherwise, say N.
+
+DMI Resolver support
+CONFIG_GSP_RESOLVER
+  Include support in the kernel for the DMI Resolver graphics card. If
+  you have one, say Y; otherwise, say N.
+
+A2410 support
+CONFIG_GSP_A2410
+  Include support in the kernel for the Commodore/University of Lowell
+  A2410 graphics card. If you have one, say Y; otherwise, say N.
+
+Amiga Zorro II ramdisk support
+CONFIG_AMIGA_Z2RAM
+  This enables support for using Chip RAM and Zorro II RAM as a
+  ramdisk or as a swap partition. Say Y if you want to include this
+  driver in the kernel. This driver is also available as a module 
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). The module is called z2ram.o. If you want
+  to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari ST-RAM swap support
+CONFIG_STRAM_SWAP
+  This enables support for using (parts of) ST-RAM as swap space,
+  instead of as normal system memory. This can first enhance system
+  performance if you have lots of alternate RAM (compared to the size
+  of ST-RAM), because executable code always will reside in faster
+  memory. ST-RAM will remain as ultra-fast swap space. On the other
+  hand, it allows much improved dynamic allocations of ST-RAM buffers
+  for device driver modules (e.g. floppy, ACSI, SLM printer, DMA
+  sound). The probability that such allocations at module load time
+  fail is drastically reduced.
+
+Atari ACSI support
+CONFIG_ATARI_ACSI
+  This enables support for the Atari ACSI interface. The driver
+  supports hard disks and CD-ROMs, which have 512-byte sectors, or can
+  be switched to that mode. Due to the ACSI command format, only disks
+  up to 1 GB are supported. Special support for certain ACSI to SCSI
+  adapters, which could relax that, isn't included yet. The ACSI
+  driver is also the basis for certain other drivers for devices
+  attached to the ACSI bus: Atari SLM laser printer, BioNet-100
+  Ethernet, and PAMsNet Ethernet. If you want to use one of these
+  devices, you need ACSI support, too. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acsi.o.
+
+Probe all LUNs on each ACSI device
+CONFIG_ACSI_MULTI_LUN
+  If you have a ACSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, you should say Y here so that all
+  will be found by the ACSI driver. An ACSI device with multiple LUNs
+  acts logically like multiple ACSI devices. The vast majority of ACSI
+  devices have only one LUN, and so most people can say N here and
+  should in fact do so, because it is safer.
+
+Atari SLM laser printer support
+CONFIG_ATARI_SLM
+  If you have an Atari SLM laser printer, say Y to include support for
+  it in the kernel. Otherwise, say N. This driver is also available as
+  a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). The module will be called
+  acsi_slm.o. Be warned: the driver needs much ST-RAM and can cause
+  problems due to that fact!
+
+A3000 WD33C93A support
+CONFIG_A3000_SCSI
+  If you have an Amiga 3000 and have SCSI devices connected to the
+  built-in SCSI controller, say Y. Otherwise, say N. This driver is
+  also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module is
+  called wd33c93.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+A2091 WD33C93A support
+CONFIG_A2091_SCSI
+  If you have a Commodore A2091 SCSI controller, say Y. Otherwise,
+  say N. This driver is also available as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). The module is called wd33c93.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+GVP Series II WD33C93A support
+CONFIG_GVP11_SCSI
+  If you have a Great Valley Products Series II SCSI controller,
+  answer Y. Also say Y if you have a later model of GVP SCSI
+  controller (such as the GVP A4008 or a Combo board). Otherwise,
+  answer N. This driver does NOT work for the T-Rex series of
+  accelerators from TekMagic and GVP-M.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called gvp11.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Cyberstorm SCSI support
+CONFIG_CYBERSTORM_SCSI
+  If you have an Amiga with an original (MkI) Phase5 Cyberstorm
+  accelerator board and the optional Cyberstorm SCSI controller,
+  answer Y. Otherwise, say N.
+
+Cyberstorm II SCSI support
+CONFIG_CYBERSTORMII_SCSI
+  If you have an Amiga with a Phase5 Cyberstorm MkII accelerator board
+  and the optional Cyberstorm SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 2060 SCSI support
+CONFIG_BLZ2060_SCSI
+  If you have an Amiga with a Phase5 Blizzard 2060 accelerator board
+  and want to use the onboard SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 1230IV/1260 SCSI support
+CONFIG_BLZ1230_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard 1230IV or Blizzard
+  1260 accelerator, and the optional SCSI module, say Y. Otherwise,
+  say N.
+
+Blizzard PowerUP 603e+ SCSI support
+CONFIG_BLZ603EPLUS_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard PowerUP 603e+
+  accelerator, say Y. Otherwise, say N.
+
+Fastlane SCSI support
+CONFIG_FASTLANE_SCSI
+  If you have the Phase5 Fastlane Z3 SCSI controller, or plan to use
+  one in the near future, say Y to this question. Otherwise, say N.
+
+Atari native SCSI support
+CONFIG_ATARI_SCSI
+  If you have an Atari with built-in NCR5380 SCSI controller (TT,
+  Falcon, ...) say Y to get it supported. Of course also, if you have
+  a compatible SCSI controller (e.g. for Medusa). This driver is also
+  available as a module ( = code which can be inserted in and removed
+  from the running kernel whenever you want). The module is called
+  atari_scsi.o. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. This driver supports both styles of
+  NCR integration into the system: the TT style (separate DMA), and
+  the Falcon style (via ST-DMA, replacing ACSI). It does NOT support
+  other schemes, like in the Hades (without DMA).
+
+Long delays for Toshiba CD-ROMs
+CONFIG_ATARI_SCSI_TOSHIBA_DELAY
+  This option increases the delay after a SCSI arbitration to
+  accommodate some flaky Toshiba CD-ROM drives. Say Y if you intend to
+  use a Toshiba CD-ROM drive; otherwise, the option is not needed and
+  would impact performance a bit, so say N.
+
+Hades SCSI DMA emulator (EXPERIMENTAL)
+CONFIG_TT_DMA_EMUL
+  This option enables code which emulates the TT SCSI DMA chip on the
+  Hades. This increases the SCSI transfer rates at least ten times
+  compared to PIO transfers. Note that this code is experimental and
+  has only been tested on a Hades with a 68060 processor. Before you
+  use this, make backups of your entire hard disk.
+
+Macintosh NCR5380 (II-series) SCSI
+CONFIG_MAC_SCSI
+  If you have a Macintosh with NCR5380-based SCSI, say Y.  Otherwise,
+  say N.  This SCSI adaptor is found on all 68030-based Macs,
+  including the II, IIx, IIcx, IIci, IIsi, IIvx, IIvi, Color Classic,
+  Classic II, LC II, LC III, and their associated Performa models, as
+  well as the 68030-based PowerBooks and Duos.
+
+Macintosh NCR53c9[46] (Quadra/Centris) SCSI
+CONFIG_SCSI_MAC_ESP
+  If you have a Macintosh with NCR53c96 or NCR53c94-based SCSI, say
+  Y.  Otherwise, say N.  These SCSI adaptors are found on all
+  68040-based Macs, including all Quadra and Centris models, the LC
+  475/476 and 575, and the Performa 575, 580, and 630.
+
+Ariadne support
+CONFIG_ARIADNE
+  If you have a Village Tronic Ariadne Ethernet adapter, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called ariadne.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Ariadne II support
+CONFIG_ARIADNE2
+  If you have a Village Tronic Ariadne II Ethernet adapter, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called ariadne2.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+A2065 support
+CONFIG_A2065
+  If you have a Commodore A2065 Ethernet adapter, say Y. Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called a2065.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Hydra support
+CONFIG_HYDRA
+  If you have a Hydra Ethernet adapter, say Y. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called hydra.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Pcmcia NE2000 compatible support
+CONFIG_APNE
+  If you have a pcmcia ne2000 compatible adapter, say Y.  Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called apne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari Lance support
+CONFIG_ATARILANCE
+  Say Y to include support for several Atari Ethernet adapters based
+  on the AMD Lance chipset: RieblCard (with or without battery), or
+  PAMCard VME (also the version by Rhotron, with different addresses).
+
+BioNet-100 support
+CONFIG_ATARI_BIONET
+  Say Y to include support for BioData's BioNet-100 Ethernet adapter
+  for the ACSI port. The driver works (has to work...) with a polled
+  I/O scheme, so it's rather slow :-(
+
+PAMsNet support
+CONFIG_ATARI_PAMSNET
+  Say Y to include support for the PAMsNet Ethernet adapter for the
+  ACSI port ("ACSI node"). The driver works (has to work...) with a
+  polled I/O scheme, so it's rather slow :-(
+
+Macintosh NS 8390 based ethernet cards
+CONFIG_DAYNAPORT
+  Say Y to include support for Macintosh ethernet adaptors based on
+  the National Semiconductor 8390 and ST-NIC chips.  This family of
+  cards includes the majority of NuBus ethernet cards, as well as many
+  LC-PDS slot cards, from Apple, Asante, Cabletron, Farallon, and
+  other manufacturers.
+
+Macintosh SONIC based ethernet
+CONFIG_MACSONIC
+  Say Y to include support for Macintosh ethernet adaptors based on
+  the National Semiconductor SONIC chip (83932 and 83934).  If you
+  have a Quadra with onboard SONIC ethernet, say Y here.  Onboard
+  SONIC ethernet chips are found on all Quadra 605, 610, 650, 700,
+  800, 900, and 950 models, all Centris 650, most Centris 610, and all
+  LC475/476 models.  It is also found in the DuoDock Plus and DuoDock
+  II, as well as many NuBus, LC-PDS, and comm-slot cards. 
+
+Macintosh (AV) onboard MACE ethernet
+CONFIG_MACMACE
+  Say Y here if you have a Centris 660AV, a Quadra 660AV, or a Quadra
+  840AV, and you would like to use the onboard MACE Ethernet adaptor.
+
+
+Multiface Card III parallel support
+CONFIG_MULTIFACE_III_LP
+  If you have a Multiface III card for your Amiga, and want to use its
+  parallel port in Linux, say Y. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called lp_m68k.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amiga mouse support
+CONFIG_AMIGAMOUSE
+  If you want to be able to use an Amiga mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called amigamouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amiga Copper Console
+CONFIG_COPCON
+  This configures the console to use the Amiga's graphics coprocessor
+  for scrolling, instead of using the CPU. This option markedly
+  improves response times in the high color modes (5 bitplanes and
+  up). If you would like to use this, say Y; otherwise, say N.
+
+Atari mouse support
+CONFIG_ATARIMOUSE
+  If you want to be able to use an Atari mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called atarimouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari MFP serial support
+CONFIG_ATARI_MFPSER
+  If you like to use the MFP serial ports ("Modem1", "Serial1") under
+  Linux, say Y. The driver equally supports all kinds of MFP serial
+  ports and automatically detects whether Serial1 is available. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. 
+
+  Note for Falcon users: You also have an MFP port, it's just not
+  wired to the outside... But you could use the port under Linux.
+
+Atari SCC serial support
+CONFIG_ATARI_SCC
+  If you have serial ports based on a Zilog SCC chip (Modem2, Serial2,
+  LAN) and like to use them under Linux, say Y. All built-in SCC's are
+  supported (TT, MegaSTE, Falcon), and also the ST-ESCC. If you have
+  two connectors for channel A (Serial2 and LAN), they are visible as
+  two separate devices.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari SCC serial DMA support
+CONFIG_ATARI_SCC_DMA
+  This enables DMA support for receiving data on channel A of the SCC.
+  If you have a TT you may say Y here and read
+  drivers/char/atari_SCC.README. All other users should say N here,
+  because only the TT has SCC-DMA, even if your machine keeps claiming
+  so at boot time.
+
+Atari MIDI serial support
+CONFIG_ATARI_MIDI
+  If you want to use your Atari's MIDI port in Linux, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari DSP56k Digital Signal Processor support
+CONFIG_ATARI_DSP56K
+  If you want to be able to use the DSP56001 in Falcons, say Y. This
+  driver is still experimental, and if you don't know what it is, or
+  if you don't have this processor, just say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Amiga builtin serial support
+CONFIG_AMIGA_BUILTIN_SERIAL
+  If you want to use your Amiga's built-in serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+GVP IO-Extender support
+CONFIG_GVPIOEXT
+  If you want to use a GVP IO-Extender serial card in Linux, say Y.
+  Otherwise, say N.
+
+Multiface Card III serial support
+CONFIG_MULTIFACE_III_TTY
+  If you want to use a Multiface III card's serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Macintosh SCC serial support
+CONFIG_MAC_SCC
+  If you have a Macintosh and would like to use its serial
+  ("Printer" and "Modem") ports in Linux, say Y.  Otherwise, say N.
+
+Amiga or Atari DMA sound support
+CONFIG_DMASOUND
+  If you want to use the internal audio of your Atari or Amiga in
+  Linux, answer Y to this question. This will provide a Sun-like
+  /dev/audio, compatible with the Linux/i386 sound system. Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+HP DCA serial support
+CONFIG_HPDCA
+  If you want to use the internal "DCA" serial ports on an HP300
+  machine, say Y here.
+
+HP on-board LANCE support
+CONFIG_HPLANCE
+  If you want to use the builtin "LANCE" Ethernet controller on an
+  HP300 machine, say Y here.
+
+DIO bus support
+CONFIG_DIO
+  Say Y here to enable support for the "DIO" expansion bus used in
+  HP300 machines. If you are using such a system you almost certainly
+  want this.
+
+MSDOS partition support
+CONFIG_MSDOS_PARTITION
+  This option enables support for using hard disks that were
+  partitioned on an MS-DOS system. This may be useful if you are
+  sharing a hard disk between i386 and m68k Linux boxes, for example.
+  Say Y if you need this feature; users who are only using their
+  system-native partitioning scheme can say N here.
+
+Processor Type
+CONFIG_6xx
+  There are two types of PowerPC chips supported. The more common
+  types (601,603,604,740,750) and the embedded versions (821 and 860).
+  Unless you are building a kernel for one of the embedded boards
+  using the 821 or 860 choose 6xx.
+
+Machine Type
+CONFIG_PMAC
+  Linux currently supports several different kinds of PowerPC-based
+  machines: Apple Power Macintoshes and clones (such as the Motorola
+  Starmax series), PReP (PowerPC Reference Platform) machines such as
+  the Motorola PowerStack, Amiga Power-Up systems (APUS), CHRP and the
+  embedded MBX boards from Motorola. Currently, a single kernel binary
+  only supports one type or the other. However, there is very early
+  work on support for CHRP, PReP and PowerMac's from a single binary.
+
+Support for Open Firmware device tree in /proc
+CONFIG_PROC_DEVICETREE
+  This option adds a device-tree directory under /proc which contains
+  an image of the device tree that the kernel copies from Open
+  Firmware. If unsure, say Y here.
+
+MESH (Power Mac internal SCSI) support
+CONFIG_SCSI_MESH
+  Many Power Macintoshes and clones have a MESH (Macintosh Enhanced
+  SCSI Hardware) SCSI bus adaptor (the 7200 doesn't, but all of the
+  other Power Macintoshes do). Say Y to include support for this SCSI
+  adaptor. This driver is also available as a module called mesh.o
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+
+Maximum synchronous transfer rate
+CONFIG_SCSI_MESH_SYNC_RATE
+  On Power Macintoshes (and clones) where the MESH SCSI bus adaptor
+  drives a bus which is entirely internal to the machine (such as the
+  7500, 7600, 8500, etc.), the MESH is capable of synchronous
+  operation at up to 10 MB/s. On machines where the SCSI bus
+  controlled by the MESH can have external devices connected, it is
+  usually rated at 5 MB/s. 5 is a safe value here unless you know the
+  MESH SCSI bus is internal only; in that case you can say 10. Say 0
+  to disable synchronous operation.
+
+53C94 (Power Mac external SCSI) support
+CONFIG_SCSI_MAC53C94
+  On Power Macintoshes (and clones) with two SCSI buses, the external
+  SCSI bus is usually controlled by a 53C94 SCSI bus adaptor. Older
+  machines which only have one SCSI bus, such as the 7200, also use
+  the 53C94. Say Y to include support for the 53C94. 
+
+  This driver is also available as a module called mac53c94.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+MACE (Power Mac Ethernet) support
+CONFIG_MACE
+  Power Macintoshes and clones with Ethernet built-in on the
+  motherboard will usually use a MACE (Medium Access Control for
+  Ethernet) interface. Say Y to include support for the MACE chip.
+
+  This driver is also available as a module called mace.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Use AAUI port instead of TP by default
+CONFIG_MACE_AAUI_PORT
+  Some Apple machines (notably the Apple Network Server) which use the
+  MACE ethernet chip have an Apple AUI port (small 15-pin connector),
+  instead of an 8-pin RJ45 connector for twisted-pair ethernet.  Say
+  Y here if you have such a machine.  If unsure, say N.
+
+BMAC (G3/G4 ethernet) support
+CONFIG_BMAC
+  Say Y for support of BMAC and BMAC+ Ethernet interfaces. These
+  are used on G3 and G4 computers (Apple Power Macintoshes and
+  PowerBooks).
+
+  This driver is also available as a module called bmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+GMAC (Core99 ethernet) support
+CONFIG_GMAC
+  Say Y for support of the GMAC Ethernet interfaces. This interface
+  is used on some Apple G4 PowerMacs (recent ones), new iMacs, iBooks
+  and PowerBook 2000 (aka "Pismo").
+
+  This driver is also available as a module called gmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Video For Linux
+CONFIG_VIDEO_DEV
+  Support for audio/video capture and overlay devices and FM radio
+  cards. The exact capabilities of each device vary. User tools for
+  this are available from
+  ftp://ftp.uk.linux.org/pub/linux/video4linux.
+
+  If you are interested in writing a driver for such an audio/video
+  device or user software interacting with such a driver, please read
+  the file Documentation/video4linux/API.html.
+
+  This driver is also available as a module called videodev.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+AIMSlab RadioTrack (aka RadioReveal) support
+CONFIG_RADIO_RTRACK
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  Note that newer AIMSlab RadioTrack cards have a different chipset
+  and are not supported by this driver. For these cards, use the
+  RadioTrack II driver below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape. More information is contained in the
+  file Documentation/video4linux/radiotrack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aimslab.o.
+
+RadioTrack i/o port
+CONFIG_RADIO_RTRACK_PORT
+  Enter either 0x30f or 0x20f here. The card default is 0x30f, if you
+  haven't changed the jumper setting on the card.
+
+AIMSlab RadioTrack II support
+CONFIG_RADIO_RTRACK2
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-rtrack2.o.
+
+RadioTrack II i/o port
+CONFIG_RADIO_RTRACK2_PORT
+  Enter either 0x30c or 0x20c here. The card default is 0x30c, if you
+  haven't changed the jumper setting on the card.
+
+Aztech/Packard Bell Radio
+CONFIG_RADIO_AZTECH
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aztech.o.
+
+Aztech/Packard Bell radio card i/o port
+CONFIG_RADIO_AZTECH_PORT
+  Enter either 0x350 or 0x358 here. The card default is 0x350, if you
+  haven't changed the setting of jumper JP3 on the card. Removing the
+  jumper sets the card to 0x358.
+
+ADS Cadet AM/FM Radio Tuner Card
+CONFIG_RADIO_CADET
+  Choose Y here if you have one of these AM/FM radio cards, and then fill
+  in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  Further documentation on this driver can be found on the WWW at
+  http://linux.blackhawke.net/cadet.html. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-cadet.o.
+
+ADS Cadet AM/FM Radio Tuner Card I/O Port
+CONFIG_RADIO_CADET_PORT
+  Enter the I/O address of the card here (most commonly 330). 
+
+Maestro Radio
+CONFIG_RADIO_MAESTRO
+  Choose Y here if you have one of these Maestro sound cards
+  with FM radio included.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-maestro.o
+
+SF16FMI Radio
+CONFIG_RADIO_SF16FMI
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-sf16fmi.o
+
+SF16FMI I/O port (0x284 or 0x384)
+CONFIG_RADIO_SF16FMI_PORT
+  Enter the I/O port of your SF16FMI radio card.
+
+Typhoon Radio
+CONFIG_RADIO_TYPHOON
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address and the frequency used for muting below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-typhoon.o
+
+Support for /proc/radio-typhoon
+CONFIG_RADIO_TYPHOON_PROC_FS
+  Say Y here if you want the typhoon radio card driver to write
+  status information (frequency, volume, muted, mute frequency,
+  base address) to /proc/radio-typhoon. The file can be viewed with
+  your favorite pager (i.e. use "more /proc/radio-typhoon" or "less
+  /proc/radio-typhoon" or simply "cat /proc/radio-typhoon").
+
+Typhoon I/O port (0x316 or 0x336)
+CONFIG_RADIO_TYPHOON_PORT
+  Enter the I/O port of your Typhoon or EcoRadio radio card.
+
+Typhoon frequency set when muting the device (kHz)
+CONFIG_RADIO_TYPHOON_MUTEFREQ
+  Enter the frequency used for muting the radio. The device is never
+  completely silent. If the volume is just turned down, you can still
+  hear silent voices and music. For that reason, the frequency of the
+  radio device is set to the frequency you can enter here whenever
+  the device is muted. There should be no local radio station at that
+  frequency.
+
+Zoltrix Radio
+CONFIG_RADIO_ZOLTRIX
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-zoltrix.o
+
+ZOLTRIX I/O port (0x20c or 0x30c)
+CONFIG_RADIO_ZOLTRIX_PORT
+  Enter the I/O port of your Zoltrix radio card.
+
+ADS Cadet AM/FM Tuner
+CONFIG_RADIO_CADET
+  Say Y here if this is your AM/FM radio card.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-cadet.o
+
+Miro PCM20 Radio
+CONFIG_RADIO_MIROPCM20
+  Choose Y here if you have this FM radio card. You also need to say Y
+  to "ACI mixer (miroPCM12/PCM20)" (in "additional low level sound
+  drivers") for this to work.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-miropcm20.o
+
+GemTek Radio Card
+CONFIG_RADIO_GEMTEK
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  If you have GemTeks combined (PnP) sound- and radio card you might want
+  to use this driver as a module and setup the card with isapnptools. You
+  must also pass the module a suitable io parameter. If you have trouble
+  getting the driver to work with the card as a module, please try building
+  it into the kernel by answering Y.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml; to browse the WWW,
+  you need to have access to a machine on the Internet that has a 
+  program like lynx or netscape.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-gemtek.o.
+
+GemTek i/o port
+CONFIG_RADIO_GEMTEK_PORT
+  Enter either 0x20c, 0x30c, 0x24c or 0x34c here. 0x20c and 0x248 have
+  been reported to work with the combined sound/radio card. The card
+  default is 0x34c, if you haven't changed the jumper setting on the card.
+
+Trust FM Radio Card
+CONFIG_RADIO_TRUST
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-trust.o.
+
+Trust FM Radio I/O port
+CONFIG_RADIO_TRUST_PORT
+  Enter the I/O port of your card (usually 0x350 or 0x358).
+
+BT848 Video For Linux
+CONFIG_VIDEO_BT848
+  Support for BT848 based frame grabber/overlay boards. This includes
+  the Miro, Hauppauge and STB boards. Please read the material in
+  Documentation/video4linux/bttv for more information.
+
+  This driver is also available as a module called bttv.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SAA5249 Teletext processor
+CONFIG_VIDEO_SAA5249
+  Support for I2C bus based teletext using the SAA5249 chip. At the
+  moment this is only useful on some European WinTV cards.
+
+  This driver is also available as a module called saa5249.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Quickcam BW Video For Linux
+CONFIG_VIDEO_BWQCAM
+  Say Y have if you the black and white version of the QuickCam
+  camera. See the next option for the color version. 
+
+  This driver is also available as a module called bw-qcam.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Colour QuickCam Video For Linux
+CONFIG_VIDEO_CQCAM
+  This is the video4linux driver for the colour version of the
+  Connectix Quickcam. If you have one of these cameras, say Y here,
+  otherwise say N. This driver does not work with the original
+  monochrome Quickcam, Quickcam VC or QuickClip. It is also available
+  as a module (c-qcam.o).
+
+Mediavision Pro Movie Studio Video For Linux
+CONFIG_VIDEO_PMS
+  Say Y if you have such a thing. This driver is also available as a
+  module called pms.o ( = code which can be inserted in and removed
+  from the running kernel whenever you want). If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+PlanB Video-In for PowerMacs
+CONFIG_VIDEO_PLANB
+  PlanB is the V4L driver for the PowerMac 7x00/8x00 series video
+  input hardware. If you want to experiment with this, say Y.
+  Otherwise, or if you don't understand a word, say N.
+  See http://www.cpu.lu/~mlan/planb.html for more info.
+
+  Saying M will compile this driver as a module (planb.o).
+
+#
+# ARM options
+#
+CPU Optimization
+CONFIG_CPU_ARM2
+  This selects the processor type of your CPU. This is only used to
+  determine C compiler optimization options, and can affect the
+  compatibility of the kernel on other processors. If you specify
+  ARM6, the kernel should work on all 32-bit processors. If you
+  specify ARM2, ARM250 or ARM3, it should work on all 26-bit
+  processors. If you're not sure, set it to "None".
+
+ARM System type
+CONFIG_ARCH_ARC
+  This selects what ARM system you wish to build the kernel for. It
+  also selects to some extent the CPU type. If you are unsure what
+  to set this option to, please consult any information supplied with
+  your system.
+
+Include support for Chalice CATS boards
+CONFIG_CATS
+  Say Y here if you intend to run this kernel on a CATS system.
+
+Include support for Intel EBSA285
+CONFIG_ARCH_EBSA285
+  Say Y here if you intend to run this kernel on an EBSA-285 evaluation
+  board.
+
+Include support for the NetWinder
+CONFIG_ARCH_NETWINDER
+  Say Y here if you intend to run this kernel on the NetWinder.
+
+Math emulation
+CONFIG_NWFPE
+  Say Y to include the NWFPE floating point emulator in the kernel. This
+  is necessary to run most binaries. Linux does not currently support
+  floating point hardware so you need to say Y here even if your machine
+  has an FPA or floating point co-processor podule.
+
+  It is also possible to say M to build the emulator as a module
+  (nwfpe.o) or indeed to leave it out altogether. However, unless you
+  know what you are doing this can easily render your machine unbootable.
+  Saying Y is the safe option.
+
+  You may say N here if you are going to load the Acorn FPEmulator
+  early in the bootup.
+
+DS1620 Thermometer support
+CONFIG_DS1620
+  Say Y here to include support for the thermal management hardware
+  found in the NetWinder. This driver allows the user to control the
+  temperature set points and to read the current temperature.
+
+  It is also possible to say M here to build it as a module (ds1620.o)
+  It is recommended to be used on a NetWinder, but it is not a
+  necessity.
+
+Verbose kernel error messages
+CONFIG_DEBUG_ERRORS
+  This option controls verbose debugging information which can be
+  printed when the kernel detects an internal error. This debugging
+  information is useful to kernel hackers when tracking down problems,
+  but mostly meaningless to other people. It's safe to say Y unless
+  you are concerned with the code size or don't want to see these
+  messages.
+
+Compile kernel with frame pointer
+CONFIG_FRAME_POINTER
+  If you say Y here, the resulting kernel will be slightly larger and
+  slower, but it will give useful debugging information. If you don't
+  debug the kernel, you can say N.
+
+User fault debugging
+CONFIG_DEBUG_USER
+  When a user program crashes due to an exception, the kernel can print
+  a brief message explaining what the problem was. This is sometimes
+  helpful for debugging but serves no purpose on a production system.
+  Most people should say N here.
+
+Include gdb debugging information in kernel binary
+CONFIG_DEBUG_INFO
+  Say Y here to include source-level debugging information in the
+  `vmlinux' binary image. This is handy if you want to use gdb or
+  addr2line to debug the kernel. It has no impact on the in-memory
+  footprint of the running kernel but it can increase the amount of
+  time and disk space needed for compilation. If in doubt say N.
+
+Split initialisation functions into discardable section
+CONFIG_TEXT_SECTIONS
+  Normally code that is only used during initialisation is collected
+  into a special area of the kernel so that it can be discarded and
+  the memory reclaimed when initialisation is complete. In addition,
+  if the kernel you wish to build is able to run on multiple
+  architectures, it allows the unused code to be discarded. Some
+  versions of binutils, however, have a bug that causes the kernel
+  to crash during startup when this option is enabled. Say Y unless
+  you experience problems that you suspect may be caused by this.
+
+Disable pgtable cache
+CONFIG_NO_PGT_CACHE
+  Normally the kernel maintains a `quicklist' of preallocated pagetable
+  structures in order to increase performance. On machines with very
+  few pages this may however be a loss. Say Y here to disable the pgtable
+  cache.
+
+RISC OS personality
+CONFIG_ARTHUR
+  Say Y here to include the kernel code necessary if you want to run
+  Acorn RISC OS/Arthur binaries under Linux. This code is still very 
+  experimental; if this sounds frightening, say N and sleep in peace.
+  You can also say M here to compile this support as a module (which
+  will be called arthur.o).
+
+Initial kernel command line
+CONFIG_CMDLINE
+  On some architectures (EBSA110 and CATS), there is currently no way
+  for the boot loader to pass arguments to the kernel. For these
+  architectures, you should supply some command-line options at build
+  time by entering them here. As a minimum, you should specify the
+  memory size and the root device (eg, mem=64M root=/dev/nfs)
+
+Hardware alignment trap
+CONFIG_ALIGNMENT_TRAP
+  ARM processors can not fetch/store information which is not naturally
+  aligned on the bus, ie, a 4 byte fetch must start at an address divisable
+  by 4.  On 32-bit ARM processors, these instructions can be emulated in
+  software with a severe performance impact. This is necessary for correct
+  operation of some network protocols.  With an IP-only configuration
+  it is safe to say N, otherwise say Y.
+
+21285 serial port support
+CONFIG_SERIAL_21285
+  If you have a machine based on a 21285 (Footbridge) StrongARM/PCI
+  bridge you can enable its onboard serial port by enabling this
+  option. The device has major ID 4, minor 64.
+
+Console on 21285 serial port
+CONFIG_SERIAL_21285_CONSOLE
+  If you have enabled the serial port on the 21285 footbridge you can
+  make it the console by answering 'Y' to this option.
+
+Footbridge Mode
+CONFIG_HOST_FOOTBRIDGE
+  The 21285 Footbridge chip can operate in either `host mode' or
+  `add-in' mode.  Say Y if your 21285 is in host mode, and therefore
+  is the configuration master, otherwise say N.
+
+MFM harddisk support
+CONFIG_BLK_DEV_MFM
+  Support the MFM hard drives on the Acorn Archimedes both
+  on-board the A4x0 motherboards and via the Acorn MFM podules.
+  Drives upto 64MB are supported. If you haven't got one of these
+  machines or drives just say 'N'.
+
+Old Archimedes floppy (1772) support
+CONFIG_BLK_DEV_FD1772
+  Support the floppy drive on the Acorn Archimedes (A300, A4x0, A540,
+  R140 and R260) series of computers; it supports only 720K floppies
+  at the moment. If you don't have one of these machines just answer
+  'N'.
+
+Autodetect hard drive geometry
+CONFIG_BLK_DEV_MFM_AUTODETECT
+  If you answer 'Y' the MFM code will attempt to automatically detect
+  the cylinders/heads/sectors count on your hard drive. WARNING: This
+  sometimes doesn't work and it also does some dodgy stuff which
+  potentially might damage your drive.
+
+IrDA Protocols
+CONFIG_IRDA
+  Say Y here if you want to build support for the IrDA (TM) protocols.
+  The Infrared Data Associations (tm) specifies standards for wireless
+  infrared communication and is supported by most laptops and PDA's.
+
+  To use Linux support for the IrDA (tm) protocols, you will also need
+  some user-space utilities like the irmanager and probably irattach
+  as well. For more information, see the file
+  Documentation/networking/irda.txt. You also want to read the
+  IR-HOWTO, available from
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called 
+
+IrDA Cache last LSAP
+CONFIG_IRDA_CACHE_LAST_LSAP
+  Say Y here if you want IrLMP to cache the last LSAP used. This makes
+  sense since most frames will be sent/received on the same
+  connection. Enabling this option will save a hash-lookup per frame.
+
+  If unsure, say Y.
+
+IrDA Fast RR's
+CONFIG_IRDA_FAST_RR
+  Say Y here is you want IrLAP to send fast RR (Receive Ready) frames
+  when acting as a primary station. This will make IrLAP send out a RR
+  frame immediately when receiving a frame if its own transmit queue
+  is currently empty. This will give a lot of speed improvement when
+  receiving much data since the secondary station will not have to
+  wait the max. turn around time before it is allowed to transmit the
+  next time. If the transmit queue of the secondary is also empty the
+  primary will back off waiting longer for sending out the RR frame
+  until the timeout reaches the normal value. Enabling this option
+  will make the IR-diode burn more power and thus reduce your battery
+  life.
+
+  If unsure, say N.
+
+IrDA Debug
+CONFIG_IRDA_DEBUG
+  Say Y here if you want the IrDA subsystem to write debug information
+  to your syslog. You can change the debug level in
+  /proc/sys/net/irda/debug
+
+  If unsure, say Y (since it makes it easier to find the bugs).
+
+IrLAP Compression support
+CONFIG_IRDA_COMPRESSION
+  Compression is _not_ part of the IrDA(tm) protocol specification,
+  but it's working great! Linux is the first to try out compression
+  support at the IrLAP layer. This means that you will only benefit
+  from compression if you are running a Linux <-> Linux configuration.
+  
+  If you say Y here, you also need to say Y or M to a compression
+  protocol below.
+
+IrLAP Deflate Compression Protocol
+CONFIG_IRDA_DEFLATE
+  Say Y here if you want to build support for the Deflate compression
+  protocol. The deflate compression (GZIP) is exactly
+  the same as the one used by the PPP protocol. 
+
+  If you want to compile this compression support as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  irda_deflate.o.
+
+IrLAN Protocol 
+CONFIG_IRLAN
+  Say Y here if you want to build support for the IrLAN protocol. If
+  you want to compile it as a module, say M here and read
+  Documentation/modules.txt. IrLAN emulates an Ethernet and makes it
+  possible to put up a wireless LAN using infrared beams.
+
+  The IrLAN protocol can be used to talk with infrared access points 
+  like the HP NetbeamIR, or the ESI JetEye NET. You can also connect 
+  to another Linux machine running the IrLAN protocol for ad-hoc 
+  networking!
+
+IrCOMM Protocol
+CONFIG_IRCOMM
+  Say Y here if you want to build support for the IrCOMM protocol. If
+  you want to compile it as a module, say M here and read
+  Documentation/modules.txt. IrCOMM implements serial port emulation,
+  and makes it possible to use all existing applications that
+  understands TTY's with an infrared link. Thus you should be able to
+  use application like PPP, minicom and others. Enabling this option
+  will create two modules called ircomm and ircomm-tty.
+
+IrTTY IrDA Device Driver
+CONFIG_IRTTY_SIR
+  Say Y here if you want to build support for the IrTTY line
+  discipline. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. IrTTY makes it possible to use
+  Linux's own serial driver for all IrDA ports that are 16550
+  compatible. Most IrDA chips are 16550 compatible so you should
+  probably say Y to this option. Using IrTTY will however limit the
+  speed of the connection to 115200 bps (IrDA SIR mode)
+
+  If unsure, say Y.
+
+IrPORT IrDA Device Driver
+CONFIG_IRPORT_SIR
+  Say Y here if you want to build support for the IrPORT IrDA device
+  driver. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. IrPORT can be used instead of
+  IrTTY and sometimes this can be better. One example is if your
+  IrDA port does not have echo-canceling, which will work OK with
+  IrPORT since this driver is working in half-duplex mode only. You
+  don't need to use irattach with IrPORT, but you just insert it 
+  the same way as FIR drivers (insmod irport io=0x3e8 irq=11).
+  Notice that IrPORT is a SIR device driver which means that speed
+  is limited to 115200 bps.
+
+  If unsure, say Y.
+
+Winbond W83977AF IrDA Device Driver
+CONFIG_WINBOND_FIR
+  Say Y here if you want to build IrDA support for the Winbond
+  W83977AF super-io chipset. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. This driver should be
+  used for the IrDA chipset in the Corel NetWinder. The driver
+  supports SIR, MIR and FIR (4Mbps) speeds.
+
+NSC IrDA Device Driver
+CONFIG_NSC_FIR
+  Say Y here if you want to build support for the NSC PC87108 and
+  PC87338 IrDA chipsets. If you want to compile it as a module, say M 
+  here and read Documentation/modules.txt. This driver supports SIR, 
+  MIR and FIR (4Mbps) speeds.
+
+Toshiba Type-O IR Port Device Driver
+CONFIG_TOSHIBA_FIR
+  Say Y here if you want to build support for the Toshiba Type-O IR
+  chipset. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. This chipset is used by the Toshiba
+  Libretto 100CT, and many more laptops.
+
+ESI JetEye PC Dongle
+CONFIG_ESI_DONGLE
+  Say Y here if you want to build support for the Extended Systems
+  JetEye PC dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The ESI dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for ESI dongles you will have to
+  start irattach like this: "irattach -d esi".
+
+ACTiSYS IR-220L and IR220L+ dongle
+CONFIG_ACTISYS_DONGLE
+  Say Y here if you want to build support for the ACTiSYS
+  IR-220L and IR220L+ dongles. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. The ACTiSYS dongles
+  attaches to the normal 9-pin serial port connector, and can
+  currently only be used by IrTTY. To activate support for ACTiSYS
+  dongles you will have to start irattach like this: 
+  "irattach -d actisys" or "irattach -d actisys+".
+
+Tekram IrMate 210B dongle
+CONFIG_TEKRAM_DONGLE
+  Say Y here if you want to build support for the Tekram IrMate 210B 
+  dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The Tekram dongle attaches to
+  the normal 9-pin serial port connector, and can currently only be
+  used by IrTTY. To activate support for Tekram dongles you will have
+  to start irattach like this: "irattach -d tekram".
+
+Greenwich GIrBIL dongle
+CONFIG_GIRBIL_DONGLE
+  Say Y here if you want to build support for the Greenwich GIrBIL
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Greenwich dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Greenwich dongles you will have to
+  insert "irattach -d girbil" in the /etc/irda/drivers script.
+
+Parallax Litelink dongle
+CONFIG_LITELINK_DONGLE
+  Say Y here if you want to build support for the Parallax Litelink
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Parallax dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Parallax dongles you will have to
+  start irattach like this "irattach -d litelink".
+
+Old Belking dongle
+CONFIG_OLD_BELKING_DONGLE
+  Say Y here if you want to build support for the old Belkin SmartBeam
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Belkin SmartBeam dongle (F5F500) come 
+  in two variants. The only way to distinguish those is to open the 
+  dongle and check the presence of a jumper (the jumper, on the new 
+  dongle, toggle between IrDA and ASK modes). This driver only support 
+  the old dongle. The old dongle is also limited to 9600 b/s (which is 
+  not very fun). To activate support for old Belkin dongles you will 
+  have to start irattach like this: "irattach -d old_dongle".
+
+VME (Motorola and BVM) support
+CONFIG_VME
+  Say Y here if you want to build a kernel for a 680x0 based VME
+  board.  Boards currently supported include Motorola boards MVME162,
+  MVME166, MVME167, MVME172, and MVME177.  BVME4000 and BVME6000
+  boards from BVM Ltd are also supported.
+
+MVME162, 166 and 167 support
+CONFIG_MVME16x
+  Say Y to include support for Motorola VME boards.  This will build a
+  kernel which can run on MVME162, MVME166, MVME167, MVME172, and
+  MVME177 boards.  If you select this option you will have to select
+  the appropriate drivers for SCSI, Ethernet and serial ports later
+  on.
+
+BVME4000 and BVME6000 support
+CONFIG_BVME6000
+  Say Y to include support for VME boards from BVM Ltd.  This will
+  build a kernel which can run on BVME4000 and BVME6000 boards.  If
+  you select this option you will have to select the appropriate
+  drivers for SCSI, Ethernet and serial ports later on.
+
+Use write-through caching for 68060 supervisor accesses
+CONFIG_060_WRITETHROUGH
+  The 68060 generally uses copyback caching of recently accessed data.
+  Copyback caching means that memory writes will be held in an on-chip
+  cache and only written back to memory some time later.  Saying Y
+  here will force supervisor (kernel) accesses to use writethrough
+  caching.  Writethrough caching means that data is written to memory
+  straight away, so that cache and memory data always agree.
+  Writethrough caching is less efficient, but is needed for some
+  drivers on 68060 based systems where the 68060 bus snooping signal
+  is hardwired on.  The 53c710 SCSI driver is known to suffer from
+  this problem.
+
+NCR53C710 SCSI driver for MVME16x
+CONFIG_MVME16x_SCSI
+  The Motorola MVME162, 166, 167, 172 and 177 boards use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+NCR53C710 SCSI driver for BVME6000
+CONFIG_BVME6000_SCSI
+  The BVME4000 and BVME6000 boards from BVM Ltd use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+Simple 53c710 SCSI support (Compaq, NCR machines)
+CONFIG_SCSI_SIM710
+  This is a driver for the NCR53C710 chip commonly found in Compaq and
+  NCR machines.  If you are looking for 53C710 support for an Amiga or
+  some 680x0 based VME card then you probably want the other NCR53C710
+  driver.
+
+MVME16x Ethernet support
+CONFIG_MVME16x_NET
+  This is the driver for the Ethernet interface on the Motorola
+  MVME162, 166, 167, 172 and 177 boards.  Say Y here to include the
+  driver for this chip in your kernel.   If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+BVME6000 Ethernet support
+CONFIG_BVME6000_NET
+  This is the driver for the Ethernet interface on BVME4000 and
+  BVME6000 VME boards.  Say Y here to include the driver for this chip
+  in your kernel.   If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+CD2401 support for MVME166/7 serial ports
+CONFIG_SERIAL167
+  This is the driver for the serial ports on the Motorola MVME166,
+  167, and 172 boards.  Everyone using one of these boards should say
+  Y here.
+
+SCC support for MVME162 serial ports
+CONFIG_MVME162_SCC
+  This is the driver for the serial ports on the Motorola MVME162 and
+  172 boards.  Everyone using one of these boards should say Y here.
+
+SCC support for BVME6000 serial ports
+CONFIG_BVME6000_SCC
+  This is the driver for the serial ports on the BVME4000 and BVME6000
+  boards from BVM Ltd.  Everyone using one of these boards should say
+  Y here.
+
+IBM's S/390 architecture
+CONFIG_ARCH_S390
+  Select this option, if you want to run the Kernel on one of IBM's
+  mainframes of the S/390 generation. You should have installed the
+  s390-compiler released by IBM (based on gcc-2.95.1) before.
+
+Merge some code into the kernel to make the image IPLable
+CONFIG_IPLABLE
+  If you want to use the produced kernel to IPL directly from a
+  device, you have to merge a bootsector specific to the device
+  into the first bytes of the kernel. You will have to select the
+  IPL device on another question, that pops up, when you select
+  CONFIG_IPLABE.
+
+IPL from a S/390 tape unit
+CONFIG_IPL_TAPE
+  Select this option if you want to IPL the image from a tape.
+
+IPL from a virtual card reader emulated by VM/ESA
+CONFIG_IPL_RDR_VM
+  Select this option if you are running under VM/ESA and want 
+  to IPL the image from the emulated card reader.
+
+IPL from a real card reader
+CONFIG_IPL_RDR
+  Select this option if you want to IPL the image from a real
+  card reader. Maybe you still got one and want to try. We didn't
+  test.
+
+IBMs S/390 Harddisks (DASDs)
+CONFIG_DASD
+  Enable this option if you want to access DASDs directly utilizing
+  S/390s channel subsystem commands. This is necessary for running
+  natively on a single image or an LPAR.
+
+Enable DASD fast write
+CONFIG_DASD_FAST_IO
+  Enable fast I/O for DASDs. That means that the next I/O command
+  is already issued at interrupt time, if an I/O request is pending.
+  This option gives significant speedup of I/O, because we don't
+  schedule the bottom-halves as often as Intel.
+
+Support for IBM-style disk-labels (S/390)
+CONFIG_S390_PARTITION
+  Enable this option to assure standard IBM labels on the DASDs.
+  You must enable it, if you are planning to access DASDs also
+  attached to another IBM mainframe operation system (OS/390, 
+  VM/ESA, VSE/ESA).
+
+ECKD devices
+CONFIG_DASD_ECKD
+  ECKD devices are the most commonly used devices. you should enable
+  this option unless you are very sure to have no ECKD device.
+
+CKD devices
+CONFIG_DASD_CKD
+  CKD devices are currently unsupported.
+
+FBA devices
+CONFIG_DASD_FBA
+  FBA devices are e.g. the Vitual disk in storage under VM/ESA and others.
+
+Diag access to CMS formatted minidisk
+CONFIG_DASD_MDSK
+  By using this access method you can acess any disk supported by VM/ESA.
+  You have to format the disk using CMS and then specify the parameter
+  dasd_force_diag=<devno> in the parameter line of the kernel.
+
+Compaq SMART2 support
+CONFIG_BLK_CPQ_DA
+   This is the driver for Compaq Smart Array controllers.  
+   Everyone using these boards should say Y here.  
+   See "linux/Documentation/cpqarray.txt" for the current list of 
+   boards supported by this driver, and for further information 
+   on the use of this driver. 
+
+Compaq Smart Array support
+CONFIG_BLK_CPQ_CISS_DA
+   This is the driver for Compaq Smart Array controllers.
+   Everyone using these boards should say Y here.
+   See "linux/Documentation/cciss.txt" for the current list of
+   boards supported by this driver, and for further information
+   on the use of this driver.
+
+QuickNet Internet LineJack/PhoneJack support
+CONFIG_PHONE_IXJ
+  Say M if you have a telephony card manufactured by Quicknet
+  Technologies, Inc.  These include the Internet PhoneJACK and
+  Internet LineJACK Telephony Cards.
+
+  For the ISA versions of these products, you can configure the
+  cards using the isapnp tools (pnpdump/isapnp) or you can use the
+  backported isapnp module.  Please read:
+
+  /usr/src/linux/Documentation/telephony/ixj.txt.
+
+  For more information on these cards, see Quicknet's website at:
+  http://www.quicknet.net/
+
+  If you do not have any Quicknet telephony cards, you can safely
+  ignore this option.
+
+Toshiba Laptop support
+CONFIG_TOSHIBA	
+  If you intend to run this the kernel on a Toshiba portable say yes
+  here. This adds a driver to safely access the System Management
+  Mode of the CPU on Toshiba portables. The System Management Mode
+  is used to set the BIOS and power saving options on Toshiba portables.
+
+  For information on utilities to make use of this driver see the
+  Toshiba Linux utilities website at:
+  http://www.buzzard.org.uk/toshiba/
+ 
+CPiA Video For Linux
+CONFIG_VIDEO_CPIA
+  This is the video4linux driver for cameras based on Vision's CPiA
+  (Colour Processor Interface ASIC), such as the Creative Labs Video
+  Blaster Webcam II. If you have one of these cameras, say Y here
+  and select parallel port lowlevel support below (the USB-version,
+  is not supported on this kernel-version) otherwise say N. This will
+  not work with the Creative Webcam III. It is also available as a
+  module (cpia.o).
+
+  For more information (supported camera models, module autoloading, DMA
+  interrupt settings, supported applications, etc.) read
+  Documentation/video4linux/README.cpia.
+
+CPiA Parallel Port Lowlevel Support
+CONFIG_VIDEO_CPIA_PP
+  This is the lowlevel parallel port support for cameras based on
+  Vision's CPiA (Colour Processor Interface ASIC), such as the
+  Creative Webcam II. If you have the parallel port version of one
+  of these cameras, say Y here, otherwise say N. It is also available
+  as a module (cpia_pp.o).
+
+CPiA Parallel Port DMA Support
+CONFIG_VIDEO_CPIA_PP_DMA
+  This will use DMA if possible to reduce CPU usage.  If in doubt,
+  say Y here.
+
+7-Segment Display support
+CONFIG_DISPLAY7SEG
+  This is the driver for the digital display and LED present on
+  Sun Microsystems CompactPCI models CP1400 and CP1500.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called display7seg.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+  If you do not have a CompactPCI model CP1400 or CP1500, or 
+  another UltraSPARC-IIi-cEngine boardset with digital display,
+  you should say N to this option.
+   
+#
+# A couple of things I keep forgetting:
+#   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet, 
+#               Intel, IRQ, Linux, MSDOS, NetWare, NetWinder, NFS, 
+#               PCI, SCSI, SPARC
+#   two words:  hard drive, hard disk, sound card, home page
+#   other:      it's safe to save; daemon; use --, not - or ---
+#
+#
+# This is used by Emacs' spell checker ispell.el:
+#
+# LocalWords:  CONFIG coprocessor DX Pentium SX lilo loadlin HOWTO ftp metalab
+# LocalWords:  unc edu docs emu README kB BLK DEV FD Thinkpad fd MFM RLL IDE gz
+# LocalWords:  cdrom diskless netboot nfs xzvf ATAPI MB ide pavia pl pd
+# LocalWords:  HD CDROMs IDECD NEC MITSUMI filesystem XT XD PCI BIOS cezar ATEN
+# LocalWords:  ISA EISA Microchannel VESA BIOSes IPC SYSVIPC ipc Ctrl dmesg hlt
+# LocalWords:  BINFMT Linkable http ac uk jo html GCC SPARC AVANTI CABRIOLET EB
+# LocalWords:  netscape gcc LD CC toplevel MODVERSIONS insmod rmmod modprobe IP
+# LocalWords:  genksyms INET loopback gatewaying ethernet PPP ARP Arp MEMSIZE
+# LocalWords:  howto multicasting MULTICAST MBONE firewalling ipfw ACCT resp ip
+# LocalWords:  proc acct IPIP encapsulator decapsulator klogd PCTCP RARP EXT PS
+# LocalWords:  telnetting subnetted NAGLE rlogin NOSR ttyS TGA techinfo mbone nl
+# LocalWords:  Mb SKB IPX Novell dosemu Appletalk DDP ATALK vmalloc visar ehome
+# LocalWords:  SD CHR scsi thingy SG CD LUNs LUN jukebox Adaptec BusLogic EATA
+# LocalWords:  buslogic DMA DPT ATT eata dma PIO UltraStor fdomain umsdos ext
+# LocalWords:  QLOGIC qlogic TMC seagate Trantor ultrastor FASST wd NETDEVICES
+# LocalWords:  unix BBS linux CSLIP PLIP Kirch's LDP CSlip SL SCC IRQ csustan
+# LocalWords:  Turbo Laplink plip NCSA port's ReQuest IRQs EQL SMC AMD PCnet NE
+# LocalWords:  COM ELPLUS Com EtherLinkIII VLB Arcnet Cabletron DEPCA DE carlos
+# LocalWords:  depca EtherWorks EWRK ewrk SEEQ EtherExpress EEXPRESS NI xxx dia
+# LocalWords:  EtherExpress WaveLAN wavelan PCLAN HPLAN VG SK Ansel Xen de ZNET
+# LocalWords:  PCMCIA cb stanford LAN TEC RealTek ATP atp DLINK NetTools VISWS
+# LocalWords:  TR Sony CDU caddyless cdu Mitsumi MCD cd mcd XA MultiSession CDA
+# LocalWords:  Matsushita Panasonic SBPCD Soundblaster Longshine sbpcd Aztech
+# LocalWords:  Okano Wearnes AZTCD CDD SE aztcd sonycd Goldstar GSCD Philips fs
+# LocalWords:  LMS OPTCD Sanyo SJCD minix faqs xiafs XIA msdos mtools Cichocki
+# LocalWords:  std softlinks umssync NetworkFileSharing nfsd mountd CDs HPFS TI
+# LocalWords:  hpfs SYSV SCO iBCS Wyse WordPerfect tsx mit unixes sysv NR irisa
+# LocalWords:  SMB WfW Cyclades async mux Logitech busmouse MouseSystem aka AST
+# LocalWords:  PSMOUSE Compaq trackballs Travelmate Inport ATIXL ATI busmice ld
+# LocalWords:  gpm config QIC DYNCONF FTAPE Stor Ftape ftape pcsndrv manpage NT
+# LocalWords:  readprofile diskdrives org com masq EtherTalk tcp netrom sunacm
+# LocalWords:  misc AIC aic pio scc Portmaster eql GIS PhotoCDs MCDX Perell PG
+# LocalWords:  mcdx gscd optcd sjcd ISP hdparm Workgroups Lan samba PARIDE PCD
+# LocalWords:  filesystems smbfs ATA ppp PCTech RZ www powerquest txt CMD ESDI
+# LocalWords:  chipset FB multicast MROUTE appletalk ifconfig IBMTR multiport
+# LocalWords:  Multisession STALDRV EasyIO EC EasyConnection ISTALLION ONboard
+# LocalWords:  Brumby pci TNC cis ohio faq usenet NETLINK dev hydra ca Tyne mem
+# LocalWords:  carleton Deskstation DECstation SUNFD JENSEN Noname XXXM SLiRP
+# LocalWords:  pppd Zilog ZS SRM bootloader ez mainmenu rarp ipfwadm paride pcd
+# LocalWords:  RTNETLINK mknod xos MTU lwared Macs mac netatalk macs cs Wolff
+# LocalWords:  dartmouth flowerpt MultiMaster FlashPoint tudelft etherexpress
+# LocalWords:  ICL EtherTeam ETH IDESCSI TXC SmartRAID SmartCache httpd sjc dlp
+# LocalWords:  thesphere TwoServers BOOTP DHCP ncpfs BPQETHER BPQ MG HIPPI cern
+# LocalWords:  bsd comp SPARCstation le SunOS ie Gracilis PackeTwin PT pt LU FX
+# LocalWords:  FX TEAC CR LCS mS ramdisk IDETAPE cmd fperllo encis tcfs unisa
+# LocalWords:  Vertos Genoa Funai hsfs NCP NetWare tgz APM apm ioctls UltraLite
+# LocalWords:  TravelMate CDT LCD backlight VC RPC Mips AXP barlow cdrecord pg
+# LocalWords:  PMAX MILO Alphas Multia Tseng linuxelf endian mipsel mips drv HT
+# LocalWords:  kerneld callouts AdvanSys advansys Admin WDT DataStor EP verden
+# LocalWords:  wdt hdb hdc bugfix SiS vlb Acculogic CSA DTC dtc Holtek ht QDI
+# LocalWords:  QD qd UMC umc ALI ali lena fnet fr azstarnet cdr fb MDA ps esdi
+# LocalWords:  Avanti XL AlphaStations Jensen DECpc AXPpci UDB Cabriolet MCA RC
+# LocalWords:  AlphaPC mca AOUT OUTput PPro sipx gwdg lo nwe FourPort Boca unm
+# LocalWords:  Keepalive linefill RELCOM keepalive analogue CDR conf CDI INIT
+# LocalWords:  OPTi isp irq noisp VFAT vfat NTFS losetup dmsdosfs dosfs ISDN MP
+# LocalWords:  NOWAYOUT behaviour dialin isdn callback BTX Teles ICN EDSS Cisco
+# LocalWords:  ipppd syncppp RFC MPP VJ downloaded icn NICCY Creatix shmem ufr
+# LocalWords:  ibp md ARCnet ether encap NDIS arcether ODI Amigas AmiTCP NetBSD
+# LocalWords:  initrd tue util DES funet des OnNet BIOSP smc Travan Iomega CMS
+# LocalWords:  FC DC dc PPA IOMEGA's ppa RNFS FMV Fujitsu ARPD arpd loran layes
+# LocalWords:  FRAD indiana framerelay DLCI DCLIs Sangoma SDLA mrouted sync sec
+# LocalWords:  Starmode Metricom MosquitoNet mosquitonet kbit nfsroot Digiboard
+# LocalWords:  DIGI Xe Xeve digiboard UMISC touchscreens mtu ethernets HBAs MEX
+# LocalWords:  Shifflett netcom js jshiffle WIC DECchip ELCP EtherPower dst RTC
+# LocalWords:  rtc SMP lp Digi Intl RightSwitch DGRS dgrs AFFS Amiga UFS SDL AP
+# LocalWords:  Solaris RISCom riscom syncPPP PCBIT pcbit sparc anu au artoo MFB
+# LocalWords:  hitchcock Crynwr cnam pktdrvr NCSA's CyDROM CyCDROM FreeBSD NeXT
+# LocalWords:  NeXTstep disklabel disklabels SMD FFS tm AmigaOS diskfiles Un IQ
+# LocalWords:  Bernd informatik rwth aachen uae affs multihosting bytecode java
+# LocalWords:  applets applet JDK ncsa cabi SNI Alphatronix readme LANs scarab
+# LocalWords:  winsock RNIS caltech OSPF honour Honouring Mbit LocalTalk DEFRAG
+# LocalWords:  localtalk download Packetwin Baycom baycom interwork ASCII JNT
+# LocalWords:  Camtec proxying indyramp defragment defragmented UDP FAS FASXX
+# LocalWords:  FastSCSI SIO FDC qlogicfas QLogic qlogicisp setbaycom ife ee LJ
+# LocalWords:  ethz ch Travelmates ProAudioSpectrum ProAudio SoundMan SB SBPro
+# LocalWords:  Thunderboard SM OPL FM ADLIB TSR Gravis MPU PSS ADI SW DSP codec
+# LocalWords:  ADSP ESC ASIC daughtercard GUSMAX MSS NX AdLib Excell Ensoniq YM
+# LocalWords:  SoundScape Spea MediaTriX AudioTriX WSS OTI ThunderBoard VoxWare
+# LocalWords:  Soundscape SSCAPE TRIX MediaTrix PnP Maui dsp midixx EIA getty
+# LocalWords:  mgetty sendfax gert greenie muc lowlevel Lasermate LanManager io
+# LocalWords:  OOPSes trackball binghamton mobileip ncr IOMAPPED settags ns ser
+# LocalWords:  setsync NEGO MPARITY autotuning prefetch PIIX cdwrite utils rc
+# LocalWords:  PCWATCHDOG berkprod bitgate boldt ucsb jf kyoto jp euc Tetsuyasu 
+# LocalWords:  YAMADA tetsu cauchy nslab ntt nevod perm su doc kaf kheops wsc
+# LocalWords:  traduc Bourgin dbourgin menuconfig kfill READMEs HOWTOs Virge WA
+# LocalWords:  IDEDISK IDEFLOPPY EIDE firewalls QMAGIC ZMAGIC LocalWords opti
+# LocalWords:  SVGATextMode vga svga Xkernel syr jmwobus comfaqs dhcp flakey GD
+# LocalWords:  IPv IPng interoperability ipng ipv radio's tapr pkthome PLP nano
+# LocalWords:  Ses Mhz sethdlc SOUNDMODEM WindowsSoundSystem smdiag pcf inka ES
+# LocalWords:  smmixer ptt circ soundmodem MKISS FDDI DEFEA DEFPA DEFXX redhat
+# LocalWords:  HyperNews khg mconv sed lina wuftpd MicroChannel netlink irc cum
+# LocalWords:  raudio RealAudio PPROP NETBIOS GUI IBMMCA ELMC Racal Interlan fi
+# LocalWords:  eth shapecfg src esp PCWD PREVSTAT bootparam sig bitwizard SBC
+# LocalWords:  downloads AFSK TCM FP Karn KA FSK RUH LinkSys cron mouseman LLC
+# LocalWords:  SyQuest SyQuest's CCITT MicroSolutions BPCD bpcd ESPSERIAL PROM
+# LocalWords:  SUNESP openprom OPENPROMIO quango themall al TT MC MMU LC RMW AA
+# LocalWords:  INSNS Ataris AutoConfig ZORRO OCS AMIFB Agnus Denise ECS CDTV GB
+# LocalWords:  AGA Cybervision CYBER GSP TMS DMI Zorro ACSI ROMs SLM BioNet GVP
+# LocalWords:  PAMsNet TekMagic Cyberstorm MkI CYBERSTORMII MkII BLZ onboard cx
+# LocalWords:  Village Tronic ATARILANCE RieblCard PAMCard VME MFP sangoma LAPB
+# LocalWords:  Rhotron BioData's Multiface AMIGAMOUSE COPCON Amiga's bitplanes
+# LocalWords:  ATARIMOUSE MFPSER SCC's MegaSTE ESCC Atari's GVPIOEXT DMASOUND
+# LocalWords:  fdutils cisco univercd rpcg htm iface lapb LAPBETHER tpqic qic
+# LocalWords:  SYNTH xd en binfmt aout ipip terra ipx sd sr sg wic framebuffer
+# LocalWords:  ibmmca lapbether mkiss dlci sdla fmv eepro eexpress ni hp ne es
+# LocalWords:  ibmtr isofs ROMFS romfs pcxx cyclades istallion psaux msbusmouse
+# LocalWords:  atixlmouse sbin softdog pcwd USS Lite ACI miroSOUND PCM miroPCM
+# LocalWords:  microcontroller miro Voxware downloading teles acsi slm gvp ltpc
+# LocalWords:  atari ariadne amigamouse atarimouse builtin IPDDP maths bradford
+# LocalWords:  AppleTalk Farallon PhoneNet Zubkoff lnz SCCB HAPN WANs vesafb nt
+# LocalWords:  wanrouter WANPIPE multiprotocol Mbps wanpipe EtherWORKS nodma SC
+# LocalWords:  smp HiSax SiemensChipSet Siemens AVM Elsa ITK hisax PCC MICROR
+# LocalWords:  Mircolink EURO DSS Spellcaster BRI sc spellcast Digiboards GPIO
+# LocalWords:  SYMBIOS COMPAT SDMS rev ASUS Tekram HX VX API ibmmcascsi ASY asy
+# LocalWords:  loader's PCnetPCI automounter AUTOFS amd autofs VT Gallant's Pnp
+# LocalWords:  AEDSP aedsp enskip tik Sysctl sysctl PARPORT parport pnp IDs EPP
+# LocalWords:  Autoprobe bart patrickr HDLS READBACK AB usr DAMA DS SparQ aten
+# LocalWords:  Symbios PCscsi tmscsim RoamAbout GHz Hinds contrib mathematik ok
+# LocalWords:  darmstadt okir DIGIEPCA International's Xem digiepca epca bootup
+# LocalWords:  zorro CAPI AVMB capi avmb VP SYN syncookies EM em pc Ethertalk
+# LocalWords:  Dayna DL Daynatalk LT PhoneNET ATB Daystar queueing CMDS SCBs ls
+# LocalWords:  SCB STATS Thinnet ThunderLAN TLAN Netelligent NetFlex tlan james
+# LocalWords:  caldera Preload Preloading slowdowns schoebel uni NBD nbd prog
+# LocalWords:  stuttgart rdist TRANS hostnames mango jukeboxes ESS userland PD
+# LocalWords:  hardlinked NAMETRANS env mtab fstab umount nologin runlevel gid
+# LocalWords:  transname filespace adm Nodename hostname uname Kernelname bootp
+# LocalWords:  KERNNAME kname ktype kernelname Kerneltype KERNTYPE Alt RX mdafb
+# LocalWords:  dataless kerneltype SYSNAME Comtrol Rocketport palmtop fbset EGS
+# LocalWords:  nvram SYSRQ SysRq PrintScreen sysrq NVRAMs NvRAM Shortwave RTTY
+# LocalWords:  HFMODEM shortwave Sitor Amtor Pactor GTOR hfmodem hayes TX TMOUT
+# LocalWords:  IDEPCI IDEDMA idedma PDC pdc TRM trm raidtools luthien nuclecu
+# LocalWords:  unam mx miguel koobera uic EMUL solaris pp ieee lpsg co DMAs TOS
+# LocalWords:  BLDCONFIG preloading jumperless BOOTINIT modutils multipath GRE
+# LocalWords:  misconfigured autoconfiguration IPGRE ICMP tracert ipautofw PIM
+# LocalWords:  netis rlynch autofw ipportfw monmouth ipsubs portforwarding pimd
+# LocalWords:  portfw PIMSM netweb usc pim pf EUI aggregatable PB decapsulate
+# LocalWords:  ipddp Decapsulation DECAP bool HAMRADIO tcpdump af CDs tx FBCON
+# LocalWords:  ethertap multisession PPC MMIO GDT GDTH ICP gdth hamradio  bpp
+# LocalWords:  lmh weejock AIMSlab RadioTrack RTRACK HZP OptoSCC TRX rx TRXECHO
+# LocalWords:  DMASCC paccomm dmascc addr cfg oevsv oe kib picpar FDX baudrate
+# LocalWords:  baudrates fdx HDX hdx PSK kanren frforum QoS SCHED CBQ SCH sched
+# LocalWords:  sch cbq CSZ Shenker Zhang csz SFQ sfq TBF tbf PFIFO fifo PRIO RW
+# LocalWords:  prio Micom xIO dwmw rimi OMIRR omirr omirrd unicode ntfs cmu NIC
+# LocalWords:  Braam braam Schmidt's freiburg nls codepages codepage Romanian
+# LocalWords:  Slovak Slovenian Sorbian Nordic iso Catalan Faeroese Galician SZ
+# LocalWords:  Valencian Slovene Esperanto Estonian Latvian Byelorussian KOI mt
+# LocalWords:  charset Inuit Greenlandic Sami Lappish koi SOFTCURSOR softcursor
+# LocalWords:  Specialix specialix DTR RTS RTSCTS cycladesZ Exabyte ftape's inr
+# LocalWords:  Iomega's LBFM claus ZFTAPE VFS zftape zft William's lzrw DFLT kb
+# LocalWords:  MTSETBLK MTIOCTOP qft setblk zftape's tar's afio's setdrvbuffer
+# LocalWords:  Procfs Exabyte's THR FCD sysvinit init PSC pscwdt VMIDI Euro SAB
+# LocalWords:  Mostek Fastlane PowerMac PReP PMAC PowerPC Macintoshes Starmax
+# LocalWords:  PowerStack Starmaxes MCOMMON DEVICETREE ATY IMS IMSTT videodev
+# LocalWords:  BT Hauppauge STB bttv Quickcam BW BWQCAM bw qcam Mediavision PMS
+# LocalWords:  pms Avatar Freecom Imation Superdisk BPCK bpck COMM comm DSTR ru
+# LocalWords:  dstr EPAT EPEZ epat EPIA epia FreeCom FRPW frpw KingByte KBIC HW
+# LocalWords:  KingByte's kbic OnSpec ValuStore FASTROUTE fastroute FLOWCONTROL
+# LocalWords:  struct APIC realtime OSs LynxOS CNC tmp cvf HFS hfs ADFS Risc os
+# LocalWords:  adfs ncpmount namespace SUBDIR reexport NDS kcore FT SPX spx DAT
+# LocalWords:  interserver BLKSZ NUMBUFFERS apmd Tadpole ANA roestock QuickCam
+# LocalWords:  isapnptools Colour CQCAM colour Connectix QuickClip prive mentre
+# LocalWords:  KMOD kmod conformant utexas kharker UnixWare Mwave cgi cl ts ibm
+# LocalWords:  eXchange threepio oakland simtel pre ULTRAMCA EtherLink isa luik
+# LocalWords:  EtherLink OpenBSD pts DEVPTS devpts ptmx ttyp glibc readback SA
+# LocalWords:  mwave OLDCARD isdnloop linklevel loopctrl Eicon Diehl DIEHLDIVA
+# LocalWords:  ASUSCOM AsusCom TELEINT semiactiv Sedlbauer Sportster TA MIC ITH
+# LocalWords:  NETjet NetJet Niccy Neuhaus sparcs AOC AOCD AOCE Microlink SAA
+# LocalWords:  teletext WinTV saa iproute tc Quadra Performa PowerBook tor AUN
+# LocalWords:  setserial compsoc steve Econet econet AUNUDP psched TEQL TLE CLS
+# LocalWords:  teql FW Ingres TwistedPair MTRR MTRRs mtrr cfs crypto TD ktti KT
+# LocalWords:  PHd ICS ipchains adelaide rustcorp syslog Cumana steganography
+# LocalWords:  AcornSCSI EcoSCSI EESOX EESOXSCSI Powertec POWERTECSCSI dec SF
+# LocalWords:  RadioReveal gatekeeper aimslab aztech FMI sf fmi RTL rtl cesdis
+# LocalWords:  Yellowfin gsfc nasa gov yellowfin pcnet Mylex LNE lne EtherH hs
+# LocalWords:  EBSA chattr RiscOS Winmodem AGP Atomwide DUALSP pcsp robinson CT
+# LocalWords:  SGALAXY Waverider DSPxxx TRXPRO AudioTrix OSWF MOT CFB DSY kbps
+# LocalWords:  tuwien kkudielk LVD mega lun MAXTAGS Gbps arcnet Olicom SKTR SNA
+# LocalWords:  SysKonnect sktr sna etherboot ufs NetBEUI MultiSound MSNDCLAS GX
+# LocalWords:  MSNDINIT MSNDPERM MSNDPIN PNDSPINI PNDSPERM Ensoniq's RetinaZ SS
+# LocalWords:  AudioPCI lspci SonicVibes sonicvibes SPARCs roadrunner CLgen UPA
+# LocalWords:  swansea shtml Zoltrix zoltrix BINUTILS EGCS binutils VIDC DACs
+# LocalWords:  CyberVision Cirrus PowerBooks Topcat SBUS CGsix TurboGX BWtwo SS
+# LocalWords:  CGthree TCX unswapable vfb fbcon hicolor truecolor AFB ILBM SOC
+# LocalWords:  IPLAN gracilis Fibre SBus SparcSTORAGE SV jnewbigin swin QNX qnx
+# LocalWords:  PTY PTYS ptyxx ttyxx PTYs ssh sb Avance ALS pss pvv kerneli hd
+# LocalWords:  synth WaveFront MSND NONPNP AudioExcelDSP STRAM APUS CHRP MBX Nx
+# LocalWords:  PowerMac's BMAC radiotrack rtrack miropcm OFFBOARD HPT UDMA DVD
+# LocalWords:  hpt fokus gmd Cyrix DXL SLC DLC NexGen MediaGX GXm IDT WinChip
+# LocalWords:  MMX MII valkyrie mdacon vdolive VDOLive cuseeme CU hippi rrunner
+# LocalWords:  SeeMe ipmasqadm juanjox ipmarkfw markfw TNCs Microdyne rhine lib
+# LocalWords:  libc jsX gamepad gameport CHF FCS FPGaming MadCatz ASSASIN GrIP
+# LocalWords:  Assasin gamepads GamePad PDPI gamecards gamecard WingMan BSP WCS
+# LocalWords:  ThunderPad CyberMan SideWinder ThrustMaster DirectConnect NES XF
+# LocalWords:  Millenium SNES PSX Multisystem Nintendo PlayStation Amstrad CPC
+# LocalWords:  Sega TurboGraFX Steffen Schwenke Multiststem PDIF FIFOSIZE EPLUS
+# LocalWords:  PowerUP RoadRunner tahallah dos functionkey setterm imladris Woz
+# LocalWords:  PowerMacs Winbond Algorithmics ALGOR algor ECOFF IRIX SGI SGI's
+# LocalWords:  gfx virtualized Xpmac mklinux XFree FBDev Woodhouse mvhi Seeq fp
+# LocalWords:  SGISEEQ HIgh ADB ADBMOUSE crosscompiler CROSSCOMPILE FPE GDB gdb
+# LocalWords:  JOYPORT rp spoofing DawiControl NOGENSUPP EEPROM HSSI Alessandro
+# LocalWords:  singleprocessor tex MATHEMU FRIQ Maxell friq Alcor XLT AlphaBook
+# LocalWords:  AlphaPCI DP LX Miata Mikasa Noritake RPX UX BX Takara EV PRIMO
+# LocalWords:  TSC Matrox Productiva matroxfb matrox multihead ia linuxhq MFW
+# LocalWords:  mfw AAA MCS Initio XXU initio imm AutoDetect IZIP CTR usec HDLC
+# LocalWords:  COSA SRP muni cz kas cosa Alteon AceNIC acenic VTOC OSes GMT SAx
+# LocalWords:  Inspiron localtime INTS Thinkpads Ralf Brown's Flightstick NNN
+# LocalWords:  Xterminator Blackhawk NN mpu ioports DCA HPDCA HPLANCE DIO Corel
+# LocalWords:  GemTek gemtek CMDLINE IrDA PDA's irmanager irattach RR AVA DN rg
+# LocalWords:  uit dagb irda LSAP IrLMP RR's IrLAP IR alloc skb's kfree skb's
+# LocalWords:  GZIP IrLAN NetbeamIR ESI JetEye IrOBEX IrCOMM TTY's minicom dti
+# LocalWords:  ircomm ircomm pluto thiguchi IrTTY Linux's bps NetWinder MIR NSC
+# LocalWords:  ACTiSYS Dongle dongle dongles esi actisys IrMate tekram BVM MVME
+# LocalWords:  BVME BVME WRITETHROUGH copyback writethrough fwmark syncookie tu
+# LocalWords:  alphalinux GOBIOS csn chemnitz nat ACARD AMI MegaRAID megaraid
+# LocalWords:  QNX4FS ISI isicom xterms Apollos VPN RCPCI rcpci sgi visws pcmcia
+# LocalWords:  IrLPT UIRCC Tecra
+
diff -druN linux-noipsec/arch/i386/defconfig linux/arch/i386/defconfig
--- linux-noipsec/arch/i386/defconfig	Fri Dec 15 15:16:54 2000
+++ linux/arch/i386/defconfig	Fri Dec 15 15:18:22 2000
@@ -392,3 +392,96 @@
 # Kernel hacking
 #
 # CONFIG_MAGIC_SYSRQ is not set
+#
+# RCSID $Id$
+#
+
+#
+# FreeS/WAN IPSec implementation, KLIPS kernel config defaults
+#
+
+#
+# First, lets override stuff already set or not in the kernel config.
+#
+# We can't even think about leaving this off...
+CONFIG_INET=y
+
+#
+# This must be on for subnet protection.
+CONFIG_IP_FORWARD=y
+
+# Shut off IPSEC masquerading if it has been enabled, since it will 
+# break the compile.  IPPROTO_ESP and IPPROTO_AH were included in 
+# net/ipv4/ip_masq.c when they should have gone into include/linux/in.h.
+CONFIG_IP_MASQUERADE_IPSEC=n
+
+#
+# Next, lets set the recommended FreeS/WAN configuration.
+#
+
+# To config as static (preferred), 'y'.  To config as module, 'm'.
+CONFIG_IPSEC=y
+
+# To do tunnel mode IPSec, this must be enabled.
+CONFIG_IPSEC_IPIP=y
+
+# To enable authentication, say 'y'.   (Highly recommended)
+CONFIG_IPSEC_AH=y
+
+# Authentication algorithm(s):
+CONFIG_IPSEC_AUTH_HMAC_MD5=y
+CONFIG_IPSEC_AUTH_HMAC_SHA1=y
+
+# To enable encryption, say 'y'.   (Highly recommended)
+CONFIG_IPSEC_ESP=y
+
+# Encryption algorithm(s):
+CONFIG_IPSEC_ENC_3DES=y
+
+# IP Compression: new, probably still has minor bugs.
+CONFIG_IPSEC_IPCOMP=y
+
+# To enable userspace-switchable KLIPS debugging, say 'y'.
+CONFIG_IPSEC_DEBUG=y
+
+#
+#
+# $Log$
+# Revision 1.18  2000/11/30 17:26:56  rgb
+# Cleaned out unused options and enabled ipcomp by default.
+#
+# Revision 1.17  2000/09/15 11:37:01  rgb
+# Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+# IPCOMP zlib deflate code.
+#
+# Revision 1.16  2000/09/08 19:12:55  rgb
+# Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+#
+# Revision 1.15  2000/05/24 19:37:13  rgb
+# *** empty log message ***
+#
+# Revision 1.14  2000/05/11 21:14:57  henry
+# just commenting the FOOBAR=y lines out is not enough
+#
+# Revision 1.13  2000/05/10 20:17:58  rgb
+# Comment out netlink defaults, which are no longer needed.
+#
+# Revision 1.12  2000/05/10 19:13:38  rgb
+# Added configure option to shut off no eroute passthrough.
+#
+# Revision 1.11  2000/03/16 07:09:46  rgb
+# Hardcode PF_KEYv2 support.
+# Disable IPSEC_ICMP by default.
+# Remove DES config option from defaults file.
+#
+# Revision 1.10  2000/01/11 03:09:42  rgb
+# Added a default of 'y' to PF_KEYv2 keying I/F.
+#
+# Revision 1.9  1999/05/08 21:23:12  rgb
+# Added support for 2.2.x kernels.
+#
+# Revision 1.8  1999/04/06 04:54:25  rgb
+# Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+# patch shell fixes.
+#
+#
--- linux-noipsec/net/Config.in	Fri Dec 15 15:15:48 2000
+++ linux/net/Config.in	Fri Dec 15 15:18:21 2000
@@ -67,4 +67,8 @@
   endmenu
   fi
 fi
+tristate 'IP Security Protocol (FreeS/WAN IPSEC)' CONFIG_IPSEC
+if [ "$CONFIG_IPSEC" != "n" ]; then
+  source net/ipsec/Config.in
+fi
 endmenu
diff -druN linux-noipsec/net/Config.in.wipsec linux/net/Config.in.wipsec
--- linux-noipsec/net/Config.in.wipsec	Thu Jan  1 01:00:00 1970
+++ linux/net/Config.in.wipsec	Fri Dec 15 15:18:21 2000
@@ -0,0 +1,74 @@
+#
+# Network configuration
+#
+mainmenu_option next_comment
+comment 'Networking options'
+tristate 'Packet socket' CONFIG_PACKET
+bool 'Kernel/User netlink socket' CONFIG_NETLINK
+if [ "$CONFIG_NETLINK" = "y" ]; then
+  bool 'Routing messages' CONFIG_RTNETLINK
+  tristate 'Netlink device emulation' CONFIG_NETLINK_DEV
+fi
+bool 'Network firewalls' CONFIG_FIREWALL
+bool 'Socket Filtering'  CONFIG_FILTER
+tristate 'Unix domain sockets' CONFIG_UNIX
+bool 'TCP/IP networking' CONFIG_INET
+if [ "$CONFIG_INET" = "y" ]; then
+  source net/ipv4/Config.in
+  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+#   Sorry, but IPv6 as module is still invalid.
+    tristate 'The IPv6 protocol (EXPERIMENTAL)' CONFIG_IPV6
+#   bool 'The IPv6 protocol (EXPERIMENTAL)' CONFIG_IPV6
+    if [ "$CONFIG_IPV6" != "n" ]; then
+	    source net/ipv6/Config.in
+    fi
+  fi
+fi
+
+comment ' '
+tristate 'The IPX protocol' CONFIG_IPX
+if [ "$CONFIG_IPX" != "n" ]; then
+  source net/ipx/Config.in
+fi
+tristate 'Appletalk DDP' CONFIG_ATALK
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+#  tristate 'DECnet Support (NOT YET FUNCTIONAL)' CONFIG_DECNET
+#  if [ "$CONFIG_DECNET" != "n" ]; then
+#    source net/decnet/Config.in
+#  fi
+  tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
+  tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
+  bool 'Bridging (EXPERIMENTAL)' CONFIG_BRIDGE
+  if [ "$CONFIG_BRIDGE" != "n" ]; then
+	int '  Maximum number of bridged interfaces' CONFIG_BRIDGE_NUM_PORTS 8
+  fi
+  bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
+  bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
+#  if [ "$CONFIG_LLC" = "y" ]; then
+#   bool 'Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
+#  fi
+  tristate 'Acorn Econet/AUN protocols (EXPERIMENTAL)' CONFIG_ECONET
+  if [ "$CONFIG_ECONET" != "n" ]; then
+    bool '  AUN over UDP' CONFIG_ECONET_AUNUDP
+    bool '  Native Econet' CONFIG_ECONET_NATIVE
+  fi
+  tristate 'WAN router' CONFIG_WAN_ROUTER
+  bool 'Fast switching (read help!)' CONFIG_NET_FASTROUTE
+  bool 'Forwarding between high speed interfaces' CONFIG_NET_HW_FLOWCONTROL
+  bool 'CPU is too slow to handle full bandwidth' CONFIG_CPU_IS_SLOW
+  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+  mainmenu_option next_comment
+  comment 'QoS and/or fair queueing'
+  bool 'QoS and/or fair queueing' CONFIG_NET_SCHED
+  if [ "$CONFIG_NET_SCHED" = "y" ]; then
+    source net/sched/Config.in
+  fi
+#  bool 'Network code profiler' CONFIG_NET_PROFILE
+  endmenu
+  fi
+fi
+tristate 'IP Security Protocol (FreeS/WAN IPSEC)' CONFIG_IPSEC
+if [ "$CONFIG_IPSEC" != "n" ]; then
+  source net/ipsec/Config.in
+fi
+endmenu
diff -druN linux-noipsec/net/Config.in~ linux/net/Config.in~
--- linux-noipsec/net/Config.in~	Thu Jan  1 01:00:00 1970
+++ linux/net/Config.in~	Mon Dec 11 01:49:44 2000
@@ -0,0 +1,70 @@
+#
+# Network configuration
+#
+mainmenu_option next_comment
+comment 'Networking options'
+tristate 'Packet socket' CONFIG_PACKET
+bool 'Kernel/User netlink socket' CONFIG_NETLINK
+if [ "$CONFIG_NETLINK" = "y" ]; then
+  bool 'Routing messages' CONFIG_RTNETLINK
+  tristate 'Netlink device emulation' CONFIG_NETLINK_DEV
+fi
+bool 'Network firewalls' CONFIG_FIREWALL
+bool 'Socket Filtering'  CONFIG_FILTER
+tristate 'Unix domain sockets' CONFIG_UNIX
+bool 'TCP/IP networking' CONFIG_INET
+if [ "$CONFIG_INET" = "y" ]; then
+  source net/ipv4/Config.in
+  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+#   Sorry, but IPv6 as module is still invalid.
+    tristate 'The IPv6 protocol (EXPERIMENTAL)' CONFIG_IPV6
+#   bool 'The IPv6 protocol (EXPERIMENTAL)' CONFIG_IPV6
+    if [ "$CONFIG_IPV6" != "n" ]; then
+	    source net/ipv6/Config.in
+    fi
+  fi
+fi
+
+comment ' '
+tristate 'The IPX protocol' CONFIG_IPX
+if [ "$CONFIG_IPX" != "n" ]; then
+  source net/ipx/Config.in
+fi
+tristate 'Appletalk DDP' CONFIG_ATALK
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+#  tristate 'DECnet Support (NOT YET FUNCTIONAL)' CONFIG_DECNET
+#  if [ "$CONFIG_DECNET" != "n" ]; then
+#    source net/decnet/Config.in
+#  fi
+  tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
+  tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
+  bool 'Bridging (EXPERIMENTAL)' CONFIG_BRIDGE
+  if [ "$CONFIG_BRIDGE" != "n" ]; then
+	int '  Maximum number of bridged interfaces' CONFIG_BRIDGE_NUM_PORTS 8
+  fi
+  bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
+  bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
+#  if [ "$CONFIG_LLC" = "y" ]; then
+#   bool 'Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
+#  fi
+  tristate 'Acorn Econet/AUN protocols (EXPERIMENTAL)' CONFIG_ECONET
+  if [ "$CONFIG_ECONET" != "n" ]; then
+    bool '  AUN over UDP' CONFIG_ECONET_AUNUDP
+    bool '  Native Econet' CONFIG_ECONET_NATIVE
+  fi
+  tristate 'WAN router' CONFIG_WAN_ROUTER
+  bool 'Fast switching (read help!)' CONFIG_NET_FASTROUTE
+  bool 'Forwarding between high speed interfaces' CONFIG_NET_HW_FLOWCONTROL
+  bool 'CPU is too slow to handle full bandwidth' CONFIG_CPU_IS_SLOW
+  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+  mainmenu_option next_comment
+  comment 'QoS and/or fair queueing'
+  bool 'QoS and/or fair queueing' CONFIG_NET_SCHED
+  if [ "$CONFIG_NET_SCHED" = "y" ]; then
+    source net/sched/Config.in
+  fi
+#  bool 'Network code profiler' CONFIG_NET_PROFILE
+  endmenu
+  fi
+fi
+endmenu
diff -druN linux-noipsec/net/Makefile linux/net/Makefile
--- linux-noipsec/net/Makefile	Fri Dec 15 15:15:46 2000
+++ linux/net/Makefile	Fri Dec 15 15:18:21 2000
@@ -161,6 +161,16 @@
   endif
 endif
 
+ifeq ($(CONFIG_IPSEC),y)
+ALL_SUB_DIRS += ipsec
+SUB_DIRS += ipsec
+else
+  ifeq ($(CONFIG_IPSEC),m)
+  ALL_SUB_DIRS += ipsec
+  MOD_SUB_DIRS += ipsec
+  endif
+endif
+
 # We must attach netsyms.o to socket.o, as otherwise there is nothing
 # to pull the object file from the archive.
 
diff -druN linux-noipsec/net/Makefile.wipsec linux/net/Makefile.wipsec
--- linux-noipsec/net/Makefile.wipsec	Thu Jan  1 01:00:00 1970
+++ linux/net/Makefile.wipsec	Fri Dec 15 15:18:21 2000
@@ -0,0 +1,198 @@
+#
+# Makefile for the linux networking.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+MOD_SUB_DIRS := ipv4
+ALL_SUB_DIRS := 802 ax25 bridge core ethernet ipv4 ipv6 ipx unix appletalk \
+		netrom rose lapb x25 wanrouter netlink sched packet sunrpc \
+		econet irda #decnet
+SUB_DIRS     := core ethernet sched
+MOD_LIST_NAME := NET_MISC_MODULES
+
+ifeq ($(CONFIG_NET),y)
+SUB_DIRS += 802
+endif
+
+ifeq ($(CONFIG_INET),y)
+SUB_DIRS += ipv4
+endif
+
+ifeq ($(CONFIG_UNIX),y)
+SUB_DIRS += unix
+else
+  ifeq ($(CONFIG_UNIX),m)
+  MOD_SUB_DIRS += unix
+  endif
+endif
+
+ifeq ($(CONFIG_IPV6),y)
+SUB_DIRS += ipv6
+else
+  ifeq ($(CONFIG_IPV6),m)
+  MOD_SUB_DIRS += ipv6
+  endif
+endif
+
+ifeq ($(CONFIG_NETLINK),y)
+SUB_DIRS += netlink
+  ifeq ($(CONFIG_NETLINK_DEV),m)
+    MOD_SUB_DIRS += netlink
+  endif
+endif
+
+ifeq ($(CONFIG_PACKET),y)
+SUB_DIRS += packet
+else
+  ifeq ($(CONFIG_PACKET),m)
+    MOD_SUB_DIRS += packet
+  endif
+endif
+
+ifeq ($(CONFIG_NET_SCHED),y)
+  MOD_SUB_DIRS += sched
+endif
+
+ifeq ($(CONFIG_BRIDGE),y)
+SUB_DIRS += bridge
+endif
+
+ifeq ($(CONFIG_IPX),y)
+SUB_DIRS += ipx
+# SPX can be still a module
+MOD_SUB_DIRS += ipx
+else
+  ifeq ($(CONFIG_IPX),m)
+  MOD_SUB_DIRS += ipx
+  endif
+endif
+
+ifeq ($(CONFIG_ATALK),y)
+SUB_DIRS += appletalk
+else
+  ifeq ($(CONFIG_ATALK),m)
+  MOD_SUB_DIRS += appletalk
+  endif
+endif
+
+ifeq ($(CONFIG_WAN_ROUTER),y)
+SUB_DIRS += wanrouter
+else
+  ifeq ($(CONFIG_WAN_ROUTER),m)
+  MOD_SUB_DIRS += wanrouter
+  endif
+endif
+
+ifeq ($(CONFIG_X25),y)
+SUB_DIRS += x25
+else
+  ifeq ($(CONFIG_X25),m)
+  MOD_SUB_DIRS += x25
+  endif
+endif
+
+ifeq ($(CONFIG_LAPB),y)
+SUB_DIRS += lapb
+else
+  ifeq ($(CONFIG_LAPB),m)
+  MOD_SUB_DIRS += lapb
+  endif
+endif
+
+ifeq ($(CONFIG_NETROM),y)
+SUB_DIRS += netrom
+else
+  ifeq ($(CONFIG_NETROM),m)
+  MOD_SUB_DIRS += netrom
+  endif
+endif
+
+ifeq ($(CONFIG_ROSE),y)
+SUB_DIRS += rose
+else
+  ifeq ($(CONFIG_ROSE),m)
+  MOD_SUB_DIRS += rose
+  endif
+endif
+
+ifeq ($(CONFIG_AX25),y)
+SUB_DIRS += ax25
+else
+  ifeq ($(CONFIG_AX25),m)
+  MOD_SUB_DIRS += ax25
+  endif
+endif
+
+ifeq ($(CONFIG_IRDA),y)
+SUB_DIRS += irda
+# There might be some irda features that are compiled as modules
+MOD_IN_SUB_DIRS += irda
+else
+  ifeq ($(CONFIG_IRDA),m)
+  MOD_SUB_DIRS += irda
+  endif
+endif
+
+ifeq ($(CONFIG_SUNRPC),y)
+SUB_DIRS += sunrpc
+else
+  ifeq ($(CONFIG_SUNRPC),m)
+  MOD_SUB_DIRS += sunrpc
+  endif
+endif
+
+ifeq ($(CONFIG_DECNET),y)
+SUB_DIRS += decnet
+else
+  ifeq ($(CONFIG_DECNET),m)
+  MOD_SUB_DIRS += decnet
+  endif
+endif
+
+ifeq ($(CONFIG_ECONET),y)
+SUB_DIRS += econet
+else
+  ifeq ($(CONFIG_ECONET),m)
+  MOD_SUB_DIRS += econet
+  endif
+endif
+
+ifeq ($(CONFIG_IPSEC),y)
+ALL_SUB_DIRS += ipsec
+SUB_DIRS += ipsec
+else
+  ifeq ($(CONFIG_IPSEC),m)
+  ALL_SUB_DIRS += ipsec
+  MOD_SUB_DIRS += ipsec
+  endif
+endif
+
+# We must attach netsyms.o to socket.o, as otherwise there is nothing
+# to pull the object file from the archive.
+
+SOCK         := socket.o
+ifeq ($(CONFIG_NET),y)
+ifeq ($(CONFIG_MODULES),y)
+O_TARGET     := sock_n_syms.o
+O_OBJS       := socket.o
+OX_OBJS      := netsyms.o
+SOCK         := $(O_TARGET)
+endif
+endif
+
+L_TARGET     := network.a
+L_OBJS	     := $(SOCK) protocols.o $(join $(SUB_DIRS),$(SUB_DIRS:%=/%.o))
+
+M_OBJS	     :=
+
+ifeq ($(CONFIG_SYSCTL),y)
+ifeq ($(CONFIG_NET),y)
+L_OBJS += sysctl_net.o
+endif
+endif
+
+include $(TOPDIR)/Rules.make
diff -druN linux-noipsec/net/Makefile~ linux/net/Makefile~
--- linux-noipsec/net/Makefile~	Thu Jan  1 01:00:00 1970
+++ linux/net/Makefile~	Mon Mar 22 20:18:17 1999
@@ -0,0 +1,188 @@
+#
+# Makefile for the linux networking.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+MOD_SUB_DIRS := ipv4
+ALL_SUB_DIRS := 802 ax25 bridge core ethernet ipv4 ipv6 ipx unix appletalk \
+		netrom rose lapb x25 wanrouter netlink sched packet sunrpc \
+		econet irda #decnet
+SUB_DIRS     := core ethernet sched
+MOD_LIST_NAME := NET_MISC_MODULES
+
+ifeq ($(CONFIG_NET),y)
+SUB_DIRS += 802
+endif
+
+ifeq ($(CONFIG_INET),y)
+SUB_DIRS += ipv4
+endif
+
+ifeq ($(CONFIG_UNIX),y)
+SUB_DIRS += unix
+else
+  ifeq ($(CONFIG_UNIX),m)
+  MOD_SUB_DIRS += unix
+  endif
+endif
+
+ifeq ($(CONFIG_IPV6),y)
+SUB_DIRS += ipv6
+else
+  ifeq ($(CONFIG_IPV6),m)
+  MOD_SUB_DIRS += ipv6
+  endif
+endif
+
+ifeq ($(CONFIG_NETLINK),y)
+SUB_DIRS += netlink
+  ifeq ($(CONFIG_NETLINK_DEV),m)
+    MOD_SUB_DIRS += netlink
+  endif
+endif
+
+ifeq ($(CONFIG_PACKET),y)
+SUB_DIRS += packet
+else
+  ifeq ($(CONFIG_PACKET),m)
+    MOD_SUB_DIRS += packet
+  endif
+endif
+
+ifeq ($(CONFIG_NET_SCHED),y)
+  MOD_SUB_DIRS += sched
+endif
+
+ifeq ($(CONFIG_BRIDGE),y)
+SUB_DIRS += bridge
+endif
+
+ifeq ($(CONFIG_IPX),y)
+SUB_DIRS += ipx
+# SPX can be still a module
+MOD_SUB_DIRS += ipx
+else
+  ifeq ($(CONFIG_IPX),m)
+  MOD_SUB_DIRS += ipx
+  endif
+endif
+
+ifeq ($(CONFIG_ATALK),y)
+SUB_DIRS += appletalk
+else
+  ifeq ($(CONFIG_ATALK),m)
+  MOD_SUB_DIRS += appletalk
+  endif
+endif
+
+ifeq ($(CONFIG_WAN_ROUTER),y)
+SUB_DIRS += wanrouter
+else
+  ifeq ($(CONFIG_WAN_ROUTER),m)
+  MOD_SUB_DIRS += wanrouter
+  endif
+endif
+
+ifeq ($(CONFIG_X25),y)
+SUB_DIRS += x25
+else
+  ifeq ($(CONFIG_X25),m)
+  MOD_SUB_DIRS += x25
+  endif
+endif
+
+ifeq ($(CONFIG_LAPB),y)
+SUB_DIRS += lapb
+else
+  ifeq ($(CONFIG_LAPB),m)
+  MOD_SUB_DIRS += lapb
+  endif
+endif
+
+ifeq ($(CONFIG_NETROM),y)
+SUB_DIRS += netrom
+else
+  ifeq ($(CONFIG_NETROM),m)
+  MOD_SUB_DIRS += netrom
+  endif
+endif
+
+ifeq ($(CONFIG_ROSE),y)
+SUB_DIRS += rose
+else
+  ifeq ($(CONFIG_ROSE),m)
+  MOD_SUB_DIRS += rose
+  endif
+endif
+
+ifeq ($(CONFIG_AX25),y)
+SUB_DIRS += ax25
+else
+  ifeq ($(CONFIG_AX25),m)
+  MOD_SUB_DIRS += ax25
+  endif
+endif
+
+ifeq ($(CONFIG_IRDA),y)
+SUB_DIRS += irda
+# There might be some irda features that are compiled as modules
+MOD_IN_SUB_DIRS += irda
+else
+  ifeq ($(CONFIG_IRDA),m)
+  MOD_SUB_DIRS += irda
+  endif
+endif
+
+ifeq ($(CONFIG_SUNRPC),y)
+SUB_DIRS += sunrpc
+else
+  ifeq ($(CONFIG_SUNRPC),m)
+  MOD_SUB_DIRS += sunrpc
+  endif
+endif
+
+ifeq ($(CONFIG_DECNET),y)
+SUB_DIRS += decnet
+else
+  ifeq ($(CONFIG_DECNET),m)
+  MOD_SUB_DIRS += decnet
+  endif
+endif
+
+ifeq ($(CONFIG_ECONET),y)
+SUB_DIRS += econet
+else
+  ifeq ($(CONFIG_ECONET),m)
+  MOD_SUB_DIRS += econet
+  endif
+endif
+
+# We must attach netsyms.o to socket.o, as otherwise there is nothing
+# to pull the object file from the archive.
+
+SOCK         := socket.o
+ifeq ($(CONFIG_NET),y)
+ifeq ($(CONFIG_MODULES),y)
+O_TARGET     := sock_n_syms.o
+O_OBJS       := socket.o
+OX_OBJS      := netsyms.o
+SOCK         := $(O_TARGET)
+endif
+endif
+
+L_TARGET     := network.a
+L_OBJS	     := $(SOCK) protocols.o $(join $(SUB_DIRS),$(SUB_DIRS:%=/%.o))
+
+M_OBJS	     :=
+
+ifeq ($(CONFIG_SYSCTL),y)
+ifeq ($(CONFIG_NET),y)
+L_OBJS += sysctl_net.o
+endif
+endif
+
+include $(TOPDIR)/Rules.make
diff -druN linux-noipsec/net/ipsec/Config.in linux/net/ipsec/Config.in
--- linux-noipsec/net/ipsec/Config.in	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/Config.in	Fri Sep 15 13:37:00 2000
@@ -0,0 +1,34 @@
+#
+# IPSEC configuration
+# Copyright (C) 1998, 1999  Richard Guy Briggs.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2 of the License, or (at your
+# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# RCSID $Id$
+
+comment 'IPSec options (FreeS/WAN)'
+
+bool '   IPSEC: IP-in-IP encapsulation (tunnel mode)' CONFIG_IPSEC_IPIP
+
+bool '   IPSEC: Authentication Header' CONFIG_IPSEC_AH
+if [ "$CONFIG_IPSEC_AH" = "y" -o "$CONFIG_IPSEC_ESP" = "y" ]; then
+  bool '      HMAC-MD5 authentication algorithm' CONFIG_IPSEC_AUTH_HMAC_MD5
+  bool '      HMAC-SHA1 authentication algorithm' CONFIG_IPSEC_AUTH_HMAC_SHA1
+fi
+
+bool '   IPSEC: Encapsulating Security Payload' CONFIG_IPSEC_ESP
+if [ "$CONFIG_IPSEC_ESP" = "y" ]; then
+  bool '      3DES encryption algorithm' CONFIG_IPSEC_ENC_3DES
+fi
+
+bool '   IPSEC: IP Compression' CONFIG_IPSEC_IPCOMP
+
+bool '   IPSEC Debugging Option' CONFIG_IPSEC_DEBUG
diff -druN linux-noipsec/net/ipsec/Makefile linux/net/ipsec/Makefile
--- linux-noipsec/net/ipsec/Makefile	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/Makefile	Fri Sep 29 21:51:57 2000
@@ -0,0 +1,242 @@
+# Makefile for KLIPS kernel code
+# Copyright (C) 1998, 1999  Richard Guy Briggs.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2 of the License, or (at your
+# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# RCSID $Id$
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+ifndef TOPDIR
+TOPDIR  := /usr/src/linux
+endif
+
+SUB_DIRS := 
+ALL_SUB_DIRS := libfreeswan zlib
+MOD_SUB_DIRS := 
+
+O_TARGET := ipsec.o
+O_OBJS := ipsec_init.o ipsec_xform.o ipsec_netlink.o ipsec_radij.o ipsec_tunnel.o ipsec_rcv.o sysctl_net_ipsec.o pfkey_v2.o pfkey_v2_parser.o
+
+OX_OBJS := radij.o
+M_OBJS := $(O_TARGET)
+
+override CFLAGS += -Ilibfreeswan
+
+ifeq ($(CONFIG_IPSEC_DEBUG),y)
+override CFLAGS += -g
+endif
+
+override CFLAGS += -Wall 
+#override CFLAGS += -Wconversion 
+#override CFLAGS += -Wmissing-prototypes 
+override CFLAGS += -Wpointer-arith 
+#override CFLAGS += -Wcast-qual 
+#override CFLAGS += -Wmissing-declarations 
+override CFLAGS += -Wstrict-prototypes
+#override CFLAGS += -pedantic
+#override CFLAGS += -O3
+#override CFLAGS += -W
+#override CFLAGS += -Wwrite-strings 
+override CFLAGS += -Wbad-function-cast 
+
+
+ifeq ($(CONFIG_IPSEC_ENC_DES),y)
+INCLUDE_DES = y
+endif
+
+ifeq ($(CONFIG_IPSEC_ENC_3DES),y)
+INCLUDE_DES = y
+endif
+
+ifeq ($(CONFIG_IPSEC_AUTH_HMAC_MD5),y)
+O_OBJS += ipsec_md5c.o
+endif
+
+ifeq ($(CONFIG_IPSEC_AUTH_HMAC_SHA1),y)
+O_OBJS += ipsec_sha1.o
+endif
+
+ifeq ($(CONFIG_IPSEC_IPCOMP),y)
+  O_OBJS += ipcomp.o zlib/zlib.a
+  SUB_DIRS += zlib
+  MOD_SUB_DIRS += zlib
+endif
+
+ifeq ($(INCLUDE_DES),y)
+O_OBJS += libdes/libdes.a
+endif
+
+O_OBJS += libfreeswan/libkernel.a
+
+ifeq ($(CONFIG_IPSEC),y)
+SUB_DIRS += libfreeswan
+else
+  ifeq ($(CONFIG_IPSEC),m)
+  override MOD_SUB_DIRS += libfreeswan
+  endif
+endif
+
+include $(TOPDIR)/Rules.make
+
+$(O_OBJS) $(OX_OBJS):  $(TOPDIR)/include/linux/config.h $(TOPDIR)/include/linux/autoconf.h
+
+libdes/libdes.a:
+	( cd libdes && \
+	if test " `arch | sed 's/^i[3456]/x/'`" = " x86" ; \
+	then $(MAKE) CC='$(CC)' CFLAG='$(CFLAGS)' TESTING='' x86-elf ; \
+	else $(MAKE) CC='$(CC)' CFLAG='$(CFLAGS)' libdes.a ; \
+	fi )
+
+libfreeswan/libkernel.a:
+	$(MAKE) -C libfreeswan
+
+zlib/zlib.a:
+	$(MAKE) -C zlib
+
+clean:
+	-rm -f *.o
+
+tags TAGS: *.c *.h libfreeswan/*.c libfreeswan/*.h
+	find . -name '*.[ch]' |xargs etags
+	find . -name '*.[ch]' |xargs ctags
+
+tar:
+		tar -cvf /dev/f1 .
+
+#
+# $Log$
+# Revision 1.30  2000/09/29 19:51:57  rgb
+# Moved klips/net/ipsec/ipcomp_* to zlib/* (Svenning).
+#
+# Revision 1.29  2000/09/15 11:37:01  rgb
+# Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+# IPCOMP zlib deflate code.
+#
+# Revision 1.28  2000/09/15 04:55:25  rgb
+# Clean up pfkey object inclusion into the default object.
+#
+# Revision 1.27  2000/09/12 03:20:47  rgb
+# Cleared out now unused pfkeyv2 switch.
+# Enabled sysctl.
+#
+# Revision 1.26  2000/09/08 19:12:55  rgb
+# Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+#
+# Revision 1.25  2000/06/16 03:09:16  rgb
+# Shut up cast lost warning due to changes in 2.4.0-test1.
+#
+# Revision 1.24  2000/03/16 06:40:48  rgb
+# Hardcode PF_KEYv2 support.
+#
+# Revision 1.23  2000/02/14 21:10:38  rgb
+# Added gcc debug flag when KLIPS_DEBUG is swtiched on.
+#
+# Revision 1.22  2000/01/21 09:44:29  rgb
+# Added compiler switches to be a lot more fussy.
+#
+# Revision 1.21  1999/11/25 23:35:20  rgb
+# Removed quotes to fix Alpha compile issues.
+#
+# Revision 1.20  1999/11/17 15:49:34  rgb
+# Changed all occurrences of ../../../lib in pathnames to libfreeswan,
+# which refers to the /usr/src/linux/net/ipsec/lib directory setup by the
+# klink target in the top-level Makefile; and libdeslite.o to
+# libdes/libdes.a.
+# Added SUB_DIRS := lib definition for the kernel libraries.
+#
+# Revision 1.19  1999/04/27 19:06:47  rgb
+# dd libs and dependancies to tags generation.
+#
+# Revision 1.18  1999/04/16 16:28:12  rgb
+# Minor bugfix to avoid including DES if only AH is used.
+#
+# Revision 1.17  1999/04/15 15:37:23  rgb
+# Forward check changes from POST1_00 branch.
+#
+# Revision 1.14.2.1  1999/03/30 17:29:17  rgb
+# Add support for pfkey.
+#
+# Revision 1.16  1999/04/11 00:28:56  henry
+# GPL boilerplate
+#
+# Revision 1.15  1999/04/06 04:54:25  rgb
+# Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+# patch shell fixes.
+#
+# Revision 1.14  1999/02/18 16:50:45  henry
+# update for new DES library
+#
+# Revision 1.13  1999/02/12 21:11:45  rgb
+# Prepare for newer LIBDES (patch from P.Onion).
+#
+# Revision 1.12  1999/01/26 02:05:08  rgb
+# Remove references to INET_GET_PROTOCOL.
+# Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+# Change from transform switch to algorithm switch.
+#
+# Revision 1.11  1999/01/22 06:16:09  rgb
+# Added algorithm switch code config option.
+#
+# Revision 1.10  1998/11/08 05:31:21  henry
+# be a little fussier
+#
+# Revision 1.9  1998/11/08 05:29:41  henry
+# revisions for new libdes handling
+#
+# Revision 1.8  1998/08/12 00:05:48  rgb
+# Added new xforms to Makefile (moved des-cbc to des-old).
+#
+# Revision 1.7  1998/07/27 21:48:47  rgb
+# Add libkernel.
+#
+# Revision 1.6  1998/07/14 15:50:47  rgb
+# Add dependancies on linux config files.
+#
+# Revision 1.5  1998/07/09 17:44:06  rgb
+# Added 'clean' and 'tags' targets.
+# Added TOPDIR macro.
+# Change module back from symbol exporting to not.
+#
+# Revision 1.3  1998/06/25 19:25:04  rgb
+# Rearrange to support static linking and objects with exported symbol
+# tables.
+#
+# Revision 1.1  1998/06/18 21:27:42  henry
+# move sources from klips/src to klips/net/ipsec, to keep stupid
+# kernel-build scripts happier in the presence of symlinks
+#
+# Revision 1.3  1998/04/15 23:18:43  rgb
+# Unfixed the ../../libdes fix to avoid messing up Henry's script.
+#
+# Revision 1.2  1998/04/14 17:50:47  rgb
+# Fixed to find the new location of libdes.
+#
+# Revision 1.1  1998/04/09 03:05:22  henry
+# sources moved up from linux/net/ipsec
+# modifications to centralize libdes code
+#
+# Revision 1.1.1.1  1998/04/08 05:35:02  henry
+# RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+#
+# Revision 0.5  1997/06/03 04:24:48  ji
+# Added ESP-3DES-MD5-96
+#
+# Revision 0.4  1997/01/15 01:32:59  ji
+# Added new transforms.
+#
+# Revision 0.3  1996/11/20 14:22:53  ji
+# *** empty log message ***
+#
diff -druN linux-noipsec/net/ipsec/defconfig linux/net/ipsec/defconfig
--- linux-noipsec/net/ipsec/defconfig	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/defconfig	Thu Nov 30 18:26:56 2000
@@ -0,0 +1,93 @@
+#
+# RCSID $Id$
+#
+
+#
+# FreeS/WAN IPSec implementation, KLIPS kernel config defaults
+#
+
+#
+# First, lets override stuff already set or not in the kernel config.
+#
+# We can't even think about leaving this off...
+CONFIG_INET=y
+
+#
+# This must be on for subnet protection.
+CONFIG_IP_FORWARD=y
+
+# Shut off IPSEC masquerading if it has been enabled, since it will 
+# break the compile.  IPPROTO_ESP and IPPROTO_AH were included in 
+# net/ipv4/ip_masq.c when they should have gone into include/linux/in.h.
+CONFIG_IP_MASQUERADE_IPSEC=n
+
+#
+# Next, lets set the recommended FreeS/WAN configuration.
+#
+
+# To config as static (preferred), 'y'.  To config as module, 'm'.
+CONFIG_IPSEC=y
+
+# To do tunnel mode IPSec, this must be enabled.
+CONFIG_IPSEC_IPIP=y
+
+# To enable authentication, say 'y'.   (Highly recommended)
+CONFIG_IPSEC_AH=y
+
+# Authentication algorithm(s):
+CONFIG_IPSEC_AUTH_HMAC_MD5=y
+CONFIG_IPSEC_AUTH_HMAC_SHA1=y
+
+# To enable encryption, say 'y'.   (Highly recommended)
+CONFIG_IPSEC_ESP=y
+
+# Encryption algorithm(s):
+CONFIG_IPSEC_ENC_3DES=y
+
+# IP Compression: new, probably still has minor bugs.
+CONFIG_IPSEC_IPCOMP=y
+
+# To enable userspace-switchable KLIPS debugging, say 'y'.
+CONFIG_IPSEC_DEBUG=y
+
+#
+#
+# $Log$
+# Revision 1.18  2000/11/30 17:26:56  rgb
+# Cleaned out unused options and enabled ipcomp by default.
+#
+# Revision 1.17  2000/09/15 11:37:01  rgb
+# Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+# IPCOMP zlib deflate code.
+#
+# Revision 1.16  2000/09/08 19:12:55  rgb
+# Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+#
+# Revision 1.15  2000/05/24 19:37:13  rgb
+# *** empty log message ***
+#
+# Revision 1.14  2000/05/11 21:14:57  henry
+# just commenting the FOOBAR=y lines out is not enough
+#
+# Revision 1.13  2000/05/10 20:17:58  rgb
+# Comment out netlink defaults, which are no longer needed.
+#
+# Revision 1.12  2000/05/10 19:13:38  rgb
+# Added configure option to shut off no eroute passthrough.
+#
+# Revision 1.11  2000/03/16 07:09:46  rgb
+# Hardcode PF_KEYv2 support.
+# Disable IPSEC_ICMP by default.
+# Remove DES config option from defaults file.
+#
+# Revision 1.10  2000/01/11 03:09:42  rgb
+# Added a default of 'y' to PF_KEYv2 keying I/F.
+#
+# Revision 1.9  1999/05/08 21:23:12  rgb
+# Added support for 2.2.x kernels.
+#
+# Revision 1.8  1999/04/06 04:54:25  rgb
+# Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+# patch shell fixes.
+#
+#
diff -druN linux-noipsec/net/ipsec/ipcomp.c linux/net/ipsec/ipcomp.c
--- linux-noipsec/net/ipsec/ipcomp.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipcomp.c	Sat Nov 25 04:48:49 2000
@@ -0,0 +1,725 @@
+/*
+ * IPCOMP zlib interface code.
+ * Copyright (C) 2000  Svenning Soerensen <svenning@post5.tele.dk>
+ * Copyright (C) 2000  Richard Guy Briggs <rgb@conscoop.ottawa.on.ca>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+char ipcomp_c_version[] = "RCSID $Id$";
+
+/* SSS */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#define __NO_VERSION__
+#include <linux/module.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h>
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/ip.h>
+#include <linux/skbuff.h>
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+
+#include <freeswan.h>
+#ifdef NET_21
+#include <net/dst.h>
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#define proto_priv cb
+#endif /* NET21 */
+#include <asm/checksum.h>
+#include <net/ip.h>
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_tunnel.h"
+#include "ipsec_rcv.h" /* sysctl_ipsec_inbound_policy_check */
+#include "ipcomp.h"
+#include "zlib/zlib.h"
+#include "zlib/zutil.h"
+
+#include <pfkeyv2.h> /* SADB_X_CALG_DEFLATE */
+
+#ifdef CONFIG_IPSEC_DEBUG
+int sysctl_ipsec_debug_ipcomp = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+static
+struct sk_buff *skb_copy_ipcomp(struct sk_buff *skb, int data_growth, int gfp_mask);
+
+static
+voidpf my_zcalloc(voidpf opaque, uInt items, uInt size)
+{
+	return (voidpf) kmalloc(items*size, GFP_ATOMIC);
+}
+
+static
+void my_zfree(voidpf opaque, voidpf address)
+{
+	kfree(address);
+}
+
+struct sk_buff *skb_compress(struct sk_buff *skb, struct tdb *tdb, unsigned int *flags)
+{
+	struct iphdr *iph;
+	unsigned int iphlen, pyldsz, cpyldsz;
+	unsigned char *buffer;
+	z_stream zs;
+	int zresult;
+	
+	KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+		    "klips_debug:skb_compress: .\n");
+
+	if(!skb) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "passed in NULL skb, returning ERROR.\n");
+		if (flags) *flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+
+	if(!tdb) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "passed in NULL tdb needed for cpi, returning ERROR.\n");
+		if (flags) *flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+
+	if (!flags) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "passed in NULL flags, returning ERROR.\n");
+#ifdef NET_21
+		kfree_skb(skb);
+#else /* NET_21 */
+		dev_kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+		return NULL;
+	}
+	
+#ifdef NET_21
+	iph = skb->nh.iph;
+#else /* NET_21 */
+	iph = skb->ip_hdr;
+#endif /* NET_21 */
+
+	switch (iph->protocol) {
+	case IPPROTO_COMP:
+	case IPPROTO_AH:
+	case IPPROTO_ESP:
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "skipping compression of packet with ip protocol %d.\n",
+			    iph->protocol);
+		*flags |= IPCOMP_UNCOMPRESSABLE;
+		return skb;
+	}
+	
+	/* Don't compress packets already fragmented */
+	if (ntohs(iph->frag_off) & ~0x4000) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "skipping compression of fragmented packet.\n");
+		*flags |= IPCOMP_UNCOMPRESSABLE;
+		return skb;
+	}
+	
+	iphlen = iph->ihl << 2;
+	pyldsz = ntohs(iph->tot_len) - iphlen;
+
+	/* Don't compress less than 90 bytes (rfc 2394) */
+	if (pyldsz < 90) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "skipping compression of tiny packet, len=%d.\n",
+			    pyldsz);
+		*flags |= IPCOMP_UNCOMPRESSABLE;
+		return skb;
+	}
+	
+	/* Adaptive decision */
+	if (tdb->tdb_comp_adapt_skip) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_compress: "
+			    "skipping compression: tdb_comp_adapt_skip=%d.\n",
+			    tdb->tdb_comp_adapt_skip);
+		tdb->tdb_comp_adapt_skip--;
+		*flags |= IPCOMP_UNCOMPRESSABLE;
+		return skb;
+	}
+
+	zs.zalloc = my_zcalloc;
+	zs.zfree = my_zfree;
+	zs.opaque = 0;
+	
+	/* We want to use deflateInit2 because we don't want the adler
+	   header. */
+	zresult = deflateInit2(&zs, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -11,
+			       DEF_MEM_LEVEL,  Z_DEFAULT_STRATEGY);
+	if (zresult != Z_OK) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_compress: "
+			    "deflateInit2() returned error %d (%s), "
+			    "skipping compression.\n",
+			    zresult,
+			    zs.msg ? zs.msg : zError(zresult));
+		*flags |= IPCOMP_COMPRESSIONERROR;
+		return skb;
+	}
+	
+
+	/* Max output size. Result should be max this size.
+	 * Implementation specific tweak:
+	 * If it's not at least 32 bytes and 6.25% smaller than
+	 * the original packet, it's probably not worth wasting
+	 * the receiver's CPU cycles decompressing it.
+	 * Your mileage may vary.
+	 */
+	cpyldsz = pyldsz - sizeof(struct ipcomphdr) - (pyldsz <= 512 ? 32 : pyldsz >> 4);
+
+	buffer = kmalloc(cpyldsz, GFP_ATOMIC);
+	if (!buffer) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_compress: "
+			    "unable to kmalloc(%d, GFP_ATOMIC), "
+			    "skipping compression.\n",
+			    cpyldsz);
+		*flags |= IPCOMP_COMPRESSIONERROR;
+		deflateEnd(&zs);
+		return skb;
+	}
+	
+#ifdef CONFIG_IPSEC_DEBUG
+	if(sysctl_ipsec_debug_ipcomp && sysctl_ipsec_debug_verbose) {
+		__u8 *c;
+		int i;
+
+		c = (__u8*)iph + iphlen;
+		for(i = 0; i < pyldsz; i++, c++) {
+			if(!(i % 16)) {
+				printk(KERN_INFO "skb_compress:   before:");
+			}
+			printk("%02x ", *c);
+			if(!((i + 1) % 16)) {
+				printk("\n");
+			}
+		}
+		if(i % 16) {
+			printk("\n");
+		}
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	zs.next_in = (char *) iph + iphlen; /* start of payload */
+	zs.avail_in = pyldsz;
+	zs.next_out = buffer;     /* start of compressed payload */
+	zs.avail_out = cpyldsz;
+	
+	/* Finish compression in one step */
+	zresult = deflate(&zs, Z_FINISH);
+
+	/* Free all dynamically allocated buffers */
+	deflateEnd(&zs);
+	if (zresult != Z_STREAM_END) {
+		*flags |= IPCOMP_UNCOMPRESSABLE;
+		kfree(buffer);
+
+		/* Adjust adaptive counters */
+		if (++(tdb->tdb_comp_adapt_tries) == IPCOMP_ADAPT_INITIAL_TRIES) {
+			KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+				    "klips_debug:skb_compress: "
+				    "first %d packets didn't compress, "
+				    "skipping next %d\n",
+				    IPCOMP_ADAPT_INITIAL_TRIES,
+				    IPCOMP_ADAPT_INITIAL_SKIP);
+			tdb->tdb_comp_adapt_skip = IPCOMP_ADAPT_INITIAL_SKIP;
+		}
+		else if (tdb->tdb_comp_adapt_tries == IPCOMP_ADAPT_INITIAL_TRIES + IPCOMP_ADAPT_SUBSEQ_TRIES) {
+			KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+				    "klips_debug:skb_compress: "
+				    "next %d packets didn't compress, "
+				    "skipping next %d\n",
+				    IPCOMP_ADAPT_SUBSEQ_TRIES,
+				    IPCOMP_ADAPT_SUBSEQ_SKIP);
+			tdb->tdb_comp_adapt_skip = IPCOMP_ADAPT_SUBSEQ_SKIP;
+			tdb->tdb_comp_adapt_tries = IPCOMP_ADAPT_INITIAL_TRIES;
+		}
+
+		return skb;
+	}
+	
+	/* resulting compressed size */
+	cpyldsz -= zs.avail_out;
+	
+	/* Insert IPCOMP header */
+	((struct ipcomphdr*) ((char*) iph + iphlen))->ipcomp_nh = iph->protocol;
+	((struct ipcomphdr*) ((char*) iph + iphlen))->ipcomp_flags = 0;
+	/* use the bottom 16 bits of the spi for the cpi.  The top 16 bits are
+	   for internal reference only. */
+	((struct ipcomphdr*) (((char*)iph) + iphlen))->ipcomp_cpi = htons((__u16)(ntohl(tdb->tdb_said.spi) & 0x0000ffff));
+	KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+		    "klips_debug:skb_compress: "
+		    "spi=%08x, spi&0xffff=%04x, cpi=%04x, payload size: raw=%d, comp=%d.\n",
+		    ntohl(tdb->tdb_said.spi),
+		    ntohl(tdb->tdb_said.spi) & 0x0000ffff,
+		    ntohs(((struct ipcomphdr*)(((char*)iph)+iphlen))->ipcomp_cpi),
+		    pyldsz,
+		    cpyldsz);
+	
+	/* Update IP header */
+	iph->protocol = IPPROTO_COMP;
+	iph->tot_len = htons(iphlen + sizeof(struct ipcomphdr) + cpyldsz);
+#if 1 /* XXX checksum is done by ipsec_tunnel ? */
+	iph->check = 0;
+	iph->check = ip_fast_csum((char *) iph, iph->ihl);
+#endif
+	
+	/* Copy compressed payload */
+	memcpy((char *) iph + iphlen + sizeof(struct ipcomphdr),
+	       buffer,
+	       cpyldsz);
+	kfree(buffer);
+	
+	/* Update skb length/tail by "unputting" the shrinkage */
+	skb_put(skb,
+		cpyldsz + sizeof(struct ipcomphdr) - pyldsz);
+	
+#ifdef CONFIG_IPSEC_DEBUG
+	if(sysctl_ipsec_debug_ipcomp && sysctl_ipsec_debug_verbose) {
+		__u8 *c;
+		int i;
+		
+		c = (__u8*)iph + iphlen + sizeof(struct ipcomphdr);
+		for(i = 0; i < cpyldsz; i++, c++) {
+			if(!(i % 16)) {
+				printk(KERN_INFO "skb_compress:   result:");
+			}
+			printk("%02x ", *c);
+			if(!((i + 1) % 16)) {
+				printk("\n");
+			}
+		}
+		if(i % 16) {
+			printk("\n");
+		}
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+	
+	tdb->tdb_comp_adapt_skip = 0;
+	tdb->tdb_comp_adapt_tries = 0;
+	
+	return skb;
+}
+
+struct sk_buff *skb_decompress(struct sk_buff *skb, struct tdb *tdb, unsigned int *flags)
+{
+	struct sk_buff *nskb = NULL;
+
+	/* original ip header */
+	struct iphdr *oiph, *iph;
+	unsigned int iphlen, pyldsz, cpyldsz;
+	z_stream zs;
+	int zresult;
+
+	KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+		    "klips_debug:skb_decompress: .\n");
+
+	if(!skb) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "passed in NULL skb, returning ERROR.\n");
+		if (flags) *flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+
+	if(!tdb && sysctl_ipsec_inbound_policy_check) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "passed in NULL tdb needed for comp alg, returning ERROR.\n");
+		if (flags) *flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+
+	if (!flags) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "passed in NULL flags, returning ERROR.\n");
+#ifdef NET_21
+		kfree_skb(skb);
+#else /* NET_21 */
+		dev_kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+		return NULL;
+	}
+	
+#ifdef NET_21
+	oiph = skb->nh.iph;
+#else /* NET_21 */
+	oiph = skb->ip_hdr;
+#endif /* NET_21 */
+	
+	iphlen = oiph->ihl << 2;
+	
+	if (oiph->protocol != IPPROTO_COMP) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "called with non-IPCOMP packet (protocol=%d),"
+			    "skipping decompression.\n",
+			    oiph->protocol);
+		*flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+	
+	if ( (((struct ipcomphdr*)((char*) oiph + iphlen))->ipcomp_flags != 0)
+	     || ((((struct ipcomphdr*) ((char*) oiph + iphlen))->ipcomp_cpi
+		!= htons(SADB_X_CALG_DEFLATE))
+		 && sysctl_ipsec_inbound_policy_check
+		 && (!tdb || (tdb && (tdb->tdb_encalg != SADB_X_CALG_DEFLATE)))) ) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "called with incompatible IPCOMP packet (flags=%d, "
+			    "cpi=%d), tdb-compalg=%d, skipping decompression.\n",
+			    ntohs(((struct ipcomphdr*) ((char*) oiph + iphlen))->ipcomp_flags),
+			    ntohs(((struct ipcomphdr*) ((char*) oiph + iphlen))->ipcomp_cpi),
+			    tdb ? tdb->tdb_encalg : 0);
+		*flags |= IPCOMP_PARMERROR;
+		
+		return skb;
+	}
+	
+	if (ntohs(oiph->frag_off) & ~0x4000) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "called with fragmented IPCOMP packet, "
+			    "skipping decompression.\n");
+		*flags |= IPCOMP_PARMERROR;
+		return skb;
+	}
+	
+	/* original compressed payload size */
+	cpyldsz = ntohs(oiph->tot_len) - iphlen - sizeof(struct ipcomphdr);
+
+	zs.zalloc = my_zcalloc;
+	zs.zfree = my_zfree;
+	zs.opaque = 0;
+	
+	zs.next_in = (char *) oiph + iphlen + sizeof(struct ipcomphdr);
+	zs.avail_in = cpyldsz;
+	
+	/* Maybe we should be a bit conservative about memory
+	   requirements and use inflateInit2 */
+	/* Beware, that this might make us unable to decompress packets
+	   from other implementations - HINT: check PGPnet source code */
+	/* We want to use inflateInit2 because we don't want the adler
+	   header. */
+	zresult = inflateInit2(&zs, -15); 
+	if (zresult != Z_OK) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "inflateInit2() returned error %d (%s), "
+			    "skipping decompression.\n",
+			    zresult,
+			    zs.msg ? zs.msg : zError(zresult));
+		*flags |= IPCOMP_DECOMPRESSIONERROR;
+
+		return skb;
+	}
+	
+	/* We have no way of knowing the exact length of the resulting
+	   decompressed output before we have actually done the decompression.
+	   For now, we guess that the packet will not be bigger than the
+	   attached ipsec device's mtu or 16260, whichever is biggest.
+	   This may be wrong, since the sender's mtu may be bigger yet.
+	   XXX This must be dealt with later XXX
+	*/
+	
+	/* max payload size */
+	pyldsz = skb->dev ? (skb->dev->mtu < 16260 ? 16260 : skb->dev->mtu)
+			  : (65520 - iphlen);
+	KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+		    "klips_debug:skb_decompress: "
+		    "max payload size: %d\n", pyldsz);
+	
+	while (pyldsz > (cpyldsz + sizeof(struct ipcomphdr)) && 
+	       (nskb = skb_copy_ipcomp(skb,
+				       pyldsz - cpyldsz - sizeof(struct ipcomphdr),
+				       GFP_ATOMIC)) == NULL) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "unable to skb_copy_ipcomp(skb, %d, GFP_ATOMIC), "
+			    "trying with less payload size.\n",
+			    pyldsz - cpyldsz - sizeof(struct ipcomphdr));
+		pyldsz >>=1;
+	}
+	
+	if (!nskb) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "unable to allocate memory, dropping packet.\n");
+		*flags |= IPCOMP_DECOMPRESSIONERROR;
+		inflateEnd(&zs);
+
+		return skb;
+	}
+	
+#ifdef CONFIG_IPSEC_DEBUG
+	if(sysctl_ipsec_debug_ipcomp && sysctl_ipsec_debug_verbose) {
+		__u8 *c;
+		int i;
+		
+		c = (__u8*)oiph + iphlen + sizeof(struct ipcomphdr);
+		for(i = 0; i < cpyldsz; i++, c++) {
+			if(!(i % 16)) {
+				printk(KERN_INFO "skb_decompress:   before:");
+			}
+			printk("%02x ", *c);
+			if(!((i + 1) % 16)) {
+				printk("\n");
+			}
+		}
+		if(i % 16) {
+			printk("\n");
+		}
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef NET_21
+	iph = nskb->nh.iph;
+#else /* NET_21 */
+	iph = nskb->ip_hdr;
+#endif /* NET_21 */
+	zs.next_out = (char *)iph + iphlen;
+	zs.avail_out = pyldsz;
+
+	zresult = inflate(&zs, Z_SYNC_FLUSH);
+
+	/* work around a bug in zlib, which sometimes wants to taste an extra
+	 * byte when being used in the (undocumented) raw deflate mode.
+	 */
+	if (zresult == Z_OK && !zs.avail_in && zs.avail_out) {
+		__u8 zerostuff = 0;
+		
+		zs.next_in = &zerostuff;
+		zs.avail_in = 1;
+		zresult = inflate(&zs, Z_FINISH);
+	}
+
+	inflateEnd(&zs);
+	if (zresult != Z_STREAM_END) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_error:skb_decompress: "
+			    "inflate() returned error %d (%s), "
+			    "skipping decompression.\n",
+			    zresult,
+			    zs.msg ? zs.msg : zError(zresult));
+		*flags |= IPCOMP_DECOMPRESSIONERROR;
+#ifdef NET_21
+		kfree_skb(nskb);
+#else /* NET_21 */
+		dev_kfree_skb(nskb, FREE_WRITE);
+#endif /* NET_21 */
+
+		return skb;
+	}
+	
+	/* Update IP header */
+	/* resulting decompressed size */
+	pyldsz -= zs.avail_out;
+	iph->tot_len = htons(iphlen + pyldsz);
+	iph->protocol = ((struct ipcomphdr*) ((char*) oiph + iphlen))->ipcomp_nh;
+	KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+		    "klips_debug:skb_decompress: "
+		    "spi=%08x, spi&0xffff=%04x, cpi=%04x, payload size: comp=%d, raw=%d, nh=%d.\n",
+		    tdb ? ntohl(tdb->tdb_said.spi) : 0,
+		    tdb ? ntohl(tdb->tdb_said.spi) & 0x0000ffff : 0,
+		    ntohs(((struct ipcomphdr*)(((char*)oiph)+iphlen))->ipcomp_cpi),
+		    cpyldsz,
+		    pyldsz,
+		    iph->protocol);
+	
+#if 1 /* XXX checksum is done by ipsec_rcv ? */
+	iph->check = 0;
+	iph->check = ip_fast_csum((char*) iph, iph->ihl);
+#endif
+	
+	/* Update skb length/tail by "unputting" the unused data area */
+	skb_put(nskb, -zs.avail_out);
+	
+#ifdef NET_21
+	kfree_skb(skb);
+#else /* NET_21 */
+	dev_kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+	
+	if (iph->protocol == IPPROTO_COMP)
+	{
+#ifdef CONFIG_IPSEC_DEBUG
+		if(sysctl_ipsec_debug_ipcomp)
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_decompress: "
+			    "Eh? inner packet is also compressed, dropping.\n");
+#endif /* CONFIG_IPSEC_DEBUG */
+		
+#ifdef NET_21
+		kfree_skb(nskb);
+#else /* NET_21 */
+		dev_kfree_skb(nskb, FREE_WRITE);
+#endif /* NET_21 */
+		return NULL;
+	}
+	
+#ifdef CONFIG_IPSEC_DEBUG
+	if(sysctl_ipsec_debug_ipcomp && sysctl_ipsec_debug_verbose) {
+		__u8 *c;
+		int i;
+		
+		c = (__u8*)iph + iphlen;
+		for(i = 0; i < pyldsz; i++, c++) {
+			if(!(i % 16)) {
+				printk(KERN_INFO "skb_decompress:   result:");
+			}
+			printk("%02x ", *c);
+			if(!((i + 1) % 16)) {
+				printk("\n");
+			}
+		}
+		if(i % 16) {
+			printk("\n");
+		}
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+	
+	return nskb;
+}
+
+
+/* this is derived from skb_copy() in linux 2.2.14 */
+/* May be incompatible with other kernel versions!! */
+static
+struct sk_buff *skb_copy_ipcomp(struct sk_buff *skb, int data_growth, int gfp_mask)
+{
+        struct sk_buff *n;
+	struct iphdr *iph;
+        unsigned long offset;
+        unsigned int iphlen;
+	
+	if(!skb) {
+		KLIPS_PRINT(sysctl_ipsec_debug_ipcomp,
+			    "klips_debug:skb_copy_ipcomp: "
+			    "passed in NULL skb, returning NULL.\n");
+		return NULL;
+	}
+
+        /*
+         *      Allocate the copy buffer
+         */
+	
+#ifdef NET_21
+	iph = skb->nh.iph;
+#else /* NET_21 */
+	iph = skb->ip_hdr;
+#endif /* NET_21 */
+        if (!iph) return NULL;
+        iphlen = iph->ihl << 2;
+	
+        n=alloc_skb(skb->end - skb->head + data_growth, gfp_mask);
+        if(n==NULL)
+                return NULL;
+	
+        /*
+         *      Shift between the two data areas in bytes
+         */
+	
+        offset=n->head-skb->head;
+
+        /* Set the data pointer */
+        skb_reserve(n,skb->data-skb->head);
+        /* Set the tail pointer and length */
+        skb_put(n,skb->len+data_growth);
+        /* Copy the bytes up to and including the ip header */
+        memcpy(n->head,
+	       skb->head,
+	       ((char *)iph - (char *)skb->head) + iphlen);
+        n->list=NULL;
+	n->next=NULL;
+	n->prev=NULL;
+        n->sk=NULL;
+        n->dev=skb->dev;
+	if (skb->h.raw)
+		n->h.raw=skb->h.raw+offset;
+	else
+		n->h.raw=NULL;
+        n->protocol=skb->protocol;
+#ifdef NET_21
+        n->csum = 0;
+        n->priority=skb->priority;
+        n->dst=dst_clone(skb->dst);
+        n->nh.raw=skb->nh.raw+offset;
+        n->is_clone=0;
+        atomic_set(&n->users, 1);
+        n->destructor = NULL;
+        n->security=skb->security;
+        memcpy(n->cb, skb->cb, sizeof(skb->cb));
+#ifdef CONFIG_IP_FIREWALL
+        n->fwmark = skb->fwmark;
+#endif
+#else /* NET_21 */
+	n->link3=NULL;
+	n->when=skb->when;
+	n->ip_hdr=(struct iphdr *)(((char *)skb->ip_hdr)+offset);
+	n->saddr=skb->saddr;
+	n->daddr=skb->daddr;
+	n->raddr=skb->raddr;
+	n->seq=skb->seq;
+	n->end_seq=skb->end_seq;
+	n->ack_seq=skb->ack_seq;
+	n->acked=skb->acked;
+	n->free=1;
+	n->arp=skb->arp;
+	n->tries=0;
+	n->lock=0;
+	n->users=0;
+	memcpy(n->proto_priv, skb->proto_priv, sizeof(skb->proto_priv));
+#endif /* NET_21 */
+	if (skb->mac.raw)
+		n->mac.raw=skb->mac.raw+offset;
+	else
+		n->mac.raw=NULL;
+        n->used=skb->used;
+        n->pkt_type=skb->pkt_type;
+	n->pkt_bridged=skb->pkt_bridged;
+	n->ip_summed=0;
+        n->stamp=skb->stamp;
+#if defined(CONFIG_SHAPER) || defined(CONFIG_SHAPER_MODULE)
+        n->shapelatency=skb->shapelatency;       /* Latency on frame */
+        n->shapeclock=skb->shapeclock;           /* Time it should go out */
+        n->shapelen=skb->shapelen;               /* Frame length in clocks */
+        n->shapestamp=skb->shapestamp;           /* Stamp for shaper    */
+        n->shapepend=skb->shapepend;             /* Pending */
+#endif
+#ifdef CONFIG_HIPPI
+        n->private.ifield=skb->private.ifield;
+#endif
+
+        return n;
+}
diff -druN linux-noipsec/net/ipsec/ipcomp.h linux/net/ipsec/ipcomp.h
--- linux-noipsec/net/ipsec/ipcomp.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipcomp.h	Mon Nov  6 05:30:40 2000
@@ -0,0 +1,59 @@
+/*
+ * IPCOMP zlib interface code.
+ * Copyright (C) 2000  Svenning Soerensen <svenning@post5.tele.dk>
+ * Copyright (C) 2000  Richard Guy Briggs <rgb@conscoop.ottawa.on.ca>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+
+ RCSID $Id$
+
+ */
+
+/* SSS */
+
+#ifndef _IPCOMP_H
+#define _IPCOMP_H
+
+/* Prefix all global deflate symbols with "ipcomp_" to avoid collisions with ppp_deflate & ext2comp */
+#define IPCOMP_PREFIX
+
+#ifndef IPPROTO_COMP
+#define IPPROTO_COMP 108
+#endif /* IPPROTO_COMP */
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int sysctl_ipsec_debug_ipcomp;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+struct ipcomphdr {			/* IPCOMP header */
+    __u8    ipcomp_nh;		/* Next header (protocol) */
+    __u8    ipcomp_flags;	/* Reserved, must be 0 */
+    __u16   ipcomp_cpi;		/* Compression Parameter Index */
+};
+
+extern struct inet_protocol comp_protocol;
+extern int sysctl_ipsec_debug_ipcomp;
+
+#define IPCOMP_UNCOMPRESSABLE     0x000000001
+#define IPCOMP_COMPRESSIONERROR   0x000000002
+#define IPCOMP_PARMERROR          0x000000004
+#define IPCOMP_DECOMPRESSIONERROR 0x000000008
+
+#define IPCOMP_ADAPT_INITIAL_TRIES	8
+#define IPCOMP_ADAPT_INITIAL_SKIP	4
+#define IPCOMP_ADAPT_SUBSEQ_TRIES	2
+#define IPCOMP_ADAPT_SUBSEQ_SKIP	8
+
+/* Function prototypes */
+struct sk_buff *skb_compress(struct sk_buff *skb, struct tdb *tdb, unsigned int *flags);
+struct sk_buff *skb_decompress(struct sk_buff *skb, struct tdb *tdb, unsigned int *flags);
+
+#endif /* _IPCOMP_H */
diff -druN linux-noipsec/net/ipsec/ipsec_ah.h linux/net/ipsec/ipsec_ah.h
--- linux-noipsec/net/ipsec/ipsec_ah.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_ah.h	Tue Sep 12 05:21:20 2000
@@ -0,0 +1,232 @@
+/*
+ * Authentication Header declarations
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include "ipsec_md5h.h"
+#include "ipsec_sha1.h"
+
+#ifndef IPPROTO_AH
+#define IPPROTO_AH 51
+#endif /* IPPROTO_AH */
+
+#define AH_FLENGTH		12		/* size of fixed part */
+#define AHMD5_KMAX		64		/* MD5 max 512 bits key */
+#define AHMD5_AMAX		12		/* MD5 96 bits of authenticator */
+
+#define AHMD596_KLEN		16		/* MD5 128 bits key */
+#define AHSHA196_KLEN		20		/* SHA1 160 bits key */
+
+#define AHMD596_ALEN    	16		/* MD5 128 bits authentication length */
+#define AHSHA196_ALEN		20		/* SHA1 160 bits authentication length */
+
+#define AHMD596_BLKLEN  	64		/* MD5 block length */
+#define AHSHA196_BLKLEN 	64		/* SHA1 block length */
+
+#define AH_AMAX         	AHSHA196_ALEN   /* keep up to date! */
+#define AHHMAC_HASHLEN  	12              /* authenticator length of 96bits */
+#define AHHMAC_RPLLEN   	4               /* 32 bit replay counter */
+
+#define DB_AH_PKTRX		0x0001
+#define DB_AH_PKTRX2		0x0002
+#define DB_AH_DMP		0x0004
+#define DB_AH_TDB		0x0010
+#define DB_AH_XF		0x0020
+#define DB_AH_INAU		0x0040
+#define DB_AH_REPLAY		0x0100
+
+struct ahmd5_xdata			/* transform table data */
+{
+	__u16	amx_klen;		/* Key material length */
+	__u16	amx_alen;		/* authenticator length */
+	__u8	amx_key[AHMD5_KMAX];	/* Key material */
+};
+
+struct ahhmacmd5_edata			/* struct for netlink interface */
+{
+	__u16	ame_klen;		/* Key material length */
+	__u16	ame_alen;		/* authenticator length */
+	__u8	ame_replayp;		/* replay protection ? */
+	__u8	ame_ooowin;		/* out-of-order window size */
+	__u16	ame_x0;			/* filler */
+	__u8	ame_key[AHMD596_KLEN];	/* Key material */
+};
+	
+struct ahhmacsha1_edata			/* struct for netlink interface */
+{
+	__u16	ame_klen;		/* Key material length */
+	__u16	ame_alen;		/* authenticator length */
+	__u8	ame_replayp;		/* replay protection ? */
+	__u8	ame_ooowin;		/* out-of-order window size */
+	__u16	ame_x0;			/* filler */
+	__u8	ame_key[AHSHA196_KLEN];	/* Key material */
+};
+	
+#ifdef __KERNEL__
+
+/* General HMAC algorithm is described in RFC 2104 */
+
+#define		HMAC_IPAD	0x36
+#define		HMAC_OPAD	0x5C
+
+struct ahhmacmd5_xdata			/* struct for xform table */
+{
+	__u16	amx_alen;		/* length of authenticator, octets  */
+	__u8	amx_replayp;		/* 1 if replay prevention active */
+	__u8	amx_ooowin;		/* out-of-order window size */
+	__u64	amx_bitmap;		/* this&next should be 8 bytes each */
+	__u32	amx_lastseq;		/* or just seq if sending!! */
+	MD5_CTX	amx_octx;		/* context after H(K XOR opad) */
+	MD5_CTX amx_ictx;		/* context after H(K XOR ipad) */
+};
+
+struct ahhmacsha1_xdata			/* struct for xform table */
+{
+	__u16	amx_alen;		/* length of authenticator, octets  */
+	__u8	amx_replayp;		/* 1 if replay prevention active */
+	__u8	amx_ooowin;		/* out-of-order window size */
+	__u64	amx_bitmap;		/* this&next should be 8 bytes each */
+	__u32	amx_lastseq;		/* or just seq if sending!! */
+	SHA1_CTX amx_octx;		/* context after H(K XOR opad) */
+	SHA1_CTX amx_ictx;		/* context after H(K XOR ipad) */
+};
+
+struct md5_ctx {
+	MD5_CTX ictx;		/* context after H(K XOR ipad) */
+	MD5_CTX	octx;		/* context after H(K XOR opad) */
+};
+
+struct sha1_ctx {
+	SHA1_CTX ictx;		/* context after H(K XOR ipad) */
+	SHA1_CTX octx;		/* context after H(K XOR opad) */
+};
+
+extern struct inet_protocol ah_protocol;
+
+struct options;
+
+extern int 
+ah_rcv(struct sk_buff *skb,
+       struct device *dev,
+       struct options *opt, 
+       __u32 daddr,
+       unsigned short len,
+       __u32 saddr,
+       int redo,
+       struct inet_protocol *protocol);
+
+struct ah				/* Generic AH header */
+{
+	__u8	ah_nh;			/* Next header (protocol) */
+	__u8	ah_hl;			/* AH length, in 32-bit words */
+	__u16	ah_rv;			/* reserved, must be 0 */
+	__u32	ah_spi;			/* Security Parameters Index */
+        __u32   ah_rpl;                 /* Replay prevention */
+	__u8	ah_data[AHHMAC_HASHLEN];/* Authentication hash */
+};
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_ah;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* __KERNEL__ */
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define AHPRINTKEYS_
+#endif /* CONFIG_IPSEC_DEBUG */
+
+/*
+ * $Log$
+ * Revision 1.12  2000/09/12 03:21:20  rgb
+ * Cleared out unused htonq.
+ *
+ * Revision 1.11  2000/09/08 19:12:55  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.10  2000/01/21 06:13:10  rgb
+ * Tidied up spacing.
+ * Added macros for HMAC padding magic numbers.(kravietz)
+ *
+ * Revision 1.9  1999/12/07 18:16:23  rgb
+ * Fixed comments at end of #endif lines.
+ *
+ * Revision 1.8  1999/04/11 00:28:56  henry
+ * GPL boilerplate
+ *
+ * Revision 1.7  1999/04/06 04:54:25  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.6  1999/01/26 02:06:01  rgb
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ *
+ * Revision 1.5  1999/01/22 06:17:49  rgb
+ * Updated macro comments.
+ * Added context types to support algorithm switch code.
+ * 64-bit clean-up -- converting 'u long long' to __u64.
+ *
+ * Revision 1.4  1998/07/14 15:54:56  rgb
+ * Add #ifdef __KERNEL__ to protect kernel-only structures.
+ *
+ * Revision 1.3  1998/06/30 18:05:16  rgb
+ * Comment out references to htonq.
+ *
+ * Revision 1.2  1998/06/25 19:33:46  rgb
+ * Add prototype for protocol receive function.
+ * Rearrange for more logical layout.
+ *
+ * Revision 1.1  1998/06/18 21:27:43  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.4  1998/05/18 22:28:43  rgb
+ * Disable key printing facilities from /proc/net/ipsec_*.
+ *
+ * Revision 1.3  1998/04/21 21:29:07  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:17  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:05:55  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Added definitions for new AH transforms.
+ *
+ * Revision 0.3  1996/11/20 14:35:48  ji
+ * Minor Cleanup.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_encap.h linux/net/ipsec/ipsec_encap.h
--- linux-noipsec/net/ipsec/ipsec_encap.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_encap.h	Fri Sep  8 21:12:56 2000
@@ -0,0 +1,168 @@
+/*
+ * declarations relevant to encapsulation-like operations
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#define SENT_IP4	0x0008		/* data is two struct in_addr */
+
+#define SEN_HDRLEN	(2*sizeof(__u8)+sizeof(__u16))
+
+#define SEN_IP4_SRCOFF	(0)
+#define SEN_IP4_DSTOFF (sizeof (struct in_addr))
+#define SEN_IP4_OPTOFF	(2 * sizeof (struct in_addr))
+
+#define SEN_IP4_LEN	(SENT_HDRLEN + SENT_IP4_OPTOFF)
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define DB_ER_PROCFS	0x0001
+#define DB_SP_PROCFS	0x0001
+#endif /* CONFIG_IPSEC_DEBUG */
+
+struct sockaddr_encap
+{
+	__u8	sen_len;		/* length */
+	__u8	sen_family;		/* AF_ENCAP */
+	__u16	sen_type;		/* see SENT_* */
+	union
+	{
+		struct			/* SENT_IP4 */
+		{
+			struct in_addr Src;
+			struct in_addr Dst;
+		} Sip4;
+	} Sen;
+};
+
+#define sen_ip_src	Sen.Sip4.Src
+#define sen_ip_dst	Sen.Sip4.Dst
+
+#ifndef AF_ENCAP
+#define AF_ENCAP 26
+#endif /* AF_ENCAP */
+
+/*
+ * The "type" is really part of the address as far as the routing
+ * system is concerned. By using only one bit in the type field
+ * for each type, we sort-of make sure that different types of
+ * encapsulation addresses won't be matched against the wrong type.
+ */
+
+#ifdef __KERNEL__
+/*
+ * An entry in the radix tree 
+ */
+
+struct rjtentry
+{
+	struct	radij_node rd_nodes[2];	/* tree glue, and other values */
+#define	rd_key(r)	((struct sockaddr_encap *)((r)->rd_nodes->rj_key))
+#define	rd_mask(r)	((struct sockaddr_encap *)((r)->rd_nodes->rj_mask))
+	short	rd_flags;
+	short	rd_count;
+};
+
+/*
+ * An encapsulation route consists of a pointer to a 
+ * radix tree entry and a SAID (a destination_address/SPI/protocol triple).
+ */
+
+struct
+eroute
+{
+	struct rjtentry er_rjt;
+	struct sa_id er_said;
+	struct sockaddr_encap er_eaddr;
+	struct sockaddr_encap er_emask;
+};
+
+#define er_dst er_said.dst
+#define er_spi er_said.spi
+#define er_proto er_said.proto
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_eroute;
+extern int debug_spi;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef NETDEV_23
+#define device net_device
+#define ipsec_dev_get __dev_get_by_name
+#else
+#define ipsec_dev_get dev_get
+#endif /* NETDEV_23 */
+#endif /* __KERNEL__ */
+
+/*
+ * $Log$
+ * Revision 1.11  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.10  2000/03/22 16:15:36  rgb
+ * Fixed renaming of dev_get (MB).
+ *
+ * Revision 1.9  2000/01/21 06:13:26  rgb
+ * Added a macro for AF_ENCAP
+ *
+ * Revision 1.8  1999/12/31 14:56:55  rgb
+ * MB fix for 2.3 dev-use-count.
+ *
+ * Revision 1.7  1999/11/18 04:09:18  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.6  1999/09/24 00:34:13  rgb
+ * Add Marc Boucher's support for 2.3.xx+.
+ *
+ * Revision 1.5  1999/04/11 00:28:57  henry
+ * GPL boilerplate
+ *
+ * Revision 1.4  1999/04/06 04:54:25  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.3  1998/10/19 14:44:28  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.2  1998/07/14 18:19:33  rgb
+ * Added #ifdef __KERNEL__ directives to restrict scope of header.
+ *
+ * Revision 1.1  1998/06/18 21:27:44  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.2  1998/04/21 21:29:10  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.1  1998/04/09 03:05:58  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Minor cosmetic changes.
+ *
+ * Revision 0.3  1996/11/20 14:35:48  ji
+ * Minor Cleanup.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_esp.h linux/net/ipsec/ipsec_esp.h
--- linux-noipsec/net/ipsec/ipsec_esp.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_esp.h	Fri Sep  8 21:12:56 2000
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include "ipsec_md5h.h"
+#include "ipsec_sha1.h"
+
+#ifndef IPPROTO_ESP
+#define IPPROTO_ESP 50
+#endif /* IPPROTO_ESP */
+
+#define EMT_ESPDESCBC_ULEN	20	/* coming from user mode */
+#define EMT_ESPDES_KMAX		64	/* 512 bit secret key enough? */
+#define EMT_ESPDES_KEY_SZ	8	/* 56 bit secret key with parity = 64 bits */
+#define EMT_ESP3DES_KEY_SZ	24	/* 168 bit secret key with parity = 192 bits */
+#define EMT_ESPDES_IV_SZ	8	/* IV size */
+#define ESP_DESCBC_BLKLEN       8       /* DES-CBC block size */
+
+#define DB_ES_PKTRX	0x0001
+#define DB_ES_PKTRX2	0x0002
+#define DB_ES_TDB	0x0010
+#define DB_ES_XF	0x0020
+#define DB_ES_IPAD	0x0040
+#define DB_ES_INAU	0x0080
+#define DB_ES_OINFO	0x0100
+#define DB_ES_OINFO2	0x0200
+#define DB_ES_OH	0x0400
+#define DB_ES_REPLAY	0x0800
+
+struct espblkrply_edata
+{
+	__u16	eme_klen;		/* encryption key length */
+	__u16	ame_klen;		/* authentication key length */
+	__u16	eme_flags;		/* see below */
+	__u16	eme_ooowin;		/* out-of-order window size */
+#if 1
+	__u16	eme_ivlen;		/* IV length */
+	__u16	filler;
+	union
+	{
+		__u8	Iv[8];		/* that's enough space */
+		__u32	Ivl[2];
+		__u64	Ivq;
+	}Iu;
+#define eme_iv	Iu.Iv
+#define eme_ivl Iu.Ivl
+#define eme_ivq Iu.Ivq
+#endif
+	__u8	eme_key[EMT_ESPDES_KMAX]; /* the encryption raw key */
+	__u8	ame_key[AH_AMAX];	/* the authentication raw key */
+};
+
+#ifdef __KERNEL__
+struct esp3desmd5_xdata
+{
+	__u8	edmx_flags;		/* same as before */
+	__u8	edmx_ooowin;		/* out-of-order window size */
+	__u16	edmx_ivlen;		/* IV length */
+	__u32	edmx_bitmap;		/* this&next should be 4 bytes each */
+	__u32	edmx_lastseq;		/* in host order */
+	__u32	edmx_eks1[16][2];	/* the first key schedule */
+	__u32	edmx_eks2[16][2];	/* the second key schedule */
+	__u32	edmx_eks3[16][2];	/* the third key schedule */
+	__u32	edmx_iv[2];		/* constant IV */
+	MD5_CTX edmx_ictx;		/* derived from HMAC_key */
+	MD5_CTX edmx_octx;		/* ditto */
+};
+
+struct espnullmd5_xdata
+{
+	__u8	edmx_flags;		/* same as before */
+	__u8	edmx_ooowin;		/* out-of-order window size */
+	__u32	edmx_bitmap;		/* this&next should be 4 bytes each */
+	__u32	edmx_lastseq;		/* in host order */
+	MD5_CTX edmx_ictx;		/* derived from HMAC_key */
+	MD5_CTX edmx_octx;		/* ditto */
+};
+
+struct esp3dessha1_xdata
+{
+	__u8	edmx_flags;		/* same as before */
+	__u8	edmx_ooowin;		/* out-of-order window size */
+	__u16	edmx_ivlen;		/* IV length */
+	__u32	edmx_bitmap;		/* this&next should be 4 bytes each */
+	__u32	edmx_lastseq;		/* in host order */
+	__u32	edmx_eks1[16][2];	/* the first key schedule */
+	__u32	edmx_eks2[16][2];	/* the second key schedule */
+	__u32	edmx_eks3[16][2];	/* the third key schedule */
+	__u32	edmx_iv[2];		/* constant IV */
+	SHA1_CTX edmx_ictx;		/* derived from HMAC_key */
+	SHA1_CTX edmx_octx;		/* ditto */
+};
+
+struct espnullsha1_xdata
+{
+	__u8	edmx_flags;		/* same as before */
+	__u8	edmx_ooowin;		/* out-of-order window size */
+	__u32	edmx_bitmap;		/* this&next should be 4 bytes each */
+	__u32	edmx_lastseq;		/* in host order */
+	SHA1_CTX edmx_ictx;		/* derived from HMAC_key */
+	SHA1_CTX edmx_octx;		/* ditto */
+};
+
+struct esp3des_xdata
+{
+	__u8	edmx_flags;		/* same as before */
+	__u8	edmx_ooowin;		/* out-of-order window size */
+	__u16	edmx_ivlen;		/* IV length */
+	__u32	edmx_bitmap;		/* this&next should be 4 bytes each */
+	__u32	edmx_lastseq;		/* in host order */
+	__u32	edmx_eks1[16][2];	/* the first key schedule */
+	__u32	edmx_eks2[16][2];	/* the second key schedule */
+	__u32	edmx_eks3[16][2];	/* the third key schedule */
+	__u32	edmx_iv[2];		/* constant IV */
+};
+
+struct des_eks {
+	__u32	eks[16][2];	/* the key schedule */
+};
+
+extern struct inet_protocol esp_protocol;
+
+struct options;
+
+extern int
+esp_rcv(struct sk_buff *skb,
+	struct device *dev,
+	struct options *opt, 
+	__u32 daddr,
+	unsigned short len,
+	__u32 saddr,
+	int redo,
+	struct inet_protocol *protocol);
+
+struct esp
+{
+	__u32	esp_spi;		/* Security Parameters Index */
+        __u32   esp_rpl;                /* Replay counter */
+	__u8	esp_iv[8];		/* iv */
+};
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_esp;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* __KERNEL__ */
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define ESPPRINTKEYS_
+#endif /* CONFIG_IPSEC_DEBUG */
+
+/*
+ * $Log$
+ * Revision 1.13  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.12  2000/08/01 14:51:50  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.11  2000/01/10 16:36:20  rgb
+ * Ditch last of EME option flags, including initiator.
+ *
+ * Revision 1.10  1999/12/07 18:16:22  rgb
+ * Fixed comments at end of #endif lines.
+ *
+ * Revision 1.9  1999/04/11 00:28:57  henry
+ * GPL boilerplate
+ *
+ * Revision 1.8  1999/04/06 04:54:25  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.7  1999/01/26 02:06:00  rgb
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ *
+ * Revision 1.6  1999/01/22 15:22:05  rgb
+ * Re-enable IV in the espblkrply_edata structure to avoid breaking pluto
+ * until pluto can be fixed properly.
+ *
+ * Revision 1.5  1999/01/22 06:18:16  rgb
+ * Updated macro comments.
+ * Added key schedule types to support algorithm switch code.
+ *
+ * Revision 1.4  1998/08/12 00:07:32  rgb
+ * Added data structures for new xforms: null, {,3}dessha1.
+ *
+ * Revision 1.3  1998/07/14 15:57:01  rgb
+ * Add #ifdef __KERNEL__ to protect kernel-only structures.
+ *
+ * Revision 1.2  1998/06/25 19:33:46  rgb
+ * Add prototype for protocol receive function.
+ * Rearrange for more logical layout.
+ *
+ * Revision 1.1  1998/06/18 21:27:45  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.6  1998/06/05 02:28:08  rgb
+ * Minor comment fix.
+ *
+ * Revision 1.5  1998/05/27 22:34:00  rgb
+ * Changed structures to accomodate key separation.
+ *
+ * Revision 1.4  1998/05/18 22:28:43  rgb
+ * Disable key printing facilities from /proc/net/ipsec_*.
+ *
+ * Revision 1.3  1998/04/21 21:29:07  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:20  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:00  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added ESP-3DES-MD5-96 transform.
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Added definitions for new ESP transforms.
+ *
+ * Revision 0.3  1996/11/20 14:35:48  ji
+ * Minor Cleanup.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_init.c linux/net/ipsec/ipsec_init.c
--- linux-noipsec/net/ipsec/ipsec_init.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_init.c	Wed Nov 29 21:14:06 2000
@@ -0,0 +1,1149 @@
+/*
+ * Initialization code, and /proc file system interface code.
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+char ipsec_init_c_version[] = "RCSID $Id$";
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/in.h>          /* struct sockaddr_in */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+#ifdef SPINLOCK_23
+#include <linux/spinlock.h> /* *lock* */
+#else /* SPINLOCK_23 */
+#include <asm/spinlock.h> /* *lock* */
+#endif /* SPINLOCK_23 */
+#endif /* SPINLOCK */
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#endif /* NET_21 */
+#include <asm/checksum.h>
+#include <net/ip.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif /* CONFIG_PROC_FS */
+#ifdef NETLINK_SOCK
+#include <linux/netlink.h>
+#else
+#include <net/netlink.h>
+#endif
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_tunnel.h"
+
+#include "version.c"
+
+#include "ipsec_rcv.h"
+#include "ipsec_ah.h"
+#include "ipsec_esp.h"
+
+#ifdef CONFIG_IPSEC_IPCOMP
+#include "ipcomp.h"
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+extern char *radij_c_version;
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_eroute = 0;
+int debug_spi = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef CONFIG_PROC_FS
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_eroute_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	struct wsbuf w = {buffer, length, offset, 0, 0, 0, 0};
+
+#ifdef CONFIG_IPSEC_DEBUG
+	if (debug_radij & DB_RJ_DUMPTREES)
+	  rj_dumptrees();			/* XXXXXXXXX */
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_eroute_get_info: buffer=0x%p,"
+		    " *start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+
+	spin_lock_bh(&eroute_lock);
+
+	rj_walktree(rnh, ipsec_rj_walker_procprint, &w);
+/*	rj_walktree(mask_rjhead, ipsec_rj_walker_procprint, &w); */
+
+	spin_unlock_bh(&eroute_lock);
+
+	*start = buffer + (offset - w.begin);	/* Start of wanted data */
+	w.len -= (offset - w.begin);			/* Start slop */
+	if (w.len > length)
+		w.len = length;
+	return w.len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_spi_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef  PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	int len = 0;
+	off_t pos = 0, begin = 0;
+	int i;
+	struct tdb *tdbp;
+	char sa[SATOA_BUF];
+	char buf_s[ADDRTOA_BUF];
+#if 0
+	char buf_d[ADDRTOA_BUF];
+#endif
+	size_t sa_len;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_spi_get_info: buffer=0x%p,"
+		    "*start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+	
+	spin_lock_bh(&tdb_lock);
+	
+	for (i = 0; i < TDB_HASHMOD; i++) {
+		for (tdbp = tdbh[i]; tdbp; tdbp = tdbp->tdb_hnext) {
+			sa_len = satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+			len += sprintf(buffer + len, "%s ", sa);
+			len += sprintf(buffer + len, "%s%s%s", TDB_XFORM_NAME(tdbp));
+			len += sprintf(buffer + len, ": dir=%s",
+				       (tdbp->tdb_flags & EMT_INBOUND) ?
+				       "in " : "out");
+#if 0
+			if((tdbp->tdb_said.proto == IPPROTO_IPIP) && tdbp->tdb_addr_s && tdbp->tdb_addr_d) {
+				addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr,
+					0, buf_s, sizeof(buf_s));
+				addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr,
+					0, buf_d, sizeof(buf_d));
+				len += sprintf(buffer + len, " %s -> %s",
+					       buf_s, buf_d);
+			}
+#else
+			if(tdbp->tdb_addr_s) {
+				addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr,
+					0, buf_s, sizeof(buf_s));
+				len += sprintf(buffer + len, " src=%s",
+					       buf_s);
+			}
+#endif
+
+			if(tdbp->tdb_iv_bits) {
+				int j;
+				len += sprintf(buffer + len, " iv_bits=%dbits iv=0x",
+					       tdbp->tdb_iv_bits);
+				for(j = 0; j < tdbp->tdb_iv_bits / 8; j++) {
+					len += sprintf(buffer + len, "%02x",
+						       (__u32)((__u8*)(tdbp->tdb_iv))[j]);
+				}
+			}
+			if(tdbp->tdb_encalg || tdbp->tdb_authalg) {
+				if(tdbp->tdb_replaywin) {
+					len += sprintf(buffer + len, " ooowin=%d",
+						       tdbp->tdb_replaywin);
+				}
+				if(tdbp->tdb_replaywin_errs) {
+					len += sprintf(buffer + len, " ooo_errs=%d",
+						       tdbp->tdb_replaywin_errs);
+				}
+				if(tdbp->tdb_replaywin_lastseq) {
+                                       len += sprintf(buffer + len, " seq=%d",
+						      tdbp->tdb_replaywin_lastseq);
+				}
+				if(tdbp->tdb_replaywin_bitmap) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+					len += sprintf(buffer + len, " bit=0x%Lx",
+						       tdbp->tdb_replaywin_bitmap);
+#else
+					len += sprintf(buffer + len, " bit=0x%x%08x",
+						       (__u32)(tdbp->tdb_replaywin_bitmap >> 32),
+						       (__u32)tdbp->tdb_replaywin_bitmap);
+#endif
+				}
+				if(tdbp->tdb_replaywin_maxdiff) {
+					len += sprintf(buffer + len, " max_seq_diff=%d",
+						       tdbp->tdb_replaywin_maxdiff);
+				}
+			}
+			if(tdbp->tdb_flags & ~EMT_INBOUND) {
+				len += sprintf(buffer + len, " flags=0x%x",
+					       tdbp->tdb_flags & ~EMT_INBOUND);
+				len += sprintf(buffer + len, "<");
+				/* flag printing goes here */
+				len += sprintf(buffer + len, ">");
+			}
+			if(tdbp->tdb_auth_bits) {
+				len += sprintf(buffer + len, " alen=%d",
+					       tdbp->tdb_auth_bits);
+			}
+			if(tdbp->tdb_key_bits_a) {
+				len += sprintf(buffer + len, " aklen=%d",
+					       tdbp->tdb_key_bits_a);
+			}
+			if(tdbp->tdb_auth_errs) {
+				len += sprintf(buffer + len, " auth_errs=%d",
+					       tdbp->tdb_auth_errs);
+			}
+			if(tdbp->tdb_key_bits_e) {
+				len += sprintf(buffer + len, " eklen=%d",
+					       tdbp->tdb_key_bits_e);
+			}
+			if(tdbp->tdb_encsize_errs) {
+				len += sprintf(buffer + len, " encr_size_errs=%d",
+					       tdbp->tdb_encsize_errs);
+			}
+			if(tdbp->tdb_encpad_errs) {
+				len += sprintf(buffer + len, " encr_pad_errs=%d",
+					       tdbp->tdb_encpad_errs);
+			}
+			
+			len += sprintf(buffer + len, " life(c,s,h)=");
+			if(tdbp->tdb_lifetime_allocations_c > 1 || 
+			   tdbp->tdb_lifetime_allocations_s ||
+			   tdbp->tdb_lifetime_allocations_h) {
+				len += sprintf(buffer + len, "alloc(%d,%d,%d)",
+					       (int)(jiffies - tdbp->tdb_lifetime_allocations_c),
+					       tdbp->tdb_lifetime_allocations_s,
+					       (int)tdbp->tdb_lifetime_allocations_h);
+			}
+			if(tdbp->tdb_lifetime_bytes_c ||
+			   tdbp->tdb_lifetime_bytes_s ||
+			   tdbp->tdb_lifetime_bytes_h) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, "bytes(%Ld,%Ld,%Ld)",
+					       tdbp->tdb_lifetime_bytes_c,
+					       tdbp->tdb_lifetime_bytes_s,
+					       tdbp->tdb_lifetime_bytes_h);
+#else /* XXX high 32 bits are not displayed */
+				len += sprintf(buffer + len, "bytes(%lu,%lu,%lu)",
+					       (unsigned long)tdbp->tdb_lifetime_bytes_c,
+					       (unsigned long)tdbp->tdb_lifetime_bytes_s,
+					       (unsigned long)tdbp->tdb_lifetime_bytes_h);
+#endif
+
+			}
+			if(tdbp->tdb_lifetime_addtime_c ||
+			   tdbp->tdb_lifetime_addtime_s ||
+			   tdbp->tdb_lifetime_addtime_h) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, "add(%Ld,%Ld,%Ld)",
+					       jiffies / HZ - tdbp->tdb_lifetime_addtime_c,
+					       tdbp->tdb_lifetime_addtime_s,
+					       tdbp->tdb_lifetime_addtime_h);
+#else
+				len += sprintf(buffer + len, "add(%lu,%lu,%lu)",
+					       jiffies / HZ - (unsigned long)tdbp->tdb_lifetime_addtime_c,
+					       (unsigned long)tdbp->tdb_lifetime_addtime_s,
+					       (unsigned long)tdbp->tdb_lifetime_addtime_h);
+#endif
+			}
+			if(tdbp->tdb_lifetime_usetime_c ||
+			   tdbp->tdb_lifetime_usetime_s ||
+			   tdbp->tdb_lifetime_usetime_h) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, "use(%Ld,%Ld,%Ld)",
+					       tdbp->tdb_lifetime_usetime_c ?
+						jiffies / HZ - tdbp->tdb_lifetime_usetime_c : 0,
+					       tdbp->tdb_lifetime_usetime_s,
+					       tdbp->tdb_lifetime_usetime_h);
+#else
+				len += sprintf(buffer + len, "use(%lu,%lu,%lu)",
+					       tdbp->tdb_lifetime_usetime_c ?
+						jiffies / HZ - (unsigned long)tdbp->tdb_lifetime_usetime_c : 0,
+					       (unsigned long)tdbp->tdb_lifetime_usetime_s,
+					       (unsigned long)tdbp->tdb_lifetime_usetime_h);
+#endif
+			}
+			if(tdbp->tdb_lifetime_packets_c ||
+			   tdbp->tdb_lifetime_packets_s ||
+			   tdbp->tdb_lifetime_packets_h) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, "packets(%Ld,%Ld,%Ld)",
+					       tdbp->tdb_lifetime_packets_c,
+					       tdbp->tdb_lifetime_packets_s,
+					       tdbp->tdb_lifetime_packets_h);
+#else
+				len += sprintf(buffer + len, "packets(%lu,%lu,%lu)",
+					       (unsigned long)tdbp->tdb_lifetime_packets_c,
+					       (unsigned long)tdbp->tdb_lifetime_packets_s,
+					       (unsigned long)tdbp->tdb_lifetime_packets_h);
+#endif
+			}
+
+			if(tdbp->tdb_lifetime_usetime_c) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, " idle=%Ld",
+					       jiffies / HZ - tdbp->tdb_lifetime_usetime_l);
+#else
+				len += sprintf(buffer + len, " idle=%lu",
+					       jiffies / HZ - (unsigned long)tdbp->tdb_lifetime_usetime_l);
+#endif
+			}
+
+#ifdef CONFIG_IPSEC_IPCOMP
+			if(tdbp->tdb_said.proto == IPPROTO_COMP &&
+			   (tdbp->tdb_comp_ratio_dbytes ||
+			    tdbp->tdb_comp_ratio_cbytes)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				len += sprintf(buffer + len, " ratio=%Ld:%Ld",
+					       tdbp->tdb_comp_ratio_dbytes,
+					       tdbp->tdb_comp_ratio_cbytes);
+#else
+				len += sprintf(buffer + len, " ratio=%lu:%lu",
+					       (unsigned long)tdbp->tdb_comp_ratio_dbytes,
+					       (unsigned long)tdbp->tdb_comp_ratio_cbytes);
+#endif
+			}
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+			len += sprintf(buffer + len, "\n");
+
+			pos = begin + len;
+			if(pos < offset) {
+				len = 0;
+				begin = pos;
+			}
+			if (pos > offset + length) {
+				goto done_spi_i;
+			}
+		}
+	}
+
+ done_spi_i:	
+	spin_unlock_bh(&tdb_lock);
+
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);			/* Start slop */
+	if (len > length)
+		len = length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_spigrp_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	int len = 0;
+	off_t pos = 0, begin = 0;
+	int i;
+	struct tdb *tdbp, *tdbp2;
+	char sa[SATOA_BUF];
+	size_t sa_len;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_spigrp_get_info: buffer=0x%p,"
+		    " *start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+
+	spin_lock_bh(&tdb_lock);
+	
+	for (i = 0; i < TDB_HASHMOD; i++) {
+		for (tdbp = tdbh[i]; tdbp; tdbp = tdbp->tdb_hnext)
+		{
+			if(!tdbp->tdb_inext)
+			{
+				tdbp2 = tdbp;
+				while(tdbp2) {
+					sa_len = satoa(tdbp2->tdb_said, 0, sa, SATOA_BUF);
+					len += sprintf(buffer + len, "%s ",
+						       sa);
+					tdbp2 = tdbp2->tdb_onext;
+				}
+				len += sprintf(buffer + len, "\n");
+				pos = begin + len;
+				if(pos < offset) {
+					len = 0;
+					begin = pos;
+				}
+				if (pos > offset + length) {
+					goto done_spigrp_i;
+				}
+			}
+		}
+	}
+
+ done_spigrp_i:	
+	spin_unlock_bh(&tdb_lock);
+
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);			/* Start slop */
+	if (len > length)
+		len = length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_tncfg_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	int len = 0;
+	off_t pos = 0, begin = 0;
+	int i;
+	char name[9];
+	struct device *dev, *privdev;
+	struct ipsecpriv *priv;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_tncfg_get_info: buffer=0x%p,"
+		    "*start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+
+	for(i = 0; i < IPSEC_NUM_IF; i++) {
+		sprintf(name, "ipsec%d", i);
+		dev = ipsec_dev_get(name);
+		if(dev) {
+			priv = (struct ipsecpriv *)(dev->priv);
+			len += sprintf(buffer + len, "%s",
+				       dev->name);
+			if(priv) {
+				privdev = (struct device *)(priv->dev);
+				len += sprintf(buffer + len, " -> %s",
+					       privdev ? privdev->name : "NULL");
+				len += sprintf(buffer + len, " mtu=%d -> %d",
+					       /* priv */ dev->mtu, privdev ? privdev->mtu : 0);
+			} else {
+				KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+					    "klips_debug:ipsec_tncfg_get_info: device '%s' has no private data space!\n",
+					    dev->name);
+			}
+			len += sprintf(buffer + len, "\n");
+
+			pos = begin + len;
+			if(pos < offset) {
+				len = 0;
+				begin = pos;
+			}
+			else if (pos > offset + length)	{
+				break;
+			}
+		}
+	}
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);			/* Start slop */
+	if (len > length)
+		len = length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_version_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	int len = 0;
+	off_t begin = 0;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_version_get_info: "
+		    "buffer=0x%p, *start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+
+	len += sprintf(buffer + len, "FreeS/WAN version: %s\n", freeswan_version);
+#if 0
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_version_get_info: "
+		    "ipsec_init version: %s\n",
+		    ipsec_init_c_version);
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_version_get_info: "
+		    "ipsec_tunnel version: %s\n",
+		    ipsec_tunnel_c_version);
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_version_get_info: "
+		    "ipsec_netlink version: %s\n",
+		    ipsec_netlink_c_version);
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_version_get_info: "
+		    "radij_c_version: %s\n",
+		    radij_c_version);
+#endif
+
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);			/* Start slop */
+	if (len > length)
+		len = length;
+	return len;
+}
+
+#ifdef CONFIG_IPSEC_DEBUG
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+ipsec_klipsdebug_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	int len = 0;
+	off_t begin = 0;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_PROCFS,
+		    "klips_debug:ipsec_klipsdebug_get_info: buffer=0x%p,"
+		    "*start=0x%x, offset=%d, length=%d\n",
+		    buffer, (u_int)*start, (int)offset, length);
+
+	len += sprintf(buffer + len, "debug_tunnel=%08x.\n", debug_tunnel);
+	len += sprintf(buffer + len, "debug_netlink=%08x.\n", debug_netlink);
+	len += sprintf(buffer + len, "debug_xform=%08x.\n", debug_xform);
+	len += sprintf(buffer + len, "debug_eroute=%08x.\n", debug_eroute);
+	len += sprintf(buffer + len, "debug_spi=%08x.\n", debug_spi);
+	len += sprintf(buffer + len, "debug_radij=%08x.\n", debug_radij);
+	len += sprintf(buffer + len, "debug_esp=%08x.\n", debug_esp);
+	len += sprintf(buffer + len, "debug_ah=%08x.\n", debug_ah);
+	len += sprintf(buffer + len, "debug_rcv=%08x.\n", debug_rcv);
+	len += sprintf(buffer + len, "debug_pfkey=%08x.\n", debug_pfkey);
+
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);			/* Start slop */
+	if (len > length)
+		len = length;
+	return len;
+}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifndef PROC_FS_2325
+struct proc_dir_entry ipsec_eroute =
+{
+	0,
+	12, "ipsec_eroute",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_eroute_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+
+struct proc_dir_entry ipsec_spi =
+{
+	0,
+	9, "ipsec_spi",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_spi_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+
+struct proc_dir_entry ipsec_spigrp =
+{
+	0,
+	12, "ipsec_spigrp",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_spigrp_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+
+struct proc_dir_entry ipsec_tncfg =
+{
+	0,
+	11, "ipsec_tncfg",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_tncfg_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+
+struct proc_dir_entry ipsec_version =
+{
+	0,
+	13, "ipsec_version",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_version_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+
+#ifdef CONFIG_IPSEC_DEBUG
+struct proc_dir_entry ipsec_klipsdebug =
+{
+	0,
+	16, "ipsec_klipsdebug",
+	S_IFREG | S_IRUGO, 1, 0, 0, 0,
+	&proc_net_inode_operations,
+	ipsec_klipsdebug_get_info,
+	NULL, NULL, NULL, NULL, NULL
+};
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* !PROC_FS_2325 */
+#endif /* CONFIG_PROC_FS */
+
+int ipsec_device_event(struct notifier_block *dnot, unsigned long event, void *ptr);
+/*
+ * the following structure is required so that we receive
+ * event notifications when network devices are enabled and
+ * disabled (ifconfig up and down).
+ */
+static struct notifier_block ipsec_dev_notifier={
+	ipsec_device_event,
+	NULL,
+	0
+};
+
+#ifdef CONFIG_SYSCTL
+extern int ipsec_sysctl_register(void);
+extern void ipsec_sysctl_unregister(void);
+#endif
+
+/* void */
+int
+ipsec_init(void)
+{
+	int error = 0;
+
+#ifdef CONFIG_PROC_FS
+#  ifndef PROC_FS_2325
+#    ifdef PROC_FS_21
+	proc_register(proc_net, &ipsec_eroute);
+	proc_register(proc_net, &ipsec_spi);
+	proc_register(proc_net, &ipsec_spigrp);
+	proc_register(proc_net, &ipsec_tncfg);
+	proc_register(proc_net, &ipsec_version);
+#      ifdef CONFIG_IPSEC_DEBUG
+	proc_register(proc_net, &ipsec_klipsdebug);
+#      endif /* CONFIG_IPSEC_DEBUG */
+#    else /* PROC_FS_21 */
+	proc_register_dynamic(&proc_net, &ipsec_eroute);
+	proc_register_dynamic(&proc_net, &ipsec_spi);
+	proc_register_dynamic(&proc_net, &ipsec_spigrp);
+	proc_register_dynamic(&proc_net, &ipsec_tncfg);
+	proc_register_dynamic(&proc_net, &ipsec_version);
+#      ifdef CONFIG_IPSEC_DEBUG
+	proc_register_dynamic(&proc_net, &ipsec_klipsdebug);
+#      endif /* CONFIG_IPSEC_DEBUG */
+#    endif /* PROC_FS_21 */
+#  else /* !PROC_FS_2325 */
+	proc_net_create ("ipsec_eroute", 0, ipsec_eroute_get_info);
+	proc_net_create ("ipsec_spi", 0, ipsec_spi_get_info);
+	proc_net_create ("ipsec_spigrp", 0, ipsec_spigrp_get_info);
+	proc_net_create ("ipsec_tncfg", 0, ipsec_tncfg_get_info);
+	proc_net_create ("ipsec_version", 0, ipsec_version_get_info);
+#    ifdef CONFIG_IPSEC_DEBUG
+	proc_net_create ("ipsec_klipsdebug", 0, ipsec_klipsdebug_get_info);
+#    endif /* CONFIG_IPSEC_DEBUG */
+#  endif /* !PROC_FS_2325 */
+#endif          /* CONFIG_PROC_FS */
+
+	printk("klips_debug:ipsec_init: ipsec module loading. freeswan version: %s\n",
+	       freeswan_version);
+
+#ifndef SPINLOCK
+	tdb_lock.lock = 0;
+	eroute_lock.lock = 0;
+#endif /* !SPINLOCK */
+
+	error |= ipsec_tdbinit();
+	error |= ipsec_radijinit();
+
+	error |= pfkey_init();
+
+	register_netdevice_notifier(&ipsec_dev_notifier);
+
+#ifdef CONFIG_IPSEC_ESP
+	inet_add_protocol(&esp_protocol);
+#endif /* CONFIG_IPSEC_ESP */
+
+#ifdef CONFIG_IPSEC_AH
+	inet_add_protocol(&ah_protocol);
+#endif /* CONFIG_IPSEC_AH */
+
+#if 0
+#ifdef CONFIG_IPSEC_IPCOMP
+  inet_add_protocol(&comp_protocol);
+#endif /* CONFIG_IPSEC_IPCOMP */
+#endif
+
+	error |= ipsec_tunnel_init_devices();
+
+#ifdef CONFIG_SYSCTL
+        error |= ipsec_sysctl_register();
+#endif                                                                          
+	return error;
+}	
+
+
+/* void */
+int
+ipsec_cleanup(void)
+{
+	int error = 0;
+
+#ifdef CONFIG_SYSCTL
+        ipsec_sysctl_unregister();
+#endif                                                                          
+	KLIPS_PRINT(debug_netlink, /* debug_tunnel & DB_TN_INIT, */
+		    "klips_debug:ipsec_cleanup: calling ipsec_tunnel_cleanup_devices.\n");
+	error |= ipsec_tunnel_cleanup_devices();
+
+#if 0
+#ifdef CONFIG_IPSEC_IPCOMP
+  if (inet_del_protocol(&comp_protocol) < 0)
+    printk(KERN_INFO "klips_debug:ipsec_cleanup:comp close: can't remove protocol\n");
+#endif
+#endif
+#ifdef CONFIG_IPSEC_AH
+	if ( inet_del_protocol(&ah_protocol) < 0 )
+		printk(KERN_INFO "klips_debug:ipsec_cleanup:ah close: can't remove protocol\n");
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_ESP
+	if ( inet_del_protocol(&esp_protocol) < 0 )
+		printk(KERN_INFO "klips_debug:ipsec_cleanup:esp close: can't remove protocol\n");
+#endif /* CONFIG_IPSEC_ESP */
+
+	unregister_netdevice_notifier(&ipsec_dev_notifier);
+
+	KLIPS_PRINT(debug_netlink, /* debug_tunnel & DB_TN_INIT, */
+		    "klips_debug:ipsec_cleanup: calling ipsec_tdbcleanup.\n");
+	error |= ipsec_tdbcleanup(0);
+	KLIPS_PRINT(debug_netlink, /* debug_tunnel & DB_TN_INIT, */
+		    "klips_debug:ipsec_cleanup: calling ipsec_radijcleanup.\n");
+	error |= ipsec_radijcleanup();
+	
+	KLIPS_PRINT(debug_pfkey, /* debug_tunnel & DB_TN_INIT, */
+		    "klips_debug:ipsec_cleanup: calling pfkey_cleanup.\n");
+	error |= pfkey_cleanup();
+
+#ifdef CONFIG_PROC_FS
+#  ifndef PROC_FS_2325
+#    ifdef CONFIG_IPSEC_DEBUG
+	if (proc_net_unregister(ipsec_klipsdebug.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_klipsdebug\n");
+#    endif /* CONFIG_IPSEC_DEBUG */
+	if (proc_net_unregister(ipsec_version.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_version\n");
+	if (proc_net_unregister(ipsec_eroute.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_eroute\n");
+	if (proc_net_unregister(ipsec_spi.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_spi\n");
+	if (proc_net_unregister(ipsec_spigrp.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_spigrp\n");
+	if (proc_net_unregister(ipsec_tncfg.low_ino) != 0)
+		printk("klips_debug:ipsec_cleanup: cannot unregister /proc/net/ipsec_tncfg\n");
+#  else /* !PROC_FS_2325 */
+#    ifdef CONFIG_IPSEC_DEBUG
+	proc_net_remove ("ipsec_klipsdebug");
+#    endif /* CONFIG_IPSEC_DEBUG */
+	proc_net_remove ("ipsec_eroute");
+	proc_net_remove ("ipsec_spi");
+	proc_net_remove ("ipsec_spigrp");
+	proc_net_remove ("ipsec_tncfg");
+	proc_net_remove ("ipsec_version");
+#  endif /* !PROC_FS_2325 */
+#endif          /* CONFIG_PROC_FS */
+
+	return error;
+}
+
+#ifdef MODULE
+int
+init_module(void)
+{
+	int error = 0;
+
+	error |= ipsec_init();
+
+	return error;
+}
+
+int
+cleanup_module(void)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_netlink, /* debug_tunnel & DB_TN_INIT, */
+		    "klips_debug:cleanup_module: calling ipsec_cleanup.\n");
+
+	error |= ipsec_cleanup();
+
+	KLIPS_PRINT(1, "klips_debug:cleanup_module: ipsec module unloaded.\n");
+
+	return error;
+}
+#endif /* MODULE */
+
+/*
+ * $Log$
+ * Revision 1.63  2000/11/29 20:14:06  rgb
+ * Add src= to the output of /proc/net/ipsec_spi and delete dst from IPIP.
+ *
+ * Revision 1.62  2000/11/06 04:31:24  rgb
+ * Ditched spin_lock_irqsave in favour of spin_lock_bh.
+ * Fixed longlong for pre-2.4 kernels (Svenning).
+ * Add Svenning's adaptive content compression.
+ * Disabled registration of ipcomp handler.
+ *
+ * Revision 1.61  2000/10/11 13:37:54  rgb
+ * #ifdef out debug print that causes proc/net/ipsec_version to oops.
+ *
+ * Revision 1.60  2000/09/20 03:59:01  rgb
+ * Change static info functions to DEBUG_NO_STATIC to reveal function names
+ * in oopsen.
+ *
+ * Revision 1.59  2000/09/16 01:06:26  rgb
+ * Added cast of var to silence compiler warning about long fed to int
+ * format.
+ *
+ * Revision 1.58  2000/09/15 11:37:01  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.57  2000/09/12 03:21:50  rgb
+ * Moved radij_c_version printing to ipsec_version_get_info().
+ * Reformatted ipsec_version_get_info().
+ * Added sysctl_{,un}register() calls.
+ *
+ * Revision 1.56  2000/09/08 19:16:50  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Removed all references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.55  2000/08/30 05:19:03  rgb
+ * Cleaned up no longer used spi_next, netlink register/unregister, other
+ * minor cleanup.
+ * Removed cruft replaced by TDB_XFORM_NAME.
+ * Removed all the rest of the references to tdb_spi, tdb_proto, tdb_dst.
+ * Moved debug version strings to printk when /proc/net/ipsec_version is
+ * called.
+ *
+ * Revision 1.54  2000/08/20 18:31:05  rgb
+ * Changed cosmetic alignment in spi_info.
+ * Changed addtime and usetime to use actual value which is relative
+ * anyways, as intended. (Momchil)
+ *
+ * Revision 1.53  2000/08/18 17:37:03  rgb
+ * Added an (int) cast to shut up the compiler...
+ *
+ * Revision 1.52  2000/08/01 14:51:50  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.51  2000/07/25 20:41:22  rgb
+ * Removed duplicate parameter in spi_getinfo.
+ *
+ * Revision 1.50  2000/07/17 03:21:45  rgb
+ * Removed /proc/net/ipsec_spinew.
+ *
+ * Revision 1.49  2000/06/28 05:46:51  rgb
+ * Renamed ivlen to iv_bits for consistency.
+ * Changed output of add and use times to be relative to now.
+ *
+ * Revision 1.48  2000/05/11 18:26:10  rgb
+ * Commented out calls to netlink_attach/detach to avoid activating netlink
+ * in the kenrel config.
+ *
+ * Revision 1.47  2000/05/10 22:35:26  rgb
+ * Comment out most of the startup version information.
+ *
+ * Revision 1.46  2000/03/22 16:15:36  rgb
+ * Fixed renaming of dev_get (MB).
+ *
+ * Revision 1.45  2000/03/16 06:40:48  rgb
+ * Hardcode PF_KEYv2 support.
+ *
+ * Revision 1.44  2000/01/22 23:19:20  rgb
+ * Simplified code to use existing macro TDB_XFORM_NAME().
+ *
+ * Revision 1.43  2000/01/21 06:14:04  rgb
+ * Print individual stats only if non-zero.
+ * Removed 'bits' from each keylength for brevity.
+ * Shortened lifetimes legend for brevity.
+ * Changed wording from 'last_used' to the clearer 'idle'.
+ *
+ * Revision 1.42  1999/12/31 14:57:19  rgb
+ * MB fix for new dummy-less proc_get_info in 2.3.35.
+ *
+ * Revision 1.41  1999/11/23 23:04:03  rgb
+ * Use provided macro ADDRTOA_BUF instead of hardcoded value.
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.40  1999/11/18 18:47:01  rgb
+ * Added dynamic proc registration for 2.3.25+.
+ * Changed all device registrations for static linking to
+ * dynamic to reduce the number and size of patches.
+ * Changed all protocol registrations for static linking to
+ * dynamic to reduce the number and size of patches.
+ *
+ * Revision 1.39  1999/11/18 04:12:07  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ * Added Marc Boucher's 2.3.25 proc patches.
+ * Converted all PROC_FS entries to dynamic to reduce kernel patching.
+ * Added CONFIG_PROC_FS compiler directives in case it is shut off.
+ *
+ * Revision 1.38  1999/11/17 15:53:38  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.37  1999/10/16 04:23:06  rgb
+ * Add stats for replaywin_errs, replaywin_max_sequence_difference,
+ * authentication errors, encryption size errors, encryption padding
+ * errors, and time since last packet.
+ *
+ * Revision 1.36  1999/10/16 00:30:47  rgb
+ * Added SA lifetime counting.
+ *
+ * Revision 1.35  1999/10/15 22:14:00  rgb
+ * Clean out cruft.
+ *
+ * Revision 1.34  1999/10/03 18:46:28  rgb
+ * Spinlock fixes for 2.0.xx and 2.3.xx.
+ *
+ * Revision 1.33  1999/10/01 17:08:10  rgb
+ * Disable spinlock init.
+ *
+ * Revision 1.32  1999/10/01 16:22:24  rgb
+ * Switch from assignment init. to functional init. of spinlocks.
+ *
+ * Revision 1.31  1999/10/01 15:44:52  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.30  1999/10/01 00:00:16  rgb
+ * Added eroute structure locking.
+ * Added tdb structure locking.
+ * Minor formatting changes.
+ * Add call to initialize tdb hash table.
+ *
+ * Revision 1.29  1999/09/23 20:22:40  rgb
+ * Enable, tidy and fix network notifier code.
+ *
+ * Revision 1.28  1999/09/18 11:39:56  rgb
+ * Start to add (disabled) netdevice notifier code.
+ *
+ * Revision 1.27  1999/08/28 08:24:47  rgb
+ * Add compiler directives to compile cleanly without debugging.
+ *
+ * Revision 1.26  1999/08/06 16:03:22  rgb
+ * Correct error messages on failure to unload /proc entries.
+ *
+ * Revision 1.25  1999/08/03 17:07:25  rgb
+ * Report device MTU, not private MTU.
+ *
+ * Revision 1.24  1999/05/25 22:24:37  rgb
+ * /PROC/NET/ipsec* init problem fix.
+ *
+ * Revision 1.23  1999/05/25 02:16:38  rgb
+ * Make modular proc_fs entries dynamic and fix for 2.2.x.
+ *
+ * Revision 1.22  1999/05/09 03:25:35  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.21  1999/05/05 22:02:30  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.20  1999/04/29 15:15:50  rgb
+ * Fix undetected iv_len reporting bug.
+ * Add sanity checking for null pointer to private data space.
+ * Add return values to init and cleanup functions.
+ *
+ * Revision 1.19  1999/04/27 19:24:44  rgb
+ * Added /proc/net/ipsec_klipsdebug support for reading the current debug
+ * settings.
+ * Instrument module load/init/unload.
+ *
+ * Revision 1.18  1999/04/15 15:37:24  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.15.2.3  1999/04/13 20:29:19  rgb
+ * /proc/net/ipsec_* cleanup.
+ *
+ * Revision 1.15.2.2  1999/04/02 04:28:23  rgb
+ * /proc/net/ipsec_* formatting enhancements.
+ *
+ * Revision 1.15.2.1  1999/03/30 17:08:33  rgb
+ * Add pfkey initialisation.
+ *
+ * Revision 1.17  1999/04/11 00:28:57  henry
+ * GPL boilerplate
+ *
+ * Revision 1.16  1999/04/06 04:54:25  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.15  1999/02/24 20:15:07  rgb
+ * Update output format.
+ *
+ * Revision 1.14  1999/02/17 16:49:39  rgb
+ * Convert DEBUG_IPSEC to KLIPS_PRINT
+ * Ditch NET_IPIP dependancy.
+ *
+ * Revision 1.13  1999/01/26 02:06:37  rgb
+ * Remove ah/esp switching on include files.
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ * Removed dead code.
+ * Remove references to INET_GET_PROTOCOL.
+ *
+ * Revision 1.12  1999/01/22 06:19:18  rgb
+ * Cruft clean-out.
+ * 64-bit clean-up.
+ * Added algorithm switch code.
+ *
+ * Revision 1.11  1998/12/01 05:54:53  rgb
+ * Cleanup and order debug version output.
+ *
+ * Revision 1.10  1998/11/30 13:22:54  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.9  1998/11/10 05:35:13  rgb
+ * Print direction in/out flag from /proc/net/ipsec_spi.
+ *
+ * Revision 1.8  1998/10/27 13:48:10  rgb
+ * Cleaned up /proc/net/ipsec_* filesystem for easy parsing by scripts.
+ * Fixed less(1) truncated output bug.
+ * Code clean-up.
+ *
+ * Revision 1.7  1998/10/22 06:43:16  rgb
+ * Convert to use satoa for printk.
+ *
+ * Revision 1.6  1998/10/19 14:24:35  rgb
+ * Added inclusion of freeswan.h.
+ *
+ * Revision 1.5  1998/10/09 04:43:35  rgb
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ *
+ * Revision 1.4  1998/07/27 21:50:22  rgb
+ * Not necessary to traverse mask tree for /proc/net/ipsec_eroute.
+ *
+ * Revision 1.3  1998/06/25 19:51:20  rgb
+ * Clean up #endif comments.
+ * Shift debugging comment control for procfs to debug_tunnel.
+ * Make proc_dir_entries visible to rest of kernel for static link.
+ * Replace hardwired fileperms with macros.
+ * Use macros for procfs inode numbers.
+ * Rearrange initialisations between ipsec_init and module_init as appropriate
+ * for static loading.
+ *
+ * Revision 1.2  1998/06/23 02:55:43  rgb
+ * Slightly quieted init-time messages.
+ * Re-introduced inet_add_protocol after it mysteriously disappeared...
+ * Check for and warn of absence of IPIP protocol on install of module.
+ * Move tdbcleanup to ipsec_xform.c.
+ *
+ * Revision 1.10  1998/06/18 21:29:04  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid kernel
+ * build scripts happier in presence of symbolic links
+ *
+ * Revision 1.9  1998/06/14 23:49:40  rgb
+ * Clarify version reporting on module loading.
+ *
+ * Revision 1.8  1998/06/11 05:54:23  rgb
+ * Added /proc/net/ipsec_version to report freeswan and transform versions.
+ * Added /proc/net/ipsec_spinew to generate new and unique spi's..
+ * Fixed /proc/net/ipsec_tncfg bug.
+ *
+ * Revision 1.7  1998/05/25 20:23:13  rgb
+ * proc_register changed to dynamic registration to avoid arbitrary inode
+ * numbers.
+ *
+ * Implement memory recovery from tdb and eroute tables.
+ *
+ * Revision 1.6  1998/05/21 13:08:58  rgb
+ * Rewrote procinfo subroutines to avoid *bad things* when more that 3k of
+ * information is available for printout.
+ *
+ * Revision 1.5  1998/05/18 21:29:48  rgb
+ * Cleaned up /proc/net/ipsec_* output, including a title line, algorithm
+ * names instead of numbers, standard format for numerical output base,
+ * whitespace for legibility, and the names themselves for consistency.
+ *
+ * Added /proc/net/ipsec_spigrp and /proc/net/ipsec_tncfg.
+ *
+ * Revision 1.4  1998/04/30 15:42:24  rgb
+ * Silencing attach for normal operations with #ifdef IPSEC_DEBUG.
+ *
+ * Revision 1.3  1998/04/21 21:28:58  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:22  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:05  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Fixed problem with node names of /proc/net entries.
+ * Other minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_ipe4.h linux/net/ipsec/ipsec_ipe4.h
--- linux-noipsec/net/ipsec/ipsec_ipe4.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_ipe4.h	Sun Apr 11 02:28:57 1999
@@ -0,0 +1,59 @@
+/*
+ * IP-in-IP Header declarations
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/* The packet header is an IP header! */
+
+struct ipe4_xdata			/* transform table data */
+{
+	struct in_addr	i4_src;
+	struct in_addr	i4_dst;
+};
+
+#define EMT_IPE4_ULEN	8	/* coming from user mode */
+ 
+
+/*
+ * $Log$
+ * Revision 1.3  1999/04/11 00:28:57  henry
+ * GPL boilerplate
+ *
+ * Revision 1.2  1999/04/06 04:54:25  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.1  1998/06/18 21:27:47  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.1  1998/04/09 03:06:07  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:03  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:48:53  ji
+ * Release update only.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_md5c.c linux/net/ipsec/ipsec_md5c.c
--- linux-noipsec/net/ipsec/ipsec_md5c.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_md5c.c	Mon Dec 13 14:59:12 1999
@@ -0,0 +1,430 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+ * The rest of the code is derived from MD5C.C by RSADSI. Minor cosmetic
+ * changes to accomodate it in the kernel by ji.
+ */
+
+#include <asm/byteorder.h>
+#include <linux/string.h>
+
+#include "ipsec_md5h.h"
+
+/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
+ */
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+/*
+ * Additions by JI
+ * 
+ * HAVEMEMCOPY is defined if mem* routines are available
+ *
+ * HAVEHTON is defined if htons() and htonl() can be used
+ * for big/little endian conversions
+ *
+ */
+
+#define HAVEMEMCOPY
+#ifdef __LITTLE_ENDIAN
+#define LITTLENDIAN
+#endif
+#ifdef __BIG_ENDIAN
+#define BIGENDIAN
+#endif
+
+/* Constants for MD5Transform routine.
+ */
+
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+
+static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
+
+#ifdef LITTLEENDIAN
+#define Encode MD5_memcpy
+#define Decode MD5_memcpy
+#else
+static void Encode PROTO_LIST
+  ((unsigned char *, UINT4 *, unsigned int));
+static void Decode PROTO_LIST
+  ((UINT4 *, unsigned char *, unsigned int));
+#endif
+
+#ifdef HAVEMEMCOPY
+/* no need to include <memory.h> here; <linux/string.h> defines these */
+#define MD5_memcpy	memcpy
+#define MD5_memset	memset
+#else
+#ifdef HAVEBCOPY
+#define MD5_memcpy(_a,_b,_c) bcopy((_b),(_a),(_c))
+#define MD5_memset(_a,_b,_c) bzero((_a),(_c))
+#else
+static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
+static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));
+#endif
+#endif
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+ (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) { \
+ (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) { \
+ (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) { \
+ (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+
+/* MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+void MD5Init (context)
+MD5_CTX *context;                                        /* context */
+{
+  context->count[0] = context->count[1] = 0;
+  /* Load magic initialization constants.
+*/
+  context->state[0] = 0x67452301;
+  context->state[1] = 0xefcdab89;
+  context->state[2] = 0x98badcfe;
+  context->state[3] = 0x10325476;
+}
+
+/* MD5 block update operation. Continues an MD5 message-digest
+  operation, processing another message block, and updating the
+  context.
+ */
+void MD5Update (context, input, inputLen)
+MD5_CTX *context;                                        /* context */
+unsigned char *input;                                /* input block */
+__u32 inputLen;                     /* length of input block */
+{
+  __u32 i;
+  unsigned int index, partLen;
+
+  /* Compute number of bytes mod 64 */
+  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
+
+  /* Update number of bits */
+  if ((context->count[0] += ((UINT4)inputLen << 3))
+   < ((UINT4)inputLen << 3))
+ context->count[1]++;
+  context->count[1] += ((UINT4)inputLen >> 29);
+
+  partLen = 64 - index;
+
+  /* Transform as many times as possible.
+*/
+  if (inputLen >= partLen) {
+ MD5_memcpy
+   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
+ MD5Transform (context->state, context->buffer);
+
+ for (i = partLen; i + 63 < inputLen; i += 64)
+   MD5Transform (context->state, &input[i]);
+
+ index = 0;
+  }
+  else
+ i = 0;
+
+  /* Buffer remaining input */
+  MD5_memcpy
+ ((POINTER)&context->buffer[index], (POINTER)&input[i],
+  inputLen-i);
+}
+
+/* MD5 finalization. Ends an MD5 message-digest operation, writing the
+  the message digest and zeroizing the context.
+ */
+void MD5Final (digest, context)
+unsigned char digest[16];                         /* message digest */
+MD5_CTX *context;                                       /* context */
+{
+  unsigned char bits[8];
+  unsigned int index, padLen;
+
+  /* Save number of bits */
+  Encode (bits, context->count, 8);
+
+  /* Pad out to 56 mod 64.
+*/
+  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
+  padLen = (index < 56) ? (56 - index) : (120 - index);
+  MD5Update (context, PADDING, padLen);
+
+  /* Append length (before padding) */
+  MD5Update (context, bits, 8);
+
+  if (digest != NULL)			/* Bill Simpson's padding */
+  {
+	  /* store state in digest */
+	  Encode (digest, context->state, 16);
+
+	  /* Zeroize sensitive information.
+	   */
+	  MD5_memset ((POINTER)context, 0, sizeof (*context));
+  }
+}
+
+/* MD5 basic transformation. Transforms state based on block.
+ */
+static void MD5Transform (state, block)
+UINT4 state[4];
+unsigned char block[64];
+{
+  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+  Decode (x, block, 64);
+
+  /* Round 1 */
+  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
+  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
+  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
+  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
+  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
+  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
+  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
+  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
+  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
+  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
+  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
+  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
+  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
+  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
+  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
+  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
+
+ /* Round 2 */
+  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
+  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
+  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
+  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
+  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
+  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
+  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
+  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
+  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
+  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
+  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
+  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
+  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
+  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
+  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
+  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
+
+  /* Round 3 */
+  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
+  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
+  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
+  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
+  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
+  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
+  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
+  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
+  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
+  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
+  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
+  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
+  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
+  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
+  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
+  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
+
+  /* Round 4 */
+  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
+  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
+  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
+  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
+  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
+  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
+  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
+  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
+  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
+  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
+  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
+  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
+  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
+  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
+  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
+  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
+
+  state[0] += a;
+  state[1] += b;
+  state[2] += c;
+  state[3] += d;
+
+  /* Zeroize sensitive information.
+*/
+  MD5_memset ((POINTER)x, 0, sizeof (x));
+}
+
+#ifndef LITTLEENDIAN
+
+/* Encodes input (UINT4) into output (unsigned char). Assumes len is
+  a multiple of 4.
+ */
+static void Encode (output, input, len)
+unsigned char *output;
+UINT4 *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4) {
+ output[j] = (unsigned char)(input[i] & 0xff);
+ output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
+ output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
+ output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
+  }
+}
+
+/* Decodes input (unsigned char) into output (UINT4). Assumes len is
+  a multiple of 4.
+ */
+static void Decode (output, input, len)
+UINT4 *output;
+unsigned char *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4)
+ output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
+   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
+}
+
+#endif
+
+#ifndef HAVEMEMCOPY
+#ifndef HAVEBCOPY
+/* Note: Replace "for loop" with standard memcpy if possible.
+ */
+
+static void MD5_memcpy (output, input, len)
+POINTER output;
+POINTER input;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+
+ output[i] = input[i];
+}
+
+/* Note: Replace "for loop" with standard memset if possible.
+ */
+
+static void MD5_memset (output, value, len)
+POINTER output;
+int value;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+ ((char *)output)[i] = (char)value;
+}
+#endif
+#endif
+
+/*
+ * $Log$
+ * Revision 1.4  1999/12/13 13:59:12  rgb
+ * Quick fix to argument size to Update bugs.
+ *
+ * Revision 1.3  1999/05/21 18:09:28  henry
+ * unnecessary <memory.h> include causes trouble in 2.2
+ *
+ * Revision 1.2  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.1  1998/06/18 21:27:48  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.2  1998/04/23 20:54:02  rgb
+ * Fixed md5 and sha1 include file nesting issues, to be cleaned up when
+ * verified.
+ *
+ * Revision 1.1  1998/04/09 03:06:08  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.3  1996/11/20 14:48:53  ji
+ * Release update only.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_md5h.h linux/net/ipsec/ipsec_md5h.h
--- linux-noipsec/net/ipsec/ipsec_md5h.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_md5h.h	Mon Dec 13 14:59:13 1999
@@ -0,0 +1,129 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+ * The rest of this file is Copyright RSA DSI. See the following comments
+ * for the full Copyright notice.
+ */
+
+#ifndef _IPSEC_MD5H_H_
+#define _IPSEC_MD5H_H_
+
+/* GLOBAL.H - RSAREF types and constants
+ */
+
+/* PROTOTYPES should be set to one if and only if the compiler supports
+     function argument prototyping.
+   The following makes PROTOTYPES default to 0 if it has not already
+     been defined with C compiler flags.
+ */
+#ifndef PROTOTYPES
+#define PROTOTYPES 1
+#endif /* !PROTOTYPES */
+
+/* POINTER defines a generic pointer type */
+typedef __u8 *POINTER;
+
+/* UINT2 defines a two byte word */
+typedef __u16 UINT2;
+
+/* UINT4 defines a four byte word */
+typedef __u32 UINT4;
+
+/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
+   If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
+     returns an empty list.
+ */
+
+#if PROTOTYPES
+#define PROTO_LIST(list) list
+#else /* PROTOTYPES */
+#define PROTO_LIST(list) ()
+#endif /* PROTOTYPES */
+
+
+/* MD5.H - header file for MD5C.C
+ */
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+/* MD5 context. */
+typedef struct {
+  UINT4 state[4];                                   /* state (ABCD) */
+  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
+  unsigned char buffer[64];                         /* input buffer */
+} MD5_CTX;
+
+void MD5Init PROTO_LIST ((MD5_CTX *));
+void MD5Update PROTO_LIST
+  ((MD5_CTX *, unsigned char *, __u32));
+void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
+ 
+#endif /* _IPSEC_MD5H_H_ */
+
+/*
+ * $Log$
+ * Revision 1.6  1999/12/13 13:59:13  rgb
+ * Quick fix to argument size to Update bugs.
+ *
+ * Revision 1.5  1999/12/07 18:16:23  rgb
+ * Fixed comments at end of #endif lines.
+ *
+ * Revision 1.4  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.3  1999/01/22 06:19:58  rgb
+ * 64-bit clean-up.
+ *
+ * Revision 1.2  1998/11/30 13:22:54  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.1  1998/06/18 21:27:48  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.2  1998/04/23 20:54:03  rgb
+ * Fixed md5 and sha1 include file nesting issues, to be cleaned up when
+ * verified.
+ *
+ * Revision 1.1  1998/04/09 03:04:21  henry
+ * sources moved up from linux/net/ipsec
+ * these two include files modified not to include others except in kernel
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:03  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:48:53  ji
+ * Release update only.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_netlink.c linux/net/ipsec/ipsec_netlink.c
--- linux-noipsec/net/ipsec/ipsec_netlink.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_netlink.c	Mon Nov  6 05:32:08 2000
@@ -0,0 +1,635 @@
+/*
+ * IPSEC <> netlink interface
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+char ipsec_netlink_c_version[] = "RCSID $Id$";
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+ #ifdef SPINLOCK_23
+  #include <linux/spinlock.h> /* *lock* */
+ #else /* 23_SPINLOCK */
+  #include <asm/spinlock.h> /* *lock* */
+ #endif /* 23_SPINLOCK */
+#endif /* SPINLOCK */
+#ifdef NET_21
+ #include <asm/uaccess.h>
+ #include <linux/in6.h>
+ #define ip_chk_addr inet_addr_type
+ #define IS_MYADDR RTN_LOCAL
+#endif
+#include <asm/checksum.h>
+#include <net/ip.h>
+#ifdef NETLINK_SOCK
+ #include <linux/netlink.h>
+#else
+ #include <net/netlink.h>
+#endif
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+
+#include "ipsec_rcv.h"
+#include "ipsec_ah.h"
+#include "ipsec_esp.h"
+
+#ifdef CONFIG_IPSEC_DEBUG
+ #include "ipsec_tunnel.h"
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#ifdef CONFIG_IPSEC_DEBUG
+ int debug_netlink = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#define SENDERR(_x) do { len = -(_x); goto errlab; } while (0)
+
+#if 0
+int 
+#ifdef NETLINK_SOCK
+ipsec_callback(int proto, struct sk_buff *skb)
+#else /* NETLINK_SOCK */
+ipsec_callback(struct sk_buff *skb)
+#endif /* NETLINK_SOCK */
+{
+	/*
+	 * this happens when we write to /dev/ipsec (c 36 10)
+	 */
+	int len = skb->len;
+	u_char *dat = (u_char *)skb->data;
+	struct encap_msghdr *em	= (struct encap_msghdr *)dat;
+	struct tdb *tdbp, *tprev;
+	int i, nspis, error = 0;
+#ifdef CONFIG_IPSEC_DEBUG
+	struct eroute *eret;
+	char sa[SATOA_BUF];
+
+
+	satoa(em->em_said, 0, sa, SATOA_BUF);
+
+	if(debug_netlink) {
+		printk("klips_debug:ipsec_callback: skb=0x%p skblen=%ld em_magic=%d em_type=%d\n",
+		       skb, (unsigned long int)skb->len, em->em_magic, em->em_type);
+		switch(em->em_type) {
+		case EMT_SETDEBUG:
+			printk("klips_debug:ipsec_callback: set ipsec_debug level\n");
+			break;
+		case EMT_DELEROUTE:
+		case EMT_CLREROUTE:
+		case EMT_CLRSPIS:
+			break;
+		default:
+			printk("klips_debug:ipsec_callback: called for SA:%s\n", sa);
+		}
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	/* XXXX Temporarily disable netlink I/F code until it gets permanantly
+	   ripped out in favour of PF_KEYv2 I/F. */
+	SENDERR(EPROTONOSUPPORT);
+
+	/*	em = (struct encap_msghdr *)dat; */
+	if (em->em_magic != EM_MAGIC) {
+		printk("klips_debug:ipsec_callback: bad magic=%d failed, should be %d\n",
+		       em->em_magic,
+		       EM_MAGIC);
+		SENDERR(EINVAL);
+	}
+	switch (em->em_type) {
+	case EMT_SETDEBUG:
+#ifdef CONFIG_IPSEC_DEBUG
+		if(em->em_db_nl >> (sizeof(em->em_db_nl) * 8 - 1)) {
+			em->em_db_nl &= ~(1 << (sizeof(em->em_db_nl) * 8 -1));
+			debug_tunnel  |= em->em_db_tn;
+			debug_netlink |= em->em_db_nl;
+			debug_xform   |= em->em_db_xf;
+			debug_eroute  |= em->em_db_er;
+			debug_spi     |= em->em_db_sp;
+			debug_radij   |= em->em_db_rj;
+			debug_esp     |= em->em_db_es;
+			debug_ah      |= em->em_db_ah;
+			debug_rcv     |= em->em_db_rx;
+			debug_pfkey   |= em->em_db_ky;
+			if(debug_netlink)
+				printk("klips_debug:ipsec_callback: set\n");
+		} else {
+			if(debug_netlink)
+				printk("klips_debug:ipsec_callback: unset\n");
+			debug_tunnel  &= em->em_db_tn;
+			debug_netlink &= em->em_db_nl;
+			debug_xform   &= em->em_db_xf;
+			debug_eroute  &= em->em_db_er;
+			debug_spi     &= em->em_db_sp;
+			debug_radij   &= em->em_db_rj;
+			debug_esp     &= em->em_db_es;
+			debug_ah      &= em->em_db_ah;
+			debug_rcv     &= em->em_db_rx;
+			debug_pfkey   &= em->em_db_ky;
+		}
+#else /* CONFIG_IPSEC_DEBUG */
+		printk("klips_debug:ipsec_callback: debugging not enabled\n");
+		SENDERR(EINVAL);
+#endif /* CONFIG_IPSEC_DEBUG */
+		break;
+
+	case EMT_SETEROUTE:
+		if ((error = ipsec_makeroute(&(em->em_eaddr), &(em->em_emask), em->em_ersaid)))
+			SENDERR(-error);
+		break;
+
+	case EMT_RPLACEROUTE:
+		if ((error = ipsec_breakroute(&(em->em_eaddr), &(em->em_emask))) == EINVAL) {
+				SENDERR(-error);
+		}
+		if ((error = ipsec_makeroute(&(em->em_eaddr), &(em->em_emask), em->em_ersaid)))
+			SENDERR(-error);
+		break;
+
+	case EMT_DELEROUTE:
+		if ((error = ipsec_breakroute(&(em->em_eaddr), &(em->em_emask))))
+			SENDERR(-error);
+		break;
+
+	case EMT_CLREROUTE:
+		if ((error = ipsec_cleareroutes()))
+			SENDERR(-error);
+		break;
+
+	case EMT_SETSPI:
+		if (em->em_if >= 5)	/* XXX -- why 5? */
+			SENDERR(ENODEV);
+		
+		tdbp = gettdb(&(em->em_said));
+		if (tdbp == NULL) {
+			tdbp = (struct tdb *)kmalloc(sizeof (*tdbp), GFP_ATOMIC);
+
+			if (tdbp == NULL)
+				SENDERR(ENOBUFS);
+			
+			memset((caddr_t)tdbp, 0, sizeof(*tdbp));
+			
+			tdbp->tdb_said = em->em_said;
+			tdbp->tdb_flags = em->em_flags;
+			
+			if(ip_chk_addr((unsigned long)em->em_said.dst.s_addr) == IS_MYADDR) {
+				tdbp->tdb_flags |= EMT_INBOUND;
+			}
+			KLIPS_PRINT(debug_netlink & DB_NL_TDBCB,
+				    "klips_debug:ipsec_callback: existing Tunnel Descriptor Block not found (this\n"
+				    "klips_debug:                is good) for SA: %s, %s-bound, allocating.\n",
+				    sa, (tdbp->tdb_flags & EMT_INBOUND) ? "in" : "out");
+
+/* XXX  		tdbp->tdb_rcvif = &(enc_softc[em->em_if].enc_if);*/
+			tdbp->tdb_rcvif = NULL;
+		} else {
+			KLIPS_PRINT(debug_netlink & DB_NL_TDBCB,
+				    "klips_debug:ipsec_callback: EMT_SETSPI found an old Tunnel Descriptor Block\n"
+				    "klips_debug:                for SA: %s, delete it first.\n", sa);
+			SENDERR(EEXIST);
+		}
+		
+		if ((error = tdb_init(tdbp, em))) {
+			KLIPS_PRINT(debug_netlink & DB_NL_TDBCB,
+				    "klips_debug:ipsec_callback: EMT_SETSPI not successful for SA: %s, deleting.\n", sa);
+			ipsec_tdbwipe(tdbp);
+			
+			SENDERR(-error);
+		}
+
+		tdbp->tdb_lifetime_addtime_c = jiffies/HZ;
+		tdbp->tdb_state = 1;
+		if(!tdbp->tdb_lifetime_allocations_c) {
+			tdbp->tdb_lifetime_allocations_c += 1;
+		}
+
+		puttdb(tdbp);
+		KLIPS_PRINT(debug_netlink & DB_NL_TDBCB,
+			    "klips_debug:ipsec_callback: EMT_SETSPI successful for SA: %s\n", sa);
+		break;
+		
+	case EMT_DELSPI:
+		if (em->em_if >= 5)	/* XXX -- why 5? */
+			SENDERR(ENODEV);
+		
+		spin_lock_bh(&tdb_lock);
+		
+		tdbp = gettdb(&(em->em_said));
+		if (tdbp == NULL) {
+			KLIPS_PRINT(debug_netlink & DB_NL_TDBCB,
+				    "klips_debug:ipsec_callback: "
+				    "EMT_DELSPI Tunnel Descriptor Block not found for SA:\n"
+				    "klips_debug:                %s, could not delete.\n", sa);
+			spin_unlock_bh(&tdb_lock);
+			SENDERR(ENXIO);  /* XXX -- wrong error message... */
+		} else {
+			if((error = deltdbchain(tdbp))) {
+				spin_unlock_bh(&tdb_lock);
+				SENDERR(-error);
+			}
+		}
+		spin_unlock_bh(&tdb_lock);
+
+		break;
+		
+	case EMT_GRPSPIS:
+		nspis = (len - EMT_GRPSPIS_FLEN) / sizeof(em->em_rel[0]);
+		if ((nspis * (sizeof(em->em_rel[0]))) != (len - EMT_GRPSPIS_FLEN)) {
+			printk("klips_debug:ipsec_callback: EMT_GRPSPI message size incorrect, expected nspis(%d)*%d, got %d.\n",
+			       nspis,
+			       sizeof(em->em_rel[0]),
+			       (len - EMT_GRPSPIS_FLEN));
+			SENDERR(EINVAL);
+			break;
+		}
+		
+		spin_lock_bh(&tdb_lock);
+
+		for (i = 0; i < nspis; i++) {
+			KLIPS_PRINT(debug_netlink,
+				    "klips_debug:ipsec_callback: EMT_GRPSPI for SA(%d)\n"
+				    "klips_debug:                %s,\n", i, sa);
+			if ((tdbp = gettdb(&(em->em_rel[i].emr_said))) == NULL) {
+				KLIPS_PRINT(debug_netlink,
+					    "klips_debug:ipsec_callback: "
+					    "EMT_GRPSPI Tunnel Descriptor Block not found for SA:\n"
+					    "klips_debug:                %s, could not group.\n", sa);
+				spin_unlock_bh(&tdb_lock);
+				SENDERR(ENXIO);
+			} else {
+				if(tdbp->tdb_inext || tdbp->tdb_onext) {
+					KLIPS_PRINT(debug_netlink,
+						    "klips_debug:ipsec_callback: "
+						    "EMT_GRPSPI Tunnel Descriptor Block already grouped\n"
+						    "klips_debug:                for SA: %s, can't regroup.\n", sa);
+					spin_unlock_bh(&tdb_lock);
+					SENDERR(EBUSY);
+				}
+				em->em_rel[i].emr_tdb = tdbp;
+			}
+		}
+		tprev = em->em_rel[0].emr_tdb;
+		tprev->tdb_inext = NULL;
+		for (i = 1; i < nspis; i++) {
+			tdbp = em->em_rel[i].emr_tdb;
+			tprev->tdb_onext = tdbp;
+			tdbp->tdb_inext = tprev;
+			tprev = tdbp;
+		}
+		tprev->tdb_onext = NULL;
+
+		spin_unlock_bh(&tdb_lock);
+
+		error = 0;
+		break;
+		
+	case EMT_UNGRPSPIS:
+		if (len != (8 + (sizeof(struct sa_id) + sizeof(struct tdb *)) /* 12 */) ) {
+			printk("klips_debug:ipsec_callback: "
+			       "EMT_UNGRPSPIS message size incorrect, expected %d, got %d.\n",
+			       8 + (sizeof(struct sa_id) + sizeof(struct tdb *)),
+				    len);
+			SENDERR(EINVAL);
+			break;
+		}
+		
+		spin_lock_bh(&tdb_lock);
+
+		if ((tdbp = gettdb(&(em->em_rel[0].emr_said))) == NULL) {
+			KLIPS_PRINT(debug_netlink,
+				    "klips_debug:ipsec_callback: "
+				    "EMT_UGRPSPI Tunnel Descriptor Block not found for SA:\n"
+				    "klips_debug:                %s, could not ungroup.\n", sa);
+			spin_unlock_bh(&tdb_lock);
+			SENDERR(ENXIO);
+		}
+		while(tdbp->tdb_onext) {
+			tdbp = tdbp->tdb_onext;
+		}
+		while(tdbp->tdb_inext) {
+			tprev = tdbp;
+			tdbp = tdbp->tdb_inext;
+			tprev->tdb_inext = NULL;
+			tdbp->tdb_onext = NULL;
+		}
+
+		spin_unlock_bh(&tdb_lock);
+
+		break;
+		
+	case EMT_CLRSPIS:
+		KLIPS_PRINT(debug_netlink,
+			    "klips_debug:ipsec_callback: spi clear called.\n");
+		if (em->em_if >= 5)	/* XXX -- why 5? */
+			SENDERR(ENODEV);
+		ipsec_tdbcleanup(0);
+		break;
+	default:
+		KLIPS_PRINT(debug_netlink,
+			    "klips_debug:ipsec_callback: unknown message type\n");
+		SENDERR(EINVAL);
+	}
+ errlab:
+#ifdef NET_21
+	kfree_skb(skb);
+#else /* NET_21 */
+	kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+	return len;
+}
+#endif
+
+/*
+ * $Log$
+ * Revision 1.47  2000/11/06 04:32:08  rgb
+ * Ditched spin_lock_irqsave in favour of spin_lock_bh.
+ *
+ * Revision 1.46  2000/09/08 19:16:50  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Removed all references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.45  2000/08/30 05:23:55  rgb
+ * Compiler-define out ipsec_callback() function of ipsec_netlink.c.
+ * Nothing should be using it anyways.
+ *
+ * Revision 1.44  2000/03/16 14:01:26  rgb
+ * Indented headers for readability.
+ *
+ * Revision 1.43  2000/03/16 07:13:04  rgb
+ * Hardcode PF_KEYv2 support.
+ * Disable NET_LINK support.
+ *
+ * Revision 1.42  2000/01/21 06:14:27  rgb
+ * Moved debug message for expected output on set or clear.
+ *
+ * Revision 1.41  1999/12/01 22:14:37  rgb
+ * Added debugging message for bad netlink magic.
+ * Initialise tdb_sastate to MATURE (1).
+ * Added UNGRPSPIS bad length debugging message.
+ *
+ * Revision 1.40  1999/11/23 23:06:25  rgb
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.39  1999/11/18 04:09:18  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.38  1999/11/17 15:53:39  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.37  1999/10/26 13:58:32  rgb
+ * Put spinlock flags variable declaration outside the debug compiler
+ * directive to enable compilation with debug shut off.
+ *
+ * Revision 1.36  1999/10/16 18:24:22  rgb
+ * Initialize lifetime_addtime_c and lifetime_allocations_c.
+ * Clean-up unused cruft.
+ *
+ * Revision 1.35  1999/10/08 18:37:34  rgb
+ * Fix end-of-line spacing to sate whining PHMs.
+ *
+ * Revision 1.34  1999/10/03 18:49:11  rgb
+ * Spinlock fixes for 2.0.xx and 2.3.xx.
+ *
+ * Revision 1.33  1999/10/01 15:44:53  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.32  1999/10/01 00:00:53  rgb
+ * Fix for proper netlink debugging operation.
+ * Added tdb structure locking.
+ * Minor formatting changes.
+ *
+ * Revision 1.31  1999/05/25 21:21:43  rgb
+ * Fix deltdbchain() error return code checking.
+ *
+ * Revision 1.30  1999/05/09 03:25:36  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.29  1999/05/08 21:23:27  rgb
+ * Simplify satoa() calling.
+ * Fix error return reporting.
+ * Add casting to silence the 2.2.x compile.
+ *
+ * Revision 1.28  1999/05/05 22:02:31  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.27  1999/04/29 15:16:24  rgb
+ * Add pfkey support to debugging.
+ * Change gettdb parameter to a pointer to reduce stack loading and
+ * facilitate
+ * parameter sanity checking.
+ * Add IS_MYADDR support obviating the necessity of doing this in user
+ * space.
+ * Fix undetected bug by moving puttdb in SETSPI until after initialisation
+ * to
+ * prevent tdb usage before it is ready and to save work if it does not
+ * initialise.
+ * Clean up deltdb/wipe code.
+ * Fix undetected bug of returning error as positive value.
+ * Add a parameter to tdbcleanup to be able to delete a class of SAs.
+ *
+ * Revision 1.26  1999/04/16 15:39:35  rgb
+ * Fix already fixed unbalanced #endif.
+ *
+ * Revision 1.25  1999/04/15 15:37:24  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.21.2.1  1999/04/13 20:30:26  rgb
+ * Add experimental 'getdebug'.
+ *
+ * Revision 1.24  1999/04/11 00:28:58  henry
+ * GPL boilerplate
+ *
+ * Revision 1.23  1999/04/07 17:44:21  rgb
+ * Fix ipsec_callback memory leak, skb not freed after use.
+ *
+ * Revision 1.22  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.21  1999/02/17 16:50:11  rgb
+ * Consolidate satoa()s for space and speed efficiency.
+ * Convert DEBUG_IPSEC to KLIPS_PRINT
+ * Clean out unused cruft.
+ *
+ * Revision 1.20  1999/01/28 23:20:49  rgb
+ * Replace hard-coded numbers in macros and code with meaningful values
+ * automatically generated from sizeof() and offsetof() to further the
+ * goal of platform independance.
+ *
+ * Revision 1.19  1999/01/26 02:07:07  rgb
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ * Remove ah/esp switching on include files.
+ * Removed dead code.
+ *
+ * Revision 1.18  1999/01/22 06:20:36  rgb
+ * Cruft clean-out.
+ * 64-bit clean-up.
+ * Added algorithm switch code.
+ *
+ * Revision 1.17  1998/12/02 03:09:39  rgb
+ * Clean up debug printing conditionals to compile with debugging off.
+ *
+ * Revision 1.16  1998/12/01 05:56:57  rgb
+ * Add support for debug printing of version info.
+ * Fail on unknown error for breakroute in replace command.
+ *
+ * Revision 1.15  1998/11/30 13:22:54  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.14  1998/11/10 05:36:14  rgb
+ * Clean up debug output.
+ * Add direction to spi setup debug code.
+ * Add support for SA direction flag.
+ *
+ * Revision 1.13  1998/10/31 06:51:56  rgb
+ * Get zeroize to return something useful.
+ * Clean up code to isolate 'spi --add/del' memory leak.
+ * Fixed up comments in #endif directives.
+ *
+ * Revision 1.12  1998/10/27 00:35:02  rgb
+ * Supressed debug output during normal operation.
+ *
+ * Revision 1.11  1998/10/25 02:40:21  rgb
+ * Selective debug printing, depending upon called service.
+ * Institute more precise error return codes from eroute commands.
+ * Fix bug in size of stucture passed in from user space for grpspi command.
+ *
+ * Revision 1.10  1998/10/22 06:44:58  rgb
+ * Convert to use satoa for printk.
+ * Moved break; in 'set debug level code to avoid undetected bug.
+ * Fixed run-on error message to fit 80 columns.
+ *
+ * Revision 1.9  1998/10/19 14:44:28  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.8  1998/10/09 04:29:51  rgb
+ * Added support for '-replace' option to eroute.
+ * Fixed spiungroup bug.
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ *
+ * Revision 1.7  1998/08/12 00:10:06  rgb
+ * Fixed minor error return code syntax.
+ *
+ * Revision 1.6  1998/07/29 20:22:57  rgb
+ * Cosmetic cleanup.
+ *
+ * Revision 1.5  1998/07/27 21:53:11  rgb
+ * Check for proper return code from eroute clear command.
+ * Use appropriate error return codes from kernel.
+ * Add an option to clear the SA table.
+ *
+ * Revision 1.4  1998/07/14 18:02:40  rgb
+ * Add a command to clear the eroute table.
+ * Clean up some error codes.
+ *
+ * Revision 1.3  1998/06/25 19:52:33  rgb
+ * Code cosmetic changes only.
+ *
+ * Revision 1.2  1998/06/23 02:57:58  rgb
+ * Clean up after an error condition in setspi.
+ *
+ * Revision 1.9  1998/06/18 21:29:06  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid kernel
+ * build scripts happier in presence of symbolic links
+ *
+ * Revision 1.8  1998/06/08 17:57:15  rgb
+ * Very minor spacing change.
+ *
+ * Revision 1.7  1998/05/18 21:46:45  rgb
+ * Clean up for numerical consistency of output.
+ *
+ * Added debugging switch output.
+ *
+ * SETSPI will refuse to overwrite a previous SA.  This is to make it
+ * consistent with the eroute command.
+ *
+ * spidel now deletes entire chain of spi's.
+ *
+ * spigrp can now ungroup a set of spi's.
+ *
+ * spigrp will not regroup a previously grouped spi.
+ *
+ * Key data is properly cleaned up, ie. zeroed.
+ *
+ * Revision 1.6  1998/05/07 20:36:27  rgb
+ * Fixed case where debugging not enabled that caused ipsec_netlink.c to
+ * not compile.
+ *
+ * Revision 1.5  1998/05/06 03:34:21  rgb
+ * Updated debugging output statements.
+ *
+ * Revision 1.4  1998/04/23 21:03:59  rgb
+ * Completed kernel development for userspace access to klips kernel debugging
+ * switches.
+ * Added detail to the kernel error message when trying to group non-existant
+ * spi's.
+ *
+ * Revision 1.3  1998/04/21 21:29:06  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:23  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:08  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_netlink.h linux/net/ipsec/ipsec_netlink.h
--- linux-noipsec/net/ipsec/ipsec_netlink.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_netlink.h	Tue Oct 10 22:10:18 2000
@@ -0,0 +1,330 @@
+/*
+ * IPSEC <> netlink interface
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include <linux/stddef.h>
+
+#ifndef NETLINK_IPSEC
+#define NETLINK_IPSEC          10      /* IPSEC */ 
+#endif /* !NETLINK_IPSEC */
+
+#define EM_MAXRELSPIS	4		/* at most five chained xforms */
+#define EM_MAGIC	0x5377616e	/* "Swan" */
+
+#define EMT_IFADDR	1	/* set enc if addr */
+#define EMT_SETSPI	2	/* Set SPI properties */
+#define EMT_DELSPI	3	/* Delete an SPI */
+#define EMT_GRPSPIS	4	/* Group SPIs (output order)  */
+#define EMT_SETEROUTE	5	/* set an extended route */
+#define EMT_DELEROUTE	6	/* del an extended route */
+#define EMT_TESTROUTE	7	/* try to find route, print to console */
+#define EMT_SETDEBUG	8	/* set debug level if active */
+#define EMT_UNGRPSPIS	9	/* UnGroup SPIs (output order)  */
+#define EMT_CLREROUTE	10	/* clear the extended route table */
+#define EMT_CLRSPIS	11	/* clear the spi table */
+#define EMT_RPLACEROUTE	12	/* set an extended route */
+#define EMT_GETDEBUG	13	/* get debug level if active */
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define DB_NL_TDBCB	0x0001
+#endif /* CONFIG_IPSEC_DEBUG */
+
+/* em_flags constants */
+/* be mindful that this flag conflicts with SADB_SAFLAGS_PFS in pfkeyv2 */
+/* perhaps it should be moved... */
+#define EMT_INBOUND	0x01	/* SA direction, 1=inbound */
+
+struct encap_msghdr
+{
+	__u32	em_magic;		/* EM_MAGIC */
+#if 0
+	__u16	em_msglen;		/* message length */
+#endif
+	__u8	em_msglen;		/* message length */
+	__u8	em_flags;		/* message flags */
+	__u8	em_version;		/* for future expansion */
+	__u8	em_type;		/* message type */
+	union
+	{
+		__u8	C;		/* Free-text */
+		
+		struct 
+		{
+			struct sa_id Said; /* SA ID */
+			struct sockaddr_encap Eaddr;
+			struct sockaddr_encap Emask;
+		} Ert;
+
+		struct
+		{
+			struct in_addr Ia;
+			__u8	Ifn;
+			__u8  xxx[3];	/* makes life a lot easier */
+		} Ifa;
+
+		struct
+		{
+			struct sa_id Said; /* SA ID */
+			int If;		/* enc i/f for input */
+			int Alg;	/* Algorithm to use */
+
+                        /* The following union is a surrogate for
+                         * algorithm-specific data.  To insure
+                         * proper alignment, worst-case fields
+                         * should be included.  It would be even
+                         * better to include the types that will
+                         * actually be used, but they may not be
+                         * defined for each use of this header.
+                         * The actual length is expected to be longer
+                         * than is declared here.  References are normally
+                         * made using the em_dat macro, as if it were a
+                         * field name.
+                         */
+                        union { /* Data */
+                                __u8 Dat[1];
+                                __u64 Datq[1];  /* maximal alignment (?) */
+                        } u;
+		} Xfm;
+		
+		struct
+		{
+			struct sa_id emr_said; /* SA ID */
+			struct tdb * emr_tdb; /* used internally! */
+			
+		} Rel[EM_MAXRELSPIS];
+		
+#ifdef CONFIG_IPSEC_DEBUG
+		struct
+		{
+			int debug_tunnel;
+			int debug_netlink;
+			int debug_xform;
+			int debug_eroute;
+			int debug_spi;
+			int debug_radij;
+			int debug_esp;
+			int debug_ah;
+			int debug_rcv;
+			int debug_pfkey;
+			int debug_ipcomp;
+			int debug_verbose;
+		} Dbg;
+#endif /* CONFIG_IPSEC_DEBUG */
+	} Eu;
+};
+
+#define EM_MINLEN	offsetof(struct encap_msghdr, Eu)
+#define EMT_SETSPI_FLEN	offsetof(struct encap_msghdr, em_dat)
+#define EMT_GRPSPIS_FLEN offsetof(struct encap_msghdr, Eu.Rel)
+#define EMT_SETDEBUG_FLEN (offsetof(struct encap_msghdr, Eu.Dbg + \
+			sizeof(((struct encap_msghdr*)0)->Eu.Dbg)))
+
+#define em_c	Eu.C
+#define em_eaddr Eu.Ert.Eaddr
+#define em_emask Eu.Ert.Emask
+#define em_ersaid Eu.Ert.Said
+#define em_erdst Eu.Ert.Said.dst
+#define em_erspi Eu.Ert.Said.spi
+#define em_erproto Eu.Ert.Said.proto
+
+#define em_ifa	Eu.Ifa.Ia
+#define em_ifn	Eu.Ifa.Ifn
+
+#define em_said	Eu.Xfm.Said
+#define em_spi	Eu.Xfm.Said.spi
+#define em_dst	Eu.Xfm.Said.dst
+#define em_proto	Eu.Xfm.Said.proto
+#define em_if	Eu.Xfm.If
+#define em_alg	Eu.Xfm.Alg
+#define em_dat	Eu.Xfm.u.Dat
+
+#define em_rel	Eu.Rel
+#define emr_dst emr_said.dst
+#define emr_spi emr_said.spi
+#define emr_proto emr_said.proto
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define em_db_tn Eu.Dbg.debug_tunnel
+#define em_db_nl Eu.Dbg.debug_netlink
+#define em_db_xf Eu.Dbg.debug_xform
+#define em_db_er Eu.Dbg.debug_eroute
+#define em_db_sp Eu.Dbg.debug_spi
+#define em_db_rj Eu.Dbg.debug_radij
+#define em_db_es Eu.Dbg.debug_esp
+#define em_db_ah Eu.Dbg.debug_ah
+#define em_db_rx Eu.Dbg.debug_rcv
+#define em_db_ky Eu.Dbg.debug_pfkey
+#define em_db_gz Eu.Dbg.debug_ipcomp
+#define em_db_vb Eu.Dbg.debug_verbose
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef __KERNEL__
+extern char ipsec_netlink_c_version[];
+#ifndef KERNEL_VERSION
+#  include <linux/version.h>
+#endif
+#ifdef NETLINK_SOCK
+extern int ipsec_callback(int proto, struct sk_buff *skb);
+#else /* NETLINK_SOCK */
+extern int ipsec_callback(struct sk_buff *skb);
+#endif /* NETLINK_SOCK */
+extern void ipsec_print_ip(struct iphdr *ip);
+
+#ifdef CONFIG_IPSEC_DEBUG
+	#define KLIPS_PRINT(flag, format, args...) \
+		((flag) ? printk(KERN_INFO format , ## args) : 0)
+	#define KLIPS_PRINTMORE(flag, format, args...) \
+		((flag) ? printk(format , ## args) : 0)
+	#define KLIPS_IP_PRINT(flag, ip) \
+		((flag) ? ipsec_print_ip(ip) : 0)
+#else /* CONFIG_IPSEC_DEBUG */
+	#define KLIPS_PRINT(flag, format, args...) do ; while(0)
+	#define KLIPS_PRINTMORE(flag, format, args...) do ; while(0)
+	#define KLIPS_IP_PRINT(flag, ip) do ; while(0)
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_netlink;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* __KERNEL__ */
+
+/*
+ * $Log$
+ * Revision 1.28  2000/10/10 20:10:18  rgb
+ * Added support for debug_ipcomp and debug_verbose to klipsdebug.
+ *
+ * Revision 1.27  2000/09/12 03:20:28  rgb
+ * Cleared out now unused pfkeyv2 switch.
+ *
+ * Revision 1.26  2000/09/08 19:16:50  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Removed all references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.25  2000/08/24 16:51:59  rgb
+ * Added KLIPS_PRINTMORE macro to continue lines without KERN_INFO level
+ * info.
+ *
+ * Revision 1.24  2000/08/09 20:43:34  rgb
+ * Fixed bitmask value for SADB_X_SAFLAGS_CLEAREROUTE.
+ *
+ * Revision 1.23  2000/03/16 14:01:48  rgb
+ * Hardwired CONFIG_IPSEC_PFKEYv2 on.
+ *
+ * Revision 1.22  1999/12/08 20:31:32  rgb
+ * Moved IPPROTO_COMP to lib/freeswan.h to simplify userspace includes.
+ *
+ * Revision 1.21  1999/11/18 18:47:41  rgb
+ * Added "#define NETLINK_IPSEC" in case kernel was not compiled with it.
+ *
+ * Revision 1.20  1999/11/18 04:09:18  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.19  1999/08/28 08:27:05  rgb
+ * Add a temporary kludge for 2.0.37-38 to compile even if one patch failed.
+ *
+ * Revision 1.18  1999/08/03 17:09:33  rgb
+ * Tidy up debug output, use KERN_INFO macro in printk's.
+ *
+ * Revision 1.17  1999/05/25 01:45:37  rgb
+ * Fix version macros for 2.0.x as a module.
+ *
+ * Revision 1.16  1999/05/05 22:02:31  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.15  1999/04/29 15:16:55  rgb
+ * Add pfkey support to debugging.
+ *
+ * Revision 1.14  1999/04/15 15:37:24  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.13  1999/04/11 00:28:58  henry
+ * GPL boilerplate
+ *
+ * Revision 1.12  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.11  1999/02/12 21:13:17  rgb
+ * Moved KLIPS_PRINT into a more accessible place.
+ *
+ * Revision 1.10  1999/01/28 23:20:49  rgb
+ * Replace hard-coded numbers in macros and code with meaningful values
+ * automatically generated from sizeof() and offsetof() to further the
+ * goal of platform independance.
+ *
+ * Revision 1.9  1999/01/22 06:21:23  rgb
+ * Added algorithm switch code.
+ * Cruft clean-out.
+ * 64-bit clean-up.
+ *
+ * Revision 1.8  1998/12/01 05:57:42  rgb
+ * Add support for printing debug version info.
+ *
+ * Revision 1.7  1998/11/10 05:37:35  rgb
+ * Add support for SA direction flag.
+ *
+ * Revision 1.6  1998/10/25 02:40:45  rgb
+ * Fix bug in size of stucture passed in from user space for grpspi command.
+ *
+ * Revision 1.5  1998/10/19 14:44:29  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.4  1998/10/09 04:30:11  rgb
+ * Added support for '-replace' option to eroute.
+ *
+ * Revision 1.3  1998/07/27 21:54:22  rgb
+ * Rearrange structures for consistent alignment within a union.
+ * Add an option for clearing SA table.
+ *
+ * Revision 1.2  1998/07/14 18:05:51  rgb
+ * Added #ifdef __KERNEL__ directives to restrict scope of header.
+ *
+ * Revision 1.1  1998/06/18 21:27:49  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.4  1998/05/18 21:48:24  rgb
+ * Added switch for ungrouping spi's.
+ *
+ * Revision 1.3  1998/04/23 21:01:50  rgb
+ * Added a macro for userspace access to klips kernel debugging switches.
+ *
+ * Revision 1.2  1998/04/21 21:29:09  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.1  1998/04/09 03:06:09  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:03  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_radij.c linux/net/ipsec/ipsec_radij.c
--- linux-noipsec/net/ipsec/ipsec_radij.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_radij.c	Mon Nov  6 05:32:08 2000
@@ -0,0 +1,510 @@
+/*
+ * Interface between the IPSEC code and the radix (radij) tree code
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+#ifdef SPINLOCK_23
+#include <linux/spinlock.h> /* *lock* */
+#else /* 23_SPINLOCK */
+#include <asm/spinlock.h> /* *lock* */
+#endif /* 23_SPINLOCK */
+#endif /* SPINLOCK */
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#endif
+#include <asm/checksum.h>
+#include <net/ip.h>
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_radij = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+struct radij_node_head *rnh = 0;
+#ifdef SPINLOCK
+spinlock_t eroute_lock = SPIN_LOCK_UNLOCKED;
+#else /* SPINLOCK */
+spinlock_t eroute_lock;
+#endif /* SPINLOCK */
+
+int
+ipsec_radijinit(void)
+{
+	maj_keylen = sizeof (struct sockaddr_encap);
+
+	rj_init();
+	
+	if (rj_inithead((void **)&rnh, 16) == 0) /* 16 is bit offset of sen_type */
+		return -1;
+	return 0;
+}
+
+int
+ipsec_radijcleanup(void)
+{
+	int error;
+
+	spin_lock_bh(&eroute_lock);
+
+	error = radijcleanup();
+
+	spin_unlock_bh(&eroute_lock);
+
+	return error;
+}
+
+int
+ipsec_cleareroutes(void)
+{
+	int error;
+
+	spin_lock_bh(&eroute_lock);
+
+	error = radijcleartree();
+
+	spin_unlock_bh(&eroute_lock);
+
+	return error;
+}
+
+int
+ipsec_breakroute(struct sockaddr_encap *eaddr, struct sockaddr_encap *emask)
+{
+	struct radij_node *rn;
+	int error;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[64], buf2[64];
+	
+	if (debug_eroute) {
+		subnettoa(eaddr->sen_ip_src, emask->sen_ip_src, 0, buf1, sizeof(buf1));
+		subnettoa(eaddr->sen_ip_dst, emask->sen_ip_dst, 0, buf2, sizeof(buf2));
+		printk("klips_debug:ipsec_breakroute: attempting to delete eroute for %s->%s\n",
+			       buf1, buf2);
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	spin_lock_bh(&eroute_lock);
+
+	if ((error = rj_delete(eaddr, emask, rnh, &rn)) != 0) {
+		spin_unlock_bh(&eroute_lock);
+		KLIPS_PRINT(debug_eroute, "klips_debug:ipsec_breakroute: "
+			    "node not found, eroute delete failed.\n");
+		return error;
+	}
+
+	spin_unlock_bh(&eroute_lock);
+	
+	if (rn->rj_flags & (RJF_ACTIVE | RJF_ROOT))
+		panic ("ipsec_breakroute RMT_DELEROUTE root or active node\n");
+	
+	memset((caddr_t)rn, 0, sizeof (struct eroute));
+	kfree(rn);
+	
+	return 0;
+}
+
+int
+ipsec_makeroute(struct sockaddr_encap *eaddr, struct sockaddr_encap *emask, struct sa_id said)
+{
+	struct eroute *retrt;
+	int error;
+	char sa[SATOA_BUF];
+	size_t sa_len;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[64], buf2[64];
+	
+	if (debug_eroute) {
+		subnettoa(eaddr->sen_ip_src, emask->sen_ip_src, 0, buf1, sizeof(buf1));
+		subnettoa(eaddr->sen_ip_dst, emask->sen_ip_dst, 0, buf2, sizeof(buf2));
+		sa_len = satoa(said, 0, sa, SATOA_BUF);
+		printk("klips_debug:ipsec_makeroute: attempting to insert eroute for %s->%s, SA: %s\n",
+		       buf1, buf2, sa);
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	retrt = (struct eroute *)kmalloc(sizeof (struct eroute), GFP_ATOMIC);
+	if (retrt == NULL) {
+		printk("klips_error:ipsec_makeroute: not able to allocate kernel memory");
+		return ENOMEM;
+	}
+	memset((caddr_t)retrt, 0, sizeof (struct eroute));
+
+	retrt->er_eaddr = *eaddr;
+	retrt->er_emask = *emask;
+	retrt->er_said = said;
+	rd_key((&(retrt->er_rjt))) = &(retrt->er_eaddr);
+	
+	spin_lock_bh(&eroute_lock);
+
+	error = rj_addroute(&(retrt->er_eaddr), &(retrt->er_emask), 
+			 rnh, retrt->er_rjt.rd_nodes);
+
+	spin_unlock_bh(&eroute_lock);
+	
+	if(error) {
+		sa_len = satoa(said, 0, sa, SATOA_BUF);
+		printk("klips_debug:ipsec_makeroute: rj_addroute not able to insert eroute for SA:%s\n", sa);
+		kfree(retrt); /* XXX -- should we? */
+		return error;
+	}
+	KLIPS_PRINT(debug_eroute,
+		    "klips_debug:ipsec_makeroute: succeeded, I think...\n");
+	return 0;
+}
+
+struct eroute *
+ipsec_findroute(struct sockaddr_encap *eaddr)
+{
+	struct radij_node *rn;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[ADDRTOA_BUF], buf2[ADDRTOA_BUF];
+	
+	if (debug_radij & DB_RJ_FINDROUTE) {
+		addrtoa(eaddr->sen_ip_src, 0, buf1, sizeof(buf1));
+		addrtoa(eaddr->sen_ip_dst, 0, buf2, sizeof(buf2));
+		printk("klips_debug:ipsec_findroute: %s->%s\n",
+		       buf1, buf2);
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+	rn = rj_match((caddr_t)eaddr, rnh);
+	return (struct eroute *)rn;
+}
+		
+#ifdef CONFIG_PROC_FS
+int
+ipsec_rj_walker_procprint(struct radij_node *rn, void *w0)
+{
+	struct eroute *ro = (struct eroute *)rn;
+	struct rjtentry *rd = (struct rjtentry *)rn;
+	struct wsbuf *w = (struct wsbuf *)w0;
+	char buf1[64], buf2[64];
+	char sa[SATOA_BUF];
+	size_t sa_len;
+	struct sockaddr_encap *key, *mask;
+	
+	KLIPS_PRINT(debug_radij,
+		    "klips_debug:ipsec_rj_walker_procprint: rn=%p, w0=%p\n",
+		    rn, w0);
+	if (rn == NULL)	{
+		return 120;
+	}
+	
+	if (rn->rj_b >= 0) {
+		return 0;
+	}
+	
+	key = rd_key(rd);
+	mask = rd_mask(rd);
+	
+	if ((key == 0) || (mask == 0)) {
+		return 0;
+	}
+	
+	subnettoa(key->sen_ip_src, mask->sen_ip_src, 0, buf1, sizeof(buf1));
+	subnettoa(key->sen_ip_dst, mask->sen_ip_dst, 0, buf2, sizeof(buf2));
+	sa_len = satoa(ro->er_said, 0, sa, SATOA_BUF);
+	w->len += sprintf(w->buffer + w->len,
+			  "%-18s -> %-18s => %s\n",
+			  buf1, buf2, sa);
+	
+	w->pos = w->begin + w->len;
+	if(w->pos < w->offset) {
+		w->len = 0;
+		w->begin = w->pos;
+	}
+	if (w->pos > w->offset + w->length) {
+		return -ENOBUFS;
+	}
+	return 0;
+}
+#endif          /* CONFIG_PROC_FS */
+
+int
+ipsec_rj_walker_delete(struct radij_node *rn, void *w0)
+{
+	struct rjtentry *rd = (struct rjtentry *)rn;
+	struct radij_node *rn2;
+	int error;
+	struct sockaddr_encap *key, *mask;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[64] = { 0 }, buf2[64] = { 0 };
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	if (rn == NULL)	{
+		return 120;
+	}
+	
+	key = rd_key(rd);
+	mask = rd_mask(rd);
+	
+	if(!key || !mask) {
+		return -1;
+	}
+#ifdef CONFIG_IPSEC_DEBUG
+	if(debug_radij)	{
+		subnettoa(key->sen_ip_src, mask->sen_ip_src, 0, buf1, sizeof(buf1));
+		subnettoa(key->sen_ip_dst, mask->sen_ip_dst, 0, buf2, sizeof(buf2));
+		printk("klips_debug:ipsec_rj_walker_delete: deleting: %s -> %s\n",
+		       buf1, buf2);
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	if((error = rj_delete(key, mask, rnh, &rn2))) {
+		KLIPS_PRINT(debug_radij,
+			    "klips_debug:ipsec_rj_walker_delete: "
+			    "rj_delete failed with error=%d.\n", error);
+		return error;
+	}
+
+	if(rn2 != rn) {
+		printk("klips_debug:ipsec_rj_walker_delete: tried to delete a different node?!?"
+		       "This should never happen!\n");
+	}
+	memset((caddr_t)rn, 0, sizeof (struct eroute));
+	kfree(rn);
+	
+	return 0;
+}
+
+/*
+ * $Log$
+ * Revision 1.41  2000/11/06 04:32:08  rgb
+ * Ditched spin_lock_irqsave in favour of spin_lock_bh.
+ *
+ * Revision 1.40  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.39  2000/08/30 05:25:20  rgb
+ * Correct debug text in ipsec_breakroute() from incorrect
+ * "ipsec_callback".
+ *
+ * Revision 1.38  2000/07/28 14:58:31  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.37  2000/03/16 14:02:50  rgb
+ * Fixed debug scope to enable compilation with debug off.
+ *
+ * Revision 1.36  2000/01/21 06:14:46  rgb
+ * Added debugging text to ipsec_rj_walker_delete().
+ * Set return code to negative for consistency.
+ *
+ * Revision 1.35  1999/11/23 23:05:24  rgb
+ * Use provided macro ADDRTOA_BUF instead of hardcoded value.
+ *
+ * Revision 1.34  1999/11/18 04:13:56  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ * Added CONFIG_PROC_FS compiler directives in case it is shut off.
+ *
+ * Revision 1.33  1999/11/17 15:53:39  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.32  1999/10/26 13:58:33  rgb
+ * Put spinlock flags variable declaration outside the debug compiler
+ * directive to enable compilation with debug shut off.
+ *
+ * Revision 1.31  1999/10/15 22:13:29  rgb
+ * Clean out cruft.
+ * Align /proc/net/ipsec_eroute output for easier readability.
+ * Fix double linefeed in radij debug output.
+ * Fix double locking bug that locks up 2.0.36 but not 2.0.38.
+ *
+ * Revision 1.30  1999/10/08 18:37:33  rgb
+ * Fix end-of-line spacing to sate whining PHMs.
+ *
+ * Revision 1.29  1999/10/03 18:52:45  rgb
+ * Spinlock support for 2.0.xx.
+ * Dumb return code spin_unlock fix.
+ *
+ * Revision 1.28  1999/10/01 16:22:24  rgb
+ * Switch from assignment init. to functional init. of spinlocks.
+ *
+ * Revision 1.27  1999/10/01 15:44:53  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.26  1999/10/01 00:01:23  rgb
+ * Added eroute structure locking.
+ *
+ * Revision 1.25  1999/06/10 16:07:30  rgb
+ * Silence delete eroute on no debug.
+ *
+ * Revision 1.24  1999/05/09 03:25:36  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.23  1999/05/05 22:02:31  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.22  1999/04/29 15:17:23  rgb
+ * Add return values to init and cleanup functions.
+ * Add sanity checking for null pointer arguments.
+ *
+ * Revision 1.21  1999/04/11 00:28:58  henry
+ * GPL boilerplate
+ *
+ * Revision 1.20  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.19  1999/02/17 16:50:35  rgb
+ * Clean out unused cruft.
+ * Consolidate for space and speed efficiency.
+ * Convert DEBUG_IPSEC to KLIPS_PRINT
+ *
+ * Revision 1.18  1999/01/22 06:22:06  rgb
+ * Cruft clean-out.
+ * 64-bit clean-up.
+ *
+ * Revision 1.17  1998/12/02 03:09:39  rgb
+ * Clean up debug printing conditionals to compile with debugging off.
+ *
+ * Revision 1.16  1998/12/01 13:49:39  rgb
+ * Wrap version info printing in debug switches.
+ *
+ * Revision 1.15  1998/11/30 13:22:54  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.14  1998/10/31 06:48:17  rgb
+ * Fixed up comments in #endif directives.
+ *
+ * Revision 1.13  1998/10/27 13:48:09  rgb
+ * Cleaned up /proc/net/ipsec_* filesystem for easy parsing by scripts.
+ * Fixed less(1) truncated output bug.
+ * Code clean-up.
+ *
+ * Revision 1.12  1998/10/25 02:41:36  rgb
+ * Change return type on ipsec_breakroute and ipsec_makeroute and add an
+ * argument to be able to transmit more infomation about errors.
+ * Fix cut-and-paste debug statement identifier.
+ *
+ * Revision 1.11  1998/10/22 06:45:39  rgb
+ * Cleaned up cruft.
+ * Convert to use satoa for printk.
+ *
+ * Revision 1.10  1998/10/19 14:44:28  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.9  1998/10/09 04:30:52  rgb
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ * Deleted old commented out cruft.
+ *
+ * Revision 1.8  1998/08/06 17:24:23  rgb
+ * Fix addrtoa return code bug from stale manpage advice preventing packets
+ * from being erouted.
+ *
+ * Revision 1.7  1998/08/06 07:44:59  rgb
+ * Fixed /proc/net/ipsec_eroute subnettoa and addrtoa return value bug that
+ * ended up in nothing being printed.
+ *
+ * Revision 1.6  1998/08/05 22:16:41  rgb
+ * Cleanup to prevent cosmetic errors (ie. debug output) from being fatal.
+ *
+ * Revision 1.5  1998/07/29 20:38:44  rgb
+ * Debug and fix subnettoa and addrtoa output.
+ *
+ * Revision 1.4  1998/07/28 00:02:39  rgb
+ * Converting to exclusive use of addrtoa.
+ * Fix eroute delete.
+ *
+ * Revision 1.3  1998/07/14 18:21:26  rgb
+ * Add function to clear the eroute table.
+ *
+ * Revision 1.2  1998/06/23 02:59:14  rgb
+ * Added debugging output to eroute add/delete routines.
+ *
+ * Revision 1.9  1998/06/18 21:29:06  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid kernel
+ * build scripts happier in presence of symbolic links
+ *
+ * Revision 1.8  1998/06/05 02:32:26  rgb
+ * Fix spi ntoh kernel debug output.
+ *
+ * Revision 1.7  1998/05/25 20:30:37  rgb
+ * Remove temporary ipsec_walk, rj_deltree and rj_delnodes functions.
+ *
+ * Rename ipsec_rj_walker (ipsec_walk) to ipsec_rj_walker_procprint and
+ * add ipsec_rj_walker_delete.
+ *
+ * Revision 1.6  1998/05/21 13:08:57  rgb
+ * Rewrote procinfo subroutines to avoid *bad things* when more that 3k of
+ * information is available for printout.
+ *
+ * Revision 1.5  1998/05/18 21:35:55  rgb
+ * Clean up output for numerical consistency and readability.  Zero freed
+ * eroute memory.
+ *
+ * Revision 1.4  1998/04/21 21:28:58  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.3  1998/04/14 17:30:39  rgb
+ * Fix up compiling errors for radij tree memory reclamation.
+ *
+ * Revision 1.2  1998/04/12 22:03:23  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:10  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:03  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_radij.h linux/net/ipsec/ipsec_radij.h
--- linux-noipsec/net/ipsec/ipsec_radij.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_radij.h	Fri Sep  8 21:12:56 2000
@@ -0,0 +1,146 @@
+/*
+ * Definitions relevant to the IPSEC <> radij tree interfacing
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include <freeswan.h>
+
+int ipsec_walk(char *);
+
+int ipsec_rj_walker_procprint(struct radij_node *, void *);
+int ipsec_rj_walker_delete(struct radij_node *, void *);
+
+struct wsbuf
+{
+	char *buffer;
+	int length;
+	off_t offset;
+	int len;
+	int prev_len;
+	off_t begin;
+	off_t pos;
+};
+
+#if 0
+struct eroute * ipsec_makeroute(struct sockaddr_encap *ea, struct sockaddr_encap *em, struct sa_id);
+#endif
+int ipsec_makeroute(struct sockaddr_encap *ea, struct sockaddr_encap *em, struct sa_id);
+
+#if 0
+struct eroute * ipsec_breakroute(struct sockaddr_encap *ea, struct sockaddr_encap *em);
+#endif
+int ipsec_breakroute(struct sockaddr_encap *ea, struct sockaddr_encap *em);
+
+int ipsec_radijinit(void);
+int ipsec_cleareroutes(void);
+int ipsec_radijcleanup(void);
+
+extern struct radij_node_head *rnh;
+extern spinlock_t eroute_lock;
+
+struct eroute * ipsec_findroute(struct sockaddr_encap *);
+
+#define O1(x) (int)(((x)>>24)&0xff)
+#define O2(x) (int)(((x)>>16)&0xff)
+#define O3(x) (int)(((x)>>8)&0xff)
+#define O4(x) (int)(((x))&0xff)
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_radij;
+void rj_dumptrees(void);
+
+#define DB_RJ_DUMPTREES	0x0001
+#define DB_RJ_FINDROUTE 0x0002
+#endif /* CONFIG_IPSEC_DEBUG */
+
+/*
+ * $Log$
+ * Revision 1.11  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.10  1999/11/17 15:53:39  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.9  1999/10/01 00:01:23  rgb
+ * Added eroute structure locking.
+ *
+ * Revision 1.8  1999/04/11 00:28:59  henry
+ * GPL boilerplate
+ *
+ * Revision 1.7  1999/04/06 04:54:26  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.6  1999/01/22 06:23:26  rgb
+ * Cruft clean-out.
+ *
+ * Revision 1.5  1998/10/25 02:42:08  rgb
+ * Change return type on ipsec_breakroute and ipsec_makeroute and add an
+ * argument to be able to transmit more infomation about errors.
+ *
+ * Revision 1.4  1998/10/19 14:44:29  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.3  1998/07/28 00:03:31  rgb
+ * Comment out temporary inet_nto4u() kluge.
+ *
+ * Revision 1.2  1998/07/14 18:22:00  rgb
+ * Add function to clear the eroute table.
+ *
+ * Revision 1.1  1998/06/18 21:27:49  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.5  1998/05/25 20:30:38  rgb
+ * Remove temporary ipsec_walk, rj_deltree and rj_delnodes functions.
+ *
+ * Rename ipsec_rj_walker (ipsec_walk) to ipsec_rj_walker_procprint and
+ * add ipsec_rj_walker_delete.
+ *
+ * Revision 1.4  1998/05/21 13:02:56  rgb
+ * Imported definitions from ipsec_radij.c and radij.c to support /proc 3k
+ * limit fix.
+ *
+ * Revision 1.3  1998/04/21 21:29:09  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/14 17:30:39  rgb
+ * Fix up compiling errors for radij tree memory reclamation.
+ *
+ * Revision 1.1  1998/04/09 03:06:10  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_rcv.c linux/net/ipsec/ipsec_rcv.c
--- linux-noipsec/net/ipsec/ipsec_rcv.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_rcv.c	Sat Nov 25 04:50:36 2000
@@ -0,0 +1,1973 @@
+/*
+ * receive code
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+char ipsec_rcv_c_version[] = "RCSID $Id$";
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#define __NO_VERSION__
+#include <linux/module.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+#ifdef SPINLOCK_23
+#include <linux/spinlock.h> /* *lock* */
+#else /* SPINLOCK_23 */
+#include <asm/spinlock.h> /* *lock* */
+#endif /* SPINLOCK_23 */
+#endif /* SPINLOCK */
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#define proto_priv cb
+#endif /* NET21 */
+#include <asm/checksum.h>
+#include <net/ip.h>
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_tunnel.h"
+#include "ipsec_rcv.h"
+#if defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH)
+#include "ipsec_ah.h"
+#endif /* defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH) */
+#ifdef CONFIG_IPSEC_ESP
+#include "ipsec_esp.h"
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_IPCOMP
+#include "ipcomp.h"
+#endif /* CONFIG_IPSEC_COMP */
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_ah = 0;
+int debug_esp = 0;
+int debug_rcv = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+int sysctl_ipsec_inbound_policy_check = 1;
+
+#ifdef CONFIG_IPSEC_ESP
+extern void des_ede3_cbc_encrypt(caddr_t, caddr_t, int, caddr_t, caddr_t, caddr_t, caddr_t, int);
+#endif /* !CONFIG_IPSEC_ESP */
+#if defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH)
+__u32 zeroes[AH_AMAX];
+#endif /* defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH) */
+
+/*
+ * Check-replay-window routine, adapted from the original 
+ * by J. Hughes, from draft-ietf-ipsec-esp-des-md5-03.txt
+ *
+ *  This is a routine that implements a 64 packet window. This is intend-
+ *  ed on being an implementation sample.
+ */
+
+DEBUG_NO_STATIC int
+ipsec_checkreplaywindow(struct tdb*tdbp, __u32 seq)
+{
+	__u32 diff;
+	
+	if (tdbp->tdb_replaywin == 0)	/* replay shut off */
+		return 1;
+	if (seq == 0) 
+		return 0;		/* first == 0 or wrapped */
+
+	/* new larger sequence number */
+	if (seq > tdbp->tdb_replaywin_lastseq) {
+		return 1;		/* larger is good */
+	}
+	diff = tdbp->tdb_replaywin_lastseq - seq;
+
+	/* too old or wrapped */ /* if wrapped, kill off SA? */
+	if (diff >= tdbp->tdb_replaywin) {
+		return 0;
+	}
+	/* this packet already seen */
+	if (tdbp->tdb_replaywin_bitmap & (1 << diff))
+		return 0;
+	return 1;			/* out of order but good */
+}
+
+DEBUG_NO_STATIC int
+ipsec_updatereplaywindow(struct tdb*tdbp, __u32 seq)
+{
+	__u32 diff;
+	
+	if (tdbp->tdb_replaywin == 0)	/* replay shut off */
+		return 1;
+	if (seq == 0) 
+		return 0;		/* first == 0 or wrapped */
+
+	/* new larger sequence number */
+	if (seq > tdbp->tdb_replaywin_lastseq) {
+		diff = seq - tdbp->tdb_replaywin_lastseq;
+
+		/* In win, set bit for this pkt */
+		if (diff < tdbp->tdb_replaywin)
+			tdbp->tdb_replaywin_bitmap =
+				(tdbp->tdb_replaywin_bitmap << diff) | 1;
+		else
+			/* This packet has way larger seq num */
+			tdbp->tdb_replaywin_bitmap = 1;
+
+		if(seq - tdbp->tdb_replaywin_lastseq - 1 > tdbp->tdb_replaywin_maxdiff) {
+			tdbp->tdb_replaywin_maxdiff = seq - tdbp->tdb_replaywin_lastseq - 1;
+		}
+		tdbp->tdb_replaywin_lastseq = seq;
+		return 1;		/* larger is good */
+	}
+	diff = tdbp->tdb_replaywin_lastseq - seq;
+
+	/* too old or wrapped */ /* if wrapped, kill off SA? */
+	if (diff >= tdbp->tdb_replaywin) {
+/*
+		if(seq < 0.25*max && tdbp->tdb_replaywin_lastseq > 0.75*max) {
+			deltdbchain(tdbp);
+		}
+*/	
+		return 0;
+	}
+	/* this packet already seen */
+	if (tdbp->tdb_replaywin_bitmap & (1 << diff))
+		return 0;
+	tdbp->tdb_replaywin_bitmap |= (1 << diff);	/* mark as seen */
+	return 1;			/* out of order but good */
+}
+
+int
+#ifdef NET_21
+ipsec_rcv(struct sk_buff *skb, unsigned short xlen)
+#else /* NET_21 */
+ipsec_rcv(struct sk_buff *skb, struct device *dev, struct options *opt, 
+		__u32 daddr, unsigned short xlen, __u32 saddr,
+                                   int redo, struct inet_protocol *protocol)
+#endif /* NET_21 */
+{
+#ifdef NET_21
+#ifdef CONFIG_IPSEC_DEBUG
+	struct device *dev = skb->dev;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* NET_21 */
+	unsigned char protoc;
+	struct iphdr *ipp;
+	int authlen = 0;
+#ifdef CONFIG_IPSEC_ESP
+	struct esp *espp = NULL;
+	int esphlen = 0;
+	__u32 iv[2];
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+	struct ah *ahp = NULL;
+	int ahhlen = 0;
+	struct iphdr ipo;
+#endif /* CONFIG_IPSEC_AH */
+	unsigned char *authenticator = NULL;
+	union {
+		MD5_CTX		md5;
+		SHA1_CTX	sha1;
+	} tctx;
+	__u8 hash[AH_AMAX];
+#if defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH)
+#endif /* defined(CONFIG_IPSEC_ESP) || defined(CONFIG_IPSEC_AH) */
+#ifdef CONFIG_IPSEC_IPCOMP
+	struct ipcomphdr*compp = NULL;
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+	int hard_header_len;
+	int iphlen;
+	unsigned char *dat;
+	struct tdb *tdbp = NULL;
+	struct sa_id said;
+	struct net_device_stats *stats = NULL;		/* This device's statistics */
+	struct device *ipsecdev = NULL, *prvdev;
+	struct ipsecpriv *prv;
+	char name[9];
+	char sa[SATOA_BUF];
+	size_t sa_len;
+	char ipaddr_txt[ADDRTOA_BUF];
+	int i;
+	struct in_addr ipaddr;
+	__u8 next_header = 0;
+	__u8 proto;
+	
+#ifdef CONFIG_IPSEC_ESP
+	int pad = 0, padlen;
+#endif /* CONFIG_IPSEC_ESP */
+	int ilen, len, replay = 0;
+	__u8 *idat;
+	struct tdb* tdbprev = NULL;
+	struct tdb* tdbnext = NULL;
+#ifdef INBOUND_POLICY_CHECK_eroute
+	struct sockaddr_encap matcher;	/* eroute search key */
+	struct eroute *er;
+	struct tdb* policy_tdb = NULL;
+	struct sa_id policy_said;
+	struct sockaddr_encap policy_eaddr;
+	struct sockaddr_encap policy_emask;
+#endif /* INBOUND_POLICY_CHECK_eroute */
+
+	/* Don't unlink in the middle of a turnaround */
+	MOD_INC_USE_COUNT;
+	
+	if (skb == NULL) {
+		KLIPS_PRINT(debug_rcv, 
+			    "klips_debug:ipsec_rcv: "
+			    "NULL skb passed in.\n");
+		goto rcvleave;
+	}
+		
+	if (skb->data == NULL) {
+		KLIPS_PRINT(debug_rcv,
+			    "klips_debug:ipsec_rcv: "
+			    "NULL skb->data passed in, packet is bogus, dropping.\n");
+		goto rcvleave;
+	}
+		
+	ipp = (struct iphdr *)skb->data;
+	iphlen = ipp->ihl << 2;
+	/* dev->hard_header_len is unreliable and should not be used */
+	hard_header_len = skb->mac.raw ? (skb->data - skb->mac.raw) : 0;
+	if((hard_header_len < 0) || (hard_header_len > skb_headroom(skb)))
+		hard_header_len = 0;
+
+#ifdef NET_21
+	/* if skb was cloned (most likely due to a packet sniffer such as
+	   tcpdump being momentarily attached to the interface), make
+	   a copy of our own to modify */
+	if(skb_cloned(skb)) {
+		/* include any mac header while copying.. */
+		if(skb_headroom(skb) < hard_header_len) {
+			printk(KERN_WARNING "klips_error:ipsec_rcv: "
+			       "tried to skb_push hhlen=%d, %d available.  "
+			       "This should never happen, please report.\n",
+			       hard_header_len, skb_headroom(skb));
+			goto rcvleave;
+		}
+		skb_push(skb, hard_header_len);
+		if ((skb = skb_cow(skb, skb_headroom(skb))) == NULL) {
+			goto rcvleave;
+		}
+		if(skb->len < hard_header_len) {
+			printk(KERN_WARNING "klips_error:ipsec_rcv: "
+			       "tried to skb_pull hhlen=%d, %d available.  "
+			       "This should never happen, please report.\n",
+			       hard_header_len, skb->len);
+			goto rcvleave;
+		}
+		skb_pull(skb, hard_header_len);
+	}
+	
+#endif /* NET_21 */
+		
+	KLIPS_PRINT(debug_rcv, 
+		    "klips_debug:ipsec_rcv: <<< Info -- ");
+	KLIPS_PRINTMORE(debug_rcv && skb->dev, "skb->dev=%s ",
+		    skb->dev->name ? skb->dev->name : "NULL");
+	KLIPS_PRINTMORE(debug_rcv && dev, "dev=%s ",
+		    dev->name ? dev->name : "NULL");
+	KLIPS_PRINTMORE(debug_rcv, "\n");
+
+	KLIPS_PRINT(debug_rcv && !(skb->dev && dev && (skb->dev == dev)),
+		    "klips_debug:ipsec_rcv: Informational -- "
+		    "**if this happens, find out why** "
+		    "skb->dev:%s is not equal to dev:%s\n",
+		    skb->dev ? (skb->dev->name ? skb->dev->name : "NULL") : "NULL",
+		    dev ? (dev->name ? dev->name : "NULL") : "NULL");
+
+	protoc = ipp->protocol;
+#ifndef NET_21
+	if((!protocol) || (protocol->protocol != protoc)) {
+		KLIPS_PRINT(debug_rcv & DB_RX_TDB,
+			    "klips_debug:ipsec_rcv: "
+			    "protocol arg is NULL or unequal to the packet contents, this is odd, using value in packet.\n");
+	}
+#endif /* !NET_21 */
+
+	if( (protoc != IPPROTO_AH) &&
+#ifdef CONFIG_IPSEC_IPCOMP
+	    (protoc != IPPROTO_COMP) &&
+#endif /* CONFIG_IPSEC_IPCOMP */
+	    (protoc != IPPROTO_ESP) ) {
+		KLIPS_PRINT(debug_rcv & DB_RX_TDB,
+			    "klips_debug:ipsec_rcv: Why the hell is someone "
+			    "passing me a non-ipsec packet? -- dropped.\n");
+		goto rcvleave;
+	}
+
+	if(skb->dev) {
+		for(i = 0; i < IPSEC_NUM_IF; i++) {
+			sprintf(name, "ipsec%d", i);
+			if(!strcmp(name, skb->dev->name)) {
+				prv = (struct ipsecpriv *)(skb->dev->priv);
+				if(prv) {
+					stats = (struct net_device_stats *) &(prv->mystats);
+				}
+				ipsecdev = skb->dev;
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: Info -- pkt "
+					    "already proc'ed a group of ipsec headers, "
+					    "processing next group of ipsec headers.\n");
+				break;
+			}
+			if((ipsecdev = ipsec_dev_get(name)) == NULL) {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_error:ipsec_rcv: device %s does "
+					    "not exist\n", name);
+			}
+			prv = ipsecdev ? (struct ipsecpriv *)(ipsecdev->priv) : NULL;
+			prvdev = prv ? (struct device *)(prv->dev) : NULL;
+			
+			KLIPS_PRINT(debug_rcv && prvdev, 
+				    "klips_debug:ipsec_rcv: physical device"
+				    " for device %s is %s\n",
+				    name, prvdev->name);
+			if(prvdev && skb->dev &&
+			   !strcmp(prvdev->name, skb->dev->name)) {
+				stats = prv ? ((struct net_device_stats *) &(prv->mystats)) : NULL;
+				skb->dev = ipsecdev;
+				if(stats) {
+					stats->rx_packets++;
+				}
+				break;
+			}
+		}
+	} else {
+		KLIPS_PRINT(debug_rcv, 
+			    "klips_debug:ipsec_rcv: device supplied"
+			    " with skb is NULL\n");
+	}
+			
+	if(!stats) {
+		ipsecdev = NULL;
+	}
+	KLIPS_PRINT((debug_rcv && !stats),
+		    "klips_error:ipsec_rcv: packet received from physical "
+		    "I/F (%s) not connected to ipsec I/F.  Cannot record "
+		    "stats.\n"
+		    "klips_error          May not have SA for decoding.  "
+		    "Is IPSEC traffic expected on this I/F?  "
+		    "Check routing.\n",
+		    skb->dev ? (skb->dev->name ? skb->dev->name : "NULL") : "NULL");
+
+	KLIPS_IP_PRINT(debug_rcv, ipp);
+
+	/* begin decapsulating loop here */
+	do {
+		authlen = 0;
+#ifdef CONFIG_IPSEC_ESP
+		espp = NULL;
+		esphlen = 0;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+		ahp = NULL;
+		ahhlen = 0;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_IPCOMP
+		compp = NULL;
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+		len = skb->len;
+		dat = skb->data;
+		ipp = (struct iphdr *)skb->data;
+		proto = ipp->protocol;
+		ipaddr.s_addr = ipp->saddr;
+		addrtoa(ipaddr, 0, ipaddr_txt, sizeof(ipaddr_txt));
+		
+		iphlen = ipp->ihl << 2;
+		ipp->check = 0;			/* we know the sum is good */
+		
+#ifdef CONFIG_IPSEC_ESP
+		/* XXX this will need to be 8 for IPv6 */
+		if ((proto == IPPROTO_ESP) && ((len - iphlen) % 4)) {
+			printk("klips_error:ipsec_rcv: "
+			       "got packet with content length = %d from %s "
+			       "-- should be on 4 octet boundary, packet dropped\n",
+			       len - iphlen, ipaddr_txt);
+			if(stats) {
+				stats->rx_errors++;
+			}
+			goto rcvleave;
+		}
+#endif /* !CONFIG_IPSEC_ESP */
+		
+		/*
+		 * Find tunnel control block and (indirectly) call the
+		 * appropriate tranform routine. The resulting sk_buf
+		 * is a valid IP packet ready to go through input processing.
+		 */
+		
+		said.dst.s_addr = ipp->daddr;
+		switch(proto) {
+#ifdef CONFIG_IPSEC_ESP
+		case IPPROTO_ESP:
+			espp = (struct esp *)(skb->data + iphlen);
+			said.spi = espp->esp_spi;
+			break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+		case IPPROTO_AH:
+			ahp = (struct ah *)(skb->data + iphlen);
+			said.spi = ahp->ah_spi;
+			break;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_IPCOMP
+		case IPPROTO_COMP:
+			compp = (struct ipcomphdr *)(skb->data + iphlen);
+			said.spi = htonl((__u32)ntohs(compp->ipcomp_cpi));
+			break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+		default:
+			if(stats) {
+				stats->rx_errors++;
+			}
+			goto rcvleave;
+		}
+		said.proto = proto;
+		sa_len = satoa(said, 0, sa, SATOA_BUF);
+		
+#ifdef CONFIG_IPSEC_AH
+		if(proto == IPPROTO_AH) {
+			ahhlen = (ahp->ah_hl << 2) +
+				((caddr_t)&(ahp->ah_rpl) - (caddr_t)ahp);
+			next_header = ahp->ah_nh;
+			if (ahhlen != sizeof(struct ah)) {
+				KLIPS_PRINT(debug_rcv & DB_RX_INAU,
+					    "klips_debug:ipsec_rcv: bad "
+					    "authenticator length %d, expected "
+					    "%d from %s\n",
+					    ahhlen - ((caddr_t)(ahp->ah_data) -
+						      (caddr_t)ahp),
+					    AHHMAC_HASHLEN,
+					    ipaddr_txt);
+				if(stats) {
+					stats->rx_errors++;
+				}
+				goto rcvleave;
+			}
+			
+		}
+#endif /* CONFIG_IPSEC_AH */
+		
+		/*
+		 * The spinlock is to prevent any other process from
+		 * accessing or deleting the structure while we are
+		 * using and updating it.
+		 */
+		spin_lock(&tdb_lock);
+		
+#ifdef CONFIG_IPSEC_IPCOMP
+		if (proto == IPPROTO_COMP) {
+			unsigned int flags = 0;
+			if (tdbp == NULL) {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "Incoming packet with outer IPCOMP "
+					    "header SA:%s: not yet supported "
+					    "by KLIPS, dropped\n", sa);
+				if(stats) {
+					stats->rx_dropped++;
+				}
+
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			}
+
+			tdbprev = tdbp;
+			tdbp = tdbnext;
+
+			if(sysctl_ipsec_inbound_policy_check
+			   && ((tdbp == NULL)
+			       || ((tdbp != NULL)
+				   && ((ntohl(tdbp->tdb_said.spi) & 0x0000ffff)
+				       != ntohl(said.spi))))) {
+				char sa2[SATOA_BUF];
+
+				if(tdbp) {
+					sa_len = satoa(tdbp->tdb_said, 0, sa2, SATOA_BUF);
+				}
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "Incoming packet with SA(IPCA):%s "
+					    "does not match policy SA(IPCA):%s "
+					    "cpi=%04x cpi->spi=%08x spi=%08x, spi->cpi=%04x for "
+					    "SA grouping, dropped.\n",
+					    sa,
+					    tdbp ? sa2 : "NULL",
+					    ntohs(compp->ipcomp_cpi),
+					    (__u32)ntohl(said.spi),
+					    tdbp ? (__u32)ntohl((tdbp->tdb_said.spi)) : 0,
+					    tdbp ? (__u16)(ntohl(tdbp->tdb_said.spi) & 0x0000ffff) : 0);
+				if(stats) {
+					stats->rx_dropped++;
+				}
+
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			}
+
+			if (tdbp) {
+				tdbp->tdb_comp_ratio_cbytes += ntohs(ipp->tot_len);
+				tdbnext = tdbp->tdb_inext;
+			}
+			next_header = compp->ipcomp_nh;
+
+			skb = skb_decompress(skb, tdbp, &flags);
+			if (!skb || flags) {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "skb_decompress() returned "
+					    "error flags=%x, dropped.\n",
+					    flags);
+				if (stats) {
+				    if (flags)
+					stats->rx_errors++;
+				    else
+					stats->rx_dropped++;
+				}
+
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			}
+#ifdef NET_21
+			ipp = skb->nh.iph;
+#else /* NET_21 */
+			ipp = skb->ip_hdr;
+#endif /* NET_21 */
+
+			if (tdbp) {
+				tdbp->tdb_comp_ratio_dbytes += ntohs(ipp->tot_len);
+			}
+
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "packet decompressed SA(IPCA):%s "
+				    "cpi->spi=%08x spi=%08x, spi->cpi=%04x, nh=%d.\n",
+				    sa,
+				    (__u32)ntohl(said.spi),
+				    tdbp ? (__u32)ntohl((tdbp->tdb_said.spi)) : 0,
+				    tdbp ? (__u16)(ntohl(tdbp->tdb_said.spi) & 0x0000ffff) : 0,
+				    next_header);
+			KLIPS_IP_PRINT(debug_rcv & DB_RX_PKTRX, ipp);
+
+			continue;
+			/* Skip rest of stuff and decapsulate next inner
+			   packet, if any */
+		}
+#endif /* CONFIG_IPSEC_IPCOMP */
+		
+		tdbp = gettdb(&said);
+		if (tdbp == NULL) {
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: no Tunnel Descriptor "
+				    "Block for SA:%s: incoming packet with no SA "
+				    "dropped\n", sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+
+		if(sysctl_ipsec_inbound_policy_check) {
+			if(ipp->saddr != ((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr.s_addr) {
+				spin_unlock(&tdb_lock);
+				ipaddr.s_addr = ipp->saddr;
+				addrtoa(ipaddr, 0, ipaddr_txt, sizeof(ipaddr_txt));
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s, src=%s of pkt does not agree with expected SA source address policy.\n",
+					    sa, ipaddr_txt);
+				if(stats) {
+					stats->rx_dropped++;
+				}
+				goto rcvleave;
+			}
+			{
+				ipaddr.s_addr = ipp->saddr;
+				addrtoa(ipaddr, 0, ipaddr_txt, sizeof(ipaddr_txt));
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s, src=%s of pkt agrees with expected SA source address policy.\n",
+					    sa, ipaddr_txt);
+			}
+			if(tdbnext) {
+				if(tdbnext != tdbp) {
+					spin_unlock(&tdb_lock);
+					KLIPS_PRINT(debug_rcv,
+						    "klips_debug:ipsec_rcv: "
+						    "unexpected SA:%s: does not agree with tdb->inext policy, dropped\n",
+						    sa);
+					if(stats) {
+						stats->rx_dropped++;
+					}
+					goto rcvleave;
+				}
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s grouping from previous SA is OK.\n",
+					    sa);
+			} else {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s First SA in group.\n",
+					    sa);
+			}
+			
+#if 1
+			if(tdbp->tdb_onext) {
+				if(tdbprev != tdbp->tdb_onext) {
+					spin_unlock(&tdb_lock);
+					KLIPS_PRINT(debug_rcv,
+						    "klips_debug:ipsec_rcv: "
+						    "unexpected SA:%s: does not agree with tdb->onext policy, dropped.\n",
+						    sa);
+					if(stats) {
+						stats->rx_dropped++;
+					}
+					goto rcvleave;
+				} else {
+					KLIPS_PRINT(debug_rcv,
+						    "klips_debug:ipsec_rcv: "
+						    "SA:%s grouping to previous SA is OK.\n",
+						    sa);
+				}
+			} else {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s No previous backlink in group.\n",
+					    sa);
+			}
+#endif
+		}
+		
+		/* If it is in larval state, drop the packet, we cannot process yet. */
+		if(tdbp->tdb_state == SADB_SASTATE_LARVAL) {
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "TDB in larval state, cannot be used yet, "
+				    "dropping packet.\n");
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		
+		if(tdbp->tdb_state == SADB_SASTATE_DEAD) {
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "TDB in dead state, cannot be used any more, "
+				    "dropping packet.\n");
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		
+		if(tdbp->tdb_lifetime_bytes_h &&
+		   (tdbp->tdb_lifetime_bytes_c > tdbp->tdb_lifetime_bytes_h)) {
+			pfkey_expire(tdbp, 1);
+			deltdbchain(tdbp);
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "hard bytes lifetime of SA:%s has been reached, "
+				    "SA expired, incoming packet dropped.\n", sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		if(tdbp->tdb_lifetime_bytes_s &&
+		   (tdbp->tdb_lifetime_bytes_c > tdbp->tdb_lifetime_bytes_s)) {
+			tdbp->tdb_state = SADB_SASTATE_DYING;
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "soft bytes lifetime of SA:%s has been reached, "
+				    "SA expiring, soft expire message sent up, "
+				    "incoming packet still processed.\n", sa);
+			pfkey_expire(tdbp, 0);
+		}
+		
+		if(tdbp->tdb_lifetime_addtime_h &&
+		   ((jiffies / HZ) - tdbp->tdb_lifetime_addtime_c >
+		    tdbp->tdb_lifetime_addtime_h)) {
+			pfkey_expire(tdbp, 1);
+			deltdbchain(tdbp);
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "hard addtime lifetime of SA:%s has been reached, "
+				    "SA expired, incoming packet dropped.\n", sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		if(tdbp->tdb_lifetime_addtime_s &&
+		   ((jiffies / HZ) - tdbp->tdb_lifetime_addtime_c >
+		    tdbp->tdb_lifetime_addtime_s)) {
+			tdbp->tdb_state = SADB_SASTATE_DYING;
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "soft addtime lifetime of SA:%s has been reached, "
+				    "SA expiring, soft expire message sent up, "
+				    "incoming packet still processed.\n", sa);
+			pfkey_expire(tdbp, 0);
+		}
+		
+		if(tdbp->tdb_lifetime_usetime_c) {
+			if(tdbp->tdb_lifetime_usetime_h &&
+			   ((jiffies / HZ) - tdbp->tdb_lifetime_usetime_c >
+			    tdbp->tdb_lifetime_usetime_h)) {
+				pfkey_expire(tdbp, 1);
+				deltdbchain(tdbp);
+				spin_unlock(&tdb_lock);
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "hard usetime lifetime of SA:%s has been reached, "
+					    "SA expired, incoming packet dropped.\n", sa);
+				if(stats) {
+					stats->rx_dropped++;
+				}
+				goto rcvleave;
+			}
+			if(tdbp->tdb_lifetime_usetime_s &&
+			   ((jiffies / HZ) - tdbp->tdb_lifetime_usetime_c >
+			    tdbp->tdb_lifetime_usetime_s)) {
+				tdbp->tdb_state = SADB_SASTATE_DYING;
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "soft usetime lifetime of SA:%s has been reached, "
+					    "SA expiring, soft expire message sent up, "
+					    "incoming packet still processed.\n", sa);
+				pfkey_expire(tdbp, 0);
+			}
+		}
+		
+		if(tdbp->tdb_lifetime_packets_h &&
+		   (tdbp->tdb_lifetime_packets_c > tdbp->tdb_lifetime_packets_h)) {
+			pfkey_expire(tdbp, 1);
+			deltdbchain(tdbp);
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "hard packets lifetime of SA:%s has been reached, "
+				    "SA expired, incoming packet dropped.\n", sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		if(tdbp->tdb_lifetime_packets_s &&
+		   (tdbp->tdb_lifetime_packets_c > tdbp->tdb_lifetime_packets_s)) {
+			tdbp->tdb_state = SADB_SASTATE_DYING;
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "soft packets lifetime of SA:%s has been reached, "
+				    "SA expiring, soft expire message sent up, "
+				    "incoming packet still processed.\n", sa);
+			pfkey_expire(tdbp, 0);
+		}
+		
+		/* authenticate, if required */
+		idat = dat + iphlen;
+		switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+		case AH_MD5:
+			authlen = AHHMAC_HASHLEN;
+			break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+		case AH_SHA:
+			authlen = AHHMAC_HASHLEN;
+			break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+		case AH_NONE:
+			authlen = 0;
+			break;
+		default:
+			if(stats) {
+				stats->rx_errors++;
+			}
+			tdbp->tdb_alg_errs += 1;
+			spin_unlock(&tdb_lock);
+			goto rcvleave;
+		}
+		ilen = len - iphlen - authlen;
+		
+#ifdef CONFIG_IPSEC_ESP
+		KLIPS_PRINT(proto == IPPROTO_ESP && debug_rcv, 
+			    "klips_debug:ipsec_rcv: packet from %s received with"
+			    " seq=%d (iv)=0x%08x%08x iplen=%d esplen=%d sa=%s\n",
+			    ipaddr_txt,
+			    (__u32)ntohl(espp->esp_rpl),
+			    (__u32)ntohl(*((__u32 *)(espp->esp_iv)    )),
+			    (__u32)ntohl(*((__u32 *)(espp->esp_iv) + 1)),
+			    len, ilen, sa);
+#endif /* !CONFIG_IPSEC_ESP */
+		
+		switch(proto) {
+#ifdef CONFIG_IPSEC_ESP
+		case IPPROTO_ESP:
+			replay = ntohl(espp->esp_rpl);
+			authenticator = &(dat[len - authlen]);
+			break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+		case IPPROTO_AH:
+			replay = ntohl(ahp->ah_rpl);
+			authenticator = ahp->ah_data;
+			break;
+#endif /* CONFIG_IPSEC_AH */
+		}
+
+		/* If the sequence number == 0, expire SA, it had rolled */
+		if(tdbp->tdb_replaywin && !replay /* !tdbp->tdb_replaywin_lastseq */) {
+			deltdbchain(tdbp);
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "replay window counter rolled, expiring SA.\n");
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+
+		if (!ipsec_checkreplaywindow(tdbp, replay)) {
+			KLIPS_PRINT(debug_rcv & DB_RX_REPLAY,
+				    "klips_debug:ipsec_rcv: duplicate frame from %s,"
+				    " packet dropped\n",
+				    ipaddr_txt);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			tdbp->tdb_replaywin_errs += 1;
+			spin_unlock(&tdb_lock);
+			goto rcvleave;
+		}
+		
+		/*
+		 * verify authenticator
+		 */
+		
+		KLIPS_PRINT(debug_rcv,
+			    "klips_debug:ipsec_rcv: encalg = %d, authalg = %d.\n",
+			    tdbp->tdb_encalg, tdbp->tdb_authalg);
+		
+		if(tdbp->tdb_authalg) {
+			switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+			case AH_MD5:
+				tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->ictx;
+				if(proto == IPPROTO_ESP) {
+					MD5Update(&tctx.md5, (caddr_t)espp, ilen);
+#ifdef CONFIG_IPSEC_AH
+				} else {
+					ipo = *ipp;
+					ipo.tos = 0;	/* mutable RFC 2402 3.3.3.1.1.1 */
+					ipo.frag_off = 0;
+					ipo.ttl = 0;
+					ipo.check = 0;
+					
+					MD5Update(&tctx.md5, (caddr_t)&ipo,
+						  sizeof(struct iphdr));
+					MD5Update(&tctx.md5, (caddr_t)ahp,
+						  ahhlen - AHHMAC_HASHLEN);
+					MD5Update(&tctx.md5, (caddr_t)zeroes,
+						  AHHMAC_HASHLEN);
+					MD5Update(&tctx.md5,
+						  (caddr_t)dat + iphlen + ahhlen,
+						  len - iphlen - ahhlen);
+#endif /* CONFIG_IPSEC_AH */
+				}
+				MD5Final(hash, &tctx.md5);
+				tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->octx;
+				MD5Update(&tctx.md5, hash, AHMD596_ALEN);
+				MD5Final(hash, &tctx.md5);
+				break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+			case AH_SHA:
+				tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx;
+				if(proto == IPPROTO_ESP) {
+					SHA1Update(&tctx.sha1, (caddr_t)espp, ilen);
+#ifdef CONFIG_IPSEC_AH
+				} else {
+					ipo = *ipp;
+					ipo.tos = 0;
+					ipo.frag_off = 0;
+					ipo.ttl = 0;
+					ipo.check = 0;
+					
+					SHA1Update(&tctx.sha1, (caddr_t)&ipo,
+						   sizeof(struct iphdr));
+					SHA1Update(&tctx.sha1, (caddr_t)ahp,
+						   ahhlen - AHHMAC_HASHLEN);
+					SHA1Update(&tctx.sha1, (caddr_t)zeroes,
+						   AHHMAC_HASHLEN);
+					SHA1Update(&tctx.sha1,
+						   (caddr_t)dat + iphlen + ahhlen,
+						   len - iphlen - ahhlen);
+#endif /* CONFIG_IPSEC_AH */
+				}
+				SHA1Final(hash, &tctx.sha1);
+				tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->octx;
+				SHA1Update(&tctx.sha1, hash, AHSHA196_ALEN);
+				SHA1Final(hash, &tctx.sha1);
+				break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+			case AH_NONE:
+				break;
+			}
+		
+			if(!authenticator) {
+				if(stats) {
+					stats->rx_dropped++;
+				}
+				tdbp->tdb_auth_errs += 1;
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			}
+
+			if (memcmp(hash, authenticator, authlen)) {
+				KLIPS_PRINT(debug_rcv & DB_RX_INAU,
+					    "klips_debug:ipsec_rcv: auth failed on incoming "
+					    "packet from %s: hash=%08x%08x%08x "
+					    "auth=%08x%08x%08x, dropped\n", ipaddr_txt,
+					    *(__u32*)&hash[0],
+					    *(__u32*)&hash[4],
+					    *(__u32*)&hash[8],
+					    *(__u32*)authenticator,
+					    *((__u32*)authenticator + 1),
+					    *((__u32*)authenticator + 2));
+				if(stats) {
+					stats->rx_dropped++;
+				}
+				tdbp->tdb_auth_errs += 1;
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			} else {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: authentication successful.\n");
+			}
+			
+			memset((caddr_t)&tctx, 0, sizeof(tctx));
+			memset(hash, 0, sizeof(hash));
+		}
+
+		if (!ipsec_updatereplaywindow(tdbp, replay)) {
+			KLIPS_PRINT(debug_rcv & DB_RX_REPLAY,
+				    "klips_debug:ipsec_rcv: duplicate frame from %s,"
+				    " packet dropped\n",
+				    ipaddr_txt);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			tdbp->tdb_replaywin_errs += 1;
+			spin_unlock(&tdb_lock);
+			goto rcvleave;
+		}
+		
+		switch(proto) {
+#ifdef CONFIG_IPSEC_ESP
+		case IPPROTO_ESP:
+			switch(tdbp->tdb_encalg) {
+			case ESP_3DES:
+				iv[0] = *((__u32 *)(espp->esp_iv)    );
+				iv[1] = *((__u32 *)(espp->esp_iv) + 1);
+				esphlen = sizeof(struct esp);
+				break;
+			case ESP_NULL:
+				esphlen = offsetof(struct esp, esp_iv);
+				break;
+			default:
+				if(stats) {
+					stats->rx_errors++;
+				}
+				tdbp->tdb_alg_errs += 1;
+				spin_unlock(&tdb_lock);
+				goto rcvleave;
+			}
+			idat += esphlen;
+			ilen -= esphlen;
+			
+			switch(tdbp->tdb_encalg) {
+			case ESP_3DES:
+				if ((ilen) % 8) {
+					printk("klips_error:ipsec_rcv: "
+					       "got packet with esplen = %d from %s "
+					       "-- should be on 8 octet boundary, packet dropped\n",
+					       ilen, ipaddr_txt);
+					if(stats) {
+						stats->rx_errors++;
+					}
+					tdbp->tdb_encsize_errs += 1;
+					spin_unlock(&tdb_lock);
+					goto rcvleave;
+				}
+				des_ede3_cbc_encrypt(idat, idat, ilen,
+						     tdbp->tdb_key_e,
+						     tdbp->tdb_key_e + sizeof(struct des_eks),
+						     tdbp->tdb_key_e + 2 * sizeof(struct des_eks),
+						     (caddr_t)iv, 0);
+				break;
+			case ESP_NULL:
+				break;
+			}
+			next_header = idat[ilen - 1];
+			padlen = idat[ilen - 2];
+			pad = padlen + 2 + authlen;
+			{
+			        int badpad = 0;
+				
+				KLIPS_PRINT(debug_rcv & DB_RX_IPAD,
+					    "klips_debug:ipsec_rcv: "
+					    "padlen=%d, contents: 0x<offset>: 0x<value> 0x<value> ...\n",
+					    padlen);
+				
+				for (i = 1; i <= padlen; i++) {
+					if((i % 16) == 1) {
+						KLIPS_PRINT(debug_rcv & DB_RX_IPAD,
+							    "klips_debug:           %02x:",
+							    i - 1);
+					}
+					KLIPS_PRINTMORE(debug_rcv & DB_RX_IPAD,
+						    " %02x",
+						    idat[ilen - 2 - padlen + i - 1]);
+					if(i != idat[ilen - 2 - padlen + i - 1]) {
+					        badpad = 1;
+					} 
+					if((i % 16) == 0) {
+						KLIPS_PRINTMORE(debug_rcv & DB_RX_IPAD,
+							    "\n");
+					}
+				}
+				if((i % 16) != 1) {
+					KLIPS_PRINTMORE(debug_rcv & DB_RX_IPAD,
+							"\n");
+				}
+				if(badpad) {
+					KLIPS_PRINT(debug_rcv & DB_RX_IPAD,
+						    "klips_debug:ipsec_rcv: "
+						    "warning, decrypted packet from %s has bad padding\n",
+						    ipaddr_txt);
+					KLIPS_PRINT(debug_rcv & DB_RX_IPAD,
+						    "klips_debug:ipsec_rcv: "
+						    "...may be bad decryption -- not dropped\n");
+					tdbp->tdb_encpad_errs += 1;
+				}
+				
+				KLIPS_PRINT(debug_rcv & DB_RX_IPAD,
+					    "klips_debug:ipsec_rcv: "
+					    "packet decrypted from %s: next_header = %d, padding = %d\n",
+					    ipaddr_txt,
+					    next_header,
+					    pad - 2 - authlen);
+			}
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+		case IPPROTO_AH:
+			break;
+#endif /* CONFIG_IPSEC_AH */
+		}
+	       
+		/*
+		 *	Discard the original IP header
+		 */
+		
+		ipp->protocol = next_header;
+		
+		switch(proto) {
+#ifdef CONFIG_IPSEC_ESP
+		case IPPROTO_ESP:
+			ipp->tot_len = htons(ntohs(ipp->tot_len) - (esphlen + pad));
+			memmove((void *)(skb->data + esphlen),
+				(void *)(skb->data), iphlen);
+			if(skb->len < esphlen) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_rcv: "
+				       "tried to skb_pull esphlen=%d, %d available.  "
+				       "This should never happen, please report.\n",
+				       esphlen, (int)(skb->len));
+				goto rcvleave;
+			}
+			skb_pull(skb, esphlen);
+
+			KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+				    "klips_debug:ipsec_rcv: trimming to %d.\n",
+				    len - esphlen - pad);
+			if(pad + esphlen <= len) {
+			        skb_trim(skb, len - esphlen - pad);
+			} else {
+				spin_unlock(&tdb_lock);
+			        KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+				            "klips_debug:ipsec_rcv: bogus packet, size is zero or negative, dropping.\n");
+				goto rcvleave;
+			}
+		break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+		case IPPROTO_AH:
+			ipp->tot_len = htons(ntohs(ipp->tot_len) - ahhlen);
+			memmove((void *)(skb->data + ahhlen),
+				(void *)(skb->data), iphlen);
+			if(skb->len < ahhlen) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_rcv: "
+				       "tried to skb_pull ahhlen=%d, %d available.  "
+				       "This should never happen, please report.\n",
+				       ahhlen, (int)(skb->len));
+				goto rcvleave;
+			}
+			skb_pull(skb, ahhlen);
+			break;
+#endif /* CONFIG_IPSEC_AH */
+		}
+
+
+		/*
+		 *	Adjust pointers
+		 */
+		
+		len = skb->len;
+		dat = skb->data;
+		
+#ifdef NET_21
+/*		skb->h.ipiph=(struct iphdr *)skb->data; */
+		skb->nh.raw = skb->data;
+		skb->h.raw = skb->nh.raw + (skb->nh.iph->ihl << 2);
+		
+		memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
+#else /* NET_21 */
+		skb->h.iph=(struct iphdr *)skb->data;
+		skb->ip_hdr=(struct iphdr *)skb->data;
+		memset(skb->proto_priv, 0, sizeof(struct options));
+#endif /* NET_21 */
+		
+		ipp = (struct iphdr *)dat;
+		ipp->check = 0;
+		ipp->check = ip_fast_csum((unsigned char *)dat, iphlen >> 2);
+		
+		KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+			    "klips_debug:ipsec_rcv: after <%s%s%s>, SA:%s:\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+		KLIPS_IP_PRINT(debug_rcv & DB_RX_PKTRX, ipp);
+		
+		skb->protocol = htons(ETH_P_IP);
+		skb->ip_summed = 0;
+
+		tdbprev = tdbp;
+		tdbnext = tdbp->tdb_inext;
+		if(sysctl_ipsec_inbound_policy_check) {
+			if(tdbnext) {
+				if(tdbnext->tdb_onext != tdbp) {
+					spin_unlock(&tdb_lock);
+					KLIPS_PRINT(debug_rcv,
+						    "klips_debug:ipsec_rcv: "
+						    "SA:%s, backpolicy does not agree with fwdpolicy.\n",
+						    sa);
+					if(stats) {
+						stats->rx_dropped++;
+					}
+					goto rcvleave;
+				}
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s, backpolicy agrees with fwdpolicy.\n",
+					    sa);
+				if(!(   (ipp->protocol == IPPROTO_AH  )
+					|| (ipp->protocol == IPPROTO_ESP )
+					|| (ipp->protocol == IPPROTO_IPIP)
+#ifdef CONFIG_IPSEC_IPCOMP
+					|| (ipp->protocol == IPPROTO_COMP)
+#endif /* CONFIG_IPSEC_IPCOMP */
+					)) {
+					spin_unlock(&tdb_lock);
+					KLIPS_PRINT(debug_rcv,
+						    "klips_debug:ipsec_rcv: "
+						    "packet with incomplete policy dropped, last successful SA:%s.\n",
+						    sa);
+					if(stats) {
+						stats->rx_dropped++;
+					}
+					goto rcvleave;
+				}
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "SA:%s, Another IPSEC header to process.\n",
+					    sa);
+			} else {
+				KLIPS_PRINT(debug_rcv,
+					    "klips_debug:ipsec_rcv: "
+					    "No tdb_inext from this SA:%s.\n",
+					    sa);
+			}
+		}
+
+#ifdef CONFIG_IPSEC_IPCOMP
+		/* update ipcomp ratio counters, even if no ipcomp packet is present */
+		if (tdbnext
+		  && tdbnext->tdb_said.proto == IPPROTO_COMP
+		  && ipp->protocol != IPPROTO_COMP) {
+			tdbnext->tdb_comp_ratio_cbytes += ntohs(ipp->tot_len);
+			tdbnext->tdb_comp_ratio_dbytes += ntohs(ipp->tot_len);
+		}
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+		tdbp->tdb_lifetime_bytes_c += len;
+		if(!tdbp->tdb_lifetime_usetime_c) {
+			tdbp->tdb_lifetime_usetime_c = jiffies / HZ;
+		}
+		tdbp->tdb_lifetime_usetime_l = jiffies / HZ;
+		tdbp->tdb_lifetime_packets_c += 1;
+		
+	/* end decapsulation loop here */
+	} while(   (ipp->protocol == IPPROTO_ESP )
+		|| (ipp->protocol == IPPROTO_AH  )
+#ifdef CONFIG_IPSEC_IPCOMP
+		|| (ipp->protocol == IPPROTO_COMP)
+#endif /* CONFIG_IPSEC_IPCOMP */
+		);
+	
+#ifdef CONFIG_IPSEC_IPCOMP
+	if(tdbnext && tdbnext->tdb_said.proto == IPPROTO_COMP) {
+		tdbprev = tdbp;
+		tdbp = tdbnext;
+		tdbnext = tdbp->tdb_inext;
+	}
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+	/*
+	 * XXX this needs to be locked from when it was first looked
+	 * up in the decapsulation loop.  Perhaps it is better to put
+	 * the IPIP decap inside the loop.
+	 */
+	if(tdbnext) {
+		tdbp = tdbnext;
+		sa_len = satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+		if(ipp->protocol != IPPROTO_IPIP) {
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "SA:%s, Hey!  How did this get through?  Dropped.\n",
+				    sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+		if(sysctl_ipsec_inbound_policy_check && (tdbnext = tdbp->tdb_inext)) {
+			char sa2[SATOA_BUF];
+			sa_len = satoa(tdbnext->tdb_said, 0, sa2, SATOA_BUF);
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "unexpected SA:%s after IPIP SA:%s\n",
+				    sa2, sa);
+			if(stats) {
+				stats->rx_dropped++;
+			}
+			goto rcvleave;
+		}
+	}
+
+#ifdef INBOUND_POLICY_CHECK_eroute
+	/*
+	  Do *not* enable this without thoroughly checking spinlock issues
+	  first.  In particular, nesting an eroute spinlock within a tdb
+	  spinlock could result in a deadlock.  (Well, only on a SMP machine
+	  under 2.4?)
+	*/
+
+	/*
+	 * First things first -- look us up in the erouting tables.
+	 */
+	matcher.sen_len = sizeof (struct sockaddr_encap);
+	matcher.sen_family = AF_ENCAP;
+	matcher.sen_type = SENT_IP4;
+	if(ipp->protocol == IPPROTO_IPIP) {
+		struct iphdr *ipp2;
+
+		ipp2 = (struct iphdr*) (((char*)ipp) + (ipp->ihl << 2));
+		matcher.sen_ip_src.s_addr = ipp2->saddr;
+		matcher.sen_ip_dst.s_addr = ipp2->daddr;
+	} else {
+		matcher.sen_ip_src.s_addr = ipp->saddr;
+		matcher.sen_ip_dst.s_addr = ipp->daddr;
+	}
+	
+	/*
+	 * The spinlock is to prevent any other process from accessing or
+	 * deleting the eroute while we are using and updating it.
+	 */
+	spin_lock(&eroute_lock);
+	
+	er = ipsec_findroute(&matcher);
+	if(er) {
+		policy_said = er->er_said;
+		policy_eaddr = er->er_eaddr;
+		policy_emask = er->er_emask;
+	}
+	
+	spin_unlock(&eroute_lock);
+
+	if(er) {
+		/*
+		 * The spinlock is to prevent any other process from
+		 * accessing or deleting the tdb while we are using and
+		 * updating it.
+		 */
+		/* spin_lock(&tdb_lock); */
+
+		policy_tdb = gettdb(&policy_said);
+		if (policy_tdb == NULL) {
+			/* spin_unlock(&tdb_lock); */
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    "no Tunnel Descriptor Block for SA%s: "
+				    "incoming packet with no policy SA, dropped.\n", sa);
+			goto rcvleave;
+		}
+		
+		sa_len = satoa(policy_said, 0, sa, SATOA_BUF);
+
+		KLIPS_PRINT(debug_rcv,
+			    "klips_debug:ipsec_rcv: "
+			    "found policy Tunnel Descriptor Block -- SA:%s\n", sa);
+		while(1) {
+			if(policy_tdb->tdb_inext) {
+				policy_tdb = policy_tdb->tdb_inext;
+			} else {
+				break;
+			}
+		}
+		if(policy_tdb != tdbp) {
+			/* spin_unlock(&tdb_lock); */
+			KLIPS_PRINT(debug_rcv,
+				    "klips_debug:ipsec_rcv: "
+				    " Tunnel Descriptor Block for SA%s: "
+				    "incoming packet with different policy SA, dropped.\n", sa);
+			goto rcvleave;
+		}
+
+		/* spin_unlock(&tdb_lock); */
+	}
+#endif /* INBOUND_POLICY_CHECK_eroute */
+
+	if(ipp->protocol == IPPROTO_IPIP) {
+		/*
+		 * XXX this needs to be locked from when it was first looked
+		 * up in the decapsulation loop.  Perhaps it is better to put
+		 * the IPIP decap inside the loop.
+		 */
+		if(tdbp) {
+			tdbp->tdb_lifetime_bytes_c += len;
+			if(!tdbp->tdb_lifetime_usetime_c) {
+				tdbp->tdb_lifetime_usetime_c = jiffies / HZ;
+			}
+			tdbp->tdb_lifetime_usetime_l = jiffies / HZ;
+			tdbp->tdb_lifetime_packets_c += 1;
+		}
+		
+		if(skb->len < iphlen) {
+			printk(KERN_WARNING "klips_debug:ipsec_rcv: "
+			       "tried to skb_pull iphlen=%d, %d available.  "
+			       "This should never happen, please report.\n",
+			       iphlen, (int)(skb->len));
+
+			spin_unlock(&tdb_lock);
+			goto rcvleave;
+		}
+		skb_pull(skb, iphlen);
+
+#ifdef NET_21
+		ipp = (struct iphdr *)skb->nh.raw = skb->data;
+		skb->h.raw = skb->nh.raw + (skb->nh.iph->ihl << 2);
+		
+		memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
+#else /* NET_21 */
+		ipp = skb->ip_hdr = skb->h.iph = (struct iphdr *)skb->data;
+
+		memset(skb->proto_priv, 0, sizeof(struct options));
+#endif /* NET_21 */
+
+		skb->protocol = htons(ETH_P_IP);
+		skb->ip_summed = 0;
+		KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+			    "klips_debug:ipsec_rcv: IPIP tunnel stripped.\n");
+		KLIPS_IP_PRINT(debug_rcv & DB_RX_PKTRX, ipp);
+	}
+
+	spin_unlock(&tdb_lock);
+
+#ifdef NET_21
+	if(stats) {
+		stats->rx_bytes += skb->len;
+	}
+	if(skb->dst) {
+		dst_release(skb->dst);
+		skb->dst = NULL;
+	}
+	skb->pkt_type = PACKET_HOST;
+	if(hard_header_len &&
+	   (skb->mac.raw != (skb->data - hard_header_len)) &&
+	   (hard_header_len <= skb_headroom(skb))) {
+		/* copy back original MAC header */
+		memmove(skb->data - hard_header_len, skb->mac.raw, hard_header_len);
+		skb->mac.raw = skb->data - hard_header_len;
+	}
+#endif /* NET_21 */
+
+#ifdef CONFIG_IPSEC_IPCOMP
+	if(ipp->protocol == IPPROTO_COMP) {
+		unsigned int flags = 0;
+
+		if(sysctl_ipsec_inbound_policy_check) {
+			KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+				"klips_debug:ipsec_rcv: "
+				"inbound policy checking enabled, IPCOMP follows IPIP, dropped.\n");
+			if (stats) {
+				stats->rx_errors++;
+			}
+			goto rcvleave;
+		}
+		/* XXX need a tdb for updating ratio counters XXX */
+		skb = skb_decompress(skb, NULL, &flags);
+		if (!skb || flags) {
+			KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+				"klips_debug:ipsec_rcv: "
+				"skb_decompress() returned error flags: %d, dropped.\n",
+			       flags);
+			if (stats) {
+				stats->rx_errors++;
+			}
+			goto rcvleave;
+		}
+#ifdef NET_21
+		ipp = skb->nh.iph;
+#else /* NET_21 */
+		ipp = skb->ip_hdr;
+#endif /* NET_21 */
+	}
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+#ifdef SKB_RESET_NFCT
+        nf_conntrack_put(skb->nfct);
+        skb->nfct = NULL;
+#ifdef CONFIG_NETFILTER_DEBUG
+	skb->nf_debug = 0;
+#endif /* CONFIG_NETFILTER_DEBUG */
+#endif /* SKB_RESET_NFCT */
+	KLIPS_PRINT(debug_rcv & DB_RX_PKTRX,
+		    "klips_debug:ipsec_rcv: netif_rx() called.\n");
+	netif_rx(skb);
+
+	MOD_DEC_USE_COUNT;
+	return(0);
+	
+ rcvleave:
+ 	if(skb) {
+#ifdef NET_21
+                kfree_skb(skb);
+#else /* NET_21 */
+                kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+	}
+
+	MOD_DEC_USE_COUNT;
+	return(0);
+}
+
+struct inet_protocol ah_protocol =
+{
+	ipsec_rcv,				/* AH handler */
+	NULL,				/* TUNNEL error control */
+	0,				/* next */
+	IPPROTO_AH,			/* protocol ID */
+	0,				/* copy */
+	NULL,				/* data */
+	"AH"				/* name */
+};
+
+struct inet_protocol esp_protocol = 
+{
+	ipsec_rcv,			/* ESP handler          */
+	NULL,				/* TUNNEL error control */
+	0,				/* next */
+	IPPROTO_ESP,			/* protocol ID */
+	0,				/* copy */
+	NULL,				/* data */
+	"ESP"				/* name */
+};
+
+#if 0
+/* We probably don't want to install a pure IPCOMP protocol handler, but
+   only want to handle IPCOMP if it is encapsulated inside an ESP payload
+   (which is already handled) */
+#ifdef CONFIG_IPSEC_IPCOMP
+struct inet_protocol comp_protocol =
+{
+	ipsec_rcv,			/* COMP handler		*/
+	NULL,				/* COMP error control	*/
+	0,				/* next */
+	IPPROTO_COMP,			/* protocol ID */
+	0,				/* copy */
+	NULL,				/* data */
+	"COMP"				/* name */
+};
+#endif /* CONFIG_IPSEC_IPCOMP */
+#endif
+
+/*
+ * $Log$
+ * Revision 1.74  2000/11/25 03:50:36  rgb
+ * Oops fix by minor re-arrangement of code to avoid accessing a freed tdb.
+ *
+ * Revision 1.73  2000/11/09 20:52:15  rgb
+ * More spinlock shuffling, locking earlier and unlocking later in rcv to
+ * include ipcomp and prevent races, renaming some tdb variables that got
+ * forgotten, moving some unlocks to include tdbs and adding a missing
+ * unlock.  Thanks to Svenning for some of these.
+ *
+ * Revision 1.72  2000/11/09 20:11:22  rgb
+ * Minor shuffles to fix non-standard kernel config option selection.
+ *
+ * Revision 1.71  2000/11/06 04:36:18  rgb
+ * Ditched spin_lock_irqsave in favour of spin_lock.
+ * Minor initial protocol check rewrite.
+ * Clean up debug printing.
+ * Clean up tdb handling on ipcomp.
+ * Fixed transport mode null pointer de-reference without ipcomp.
+ * Add Svenning's adaptive content compression.
+ * Disabled registration of ipcomp handler.
+ *
+ * Revision 1.70  2000/10/30 23:41:43  henry
+ * Hans-Joerg Hoexer's null-pointer fix
+ *
+ * Revision 1.69  2000/10/10 18:54:16  rgb
+ * Added a fix for incoming policy check with ipcomp enabled but
+ * uncompressible.
+ *
+ * Revision 1.68  2000/09/22 17:53:12  rgb
+ * Fixed ipcomp tdb pointers update for policy checking.
+ *
+ * Revision 1.67  2000/09/21 03:40:58  rgb
+ * Added more debugging to try and track down the cpi outward copy problem.
+ *
+ * Revision 1.66  2000/09/20 04:00:10  rgb
+ * Changed static functions to DEBUG_NO_STATIC to reveal function names for
+ * debugging oopsen.
+ *
+ * Revision 1.65  2000/09/19 07:07:16  rgb
+ * Added debugging to inbound policy check for ipcomp.
+ * Added missing spin_unlocks (thanks Svenning!).
+ * Fixed misplaced tdbnext pointers causing mismatched ipip policy check.
+ * Protect ipcomp policy check following ipip decap with sysctl switch.
+ *
+ * Revision 1.64  2000/09/18 21:27:29  rgb
+ * 2.0 fixes.
+ *
+ * Revision 1.63  2000/09/18 02:35:50  rgb
+ * Added policy checking to ipcomp and re-enabled policy checking by
+ * default.
+ * Optimised satoa calls.
+ *
+ * Revision 1.62  2000/09/17 21:02:32  rgb
+ * Clean up debugging, removing slow timestamp debug code.
+ *
+ * Revision 1.61  2000/09/16 01:07:55  rgb
+ * Fixed erroneous ref from struct ipcomp to struct ipcomphdr.
+ *
+ * Revision 1.60  2000/09/15 11:37:01  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.59  2000/09/15 04:56:20  rgb
+ * Remove redundant satoa() call, reformat comment.
+ *
+ * Revision 1.58  2000/09/13 08:00:52  rgb
+ * Flick on inbound policy checking.
+ *
+ * Revision 1.57  2000/09/12 03:22:19  rgb
+ * Converted inbound_policy_check to sysctl.
+ * Re-enabled policy backcheck.
+ * Moved policy checks to top and within tdb lock.
+ *
+ * Revision 1.56  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.55  2000/08/28 18:15:46  rgb
+ * Added MB's nf-debug reset patch.
+ *
+ * Revision 1.54  2000/08/27 01:41:26  rgb
+ * More minor tweaks to the bad padding debug code.
+ *
+ * Revision 1.53  2000/08/24 16:54:16  rgb
+ * Added KLIPS_PRINTMORE macro to continue lines without KERN_INFO level
+ * info.
+ * Tidied up device reporting at the start of ipsec_rcv.
+ * Tidied up bad padding debugging and processing.
+ *
+ * Revision 1.52  2000/08/20 21:36:03  rgb
+ * Activated pfkey_expire() calls.
+ * Added a hard/soft expiry parameter to pfkey_expire().
+ * Added sanity checking to avoid propagating zero or smaller-length skbs
+ * from a bogus decryption.
+ * Re-arranged the order of soft and hard expiry to conform to RFC2367.
+ * Clean up references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.51  2000/08/18 21:23:30  rgb
+ * Improve bad padding warning so that the printk buffer doesn't get
+ * trampled.
+ *
+ * Revision 1.50  2000/08/01 14:51:51  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.49  2000/07/28 13:50:53  rgb
+ * Changed enet_statistics to net_device_stats and added back compatibility
+ * for pre-2.1.19.
+ *
+ * Revision 1.48  2000/05/10 19:14:40  rgb
+ * Only check usetime against soft and hard limits if the tdb has been
+ * used.
+ * Cast output of ntohl so that the broken prototype doesn't make our
+ * compile noisy.
+ *
+ * Revision 1.47  2000/05/09 17:45:43  rgb
+ * Fix replay bitmap corruption bug upon receipt of bogus packet
+ * with correct SPI.  This was a DoS.
+ *
+ * Revision 1.46  2000/03/27 02:31:58  rgb
+ * Fixed authentication failure printout bug.
+ *
+ * Revision 1.45  2000/03/22 16:15:37  rgb
+ * Fixed renaming of dev_get (MB).
+ *
+ * Revision 1.44  2000/03/16 08:17:24  rgb
+ * Hardcode PF_KEYv2 support.
+ * Fixed minor bug checking AH header length.
+ *
+ * Revision 1.43  2000/03/14 12:26:59  rgb
+ * Added skb->nfct support for clearing netfilter conntrack bits (MB).
+ *
+ * Revision 1.42  2000/01/26 10:04:04  rgb
+ * Fixed inbound policy checking on transport mode bug.
+ * Fixed noisy 2.0 printk arguments.
+ *
+ * Revision 1.41  2000/01/24 20:58:02  rgb
+ * Improve debugging/reporting support for (disabled) inbound
+ * policy checking.
+ *
+ * Revision 1.40  2000/01/22 23:20:10  rgb
+ * Fixed up inboud policy checking code.
+ * Cleaned out unused crud.
+ *
+ * Revision 1.39  2000/01/21 06:15:29  rgb
+ * Added sanity checks on skb_push(), skb_pull() to prevent panics.
+ * Fixed cut-and-paste debug_tunnel to debug_rcv.
+ * Added inbound policy checking code, disabled.
+ * Simplified output code by updating ipp to post-IPIP decapsulation.
+ *
+ * Revision 1.38  1999/12/22 05:08:36  rgb
+ * Checked for null skb, skb->dev, skb->data, skb->dev->name, dev->name,
+ * protocol and take appropriate action for sanity.
+ * Set ipsecdev to NULL if device could not be determined.
+ * Fixed NULL stats access bug if device could not be determined.
+ *
+ * Revision 1.37  1999/12/14 20:07:59  rgb
+ * Added a default switch case to catch bogus encalg values.
+ *
+ * Revision 1.36  1999/12/07 18:57:57  rgb
+ * Fix PFKEY symbol compile error (SADB_*) without pfkey enabled.
+ *
+ * Revision 1.35  1999/12/01 22:15:35  rgb
+ * Add checks for LARVAL and DEAD SAs.
+ * Change state of SA from MATURE to DYING when a soft lifetime is
+ * reached and print debug warning.
+ *
+ * Revision 1.34  1999/11/23 23:04:03  rgb
+ * Use provided macro ADDRTOA_BUF instead of hardcoded value.
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.33  1999/11/19 01:10:06  rgb
+ * Enable protocol handler structures for static linking.
+ *
+ * Revision 1.32  1999/11/18 04:09:19  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.31  1999/11/17 15:53:39  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.30  1999/10/26 15:09:07  rgb
+ * Used debug compiler directives to shut up compiler for decl/assign
+ * statement.
+ *
+ * Revision 1.29  1999/10/16 18:25:37  rgb
+ * Moved SA lifetime expiry checks before packet processing.
+ * Expire SA on replay counter rollover.
+ *
+ * Revision 1.28  1999/10/16 04:23:07  rgb
+ * Add stats for replaywin_errs, replaywin_max_sequence_difference,
+ * authentication errors, encryption size errors, encryption padding
+ * errors, and time since last packet.
+ *
+ * Revision 1.27  1999/10/16 00:30:47  rgb
+ * Added SA lifetime counting.
+ *
+ * Revision 1.26  1999/10/15 22:14:37  rgb
+ * Add debugging.
+ *
+ * Revision 1.25  1999/10/08 18:37:34  rgb
+ * Fix end-of-line spacing to sate whining PHMs.
+ *
+ * Revision 1.24  1999/10/03 18:54:51  rgb
+ * Spinlock support for 2.3.xx.
+ * Don't forget to undo spinlocks on error!
+ *
+ * Revision 1.23  1999/10/01 15:44:53  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.22  1999/10/01 00:01:54  rgb
+ * Added tdb structure locking.
+ *
+ * Revision 1.21  1999/09/18 11:42:12  rgb
+ * Add Marc Boucher's tcpdump cloned packet fix.
+ *
+ * Revision 1.20  1999/09/17 23:50:25  rgb
+ * Add Marc Boucher's hard_header_len patches.
+ *
+ * Revision 1.19  1999/09/10 05:31:36  henry
+ * tentative fix for 2.0.38-crash bug (move chunk of new code into 2.2 #ifdef)
+ *
+ * Revision 1.18  1999/08/28 08:28:06  rgb
+ * Delete redundant sanity check.
+ *
+ * Revision 1.17  1999/08/28 02:00:58  rgb
+ * Add an extra sanity check for null skbs.
+ *
+ * Revision 1.16  1999/08/27 05:21:38  rgb
+ * Clean up skb->data/raw/nh/h manipulation.
+ * Add Marc Boucher's mods to aid tcpdump.
+ *
+ * Revision 1.15  1999/08/25 14:22:40  rgb
+ * Require 4-octet boundary check only for ESP.
+ *
+ * Revision 1.14  1999/08/11 08:36:44  rgb
+ * Add compiler directives to allow configuring out AH, ESP or transforms.
+ *
+ * Revision 1.13  1999/08/03 17:10:49  rgb
+ * Cosmetic fixes and clarification to debug output.
+ *
+ * Revision 1.12  1999/05/09 03:25:36  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.11  1999/05/08 21:23:57  rgb
+ * Add casting to silence the 2.2.x compile.
+ *
+ * Revision 1.10  1999/05/05 22:02:31  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.9  1999/04/29 15:18:01  rgb
+ * hange debugging to respond only to debug_rcv.
+ * Change gettdb parameter to a pointer to reduce stack loading and
+ * facilitate parameter sanity checking.
+ *
+ * Revision 1.8  1999/04/15 15:37:24  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.4.2.2  1999/04/13 20:32:45  rgb
+ * Move null skb sanity check.
+ * Silence debug a bit more when off.
+ * Use stats more effectively.
+ *
+ * Revision 1.4.2.1  1999/03/30 17:10:32  rgb
+ * Update AH+ESP bugfix.
+ *
+ * Revision 1.7  1999/04/11 00:28:59  henry
+ * GPL boilerplate
+ *
+ * Revision 1.6  1999/04/06 04:54:27  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.5  1999/03/17 15:39:23  rgb
+ * Code clean-up.
+ * Bundling bug fix.
+ * ESP_NULL esphlen and IV bug fix.
+ *
+ * Revision 1.4  1999/02/17 16:51:02  rgb
+ * Ditch NET_IPIP dependancy.
+ * Decapsulate recursively for an entire bundle.
+ *
+ * Revision 1.3  1999/02/12 21:22:47  rgb
+ * Convert debugging printks to KLIPS_PRINT macro.
+ * Clean-up cruft.
+ * Process IPIP tunnels internally.
+ *
+ * Revision 1.2  1999/01/26 02:07:36  rgb
+ * Clean up debug code when switched off.
+ * Remove references to INET_GET_PROTOCOL.
+ *
+ * Revision 1.1  1999/01/21 20:29:11  rgb
+ * Converted from transform switching to algorithm switching.
+ *
+ *
+ * Id: ipsec_esp.c,v 1.16 1998/12/02 03:08:11 rgb Exp $
+ *
+ * Log: ipsec_esp.c,v $
+ * Revision 1.16  1998/12/02 03:08:11  rgb
+ * Fix incoming I/F bug in AH and clean up inconsistencies in the I/F
+ * discovery routine in both AH and ESP.
+ *
+ * Revision 1.15  1998/11/30 13:22:51  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.14  1998/11/10 05:55:37  rgb
+ * Add even more detail to 'wrong I/F' debug statement.
+ *
+ * Revision 1.13  1998/11/10 05:01:30  rgb
+ * Clean up debug output to be quiet when disabled.
+ * Add more detail to 'wrong I/F' debug statement.
+ *
+ * Revision 1.12  1998/10/31 06:39:32  rgb
+ * Fixed up comments in #endif directives.
+ * Tidied up debug printk output.
+ * Convert to addrtoa and satoa where possible.
+ *
+ * Revision 1.11  1998/10/27 00:49:30  rgb
+ * AH+ESP bundling bug has been squished.
+ * Cosmetic brace fixing in code.
+ * Newlines added before calls to ipsec_print_ip.
+ * Fix debug output function ID's.
+ *
+ * Revision 1.10  1998/10/22 06:37:22  rgb
+ * Fixed run-on error message to fit 80 columns.
+ *
+ * Revision 1.9  1998/10/20 02:41:04  rgb
+ * Fixed a replay window size sanity test bug.
+ *
+ * Revision 1.8  1998/10/19 18:55:27  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ * \n bugfix to printk debug message.
+ *
+ * Revision 1.7  1998/10/09 04:23:03  rgb
+ * Fixed possible DoS caused by invalid transform called from an ESP
+ * packet.  This should not be a problem when protocol is added to the SA.
+ * Sanity check added for null xf_input routine.  Sanity check added for null
+ * socket buffer returned from xf_input routine.
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ *
+ * Revision 1.6  1998/07/14 15:56:04  rgb
+ * Set sdb->dev to virtual ipsec I/F.
+ *
+ * Revision 1.5  1998/06/30 18:07:46  rgb
+ * Change for ah/esp_protocol stuct visible only if module.
+ *
+ * Revision 1.4  1998/06/30 00:12:46  rgb
+ * Clean up a module compile error.
+ *
+ * Revision 1.3  1998/06/25 19:28:06  rgb
+ * Readjust premature unloading of module on packet receipt.
+ * Make protocol structure abailable to rest of kernel.
+ * Use macro for protocol number.
+ *
+ * Revision 1.2  1998/06/23 02:49:34  rgb
+ * Fix minor #include bug that prevented compiling without debugging.
+ * Added code to check for presence of IPIP protocol if an incoming packet
+ * is IPIP encapped.
+ *
+ * Revision 1.1  1998/06/18 21:27:44  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.9  1998/06/14 23:48:42  rgb
+ * Fix I/F name comparison oops bug.
+ *
+ * Revision 1.8  1998/06/11 07:20:04  rgb
+ * Stats fixed for rx_packets.
+ *
+ * Revision 1.7  1998/06/11 05:53:34  rgb
+ * Added stats for rx error and good packet reporting.
+ *
+ * Revision 1.6  1998/06/05 02:27:28  rgb
+ * Add rx_errors stats.
+ * Fix DoS bug:  skb's not being freed on dropped packets.
+ *
+ * Revision 1.5  1998/05/27 21:21:29  rgb
+ * Fix DoS potential bug.  skb was not being freed if the packet was bad.
+ *
+ * Revision 1.4  1998/05/18 22:31:37  rgb
+ * Minor change in debug output and comments.
+ *
+ * Revision 1.3  1998/04/21 21:29:02  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:19  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:05:59  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Minor cosmetic changes.
+ *
+ * Revision 0.3  1996/11/20 14:35:48  ji
+ * Minor Cleanup.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_rcv.h linux/net/ipsec/ipsec_rcv.h
--- linux-noipsec/net/ipsec/ipsec_rcv.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_rcv.h	Thu Sep 21 06:34:21 2000
@@ -0,0 +1,161 @@
+/*
+ * 
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#define DB_RX_PKTRX	0x0001
+#define DB_RX_PKTRX2	0x0002
+#define DB_RX_DMP	0x0004
+#define DB_RX_TDB	0x0010
+#define DB_RX_XF	0x0020
+#define DB_RX_IPAD	0x0040
+#define DB_RX_INAU	0x0080
+#define DB_RX_OINFO	0x0100
+#define DB_RX_OINFO2	0x0200
+#define DB_RX_OH	0x0400
+#define DB_RX_REPLAY	0x0800
+
+#ifdef __KERNEL__
+/* struct options; */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/config.h>	/* for CONFIG_IP_FORWARD */
+#include <linux/version.h>
+#include <freeswan.h>
+
+extern int
+ipsec_rcv(struct sk_buff *skb,
+#ifdef NET_21
+	  unsigned short xlen);
+#else /* NET_21 */
+	  struct device *dev,
+	  struct options *opt, 
+	  __u32 daddr,
+	  unsigned short len,
+	  __u32 saddr,
+	  int redo,
+	  struct inet_protocol *protocol);
+#endif /* NET_21 */
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_rcv;
+#endif /* CONFIG_IPSEC_DEBUG */
+extern int sysctl_ipsec_inbound_policy_check;
+#endif __KERNEL__
+
+/*
+ * $Log$
+ * Revision 1.11  2000/09/21 04:34:21  rgb
+ * Moved declaration of sysctl_ipsec_inbound_policy_check outside
+ * CONFIG_IPSEC_DEBUG. (MB)
+ *
+ * Revision 1.10  2000/09/18 02:36:10  rgb
+ * Exported sysctl_ipsec_inbound_policy_check for skb_decompress().
+ *
+ * Revision 1.9  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.8  1999/11/18 04:09:19  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.7  1999/05/25 01:45:37  rgb
+ * Fix version macros for 2.0.x as a module.
+ *
+ * Revision 1.6  1999/05/08 21:24:27  rgb
+ * Add includes for 2.2.x include into net/ipv4/protocol.c
+ *
+ * Revision 1.5  1999/05/05 22:02:32  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.4  1999/04/11 00:28:59  henry
+ * GPL boilerplate
+ *
+ * Revision 1.3  1999/04/06 04:54:27  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.2  1999/01/22 20:06:59  rgb
+ * Fixed cut-and-paste error from ipsec_esp.h.
+ *
+ * Revision 1.1  1999/01/21 20:29:12  rgb
+ * Converted from transform switching to algorithm switching.
+ *
+ * Log: ipsec_esp.h,v 
+ * Revision 1.4  1998/08/12 00:07:32  rgb
+ * Added data structures for new xforms: null, {,3}dessha1.
+ *
+ * Revision 1.3  1998/07/14 15:57:01  rgb
+ * Add #ifdef __KERNEL__ to protect kernel-only structures.
+ *
+ * Revision 1.2  1998/06/25 19:33:46  rgb
+ * Add prototype for protocol receive function.
+ * Rearrange for more logical layout.
+ *
+ * Revision 1.1  1998/06/18 21:27:45  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.6  1998/06/05 02:28:08  rgb
+ * Minor comment fix.
+ *
+ * Revision 1.5  1998/05/27 22:34:00  rgb
+ * Changed structures to accomodate key separation.
+ *
+ * Revision 1.4  1998/05/18 22:28:43  rgb
+ * Disable key printing facilities from /proc/net/ipsec_*.
+ *
+ * Revision 1.3  1998/04/21 21:29:07  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:20  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:00  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added ESP-3DES-MD5-96 transform.
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Added definitions for new ESP transforms.
+ *
+ * Revision 0.3  1996/11/20 14:35:48  ji
+ * Minor Cleanup.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
+
+
diff -druN linux-noipsec/net/ipsec/ipsec_sha1.c linux/net/ipsec/ipsec_sha1.c
--- linux-noipsec/net/ipsec/ipsec_sha1.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_sha1.c	Mon Dec 13 14:59:13 1999
@@ -0,0 +1,201 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+ * The rest of the code is derived from sha1.c by Steve Reid, which is
+ * public domain.
+ * Minor cosmetic changes to accomodate it in the Linux kernel by ji.
+ */
+
+#include <asm/byteorder.h>
+#include <linux/string.h>
+
+#include "ipsec_sha1.h"
+
+#if defined(rol)
+#undef rol
+#endif
+
+#define SHA1HANDSOFF
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+#ifdef __LITTLE_ENDIAN
+#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
+    |(rol(block->l[i],8)&0x00FF00FF))
+#else
+#define blk0(i) block->l[i]
+#endif
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+    ^block->l[(i+2)&15]^block->l[i&15],1))
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+
+void SHA1Transform(__u32 state[5], __u8 buffer[64])
+{
+__u32 a, b, c, d, e;
+typedef union {
+    unsigned char c[64];
+    __u32 l[16];
+} CHAR64LONG16;
+CHAR64LONG16* block;
+#ifdef SHA1HANDSOFF
+static unsigned char workspace[64];
+    block = (CHAR64LONG16*)workspace;
+    memcpy(block, buffer, 64);
+#else
+    block = (CHAR64LONG16*)buffer;
+#endif
+    /* Copy context->state[] to working vars */
+    a = state[0];
+    b = state[1];
+    c = state[2];
+    d = state[3];
+    e = state[4];
+    /* 4 rounds of 20 operations each. Loop unrolled. */
+    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
+    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
+    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+    /* Add the working vars back into context.state[] */
+    state[0] += a;
+    state[1] += b;
+    state[2] += c;
+    state[3] += d;
+    state[4] += e;
+    /* Wipe variables */
+    a = b = c = d = e = 0;
+}
+
+
+/* SHA1Init - Initialize new context */
+
+void SHA1Init(SHA1_CTX* context)
+{
+    /* SHA1 initialization constants */
+    context->state[0] = 0x67452301;
+    context->state[1] = 0xEFCDAB89;
+    context->state[2] = 0x98BADCFE;
+    context->state[3] = 0x10325476;
+    context->state[4] = 0xC3D2E1F0;
+    context->count[0] = context->count[1] = 0;
+}
+
+
+/* Run your data through this. */
+
+void SHA1Update(SHA1_CTX* context, unsigned char* data, __u32 len)
+{
+__u32 i, j;
+
+    j = context->count[0];
+    if ((context->count[0] += len << 3) < j)
+	context->count[1]++;
+    context->count[1] += (len>>29);
+    j = (j >> 3) & 63;
+    if ((j + len) > 63) {
+        memcpy(&context->buffer[j], data, (i = 64-j));
+        SHA1Transform(context->state, context->buffer);
+        for ( ; i + 63 < len; i += 64) {
+            SHA1Transform(context->state, &data[i]);
+        }
+        j = 0;
+    }
+    else i = 0;
+    memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+
+/* Add padding and return the message digest. */
+
+void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
+{
+__u32 i, j;
+unsigned char finalcount[8];
+
+    for (i = 0; i < 8; i++) {
+        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
+         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
+    }
+    SHA1Update(context, (unsigned char *)"\200", 1);
+    while ((context->count[0] & 504) != 448) {
+        SHA1Update(context, (unsigned char *)"\0", 1);
+    }
+    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
+    for (i = 0; i < 20; i++) {
+        digest[i] = (unsigned char)
+         ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
+    }
+    /* Wipe variables */
+    i = j = 0;
+    memset(context->buffer, 0, 64);
+    memset(context->state, 0, 20);
+    memset(context->count, 0, 8);
+    memset(&finalcount, 0, 8);
+#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite its own static vars */
+    SHA1Transform(context->state, context->buffer);
+#endif
+}
+
+
+/*
+ * $Log$
+ * Revision 1.5  1999/12/13 13:59:13  rgb
+ * Quick fix to argument size to Update bugs.
+ *
+ * Revision 1.4  1999/04/11 00:29:00  henry
+ * GPL boilerplate
+ *
+ * Revision 1.3  1999/04/06 04:54:27  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.2  1999/01/22 06:55:50  rgb
+ * 64-bit clean-up.
+ *
+ * Revision 1.1  1998/06/18 21:27:50  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.2  1998/04/23 20:54:04  rgb
+ * Fixed md5 and sha1 include file nesting issues, to be cleaned up when
+ * verified.
+ *
+ * Revision 1.1  1998/04/09 03:06:11  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:05  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * New transform
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_sha1.h linux/net/ipsec/ipsec_sha1.h
--- linux-noipsec/net/ipsec/ipsec_sha1.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_sha1.h	Mon Dec 13 14:59:13 1999
@@ -0,0 +1,68 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+ * Here is the original comment from the distribution:
+
+SHA-1 in C
+By Steve Reid <steve@edmweb.com>
+100% Public Domain
+
+ * Adapted for use by the IPSEC code by John Ioannidis
+ */
+
+
+#ifndef _IPSEC_SHA1_H_
+#define _IPSEC_SHA1_H_
+
+typedef struct
+{
+	__u32	state[5];
+	__u32	count[2];
+	__u8	buffer[64];
+} SHA1_CTX;
+
+void SHA1Transform(__u32 state[5], __u8 buffer[64]);
+void SHA1Init(SHA1_CTX *context);
+void SHA1Update(SHA1_CTX *context, unsigned char *data, __u32 len);
+void SHA1Final(unsigned char digest[20], SHA1_CTX *context);
+
+ 
+#endif /* _IPSEC_SHA1_H_ */
+
+/*
+ * $Log$
+ * Revision 1.5  1999/12/13 13:59:13  rgb
+ * Quick fix to argument size to Update bugs.
+ *
+ * Revision 1.4  1999/12/07 18:16:23  rgb
+ * Fixed comments at end of #endif lines.
+ *
+ * Revision 1.3  1999/04/06 04:54:27  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.2  1998/11/30 13:22:54  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.1  1998/06/18 21:27:50  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.2  1998/04/23 20:54:05  rgb
+ * Fixed md5 and sha1 include file nesting issues, to be cleaned up when
+ * verified.
+ *
+ * Revision 1.1  1998/04/09 03:04:21  henry
+ * sources moved up from linux/net/ipsec
+ * these two include files modified not to include others except in kernel
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * New transform
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_tunnel.c linux/net/ipsec/ipsec_tunnel.c
--- linux-noipsec/net/ipsec/ipsec_tunnel.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_tunnel.c	Thu Nov  9 21:52:15 2000
@@ -0,0 +1,3065 @@
+/*
+ * IPSEC Tunneling code. Heavily based on drivers/net/new_tunnel.c
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+char ipsec_tunnel_c_version[] = "RCSID $Id$";
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/config.h>	/* for CONFIG_IP_FORWARD */
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/tcp.h>         /* struct tcphdr */
+#include <linux/udp.h>         /* struct udphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+ #ifdef SPINLOCK_23
+  #include <linux/spinlock.h> /* *lock* */
+ #else /* SPINLOCK_23 */
+  #include <asm/spinlock.h> /* *lock* */
+ #endif /* SPINLOCK_23 */
+#endif /* SPINLOCK */
+#ifdef NET_21
+ #define MSS_HACK_		/* experimental */
+ #include <asm/uaccess.h>
+ #include <linux/in6.h>
+ #define ip_chk_addr inet_addr_type
+ #define IS_MYADDR RTN_LOCAL
+ #include <net/dst.h>
+ #undef dev_kfree_skb
+ #define dev_kfree_skb(a,b) kfree_skb(a)
+ #define proto_priv cb
+ #define PHYSDEV_TYPE
+ #define DEV_QUEUE_XMIT(skb, device, pri) {\
+	skb->dev = device; \
+	neigh_compat_output(skb); \
+	/* skb->dst->output(skb); */ \
+ }
+ #define ICMP_SEND(skb_in, type, code, info, dev) \
+	icmp_send(skb_in, type, code, htonl(info))
+ #define IP_SEND(skb, dev) \
+	ip_send(skb);
+#else /* NET_21 */
+ #define DEV_QUEUE_XMIT(skb, device, pri) {\
+	dev_queue_xmit(skb, device, pri); \
+ }
+ #define ICMP_SEND(skb_in, type, code, info, dev) \
+	icmp_send(skb_in, type, code, info, dev)
+ #define IP_SEND(skb, dev) \
+	if(ntohs(iph->tot_len) > physmtu) { \
+		ip_fragment(NULL, skb, dev, 0); \
+		dev_kfree_skb(skb, FREE_WRITE); \
+	} else { \
+		dev_queue_xmit(skb, dev, SOPRI_NORMAL); \
+	}
+#endif /* NET_21 */
+#include <asm/checksum.h>
+#include <net/icmp.h>		/* icmp_send() */
+#include <net/ip.h>
+#ifdef NETDEV_23
+#include <linux/netfilter_ipv4.h>
+#endif
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_tunnel.h"
+#include "ipsec_ipe4.h"
+#include "ipsec_ah.h"
+#include "ipsec_esp.h"
+
+#ifdef CONFIG_IPSEC_IPCOMP
+#include "ipcomp.h"
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#include <net/ip.h>
+#include <linux/if_arp.h>
+#ifdef MSS_HACK
+#include <net/tcp.h>		/* TCP options */
+#endif	/* MSS_HACK */
+extern void des_ede3_cbc_encrypt(caddr_t, caddr_t, int, caddr_t, caddr_t, caddr_t, caddr_t, int);
+static __u32 zeroes[64];
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_tunnel = 0;
+int sysctl_ipsec_debug_verbose = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+int sysctl_ipsec_icmp = 0;
+int sysctl_ipsec_no_eroute_pass = 0;
+int sysctl_ipsec_opportunistic = 0;
+int sysctl_ipsec_tos = 0;
+
+#ifdef CONFIG_IPSEC_DEBUG_
+DEBUG_NO_STATIC void
+dmp(char *s, caddr_t bb, int len)
+{
+	int i;
+	unsigned char *b = bb;
+  
+	if (debug_tunnel) {
+		printk(KERN_INFO "klips_debug:ipsec_tunnel_:at %s, len=%d:", s, len);
+		for (i=0; i < len; i++) {
+			if(!(i%16)){
+				printk("\nklips_debug:  ");
+			}
+			printk(" %02x", *b++);
+		}
+		printk("\n");
+	}
+}
+#else /* CONFIG_IPSEC_DEBUG */
+#define dmp(_x, _y, _z) 
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifndef SKB_COPY_EXPAND
+/*
+ *	This is mostly skbuff.c:skb_copy().
+ */
+struct sk_buff *
+skb_copy_expand(struct sk_buff *skb, int headroom, int tailroom, int priority)
+{
+	struct sk_buff *n;
+	unsigned long offset;
+
+	/*
+	 *	Do sanity checking
+	 */
+	if((headroom < 0) || (tailroom < 0) || ((headroom+tailroom) < 0)) {
+		printk(KERN_WARNING "klips_error:skb_copy_expand: "
+		       "Illegal negative head,tailroom %d,%d\n",
+		       headroom, tailroom);
+		return NULL;
+	}
+	/*
+	 *	Allocate the copy buffer
+	 */
+	 
+#ifndef NET_21
+	IS_SKB(skb);
+#endif /* !NET_21 */
+
+
+	n=alloc_skb(skb->end - skb->head + headroom + tailroom, priority);
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+		    "klips_debug:skb_copy_expand: "
+		    "head=%p data=%p tail=%p end=%p end-head=%d tail-data=%d\n",
+		    skb->head,
+		    skb->data,
+		    skb->tail,
+		    skb->end,
+		    skb->end - skb->head,
+		    skb->tail - skb->data);
+
+	if(n==NULL)
+		return NULL;
+
+	/*
+	 *	Shift between the two data areas in bytes
+	 */
+	 
+	/* offset=n->head-skb->head; */ /* moved down a few lines */
+
+	/* Set the data pointer */
+	skb_reserve(n,skb->data-skb->head+headroom);
+	/* Set the tail pointer and length */
+	if(skb_tailroom(n) < skb->len) {
+		printk(KERN_WARNING "klips_error:skb_copy_expand: "
+		       "tried to skb_put %ld, %d available.  "
+		       "This should never happen, please report.\n",
+		       (unsigned long int)skb->len, skb_tailroom(n));
+		dev_kfree_skb(n, FREE_WRITE);
+		return NULL;
+	}
+	skb_put(n,skb->len);
+
+	offset=n->head + headroom - skb->head;
+
+	/* Copy the bytes */
+	memcpy(n->head + headroom, skb->head,skb->end-skb->head);
+#ifdef NET_21
+	n->csum=skb->csum;
+	n->priority=skb->priority;
+	n->dst=dst_clone(skb->dst);
+	if(skb->nh.raw)
+		n->nh.raw=skb->nh.raw+offset;
+	n->is_clone=0;
+	atomic_set(&n->users, 1);
+	n->destructor = NULL;
+	n->security=skb->security;
+#else /* NET_21 */
+	n->link3=NULL;
+	n->when=skb->when;
+	if(skb->ip_hdr)
+	        n->ip_hdr=(struct iphdr *)(((char *)skb->ip_hdr)+offset);
+	n->saddr=skb->saddr;
+	n->daddr=skb->daddr;
+	n->raddr=skb->raddr;
+	n->seq=skb->seq;
+	n->end_seq=skb->end_seq;
+	n->ack_seq=skb->ack_seq;
+	n->acked=skb->acked;
+	n->free=1;
+	n->arp=skb->arp;
+	n->tries=0;
+	n->lock=0;
+	n->users=0;
+#endif /* NET_21 */
+	n->protocol=skb->protocol;
+	n->list=NULL;
+	n->sk=NULL;
+	n->dev=skb->dev;
+	if(skb->h.raw)
+		n->h.raw=skb->h.raw+offset;
+	if(skb->mac.raw) 
+		n->mac.raw=skb->mac.raw+offset;
+	memcpy(n->proto_priv, skb->proto_priv, sizeof(skb->proto_priv));
+	n->used=skb->used;
+	n->pkt_type=skb->pkt_type;
+	n->stamp=skb->stamp;
+	
+#ifndef NET_21
+	IS_SKB(n);
+#endif /* !NET_21 */
+	return n;
+}
+#endif /* !SKB_COPY_EXPAND */
+
+#ifdef CONFIG_IPSEC_DEBUG
+void
+ipsec_print_ip(struct iphdr *ip)
+{
+	char buf[ADDRTOA_BUF];
+
+	printk(KERN_INFO "klips_debug:   IP:");
+	printk(" ihl:%d", ip->ihl*4);
+	printk(" ver:%d", ip->version);
+	printk(" tos:%d", ip->tos);
+	printk(" tlen:%d", ntohs(ip->tot_len));
+	printk(" id:%d", ip->id);
+	printk(" frag_off:%d", ip->frag_off);
+	printk(" ttl:%d", ip->ttl);
+	printk(" proto:%d", ip->protocol);
+	printk(" chk:%d", ip->check);
+	addrtoa(*((struct in_addr*)(&ip->saddr)), 0, buf, sizeof(buf));
+	printk(" saddr:%s", buf);
+	addrtoa(*((struct in_addr*)(&ip->daddr)), 0, buf, sizeof(buf));
+	printk(" daddr:%s", buf);
+	printk("\n");
+
+	if(sysctl_ipsec_debug_verbose) {
+		__u8 *c;
+		int i;
+		
+		c = ((__u8*)ip) + ip->ihl*4;
+		for(i = 0; i < ntohs(ip->tot_len) - ip->ihl*4; i++ /*, c++*/) {
+			if(!(i % 16)) {
+				printk(KERN_INFO "klips_debug:   @%03x:",
+				       i);
+			}
+			printk(" %02x", /***/c[i]);
+			if(!((i + 1) % 16)) {
+				printk("\n");
+			}
+		}
+		if(i % 16) {
+			printk("\n");
+		}
+	}
+}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef REAL_LOCKING_P
+/*
+ *	Locking
+ */
+ 
+DEBUG_NO_STATIC int
+ipsec_tunnel_lock(struct ipsecpriv *prv)
+{
+	unsigned long flags;
+	save_flags(flags);
+	cli();
+	/*
+	 *	Lock in an interrupt may fail
+	 */
+	if(prv->locked && in_interrupt()) {
+		restore_flags(flags);
+		return 0;
+	}
+	while(prv->locked)
+		sleep_on(&prv->wait_queue);
+	prv->locked=1;
+	restore_flags(flags);
+	return 1;
+}
+
+DEBUG_NO_STATIC void
+ipsec_tunnel_unlock(struct ipsecpriv *prv)
+{
+	prv->locked=0;
+	wake_up(&prv->wait_queue);
+}
+#endif /* REAL_LOCKING_P */
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_open(struct device *dev)
+{
+	struct ipsecpriv *prv = dev->priv;
+	
+	/*
+	 * Can't open until attached.
+	 */
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_open: "
+		    "dev = %s, prv->dev = %s\n",
+		    dev->name, prv->dev?prv->dev->name:"NONE");
+
+	if (prv->dev == NULL)
+		return -ENODEV;
+	
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_close(struct device *dev)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+#ifdef MSS_HACK
+/*
+ * Issues:
+ *  1) Fragments arriving in the tunnel should probably be rejected.
+ *  2) How does this affect syncookies, mss_cache, dst cache ?
+ *  3) Path MTU discovery handling needs to be reviewed.  For example,
+ *     if we receive an ICMP 'packet too big' message from an intermediate 
+ *     router specifying it's next hop MTU, our stack may process this and
+ *     adjust the MSS without taking our AH/ESP overheads into account.
+ */
+
+ 
+/*
+ * Recaclulate checksum using differences between changed datum, 
+ * borrowed from netfilter.
+ */
+DEBUG_NO_STATIC u_int16_t 
+ipsec_fast_csum(u_int32_t oldvalinv, u_int32_t newval, u_int16_t oldcheck)
+{
+	u_int32_t diffs[] = { oldvalinv, newval };
+	return csum_fold(csum_partial((char *)diffs, sizeof(diffs),
+	oldcheck^0xFFFF));
+}
+
+/*
+ * Determine effective MSS.
+ *
+ * Note that we assume that there is always an MSS option for our own
+ * SYN segments, which is mentioned in tcp_syn_build_options(), kernel 2.2.x.
+ * This could change, and we should probably parse TCP options instead.
+ *
+ */
+DEBUG_NO_STATIC u_int8_t
+ipsec_adjust_mss(struct sk_buff *skb, struct tcphdr *tcph, u_int16_t mtu)
+{
+	u_int16_t oldmss, newmss;
+	u_int32_t *mssp;
+	struct sock *sk = skb->sk;
+	
+	newmss = tcp_sync_mss(sk, mtu);
+	printk(KERN_INFO "klips: setting mss to %u\n", newmss);
+	mssp = (u_int32_t *)tcph + sizeof(struct tcphdr) / sizeof(u_int32_t);
+	oldmss = ntohl(*mssp) & 0x0000FFFF;
+	*mssp = htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) | newmss);
+	tcph->check = ipsec_fast_csum(htons(~oldmss), 
+	                              htons(newmss), tcph->check);
+	return 1;
+}
+#endif	/* MSS_HACK */
+                                                        
+#ifdef NETDEV_23
+static inline int ipsec_tunnel_xmit2(struct sk_buff *skb)
+{
+	return ip_send(skb);
+}
+#endif
+
+/*
+ *	This function assumes it is being called from dev_queue_xmit()
+ *	and that skb is filled properly by that function.
+ */
+
+int
+ipsec_tunnel_start_xmit(struct sk_buff *skb, struct device *dev)
+{
+	struct ipsecpriv *prv;		/* Our device' private space */
+	struct sk_buff *oskb = NULL;	/* Original skb pointer */
+	struct net_device_stats *stats;	/* This device's statistics */
+	struct iphdr  *iph;		/* Our new IP header */
+	__u32   newdst;			/* The other SG's IP address */
+	__u32	orgdst;			/* Original IP destination address */
+	__u32	orgedst;		/* 1st SG's IP address */
+	__u32   newsrc;			/* The new source SG's IP address */
+	__u32	orgsrc;			/* Original IP source address */
+	__u32	innersrc;		/* Innermost IP source address */
+	int	iphlen;			/* IP header length */
+	int	pyldsz;			/* upper protocol payload size */
+	int	headroom;
+	int	tailroom;
+	int     max_headroom = 0;	/* The extra header space needed */
+	int	max_tailroom = 0;	/* The extra stuffing needed */
+	int     ll_headroom;		/* The extra link layer hard_header space needed */
+	int     tot_headroom = 0;	/* The total header space needed */
+	int	tot_tailroom = 0;	/* The totalstuffing needed */
+	__u8	*saved_header = NULL;	/* saved copy of the hard header */
+	int i;
+
+	struct sockaddr_encap matcher;	/* eroute search key */
+	struct eroute *er;
+	struct tdb *tdbp, *tdbq;	/* Tunnel Descriptor Block pointers */
+	char sa[SATOA_BUF];
+	size_t sa_len;
+	int hard_header_stripped = 0;	/* has the hard header been removed yet? */
+	int hard_header_len = 0;
+	struct device *physdev;
+/*	struct device *virtdev; */
+	short physmtu;
+	short mtudiff;
+#ifdef NET_21
+	struct rtable *rt = NULL;
+#endif /* NET_21 */
+	struct sa_id outgoing_said;
+
+	/*
+	 *	Return if there is nothing to do.  (Does this ever happen?) XXX
+	 */
+	if (skb == NULL) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_error:ipsec_tunnel_start_xmit: "
+			    "Nothing to do!\n" );
+		goto cleanup;
+	}
+	if (dev == NULL) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_error:ipsec_tunnel_start_xmit: "
+			    "No device associated with skb!\n" );
+		goto cleanup;
+	}
+
+	prv = dev->priv;
+	if (prv == NULL) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_error:ipsec_tunnel_start_xmit: "
+			    "Device has no private structure!\n" );
+		goto cleanup;
+	}
+
+	physdev = prv->dev;
+	if (physdev == NULL) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_error:ipsec_tunnel_start_xmit: "
+			    "Device is not attached to physical device!\n" );
+		goto cleanup;
+	}
+
+	physmtu = physdev->mtu;
+
+	stats = (struct net_device_stats *) &(prv->mystats);
+
+#ifdef NET_21
+	/* if skb was cloned (most likely due to a packet sniffer such as
+	   tcpdump being momentarily attached to the interface), make
+	   a copy of our own to modify */
+	if(skb_cloned(skb)) {
+		if ((skb = skb_cow(skb, skb_headroom(skb))) == NULL) {
+			KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+		        	    "klips_error:ipsec_tunnel_start_xmit: "
+				    "skb_cow failed to allocate buffer, dropping.\n" );
+			goto cleanup;
+		}
+	}
+#endif /* NET_21 */
+
+#ifdef NET_21
+	iph = skb->nh.iph;
+#else /* NET_21 */
+	iph = skb->ip_hdr;
+#endif /* NET_21 */
+
+	/* physdev->hard_header_len is unreliable and should not be used */
+	hard_header_len = (unsigned char *)iph - skb->data;
+
+	if(hard_header_len < 0) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_error:ipsec_tunnel_start_xmit: "
+			    "Negative hard_header_len (%d)?!\n", hard_header_len);
+		stats->tx_dropped++;
+		goto cleanup;
+	}
+
+	if(hard_header_len == 0) { /* no hard header present */
+		hard_header_stripped = 1;
+	}
+
+#ifdef CONFIG_IPSEC_DEBUG
+	if (debug_tunnel & DB_TN_XMIT) {
+		int i;
+		char c;
+		
+		printk(KERN_INFO "klips_debug:ipsec_tunnel_start_xmit: "
+		       ">>> skb->len=%ld hard_header_len:%d",
+		       (unsigned long int)skb->len, hard_header_len);
+		c = ' ';
+		for (i=0; i < hard_header_len; i++) {
+			printk("%c%02x", c, skb->data[i]);
+			c = ':';
+		}
+		printk(" \n");
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	KLIPS_IP_PRINT(debug_tunnel & DB_TN_XMIT, iph);
+
+	/*
+	 * Sanity checks
+	 */
+
+	if ((iph->ihl << 2) != sizeof (struct iphdr)) {
+		KLIPS_PRINT(debug_tunnel,
+			    "klips_debug:ipsec_tunnel_start_xmit: "
+			    "cannot process IP header options yet.  "
+			    "May be mal-formed packet.\n"); /* XXX */
+		stats->tx_dropped++;
+		goto cleanup;
+	}
+	
+#ifndef NET_21
+	/* TTL decrement code (on the way out!) borrowed from ip_forward.c */
+	if(0) {
+		unsigned long checksum = iph->check;
+		iph->ttl--;
+	/*
+	 *	Re-compute the IP header checksum.
+	 *	This is efficient. We know what has happened to the header
+	 *	and can thus adjust the checksum as Phil Karn does in KA9Q
+	 *	except we do this in "network byte order".
+	 */
+		checksum += htons(0x0100);
+		/* carry overflow? */
+		checksum += checksum >> 16;
+		iph->check = checksum;
+	}
+	if (iph->ttl <= 0) {
+		/* Tell the sender its packet died... */
+		ICMP_SEND(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0, physdev);
+
+		KLIPS_PRINT(debug_tunnel, "klips_debug:ipsec_tunnel_start_xmit: "
+			    "TTL=0, too many hops!\n");
+		stats->tx_dropped++;
+		goto cleanup;
+	}
+#endif /* !NET_21 */
+
+	/*
+	 * First things first -- look us up in the erouting tables.
+	 */
+	matcher.sen_len = sizeof (struct sockaddr_encap);
+	matcher.sen_family = AF_ENCAP;
+	matcher.sen_type = SENT_IP4;
+	matcher.sen_ip_src.s_addr = iph->saddr;
+	matcher.sen_ip_dst.s_addr = iph->daddr;
+
+	/*
+	 * The spinlock is to prevent any other process from accessing or deleting
+	 * the eroute while we are using and updating it.
+	 */
+	spin_lock(&eroute_lock);
+	
+	er = ipsec_findroute(&matcher);
+	if(er) {
+		outgoing_said = er->er_said;
+	}
+
+	spin_unlock(&eroute_lock);
+
+	/*
+	 * Quick cheat for now...are we udp/500? If so, let it through
+	 * without interference since it is most likely an IKE packet.
+	 */
+	if((ip_chk_addr((unsigned long)iph->saddr) == IS_MYADDR)
+	   && ((!er) || (iph->daddr == outgoing_said.dst.s_addr))) {
+		if(iph->protocol == IPPROTO_UDP) {
+			struct udphdr *udph = (struct udphdr*)((caddr_t)iph + (iph->ihl << 2));
+			if(ntohs(udph->dest) == 500) {
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "udp/500 IKE packet, sending unprocessed, "
+					    "calling dev_queue_xmit\n"); 
+#if 1
+				goto bypass;
+#else
+				DEV_QUEUE_XMIT(skb, physdev, SOPRI_NORMAL);
+				/* IP_SEND(skb, physdev); */
+				skb = NULL;
+				goto cleanup;
+#endif
+			}
+		}
+	}
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+		    "klips_debug:ipsec_tunnel_start_xmit: "
+		    "Original head,tailroom: %d,%d\n",
+		    skb_headroom(skb), skb_tailroom(skb));
+
+	innersrc = iph->saddr;
+	/* start encapsulation loop here XXX */
+	do {
+		newdst = orgdst = iph->daddr;
+		newsrc = orgsrc = iph->saddr;
+		orgedst = outgoing_said.dst.s_addr;
+		iphlen = iph->ihl << 2;
+		pyldsz = ntohs(iph->tot_len) - iphlen;
+		max_headroom = max_tailroom = 0;
+		
+		if (er == NULL)	{
+			if(sysctl_ipsec_no_eroute_pass) {
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "no eroute!: calling dev_queue_xmit\n");
+#if 1
+				goto bypass;
+#else
+				DEV_QUEUE_XMIT(skb, physdev, SOPRI_NORMAL);
+				/* IP_SEND(skb, physdev); */
+				skb = NULL;
+#endif
+			} else {
+				if(sysctl_ipsec_opportunistic && !er) {
+					struct tdb tdb;
+					struct sockaddr_in src, dst;
+#ifdef CONFIG_IPSEC_DEBUG
+					char buf[ADDRTOA_BUF];
+#endif /* CONFIG_IPSEC_DEBUG */
+					
+					tdb.tdb_said.proto = iph->protocol;
+					src.sin_family = AF_INET;
+					dst.sin_family = AF_INET;
+					src.sin_addr.s_addr = iph->saddr;
+					dst.sin_addr.s_addr = iph->daddr;
+					src.sin_port = 
+						(iph->protocol == IPPROTO_UDP
+						 ? ((struct udphdr*) (((caddr_t)iph) + (iph->ihl << 2)))->source
+						 : (iph->protocol == IPPROTO_TCP
+						    ? ((struct tcphdr*)((caddr_t)iph + (iph->ihl << 2)))->source
+						    : 0));
+					dst.sin_port = 
+						(iph->protocol == IPPROTO_UDP
+						 ? ((struct udphdr*) (((caddr_t)iph) + (iph->ihl << 2)))->dest
+						 : (iph->protocol == IPPROTO_TCP
+						    ? ((struct tcphdr*)((caddr_t)iph + (iph->ihl << 2)))->dest
+						    : 0));
+					for(i = 0;
+					    i < sizeof(struct sockaddr_in)
+						    - offsetof(struct sockaddr_in, sin_zero);
+					    i++) {
+						src.sin_zero[i] = 0;
+						dst.sin_zero[i] = 0;
+					}
+					
+					tdb.tdb_addr_s = (struct sockaddr*)(&src);
+					tdb.tdb_addr_d = (struct sockaddr*)(&dst);
+					KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+						    "klips_debug:ipsec_tunnel_start_xmit: "
+						    "SADB_ACQUIRE sent with src=%s:%d, dst=%s:%d, proto=%d.\n",
+						    addrtoa(((struct sockaddr_in*)(tdb.tdb_addr_s))->sin_addr, 0, buf, sizeof(buf)) <= ADDRTOA_BUF ? buf : "BAD_ADDR",
+						    ((struct sockaddr_in*)(tdb.tdb_addr_s))->sin_port,
+						    addrtoa(((struct sockaddr_in*)(tdb.tdb_addr_d))->sin_addr, 0, buf, sizeof(buf)) <= ADDRTOA_BUF ? buf : "BAD_ADDR",
+						    ((struct sockaddr_in*)(tdb.tdb_addr_d))->sin_port,
+						    tdb.tdb_said.proto);
+					pfkey_acquire(&tdb);
+				} else {
+					KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+						    "klips_debug:ipsec_tunnel_start_xmit: "
+						    "no eroute!: dropping.\n");
+					stats->tx_dropped++;
+				}
+			}
+			goto cleanup;
+		}
+		
+		/*
+		  If the packet matches an eroute with an SA.proto of IP
+		  tunnelling and 
+		  an SA.spi of '0', then forward the packet unprotected.
+		  XXX -- This should eventually go into an SPD. 
+		*/
+		if((outgoing_said.proto == IPPROTO_IPIP) && (outgoing_said.spi == 0)) {
+			KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "passthrough eroute, packet sent.\n");
+#if 1
+			goto bypass;
+#else
+			DEV_QUEUE_XMIT(skb, physdev, SOPRI_NORMAL);
+			/* IP_SEND(skb, physdev); */
+			skb = NULL;
+			goto cleanup;
+#endif
+		}
+		
+		/*
+		 * The spinlock is to prevent any other process from accessing or deleting
+		 * the tdb while we are using and updating it.
+		 */
+		spin_lock(&tdb_lock);
+
+		tdbp = gettdb(&outgoing_said);
+		sa_len = satoa(outgoing_said, 0, sa, SATOA_BUF);
+
+		if (tdbp == NULL) {
+			spin_unlock(&tdb_lock);
+			KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "no Tunnel Descriptor Block for SA%s: "
+				    "outgoing packet with no SA, dropped.\n", sa);
+			stats->tx_dropped++;
+			goto cleanup;
+		}
+		
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_debug:ipsec_tunnel_start_xmit: "
+			    "found Tunnel Descriptor Block -- SA:<%s%s%s> %s\n",
+			    TDB_XFORM_NAME(tdbp), sa);
+		
+		/*
+		 * How much headroom do we need to be able to apply
+		 * all the grouped transforms?
+		 */
+		tdbq = tdbp;	/* save the head of the tdb chain */
+		while (tdbp)	{
+			sa_len = satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+
+			/* If it is in larval state, drop the packet, we cannot process yet. */
+			if(tdbp->tdb_state == SADB_SASTATE_LARVAL) {
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "TDB in larval state for SA:<%s%s%s> %s, "
+					    "cannot be used yet, dropping packet.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+
+			if(tdbp->tdb_state == SADB_SASTATE_DEAD) {
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "TDB in dead state for SA:<%s%s%s> %s, "
+					    "can no longer be used, dropping packet.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+
+			/* If the replay window counter == -1, expire SA, it will roll */
+			if(tdbp->tdb_replaywin && tdbp->tdb_replaywin_lastseq == -1) {
+				pfkey_expire(tdbp, 1);
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "replay window counter rolled for SA:<%s%s%s> %s, "
+					    "packet dropped, expiring SA.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				deltdbchain(tdbp);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+
+			/* If any of the lifetime counters have overflowed, expire the SA(s). */
+			if(tdbp->tdb_lifetime_bytes_h &&
+			   (tdbp->tdb_lifetime_bytes_c > tdbp->tdb_lifetime_bytes_h)) {
+				pfkey_expire(tdbp, 1);
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "hard bytes lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expired, outgoing packet dropped.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				deltdbchain(tdbp);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			if(tdbp->tdb_lifetime_bytes_s &&
+			   (tdbp->tdb_lifetime_bytes_c > tdbp->tdb_lifetime_bytes_s)) {
+				pfkey_expire(tdbp, 0);
+				tdbp->tdb_state = SADB_SASTATE_DYING;
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "soft bytes lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expiring, soft expire message sent up, "
+					    "outgoing packet still processed.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+			}
+
+			if(tdbp->tdb_lifetime_addtime_h &&
+			   ((jiffies / HZ) - tdbp->tdb_lifetime_addtime_c >
+			    tdbp->tdb_lifetime_addtime_h)) {
+				pfkey_expire(tdbp, 1);
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "hard addtime lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expired, outgoing packet dropped.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				deltdbchain(tdbp);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			if(tdbp->tdb_lifetime_addtime_s &&
+			   ((jiffies / HZ) - tdbp->tdb_lifetime_addtime_c >
+			    tdbp->tdb_lifetime_addtime_s)) {
+				pfkey_expire(tdbp, 0);
+				tdbp->tdb_state = SADB_SASTATE_DYING;
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "soft addtime lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expiring, soft expire message sent up, "
+					    "outgoing packet still processed.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+			}
+
+			if(tdbp->tdb_lifetime_usetime_c) {
+				if(tdbp->tdb_lifetime_usetime_h &&
+				   ((jiffies / HZ) - tdbp->tdb_lifetime_usetime_c >
+				    tdbp->tdb_lifetime_usetime_h)) {
+					pfkey_expire(tdbp, 1);
+					KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+						    "klips_debug:ipsec_tunnel_start_xmit: "
+						    "hard usetime lifetime of SA:<%s%s%s> %s has been reached, "
+						    "SA expired, outgoing packet dropped.\n",
+						    TDB_XFORM_NAME(tdbp), sa);
+					deltdbchain(tdbp);
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				if(tdbp->tdb_lifetime_usetime_s &&
+				   ((jiffies / HZ) - tdbp->tdb_lifetime_usetime_c >
+				    tdbp->tdb_lifetime_usetime_s)) {
+					pfkey_expire(tdbp, 0);
+					tdbp->tdb_state = SADB_SASTATE_DYING;
+					KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+						    "klips_debug:ipsec_tunnel_start_xmit: "
+						    "soft usetime lifetime of SA:<%s%s%s> %s has been reached, "
+						    "SA expiring, soft expire message sent up, "
+						    "outgoing packet still processed.\n",
+						    TDB_XFORM_NAME(tdbp), sa);
+				}
+			}
+
+			if(tdbp->tdb_lifetime_packets_h &&
+			   (tdbp->tdb_lifetime_packets_c > tdbp->tdb_lifetime_packets_h)) {
+				pfkey_expire(tdbp, 1);
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "hard packets lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expired, outgoing packet dropped.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+				deltdbchain(tdbp);
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			if(tdbp->tdb_lifetime_packets_s &&
+			   (tdbp->tdb_lifetime_packets_c > tdbp->tdb_lifetime_packets_s)) {
+				pfkey_expire(tdbp, 0);
+				tdbp->tdb_state = SADB_SASTATE_DYING;
+				KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+					    "klips_debug:ipsec_tunnel_start_xmit: "
+					    "soft packets lifetime of SA:<%s%s%s> %s has been reached, "
+					    "SA expiring, soft expire message sent up, "
+					    "outgoing packet still processed.\n",
+					    TDB_XFORM_NAME(tdbp), sa);
+			}
+
+			headroom = tailroom = 0;
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "calling room for <%s%s%s>, SA:%s\n", 
+				    TDB_XFORM_NAME(tdbp), sa);
+			switch(tdbp->tdb_said.proto) {
+#ifdef CONFIG_IPSEC_AH
+			case IPPROTO_AH:
+				headroom += sizeof(struct ah);
+				break;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_ESP
+			case IPPROTO_ESP:
+				switch(tdbp->tdb_encalg) {
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case ESP_3DES:
+					headroom += sizeof(struct esp);
+					break;
+#endif /* CONFIG_IPSEC_ENC_3DES */
+#ifdef CONFIG_IPSEC_ENC_NULL
+				case ESP_NULL:
+					headroom += offsetof(struct esp, esp_iv);
+					break;
+#endif /* CONFIG_IPSEC_ENC_NULL */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				case AH_MD5:
+					tailroom += AHHMAC_HASHLEN;
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				case AH_SHA:
+					tailroom += AHHMAC_HASHLEN;
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+				case AH_NONE:
+					break;
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}			
+				tailroom += ((8 - ((pyldsz + 2 * sizeof(unsigned char)) % 8)) % 8) + 2;
+				break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_IPIP
+			case IPPROTO_IPIP:
+				headroom += sizeof(struct iphdr);
+				break;
+#endif /* !CONFIG_IPSEC_IPIP */
+			case IPPROTO_COMP:
+#ifdef CONFIG_IPSEC_IPCOMP
+				/*
+				  We can't predict how much the packet will
+				  shrink without doing the actual compression.
+				  We could do it here, if we were the first
+				  encapsulation in the chain.  That might save
+				  us a skb_copy_expand, since we might fit
+				  into the existing skb then.  However, this
+				  would be a bit unclean (and this hack has
+				  bit us once), so we better not do it. After
+				  all, the skb_copy_expand is cheap in
+				  comparison to the actual compression.
+				  At least we know the packet will not grow.
+				*/
+				break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+			default:
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			tdbp = tdbp->tdb_onext;
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "Required head,tailroom: %d,%d\n", 
+				    headroom, tailroom);
+			max_headroom += headroom;
+			max_tailroom += tailroom;
+			pyldsz += (headroom + tailroom);
+		}
+		tdbp = tdbq;	/* restore the head of the tdb chain */
+		
+		KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+			    "klips_debug:ipsec_tunnel_start_xmit: "
+			    "existing head,tailroom: %d,%d "
+			    "before applying xforms with head,tailroom: %d,%d .\n",
+			    skb_headroom(skb), skb_tailroom(skb),
+			    max_headroom, max_tailroom);
+		
+		tot_headroom += max_headroom;
+		tot_tailroom += max_tailroom;
+		
+		mtudiff = prv->mtu + tot_headroom + tot_tailroom - physmtu;
+
+		KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+			    "klips_debug:ipsec_tunnel_start_xmit: mtu:%d physmtu:%d "
+			    "tothr:%d tottr:%d mtudiff:%d ippkttotlen:%d\n",
+			    prv->mtu, physmtu,
+			    tot_headroom, tot_tailroom, mtudiff, ntohs(iph->tot_len));
+		if(mtudiff > 0) {
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_info:ipsec_tunnel_start_xmit: "
+				    "dev %s mtu of %d decreased by %d\n",
+				    dev->name,
+				    prv->mtu,
+				    prv->mtu - (physmtu - tot_headroom - tot_tailroom));
+			prv->mtu = physmtu - (tot_headroom + tot_tailroom + 7);	/* add some slop? */
+#ifdef NET_21
+#if 0
+			skb->dst->pmtu = prv->mtu; /* RGB */
+#endif /* 0 */
+#else /* NET_21 */
+#if 0
+			dev->mtu = prv->mtu; /* RGB */
+#endif /* 0 */
+#endif /* NET_21 */
+		}
+		
+#ifdef MSS_HACK
+		/*
+		 * If this is a transport mode TCP packet with
+		 * SYN set, determine an effective MSS based on 
+		 * AH/ESP overheads determined above.
+		 */
+		if (iph->protocol == IPPROTO_TCP 
+		    && outgoing_said.proto != IPPROTO_IPIP) {
+			struct tcphdr *tcph = skb->h.th;
+			if (tcph->syn && !tcph->ack) {
+				if(!ipsec_adjust_mss(skb, tcph, prv->mtu)) {
+					spin_unlock(&tdb_lock);
+					printk(KERN_WARNING "klips: "
+					       "ipsec_adjust_mss() failed\n");
+					stats->tx_errors++;
+					goto cleanup;
+				}
+			}
+		}
+#endif /* MSS_HACK */
+
+		if(!hard_header_stripped) {
+			if((saved_header = kmalloc(hard_header_len, GFP_ATOMIC)) == NULL) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_debug:ipsec_tunnel_start_xmit: Failed, "
+				       "tried to allocate %d bytes for temp hard_header.\n", 
+				       hard_header_len);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			for (i = 0; i < hard_header_len; i++) {
+				saved_header[i] = skb->data[i];
+			}
+			if(skb->len < hard_header_len) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+				       "tried to skb_pull hhlen=%d, %d available.  "
+				       "This should never happen, please report.\n",
+				       hard_header_len, (int)(skb->len));
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			skb_pull(skb, hard_header_len);
+			hard_header_stripped = 1;
+			
+/*			iph = (struct iphdr *) (skb->data); */
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "head,tailroom: %d,%d after hard_header stripped.\n",
+				    skb_headroom(skb), skb_tailroom(skb));
+			KLIPS_IP_PRINT(debug_tunnel & DB_TN_CROUT, iph);
+		} else {
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "hard header already stripped.\n");
+		}
+		
+		ll_headroom = (hard_header_len + 15) & ~15;
+
+		if ((skb_headroom(skb) >= max_headroom + 2 * ll_headroom) && 
+		    (skb_tailroom(skb) >= max_tailroom)
+#ifndef NET_21
+			&& skb->free
+#endif /* !NET_21 */
+			) {
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "data fits in existing skb\n");
+		} else {
+			struct sk_buff* tskb = skb;
+
+			if(!oskb) {
+				oskb = skb;
+			}
+
+			tskb = skb_copy_expand(skb,
+			/* The reason for 2 * link layer length here still baffles me...RGB */
+					       max_headroom + 2 * ll_headroom,
+					       max_tailroom,
+					       GFP_ATOMIC);
+#ifdef NET_21
+			if(tskb && skb->sk) {
+				skb_set_owner_w(tskb, skb->sk);
+			}
+#endif /* NET_21 */
+			if(!(skb == oskb) ) {
+				dev_kfree_skb(skb, FREE_WRITE);
+			}
+			skb = tskb;
+			if (!skb) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_debug:ipsec_tunnel_start_xmit: Failed, "
+				       "tried to allocate %d head and %d tailroom\n", 
+				       max_headroom, max_tailroom);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "head,tailroom: %d,%d after allocation\n",
+				    skb_headroom(skb), skb_tailroom(skb));
+		}
+		
+		/*
+		 * Apply grouped transforms to packet
+		 */
+		while (tdbp) {
+#ifdef CONFIG_IPSEC_ESP
+			struct esp *espp;
+			__u32 iv[2];
+			unsigned char *idat, *pad;
+			int authlen = 0, padlen = 0, i;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+			struct iphdr ipo;
+			struct ah *ahp;
+#endif /* CONFIG_IPSEC_AH */
+#if defined(CONFIG_IPSEC_AUTH_HMAC_MD5) || defined(CONFIG_IPSEC_AUTH_HMAC_SHA1)
+			union {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				MD5_CTX md5;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				SHA1_CTX sha1;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+			} tctx;
+			__u8 hash[AH_AMAX];
+#endif /* defined(CONFIG_IPSEC_AUTH_HMAC_MD5) || defined(CONFIG_IPSEC_AUTH_HMAC_SHA1) */
+			int headroom = 0, tailroom = 0, ilen = 0, len = 0;
+			unsigned char *dat;
+			
+			iphlen = iph->ihl << 2;
+			pyldsz = ntohs(iph->tot_len) - iphlen;
+			sa_len = satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+			KLIPS_PRINT(debug_tunnel & DB_TN_OXFS,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "calling output for <%s%s%s>, SA:%s\n", 
+				    TDB_XFORM_NAME(tdbp), sa);
+			
+			switch(tdbp->tdb_said.proto) {
+#ifdef CONFIG_IPSEC_AH
+			case IPPROTO_AH:
+				headroom += sizeof(struct ah);
+				break;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_ESP
+			case IPPROTO_ESP:
+				switch(tdbp->tdb_encalg) {
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case ESP_3DES:
+					headroom += sizeof(struct esp);
+					break;
+#endif /* CONFIG_IPSEC_ENC_3DES */
+#ifdef CONFIG_IPSEC_ENC_NULL
+				case ESP_NULL:
+					headroom += offsetof(struct esp, esp_iv);
+					break;
+#endif /* CONFIG_IPSEC_ENC_NULL */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				case AH_MD5:
+					authlen = AHHMAC_HASHLEN;
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				case AH_SHA:
+					authlen = AHHMAC_HASHLEN;
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+				case AH_NONE:
+					break;
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}		
+				tailroom += ((8 - ((pyldsz + 2 * sizeof(unsigned char)) % 8)) % 8) + 2;
+				tailroom += authlen;
+				break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_IPIP
+			case IPPROTO_IPIP:
+				headroom += sizeof(struct iphdr);
+				break;
+#endif /* !CONFIG_IPSEC_IPIP */
+#ifdef CONFIG_IPSEC_IPCOMP
+			case IPPROTO_COMP:
+				break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+			default:
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "pushing %d bytes, putting %d, proto %d.\n", 
+				    headroom, tailroom, tdbp->tdb_said.proto);
+			if(skb_headroom(skb) < headroom) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+				       "tried to skb_push headroom=%d, %d available.  "
+				       "This should never happen, please report.\n",
+				       headroom, skb_headroom(skb));
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			dat = skb_push(skb, headroom);
+			ilen = skb->len - tailroom;
+			if(skb_tailroom(skb) < tailroom) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+				       "tried to skb_put %d, %d available.  "
+				       "This should never happen, please report.\n",
+				       tailroom, skb_tailroom(skb));
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			skb_put(skb, tailroom);
+			KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "head,tailroom: %d,%d before xform.\n",
+				    skb_headroom(skb), skb_tailroom(skb));
+			len = skb->len;
+			if(len > 0xfff0) {
+				spin_unlock(&tdb_lock);
+				printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+				       "tot_len (%d) > 65520.  "
+				       "This should never happen, please report.\n",
+				       len);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			memmove((void *)dat, (void *)(dat + headroom), iphlen);
+			iph = (struct iphdr *)dat;
+			iph->tot_len = htons(skb->len);
+			
+			switch(tdbp->tdb_said.proto) {
+#ifdef CONFIG_IPSEC_ESP
+			case IPPROTO_ESP:
+				espp = (struct esp *)(dat + iphlen);
+				espp->esp_spi = tdbp->tdb_said.spi;
+				espp->esp_rpl = htonl(++(tdbp->tdb_replaywin_lastseq));
+				
+				switch(tdbp->tdb_encalg) {
+#if defined(CONFIG_IPSEC_ENC_3DES)
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case ESP_3DES:
+#endif /* CONFIG_IPSEC_ENC_3DES */
+					iv[0] = *((__u32*)&(espp->esp_iv)    ) =
+						((__u32*)(tdbp->tdb_iv))[0];
+					iv[1] = *((__u32*)&(espp->esp_iv) + 1) =
+						((__u32*)(tdbp->tdb_iv))[1];
+					break;
+#endif /* defined(CONFIG_IPSEC_ENC_3DES) */
+#ifdef CONFIG_IPSEC_ENC_NULL
+				case ESP_NULL:
+					break;
+#endif /* CONFIG_IPSEC_ENC_NULL */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				
+				idat = dat + iphlen + headroom;
+				ilen = len - (iphlen + headroom + authlen);
+				
+				/* Self-describing padding */
+				pad = &dat[len - tailroom];
+				padlen = tailroom - 2 - authlen;
+				for (i = 0; i < padlen; i++) {
+					pad[i] = i + 1; 
+				}
+				dat[len - authlen - 2] = padlen;
+				
+				dat[len - authlen - 1] = iph->protocol;
+				iph->protocol = IPPROTO_ESP;
+				
+				switch(tdbp->tdb_encalg) {
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case ESP_3DES:
+					des_ede3_cbc_encrypt(idat, idat, ilen,
+							     (caddr_t)(&((struct des_eks*)(tdbp->tdb_key_e))[0]),
+							     (caddr_t)(&((struct des_eks*)(tdbp->tdb_key_e))[1]),
+							     (caddr_t)(&((struct des_eks*)(tdbp->tdb_key_e))[2]),
+							     (caddr_t)iv, 1);
+					break;
+#endif /* CONFIG_IPSEC_ENC_3DES */
+#ifdef CONFIG_IPSEC_ENC_NULL
+				case ESP_NULL:
+					break;
+#endif /* CONFIG_IPSEC_ENC_NULL */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				
+				switch(tdbp->tdb_encalg) {
+#if defined(CONFIG_IPSEC_ENC_3DES)
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case ESP_3DES:
+#endif /* CONFIG_IPSEC_ENC_3DES */
+					/* XXX update IV with the last 8 octets of the encryption */
+					((__u32*)(tdbp->tdb_iv))[0] =
+						((__u32 *)(idat))[(ilen >> 2) - 2];
+					((__u32*)(tdbp->tdb_iv))[1] =
+						((__u32 *)(idat))[(ilen >> 2) - 1];
+					break;
+#endif /* defined(CONFIG_IPSEC_ENC_3DES) */
+#ifdef CONFIG_IPSEC_ENC_NULL
+				case ESP_NULL:
+					break;
+#endif /* CONFIG_IPSEC_ENC_NULL */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+				
+				switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				case AH_MD5:
+					dmp("espp", (char*)espp, len - iphlen - authlen);
+					tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->ictx;
+					dmp("ictx", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, (caddr_t)espp, len - iphlen - authlen);
+					dmp("ictx+dat", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Final(hash, &tctx.md5);
+					dmp("ictx hash", (char*)&hash, sizeof(hash));
+					tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->octx;
+					dmp("octx", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, hash, AHMD596_ALEN);
+					dmp("octx+hash", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Final(hash, &tctx.md5);
+					dmp("octx hash", (char*)&hash, sizeof(hash));
+					memcpy(&(dat[len - authlen]), hash, authlen);
+
+					/* paranoid */
+					memset((caddr_t)&tctx.md5, 0, sizeof(tctx.md5));
+					memset((caddr_t)hash, 0, sizeof(*hash));
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				case AH_SHA:
+					tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx;
+					SHA1Update(&tctx.sha1, (caddr_t)espp, len - iphlen - authlen);
+					SHA1Final(hash, &tctx.sha1);
+					tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->octx;
+					SHA1Update(&tctx.sha1, hash, AHSHA196_ALEN);
+					SHA1Final(hash, &tctx.sha1);
+					memcpy(&(dat[len - authlen]), hash, authlen);
+					
+					/* paranoid */
+					memset((caddr_t)&tctx.sha1, 0, sizeof(tctx.sha1));
+					memset((caddr_t)hash, 0, sizeof(*hash));
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+				case AH_NONE:
+					break;
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+#ifdef NET_21
+				skb->h.raw = (unsigned char*)espp;
+#endif /* NET_21 */
+				break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_AH
+			case IPPROTO_AH:
+				ahp = (struct ah *)(dat + iphlen);
+				ahp->ah_spi = tdbp->tdb_said.spi;
+				ahp->ah_rpl = htonl(++(tdbp->tdb_replaywin_lastseq));
+				ahp->ah_rv = 0;
+				ahp->ah_nh = iph->protocol;
+				ahp->ah_hl = (headroom >> 2) - sizeof(__u64)/sizeof(__u32);
+				iph->protocol = IPPROTO_AH;
+				dmp("ahp", (char*)ahp, sizeof(*ahp));
+				
+				ipo = *iph;
+				ipo.tos = 0;
+				ipo.frag_off = 0;
+				ipo.ttl = 0;
+				ipo.check = 0;
+				dmp("ipo", (char*)&ipo, sizeof(ipo));
+				
+				switch(tdbp->tdb_authalg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				case AH_MD5:
+					tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->ictx;
+					dmp("ictx", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, (unsigned char *)&ipo, sizeof (struct iphdr));
+					dmp("ictx+ipo", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, (unsigned char *)ahp, headroom - sizeof(ahp->ah_data));
+					dmp("ictx+ahp", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, (unsigned char *)zeroes, AHHMAC_HASHLEN);
+					dmp("ictx+zeroes", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5,  dat + iphlen + headroom, len - iphlen - headroom);
+					dmp("ictx+dat", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Final(hash, &tctx.md5);
+					dmp("ictx hash", (char*)&hash, sizeof(hash));
+					tctx.md5 = ((struct md5_ctx*)(tdbp->tdb_key_a))->octx;
+					dmp("octx", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Update(&tctx.md5, hash, AHMD596_ALEN);
+					dmp("octx+hash", (char*)&tctx.md5, sizeof(tctx.md5));
+					MD5Final(hash, &tctx.md5);
+					dmp("octx hash", (char*)&hash, sizeof(hash));
+					
+					memcpy(ahp->ah_data, hash, AHHMAC_HASHLEN);
+					
+					/* paranoid */
+					memset((caddr_t)&tctx.md5, 0, sizeof(tctx.md5));
+					memset((caddr_t)hash, 0, sizeof(hash));
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				case AH_SHA:
+					tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx;
+					SHA1Update(&tctx.sha1, (unsigned char *)&ipo, sizeof (struct iphdr));
+					SHA1Update(&tctx.sha1, (unsigned char *)ahp, headroom - sizeof(ahp->ah_data));
+					SHA1Update(&tctx.sha1, (unsigned char *)zeroes, AHHMAC_HASHLEN);
+					SHA1Update(&tctx.sha1,  dat + iphlen + headroom, len - iphlen - headroom);
+					SHA1Final(hash, &tctx.sha1);
+					tctx.sha1 = ((struct sha1_ctx*)(tdbp->tdb_key_a))->octx;
+					SHA1Update(&tctx.sha1, hash, AHSHA196_ALEN);
+					SHA1Final(hash, &tctx.sha1);
+					
+					memcpy(ahp->ah_data, hash, AHHMAC_HASHLEN);
+					
+					/* paranoid */
+					memset((caddr_t)&tctx.sha1, 0, sizeof(tctx.sha1));
+					memset((caddr_t)hash, 0, sizeof(hash));
+					break;
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+				default:
+					spin_unlock(&tdb_lock);
+					stats->tx_errors++;
+					goto cleanup;
+				}
+#ifdef NET_21
+				skb->h.raw = (unsigned char*)ahp;
+#endif /* NET_21 */
+				break;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_IPIP
+			case IPPROTO_IPIP:
+				iph->version  = 4;
+				switch(sysctl_ipsec_tos) {
+				case 0:
+#ifdef NET_21
+					iph->tos = skb->nh.iph->tos;
+#else /* NET_21 */
+					iph->tos = skb->ip_hdr->tos;
+#endif /* NET_21 */
+					break;
+				case 1:
+					iph->tos = 0;
+					break;
+				default:
+				}
+#ifdef NET_21
+				iph->ttl      = ip_statistics.IpDefaultTTL;
+#else /* NET_21 */
+				iph->ttl      = 64; /* ip_statistics.IpDefaultTTL; */
+#endif /* NET_21 */
+				iph->frag_off = 0;
+				iph->saddr    = ((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr.s_addr;
+				iph->daddr    = ((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr.s_addr;
+				iph->protocol = IPPROTO_IPIP;
+				iph->ihl      = sizeof(struct iphdr) >> 2 /* 5 */;
+#ifdef IP_SELECT_IDENT
+				/* XXX use of skb->dst below is a questionable
+				   substitute for &rt->u.dst which is only
+				   available later-on */
+				ip_select_ident(iph, skb->dst);
+#else
+				iph->id       = htons(ip_id_count++);   /* Race condition here? */
+#endif
+
+				newdst = (__u32)iph->daddr;
+				newsrc = (__u32)iph->saddr;
+		
+#ifdef NET_21
+				skb->h.ipiph = skb->nh.iph;
+#endif /* NET_21 */
+				break;
+#endif /* !CONFIG_IPSEC_IPIP */
+#ifdef CONFIG_IPSEC_IPCOMP
+			case IPPROTO_COMP:
+				{
+					unsigned int flags = 0;
+#ifdef CONFIG_IPSEC_DEBUG
+					unsigned int old_tot_len = ntohs(iph->tot_len);
+#endif
+					tdbp->tdb_comp_ratio_dbytes += ntohs(iph->tot_len);
+
+					skb = skb_compress(skb, tdbp, &flags);
+
+#ifdef NET_21
+					iph = skb->nh.iph;
+#else /* NET_21 */
+					iph = skb->ip_hdr;
+#endif /* NET_21 */
+
+					tdbp->tdb_comp_ratio_cbytes += ntohs(iph->tot_len);
+
+#ifdef CONFIG_IPSEC_DEBUG
+					if (debug_tunnel & DB_TN_CROUT)
+					{
+						if (old_tot_len > ntohs(iph->tot_len))
+							KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+								    "klips_debug:ipsec_tunnel_start_xmit: "
+								    "packet shrunk from %d to %d bytes after compression, cpi=%04x (should be from spi=%08x, spi&0xffff=%04x.\n",
+								    old_tot_len, ntohs(iph->tot_len),
+								    ntohs(((struct ipcomphdr*)(((char*)iph) + ((iph->ihl) << 2)))->ipcomp_cpi),
+								    ntohl(tdbp->tdb_said.spi),
+								    (__u16)(ntohl(tdbp->tdb_said.spi) & 0x0000ffff));
+						else
+							KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+								    "klips_debug:ipsec_tunnel_start_xmit: "
+								    "packet did not compress (flags = %d).\n",
+								    flags);
+					}
+#endif /* CONFIG_IPSEC_DEBUG */
+				}
+				break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+			default:
+				spin_unlock(&tdb_lock);
+				stats->tx_errors++;
+				goto cleanup;
+			}
+			
+#ifdef NET_21
+			skb->nh.raw = skb->data;
+#else /* NET_21 */
+			skb->ip_hdr = skb->h.iph = (struct iphdr *) skb->data;
+#endif /* NET_21 */
+			iph->check = 0;
+			iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+			
+			KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+				    "klips_debug:ipsec_tunnel_start_xmit: "
+				    "after <%s%s%s>, SA:%s:\n",
+				    TDB_XFORM_NAME(tdbp), sa);
+			KLIPS_IP_PRINT(debug_tunnel & DB_TN_XMIT, iph);
+ 			
+			tdbp->tdb_lifetime_bytes_c += len;
+			if(!tdbp->tdb_lifetime_usetime_c) {
+				tdbp->tdb_lifetime_usetime_c = jiffies / HZ;
+			}
+			tdbp->tdb_lifetime_usetime_l = jiffies / HZ;
+			tdbp->tdb_lifetime_packets_c += 1;
+
+			tdbp = tdbp->tdb_onext;
+			
+		}
+		/* end encapsulation loop here XXX */
+
+		spin_unlock(&tdb_lock);
+
+		matcher.sen_ip_src.s_addr = iph->saddr;
+		matcher.sen_ip_dst.s_addr = iph->daddr;
+		spin_lock(&eroute_lock);
+		er = ipsec_findroute(&matcher);
+		if(er) {
+			outgoing_said = er->er_said;
+		}
+		spin_unlock(&eroute_lock);
+		KLIPS_PRINT(/* ((orgdst != newdst) || (orgsrc != newsrc)) */
+			(orgedst != outgoing_said.dst.s_addr) &&
+			outgoing_said.dst.s_addr &&
+			er &&
+			(debug_tunnel & DB_TN_XMIT),
+			"klips_debug:ipsec_tunnel_start_xmit: We are recursing here.\n");
+	} while(/*((orgdst != newdst) || (orgsrc != newsrc))*/
+		(orgedst != outgoing_said.dst.s_addr) &&
+		outgoing_said.dst.s_addr &&
+		er);
+	
+	KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+		    "klips_debug:ipsec_tunnel_start_xmit: "
+		    "After recursive xforms -- head,tailroom: %d,%d\n",
+		    skb_headroom(skb), skb_tailroom(skb));
+
+	if(sysctl_ipsec_icmp && (innersrc != newsrc) && (ntohs(iph->tot_len) > physmtu)) {
+		ICMP_SEND(oskb ? oskb : skb,
+			  ICMP_DEST_UNREACH,
+			  ICMP_FRAG_NEEDED,
+			  prv->mtu,
+			  physdev);
+		KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+			    "klips_debug:ipsec_tunnel_start_xmit: "
+			    "IPSEC tunnel mode packet is larger than MTU, ICMP sent.\n");
+	}
+
+	if(saved_header) {
+		if(skb_headroom(skb) < hard_header_len) {
+			printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+			       "tried to skb_push hhlen=%d, %d available.  "
+			       "This should never happen, please report.\n",
+			       hard_header_len, skb_headroom(skb));
+			stats->tx_errors++;
+			goto cleanup;
+		}
+		skb_push(skb, hard_header_len);
+		for (i = 0; i < hard_header_len; i++) {
+			skb->data[i] = saved_header[i];
+		}
+	}
+ bypass:
+	KLIPS_PRINT(debug_tunnel & DB_TN_CROUT,
+		    "klips_debug:ipsec_tunnel_start_xmit: "
+		    "With hard_header, final head,tailroom: %d,%d\n",
+		    skb_headroom(skb), skb_tailroom(skb));
+
+#ifdef NET_21
+	/* new route/dst cache code from James Morris */
+	skb->dev = physdev;
+	/*skb_orphan(skb);*/
+	if(ip_route_output(&rt,
+			   skb->nh.iph->daddr,
+			   skb->nh.iph->saddr,
+			   RT_TOS(skb->nh.iph->tos),
+			   physdev->iflink)) {
+		stats->tx_errors++;
+		goto cleanup;
+	}
+	if(dev == rt->u.dst.dev) {
+		ip_rt_put(rt);
+		/* This is recursion, drop it. */
+		stats->tx_errors++;
+		KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+			    "klips_debug:ipsec_tunnel_start_xmit: "
+			    "suspect recursion, dev=rt->u.dst.dev=%s, dropped\n", dev->name);
+		goto cleanup;
+	}
+	dst_release(skb->dst);
+	skb->dst = &rt->u.dst;
+	stats->tx_bytes += skb->len;
+	if(skb->len < skb->nh.raw - skb->data) {
+		printk(KERN_WARNING "klips_error:ipsec_tunnel_start_xmit: "
+		       "tried to __skb_pull nh-data=%d, %d available.  "
+		       "This should never happen, please report.\n",
+		       skb->nh.raw - skb->data, skb->len);
+		stats->tx_errors++;
+		goto cleanup;
+	}
+	__skb_pull(skb, skb->nh.raw - skb->data);
+#ifdef SKB_RESET_NFCT
+	nf_conntrack_put(skb->nfct);
+	skb->nfct = NULL;
+#ifdef CONFIG_NETFILTER_DEBUG
+	skb->nf_debug = 0;
+#endif /* CONFIG_NETFILTER_DEBUG */
+#endif /* SKB_RESET_NFCT */
+	KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+		    "klips_debug:ipsec_tunnel_start_xmit: "
+		    "...done, calling ip_send()\n");
+#ifdef NETDEV_23
+	{
+		int err;
+
+		err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
+			      ipsec_tunnel_xmit2);
+		if(err != NET_XMIT_SUCCESS && err != NET_XMIT_CN) {
+			if(net_ratelimit())
+				printk(KERN_ERR
+				       "ipsec_tunnel_start_xmit: ip_send() failed, err=%d\n", 
+				       -err);
+			stats->tx_errors++;
+			stats->tx_aborted_errors++;
+			skb = NULL;
+			goto cleanup;
+		}
+	}
+#else
+	ip_send(skb);
+#endif
+#else /* NET_21 */
+	skb->arp = 1;
+	/* ISDN/ASYNC PPP from Matjaz Godec. */
+	/*	skb->protocol = htons(ETH_P_IP); */
+	KLIPS_PRINT(debug_tunnel & DB_TN_XMIT,
+		    "klips_debug:ipsec_tunnel_start_xmit: "
+		    "...done, calling dev_queue_xmit() or ip_fragment().\n");
+	IP_SEND(skb, physdev);
+#endif /* NET_21 */
+	stats->tx_packets++;
+
+	skb = NULL;
+ cleanup:
+#if defined(HAS_NETIF_QUEUE) || defined (HAVE_NETIF_QUEUE)
+	netif_wake_queue(dev);
+#else
+	dev->tbusy = 0;
+#endif
+	if(saved_header)
+		kfree(saved_header);
+	if(skb) {
+		dev_kfree_skb(skb, FREE_WRITE);
+	}
+	if(oskb)
+		dev_kfree_skb(oskb, FREE_WRITE);
+	return 0;
+}
+
+DEBUG_NO_STATIC struct net_device_stats *
+ipsec_tunnel_get_stats(struct device *dev)
+{
+	return &(((struct ipsecpriv *)(dev->priv))->mystats);
+}
+
+/*
+ * Revectored calls.
+ * For each of these calls, a field exists in our private structure.
+ */
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_hard_header(struct sk_buff *skb, struct device *dev,
+	unsigned short type, void *daddr, void *saddr, unsigned len)
+{
+	struct ipsecpriv *prv = dev->priv;
+	struct device *tmp;
+	int ret;
+
+	if(!prv->hard_header) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "klips_debug:ipsec_tunnel_hard_header: "
+			    "physical device has been detached, packet dropped "
+			    "0x%p->0x%p len=%d type=%d dev=%s->NULL ",
+			    saddr, daddr, len, type, dev->name);
+#ifdef NET_21
+		KLIPS_PRINTMORE(debug_tunnel & DB_TN_REVEC,
+			    "ip=%08x->%08x\n",
+			    (__u32)ntohl(skb->nh.iph->saddr),
+			    (__u32)ntohl(skb->nh.iph->daddr) );
+#else /* NET_21 */
+		KLIPS_PRINTMORE(debug_tunnel & DB_TN_REVEC,
+			    "ip=%08x->%08x\n",
+			    (__u32)ntohl(skb->ip_hdr->saddr),
+			    (__u32)ntohl(skb->ip_hdr->daddr) );
+#endif /* NET_21 */
+		return -ENODEV;
+	}
+
+#define da ((struct device *)(prv->dev))->dev_addr
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel_hard_header: "
+		    "Revectored 0x%p->0x%p len=%d type=%d dev=%s->%s "
+		    "dev_addr=%02x:%02x:%02x:%02x:%02x:%02x ",
+		    saddr, daddr, len, type, dev->name, prv->dev->name,
+		    da[0], da[1], da[2], da[3], da[4], da[5]);
+#ifdef NET_21
+		    KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+				"ip=%08x->%08x\n",
+				(__u32)ntohl(skb->nh.iph->saddr),
+				(__u32)ntohl(skb->nh.iph->daddr) );
+#else /* NET_21 */
+		    KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+				"ip=%08x->%08x\n",
+				(__u32)ntohl(skb->ip_hdr->saddr),
+				(__u32)ntohl(skb->ip_hdr->daddr) );
+#endif /* NET_21 */
+	tmp = skb->dev;
+	skb->dev = prv->dev;
+	ret = prv->hard_header(skb, prv->dev, type, (void *)daddr, (void *)saddr, len);
+	skb->dev = tmp;
+	return ret;
+}
+
+DEBUG_NO_STATIC int
+#ifdef NET_21
+ipsec_tunnel_rebuild_header(struct sk_buff *skb)
+#else /* NET_21 */
+ipsec_tunnel_rebuild_header(void *buff, struct device *dev,
+			unsigned long raddr, struct sk_buff *skb)
+#endif /* NET_21 */
+{
+	struct ipsecpriv *prv = skb->dev->priv;
+	struct device *tmp;
+	int ret;
+	
+	if(!prv->rebuild_header) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "klips_debug:ipsec_tunnel_rebuild_header: "
+			    "physical device has been detached, packet dropped "
+			    "skb->dev=%s->NULL ",
+			    skb->dev->name);
+#ifdef NET_21
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "ip=%08x->%08x\n",
+			    (__u32)ntohl(skb->nh.iph->saddr),
+			    (__u32)ntohl(skb->nh.iph->daddr) );
+#else /* NET_21 */
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "ip=%08x->%08x\n",
+			    (__u32)ntohl(skb->ip_hdr->saddr),
+			    (__u32)ntohl(skb->ip_hdr->daddr) );
+#endif /* NET_21 */
+		return -ENODEV;
+	}
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel: "
+		    "Revectored rebuild_header dev=%s->%s ",
+		    skb->dev->name, prv->dev->name);
+#ifdef NET_21
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "ip=%08x->%08x\n",
+		    (__u32)ntohl(skb->nh.iph->saddr),
+		    (__u32)ntohl(skb->nh.iph->daddr) );
+#else /* NET_21 */
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "ip=%08x->%08x\n",
+		    (__u32)ntohl(skb->ip_hdr->saddr),
+		    (__u32)ntohl(skb->ip_hdr->daddr) );
+#endif /* NET_21 */
+	tmp = skb->dev;
+	skb->dev = prv->dev;
+	
+#ifdef NET_21
+	ret = prv->rebuild_header(skb);
+#else /* NET_21 */
+	ret = prv->rebuild_header(buff, prv->dev, raddr, skb);
+#endif /* NET_21 */
+	skb->dev = tmp;
+	return ret;
+}
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_set_mac_address(struct device *dev, void *addr)
+{
+	struct ipsecpriv *prv = dev->priv;
+	
+	if(!prv->set_mac_address) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "klips_debug:ipsec_tunnel_set_mac_address: "
+			    "physical device has been detached, cannot set - "
+			    "skb->dev=%s->NULL\n",
+			    dev->name);
+		return -ENODEV;
+	}
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel_set_mac_address: "
+		    "Revectored dev=%s->%s addr=%p\n",
+		    dev->name, prv->dev->name, addr);
+	return prv->set_mac_address(prv->dev, addr);
+
+}
+
+#ifndef NET_21
+DEBUG_NO_STATIC void
+ipsec_tunnel_cache_bind(struct hh_cache **hhp, struct device *dev,
+				 unsigned short htype, __u32 daddr)
+{
+	struct ipsecpriv *prv = dev->priv;
+	
+	if(!prv->header_cache_bind) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "klips_debug:ipsec_tunnel_cache_bind: "
+			    "physical device has been detached, cannot set - "
+			    "skb->dev=%s->NULL\n",
+			    dev->name);
+		return;
+	}
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel_cache_bind: "
+		    "Revectored \n");
+	prv->header_cache_bind(hhp, prv->dev, htype, daddr);
+	return;
+}
+#endif /* !NET_21 */
+
+
+DEBUG_NO_STATIC void
+ipsec_tunnel_cache_update(struct hh_cache *hh, struct device *dev, unsigned char *  haddr)
+{
+	struct ipsecpriv *prv = dev->priv;
+	
+	if(!prv->header_cache_update) {
+		KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+			    "klips_debug:ipsec_tunnel_cache_update: "
+			    "physical device has been detached, cannot set - "
+			    "skb->dev=%s->NULL\n",
+			    dev->name);
+		return;
+	}
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel: "
+		    "Revectored cache_update\n");
+	prv->header_cache_update(hh, prv->dev, haddr);
+	return;
+}
+
+#ifdef NET_21
+DEBUG_NO_STATIC int
+ipsec_tunnel_neigh_setup(struct neighbour *n)
+{
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel: "
+		    "ipsec_tunnel_neigh_setup\n");
+
+        if (n->nud_state == NUD_NONE) {
+                n->ops = &arp_broken_ops;
+                n->output = n->ops->output;
+        }
+        return 0;
+}
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_neigh_setup_dev(struct device *dev, struct neigh_parms *p)
+{
+	KLIPS_PRINT(debug_tunnel & DB_TN_REVEC,
+		    "klips_debug:ipsec_tunnel: "
+		    "ipsec_tunnel_neigh_setup_dev\n");
+
+        if (p->tbl->family == AF_INET) {
+                p->neigh_setup = ipsec_tunnel_neigh_setup;
+                p->ucast_probes = 0;
+                p->mcast_probes = 0;
+        }
+        return 0;
+}
+#endif /* NET_21 */
+
+/*
+ * We call the attach routine to attach another device.
+ */
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_attach(struct device *tndev, struct ipsecpriv *prv, struct device *dev)
+{
+        int i;
+
+	prv->dev = dev;
+	prv->hard_start_xmit = dev->hard_start_xmit;
+	prv->get_stats = dev->get_stats;
+
+	if (dev->hard_header) {
+		prv->hard_header = dev->hard_header;
+		tndev->hard_header = ipsec_tunnel_hard_header;
+	} else
+		tndev->hard_header = NULL;
+	
+	if (dev->rebuild_header) {
+		prv->rebuild_header = dev->rebuild_header;
+		tndev->rebuild_header = ipsec_tunnel_rebuild_header;
+	} else
+		tndev->rebuild_header = NULL;
+	
+	if (dev->set_mac_address) {
+		prv->set_mac_address = dev->set_mac_address;
+		tndev->set_mac_address = ipsec_tunnel_set_mac_address;
+	} else
+		tndev->set_mac_address = NULL;
+	
+#ifndef NET_21
+	if (dev->header_cache_bind) {
+		prv->header_cache_bind = dev->header_cache_bind;
+		tndev->header_cache_bind = ipsec_tunnel_cache_bind;
+	} else
+		tndev->header_cache_bind = NULL;
+#endif /* !NET_21 */
+
+	if (dev->header_cache_update) {
+		prv->header_cache_update = dev->header_cache_update;
+		tndev->header_cache_update = ipsec_tunnel_cache_update;
+	} else
+		tndev->header_cache_update = NULL;
+
+	tndev->hard_header_len = dev->hard_header_len;
+
+#ifdef NET_21
+/*	prv->neigh_setup        = dev->neigh_setup; */
+	dev->neigh_setup        = ipsec_tunnel_neigh_setup_dev;
+#endif /* NET_21 */
+	tndev->mtu = 16260; /* 0xfff0; */ /* dev->mtu; */
+	prv->mtu = dev->mtu;
+
+#ifdef PHYSDEV_TYPE
+	tndev->type = dev->type /* ARPHRD_TUNNEL */;	/* initially */
+#endif /*  PHYSDEV_TYPE */
+
+	tndev->addr_len = dev->addr_len;
+	for (i=0; i<tndev->addr_len; i++) {
+		tndev->dev_addr[i] = dev->dev_addr[i];
+	}
+#ifdef CONFIG_IPSEC_DEBUG
+	if(debug_tunnel & DB_TN_INIT) {
+		printk(KERN_INFO "klips_debug:ipsec_tunnel_attach: "
+		       "physical device %s being attached has HW address: %2x",
+		       dev->name, dev->dev_addr[0]);
+		for (i=1; i < dev->addr_len; i++) {
+			printk(":%02x", dev->dev_addr[i]);
+		}
+		printk("\n");
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	return 0;
+}
+
+/*
+ * We call the detach routine to detach the ipsec tunnel from another device.
+ */
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_detach(struct device *dev, struct ipsecpriv *prv)
+{
+        int i;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_detach: "
+		       "physical device %s being detached from virtual device %s\n",
+		       prv->dev->name, dev->name);
+
+	prv->dev = NULL;
+	prv->hard_start_xmit = NULL;
+	prv->get_stats = NULL;
+
+	prv->hard_header = NULL;
+	dev->hard_header = NULL;
+	
+	prv->rebuild_header = NULL;
+	dev->rebuild_header = NULL;
+	
+	prv->set_mac_address = NULL;
+	dev->set_mac_address = NULL;
+	
+#ifndef NET_21
+	prv->header_cache_bind = NULL;
+	dev->header_cache_bind = NULL;
+#endif /* !NET_21 */
+
+	prv->header_cache_update = NULL;
+	dev->header_cache_update = NULL;
+
+#ifdef NET_21
+/*	prv->neigh_setup        = NULL; */
+	dev->neigh_setup        = NULL;
+#endif /* NET_21 */
+	dev->hard_header_len = 0;
+	dev->mtu = 0;
+	prv->mtu = 0;
+	for (i=0; i<MAX_ADDR_LEN; i++) {
+		dev->dev_addr[i] = 0;
+	}
+	dev->addr_len = 0;
+#ifdef PHYSDEV_TYPE
+	dev->type = 0;
+#endif /*  PHYSDEV_TYPE */
+	
+	return 0;
+}
+
+/*
+ * We call the clear routine to detach all ipsec tunnels from other devices.
+ */
+DEBUG_NO_STATIC int
+ipsec_tunnel_clear(void)
+{
+	int i;
+	struct device *ipsecdev = NULL, *prvdev;
+	struct ipsecpriv *prv;
+	char name[9];
+	int ret;
+
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_clear: called.\n");
+
+	for(i = 0; i < IPSEC_NUM_IF; i++) {
+		sprintf(name, "ipsec%d", i);
+		if((ipsecdev = ipsec_dev_get(name)) != NULL) {
+			if((prv = (struct ipsecpriv *)(ipsecdev->priv))) {
+				prvdev = (struct device *)(prv->dev);
+				if(prvdev) {
+					KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+						    "klips_debug:ipsec_tunnel_clear: "
+						    "physical device for device %s is %s\n",
+						    name, prvdev->name);
+					if((ret = ipsec_tunnel_detach(ipsecdev, prv))) {
+						KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+							    "klips_debug:ipsec_tunnel_clear: "
+							    "error %d detatching device %s from device %s.\n",
+							    ret, name, prvdev->name);
+						return ret;
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+DEBUG_NO_STATIC int
+ipsec_tunnel_ioctl(struct device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ipsectunnelconf *cf = (struct ipsectunnelconf *)&ifr->ifr_data;
+	struct ipsecpriv *prv = dev->priv;
+	struct device *them; /* physical device */
+#ifdef CONFIG_IP_ALIAS
+	char *colon;
+	char realphysname[IFNAMSIZ];
+#endif /* CONFIG_IP_ALIAS */
+	
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_ioctl: "
+		    "tncfg service call #%d\n", cmd);
+	switch (cmd) {
+	/* attach a virtual ipsec? device to a physical device */
+	case IPSEC_SET_DEV:
+#ifdef CONFIG_IP_ALIAS
+		/* If this is an IP alias interface, get its real physical name */
+		strncpy(realphysname, cf->cf_name, IFNAMSIZ);
+		realphysname[IFNAMSIZ-1] = 0;
+		colon = strchr(realphysname, ':');
+		if (colon) *colon = 0;
+		them = ipsec_dev_get(realphysname);
+#else /* CONFIG_IP_ALIAS */
+		them = ipsec_dev_get(cf->cf_name);
+#endif /* CONFIG_IP_ALIAS */
+
+		if (them == NULL) {
+			KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+				    "klips_debug:ipsec_tunnel_ioctl: "
+				    "physical device requested is null\n");
+
+			return -ENXIO;
+		}
+		
+		if (prv->dev)
+			return -EBUSY;
+		return ipsec_tunnel_attach(dev, dev->priv, them);
+
+	case IPSEC_DEL_DEV:
+		if (! prv->dev)
+			return -ENODEV;
+		return ipsec_tunnel_detach(dev, dev->priv);
+	       
+	case IPSEC_CLR_DEV:
+		KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+			    "klips_debug:ipsec_tunnel_ioctl: "
+			    "calling ipsec_tunnel_clear.\n");
+		return ipsec_tunnel_clear();
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+int
+ipsec_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
+{
+	struct device *dev = ptr;
+	struct device *ipsec_dev;
+	struct ipsecpriv *priv;
+	char name[9];
+	int i;
+
+	/* check for loopback devices */
+	if (dev->flags & IFF_LOOPBACK)
+		return(NOTIFY_DONE);
+
+	switch (event) 
+	{
+		case NETDEV_DOWN:
+			KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+				    "ipsec_device_event: NETDEV_DOWN...\n");
+			/* find the attached physical device and detach it. */
+			for(i = 0; i < IPSEC_NUM_IF; i++) {
+				sprintf(name, "ipsec%d", i);
+				ipsec_dev = ipsec_dev_get(name);
+				if(ipsec_dev) {
+					priv = (struct ipsecpriv *)(ipsec_dev->priv);
+					if(priv) {
+						;
+						if(((struct device *)(priv->dev)) == dev) {
+							dev_close(ipsec_dev);
+							/* return */ ipsec_tunnel_detach(ipsec_dev, priv);
+							return NOTIFY_DONE;
+							break;
+						}
+					} else {
+						KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+							    "klips_debug:ipsec_device_event: device '%s' has no private data space!\n",
+							    ipsec_dev->name);
+					}
+				}
+			}
+
+			break;
+		case NETDEV_UP:
+			KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+				    "ipsec_device_event: NETDEV_UP...\n");
+			/* Only handle ethernet ports */
+			if(dev->type!=ARPHRD_ETHER && dev->type!=ARPHRD_LOOPBACK)
+				return NOTIFY_DONE;
+
+			break;
+#ifdef NET_21
+		case NETDEV_UNREGISTER:
+			KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+				    "ipsec_device_event: NETDEV_UNREGISTER...\n");
+
+			break;
+#endif /* NET_21 */
+	}
+	return NOTIFY_DONE;
+}
+
+/*
+ *	Called when an ipsec tunnel device is initialized.
+ *	The ipsec tunnel device structure is passed to us.
+ */
+ 
+int
+ipsec_tunnel_init(struct device *dev)
+{
+	int i;
+
+	printk(KERN_INFO "klips_debug:ipsec_tunnel_init: "
+	       "initialisation of device: %s\n",
+	       dev->name ? dev->name : "NULL");
+
+	/* Add our tunnel functions to the device */
+	dev->open		= ipsec_tunnel_open;
+	dev->stop		= ipsec_tunnel_close;
+	dev->hard_start_xmit	= ipsec_tunnel_start_xmit;
+	dev->get_stats		= ipsec_tunnel_get_stats;
+
+	dev->priv = kmalloc(sizeof(struct ipsecpriv), GFP_KERNEL);
+	if (dev->priv == NULL)
+		return -ENOMEM;
+	memset(dev->priv, 0, sizeof(struct ipsecpriv));
+
+	for(i = 0; i < sizeof(zeroes); i++) {
+		((__u8*)(zeroes))[i] = 0;
+	}
+	
+#ifndef NET_21
+	/* Initialize the tunnel device structure */
+	for (i = 0; i < DEV_NUMBUFFS; i++)
+		skb_queue_head_init(&dev->buffs[i]);
+#endif /* !NET_21 */
+
+	dev->set_multicast_list = NULL;
+	dev->do_ioctl		= ipsec_tunnel_ioctl;
+	dev->hard_header	= NULL;
+	dev->rebuild_header 	= NULL;
+	dev->set_mac_address 	= NULL;
+#ifndef NET_21
+	dev->header_cache_bind 	= NULL;
+#endif /* !NET_21 */
+	dev->header_cache_update= NULL;
+
+#ifdef NET_21
+/*	prv->neigh_setup        = NULL; */
+	dev->neigh_setup        = ipsec_tunnel_neigh_setup_dev;
+#endif /* NET_21 */
+	dev->hard_header_len 	= 0;
+	dev->mtu		= 0;
+	dev->addr_len		= 0;
+	dev->type		= ARPHRD_TUNNEL; /* 0 */ /* ARPHRD_ETHER; */ /* initially */
+	dev->tx_queue_len	= 10;		/* Small queue */
+	memset(dev->broadcast,0xFF, ETH_ALEN);	/* what if this is not attached to ethernet? */
+
+	/* New-style flags. */
+	dev->flags		= IFF_NOARP /* 0 */ /* Petr Novak */;
+#ifdef NET_21
+	dev_init_buffers(dev);
+#else /* NET_21 */
+	dev->family		= AF_INET;
+	dev->pa_addr		= 0;
+	dev->pa_brdaddr 	= 0;
+	dev->pa_mask		= 0;
+	dev->pa_alen		= 4;
+#endif /* NET_21 */
+
+	/* We're done.  Have I forgotten anything? */
+	return 0;
+}
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/*  Module specific interface (but it links with the rest of IPSEC  */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+int
+ipsec_tunnel_probe(struct device *dev)
+{
+	ipsec_tunnel_init(dev); 
+	return 0;
+}
+
+static struct device dev_ipsec3 = 
+{
+	"ipsec3\0   ",		/* name */
+	0,			/* recv memory end */
+	0,			/* recv memory start */
+	0,			/* memory end */
+	0,			/* memory start */
+ 	0x0,			/* base I/O address */
+	0,			/* IRQ */
+	0, 0, 0,		/* flags */
+	NULL,			/* next device */
+	ipsec_tunnel_probe	/* setup */
+};
+
+static struct device dev_ipsec2 = 
+{
+	"ipsec2\0   ",		/* name */
+	0,			/* recv memory end */
+	0,			/* recv memory start */
+	0,			/* memory end */
+	0,			/* memory start */
+ 	0x0,			/* base I/O address */
+	0,			/* IRQ */
+	0, 0, 0,		/* flags */
+	NULL,			/* next device */
+	ipsec_tunnel_probe	/* setup */
+};
+
+static struct device dev_ipsec1 = 
+{
+	"ipsec1\0   ",		/* name */
+	0,			/* recv memory end */
+	0,			/* recv memory start */
+	0,			/* memory end */
+	0,			/* memory start */
+ 	0x0,			/* base I/O address */
+	0,			/* IRQ */
+	0, 0, 0,		/* flags */
+	NULL,			/* next device */
+	ipsec_tunnel_probe	/* setup */
+};
+
+static struct device dev_ipsec0 = 
+{
+	"ipsec0\0   ",		/* name */
+	0,			/* recv memory end */
+	0,			/* recv memory start */
+	0,			/* memory end */
+	0,			/* memory start */
+ 	0x0,			/* base I/O address */
+	0,			/* IRQ */
+	0, 0, 0,		/* flags */
+	NULL,			/* next device */
+	ipsec_tunnel_probe	/* setup */
+};
+
+int 
+ipsec_tunnel_init_devices(void)
+{
+#if 0
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_init_devices: "
+		    "registering device %s\n",
+		    dev_ipsec0.name);
+#endif
+	if (register_netdev(&dev_ipsec0) != 0)
+		return -EIO;
+#if 0
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_init_devices: "
+		    "registering device %s\n",
+		    dev_ipsec1.name);
+#endif
+	if (register_netdev(&dev_ipsec1) != 0)
+		return -EIO;
+#if 0
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_init_devices: "
+		    "registering device %s\n",
+		    dev_ipsec2.name);
+#endif
+	if (register_netdev(&dev_ipsec2) != 0)
+		return -EIO;
+#if 0
+	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
+		    "klips_debug:ipsec_tunnel_init_devices: "
+		    "registering device %s\n",
+		    dev_ipsec3.name);
+#endif
+	if (register_netdev(&dev_ipsec3) != 0)
+		return -EIO;
+	return 0;
+}
+
+/* void */
+int
+ipsec_tunnel_cleanup_devices(void)
+{
+	int error = 0;
+
+	unregister_netdev(&dev_ipsec0);
+	unregister_netdev(&dev_ipsec1);
+	unregister_netdev(&dev_ipsec2);
+	unregister_netdev(&dev_ipsec3);
+	kfree(dev_ipsec0.priv);
+	kfree(dev_ipsec1.priv);
+	kfree(dev_ipsec2.priv);
+	kfree(dev_ipsec3.priv);
+	dev_ipsec0.priv=NULL;
+	dev_ipsec1.priv=NULL;
+	dev_ipsec2.priv=NULL;
+	dev_ipsec3.priv=NULL;
+
+	return error;
+}
+
+/*
+ * $Log$
+ * Revision 1.131  2000/11/09 20:52:15  rgb
+ * More spinlock shuffling, locking earlier and unlocking later in rcv to
+ * include ipcomp and prevent races, renaming some tdb variables that got
+ * forgotten, moving some unlocks to include tdbs and adding a missing
+ * unlock.  Thanks to Svenning for some of these.
+ *
+ * Revision 1.130  2000/11/09 20:11:22  rgb
+ * Minor shuffles to fix non-standard kernel config option selection.
+ *
+ * Revision 1.129  2000/11/06 04:32:49  rgb
+ * Clean up debug printing.
+ * Copy skb->protocol for all kernel versions.
+ * Ditched spin_lock_irqsave in favour of spin_lock.
+ * Disabled TTL decrement, done in ip_forward.
+ * Added debug printing before pfkey_acquire().
+ * Fixed printk-deltdbchain-spin_lock races (Svenning).
+ * Use defaultTTL for 2.1+ kernels.
+ * Add Svenning's adaptive content compression.
+ * Fix up debug display arguments.
+ *
+ * Revision 1.128  2000/09/28 00:58:57  rgb
+ * Moved the IKE passthrough check after the eroute lookup so we can pass
+ * IKE through intermediate tunnels.
+ *
+ * Revision 1.127  2000/09/22 17:52:11  rgb
+ * Fixed misleading ipcomp debug output.
+ *
+ * Revision 1.126  2000/09/22 04:22:56  rgb
+ * Fixed dumb spi->cpi conversion error.
+ *
+ * Revision 1.125  2000/09/21 04:34:48  rgb
+ * A few debug-specific things should be hidden under
+ * CONFIG_IPSEC_DEBUG.(MB)
+ * Improved ip_send() error handling.(MB)
+ *
+ * Revision 1.124  2000/09/21 03:40:58  rgb
+ * Added more debugging to try and track down the cpi outward copy problem.
+ *
+ * Revision 1.123  2000/09/19 07:08:49  rgb
+ * Added debugging to outgoing compression report.
+ *
+ * Revision 1.122  2000/09/18 19:21:26  henry
+ * RGB-supplied fix for RH5.2 problem
+ *
+ * Revision 1.121  2000/09/17 21:05:09  rgb
+ * Added tdb to skb_compress call to write in cpi.
+ *
+ * Revision 1.120  2000/09/17 16:57:16  rgb
+ * Added Svenning's patch to remove restriction of ipcomp to innermost
+ * transform.
+ *
+ * Revision 1.119  2000/09/15 11:37:01  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.118  2000/09/15 04:57:16  rgb
+ * Moved debug output after sanity check.
+ * Added tos copy sysctl.
+ *
+ * Revision 1.117  2000/09/12 03:22:51  rgb
+ * Converted ipsec_icmp, no_eroute_pass, opportunistic and #if0 debugs to
+ * sysctl.
+ *
+ * Revision 1.116  2000/09/08 19:18:19  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Added outgoing opportunistic hook, ifdef'ed out.
+ *
+ * Revision 1.115  2000/08/30 05:27:29  rgb
+ * Removed all the rest of the references to tdb_spi, tdb_proto, tdb_dst.
+ * Kill remainder of tdb_xform, tdb_xdata, xformsw.
+ *
+ * Revision 1.114  2000/08/28 18:15:46  rgb
+ * Added MB's nf-debug reset patch.
+ *
+ * Revision 1.113  2000/08/27 02:26:40  rgb
+ * Send all no-eroute-bypass, pluto-bypass and passthrough packets through
+ * fragmentation machinery for 2.0, 2.2 and 2.4 kernels.
+ *
+ * Revision 1.112  2000/08/20 21:37:33  rgb
+ * Activated pfkey_expire() calls.
+ * Added a hard/soft expiry parameter to pfkey_expire(). (Momchil)
+ * Re-arranged the order of soft and hard expiry to conform to RFC2367.
+ * Clean up references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.111  2000/08/01 14:51:51  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.110  2000/07/28 14:58:31  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.109  2000/07/28 13:50:54  rgb
+ * Changed enet_statistics to net_device_stats and added back compatibility
+ * for pre-2.1.19.
+ *
+ * Revision 1.108  2000/05/16 03:03:11  rgb
+ * Updates for 2.3.99pre8 from MB.
+ *
+ * Revision 1.107  2000/05/10 23:08:21  rgb
+ * Print a debug warning about bogus packets received by the outgoing
+ * processing machinery only when klipsdebug is not set to none.
+ * Comment out the device initialisation informational messages.
+ *
+ * Revision 1.106  2000/05/10 19:17:14  rgb
+ * Define an IP_SEND macro, intending to have all packet passthroughs
+ * use fragmentation.  This didn't quite work, but is a step in the
+ * right direction.
+ * Added buffer allocation debugging statements.
+ * Added configure option to shut off no eroute passthrough.
+ * Only check usetime against soft and hard limits if the tdb has been
+ * used.
+ * Cast output of ntohl so that the broken prototype doesn't make our
+ * compile noisy.
+ *
+ * Revision 1.105  2000/03/22 16:15:37  rgb
+ * Fixed renaming of dev_get (MB).
+ *
+ * Revision 1.104  2000/03/16 14:04:15  rgb
+ * Indented headers for readability.
+ * Fixed debug scope to enable compilation with debug off.
+ * Added macros for ip_chk_addr and IS_MYADDR for identifying self.
+ *
+ * Revision 1.103  2000/03/16 07:11:07  rgb
+ * Hardcode PF_KEYv2 support.
+ * Fixed bug which allowed UDP/500 packet from another machine
+ * through in the clear.
+ * Added disabled skb->protocol fix for ISDN/ASYNC PPP from Matjaz Godec.
+ *
+ * Revision 1.102  2000/03/14 12:26:59  rgb
+ * Added skb->nfct support for clearing netfilter conntrack bits (MB).
+ *
+ * Revision 1.101  2000/02/14 21:05:22  rgb
+ * Added MB's netif_queue fix for kernels 2.3.43+.
+ *
+ * Revision 1.100  2000/01/26 10:04:57  rgb
+ * Fixed noisy 2.0 printk arguments.
+ *
+ * Revision 1.99  2000/01/21 06:16:25  rgb
+ * Added sanity checks on skb_push(), skb_pull() to prevent panics.
+ * Switched to AF_ENCAP macro.
+ * Shortened debug output per packet and re-arranging debug_tunnel
+ * bitmap flags, while retaining necessary information to avoid
+ * trampling the kernel print ring buffer.
+ * Reformatted recursion switch code.
+ * Changed all references to tdb_proto to tdb_said.proto for clarity.
+ *
+ * Revision 1.98  2000/01/13 08:09:31  rgb
+ * Shuffled debug_tunnel switches to focus output.
+ * Fixed outgoing recursion bug, limiting to recursing only if the remote
+ * SG changes and if it is valid, ie. not passthrough.
+ * Clarified a number of debug messages.
+ *
+ * Revision 1.97  2000/01/10 16:37:16  rgb
+ * MB support for new ip_select_ident() upon disappearance of
+ * ip_id_count in 2.3.36+.
+ *
+ * Revision 1.96  1999/12/31 14:59:08  rgb
+ * MB fix to use new skb_copy_expand in kernel 2.3.35.
+ *
+ * Revision 1.95  1999/12/29 21:15:44  rgb
+ * Fix tncfg to aliased device bug.
+ *
+ * Revision 1.94  1999/12/22 04:26:06  rgb
+ * Converted all 'static' functions to 'DEBUG_NO_STATIC' to enable
+ * debugging by providing external labels to all functions with debugging
+ * turned on.
+ *
+ * Revision 1.93  1999/12/13 13:30:14  rgb
+ * Changed MTU reports and HW address reporting back to debug only.
+ *
+ * Revision 1.92  1999/12/07 18:57:56  rgb
+ * Fix PFKEY symbol compile error (SADB_*) without pfkey enabled.
+ *
+ * Revision 1.91  1999/12/01 22:15:36  rgb
+ * Add checks for LARVAL and DEAD SAs.
+ * Change state of SA from MATURE to DYING when a soft lifetime is
+ * reached and print debug warning.
+ *
+ * Revision 1.90  1999/11/23 23:04:04  rgb
+ * Use provided macro ADDRTOA_BUF instead of hardcoded value.
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.89  1999/11/18 18:50:59  rgb
+ * Changed all device registrations for static linking to
+ * dynamic to reduce the number and size of patches.
+ *
+ * Revision 1.88  1999/11/18 04:09:19  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.87  1999/11/17 15:53:40  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.86  1999/10/16 18:25:37  rgb
+ * Moved SA lifetime expiry checks before packet processing.
+ * Expire SA on replay counter rollover.
+ *
+ * Revision 1.85  1999/10/16 04:24:31  rgb
+ * Add stats for time since last packet.
+ *
+ * Revision 1.84  1999/10/16 00:30:47  rgb
+ * Added SA lifetime counting.
+ *
+ * Revision 1.83  1999/10/15 22:15:57  rgb
+ * Clean out cruft.
+ * Add debugging.
+ *
+ * Revision 1.82  1999/10/08 18:26:19  rgb
+ * Fix 2.0.3x outgoing fragmented packet memory leak.
+ *
+ * Revision 1.81  1999/10/05 02:38:54  rgb
+ * Lower the default mtu of virtual devices to 16260.
+ *
+ * Revision 1.80  1999/10/03 18:56:41  rgb
+ * Spinlock support for 2.3.xx.
+ * Don't forget to undo spinlocks on error!
+ * Check for valid eroute before copying the structure.
+ *
+ * Revision 1.79  1999/10/01 15:44:53  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.78  1999/10/01 00:02:43  rgb
+ * Added tdb structure locking.
+ * Added eroute structure locking.
+ *
+ * Revision 1.77  1999/09/30 02:52:29  rgb
+ * Add Marc Boucher's Copy-On-Write code (same as ipsec_rcv.c).
+ *
+ * Revision 1.76  1999/09/25 19:31:27  rgb
+ * Refine MSS hack to affect SYN, but not SYN+ACK packets.
+ *
+ * Revision 1.75  1999/09/24 22:52:38  rgb
+ * Fix two things broken in 2.0.38 by trying to fix network notifiers.
+ *
+ * Revision 1.74  1999/09/24 00:30:37  rgb
+ * Add test for changed source as well as destination to check for
+ * recursion.
+ *
+ * Revision 1.73  1999/09/23 20:52:24  rgb
+ * Add James Morris' MSS hack patch, disabled.
+ *
+ * Revision 1.72  1999/09/23 20:22:40  rgb
+ * Enable, tidy and fix network notifier code.
+ *
+ * Revision 1.71  1999/09/23 18:09:05  rgb
+ * Clean up 2.2.x fragmenting traces.
+ * Disable dev->type switching, forcing ARPHRD_TUNNEL.
+ *
+ * Revision 1.70  1999/09/22 14:14:24  rgb
+ * Add sanity checks for revectored calls to prevent calling a downed I/F.
+ *
+ * Revision 1.69  1999/09/21 15:00:57  rgb
+ * Add Marc Boucher's packet size check.
+ * Flesh out network device notifier code.
+ *
+ * Revision 1.68  1999/09/18 11:39:57  rgb
+ * Start to add (disabled) netdevice notifier code.
+ *
+ * Revision 1.67  1999/09/17 23:44:40  rgb
+ * Add a comment warning potential code hackers to stay away from mac.raw.
+ *
+ * Revision 1.66  1999/09/17 18:04:02  rgb
+ * Add fix for unpredictable hard_header_len for ISDN folks (thanks MB).
+ * Ditch TTL decrement in 2.2 (MB).
+ *
+ * Revision 1.65  1999/09/15 23:15:35  henry
+ * Marc Boucher's PPP fixes
+ *
+ * Revision 1.64  1999/09/07 13:40:53  rgb
+ * Ditch unreliable references to skb->mac.raw.
+ *
+ * Revision 1.63  1999/08/28 11:33:09  rgb
+ * Check for null skb->mac pointer.
+ *
+ * Revision 1.62  1999/08/28 02:02:30  rgb
+ * Add Marc Boucher's fix for properly dealing with skb->sk.
+ *
+ * Revision 1.61  1999/08/27 05:23:05  rgb
+ * Clean up skb->data/raw/nh/h manipulation.
+ * Add Marc Boucher's mods to aid tcpdump.
+ * Add sanity checks to skb->raw/nh/h pointer copies in skb_copy_expand.
+ * Re-order hard_header stripping -- might be able to remove it...
+ *
+ * Revision 1.60  1999/08/26 20:01:02  rgb
+ * Tidy up compiler directives and macros.
+ * Re-enable ICMP for tunnels where inner_dst !=  outer_dst.
+ * Remove unnecessary skb->dev = physdev assignment affecting 2.2.x.
+ *
+ * Revision 1.59  1999/08/25 15:44:41  rgb
+ * Clean up from 2.2.x instrumenting for compilation under 2.0.36.
+ *
+ * Revision 1.58  1999/08/25 15:00:54  rgb
+ * Add dst cache code for 2.2.xx.
+ * Add sanity check for skb packet header pointers.
+ * Add/modify debugging instrumentation to *_start_xmit, *_hard_header and
+ * *_rebuild_header.
+ * Add neigh_* cache code.
+ * Change dev->type back to ARPHRD_TUNNEL.
+ *
+ * Revision 1.57  1999/08/17 21:50:23  rgb
+ * Fixed minor debug output bugs.
+ * Regrouped error recovery exit code.
+ * Added compiler directives to remove unwanted code and symbols.
+ * Shut off ICMP messages: to be refined to only send ICMP to remote systems.
+ * Add debugging code for output function addresses.
+ * Fix minor bug in (possibly unused) header_cache_bind function.
+ * Add device neighbour caching code.
+ * Change dev->type from ARPHRD_TUNNEL to physdev->type.
+ *
+ * Revision 1.56  1999/08/03 17:22:56  rgb
+ * Debug output clarification using KERN_* macros.  Other inactive changes
+ * added.
+ *
+ * Revision 1.55  1999/08/03 16:58:46  rgb
+ * Fix skb_copy_expand size bug.  Was getting incorrect size.
+ *
+ * Revision 1.54  1999/07/14 19:32:38  rgb
+ * Fix oversize packet crash and ssh stalling in 2.2.x kernels.
+ *
+ * Revision 1.53  1999/06/10 15:44:02  rgb
+ * Minor reformatting and clean-up.
+ *
+ * Revision 1.52  1999/05/09 03:25:36  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.51  1999/05/08 21:24:59  rgb
+ * Add casting to silence the 2.2.x compile.
+ *
+ * Revision 1.50  1999/05/05 22:02:32  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.49  1999/04/29 15:18:52  rgb
+ * Change gettdb parameter to a pointer to reduce stack loading and
+ * facilitate parameter sanity checking.
+ * Fix undetected bug that might have tried to access a null pointer.
+ * Eliminate unnessessary usage of tdb_xform member to further switch
+ * away from the transform switch to the algorithm switch.
+ * Add return values to init and cleanup functions.
+ *
+ * Revision 1.48  1999/04/16 15:38:00  rgb
+ * Minor rearrangement of freeing code to avoid memory leaks with impossible or
+ * rare situations.
+ *
+ * Revision 1.47  1999/04/15 15:37:25  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.32.2.4  1999/04/13 21:00:18  rgb
+ * Ditch 'things I wish I had known before...'.
+ *
+ * Revision 1.32.2.3  1999/04/13 20:34:38  rgb
+ * Free skb after fragmentation.
+ * Use stats more effectively.
+ * Add I/F to mtu notch-down reporting.
+ *
+ * Revision 1.32.2.2  1999/04/02 04:26:14  rgb
+ * Backcheck from HEAD, pre1.0.
+ *
+ * Revision 1.46  1999/04/11 00:29:00  henry
+ * GPL boilerplate
+ *
+ * Revision 1.45  1999/04/07 15:42:01  rgb
+ * Fix mtu/ping bug AGAIN!
+ *
+ * Revision 1.44  1999/04/06 04:54:27  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.43  1999/04/04 03:57:07  rgb
+ * ip_fragment() doesn't free the supplied skb.  Freed.
+ *
+ * Revision 1.42  1999/04/01 23:27:15  rgb
+ * Preload size of virtual mtu.
+ *
+ * Revision 1.41  1999/04/01 09:31:23  rgb
+ * Invert meaning of ICMP PMTUD config option and clarify.
+ * Code clean-up.
+ *
+ * Revision 1.40  1999/04/01 04:37:17  rgb
+ * SSH stalling bug fix.
+ *
+ * Revision 1.39  1999/03/31 23:44:28  rgb
+ * Don't send ICMP on DF and frag_off.
+ *
+ * Revision 1.38  1999/03/31 15:20:10  rgb
+ * Quiet down debugging.
+ *
+ * Revision 1.37  1999/03/31 08:30:31  rgb
+ * Add switch to shut off ICMP PMTUD packets.
+ *
+ * Revision 1.36  1999/03/31 05:44:47  rgb
+ * Keep PMTU reduction private.
+ *
+ * Revision 1.35  1999/03/27 15:13:02  rgb
+ * PMTU/fragmentation bug fix.
+ *
+ * Revision 1.34  1999/03/17 21:19:26  rgb
+ * Fix kmalloc nonatomic bug.
+ *
+ * Revision 1.33  1999/03/17 15:38:42  rgb
+ * Code clean-up.
+ * ESP_NULL IV bug fix.
+ *
+ * Revision 1.32  1999/03/01 20:44:25  rgb
+ * Code clean-up.
+ * Memory leak bug fix.
+ *
+ * Revision 1.31  1999/02/27 00:02:09  rgb
+ * Tune to report the MTU reduction once, rather than after every recursion
+ * through the encapsulating code, preventing tcp stream stalling.
+ *
+ * Revision 1.30  1999/02/24 20:21:01  rgb
+ * Reformat debug printk's.
+ * Fix recursive encapsulation, dynamic MTU bugs and add debugging code.
+ * Clean-up.
+ *
+ * Revision 1.29  1999/02/22 17:08:14  rgb
+ * Fix recursive encapsulation code.
+ *
+ * Revision 1.28  1999/02/19 18:27:02  rgb
+ * Improve DF, fragmentation and PMTU behaviour and add dynamic MTU discovery.
+ *
+ * Revision 1.27  1999/02/17 16:51:37  rgb
+ * Clean out unused cruft.
+ * Temporarily tone down volume of debug output.
+ * Temporarily shut off fragment rejection.
+ * Disabled temporary failed recursive encapsulation loop.
+ *
+ * Revision 1.26  1999/02/12 21:21:26  rgb
+ * Move KLIPS_PRINT to ipsec_netlink.h for accessibility.
+ *
+ * Revision 1.25  1999/02/11 19:38:27  rgb
+ * More clean-up.
+ * Add sanity checking for skb_copy_expand() to prevent kernel panics on
+ * skb_put() values out of range.
+ * Fix head/tailroom calculation causing skb_put() out-of-range values.
+ * Fix return values to prevent 'nonatomic alloc_skb' warnings.
+ * Allocate new skb iff needed.
+ * Added more debug statements.
+ * Make headroom depend on structure, not hard-coded values.
+ *
+ * Revision 1.24  1999/02/10 23:20:33  rgb
+ * Shut up annoying 'statement has no effect' compiler warnings with
+ * debugging compiled out.
+ *
+ * Revision 1.23  1999/02/10 22:36:30  rgb
+ * Clean-up obsolete, unused and messy code.
+ * Converted most IPSEC_DEBUG statements to KLIPS_PRINT macros.
+ * Rename ipsec_tunnel_do_xmit to ipsec_tunnel_start_xmit and eliminated
+ * original ipsec_tunnel_start_xmit.
+ * Send all packet with different inner and outer destinations directly to
+ * the attached physical device, rather than back through ip_forward,
+ * preventing disappearing routes problems.
+ * Do sanity checking before investing too much CPU in allocating new
+ * structures.
+ * Fail on IP header options: We cannot process them yet.
+ * Add some helpful comments.
+ * Use virtual device for parameters instead of physical device.
+ *
+ * Revision 1.22  1999/02/10 03:03:02  rgb
+ * Duh.  Fixed the TTL bug: forgot to update the checksum.
+ *
+ * Revision 1.21  1999/02/09 23:17:53  rgb
+ * Add structure members to ipsec_print_ip debug function.
+ * Temporarily fix TTL bug preventing tunnel mode from functioning.
+ *
+ * Revision 1.20  1999/02/09 00:14:25  rgb
+ * Add KLIPSPRINT macro.  (Not used yet, though.)
+ * Delete old ip_tunnel code (BADCODE).
+ * Decrement TTL in outgoing packet.
+ * Set TTL on new IPIP_TUNNEL to default, not existing packet TTL.
+ * Delete ethernet only feature and fix hard-coded hard_header_len.
+ *
+ * Revision 1.19  1999/01/29 17:56:22  rgb
+ * 64-bit re-fix submitted by Peter Onion.
+ *
+ * Revision 1.18  1999/01/28 22:43:24  rgb
+ * Fixed bug in ipsec_print_ip that caused an OOPS, found by P.Onion.
+ *
+ * Revision 1.17  1999/01/26 02:08:16  rgb
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ * Removed dead code.
+ *
+ * Revision 1.16  1999/01/22 06:25:26  rgb
+ * Cruft clean-out.
+ * Added algorithm switch code.
+ * 64-bit clean-up.
+ * Passthrough on IPIP protocol, spi 0x0 fix.
+ * Enhanced debugging.
+ *
+ * Revision 1.15  1998/12/01 13:22:04  rgb
+ * Added support for debug printing of version info.
+ *
+ * Revision 1.14  1998/11/30 13:22:55  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.13  1998/11/17 21:13:52  rgb
+ * Put IKE port bypass debug output in user-switched debug statements.
+ *
+ * Revision 1.12  1998/11/13 13:20:25  rgb
+ * Fixed ntohs bug in udp/500 hole for IKE.
+ *
+ * Revision 1.11  1998/11/10 08:01:19  rgb
+ * Kill tcp/500 hole,  keep udp/500 hole.
+ *
+ * Revision 1.10  1998/11/09 21:29:26  rgb
+ * If no eroute is found, discard packet and incr. tx_error.
+ *
+ * Revision 1.9  1998/10/31 06:50:00  rgb
+ * Add tcp/udp/500 bypass.
+ * Fixed up comments in #endif directives.
+ *
+ * Revision 1.8  1998/10/27 00:34:31  rgb
+ * Reformat debug output of IP headers.
+ * Newlines added before calls to ipsec_print_ip.
+ *
+ * Revision 1.7  1998/10/19 14:44:28  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.6  1998/10/09 04:31:35  rgb
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ *
+ * Revision 1.5  1998/08/28 03:09:51  rgb
+ * Prevent kernel log spam with default route through ipsec.
+ *
+ * Revision 1.4  1998/08/05 22:23:09  rgb
+ * Change setdev return code to ENXIO for a non-existant physical device.
+ *
+ * Revision 1.3  1998/07/29 20:41:11  rgb
+ * Add ipsec_tunnel_clear to clear all tunnel attachments.
+ *
+ * Revision 1.2  1998/06/25 20:00:33  rgb
+ * Clean up #endif comments.
+ * Rename dev_ipsec to dev_ipsec0 for consistency.
+ * Document ipsec device fields.
+ * Make ipsec_tunnel_probe visible from rest of kernel for static linking.
+ * Get debugging report for *every* ipsec device initialisation.
+ * Comment out redundant code.
+ *
+ * Revision 1.1  1998/06/18 21:27:50  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.8  1998/06/14 23:49:40  rgb
+ * Clarify version reporting on module loading.
+ *
+ * Revision 1.7  1998/05/27 23:19:20  rgb
+ * Added version reporting.
+ *
+ * Revision 1.6  1998/05/18 21:56:23  rgb
+ * Clean up for numerical consistency of output and cleaning up debug code.
+ *
+ * Revision 1.5  1998/05/12 02:44:23  rgb
+ * Clarifying 'no e-route to host' message.
+ *
+ * Revision 1.4  1998/04/30 15:34:35  rgb
+ * Enclosed most remaining debugging statements in #ifdef's to make it quieter.
+ *
+ * Revision 1.3  1998/04/21 21:28:54  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.2  1998/04/12 22:03:24  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:12  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added transport mode.
+ * Changed the way routing is done.
+ * Lots of bug fixes.
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_tunnel.h linux/net/ipsec/ipsec_tunnel.h
--- linux-noipsec/net/ipsec/ipsec_tunnel.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_tunnel.h	Fri Sep 15 13:37:02 2000
@@ -0,0 +1,206 @@
+/*
+ * IPSEC tunneling code
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ * Heavily based on drivers/net/new_tunnel.c.  Lots
+ * of ideas also taken from the 2.1.x version of drivers/net/shaper.c
+ */
+
+struct ipsectunnelconf
+{
+	__u32	cf_cmd;
+	union
+	{
+		char 	cfu_name[12];
+	} cf_u;
+#define cf_name cf_u.cfu_name
+};
+
+#define IPSEC_SET_DEV	(SIOCDEVPRIVATE)
+#define IPSEC_DEL_DEV	(SIOCDEVPRIVATE + 1)
+#define IPSEC_CLR_DEV	(SIOCDEVPRIVATE + 2)
+
+#ifdef __KERNEL__
+#include <linux/version.h>
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+struct ipsecpriv
+{
+	struct sk_buff_head sendq;
+	struct device *dev;
+	struct wait_queue *wait_queue;
+	char locked;
+	int  (*hard_start_xmit) (struct sk_buff *skb,
+		struct device *dev);
+	int  (*hard_header) (struct sk_buff *skb,
+		struct device *dev,
+		unsigned short type,
+		void *daddr,
+		void *saddr,
+		unsigned len);
+#ifdef NET_21
+	int  (*rebuild_header)(struct sk_buff *skb);
+#else /* NET_21 */
+	int  (*rebuild_header)(void *buff, struct device *dev,
+			unsigned long raddr, struct sk_buff *skb);
+#endif /* NET_21 */
+	int  (*set_mac_address)(struct device *dev, void *addr);
+#ifndef NET_21
+	void (*header_cache_bind)(struct hh_cache **hhp, struct device *dev,
+				 unsigned short htype, __u32 daddr);
+#endif /* !NET_21 */
+	void (*header_cache_update)(struct hh_cache *hh, struct device *dev, unsigned char *  haddr);
+	struct net_device_stats *(*get_stats)(struct device *dev);
+	struct net_device_stats mystats;
+	int mtu;	/* What is the desired MTU? */
+};
+
+#define IPSEC_NUM_IF	4
+
+extern char ipsec_tunnel_c_version[];
+
+int ipsec_tunnel_init_devices(void);
+
+/* void */ int ipsec_tunnel_cleanup_devices(void);
+
+extern /* void */ int ipsec_init(void);
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_tunnel;
+extern int sysctl_ipsec_debug_verbose;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* __KERNEL__ */
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define DB_TN_INIT	0x0001
+#define DB_TN_PROCFS	0x0002
+#define DB_TN_XMIT	0x0010
+#define DB_TN_OHDR	0x0020
+#define DB_TN_CROUT	0x0040
+#define DB_TN_OXFS	0x0080
+#define DB_TN_REVEC	0x0100
+#endif /* CONFIG_IPSEC_DEBUG */
+
+/*
+ * $Log$
+ * Revision 1.20  2000/09/15 11:37:02  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.19  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.18  2000/07/28 13:50:54  rgb
+ * Changed enet_statistics to net_device_stats and added back compatibility
+ * for pre-2.1.19.
+ *
+ * Revision 1.17  1999/11/19 01:12:15  rgb
+ * Purge unneeded proc_info prototypes, now that static linking uses
+ * dynamic proc_info registration.
+ *
+ * Revision 1.16  1999/11/18 18:51:00  rgb
+ * Changed all device registrations for static linking to
+ * dynamic to reduce the number and size of patches.
+ *
+ * Revision 1.15  1999/11/18 04:14:21  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ * Added CONFIG_PROC_FS compiler directives in case it is shut off.
+ * Added Marc Boucher's 2.3.25 proc patches.
+ *
+ * Revision 1.14  1999/05/25 02:50:10  rgb
+ * Fix kernel version macros for 2.0.x static linking.
+ *
+ * Revision 1.13  1999/05/25 02:41:06  rgb
+ * Add ipsec_klipsdebug support for static linking.
+ *
+ * Revision 1.12  1999/05/05 22:02:32  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.11  1999/04/29 15:19:50  rgb
+ * Add return values to init and cleanup functions.
+ *
+ * Revision 1.10  1999/04/16 16:02:39  rgb
+ * Bump up macro to 4 ipsec I/Fs.
+ *
+ * Revision 1.9  1999/04/15 15:37:25  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.5.2.1  1999/04/02 04:26:14  rgb
+ * Backcheck from HEAD, pre1.0.
+ *
+ * Revision 1.8  1999/04/11 00:29:01  henry
+ * GPL boilerplate
+ *
+ * Revision 1.7  1999/04/06 04:54:28  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.6  1999/03/31 05:44:48  rgb
+ * Keep PMTU reduction private.
+ *
+ * Revision 1.5  1999/02/10 22:31:20  rgb
+ * Change rebuild_header member to reflect generality of link layer.
+ *
+ * Revision 1.4  1998/12/01 13:22:04  rgb
+ * Added support for debug printing of version info.
+ *
+ * Revision 1.3  1998/07/29 20:42:46  rgb
+ * Add a macro for clearing all tunnel devices.
+ * Rearrange structures and declarations for sharing with userspace.
+ *
+ * Revision 1.2  1998/06/25 20:01:45  rgb
+ * Make prototypes available for ipsec_init and ipsec proc_dir_entries
+ * for static linking.
+ *
+ * Revision 1.1  1998/06/18 21:27:50  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.3  1998/05/18 21:51:50  rgb
+ * Added macros for num of I/F's and a procfs debug switch.
+ *
+ * Revision 1.2  1998/04/21 21:29:09  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.1  1998/04/09 03:06:13  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:05  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added transport mode.
+ * Changed the way routing is done.
+ * Lots of bug fixes.
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_xform.c linux/net/ipsec/ipsec_xform.c
--- linux-noipsec/net/ipsec/ipsec_xform.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_xform.c	Mon Nov  6 05:32:08 2000
@@ -0,0 +1,1178 @@
+/*
+ * Common routines for IPSEC transformations.
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <linux/random.h>	/* get_random_bytes() */
+#include <freeswan.h>
+#ifdef SPINLOCK
+#ifdef SPINLOCK_23
+#include <linux/spinlock.h> /* *lock* */
+#else /* SPINLOCK_23 */
+#include <asm/spinlock.h> /* *lock* */
+#endif /* SPINLOCK_23 */
+#endif /* SPINLOCK */
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#endif
+#include <asm/checksum.h>
+#include <net/ip.h>
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_ipe4.h"
+#include "ipsec_ah.h"
+#include "ipsec_esp.h"
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_xform = 0;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#define SENDERR(_x) do { len = -(_x); goto errlab; } while (0)
+
+extern int des_set_key(caddr_t, caddr_t);
+
+struct xformsw xformsw[] = {
+{ XF_IP4,		0,		"IPv4_Encapsulation"},
+{ XF_AHHMACMD5,		XFT_AUTH,	"HMAC_MD5_Authentication"},
+{ XF_AHHMACSHA1,	XFT_AUTH,	"HMAC_SHA-1_Authentication"},
+{ XF_ESP3DES,		XFT_CONF,	"3DES_Encryption"},
+{ XF_ESP3DESMD596,	XFT_CONF,	"3DES-MD5-96_Encryption"},
+{ XF_ESP3DESSHA196,	XFT_CONF,	"3DES-SHA1-96_Encryption"},
+{ XF_ESPNULLMD596,	XFT_CONF,	"NULL-MD5-96_ESP_*Plaintext*"},
+{ XF_ESPNULLSHA196,	XFT_CONF,	"NULL-SHA1-96_ESP_*Plaintext*"},
+};
+
+struct tdb *tdbh[TDB_HASHMOD];
+#ifdef SPINLOCK
+spinlock_t tdb_lock = SPIN_LOCK_UNLOCKED;
+#else /* SPINLOCK */
+spinlock_t tdb_lock;
+#endif /* SPINLOCK */
+struct xformsw *xformswNXFORMSW = &xformsw[sizeof(xformsw)/sizeof(xformsw[0])];
+
+int
+ipsec_tdbinit(void)
+{
+	int i;
+
+	for(i = 1; i < TDB_HASHMOD; i++) {
+		tdbh[i] = NULL;
+	}
+	return 0;
+}
+
+struct tdb *
+gettdb(struct sa_id *said)
+{
+	int hashval;
+	struct tdb *tdbp;
+        char sa[SATOA_BUF];
+
+	if(!said) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:gettdb: null pointer passed in!\n");
+		return NULL;
+	}
+
+	satoa(*said, 0, sa, SATOA_BUF);
+
+	hashval = (said->spi+said->dst.s_addr+said->proto) % TDB_HASHMOD;
+	
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:gettdb: linked entry in tdb table for hash=%d of SA:%s requested.\n",
+		    hashval, sa);
+
+	if(!(tdbp = tdbh[hashval])) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_debug:gettdb: no entries in tdb table for hash=%d of SA:%s.\n",
+			    hashval, sa);
+		return NULL;
+	}
+
+	for (; tdbp; tdbp = tdbp->tdb_hnext) {
+		if ((tdbp->tdb_said.spi == said->spi) &&
+		    (tdbp->tdb_said.dst.s_addr == said->dst.s_addr) &&
+		    (tdbp->tdb_said.proto == said->proto)) {
+			return tdbp;
+		}
+	}
+	
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:gettdb: no entry in linked list for hash=%d of SA:%s.\n",
+		    hashval, sa);
+	return NULL;
+}
+
+/* void */
+int
+puttdb(struct tdb *tdbp)
+{
+	int error = 0;
+	unsigned int hashval;
+
+	if(!tdbp) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:puttdb: null pointer passed in!\n");
+		return -ENODATA;
+	}
+	hashval = ((tdbp->tdb_said.spi + tdbp->tdb_said.dst.s_addr + tdbp->tdb_said.proto) % TDB_HASHMOD);
+
+	spin_lock_bh(&tdb_lock);
+	
+	tdbp->tdb_hnext = tdbh[hashval];
+	tdbh[hashval] = tdbp;
+	
+	spin_unlock_bh(&tdb_lock);
+
+	return error;
+}
+
+/* This tdb better be locked before it is handed in, or races might
+ * happen */
+
+/* void */
+int
+deltdb(struct tdb *tdbp)
+{
+	unsigned int hashval;
+	struct tdb *tdbtp;
+        char sa[SATOA_BUF];
+
+	if(!tdbp) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:deltdb: null pointer passed in!\n");
+		return -ENODATA;
+	}
+	
+	satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+	if(tdbp->tdb_inext || tdbp->tdb_onext) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:deltdb: SA:%s still linked!\n",
+			    sa);
+		return -EMLINK;
+	}
+	
+	hashval = ((tdbp->tdb_said.spi + tdbp->tdb_said.dst.s_addr + tdbp->tdb_said.proto) % TDB_HASHMOD);
+	
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:deltdb: deleting SA:%s, hashval=%d.\n",
+		    sa, hashval);
+	if(!tdbh[hashval]) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_debug:deltdb: no entries in tdb table for hash=%d of SA:%s.\n",
+			    hashval, sa);
+		return -ENOENT;
+	}
+	
+	if (tdbp == tdbh[hashval]) {
+		tdbh[hashval] = tdbh[hashval]->tdb_hnext;
+		tdbp->tdb_hnext = NULL;
+		KLIPS_PRINT(debug_xform,
+			    "klips_debug:deltdb: successfully deleted first tdb in chain.\n");
+		return 0;
+	} else {
+		for (tdbtp = tdbh[hashval]; tdbtp; tdbtp = tdbtp->tdb_hnext) {
+			if (tdbtp->tdb_hnext == tdbp) {
+				tdbtp->tdb_hnext = tdbp->tdb_hnext;
+				tdbp->tdb_hnext = NULL;
+				KLIPS_PRINT(debug_xform,
+					    "klips_debug:deltdb: successfully "
+					    "deleted link in tdb chain.\n");
+				return 0;
+			}
+		}
+	}
+	
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:deltdb: no entries in linked list for hash=%d of SA:%s.\n",
+		    hashval, sa);
+	return -ENOENT;
+}
+
+/* This tdb better be locked before it is handed in, or races might
+ * happen */
+
+int
+deltdbchain(struct tdb *tdbp)
+{
+	struct tdb *tdbdel;
+	int error = 0;
+        char sa[SATOA_BUF];
+
+	if(!tdbp) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:deltdbchain: null pointer passed in!\n");
+		return -ENODATA;
+	}
+
+	satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:deltdbchain: passed SA:%s\n", sa);
+	while(tdbp->tdb_onext) {
+		tdbp = tdbp->tdb_onext;
+	}
+
+	while(tdbp) {
+		/* XXX send a pfkey message up to advise of deleted TDB */
+		satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+		KLIPS_PRINT(debug_xform,
+			    "klips_debug:deltdbchain: unlinking and delting SA:%s", sa);
+		tdbdel = tdbp;
+		tdbp = tdbp->tdb_inext;
+		if(tdbp) {
+			satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+			KLIPS_PRINT(debug_xform,
+				    ", inext=%s", sa);
+			tdbdel->tdb_inext = NULL;
+			tdbp->tdb_onext = NULL;
+		}
+		KLIPS_PRINT(debug_xform,
+			    ".\n");
+		if((error = deltdb(tdbdel))) {
+			KLIPS_PRINT(debug_xform,
+				    "klips_debug:deltdbchain: "
+				    "deltdb returned error %d.\n", -error);
+			return error;
+		}
+		if((error = ipsec_tdbwipe(tdbdel))) {
+			KLIPS_PRINT(debug_xform,
+				    "klips_debug:deltdbchain: "
+				    "ipsec_tdbwipe returned error %d.\n", -error);
+			return error;
+		}
+	}
+	return error;
+}
+
+#if 0
+int
+tdb_init(struct tdb *tdbp, struct encap_msghdr *em)
+{
+	int alg;
+	struct xformsw *xsp;
+	int len;
+        int i;
+#if defined(CONFIG_IPSEC_ENC_3DES)
+        int error;
+#endif /* CONFIG_IPSEC_ENC_3DES */
+
+        char sa[SATOA_BUF];
+        size_t sa_len;
+
+	if(!tdbp || !em) {
+		KLIPS_PRINT(debug_xform,
+			    "klips_error:tdb_init: null pointer passed in!\n");
+		SENDERR(ENODATA);
+	}
+
+	sa_len = satoa(em->em_said, 0, sa, SATOA_BUF);
+
+        KLIPS_PRINT(debug_esp,
+		    "klips_debug:tdb_init: (algo_switch defined) called for SA:%s\n", sa);
+	alg = em->em_alg;
+	
+	for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++) {
+		if (xsp->xf_type == alg) {
+			KLIPS_PRINT(debug_netlink,
+				    "klips_debug:tdb_init: called with tdbp=0x%p, xsp=0x%p, em=0x%p\n",
+				    tdbp, xsp, em);
+			KLIPS_PRINT(debug_netlink,
+				    "klips_debug:tdb_init: calling init routine of %s\n",
+				    xsp->xf_name);
+			tdbp->tdb_xform = xsp;
+			tdbp->tdb_replaywin_lastseq = 0;
+			tdbp->tdb_replaywin_bitmap = 0;
+			/* check size of message here XXX */
+			switch(alg) {
+#ifdef CONFIG_IPSEC_IPIP
+			case XF_IP4: {
+				struct ipe4_xdata *xd;
+				xd = (struct ipe4_xdata *)(em->em_dat);
+
+				tdbp->tdb_authalg = AH_NONE;
+				tdbp->tdb_encalg = ESP_NONE;
+				
+ 				if((tdbp->tdb_addr_s = (struct sockaddr*)
+				   kmalloc((tdbp->tdb_addr_s_size = sizeof(struct sockaddr_in)),
+					   GFP_ATOMIC)) == NULL) {
+					SENDERR(ENOMEM);
+				}
+				if((tdbp->tdb_addr_d = (struct sockaddr*)
+				   kmalloc((tdbp->tdb_addr_d_size = sizeof(struct sockaddr_in)),
+					   GFP_ATOMIC)) == NULL) {
+					SENDERR(ENOMEM);
+				}
+				
+				/* might want to use a different structure here, or set sin_family and sin_port */
+				((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr = xd->i4_src;
+				((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr = xd->i4_dst;
+			}
+				break;
+#endif /* !CONFIG_IPSEC_IPIP */
+
+#ifdef CONFIG_IPSEC_AH
+
+# ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+			case XF_AHHMACMD5: {
+				struct ahhmacmd5_edata *ed;
+				unsigned char kb[AHMD596_BLKLEN];
+				MD5_CTX *ictx;
+				MD5_CTX *octx;
+
+				ed = (struct ahhmacmd5_edata *)em->em_dat;
+
+				tdbp->tdb_authalg = AH_MD5;
+				tdbp->tdb_encalg = ESP_NONE;
+				
+				if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ahhmacmd5_edata))
+					SENDERR(EINVAL);
+				
+				if (ed->ame_klen != AHMD596_KLEN) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: incorrect key size: %d"
+						    "-- must be %d octets (bytes)\n",
+						    ed->ame_klen, AHMD596_KLEN);
+					SENDERR(EINVAL);
+				}
+				
+				if (ed->ame_alen != AHMD596_ALEN) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: authenticator size: %d"
+						    " -- must be %d octets (bytes)\n",
+						    ed->ame_alen, AHMD596_ALEN);
+					SENDERR(EINVAL);
+				}
+				
+				KLIPS_PRINT(debug_ah,
+					    "klips_debug:tdb_init: hmac md5-96 key is 0x%08x %08x %08x %08x\n",
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+0)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+1)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+2)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+3)));
+				
+				tdbp->tdb_key_bits_a = ed->ame_klen;
+				tdbp->tdb_auth_bits = ed->ame_alen * 8;
+				
+				if(ed->ame_ooowin > 64) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: replay window size: %d"
+						    " -- must be 0 <= size <= 64\n",
+						    ed->ame_ooowin);
+					SENDERR(EINVAL);
+				}
+				tdbp->tdb_replaywin = ed->ame_ooowin;
+				tdbp->tdb_replaywin_lastseq = tdbp->tdb_replaywin_bitmap = 0;
+				
+				if((tdbp->tdb_key_a = (caddr_t)
+				    kmalloc((tdbp->tdb_key_a_size = sizeof(struct md5_ctx)),
+					    GFP_ATOMIC)) == NULL) {
+					SENDERR(ENOMEM);
+				}
+
+				for (i = 0; i < ed->ame_klen; i++) {
+					kb[i] = ed->ame_key[i] ^ HMAC_IPAD;
+				}
+				for (; i < AHMD596_BLKLEN; i++) {
+					kb[i] = HMAC_IPAD;
+				}
+
+				ictx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->ictx);
+				MD5Init(ictx);
+				MD5Update(ictx, kb, AHMD596_BLKLEN);
+
+				for (i = 0; i < AHMD596_BLKLEN; i++)
+					kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+
+				octx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->octx);
+				MD5Init(octx);
+				MD5Update(octx, kb, AHMD596_BLKLEN);
+				
+				KLIPS_PRINT(debug_ah,
+					    "klips_debug:tdb_init: MD5 ictx=0x%08x %08x %08x %08x"
+					    " octx=0x%08x %08x %08x %08x\n",
+					    ((__u32*)ictx)[0],
+					    ((__u32*)ictx)[1],
+					    ((__u32*)ictx)[2],
+					    ((__u32*)ictx)[3],
+					    ((__u32*)octx)[0],
+					    ((__u32*)octx)[1],
+					    ((__u32*)octx)[2],
+					    ((__u32*)octx)[3] );
+				
+				/* zero key buffer -- paranoid */
+				memset(kb, 0, sizeof(kb));
+				memset((caddr_t)&(ed->ame_key), 0, ed->ame_klen);
+			}
+				break;
+# endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+# ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+			case XF_AHHMACSHA1: {
+				struct ahhmacsha1_edata *ed;
+				unsigned char kb[AHSHA196_BLKLEN];
+				SHA1_CTX *ictx;
+				SHA1_CTX *octx;
+
+				ed = (struct ahhmacsha1_edata *)em->em_dat;
+				
+				tdbp->tdb_authalg = AH_SHA;
+				tdbp->tdb_encalg = ESP_NONE;
+				
+				if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ahhmacsha1_edata))
+					SENDERR(EINVAL);
+				
+				if (ed->ame_klen != AHSHA196_KLEN) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: incorrect key size: %d"
+						    "-- must be %d octets (bytes)\n",
+						    ed->ame_klen, AHSHA196_KLEN);
+					SENDERR(EINVAL);
+				}
+				
+				if (ed->ame_alen != AHSHA196_ALEN) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: authenticator size: %d"
+						    " -- must be %d octets (bytes)\n",
+						    ed->ame_alen, AHSHA196_ALEN);
+					SENDERR(EINVAL);
+				}
+				
+				KLIPS_PRINT(debug_ah,
+					    "klips_debug:tdb_init: hmac sha1-96 key is 0x%08x %08x %08x %08x\n",
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+0)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+1)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+2)),
+					    (__u32)ntohl(*(((__u32 *)ed->ame_key)+3)));
+				
+				tdbp->tdb_key_bits_a = ed->ame_klen;
+				tdbp->tdb_auth_bits = ed->ame_alen * 8;
+				
+				if(ed->ame_ooowin > 64) {
+					KLIPS_PRINT(debug_ah,
+						    "klips_debug:tdb_init: replay window size: %d"
+						    " -- must be 0 <= size <= 64\n",
+						    ed->ame_ooowin);
+					SENDERR(EINVAL);
+				}
+				tdbp->tdb_replaywin = ed->ame_ooowin;
+				tdbp->tdb_replaywin_lastseq = tdbp->tdb_replaywin_bitmap = 0;
+				
+				if((tdbp->tdb_key_a = (caddr_t)
+				    kmalloc((tdbp->tdb_key_a_size = (__u16)sizeof(struct sha1_ctx)),
+					    GFP_ATOMIC)) == NULL) {
+					SENDERR(ENOMEM);
+				}
+
+				for (i = 0; i < ed->ame_klen; i++)
+					kb[i] = ed->ame_key[i] ^ HMAC_IPAD;
+				for (; i < AHSHA196_BLKLEN; i++)
+					kb[i] = HMAC_IPAD;
+
+				ictx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx);
+				SHA1Init(ictx);
+				SHA1Update(ictx, kb, AHSHA196_BLKLEN);
+				
+				for (i = 0; i < AHSHA196_BLKLEN; i++)
+					kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+
+				octx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->octx);
+				SHA1Init(octx);
+				SHA1Update(octx, kb, AHSHA196_BLKLEN);
+				
+				KLIPS_PRINT(debug_ah,
+					    "klips_debug:tdb_init: SHA1 ictx=0x%08x %08x %08x %08x"
+					    " octx=0x%08x %08x %08x %08x\n", 
+					    ((__u32*)ictx)[0],
+					    ((__u32*)ictx)[1],
+					    ((__u32*)ictx)[2],
+					    ((__u32*)ictx)[3],
+					    ((__u32*)octx)[0],
+					    ((__u32*)octx)[1],
+					    ((__u32*)octx)[2],
+					    ((__u32*)octx)[3] );
+				
+				/* zero key buffer -- paranoid */
+				memset(kb, 0, sizeof(kb));
+				memset((caddr_t)&(ed->ame_key), 0, ed->ame_klen);
+			}
+				break;
+# endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+
+#endif /* CONFIG_IPSEC_AH */
+
+#ifdef CONFIG_IPSEC_ESP
+#ifdef CONFIG_IPSEC_ENC_3DES
+			case XF_ESP3DES:
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+			case XF_ESP3DESMD596:
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+			case XF_ESP3DESSHA196:
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+#endif /* CONFIG_IPSEC_ENC_3DES */
+#ifdef CONFIG_IPSEC_ENC_NULL
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+			case XF_ESPNULLMD596:
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+			case XF_ESPNULLSHA196:
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+#endif /* CONFIG_IPSEC_ENC_NULL */
+			{
+				struct espblkrply_edata *ed;
+				unsigned char kb[AHMD596_BLKLEN];
+				ed = (struct espblkrply_edata *)em->em_dat;
+
+				KLIPS_PRINT(debug_esp,
+					    "klips_debug:tdb_init: "
+					    "netlink data:"
+					    " eklen=%d"
+					    " aklen=%d"
+					    " flags=%d"
+					    " ooowin=%d.\n",
+					    ed->eme_klen,
+					    ed->ame_klen,
+					    ed->eme_flags,
+					    ed->eme_ooowin);
+
+				if(ed->eme_ooowin > 64) {
+					KLIPS_PRINT(debug_esp,
+						    "klips_debug:tdb_init: replay window size: %d"
+						    "-- must be 0 <= size <= 64\n",
+						    ed->eme_ooowin);
+					SENDERR(EINVAL);
+				}
+				tdbp->tdb_replaywin = ed->eme_ooowin;
+
+				switch(alg) {
+				case XF_ESP3DES:
+				case XF_ESP3DESMD596:
+				case XF_ESP3DESSHA196:
+					if((tdbp->tdb_iv = (caddr_t)
+					   kmalloc((tdbp->tdb_iv_size = EMT_ESPDES_IV_SZ), GFP_ATOMIC)) == NULL) {
+						SENDERR(ENOMEM);
+					}
+					get_random_bytes((void *)tdbp->tdb_iv, EMT_ESPDES_IV_SZ);
+					tdbp->tdb_iv_bits = tdbp->tdb_iv_size * 8;
+					break;
+				default:
+				}
+
+				switch(alg) {
+#ifdef CONFIG_IPSEC_ENC_3DES
+				case XF_ESP3DES:
+				case XF_ESP3DESMD596:
+				case XF_ESP3DESSHA196:
+					tdbp->tdb_encalg = ESP_3DES;
+				
+					if (ed->eme_klen != EMT_ESP3DES_KEY_SZ) {
+						KLIPS_PRINT(debug_esp,
+							    "klips_debug:tdb_init: incorrect encryption "
+							    "key size: %d -- must be %d octets (bytes)\n",
+							    ed->eme_klen, EMT_ESP3DES_KEY_SZ);
+						SENDERR(EINVAL);
+					}
+
+					tdbp->tdb_key_bits_e = ed->eme_klen;
+
+					if((tdbp->tdb_key_e = (caddr_t)
+					   kmalloc((tdbp->tdb_key_e_size = 3 * sizeof(struct des_eks)),
+						   GFP_ATOMIC)) == NULL) {
+						SENDERR(ENOMEM);
+					}
+
+					for(i = 0; i < 3; i++) {
+#if 0
+						KLIPS_PRINT(debug_esp,
+							    "klips_debug:tdb_init: 3des key %d/3 is 0x%08lx%08lx\n",
+							    i + 1,
+							    ntohl(*((__u32 *)ed->eme_key + i * 2)),
+							    ntohl(*((__u32 *)ed->eme_key + i * 2 + 1)));
+#endif
+						error = des_set_key((caddr_t)(ed->eme_key) + EMT_ESPDES_KEY_SZ * i,
+								    (caddr_t)&((struct des_eks*)(tdbp->tdb_key_e))[i]);
+						if (error == -1)
+							printk("klips_debug:tdb_init: parity error in des key %d/3\n", i + 1);
+						else if (error == -2)
+							printk("klips_debug:tdb_init: illegal weak des key %d/3\n", i + 1);
+						if (error) {
+							memset(tdbp->tdb_key_e, 0, 3 * sizeof(struct des_eks));
+							kfree(tdbp->tdb_key_e);
+							SENDERR(EINVAL);
+						}
+					}
+
+					break;
+#endif /* CONFIG_IPSEC_ENC_3DES */
+				default:
+					tdbp->tdb_encalg = ESP_NULL;
+				}
+
+				switch(alg) {
+#ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+				case XF_ESP3DESMD596:
+				case XF_ESPNULLMD596:
+				{
+					MD5_CTX *ictx;
+					MD5_CTX *octx;
+
+					tdbp->tdb_authalg = AH_MD5;
+				
+					if (ed->ame_klen != AHMD596_KLEN) {
+						KLIPS_PRINT(debug_esp,
+							    "klips_debug:tdb_init: incorrect authorisation "
+							    " key size: %d -- must be %d octets (bytes)\n",
+							    ed->ame_klen, AHMD596_KLEN);
+						SENDERR(EINVAL);
+					}
+
+					tdbp->tdb_key_bits_a = ed->ame_klen;
+					tdbp->tdb_auth_bits = ed->ame_klen * 8;
+			
+
+					if((tdbp->tdb_key_a = (caddr_t)
+					   kmalloc((tdbp->tdb_key_a_size = sizeof(struct md5_ctx)),
+						   GFP_ATOMIC)) == NULL) {
+						SENDERR(ENOMEM);
+					}
+					KLIPS_PRINT(debug_esp,
+						    "klips_debug:tdb_init: hmac md5-96 key is 0x%08x %08x %08x %08x\n",
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+0)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+1)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+2)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+3)));
+					
+					for (i=0; i< AHMD596_KLEN; i++)
+						kb[i] = (*(((unsigned char *)(ed->ame_key)) + i)) ^ HMAC_IPAD;
+					/*
+					 * HMAC_key is now contained in the first 128 bits of kb.
+					 * Pad with zeroes and XOR with HMAC_IPAD to create the inner context
+					 */
+					for (; i<AHMD596_BLKLEN; i++) {
+						kb[i] = HMAC_IPAD;
+					}
+
+					ictx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->ictx);
+					MD5Init(ictx);
+					MD5Update(ictx, kb, AHMD596_BLKLEN);
+					
+					for (i=0; i<AHMD596_BLKLEN; i++) {
+						kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+					}
+					
+					octx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->octx);
+					MD5Init(octx);
+					MD5Update(octx, kb, AHMD596_BLKLEN);
+					
+					KLIPS_PRINT(debug_esp,
+						    "klips_debug:tdb_init: MD5 ictx=0x%08x %08x %08x %08x"
+						    " octx=0x%08x %08x %08x %08x\n",
+						    ((__u32*)ictx)[0],
+						    ((__u32*)ictx)[1],
+						    ((__u32*)ictx)[2],
+						    ((__u32*)ictx)[3],
+						    ((__u32*)octx)[0],
+						    ((__u32*)octx)[1],
+						    ((__u32*)octx)[2],
+						    ((__u32*)octx)[3] );
+
+					memset(kb, 0, sizeof(kb)); /* paranoid */
+					memset((caddr_t)&(ed->eme_key), 0, ed->eme_klen);
+					memset((caddr_t)&(ed->ame_key), 0, ed->ame_klen);
+					break;
+				}
+#endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+#ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+				case XF_ESPNULLSHA196:
+				case XF_ESP3DESSHA196:
+				{
+					SHA1_CTX *ictx;
+					SHA1_CTX *octx;
+
+					tdbp->tdb_authalg = AH_SHA;
+				
+					if (ed->ame_klen != AHSHA196_KLEN) {
+						KLIPS_PRINT(debug_esp,
+							    "klips_debug:tdb_init: incorrect authorisation "
+							    " key size: %d -- must be %d octets (bytes)\n",
+							    ed->ame_klen, AHSHA196_KLEN);
+						SENDERR(EINVAL);
+					}
+
+					tdbp->tdb_key_bits_a = ed->ame_klen;
+					tdbp->tdb_auth_bits = ed->ame_klen * 8;
+
+					if((tdbp->tdb_key_a = (caddr_t)
+					   kmalloc((tdbp->tdb_key_a_size = sizeof(struct sha1_ctx)),
+						   GFP_ATOMIC)) == NULL) {
+						SENDERR(ENOMEM);
+					}
+					KLIPS_PRINT(debug_esp,
+						    "klips_debug:tdb_init: hmac sha1-96 key is 0x%08x %08x %08x %08x\n",
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+0)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+1)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+2)),
+						    (__u32)ntohl(*(((__u32 *)ed->ame_key)+3)));
+
+					for (i=0; i< AHSHA196_KLEN; i++)
+						kb[i] = (*(((unsigned char *)(ed->ame_key)) + i)) ^ HMAC_IPAD;
+					/*
+					 * HMAC_key is now contained in the first 128 bits of kb.
+					 * Pad with zeroes and XOR with HMAC_IPAD to create the inner context
+					 */
+					for (; i<AHSHA196_BLKLEN; i++)
+						kb[i] = HMAC_IPAD;
+					
+					ictx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx);
+					SHA1Init(ictx);
+					SHA1Update(ictx, kb, AHSHA196_BLKLEN);
+				
+					for (i=0; i<AHSHA196_BLKLEN; i++)
+						kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+					
+					octx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->octx);
+					SHA1Init(octx);
+					SHA1Update(octx, kb, AHSHA196_BLKLEN);
+				
+					KLIPS_PRINT(debug_esp,
+						    "klips_debug:tdb_init: SHA1 ictx=0x%08x %08x %08x %08x"
+						    " octx=0x%08x %08x %08x %08x\n",
+						    ((__u32*)ictx)[0],
+						    ((__u32*)ictx)[1],
+						    ((__u32*)ictx)[2],
+						    ((__u32*)ictx)[3],
+						    ((__u32*)octx)[0],
+						    ((__u32*)octx)[1],
+						    ((__u32*)octx)[2],
+						    ((__u32*)octx)[3] );
+					
+					memset(kb, 0, sizeof(kb)); /* paranoid */
+					memset((caddr_t)&(ed->eme_key), 0, ed->eme_klen);
+					memset((caddr_t)&(ed->ame_key), 0, ed->ame_klen);
+					break;
+				}
+#endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+				case XF_ESP3DES:
+					tdbp->tdb_authalg = AH_NONE;
+					break;
+				default:
+				}
+			}
+				break;
+#endif /* !CONFIG_IPSEC_ESP */
+			default:
+				KLIPS_PRINT(debug_xform,
+					    "klips_debug:tdb_init: alg=%d not configured\n", alg);
+				SENDERR(ESOCKTNOSUPPORT);
+			}
+			SENDERR(0);
+		}
+	}
+	KLIPS_PRINT(debug_xform & DB_XF_INIT,
+		    "klips_debug:tdb_init: unregistered algorithm %d requested\n"
+		    "klips_debug:   trying to setup SA:%s\n", alg, sa);
+	SENDERR(EINVAL);
+errlab:
+	return len;
+}
+#endif
+
+int 
+ipsec_tdbcleanup(__u8 proto)
+{
+	int i;
+	int error = 0;
+	struct tdb *tdbp, **tdbprev, *tdbdel;
+        char sa[SATOA_BUF];
+
+	KLIPS_PRINT(debug_xform,
+		    "klips_debug:ipsec_tdbcleanup: cleaning up proto=%d.\n", proto);
+
+	spin_lock_bh(&tdb_lock);
+
+	for (i = 0; i < TDB_HASHMOD; i++) {
+		tdbprev = &(tdbh[i]);
+		tdbp = tdbh[i];
+		for(; tdbp;) {
+			satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+			KLIPS_PRINT(debug_xform,
+				    "klips_debug:ipsec_tdbcleanup: checking SA:%s, hash=%d",
+				    sa, i);
+			tdbdel = tdbp;
+			tdbp = tdbdel->tdb_hnext;
+			if(tdbp) {
+				satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+				KLIPS_PRINT(debug_xform,
+					    ", hnext=%s", sa);
+			}
+			if(*tdbprev) {
+				satoa((*tdbprev)->tdb_said, 0, sa, SATOA_BUF);
+				KLIPS_PRINT(debug_xform,
+					    ", *tdbprev=%s", sa);
+				if((*tdbprev)->tdb_hnext) {
+					satoa((*tdbprev)->tdb_hnext->tdb_said, 0, sa, SATOA_BUF);
+					KLIPS_PRINT(debug_xform,
+						    ", *tdbprev->tdb_hnext=%s", sa);
+				}
+			}
+			KLIPS_PRINT(debug_xform,
+				    ".\n");
+			if(!proto || (proto == tdbdel->tdb_said.proto)) {
+				satoa(tdbdel->tdb_said, 0, sa, SATOA_BUF);
+				KLIPS_PRINT(debug_xform,
+					    "klips_debug:ipsec_tdbcleanup: deleting SA chain:%s.\n",
+					    sa);
+				/* *tdbprev = tdbdel->tdb_hnext; */
+				if((error = deltdbchain(tdbdel))) {
+					goto errlab;
+				}
+				tdbprev = &(tdbh[i]);
+				tdbp = tdbh[i];
+
+				KLIPS_PRINT(debug_xform,
+					    "klips_debug:ipsec_tdbcleanup: deleted SA chain:%s", sa);
+				if(tdbp) {
+					satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+					KLIPS_PRINT(debug_xform,
+						    ", tdbh[%d]=%s", i, sa);
+				}
+				if(*tdbprev) {
+					satoa((*tdbprev)->tdb_said, 0, sa, SATOA_BUF);
+					KLIPS_PRINT(debug_xform,
+						    ", *tdbprev=%s", sa);
+					if((*tdbprev)->tdb_hnext) {
+						satoa((*tdbprev)->tdb_hnext->tdb_said, 0, sa, SATOA_BUF);
+						KLIPS_PRINT(debug_xform,
+							    ", *tdbprev->tdb_hnext=%s", sa);
+					}
+				}
+				KLIPS_PRINT(debug_xform,
+					    ".\n");
+			} else {
+				tdbprev = &tdbdel;
+			}
+		}
+	}
+ errlab:
+
+	spin_unlock_bh(&tdb_lock);
+
+	return(-error);
+}
+
+int
+ipsec_tdbwipe(struct tdb *tdbp)
+{
+	if(!tdbp) {
+		return -1;
+	}
+
+	if(tdbp->tdb_addr_s) {
+		memset((caddr_t)(tdbp->tdb_addr_s), 0, tdbp->tdb_addr_s_size);
+		kfree(tdbp->tdb_addr_s);
+	}
+	tdbp->tdb_addr_s = NULL;
+
+	if(tdbp->tdb_addr_d) {
+		memset((caddr_t)(tdbp->tdb_addr_d), 0, tdbp->tdb_addr_d_size);
+		kfree(tdbp->tdb_addr_d);
+	}
+	tdbp->tdb_addr_d = NULL;
+
+	if(tdbp->tdb_addr_p) {
+		memset((caddr_t)(tdbp->tdb_addr_p), 0, tdbp->tdb_addr_p_size);
+		kfree(tdbp->tdb_addr_p);
+	}
+	tdbp->tdb_addr_p = NULL;
+
+	if(tdbp->tdb_key_a) {
+		memset((caddr_t)(tdbp->tdb_key_a), 0, tdbp->tdb_key_a_size);
+		kfree(tdbp->tdb_key_a);
+	}
+	tdbp->tdb_key_a = NULL;
+
+	if(tdbp->tdb_key_e) {
+		memset((caddr_t)(tdbp->tdb_key_e), 0, tdbp->tdb_key_e_size);
+		kfree(tdbp->tdb_key_e);
+	}
+	tdbp->tdb_key_e = NULL;
+
+	if(tdbp->tdb_iv) {
+		memset((caddr_t)(tdbp->tdb_iv), 0, tdbp->tdb_iv_size);
+		kfree(tdbp->tdb_iv);
+	}
+	tdbp->tdb_iv = NULL;
+
+	if(tdbp->tdb_ident_data_s) {
+		memset((caddr_t)(tdbp->tdb_ident_data_s),
+		       0,
+		       tdbp->tdb_ident_len_s * IPSEC_PFKEYv2_ALIGN);
+		kfree(tdbp->tdb_ident_data_s);
+	}
+	tdbp->tdb_ident_data_s = NULL;
+
+	if(tdbp->tdb_ident_data_d) {
+		memset((caddr_t)(tdbp->tdb_ident_data_d),
+		       0,
+		       tdbp->tdb_ident_len_d * IPSEC_PFKEYv2_ALIGN);
+		kfree(tdbp->tdb_ident_data_d);
+	}
+	tdbp->tdb_ident_data_d = NULL;
+
+	memset((caddr_t)tdbp, 0, sizeof(*tdbp));
+	kfree(tdbp);
+	tdbp = NULL;
+
+	return 0;
+}
+
+/*
+ * $Log$
+ * Revision 1.47  2000/11/06 04:32:08  rgb
+ * Ditched spin_lock_irqsave in favour of spin_lock_bh.
+ *
+ * Revision 1.46  2000/09/20 16:21:57  rgb
+ * Cleaned up ident string alloc/free.
+ *
+ * Revision 1.45  2000/09/08 19:16:51  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Removed all references to CONFIG_IPSEC_PFKEYv2.
+ *
+ * Revision 1.44  2000/08/30 05:29:04  rgb
+ * Compiler-define out no longer used tdb_init() in ipsec_xform.c.
+ *
+ * Revision 1.43  2000/08/18 21:30:41  rgb
+ * Purged all tdb_spi, tdb_proto and tdb_dst macros.  They are unclear.
+ *
+ * Revision 1.42  2000/08/01 14:51:51  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.41  2000/07/28 14:58:31  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.40  2000/06/28 05:50:11  rgb
+ * Actually set iv_bits.
+ *
+ * Revision 1.39  2000/05/10 23:11:09  rgb
+ * Added netlink debugging output.
+ * Added a cast to quiet down the ntohl bug.
+ *
+ * Revision 1.38  2000/05/10 19:18:42  rgb
+ * Cast output of ntohl so that the broken prototype doesn't make our
+ * compile noisy.
+ *
+ * Revision 1.37  2000/03/16 14:04:59  rgb
+ * Hardwired CONFIG_IPSEC_PFKEYv2 on.
+ *
+ * Revision 1.36  2000/01/26 10:11:28  rgb
+ * Fixed spacing in error text causing run-in words.
+ *
+ * Revision 1.35  2000/01/21 06:17:16  rgb
+ * Tidied up compiler directive indentation for readability.
+ * Added ictx,octx vars for simplification.(kravietz)
+ * Added macros for HMAC padding magic numbers.(kravietz)
+ * Fixed missing key length reporting bug.
+ * Fixed bug in tdbwipe to return immediately on NULL tdbp passed in.
+ *
+ * Revision 1.34  1999/12/08 00:04:19  rgb
+ * Fixed SA direction overwriting bug for netlink users.
+ *
+ * Revision 1.33  1999/12/01 22:16:44  rgb
+ * Minor formatting changes in ESP MD5 initialisation.
+ *
+ * Revision 1.32  1999/11/25 09:06:36  rgb
+ * Fixed error return messages, should be returning negative numbers.
+ * Implemented SENDERR macro for propagating error codes.
+ * Added debug message and separate error code for algorithms not compiled
+ * in.
+ *
+ * Revision 1.31  1999/11/23 23:06:26  rgb
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.30  1999/11/18 04:09:20  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.29  1999/11/17 15:53:40  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.28  1999/10/18 20:04:01  rgb
+ * Clean-out unused cruft.
+ *
+ * Revision 1.27  1999/10/03 19:01:03  rgb
+ * Spinlock support for 2.3.xx and 2.0.xx kernels.
+ *
+ * Revision 1.26  1999/10/01 16:22:24  rgb
+ * Switch from assignment init. to functional init. of spinlocks.
+ *
+ * Revision 1.25  1999/10/01 15:44:54  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.24  1999/10/01 00:03:46  rgb
+ * Added tdb structure locking.
+ * Minor formatting changes.
+ * Add function to initialize tdb hash table.
+ *
+ * Revision 1.23  1999/05/25 22:42:12  rgb
+ * Add deltdbchain() debugging.
+ *
+ * Revision 1.22  1999/05/25 21:24:31  rgb
+ * Add debugging statements to deltdbchain().
+ *
+ * Revision 1.21  1999/05/25 03:51:48  rgb
+ * Refix error return code.
+ *
+ * Revision 1.20  1999/05/25 03:34:07  rgb
+ * Fix error return for flush.
+ *
+ * Revision 1.19  1999/05/09 03:25:37  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.18  1999/05/05 22:02:32  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.17  1999/04/29 15:20:16  rgb
+ * Change gettdb parameter to a pointer to reduce stack loading and
+ * facilitate parameter sanity checking.
+ * Add sanity checking for null pointer arguments.
+ * Add debugging instrumentation.
+ * Add function deltdbchain() which will take care of unlinking,
+ * zeroing and deleting a chain of tdbs.
+ * Add a parameter to tdbcleanup to be able to delete a class of SAs.
+ * tdbwipe now actually zeroes the tdb as well as any of its pointed
+ * structures.
+ *
+ * Revision 1.16  1999/04/16 15:36:29  rgb
+ * Fix cut-and-paste error causing a memory leak in IPIP TDB freeing.
+ *
+ * Revision 1.15  1999/04/11 00:29:01  henry
+ * GPL boilerplate
+ *
+ * Revision 1.14  1999/04/06 04:54:28  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.13  1999/02/19 18:23:01  rgb
+ * Nix debug off compile warning.
+ *
+ * Revision 1.12  1999/02/17 16:52:16  rgb
+ * Consolidate satoa()s for space and speed efficiency.
+ * Convert DEBUG_IPSEC to KLIPS_PRINT
+ * Clean out unused cruft.
+ * Ditch NET_IPIP dependancy.
+ * Loop for 3des key setting.
+ *
+ * Revision 1.11  1999/01/26 02:09:05  rgb
+ * Remove ah/esp/IPIP switching on include files.
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ * Removed dead code.
+ * Clean up debug code when switched off.
+ * Remove references to INET_GET_PROTOCOL.
+ * Added code exclusion macros to reduce code from unused algorithms.
+ *
+ * Revision 1.10  1999/01/22 06:28:55  rgb
+ * Cruft clean-out.
+ * Put random IV generation in kernel.
+ * Added algorithm switch code.
+ * Enhanced debugging.
+ * 64-bit clean-up.
+ *
+ * Revision 1.9  1998/11/30 13:22:55  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.8  1998/11/25 04:59:06  rgb
+ * Add conditionals for no IPIP tunnel code.
+ * Delete commented out code.
+ *
+ * Revision 1.7  1998/10/31 06:50:41  rgb
+ * Convert xform ASCII names to no spaces.
+ * Fixed up comments in #endif directives.
+ *
+ * Revision 1.6  1998/10/19 14:44:28  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.5  1998/10/09 04:32:19  rgb
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ *
+ * Revision 1.4  1998/08/12 00:11:31  rgb
+ * Added new xform functions to the xform table.
+ * Fixed minor debug output spelling error.
+ *
+ * Revision 1.3  1998/07/09 17:45:31  rgb
+ * Clarify algorithm not available message.
+ *
+ * Revision 1.2  1998/06/23 03:00:51  rgb
+ * Check for presence of IPIP protocol if it is setup one way (we don't
+ * know what has been set up the other way and can only assume it will be
+ * symmetrical with the exception of keys).
+ *
+ * Revision 1.1  1998/06/18 21:27:51  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.3  1998/06/11 05:54:59  rgb
+ * Added transform version string pointer to xformsw initialisations.
+ *
+ * Revision 1.2  1998/04/21 21:28:57  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.1  1998/04/09 03:06:13  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:02  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added ESP-3DES-MD5-96
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Added new transforms.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/ipsec_xform.h linux/net/ipsec/ipsec_xform.h
--- linux-noipsec/net/ipsec/ipsec_xform.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/ipsec_xform.h	Mon Nov  6 05:30:40 2000
@@ -0,0 +1,359 @@
+/*
+ * Definitions relevant to IPSEC transformations
+ * Copyright (C) 1996, 1997  John Ioannidis.
+ * Copyright (C) 1998, 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#include <freeswan.h>
+
+#define XF_NONE			0	/* No transform set */
+#define XF_IP4			1	/* IPv4 inside IPv4 */
+#define XF_AHMD5		2	/* AH MD5 */
+#define XF_AHSHA		3	/* AH SHA */
+#define XF_ESP3DES		5	/* ESP DES3-CBC */
+#define XF_AHHMACMD5		6	/* AH-HMAC-MD5 with opt replay prot */
+#define XF_AHHMACSHA1		7	/* AH-HMAC-SHA1 with opt replay prot */
+#define XF_ESP3DESMD5		9	/* triple DES, HMAC-MD-5, 128-bits of authentication */
+#define	XF_ESP3DESMD596		10	/* triple DES, HMAC-MD-5, 96-bits of authentication */
+#define	XF_ESPNULLMD596		12	/* NULL, HMAC-MD-5 with 96-bits of authentication */
+#define	XF_ESPNULLSHA196	13	/* NULL, HMAC-SHA-1 with 96-bits of authentication */
+#define	XF_ESP3DESSHA196	14	/* triple DES, HMAC-SHA-1, 96-bits of authentication */
+#define XF_IP6			15	/* IPv6 inside IPv6 */
+#define XF_COMPDEFLATE		16	/* IPCOMP deflate */
+
+#define XF_CLR			126	/* Clear SA table */
+#define XF_DEL			127	/* Delete SA */
+
+/* IPsec AH transform values
+ * RFC 2407
+ * draft-ietf-ipsec-doi-tc-mib-02.txt
+ */
+
+#define AH_NONE                  0
+#define AH_MD5                   2
+#define AH_SHA                   3
+
+/* IPsec ESP transform values */
+
+#define ESP_NONE		 0
+#define ESP_3DES                 3
+#define ESP_RC5                  4
+#define ESP_IDEA                 5
+#define ESP_CAST                 6
+#define ESP_BLOWFISH             7
+#define ESP_3IDEA                8
+#define ESP_RC4                 10
+#define ESP_NULL                11
+
+/* IPCOMP transform values */
+
+#define IPCOMP_NONE              0
+#define IPCOMP_OUI               1
+#define IPCOMP_DEFLAT            2
+#define IPCOMP_LZS               3
+#define IPCOMP_V42BIS            4
+
+#define XFT_AUTH	0x0001
+#define XFT_CONF	0x0100
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define DB_XF_INIT	0x0001
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#ifdef __KERNEL__
+/* 'struct tdb' should really be 64bit aligned... XXX */
+struct tdb				/* tunnel descriptor block */
+{
+	struct tdb	*tdb_hnext;	/* next in hash chain */
+	struct tdb	*tdb_onext;	/* next in output */
+	struct tdb	*tdb_inext;	/* next in input (prev!) */
+	struct ifnet	*tdb_rcvif;	/* related rcv encap interface */
+	struct sa_id	tdb_said;	/* SA ID */
+	__u32	tdb_seq;	/* seq num of msg that set this SA */
+	__u32	tdb_pid;	/* PID of process that set this SA */
+	__u8		tdb_authalg;	/* auth algorithm for this SA */
+	__u8		tdb_encalg;	/* enc algorithm for this SA */
+
+	__u32		tdb_alg_errs;	/* number of algorithm errors */
+	__u32	tdb_auth_errs;	/* number of authentication errors */
+	__u32	tdb_encsize_errs;	/* number of encryption size errors */
+	__u32	tdb_encpad_errs;	/* number of encryption size errors */
+	__u32	tdb_replaywin_errs;	/* number of pkt sequence errors */
+
+	__u8		tdb_replaywin;	/* replay window size */
+	__u8		tdb_state;	/* state of SA */
+	__u32	tdb_replaywin_lastseq;	/* last pkt sequence num */
+	__u64	tdb_replaywin_bitmap;	/* bitmap of received pkts */
+	__u32	tdb_replaywin_maxdiff;	/* maximum pkt sequence difference */
+
+	__u32	tdb_flags;	/* generic xform flags */
+
+	__u32	tdb_lifetime_allocations_c;	/* see rfc2367 */
+	__u32	tdb_lifetime_allocations_s;
+	__u32	tdb_lifetime_allocations_h;
+	__u64	tdb_lifetime_bytes_c;
+	__u64	tdb_lifetime_bytes_s;
+	__u64	tdb_lifetime_bytes_h;
+	__u64	tdb_lifetime_addtime_c;
+	__u64	tdb_lifetime_addtime_s;
+	__u64	tdb_lifetime_addtime_h;
+	__u64	tdb_lifetime_usetime_c;
+	__u64	tdb_lifetime_usetime_s;
+	__u64	tdb_lifetime_usetime_h;
+	__u64	tdb_lifetime_packets_c;
+	__u64	tdb_lifetime_packets_s;
+	__u64	tdb_lifetime_packets_h;
+	__u64	tdb_lifetime_usetime_l;	/* last time transform was used */
+	struct sockaddr	*tdb_addr_s;	/* src sockaddr */
+	struct sockaddr	*tdb_addr_d;	/* dst sockaddr */
+       	struct sockaddr	*tdb_addr_p;	/* proxy sockaddr */
+	__u16	tdb_addr_s_size;
+	__u16	tdb_addr_d_size;
+	__u16	tdb_addr_p_size;
+	__u16	tdb_key_bits_a;	/* size of authkey in bits */
+	__u16	tdb_auth_bits;	/* size of authenticator in bits */
+	__u16	tdb_key_bits_e;	/* size of enckey in bits */
+	__u16	tdb_iv_bits;	/* size of IV in bits */
+
+	__u8	tdb_iv_size;
+	__u16	tdb_key_a_size;
+	__u16	tdb_key_e_size;
+	caddr_t	tdb_key_a;	/* authentication key */
+	caddr_t	tdb_key_e;	/* encryption key */
+	caddr_t	tdb_iv;		/* Initialisation Vector */
+	__u16	tdb_ident_type_s;	/* src identity type */
+	__u16	tdb_ident_type_d;	/* dst identity type */
+	__u64	tdb_ident_id_s;	/* src identity id */
+	__u64	tdb_ident_id_d;	/* dst identity id */
+	__u8	tdb_ident_len_s;	/* src identity type */
+	__u8	tdb_ident_len_d;	/* dst identity type */
+	caddr_t	tdb_ident_data_s;	/* src identity data */
+	caddr_t	tdb_ident_data_d;	/* dst identity data */
+#ifdef CONFIG_IPSEC_IPCOMP
+	__u16	tdb_comp_adapt_tries;   /* ipcomp self-adaption tries */
+	__u16	tdb_comp_adapt_skip;    /* ipcomp self-adaption to-skip */
+	__u64	tdb_comp_ratio_cbytes;	/* compressed bytes */
+	__u64	tdb_comp_ratio_dbytes;	/* decompressed (or uncompressed) bytes */
+#endif /* CONFIG_IPSEC_IPCOMP */
+#if 0
+	__u32	tdb_sens_dpd;
+	__u8	tdb_sens_sens_level;
+	__u8	tdb_sens_sens_len;
+	__u64*	tdb_sens_sens_bitmap;
+	__u8	tdb_sens_integ_level;
+	__u8	tdb_sens_integ_len;
+	__u64*	tdb_sens_integ_bitmap;
+#endif
+};
+
+#define PROTO2TXT(x) \
+	(x) == IPPROTO_AH ? "AH" : \
+	(x) == IPPROTO_ESP ? "ESP" : \
+	(x) == IPPROTO_IPIP ? "IPIP" : \
+	(x) == IPPROTO_COMP ? "COMP" : \
+	"UNKNOWN_proto"
+
+#if 0
+	(x)->tdb_said.proto == IPPROTO_AH ? "AH" : \
+	(x)->tdb_said.proto == IPPROTO_ESP ? "ESP" : \
+	(x)->tdb_said.proto == IPPROTO_IPIP ? "IPIP" : \
+	(x)->tdb_said.proto == IPPROTO_COMP ? "COMP" : \
+	"UNKNOWN_proto", \
+
+#endif
+#define TDB_XFORM_NAME(x) \
+	PROTO2TXT((x)->tdb_said.proto), \
+	(x)->tdb_said.proto == IPPROTO_COMP ? \
+		((x)->tdb_encalg == SADB_X_CALG_DEFLATE ? \
+		 "_DEFLATE" : "_UNKNOWN_comp") : \
+	(x)->tdb_encalg == ESP_NONE ? "" : \
+	(x)->tdb_encalg == ESP_3DES ? "_3DES" : \
+	(x)->tdb_encalg == ESP_NULL ? "_NULL_encr" : \
+	"_UNKNOWN_encr", \
+	(x)->tdb_authalg == AH_NONE ? "" : \
+	(x)->tdb_authalg == AH_MD5 ? "_HMAC_MD5" : \
+	(x)->tdb_authalg == AH_SHA ? "_HMAC_SHA1" : \
+	"_UNKNOWN_auth" \
+
+#define TDB_HASHMOD	257
+
+struct xformsw
+{
+	u_short		xf_type;	/* Unique ID of xform */
+	u_short		xf_flags;	/* secondary type reall) */
+	char		*xf_name;	/* human-readable name */
+};
+
+extern struct tdb *tdbh[TDB_HASHMOD];
+extern spinlock_t tdb_lock;
+extern struct xformsw xformsw[], *xformswNXFORMSW;
+
+extern int ipsec_tdbinit(void);
+extern struct tdb *gettdb(struct sa_id*);
+extern /* void */ int deltdb(struct tdb *);
+extern /* void */ int deltdbchain(struct tdb *);
+extern /* void */ int puttdb(struct tdb *);
+extern int tdb_init(struct tdb *, struct encap_msghdr *);
+extern int ipsec_tdbcleanup(__u8);
+extern int ipsec_tdbwipe(struct tdb *);
+
+#ifdef CONFIG_IPSEC_DEBUG
+extern int debug_xform;
+#endif /* CONFIG_IPSEC_DEBUG */
+#endif /* __KERNEL__ */
+
+/*
+ * $Log$
+ * Revision 1.28  2000/11/06 04:30:40  rgb
+ * Add Svenning's adaptive content compression.
+ *
+ * Revision 1.27  2000/09/19 00:38:25  rgb
+ * Fixed algorithm name bugs introduced for ipcomp.
+ *
+ * Revision 1.26  2000/09/17 21:36:48  rgb
+ * Added proto2txt macro.
+ *
+ * Revision 1.25  2000/09/17 18:56:47  rgb
+ * Added IPCOMP support.
+ *
+ * Revision 1.24  2000/09/12 19:34:12  rgb
+ * Defined XF_IP6 from Gerhard for ipv6 tunnel support.
+ *
+ * Revision 1.23  2000/09/12 03:23:14  rgb
+ * Cleaned out now unused tdb_xform and tdb_xdata members of struct tdb.
+ *
+ * Revision 1.22  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.21  2000/09/01 18:32:43  rgb
+ * Added (disabled) sensitivity members to tdb struct.
+ *
+ * Revision 1.20  2000/08/30 05:31:01  rgb
+ * Removed all the rest of the references to tdb_spi, tdb_proto, tdb_dst.
+ * Kill remainder of tdb_xform, tdb_xdata, xformsw.
+ *
+ * Revision 1.19  2000/08/01 14:51:52  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.18  2000/01/21 06:17:45  rgb
+ * Tidied up spacing.
+ *
+ * Revision 1.17  1999/11/17 15:53:40  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.16  1999/10/16 04:23:07  rgb
+ * Add stats for replaywin_errs, replaywin_max_sequence_difference,
+ * authentication errors, encryption size errors, encryption padding
+ * errors, and time since last packet.
+ *
+ * Revision 1.15  1999/10/16 00:29:11  rgb
+ * Added SA lifetime packet counting variables.
+ *
+ * Revision 1.14  1999/10/01 00:04:14  rgb
+ * Added tdb structure locking.
+ * Add function to initialize tdb hash table.
+ *
+ * Revision 1.13  1999/04/29 15:20:57  rgb
+ * dd return values to init and cleanup functions.
+ * Eliminate unnessessary usage of tdb_xform member to further switch
+ * away from the transform switch to the algorithm switch.
+ * Change gettdb parameter to a pointer to reduce stack loading and
+ * facilitate parameter sanity checking.
+ * Add a parameter to tdbcleanup to be able to delete a class of SAs.
+ *
+ * Revision 1.12  1999/04/15 15:37:25  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.9.2.2  1999/04/13 20:35:57  rgb
+ * Fix spelling mistake in comment.
+ *
+ * Revision 1.9.2.1  1999/03/30 17:13:52  rgb
+ * Extend struct tdb to support pfkey.
+ *
+ * Revision 1.11  1999/04/11 00:29:01  henry
+ * GPL boilerplate
+ *
+ * Revision 1.10  1999/04/06 04:54:28  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.9  1999/01/26 02:09:31  rgb
+ * Removed CONFIG_IPSEC_ALGO_SWITCH macro.
+ * Removed dead code.
+ *
+ * Revision 1.8  1999/01/22 06:29:35  rgb
+ * Added algorithm switch code.
+ * Cruft clean-out.
+ *
+ * Revision 1.7  1998/11/10 05:37:35  rgb
+ * Add support for SA direction flag.
+ *
+ * Revision 1.6  1998/10/19 14:44:29  rgb
+ * Added inclusion of freeswan.h.
+ * sa_id structure implemented and used: now includes protocol.
+ *
+ * Revision 1.5  1998/08/12 00:12:30  rgb
+ * Added macros for new xforms.  Added prototypes for new xforms.
+ *
+ * Revision 1.4  1998/07/28 00:04:20  rgb
+ * Add macro for clearing the SA table.
+ *
+ * Revision 1.3  1998/07/14 18:06:46  rgb
+ * Added #ifdef __KERNEL__ directives to restrict scope of header.
+ *
+ * Revision 1.2  1998/06/23 03:02:19  rgb
+ * Created a prototype for ipsec_tdbcleanup when it was moved from
+ * ipsec_init.c.
+ *
+ * Revision 1.1  1998/06/18 21:27:51  henry
+ * move sources from klips/src to klips/net/ipsec, to keep stupid
+ * kernel-build scripts happier in the presence of symlinks
+ *
+ * Revision 1.4  1998/06/11 05:55:31  rgb
+ * Added transform version string pointer to xformsw structure definition.
+ * Added extern declarations for transform version strings.
+ *
+ * Revision 1.3  1998/05/18 22:02:54  rgb
+ * Modify the *_zeroize function prototypes to include one parameter.
+ *
+ * Revision 1.2  1998/04/21 21:29:08  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.1  1998/04/09 03:06:14  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:06  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.5  1997/06/03 04:24:48  ji
+ * Added ESP-3DES-MD5-96
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * Added new transforms.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libdes/Makefile linux/net/ipsec/libdes/Makefile
--- linux-noipsec/net/ipsec/libdes/Makefile	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/Makefile	Fri Dec 15 15:02:26 2000
@@ -0,0 +1,246 @@
+# You must select the correct terminal control system to be used to
+# turn character echo off when reading passwords.  There a 5 systems
+# SGTTY   - the old BSD system
+# TERMIO  - most system V boxes
+# TERMIOS - SGI (ala IRIX).
+# VMS     - the DEC operating system
+# MSDOS   - we all know what it is :-)
+# read_pwd.c makes a reasonable guess at what is correct.
+
+# Targets
+# make          - twidle the options yourself :-)
+# make cc       - standard cc options
+# make gcc      - standard gcc options
+# make x86-elf  - linux-elf etc
+# make x86-out  - linux-a.out, FreeBSD etc
+# make x86-solaris
+# make x86-bdsi
+
+# If you are on a DEC Alpha, edit des.h and change the DES_LONG
+# define to 'unsigned int'.  I have seen this give a %20 speedup.
+
+OPTS0= -DLIBDES_LIT -DRAND -DTERMIO #-DNOCONST
+
+# Version 1.94 has changed the strings_to_key function so that it is
+# now compatible with MITs when the string is longer than 8 characters.
+# If you wish to keep the old version, uncomment the following line.
+# This will affect the -E/-D options on des(1).
+#OPTS1= -DOLD_STR_TO_KEY
+
+# There are 4 possible performance options
+# -DDES_PTR
+# -DDES_RISC1
+# -DDES_RISC2 (only one of DES_RISC1 and DES_RISC2)
+# -DDES_UNROLL
+# after the initial build, run 'des_opts' to see which options are best
+# for your platform.  There are some listed in options.txt
+#OPTS2= -DDES_PTR 
+#OPTS3= -DDES_RISC1 # or DES_RISC2
+#OPTS4= -DDES_UNROLL
+
+OPTS= $(OPTS0) $(OPTS1) $(OPTS2) $(OPTS3) $(OPTS4)
+
+MAKE=make -f Makefile
+#CC=cc
+#CFLAG= -O
+
+#CC=gcc
+#CFLAG= -O4 -funroll-loops -fomit-frame-pointer
+CFLAG=-fomit-frame-pointer
+
+CFLAGS=$(OPT_FLAGS) $(CFLAG)
+CPP=$(CC) -E
+AS=as
+
+# Assember version of des_encrypt*().
+DES_ENC=des_enc.o fcrypt_b.o		# normal C version
+#DES_ENC=asm/dx86-elf.o	asm/yx86-elf.o	# elf format x86
+#DES_ENC=asm/dx86-out.o	asm/yx86-out.o	# a.out format x86
+#DES_ENC=asm/dx86-sol.o	asm/yx86-sol.o	# solaris format x86 
+#DES_ENC=asm/dx86bsdi.o	asm/yx86basi.o	# bsdi format x86 
+
+LIBDIR=/usr/lib
+BINDIR=/usr/bin
+INCDIR=/usr/include
+MANDIR=/usr/share/man
+MAN1=1
+MAN3=3
+SHELL=/bin/sh
+OBJ_LIT=cbc_enc.o ecb_enc.o $(DES_ENC) fcrypt.o set_key.o
+OBJ_FULL=cbc_cksm.o $(OBJ_LIT) pcbc_enc.o \
+	xcbc_enc.o qud_cksm.o \
+	cfb64ede.o cfb64enc.o cfb_enc.o ecb3_enc.o \
+	enc_read.o enc_writ.o ofb64ede.o ofb64enc.o ofb_enc.o  \
+	rand_key.o read_pwd.o read2pwd.o rpc_enc.o  str2key.o supp.o
+
+GENERAL_LIT=COPYRIGHT INSTALL README VERSION Makefile des_crypt.man \
+	des.doc options.txt asm
+GENERAL_FULL=$(GENERAL_LIT) FILES Imakefile times vms.com KERBEROS MODES.DES \
+	des.man DES.pm DES.pod DES.xs Makefile.PL dess.cpp des3s.cpp \
+	Makefile.uni typemap t Makefile.ssl makefile.bc Makefile.lit \
+	des.org des_locl.org
+TESTING_LIT=	destest speed des_opts
+TESTING_FULL=	rpw $(TESTING_LIT)
+TESTING_SRC_LIT=destest.c speed.c des_opts.c
+TESTING_SRC_FULL=rpw.c $(TESTING_SRC_LIT)
+HEADERS_LIT=des_ver.h des.h des_locl.h podd.h sk.h spr.h
+HEADERS_FULL= $(HEADERS_LIT) rpc_des.h
+LIBDES_LIT=cbc_enc.c ecb_enc.c fcrypt.c set_key.c des_enc.c fcrypt_b.c
+LIBDES_FULL= cbc_cksm.c pcbc_enc.c qud_cksm.c \
+	cfb64ede.c cfb64enc.c cfb_enc.c ecb3_enc.c \
+	enc_read.c enc_writ.c ofb64ede.c ofb64enc.c ofb_enc.c  \
+	rand_key.c rpc_enc.c  str2key.c  supp.c \
+	xcbc_enc.c $(LIBDES_LIT) read_pwd.c read2pwd.c
+
+PERL=	des.pl testdes.pl doIP doPC1 doPC2 PC1 PC2 shifts.pl
+
+OBJ=	$(OBJ_LIT)
+GENERAL=$(GENERAL_LIT)
+TESTING=$(TESTING_LIT)
+TESTING_SRC=$(TESTING_SRC_LIT)
+HEADERS=$(HEADERS_LIT)
+LIBDES=	$(LIBDES_LIT)
+
+ALL=	$(GENERAL) $(TESTING_SRC) $(LIBDES) $(PERL) $(HEADERS)
+
+DLIB=	libdes.a
+
+all: $(DLIB) $(TESTING)
+
+cc:
+	$(MAKE) CC=cc CFLAGS="-O $(OPTS) $(CFLAG)" all
+
+gcc:
+	$(MAKE) CC=gcc CFLAGS="-O3 -fomit-frame-pointer $(OPTS) $(CFLAG)" all
+
+x86-elf:
+	$(MAKE) DES_ENC='asm/dx86-elf.o asm/yx86-elf.o' CC='$(CC)' CFLAGS="-DELF $(OPTS) $(CFLAG)" all
+
+x86-out:
+	$(MAKE) DES_ENC='asm/dx86-out.o asm/yx86-out.o' CC='$(CC)' CFLAGS="-DOUT $(OPTS) $(CFLAG)" all
+
+x86-solaris:
+	$(MAKE) DES_ENC='asm/dx86-sol.o asm/yx86-sol.o' CC='$(CC)' CFLAGS="-DSOL $(OPTS) $(CFLAG)" all
+
+x86-bsdi:
+	$(MAKE) DES_ENC='asm/dx86bsdi.o asm/yx86bsdi.o' CC='$(CC)' CFLAGS="-DBSDI $(OPTS) $(CFLAG)" all
+
+# elf
+asm/dx86-elf.o: asm/dx86unix.cpp
+	$(CPP) -DELF asm/dx86unix.cpp | $(AS) -o asm/dx86-elf.o
+
+asm/yx86-elf.o: asm/yx86unix.cpp
+	$(CPP) -DELF asm/yx86unix.cpp | $(AS) -o asm/yx86-elf.o
+
+# solaris
+asm/dx86-sol.o: asm/dx86unix.cpp
+	$(CC) -E -DSOL asm/dx86unix.cpp | sed 's/^#.*//' > asm/dx86-sol.s
+	as -o asm/dx86-sol.o asm/dx86-sol.s
+	rm -f asm/dx86-sol.s
+
+asm/yx86-sol.o: asm/yx86unix.cpp
+	$(CC) -E -DSOL asm/yx86unix.cpp | sed 's/^#.*//' > asm/yx86-sol.s
+	as -o asm/yx86-sol.o asm/yx86-sol.s
+	rm -f asm/yx86-sol.s
+
+# a.out
+asm/dx86-out.o: asm/dx86unix.cpp
+	$(CPP) -DOUT asm/dx86unix.cpp | $(AS) -o asm/dx86-out.o
+
+asm/yx86-out.o: asm/yx86unix.cpp
+	$(CPP) -DOUT asm/yx86unix.cpp | $(AS) -o asm/yx86-out.o
+
+# bsdi
+asm/dx86bsdi.o: asm/dx86unix.cpp
+	$(CPP) -DBSDI asm/dx86unix.cpp | $(AS) -o asm/dx86bsdi.o
+
+asm/yx86bsdi.o: asm/yx86unix.cpp
+	$(CPP) -DBSDI asm/yx86unix.cpp | $(AS) -o asm/yx86bsdi.o
+
+asm/dx86unix.cpp:
+	(cd asm; perl des-586.pl cpp >dx86unix.cpp)
+
+asm/yx86unix.cpp:
+	(cd asm; perl crypt586.pl cpp >yx86unix.cpp)
+
+test:	all
+	./destest
+
+$(DLIB): $(OBJ)
+	/bin/rm -f $(DLIB)
+	ar cr $(DLIB) $(OBJ)
+	-if test -s /bin/ranlib; then /bin/ranlib $(DLIB); \
+	else if test -s /usr/bin/ranlib; then /usr/bin/ranlib $(DLIB); \
+	else exit 0; fi; fi
+
+des_opts: des_opts.o $(DLIB)
+	$(CC) $(CFLAGS) -o des_opts des_opts.o $(DLIB)
+
+destest: destest.o $(DLIB)
+	$(CC) $(CFLAGS) -o destest destest.o $(DLIB)
+
+rpw: rpw.o $(DLIB)
+	$(CC) $(CFLAGS) -o rpw rpw.o $(DLIB)
+
+speed: speed.o $(DLIB)
+	$(CC) $(CFLAGS) -o speed speed.o $(DLIB)
+
+des: des.o $(DLIB)
+	$(CC) $(CFLAGS) -o des des.o $(DLIB)
+
+tags:
+	ctags $(TESTING_SRC) $(LIBDES)
+
+tar_lit:
+	/bin/mv Makefile Makefile.tmp
+	/bin/cp Makefile.lit Makefile
+	tar chf libdes-l.tar $(LIBDES_LIT) $(HEADERS_LIT) \
+		$(GENERAL_LIT) $(TESTING_SRC_LIT)
+	/bin/rm -f Makefile
+	/bin/mv Makefile.tmp Makefile
+
+tar:
+	tar chf libdes.tar $(ALL)
+
+shar:
+	shar $(ALL) >libdes.shar
+
+depend:
+	makedepend $(LIBDES) $(TESTING_SRC)
+
+clean:
+	/bin/rm -f *.o tags core $(TESTING) $(DLIB) .nfs* *.old *.bak asm/*.o 
+
+dclean:
+	sed -e '/^# DO NOT DELETE THIS LINE/ q' Makefile >Makefile.new
+	mv -f Makefile.new Makefile
+
+# Eric is probably going to choke when he next looks at this --tjh
+install:
+	if test $(INSTALLTOP); then \
+	    echo SSL style install; \
+	    cp $(DLIB) $(INSTALLTOP)/lib; \
+	    if test -s /bin/ranlib; then \
+	        /bin/ranlib $(INSTALLTOP)/lib/$(DLIB); \
+	    else \
+		if test -s /usr/bin/ranlib; then \
+		/usr/bin/ranlib $(INSTALLTOP)/lib/$(DLIB); \
+	    fi; fi; \
+	    chmod 644 $(INSTALLTOP)/lib/$(DLIB); \
+	    cp des.h $(INSTALLTOP)/include; \
+	    chmod 644 $(INSTALLTOP)/include/des.h; \
+	else \
+	    echo Standalone install; \
+	    cp $(DLIB) $(DESTDIR)$(LIBDIR)/$(DLIB); \
+	    if test -s /bin/ranlib; then \
+	      /bin/ranlib $(DESTDIR)$(LIBDIR)/$(DLIB); \
+	    else \
+	      if test -s /usr/bin/ranlib; then \
+		/usr/bin/ranlib $(LIBDIR)/$(DLIB); \
+	      fi; \
+	    fi; \
+	    cp des_crypt.man $(DESTDIR)$(MANDIR)/man$(MAN3)/des_crypt.$(MAN3); \
+	    cp des.man $(DESTDIR)$(MANDIR)/man$(MAN1)/des.$(MAN1); \
+	    cp des.h $(DESTDIR)$(INCDIR)/des.h; \
+	fi
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -druN linux-noipsec/net/ipsec/libdes/asm/crypt586.pl linux/net/ipsec/libdes/asm/crypt586.pl
--- linux-noipsec/net/ipsec/libdes/asm/crypt586.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/crypt586.pl	Thu Feb 18 17:41:30 1999
@@ -0,0 +1,204 @@
+#!/usr/local/bin/perl
+#
+# The inner loop instruction sequence and the IP/FP modifications are from
+# Svend Olaf Mikkelsen <svolaf@inet.uni-c.dk>
+# I've added the stuff needed for crypt() but I've not worried about making
+# things perfect.
+#
+
+push(@INC,"perlasm","../../perlasm");
+require "x86asm.pl";
+
+&asm_init($ARGV[0],"crypt586.pl");
+
+$L="edi";
+$R="esi";
+
+&external_label("des_SPtrans");
+&fcrypt_body("fcrypt_body");
+&asm_finish();
+
+sub fcrypt_body
+	{
+	local($name,$do_ip)=@_;
+
+	&function_begin($name,"EXTRN   _des_SPtrans:DWORD");
+
+	&comment("");
+	&comment("Load the 2 words");
+	$ks="ebp";
+
+	&xor(	$L,	$L);
+	&xor(	$R,	$R);
+	&mov($ks,&wparam(1));
+
+	&push(25); # add a variable
+
+	&set_label("start");
+	for ($i=0; $i<16; $i+=2)
+		{
+		&comment("");
+		&comment("Round $i");
+		&D_ENCRYPT($i,$L,$R,$i*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+
+		&comment("");
+		&comment("Round ".sprintf("%d",$i+1));
+		&D_ENCRYPT($i+1,$R,$L,($i+1)*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+		}
+	 &mov("ebx",	&swtmp(0));
+	&mov("eax",	$L);
+	 &dec("ebx");
+	&mov($L,	$R);
+	 &mov($R,	"eax");
+	&mov(&swtmp(0),	"ebx");
+	 &jnz(&label("start"));
+
+	&comment("");
+	&comment("FP");
+	&mov("edx",&wparam(0));
+
+	&FP_new($R,$L,"eax",3);
+	&mov(&DWP(0,"edx","",0),"eax");
+	&mov(&DWP(4,"edx","",0),$L);
+
+	&pop("ecx");	# remove variable
+
+	&function_end($name);
+	}
+
+sub D_ENCRYPT
+	{
+	local($r,$L,$R,$S,$ks,$desSP,$u,$tmp1,$tmp2,$t)=@_;
+
+	&mov(	$u,		&wparam(2));			# 2
+	&mov(	$t,		$R);
+	&shr(	$t,		16);				# 1
+	&mov(	$tmp2,		&wparam(3));			# 2
+	&xor(	$t,		$R);				# 1
+
+	&and(	$u,		$t);				# 2
+	&and(	$t,		$tmp2);				# 2
+
+	&mov(	$tmp1,		$u);
+	&shl(	$tmp1,		16); 				# 1
+	&mov(	$tmp2,		$t);
+	&shl(	$tmp2,		16); 				# 1
+	&xor(	$u,		$tmp1);				# 2
+	&xor(	$t,		$tmp2);				# 2
+	&mov(	$tmp1,		&DWP(&n2a($S*4),$ks,"",0));	# 2
+	&xor(	$u,		$tmp1);
+	&mov(	$tmp2,		&DWP(&n2a(($S+1)*4),$ks,"",0));	# 2
+	&xor(	$u,		$R);
+	&xor(	$t,		$R);
+	&xor(	$t,		$tmp2);
+
+	&and(	$u,		"0xfcfcfcfc"	);		# 2
+	&xor(	$tmp1,		$tmp1);				# 1
+	&and(	$t,		"0xcfcfcfcf"	);		# 2
+	&xor(	$tmp2,		$tmp2);	
+	&movb(	&LB($tmp1),	&LB($u)	);
+	&movb(	&LB($tmp2),	&HB($u)	);
+	&rotr(	$t,		4		);
+	&mov(	$ks,		&DWP("      $desSP",$tmp1,"",0));
+	&movb(	&LB($tmp1),	&LB($t)	);
+	&xor(	$L,		$ks);
+	&mov(	$ks,		&DWP("0x200+$desSP",$tmp2,"",0));
+	&xor(	$L,		$ks);
+	&movb(	&LB($tmp2),	&HB($t)	);
+	&shr(	$u,		16);
+	&mov(	$ks,		&DWP("0x100+$desSP",$tmp1,"",0));
+	&xor(	$L,		$ks); 
+	&movb(	&LB($tmp1),	&HB($u)	);
+	&shr(	$t,		16);
+	&mov(	$ks,		&DWP("0x300+$desSP",$tmp2,"",0));
+	&xor(	$L,		$ks);
+	&mov(	$ks,		&wparam(1));
+	&movb(	&LB($tmp2),	&HB($t)	);
+	&and(	$u,		"0xff"	);
+	&and(	$t,		"0xff"	);
+	&mov(	$tmp1,		&DWP("0x600+$desSP",$tmp1,"",0));
+	&xor(	$L,		$tmp1);
+	&mov(	$tmp1,		&DWP("0x700+$desSP",$tmp2,"",0));
+	&xor(	$L,		$tmp1);
+	&mov(	$tmp1,		&DWP("0x400+$desSP",$u,"",0));
+	&xor(	$L,		$tmp1);
+	&mov(	$tmp1,		&DWP("0x500+$desSP",$t,"",0));
+	&xor(	$L,		$tmp1);
+	}
+
+sub n2a
+	{
+	sprintf("%d",$_[0]);
+	}
+
+# now has a side affect of rotating $a by $shift
+sub R_PERM_OP
+	{
+	local($a,$b,$tt,$shift,$mask,$last)=@_;
+
+	&rotl(	$a,		$shift		) if ($shift != 0);
+	&mov(	$tt,		$a		);
+	&xor(	$a,		$b		);
+	&and(	$a,		$mask		);
+	if ($notlast eq $b)
+		{
+		&xor(	$b,		$a		);
+		&xor(	$tt,		$a		);
+		}
+	else
+		{
+		&xor(	$tt,		$a		);
+		&xor(	$b,		$a		);
+		}
+	&comment("");
+	}
+
+sub IP_new
+	{
+	local($l,$r,$tt,$lr)=@_;
+
+	&R_PERM_OP($l,$r,$tt, 4,"0xf0f0f0f0",$l);
+	&R_PERM_OP($r,$tt,$l,20,"0xfff0000f",$l);
+	&R_PERM_OP($l,$tt,$r,14,"0x33333333",$r);
+	&R_PERM_OP($tt,$r,$l,22,"0x03fc03fc",$r);
+	&R_PERM_OP($l,$r,$tt, 9,"0xaaaaaaaa",$r);
+	
+	if ($lr != 3)
+		{
+		if (($lr-3) < 0)
+			{ &rotr($tt,	3-$lr); }
+		else	{ &rotl($tt,	$lr-3); }
+		}
+	if ($lr != 2)
+		{
+		if (($lr-2) < 0)
+			{ &rotr($r,	2-$lr); }
+		else	{ &rotl($r,	$lr-2); }
+		}
+	}
+
+sub FP_new
+	{
+	local($l,$r,$tt,$lr)=@_;
+
+	if ($lr != 2)
+		{
+		if (($lr-2) < 0)
+			{ &rotl($r,	2-$lr); }
+		else	{ &rotr($r,	$lr-2); }
+		}
+	if ($lr != 3)
+		{
+		if (($lr-3) < 0)
+			{ &rotl($l,	3-$lr); }
+		else	{ &rotr($l,	$lr-3); }
+		}
+
+	&R_PERM_OP($l,$r,$tt, 0,"0xaaaaaaaa",$r);
+	&R_PERM_OP($tt,$r,$l,23,"0x03fc03fc",$r);
+	&R_PERM_OP($l,$r,$tt,10,"0x33333333",$l);
+	&R_PERM_OP($r,$tt,$l,18,"0xfff0000f",$l);
+	&R_PERM_OP($l,$tt,$r,12,"0xf0f0f0f0",$r);
+	&rotr($tt	, 4);
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/asm/des-586.pl linux/net/ipsec/libdes/asm/des-586.pl
--- linux-noipsec/net/ipsec/libdes/asm/des-586.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/des-586.pl	Thu Feb 18 17:41:31 1999
@@ -0,0 +1,251 @@
+#!/usr/local/bin/perl
+#
+# The inner loop instruction sequence and the IP/FP modifications are from
+# Svend Olaf Mikkelsen <svolaf@inet.uni-c.dk>
+#
+
+push(@INC,"perlasm","../../perlasm");
+require "x86asm.pl";
+require "cbc.pl";
+require "desboth.pl";
+
+# base code is in microsft
+# op dest, source
+# format.
+#
+
+&asm_init($ARGV[0],"des-586.pl");
+
+$L="edi";
+$R="esi";
+
+&external_label("des_SPtrans");
+&des_encrypt("des_encrypt",1);
+&des_encrypt("des_encrypt2",0);
+&des_encrypt3("des_encrypt3",1);
+&des_encrypt3("des_decrypt3",0);
+&cbc("des_ncbc_encrypt","des_encrypt","des_encrypt",0,4,5,3,5,-1);
+&cbc("des_ede3_cbc_encrypt","des_encrypt3","des_decrypt3",0,6,7,3,4,5);
+
+&asm_finish();
+
+sub des_encrypt
+	{
+	local($name,$do_ip)=@_;
+
+	&function_begin_B($name,"EXTRN   _des_SPtrans:DWORD");
+
+	&push("esi");
+	&push("edi");
+
+	&comment("");
+	&comment("Load the 2 words");
+	$ks="ebp";
+
+	if ($do_ip)
+		{
+		&mov($R,&wparam(0));
+		 &xor(	"ecx",		"ecx"		);
+
+		&push("ebx");
+		&push("ebp");
+
+		&mov("eax",&DWP(0,$R,"",0));
+		 &mov("ebx",&wparam(2));	# get encrypt flag
+		&mov($L,&DWP(4,$R,"",0));
+		&comment("");
+		&comment("IP");
+		&IP_new("eax",$L,$R,3);
+		}
+	else
+		{
+		&mov("eax",&wparam(0));
+		 &xor(	"ecx",		"ecx"		);
+
+		&push("ebx");
+		&push("ebp");
+
+		&mov($R,&DWP(0,"eax","",0));
+		 &mov("ebx",&wparam(2));	# get encrypt flag
+		&rotl($R,3);
+		&mov($L,&DWP(4,"eax","",0));
+		&rotl($L,3);
+		}
+
+	&mov(	$ks,		&wparam(1)	);
+	&cmp("ebx","0");
+	&je(&label("start_decrypt"));
+
+	for ($i=0; $i<16; $i+=2)
+		{
+		&comment("");
+		&comment("Round $i");
+		&D_ENCRYPT($i,$L,$R,$i*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+
+		&comment("");
+		&comment("Round ".sprintf("%d",$i+1));
+		&D_ENCRYPT($i+1,$R,$L,($i+1)*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+		}
+	&jmp(&label("end"));
+
+	&set_label("start_decrypt");
+
+	for ($i=15; $i>0; $i-=2)
+		{
+		&comment("");
+		&comment("Round $i");
+		&D_ENCRYPT(15-$i,$L,$R,$i*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+		&comment("");
+		&comment("Round ".sprintf("%d",$i-1));
+		&D_ENCRYPT(15-$i+1,$R,$L,($i-1)*2,$ks,"des_SPtrans","eax","ebx","ecx","edx");
+		}
+
+	&set_label("end");
+
+	if ($do_ip)
+		{
+		&comment("");
+		&comment("FP");
+		&mov("edx",&wparam(0));
+		&FP_new($L,$R,"eax",3);
+
+		&mov(&DWP(0,"edx","",0),"eax");
+		&mov(&DWP(4,"edx","",0),$R);
+		}
+	else
+		{
+		&comment("");
+		&comment("Fixup");
+		&rotr($L,3);		# r
+		 &mov("eax",&wparam(0));
+		&rotr($R,3);		# l
+		 &mov(&DWP(0,"eax","",0),$L);
+		 &mov(&DWP(4,"eax","",0),$R);
+		}
+
+	&pop("ebp");
+	&pop("ebx");
+	&pop("edi");
+	&pop("esi");
+	&ret();
+
+	&function_end_B($name);
+	}
+
+sub D_ENCRYPT
+	{
+	local($r,$L,$R,$S,$ks,$desSP,$u,$tmp1,$tmp2,$t)=@_;
+
+	 &mov(	$u,		&DWP(&n2a($S*4),$ks,"",0));
+	&xor(	$tmp1,		$tmp1);
+	 &mov(	$t,		&DWP(&n2a(($S+1)*4),$ks,"",0));
+	&xor(	$u,		$R);
+	 &xor(	$t,		$R);
+	&and(	$u,		"0xfcfcfcfc"	);
+	 &and(	$t,		"0xcfcfcfcf"	);
+	&movb(	&LB($tmp1),	&LB($u)	);
+	 &movb(	&LB($tmp2),	&HB($u)	);
+	&rotr(	$t,		4		);
+	&mov(	$ks,		&DWP("      $desSP",$tmp1,"",0));
+	 &movb(	&LB($tmp1),	&LB($t)	);
+	&xor(	$L,		$ks);
+	 &mov(	$ks,		&DWP("0x200+$desSP",$tmp2,"",0));
+	&xor(	$L,		$ks); ######
+	 &movb(	&LB($tmp2),	&HB($t)	);
+	&shr(	$u,		16);
+	 &mov(	$ks,		&DWP("0x100+$desSP",$tmp1,"",0));
+	&xor(	$L,		$ks); ######
+	 &movb(	&LB($tmp1),	&HB($u)	);
+	&shr(	$t,		16);
+	 &mov(	$ks,		&DWP("0x300+$desSP",$tmp2,"",0));
+	&xor(	$L,		$ks);
+	 &mov(	$ks,		&wparam(1)	);
+	&movb(	&LB($tmp2),	&HB($t)	);
+	 &and(	$u,		"0xff"	);
+	&and(	$t,		"0xff"	);
+	 &mov(	$tmp1,		&DWP("0x600+$desSP",$tmp1,"",0));
+	&xor(	$L,		$tmp1);
+	 &mov(	$tmp1,		&DWP("0x700+$desSP",$tmp2,"",0));
+	&xor(	$L,		$tmp1);
+	 &mov(	$tmp1,		&DWP("0x400+$desSP",$u,"",0));
+	&xor(	$L,		$tmp1);
+	 &mov(	$tmp1,		&DWP("0x500+$desSP",$t,"",0));
+	&xor(	$L,		$tmp1);
+	}
+
+sub n2a
+	{
+	sprintf("%d",$_[0]);
+	}
+
+# now has a side affect of rotating $a by $shift
+sub R_PERM_OP
+	{
+	local($a,$b,$tt,$shift,$mask,$last)=@_;
+
+	&rotl(	$a,		$shift		) if ($shift != 0);
+	&mov(	$tt,		$a		);
+	&xor(	$a,		$b		);
+	&and(	$a,		$mask		);
+	if (!$last eq $b)
+		{
+		&xor(	$b,		$a		);
+		&xor(	$tt,		$a		);
+		}
+	else
+		{
+		&xor(	$tt,		$a		);
+		&xor(	$b,		$a		);
+		}
+	&comment("");
+	}
+
+sub IP_new
+	{
+	local($l,$r,$tt,$lr)=@_;
+
+	&R_PERM_OP($l,$r,$tt, 4,"0xf0f0f0f0",$l);
+	&R_PERM_OP($r,$tt,$l,20,"0xfff0000f",$l);
+	&R_PERM_OP($l,$tt,$r,14,"0x33333333",$r);
+	&R_PERM_OP($tt,$r,$l,22,"0x03fc03fc",$r);
+	&R_PERM_OP($l,$r,$tt, 9,"0xaaaaaaaa",$r);
+	
+	if ($lr != 3)
+		{
+		if (($lr-3) < 0)
+			{ &rotr($tt,	3-$lr); }
+		else	{ &rotl($tt,	$lr-3); }
+		}
+	if ($lr != 2)
+		{
+		if (($lr-2) < 0)
+			{ &rotr($r,	2-$lr); }
+		else	{ &rotl($r,	$lr-2); }
+		}
+	}
+
+sub FP_new
+	{
+	local($l,$r,$tt,$lr)=@_;
+
+	if ($lr != 2)
+		{
+		if (($lr-2) < 0)
+			{ &rotl($r,	2-$lr); }
+		else	{ &rotr($r,	$lr-2); }
+		}
+	if ($lr != 3)
+		{
+		if (($lr-3) < 0)
+			{ &rotl($l,	3-$lr); }
+		else	{ &rotr($l,	$lr-3); }
+		}
+
+	&R_PERM_OP($l,$r,$tt, 0,"0xaaaaaaaa",$r);
+	&R_PERM_OP($tt,$r,$l,23,"0x03fc03fc",$r);
+	&R_PERM_OP($l,$r,$tt,10,"0x33333333",$l);
+	&R_PERM_OP($r,$tt,$l,18,"0xfff0000f",$l);
+	&R_PERM_OP($l,$tt,$r,12,"0xf0f0f0f0",$r);
+	&rotr($tt	, 4);
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/asm/des686.pl linux/net/ipsec/libdes/asm/des686.pl
--- linux-noipsec/net/ipsec/libdes/asm/des686.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/des686.pl	Thu Feb 18 17:41:32 1999
@@ -0,0 +1,230 @@
+#!/usr/local/bin/perl
+
+$prog="des686.pl";
+
+# base code is in microsft
+# op dest, source
+# format.
+#
+
+# WILL NOT WORK ANYMORE WITH desboth.pl
+require "desboth.pl";
+
+if (	($ARGV[0] eq "elf"))
+	{ require "x86unix.pl"; }
+elsif (	($ARGV[0] eq "a.out"))
+	{ $aout=1; require "x86unix.pl"; }
+elsif (	($ARGV[0] eq "sol"))
+	{ $sol=1; require "x86unix.pl"; }
+elsif ( ($ARGV[0] eq "cpp"))
+	{ $cpp=1; require "x86unix.pl"; }
+elsif (	($ARGV[0] eq "win32"))
+	{ require "x86ms.pl"; }
+else
+	{
+	print STDERR <<"EOF";
+Pick one target type from
+	elf	- linux, FreeBSD etc
+	a.out	- old linux
+	sol	- x86 solaris
+	cpp	- format so x86unix.cpp can be used
+	win32	- Windows 95/Windows NT
+EOF
+	exit(1);
+	}
+
+&comment("Don't even think of reading this code");
+&comment("It was automatically generated by $prog");
+&comment("Which is a perl program used to generate the x86 assember for");
+&comment("any of elf, a.out, Win32, or Solaris");
+&comment("It can be found in SSLeay 0.6.5+ or in libdes 3.26+");
+&comment("eric <eay\@cryptsoft.com>");
+&comment("");
+
+&file("dx86xxxx");
+
+$L="edi";
+$R="esi";
+
+&des_encrypt("des_encrypt",1);
+&des_encrypt("des_encrypt2",0);
+
+&des_encrypt3("des_encrypt3",1);
+&des_encrypt3("des_decrypt3",0);
+
+&file_end();
+
+sub des_encrypt
+	{
+	local($name,$do_ip)=@_;
+
+	&function_begin($name,"EXTRN   _des_SPtrans:DWORD");
+
+	&comment("");
+	&comment("Load the 2 words");
+	&mov("eax",&wparam(0));
+	&mov($L,&DWP(0,"eax","",0));
+	&mov($R,&DWP(4,"eax","",0));
+
+	$ksp=&wparam(1);
+
+	if ($do_ip)
+		{
+		&comment("");
+		&comment("IP");
+		&IP_new($L,$R,"eax");
+		}
+
+	&comment("");
+	&comment("fixup rotate");
+	&rotl($R,3);
+	&rotl($L,3);
+	&exch($L,$R);
+
+	&comment("");
+	&comment("load counter, key_schedule and enc flag");
+	&mov("eax",&wparam(2));	# get encrypt flag
+	&mov("ebp",&wparam(1));	# get ks
+	&cmp("eax","0");
+	&je(&label("start_decrypt"));
+
+	# encrypting part
+
+	for ($i=0; $i<16; $i+=2)
+		{
+		&comment("");
+		&comment("Round $i");
+		&D_ENCRYPT($L,$R,$i*2,"ebp","des_SPtrans","ecx","edx","eax","ebx");
+
+		&comment("");
+		&comment("Round ".sprintf("%d",$i+1));
+		&D_ENCRYPT($R,$L,($i+1)*2,"ebp","des_SPtrans","ecx","edx","eax","ebx");
+		}
+	&jmp(&label("end"));
+
+	&set_label("start_decrypt");
+
+	for ($i=15; $i>0; $i-=2)
+		{
+		&comment("");
+		&comment("Round $i");
+		&D_ENCRYPT($L,$R,$i*2,"ebp","des_SPtrans","ecx","edx","eax","ebx");
+		&comment("");
+		&comment("Round ".sprintf("%d",$i-1));
+		&D_ENCRYPT($R,$L,($i-1)*2,"ebp","des_SPtrans","ecx","edx","eax","ebx");
+		}
+
+	&set_label("end");
+
+	&comment("");
+	&comment("Fixup");
+	&rotr($L,3);		# r
+	&rotr($R,3);		# l
+
+	if ($do_ip)
+		{
+		&comment("");
+		&comment("FP");
+		&FP_new($R,$L,"eax");
+		}
+
+	&mov("eax",&wparam(0));
+	&mov(&DWP(0,"eax","",0),$L);
+	&mov(&DWP(4,"eax","",0),$R);
+
+	&function_end($name);
+	}
+
+
+# The logic is to load R into 2 registers and operate on both at the same time.
+# We also load the 2 R's into 2 more registers so we can do the 'move word down a byte'
+# while also masking the other copy and doing a lookup.  We then also accumulate the
+# L value in 2 registers then combine them at the end.
+sub D_ENCRYPT
+	{
+	local($L,$R,$S,$ks,$desSP,$u,$t,$tmp1,$tmp2,$tmp3)=@_;
+
+	&mov(	$u,		&DWP(&n2a($S*4),$ks,"",0));
+	&mov(	$t,		&DWP(&n2a(($S+1)*4),$ks,"",0));
+	&xor(	$u,		$R		);
+	&xor(	$t,		$R		);
+	&rotr(	$t,		4		);
+
+	# the numbers at the end of the line are origional instruction order
+	&mov(	$tmp2,		$u		);			# 1 2
+	&mov(	$tmp1,		$t		);			# 1 1
+	&and(	$tmp2,		"0xfc"		);			# 1 4
+	&and(	$tmp1,		"0xfc"		);			# 1 3
+	&shr(	$t,		8		);			# 1 5
+	&xor(	$L,		&DWP("0x100+$desSP",$tmp1,"",0));	# 1 7
+	&shr(	$u,		8		);			# 1 6
+	&mov(	$tmp1,		&DWP("      $desSP",$tmp2,"",0));	# 1 8
+
+	&mov(	$tmp2,		$u		);			# 2 2
+	&xor(	$L,		$tmp1		);			# 1 9
+	&and(	$tmp2,		"0xfc"		);			# 2 4
+	&mov(	$tmp1,		$t		);			# 2 1
+	&and(	$tmp1,		"0xfc"		);			# 2 3
+	&shr(	$t,		8		);			# 2 5
+	&xor(	$L,		&DWP("0x300+$desSP",$tmp1,"",0));	# 2 7
+	&shr(	$u,		8		);			# 2 6
+	&mov(	$tmp1,		&DWP("0x200+$desSP",$tmp2,"",0));	# 2 8
+	&mov(	$tmp2,		$u		);			# 3 2
+
+	&xor(	$L,		$tmp1		);			# 2 9
+	&and(	$tmp2,		"0xfc"		);			# 3 4
+
+	&mov(	$tmp1,		$t		);			# 3 1 
+	&shr(	$u,		8		);			# 3 6
+	&and(	$tmp1,		"0xfc"		);			# 3 3
+	&shr(	$t,		8		);			# 3 5
+	&xor(	$L,		&DWP("0x500+$desSP",$tmp1,"",0));	# 3 7
+	&mov(	$tmp1,		&DWP("0x400+$desSP",$tmp2,"",0));	# 3 8
+
+	&and(	$t,		"0xfc"		);			# 4 1
+	&xor(	$L,		$tmp1		);			# 3 9
+
+	&and(	$u,		"0xfc"		);			# 4 2
+	&xor(	$L,		&DWP("0x700+$desSP",$t,"",0));		# 4 3
+	&xor(	$L,		&DWP("0x600+$desSP",$u,"",0));		# 4 4
+	}
+
+sub PERM_OP
+	{
+	local($a,$b,$tt,$shift,$mask)=@_;
+
+	&mov(	$tt,		$a		);
+	&shr(	$tt,		$shift		);
+	&xor(	$tt,		$b		);
+	&and(	$tt,		$mask		);
+	&xor(	$b,		$tt		);
+	&shl(	$tt,		$shift		);
+	&xor(	$a,		$tt		);
+	}
+
+sub IP_new
+	{
+	local($l,$r,$tt)=@_;
+
+	&PERM_OP($r,$l,$tt, 4,"0x0f0f0f0f");
+	&PERM_OP($l,$r,$tt,16,"0x0000ffff");
+	&PERM_OP($r,$l,$tt, 2,"0x33333333");
+	&PERM_OP($l,$r,$tt, 8,"0x00ff00ff");
+	&PERM_OP($r,$l,$tt, 1,"0x55555555");
+	}
+
+sub FP_new
+	{
+	local($l,$r,$tt)=@_;
+
+	&PERM_OP($l,$r,$tt, 1,"0x55555555");
+        &PERM_OP($r,$l,$tt, 8,"0x00ff00ff");
+        &PERM_OP($l,$r,$tt, 2,"0x33333333");
+        &PERM_OP($r,$l,$tt,16,"0x0000ffff");
+        &PERM_OP($l,$r,$tt, 4,"0x0f0f0f0f");
+	}
+
+sub n2a
+	{
+	sprintf("%d",$_[0]);
+	}
diff -druN linux-noipsec/net/ipsec/libdes/asm/desboth.pl linux/net/ipsec/libdes/asm/desboth.pl
--- linux-noipsec/net/ipsec/libdes/asm/desboth.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/desboth.pl	Thu Feb 18 17:41:32 1999
@@ -0,0 +1,79 @@
+#!/usr/local/bin/perl
+
+$L="edi";
+$R="esi";
+
+sub des_encrypt3
+	{
+	local($name,$enc)=@_;
+
+	&function_begin_B($name,"");
+	&push("ebx");
+	&mov("ebx",&wparam(0));
+
+	&push("ebp");
+	&push("esi");
+
+	&push("edi");
+
+	&comment("");
+	&comment("Load the data words");
+	&mov($L,&DWP(0,"ebx","",0));
+	&mov($R,&DWP(4,"ebx","",0));
+	&stack_push(3);
+
+	&comment("");
+	&comment("IP");
+	&IP_new($L,$R,"edx",0);
+
+	# put them back
+	
+	if ($enc)
+		{
+		&mov(&DWP(4,"ebx","",0),$R);
+		 &mov("eax",&wparam(1));
+		&mov(&DWP(0,"ebx","",0),"edx");
+		 &mov("edi",&wparam(2));
+		 &mov("esi",&wparam(3));
+		}
+	else
+		{
+		&mov(&DWP(4,"ebx","",0),$R);
+		 &mov("esi",&wparam(1));
+		&mov(&DWP(0,"ebx","",0),"edx");
+		 &mov("edi",&wparam(2));
+		 &mov("eax",&wparam(3));
+		}
+	&mov(&swtmp(2),	(($enc)?"1":"0"));
+	&mov(&swtmp(1),	"eax");
+	&mov(&swtmp(0),	"ebx");
+	&call("des_encrypt2");
+	&mov(&swtmp(2),	(($enc)?"0":"1"));
+	&mov(&swtmp(1),	"edi");
+	&mov(&swtmp(0),	"ebx");
+	&call("des_encrypt2");
+	&mov(&swtmp(2),	(($enc)?"1":"0"));
+	&mov(&swtmp(1),	"esi");
+	&mov(&swtmp(0),	"ebx");
+	&call("des_encrypt2");
+
+	&stack_pop(3);
+	&mov($L,&DWP(0,"ebx","",0));
+	&mov($R,&DWP(4,"ebx","",0));
+
+	&comment("");
+	&comment("FP");
+	&FP_new($L,$R,"eax",0);
+
+	&mov(&DWP(0,"ebx","",0),"eax");
+	&mov(&DWP(4,"ebx","",0),$R);
+
+	&pop("edi");
+	&pop("esi");
+	&pop("ebp");
+	&pop("ebx");
+	&ret();
+	&function_end_B($name);
+	}
+
+
diff -druN linux-noipsec/net/ipsec/libdes/asm/perlasm/cbc.pl linux/net/ipsec/libdes/asm/perlasm/cbc.pl
--- linux-noipsec/net/ipsec/libdes/asm/perlasm/cbc.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/perlasm/cbc.pl	Thu Feb 18 17:41:34 1999
@@ -0,0 +1,342 @@
+#!/usr/local/bin/perl
+
+# void des_ncbc_encrypt(input, output, length, schedule, ivec, enc)
+# des_cblock (*input);
+# des_cblock (*output);
+# long length;
+# des_key_schedule schedule;
+# des_cblock (*ivec);
+# int enc;
+#
+# calls 
+# des_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);
+#
+
+#&cbc("des_ncbc_encrypt","des_encrypt",0);
+#&cbc("BF_cbc_encrypt","BF_encrypt","BF_encrypt",
+#	1,4,5,3,5,-1);
+#&cbc("des_ncbc_encrypt","des_encrypt","des_encrypt",
+#	0,4,5,3,5,-1);
+#&cbc("des_ede3_cbc_encrypt","des_encrypt3","des_decrypt3",
+#	0,6,7,3,4,5);
+#
+# When doing a cipher that needs bigendian order,
+# for encrypt, the iv is kept in bigendian form,
+# while for decrypt, it is kept in little endian.
+sub cbc
+	{
+	local($name,$enc_func,$dec_func,$swap,$iv_off,$enc_off,$p1,$p2,$p3)=@_;
+	# name is the function name
+	# enc_func and dec_func and the functions to call for encrypt/decrypt
+	# swap is true if byte order needs to be reversed
+	# iv_off is parameter number for the iv 
+	# enc_off is parameter number for the encrypt/decrypt flag
+	# p1,p2,p3 are the offsets for parameters to be passed to the
+	# underlying calls.
+
+	&function_begin_B($name,"");
+	&comment("");
+
+	$in="esi";
+	$out="edi";
+	$count="ebp";
+
+	&push("ebp");
+	&push("ebx");
+	&push("esi");
+	&push("edi");
+
+	$data_off=4;
+	$data_off+=4 if ($p1 > 0);
+	$data_off+=4 if ($p2 > 0);
+	$data_off+=4 if ($p3 > 0);
+
+	&mov($count,	&wparam(2));	# length
+
+	&comment("getting iv ptr from parameter $iv_off");
+	&mov("ebx",	&wparam($iv_off));	# Get iv ptr
+
+	&mov($in,	&DWP(0,"ebx","",0));#	iv[0]
+	&mov($out,	&DWP(4,"ebx","",0));#	iv[1]
+
+	&push($out);
+	&push($in);
+	&push($out);	# used in decrypt for iv[1]
+	&push($in);	# used in decrypt for iv[0]
+
+	&mov("ebx",	"esp");		# This is the address of tin[2]
+
+	&mov($in,	&wparam(0));	# in
+	&mov($out,	&wparam(1));	# out
+
+	# We have loaded them all, how lets push things
+	&comment("getting encrypt flag from parameter $enc_off");
+	&mov("ecx",	&wparam($enc_off));	# Get enc flag
+	if ($p3 > 0)
+		{
+		&comment("get and push parameter $p3");
+		if ($enc_off != $p3)
+			{ &mov("eax",	&wparam($p3)); &push("eax"); }
+		else	{ &push("ecx"); }
+		}
+	if ($p2 > 0)
+		{
+		&comment("get and push parameter $p2");
+		if ($enc_off != $p2)
+			{ &mov("eax",	&wparam($p2)); &push("eax"); }
+		else	{ &push("ecx"); }
+		}
+	if ($p1 > 0)
+		{
+		&comment("get and push parameter $p1");
+		if ($enc_off != $p1)
+			{ &mov("eax",	&wparam($p1)); &push("eax"); }
+		else	{ &push("ecx"); }
+		}
+	&push("ebx");		# push data/iv
+
+	&cmp("ecx",0);
+	&jz(&label("decrypt"));
+
+	&and($count,0xfffffff8);
+	&mov("eax",	&DWP($data_off,"esp","",0));	# load iv[0]
+	&mov("ebx",	&DWP($data_off+4,"esp","",0));	# load iv[1]
+
+	&jz(&label("encrypt_finish"));
+
+	#############################################################
+
+	&set_label("encrypt_loop");
+	# encrypt start 
+	# "eax" and "ebx" hold iv (or the last cipher text)
+
+	&mov("ecx",	&DWP(0,$in,"",0));	# load first 4 bytes
+	&mov("edx",	&DWP(4,$in,"",0));	# second 4 bytes
+
+	&xor("eax",	"ecx");
+	&xor("ebx",	"edx");
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP($data_off,"esp","",0),	"eax");	# put in array for call
+	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
+
+	&call($enc_func);
+
+	&mov("eax",	&DWP($data_off,"esp","",0));
+	&mov("ebx",	&DWP($data_off+4,"esp","",0));
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP(0,$out,"",0),"eax");
+	&mov(&DWP(4,$out,"",0),"ebx");
+
+	# eax and ebx are the next iv.
+
+	&add($in,	8);
+	&add($out,	8);
+
+	&sub($count,	8);
+	&jnz(&label("encrypt_loop"));
+
+###################################################################3
+	&set_label("encrypt_finish");
+	&mov($count,	&wparam(2));	# length
+	&and($count,	7);
+	&jz(&label("finish"));
+	&xor("ecx","ecx");
+	&xor("edx","edx");
+	&mov($count,&DWP(&label("cbc_enc_jmp_table"),"",$count,4));
+	&jmp_ptr($count);
+
+&set_label("ej7");
+	&xor("edx",		"edx") if $ppro; # ppro friendly
+	&movb(&HB("edx"),	&BP(6,$in,"",0));
+	&shl("edx",8);
+&set_label("ej6");
+	&movb(&HB("edx"),	&BP(5,$in,"",0));
+&set_label("ej5");
+	&movb(&LB("edx"),	&BP(4,$in,"",0));
+&set_label("ej4");
+	&mov("ecx",		&DWP(0,$in,"",0));
+	&jmp(&label("ejend"));
+&set_label("ej3");
+	&movb(&HB("ecx"),	&BP(2,$in,"",0));
+	&xor("ecx",		"ecx") if $ppro; # ppro friendly
+	&shl("ecx",8);
+&set_label("ej2");
+	&movb(&HB("ecx"),	&BP(1,$in,"",0));
+&set_label("ej1");
+	&movb(&LB("ecx"),	&BP(0,$in,"",0));
+&set_label("ejend");
+
+	&xor("eax",	"ecx");
+	&xor("ebx",	"edx");
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP($data_off,"esp","",0),	"eax");	# put in array for call
+	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
+
+	&call($enc_func);
+
+	&mov("eax",	&DWP($data_off,"esp","",0));
+	&mov("ebx",	&DWP($data_off+4,"esp","",0));
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP(0,$out,"",0),"eax");
+	&mov(&DWP(4,$out,"",0),"ebx");
+
+	&jmp(&label("finish"));
+
+	#############################################################
+	#############################################################
+	&set_label("decrypt",1);
+	# decrypt start 
+	&and($count,0xfffffff8);
+	# The next 2 instructions are only for if the jz is taken
+	&mov("eax",	&DWP($data_off+8,"esp","",0));	# get iv[0]
+	&mov("ebx",	&DWP($data_off+12,"esp","",0));	# get iv[1]
+	&jz(&label("decrypt_finish"));
+
+	&set_label("decrypt_loop");
+	&mov("eax",	&DWP(0,$in,"",0));	# load first 4 bytes
+	&mov("ebx",	&DWP(4,$in,"",0));	# second 4 bytes
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP($data_off,"esp","",0),	"eax");	# put back
+	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
+
+	&call($dec_func);
+
+	&mov("eax",	&DWP($data_off,"esp","",0));	# get return
+	&mov("ebx",	&DWP($data_off+4,"esp","",0));	#
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov("ecx",	&DWP($data_off+8,"esp","",0));	# get iv[0]
+	&mov("edx",	&DWP($data_off+12,"esp","",0));	# get iv[1]
+
+	&xor("ecx",	"eax");
+	&xor("edx",	"ebx");
+
+	&mov("eax",	&DWP(0,$in,"",0));	# get old cipher text,
+	&mov("ebx",	&DWP(4,$in,"",0));	# next iv actually
+
+	&mov(&DWP(0,$out,"",0),"ecx");
+	&mov(&DWP(4,$out,"",0),"edx");
+
+	&mov(&DWP($data_off+8,"esp","",0),	"eax");	# save iv
+	&mov(&DWP($data_off+12,"esp","",0),	"ebx");	#
+
+	&add($in,	8);
+	&add($out,	8);
+
+	&sub($count,	8);
+	&jnz(&label("decrypt_loop"));
+############################ ENDIT #######################3
+	&set_label("decrypt_finish");
+	&mov($count,	&wparam(2));	# length
+	&and($count,	7);
+	&jz(&label("finish"));
+
+	&mov("eax",	&DWP(0,$in,"",0));	# load first 4 bytes
+	&mov("ebx",	&DWP(4,$in,"",0));	# second 4 bytes
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov(&DWP($data_off,"esp","",0),	"eax");	# put back
+	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
+
+	&call($dec_func);
+
+	&mov("eax",	&DWP($data_off,"esp","",0));	# get return
+	&mov("ebx",	&DWP($data_off+4,"esp","",0));	#
+
+	&bswap("eax")	if $swap;
+	&bswap("ebx")	if $swap;
+
+	&mov("ecx",	&DWP($data_off+8,"esp","",0));	# get iv[0]
+	&mov("edx",	&DWP($data_off+12,"esp","",0));	# get iv[1]
+
+	&xor("ecx",	"eax");
+	&xor("edx",	"ebx");
+
+	# this is for when we exit
+	&mov("eax",	&DWP(0,$in,"",0));	# get old cipher text,
+	&mov("ebx",	&DWP(4,$in,"",0));	# next iv actually
+
+&set_label("dj7");
+	&rotr("edx",	16);
+	&movb(&BP(6,$out,"",0),	&LB("edx"));
+	&shr("edx",16);
+&set_label("dj6");
+	&movb(&BP(5,$out,"",0),	&HB("edx"));
+&set_label("dj5");
+	&movb(&BP(4,$out,"",0),	&LB("edx"));
+&set_label("dj4");
+	&mov(&DWP(0,$out,"",0),	"ecx");
+	&jmp(&label("djend"));
+&set_label("dj3");
+	&rotr("ecx",	16);
+	&movb(&BP(2,$out,"",0),	&LB("ecx"));
+	&shl("ecx",16);
+&set_label("dj2");
+	&movb(&BP(1,$in,"",0),	&HB("ecx"));
+&set_label("dj1");
+	&movb(&BP(0,$in,"",0),	&LB("ecx"));
+&set_label("djend");
+
+	# final iv is still in eax:ebx
+	&jmp(&label("finish"));
+
+
+############################ FINISH #######################3
+	&set_label("finish",1);
+	&mov("ecx",	&wparam($iv_off));	# Get iv ptr
+
+	#################################################
+	$total=16+4;
+	$total+=4 if ($p1 > 0);
+	$total+=4 if ($p2 > 0);
+	$total+=4 if ($p3 > 0);
+	&add("esp",$total);
+
+	&mov(&DWP(0,"ecx","",0),	"eax");	# save iv
+	&mov(&DWP(4,"ecx","",0),	"ebx");	# save iv
+
+	&function_end_A($name);
+
+	&set_label("cbc_enc_jmp_table",1);
+	&data_word("0");
+	&data_word(&label("ej1"));
+	&data_word(&label("ej2"));
+	&data_word(&label("ej3"));
+	&data_word(&label("ej4"));
+	&data_word(&label("ej5"));
+	&data_word(&label("ej6"));
+	&data_word(&label("ej7"));
+	&set_label("cbc_dec_jmp_table",1);
+	&data_word("0");
+	&data_word(&label("dj1"));
+	&data_word(&label("dj2"));
+	&data_word(&label("dj3"));
+	&data_word(&label("dj4"));
+	&data_word(&label("dj5"));
+	&data_word(&label("dj6"));
+	&data_word(&label("dj7"));
+
+	&function_end_B($name);
+	
+	}
+
+1;
diff -druN linux-noipsec/net/ipsec/libdes/asm/perlasm/readme linux/net/ipsec/libdes/asm/perlasm/readme
--- linux-noipsec/net/ipsec/libdes/asm/perlasm/readme	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/perlasm/readme	Thu Feb 18 17:41:35 1999
@@ -0,0 +1,124 @@
+The perl scripts in this directory are my 'hack' to generate
+multiple different assembler formats via the one origional script.
+
+The way to use this library is to start with adding the path to this directory
+and then include it.
+
+push(@INC,"perlasm","../../perlasm");
+require "x86asm.pl";
+
+The first thing we do is setup the file and type of assember
+
+&asm_init($ARGV[0],$0);
+
+The first argument is the 'type'.  Currently
+'cpp', 'sol', 'a.out', 'elf' or 'win32'.
+Argument 2 is the file name.
+
+The reciprocal function is
+&asm_finish() which should be called at the end.
+
+There are 2 main 'packages'. x86ms.pl, which is the microsoft assembler,
+and x86unix.pl which is the unix (gas) version.
+
+Functions of interest are:
+&external_label("des_SPtrans");	declare and external variable
+&LB(reg);			Low byte for a register
+&HB(reg);			High byte for a register
+&BP(off,base,index,scale)	Byte pointer addressing
+&DWP(off,base,index,scale)	Word pointer addressing
+&stack_push(num)		Basically a 'sub esp, num*4' with extra
+&stack_pop(num)			inverse of stack_push
+&function_begin(name,extra)	Start a function with pushing of
+				edi, esi, ebx and ebp.  extra is extra win32
+				external info that may be required.
+&function_begin_B(name,extra)	Same as norma function_begin but no pushing.
+&function_end(name)		Call at end of function.
+&function_end_A(name)		Standard pop and ret, for use inside functions
+&function_end_B(name)		Call at end but with poping or 'ret'.
+&swtmp(num)			Address on stack temp word.
+&wparam(num)			Parameter number num, that was push
+				in C convention.  This all works over pushes
+				and pops.
+&comment("hello there")		Put in a comment.
+&label("loop")			Refer to a label, normally a jmp target.
+&set_label("loop")		Set a label at this point.
+&data_word(word)		Put in a word of data.
+
+So how does this all hold together?  Given
+
+int calc(int len, int *data)
+	{
+	int i,j=0;
+
+	for (i=0; i<len; i++)
+		{
+		j+=other(data[i]);
+		}
+	}
+
+So a very simple version of this function could be coded as
+
+	push(@INC,"perlasm","../../perlasm");
+	require "x86asm.pl";
+	
+	&asm_init($ARGV[0],"cacl.pl");
+
+	&external_label("other");
+
+	$tmp1=	"eax";
+	$j=	"edi";
+	$data=	"esi";
+	$i=	"ebp";
+
+	&comment("a simple function");
+	&function_begin("calc");
+	&mov(	$data,		&wparam(1)); # data
+	&xor(	$j,		$j);
+	&xor(	$i,		$i);
+
+	&set_label("loop");
+	&cmp(	$i,		&wparam(0));
+	&jge(	&label("end"));
+
+	&mov(	$tmp1,		&DWP(0,$data,$i,4));
+	&push(	$tmp1);
+	&call(	"other");
+	&add(	$j,		"eax");
+	&pop(	$tmp1);
+	&inc(	$i);
+	&jmp(	&label("loop"));
+
+	&set_label("end");
+	&mov(	"eax",		$j);
+
+	&function_end("calc");
+
+	&asm_finish();
+
+The above example is very very unoptimised but gives an idea of how
+things work.
+
+There is also a cbc mode function generator in cbc.pl
+
+&cbc(	$name,
+	$encrypt_function_name,
+	$decrypt_function_name,
+	$true_if_byte_swap_needed,
+	$parameter_number_for_iv,
+	$parameter_number_for_encrypt_flag,
+	$first_parameter_to_pass,
+	$second_parameter_to_pass,
+	$third_parameter_to_pass);
+
+So for example, given
+void BF_encrypt(BF_LONG *data,BF_KEY *key);
+void BF_decrypt(BF_LONG *data,BF_KEY *key);
+void BF_cbc_encrypt(unsigned char *in, unsigned char *out, long length,
+        BF_KEY *ks, unsigned char *iv, int enc);
+
+&cbc("BF_cbc_encrypt","BF_encrypt","BF_encrypt",1,4,5,3,-1,-1);
+
+&cbc("des_ncbc_encrypt","des_encrypt","des_encrypt",0,4,5,3,5,-1);
+&cbc("des_ede3_cbc_encrypt","des_encrypt3","des_decrypt3",0,6,7,3,4,5);
+
diff -druN linux-noipsec/net/ipsec/libdes/asm/perlasm/x86asm.pl linux/net/ipsec/libdes/asm/perlasm/x86asm.pl
--- linux-noipsec/net/ipsec/libdes/asm/perlasm/x86asm.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/perlasm/x86asm.pl	Thu Feb 18 17:41:35 1999
@@ -0,0 +1,111 @@
+#!/usr/local/bin/perl
+
+# require 'x86asm.pl';
+# &asm_init("cpp","des-586.pl");
+# XXX
+# XXX
+# main'asm_finish
+
+sub main'asm_finish
+	{
+	&file_end();
+	&asm_finish_cpp() if $cpp;
+	print &asm_get_output();
+	}
+
+sub main'asm_init
+	{
+	($type,$fn)=@_;
+	$filename=$fn;
+
+	$cpp=$sol=$aout=$win32=0;
+	if (	($type eq "elf"))
+		{ require "x86unix.pl"; }
+	elsif (	($type eq "a.out"))
+		{ $aout=1; require "x86unix.pl"; }
+	elsif (	($type eq "sol"))
+		{ $sol=1; require "x86unix.pl"; }
+	elsif (	($type eq "cpp"))
+		{ $cpp=1; require "x86unix.pl"; }
+	elsif (	($type eq "win32"))
+		{ $win32=1; require "x86ms.pl"; }
+	else
+		{
+		print STDERR <<"EOF";
+Pick one target type from
+	elf	- linux, FreeBSD etc
+	a.out	- old linux
+	sol	- x86 solaris
+	cpp	- format so x86unix.cpp can be used
+	win32	- Windows 95/Windows NT
+EOF
+		exit(1);
+		}
+
+	&asm_init_output();
+
+&comment("Don't even think of reading this code");
+&comment("It was automatically generated by $filename");
+&comment("Which is a perl program used to generate the x86 assember for");
+&comment("any of elf, a.out, BSDI,Win32, or Solaris");
+&comment("eric <eay\@cryptsoft.com>");
+&comment("");
+
+	$filename =~ s/\.pl$//;
+	&file($filename);
+	}
+
+sub asm_finish_cpp
+	{
+	return unless $cpp;
+
+	local($tmp,$i);
+	foreach $i (&get_labels())
+		{
+		$tmp.="#define $i _$i\n";
+		}
+	print <<"EOF";
+/* Run the C pre-processor over this file with one of the following defined
+ * ELF - elf object files,
+ * OUT - a.out object files,
+ * BSDI - BSDI style a.out object files
+ * SOL - Solaris style elf
+ */
+
+#define TYPE(a,b)       .type   a,b
+#define SIZE(a,b)       .size   a,b
+
+#if defined(OUT) || defined(BSDI)
+$tmp
+#endif
+
+#ifdef OUT
+#define OK	1
+#define ALIGN	4
+#endif
+
+#ifdef BSDI
+#define OK              1
+#define ALIGN           4
+#undef SIZE
+#undef TYPE
+#endif
+
+#if defined(ELF) || defined(SOL)
+#define OK              1
+#define ALIGN           16
+#endif
+
+#ifndef OK
+You need to define one of
+ELF - elf systems - linux-elf, NetBSD and DG-UX
+OUT - a.out systems - linux-a.out and FreeBSD
+SOL - solaris systems, which are elf with strange comment lines
+BSDI - a.out with a very primative version of as.
+#endif
+
+/* Let the Assembler begin :-) */
+EOF
+	}
+
+1;
diff -druN linux-noipsec/net/ipsec/libdes/asm/perlasm/x86ms.pl linux/net/ipsec/libdes/asm/perlasm/x86ms.pl
--- linux-noipsec/net/ipsec/libdes/asm/perlasm/x86ms.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/perlasm/x86ms.pl	Thu Feb 18 17:41:35 1999
@@ -0,0 +1,345 @@
+#!/usr/local/bin/perl
+
+package x86ms;
+
+$label="L000";
+
+%lb=(	'eax',	'al',
+	'ebx',	'bl',
+	'ecx',	'cl',
+	'edx',	'dl',
+	'ax',	'al',
+	'bx',	'bl',
+	'cx',	'cl',
+	'dx',	'dl',
+	);
+
+%hb=(	'eax',	'ah',
+	'ebx',	'bh',
+	'ecx',	'ch',
+	'edx',	'dh',
+	'ax',	'ah',
+	'bx',	'bh',
+	'cx',	'ch',
+	'dx',	'dh',
+	);
+
+sub main'asm_init_output { @out=(); }
+sub main'asm_get_output { return(@out); }
+sub main'get_labels { return(@labels); }
+sub main'external_label { push(@labels,@_); }
+
+sub main'LB
+	{
+	(defined($lb{$_[0]})) || die "$_[0] does not have a 'low byte'\n";
+	return($lb{$_[0]});
+	}
+
+sub main'HB
+	{
+	(defined($hb{$_[0]})) || die "$_[0] does not have a 'high byte'\n";
+	return($hb{$_[0]});
+	}
+
+sub main'BP
+	{
+	&get_mem("BYTE",@_);
+	}
+
+sub main'DWP
+	{
+	&get_mem("DWORD",@_);
+	}
+
+sub main'stack_push
+	{
+	local($num)=@_;
+	$stack+=$num*4;
+	&main'sub("esp",$num*4);
+	}
+
+sub main'stack_pop
+	{
+	local($num)=@_;
+	$stack-=$num*4;
+	&main'add("esp",$num*4);
+	}
+
+sub get_mem
+	{
+	local($size,$addr,$reg1,$reg2,$idx)=@_;
+	local($t,$post);
+	local($ret)="$size PTR ";
+
+	$addr =~ s/^\s+//;
+	if ($addr =~ /^(.+)\+(.+)$/)
+		{
+		$reg2=&conv($1);
+		$addr="_$2";
+		}
+	elsif ($addr =~ /^[_a-zA-Z]/)
+		{
+		$addr="_$addr";
+		}
+
+	$reg1="$regs{$reg1}" if defined($regs{$reg1});
+	$reg2="$regs{$reg2}" if defined($regs{$reg2});
+	if (($addr ne "") && ($addr ne 0))
+		{
+		if ($addr !~ /^-/)
+			{ $ret.=$addr; }
+		else	{ $post=$addr; }
+		}
+	if ($reg2 ne "")
+		{
+		$t="";
+		$t="*$idx" if ($idx != 0);
+		$reg1="+".$reg1 if ("$reg1$post" ne "");
+		$ret.="[$reg2$t$reg1$post]";
+		}
+	else
+		{
+		$ret.="[$reg1$post]"
+		}
+	return($ret);
+	}
+
+sub main'mov	{ &out2("mov",@_); }
+sub main'movb	{ &out2("mov",@_); }
+sub main'and	{ &out2("and",@_); }
+sub main'or	{ &out2("or",@_); }
+sub main'shl	{ &out2("shl",@_); }
+sub main'shr	{ &out2("shr",@_); }
+sub main'xor	{ &out2("xor",@_); }
+sub main'xorb	{ &out2("xor",@_); }
+sub main'add	{ &out2("add",@_); }
+sub main'adc	{ &out2("adc",@_); }
+sub main'sub	{ &out2("sub",@_); }
+sub main'rotl	{ &out2("rol",@_); }
+sub main'rotr	{ &out2("ror",@_); }
+sub main'exch	{ &out2("xchg",@_); }
+sub main'cmp	{ &out2("cmp",@_); }
+sub main'lea	{ &out2("lea",@_); }
+sub main'mul	{ &out1("mul",@_); }
+sub main'div	{ &out1("div",@_); }
+sub main'dec	{ &out1("dec",@_); }
+sub main'inc	{ &out1("inc",@_); }
+sub main'jmp	{ &out1("jmp",@_); }
+sub main'jmp_ptr { &out1p("jmp",@_); }
+sub main'je	{ &out1("je",@_); }
+sub main'jle	{ &out1("jle",@_); }
+sub main'jz	{ &out1("jz",@_); }
+sub main'jge	{ &out1("jge",@_); }
+sub main'jl	{ &out1("jl",@_); }
+sub main'jb	{ &out1("jb",@_); }
+sub main'jnz	{ &out1("jnz",@_); }
+sub main'jne	{ &out1("jne",@_); }
+sub main'push	{ &out1("push",@_); $stack+=4; }
+sub main'pop	{ &out1("pop",@_); $stack-=4; }
+sub main'bswap	{ &out1("bswap",@_); &using486(); }
+sub main'not	{ &out1("not",@_); }
+sub main'call	{ &out1("call",'_'.$_[0]); }
+sub main'ret	{ &out0("ret"); }
+sub main'nop	{ &out0("nop"); }
+
+sub out2
+	{
+	local($name,$p1,$p2)=@_;
+	local($l,$t);
+
+	push(@out,"\t$name\t");
+	$t=&conv($p1).",";
+	$l=length($t);
+	push(@out,$t);
+	$l=4-($l+9)/8;
+	push(@out,"\t" x $l);
+	push(@out,&conv($p2));
+	push(@out,"\n");
+	}
+
+sub out0
+	{
+	local($name)=@_;
+
+	push(@out,"\t$name\n");
+	}
+
+sub out1
+	{
+	local($name,$p1)=@_;
+	local($l,$t);
+
+	push(@out,"\t$name\t".&conv($p1)."\n");
+	}
+
+sub conv
+	{
+	local($p)=@_;
+
+	$p =~ s/0x([0-9A-Fa-f]+)/0$1h/;
+	return $p;
+	}
+
+sub using486
+	{
+	return if $using486;
+	$using486++;
+	grep(s/\.386/\.486/,@out);
+	}
+
+sub main'file
+	{
+	local($file)=@_;
+
+	local($tmp)=<<"EOF";
+	TITLE	$file.asm
+        .386
+.model FLAT
+EOF
+	push(@out,$tmp);
+	}
+
+sub main'function_begin
+	{
+	local($func,$extra)=@_;
+
+	push(@labels,$func);
+
+	local($tmp)=<<"EOF";
+_TEXT	SEGMENT
+PUBLIC	_$func
+$extra
+_$func PROC NEAR
+	push	ebp
+	push	ebx
+	push	esi
+	push	edi
+EOF
+	push(@out,$tmp);
+	$stack=20;
+	}
+
+sub main'function_begin_B
+	{
+	local($func,$extra)=@_;
+
+	local($tmp)=<<"EOF";
+_TEXT	SEGMENT
+PUBLIC	_$func
+$extra
+_$func PROC NEAR
+EOF
+	push(@out,$tmp);
+	$stack=4;
+	}
+
+sub main'function_end
+	{
+	local($func)=@_;
+
+	local($tmp)=<<"EOF";
+	pop	edi
+	pop	esi
+	pop	ebx
+	pop	ebp
+	ret
+_$func ENDP
+_TEXT	ENDS
+EOF
+	push(@out,$tmp);
+	$stack=0;
+	%label=();
+	}
+
+sub main'function_end_B
+	{
+	local($func)=@_;
+
+	local($tmp)=<<"EOF";
+_$func ENDP
+_TEXT	ENDS
+EOF
+	push(@out,$tmp);
+	$stack=0;
+	%label=();
+	}
+
+sub main'function_end_A
+	{
+	local($func)=@_;
+
+	local($tmp)=<<"EOF";
+	pop	edi
+	pop	esi
+	pop	ebx
+	pop	ebp
+	ret
+EOF
+	push(@out,$tmp);
+	}
+
+sub main'file_end
+	{
+	push(@out,"END\n");
+	}
+
+sub main'wparam
+	{
+	local($num)=@_;
+
+	return(&main'DWP($stack+$num*4,"esp","",0));
+	}
+
+sub main'swtmp
+	{
+	return(&main'DWP($_[0]*4,"esp","",0));
+	}
+
+# Should use swtmp, which is above esp.  Linix can trash the stack above esp
+#sub main'wtmp
+#	{
+#	local($num)=@_;
+#
+#	return(&main'DWP(-(($num+1)*4),"esp","",0));
+#	}
+
+sub main'comment
+	{
+	foreach (@_)
+		{
+		push(@out,"\t; $_\n");
+		}
+	}
+
+sub main'label
+	{
+	if (!defined($label{$_[0]}))
+		{
+		$label{$_[0]}="\$${label}${_[0]}";
+		$label++;
+		}
+	return($label{$_[0]});
+	}
+
+sub main'set_label
+	{
+	if (!defined($label{$_[0]}))
+		{
+		$label{$_[0]}="${label}${_[0]}";
+		$label++;
+		}
+	push(@out,"$label{$_[0]}:\n");
+	}
+
+sub main'data_word
+	{
+	push(@out,"\tDD\t$_[0]\n");
+	}
+
+sub out1p
+	{
+	local($name,$p1)=@_;
+	local($l,$t);
+
+	push(@out,"\t$name\t ".&conv($p1)."\n");
+	}
diff -druN linux-noipsec/net/ipsec/libdes/asm/perlasm/x86unix.pl linux/net/ipsec/libdes/asm/perlasm/x86unix.pl
--- linux-noipsec/net/ipsec/libdes/asm/perlasm/x86unix.pl	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/asm/perlasm/x86unix.pl	Thu Feb 18 17:41:36 1999
@@ -0,0 +1,403 @@
+#!/usr/local/bin/perl
+
+package x86unix;
+
+$label="L000";
+
+$align=($main'aout)?"4":"16";
+$under=($main'aout)?"_":"";
+$com_start=($main'sol)?"/":"#";
+
+sub main'asm_init_output { @out=(); }
+sub main'asm_get_output { return(@out); }
+sub main'get_labels { return(@labels); }
+sub main'external_label { push(@labels,@_); }
+
+if ($main'cpp)
+	{
+	$align="ALIGN";
+	$under="";
+	$com_start='/*';
+	$com_end='*/';
+	}
+
+%lb=(	'eax',	'%al',
+	'ebx',	'%bl',
+	'ecx',	'%cl',
+	'edx',	'%dl',
+	'ax',	'%al',
+	'bx',	'%bl',
+	'cx',	'%cl',
+	'dx',	'%dl',
+	);
+
+%hb=(	'eax',	'%ah',
+	'ebx',	'%bh',
+	'ecx',	'%ch',
+	'edx',	'%dh',
+	'ax',	'%ah',
+	'bx',	'%bh',
+	'cx',	'%ch',
+	'dx',	'%dh',
+	);
+
+%regs=(	'eax',	'%eax',
+	'ebx',	'%ebx',
+	'ecx',	'%ecx',
+	'edx',	'%edx',
+	'esi',	'%esi',
+	'edi',	'%edi',
+	'ebp',	'%ebp',
+	'esp',	'%esp',
+	);
+
+%reg_val=(
+	'eax',	0x00,
+	'ebx',	0x03,
+	'ecx',	0x01,
+	'edx',	0x02,
+	'esi',	0x06,
+	'edi',	0x07,
+	'ebp',	0x05,
+	'esp',	0x04,
+	);
+
+sub main'LB
+	{
+	(defined($lb{$_[0]})) || die "$_[0] does not have a 'low byte'\n";
+	return($lb{$_[0]});
+	}
+
+sub main'HB
+	{
+	(defined($hb{$_[0]})) || die "$_[0] does not have a 'high byte'\n";
+	return($hb{$_[0]});
+	}
+
+sub main'DWP
+	{
+	local($addr,$reg1,$reg2,$idx)=@_;
+
+	$ret="";
+	$addr =~ s/(^|[+ \t])([A-Za-z_]+)($|[+ \t])/$1$under$2$3/;
+	$reg1="$regs{$reg1}" if defined($regs{$reg1});
+	$reg2="$regs{$reg2}" if defined($regs{$reg2});
+	$ret.=$addr if ($addr ne "") && ($addr ne 0);
+	if ($reg2 ne "")
+		{ $ret.="($reg1,$reg2,$idx)"; }
+	else
+		{ $ret.="($reg1)" }
+	return($ret);
+	}
+
+sub main'BP
+	{
+	return(&main'DWP(@_));
+	}
+
+#sub main'BP
+#	{
+#	local($addr,$reg1,$reg2,$idx)=@_;
+#
+#	$ret="";
+#
+#	$addr =~ s/(^|[+ \t])([A-Za-z_]+)($|[+ \t])/$1$under$2$3/;
+#	$reg1="$regs{$reg1}" if defined($regs{$reg1});
+#	$reg2="$regs{$reg2}" if defined($regs{$reg2});
+#	$ret.=$addr if ($addr ne "") && ($addr ne 0);
+#	if ($reg2 ne "")
+#		{ $ret.="($reg1,$reg2,$idx)"; }
+#	else
+#		{ $ret.="($reg1)" }
+#	return($ret);
+#	}
+
+sub main'mov	{ &out2("movl",@_); }
+sub main'movb	{ &out2("movb",@_); }
+sub main'and	{ &out2("andl",@_); }
+sub main'or	{ &out2("orl",@_); }
+sub main'shl	{ &out2("sall",@_); }
+sub main'shr	{ &out2("shrl",@_); }
+sub main'xor	{ &out2("xorl",@_); }
+sub main'xorb	{ &out2("xorb",@_); }
+sub main'add	{ &out2("addl",@_); }
+sub main'adc	{ &out2("adcl",@_); }
+sub main'sub	{ &out2("subl",@_); }
+sub main'rotl	{ &out2("roll",@_); }
+sub main'rotr	{ &out2("rorl",@_); }
+sub main'exch	{ &out2("xchg",@_); }
+sub main'cmp	{ &out2("cmpl",@_); }
+sub main'lea	{ &out2("leal",@_); }
+sub main'mul	{ &out1("mull",@_); }
+sub main'div	{ &out1("divl",@_); }
+sub main'jmp	{ &out1("jmp",@_); }
+sub main'jmp_ptr { &out1p("jmp",@_); }
+sub main'je	{ &out1("je",@_); }
+sub main'jle	{ &out1("jle",@_); }
+sub main'jne	{ &out1("jne",@_); }
+sub main'jnz	{ &out1("jnz",@_); }
+sub main'jz	{ &out1("jz",@_); }
+sub main'jge	{ &out1("jge",@_); }
+sub main'jl	{ &out1("jl",@_); }
+sub main'jb	{ &out1("jb",@_); }
+sub main'dec	{ &out1("decl",@_); }
+sub main'inc	{ &out1("incl",@_); }
+sub main'push	{ &out1("pushl",@_); $stack+=4; }
+sub main'pop	{ &out1("popl",@_); $stack-=4; }
+sub main'bswap	{ &out1("bswapl",@_); }
+sub main'not	{ &out1("notl",@_); }
+sub main'call	{ &out1("call",$under.$_[0]); }
+sub main'ret	{ &out0("ret"); }
+sub main'nop	{ &out0("nop"); }
+
+sub out2
+	{
+	local($name,$p1,$p2)=@_;
+	local($l,$ll,$t);
+	local(%special)=(	"roll",0xD1C0,"rorl",0xD1C8,
+				"rcll",0xD1D0,"rcrl",0xD1D8,
+				"shll",0xD1E0,"shrl",0xD1E8,
+				"sarl",0xD1F8);
+	
+	if ((defined($special{$name})) && defined($regs{$p1}) && ($p2 == 1))
+		{
+		$op=$special{$name}|$reg_val{$p1};
+		$tmp1=sprintf ".byte %d\n",($op>>8)&0xff;
+		$tmp2=sprintf ".byte %d\t",$op     &0xff;
+		push(@out,$tmp1);
+		push(@out,$tmp2);
+
+		$p2=&conv($p2);
+		$p1=&conv($p1);
+		&main'comment("$name $p2 $p1");
+		return;
+		}
+
+	push(@out,"\t$name\t");
+	$t=&conv($p2).",";
+	$l=length($t);
+	push(@out,$t);
+	$ll=4-($l+9)/8;
+	$tmp1=sprintf "\t" x $ll;
+	push(@out,$tmp1);
+	push(@out,&conv($p1)."\n");
+	}
+
+sub out1
+	{
+	local($name,$p1)=@_;
+	local($l,$t);
+
+	push(@out,"\t$name\t".&conv($p1)."\n");
+	}
+
+sub out1p
+	{
+	local($name,$p1)=@_;
+	local($l,$t);
+
+	push(@out,"\t$name\t*".&conv($p1)."\n");
+	}
+
+sub out0
+	{
+	push(@out,"\t$_[0]\n");
+	}
+
+sub conv
+	{
+	local($p)=@_;
+
+#	$p =~ s/0x([0-9A-Fa-f]+)/0$1h/;
+
+	$p=$regs{$p} if (defined($regs{$p}));
+
+	$p =~ s/^(-{0,1}[0-9A-Fa-f]+)$/\$$1/;
+	$p =~ s/^(0x[0-9A-Fa-f]+)$/\$$1/;
+	return $p;
+	}
+
+sub main'file
+	{
+	local($file)=@_;
+
+	local($tmp)=<<"EOF";
+	.file	"$file.s"
+	.version	"01.01"
+gcc2_compiled.:
+EOF
+	push(@out,$tmp);
+	}
+
+sub main'function_begin
+	{
+	local($func)=@_;
+
+	$func=$under.$func;
+
+	local($tmp)=<<"EOF";
+.text
+	.align $align
+.globl $func
+EOF
+	push(@out,$tmp);
+	if ($main'cpp)
+		{ $tmp=push(@out,"\tTYPE($func,\@function)\n"); }
+	else	{ $tmp=push(@out,"\t.type\t$func,\@function\n"); }
+	push(@out,"$func:\n");
+	$tmp=<<"EOF";
+	pushl	%ebp
+	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
+
+EOF
+	push(@out,$tmp);
+	$stack=20;
+	}
+
+sub main'function_begin_B
+	{
+	local($func,$extra)=@_;
+
+	$func=$under.$func;
+
+	local($tmp)=<<"EOF";
+.text
+	.align $align
+.globl $func
+EOF
+	push(@out,$tmp);
+	if ($main'cpp)
+		{ push(@out,"\tTYPE($func,\@function)\n"); }
+	else	{ push(@out,"\t.type	$func,\@function\n"); }
+	push(@out,"$func:\n");
+	$stack=4;
+	}
+
+sub main'function_end
+	{
+	local($func)=@_;
+
+	$func=$under.$func;
+
+	local($tmp)=<<"EOF";
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+	ret
+.${func}_end:
+EOF
+	push(@out,$tmp);
+	if ($main'cpp)
+		{ push(@out,"\tSIZE($func,.${func}_end-$func)\n"); }
+	else	{ push(@out,"\t.size\t$func,.${func}_end-$func\n"); }
+	push(@out,".ident	\"$func\"\n");
+	$stack=0;
+	%label=();
+	}
+
+sub main'function_end_A
+	{
+	local($func)=@_;
+
+	local($tmp)=<<"EOF";
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+	ret
+EOF
+	push(@out,$tmp);
+	}
+
+sub main'function_end_B
+	{
+	local($func)=@_;
+
+	$func=$under.$func;
+
+	push(@out,".${func}_end:\n");
+	if ($main'cpp)
+		{ push(@out,"\tSIZE($func,.${func}_end-$func)\n"); }
+	else	{ push(@out,"\t.size\t$func,.${func}_end-$func\n"); }
+	push(@out,".ident	\"desasm.pl\"\n");
+	$stack=0;
+	%label=();
+	}
+
+sub main'wparam
+	{
+	local($num)=@_;
+
+	return(&main'DWP($stack+$num*4,"esp","",0));
+	}
+
+sub main'stack_push
+	{
+	local($num)=@_;
+	$stack+=$num*4;
+	&main'sub("esp",$num*4);
+	}
+
+sub main'stack_pop
+	{
+	local($num)=@_;
+	$stack-=$num*4;
+	&main'add("esp",$num*4);
+	}
+
+sub main'swtmp
+	{
+	return(&main'DWP($_[0]*4,"esp","",0));
+	}
+
+# Should use swtmp, which is above esp.  Linix can trash the stack above esp
+#sub main'wtmp
+#	{
+#	local($num)=@_;
+#
+#	return(&main'DWP(-($num+1)*4,"esp","",0));
+#	}
+
+sub main'comment
+	{
+	foreach (@_)
+		{
+		if (/^\s*$/)
+			{ push(@out,"\n"); }
+		else
+			{ push(@out,"\t$com_start $_ $com_end\n"); }
+		}
+	}
+
+sub main'label
+	{
+	if (!defined($label{$_[0]}))
+		{
+		$label{$_[0]}=".${label}${_[0]}";
+		$label++;
+		}
+	return($label{$_[0]});
+	}
+
+sub main'set_label
+	{
+	if (!defined($label{$_[0]}))
+		{
+		$label{$_[0]}=".${label}${_[0]}";
+		$label++;
+		}
+	push(@out,".align $align\n") if ($_[1] != 0);
+	push(@out,"$label{$_[0]}:\n");
+	}
+
+sub main'file_end
+	{
+	}
+
+sub main'data_word
+	{
+	push(@out,"\t.long $_[0]\n");
+	}
diff -druN linux-noipsec/net/ipsec/libdes/cbc_enc.c linux/net/ipsec/libdes/cbc_enc.c
--- linux-noipsec/net/ipsec/libdes/cbc_enc.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/cbc_enc.c	Thu Feb 18 17:41:10 1999
@@ -0,0 +1,135 @@
+/* crypto/des/cbc_enc.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include "des_locl.h"
+
+void des_cbc_encrypt(input, output, length, schedule, ivec, enc)
+des_cblock (*input);
+des_cblock (*output);
+long length;
+des_key_schedule schedule;
+des_cblock (*ivec);
+int enc;
+	{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register unsigned char *in,*out;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	in=(unsigned char *)input;
+	out=(unsigned char *)output;
+	iv=(unsigned char *)ivec;
+
+	if (enc)
+		{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+			}
+		if (l != -8)
+			{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+			}
+		}
+	else
+		{
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=tin0;
+			xor1=tin1;
+			}
+		if (l != -8)
+			{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2cn(tout0,tout1,out,l+8);
+		/*	xor0=tin0;
+			xor1=tin1; */
+			}
+		}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/des.h linux/net/ipsec/libdes/des.h
--- linux-noipsec/net/ipsec/libdes/des.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/des.h	Wed Oct  4 16:54:10 2000
@@ -0,0 +1,303 @@
+/* crypto/des/des.org */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
+ *
+ * Always modify des.org since des.h is automatically generated from
+ * it during SSLeay configuration.
+ *
+ * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+ */
+
+#ifndef HEADER_DES_H
+#define HEADER_DES_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* If this is set to 'unsigned int' on a DEC Alpha, this gives about a
+ * %20 speed up (longs are 8 bytes, int's are 4). */
+#ifndef DES_LONG
+/* RCSID $Id$ */
+/* This conditional for FreeS/WAN project. */
+#ifdef __alpha
+#define DES_LONG unsigned int
+#else
+#define DES_LONG unsigned long
+#endif
+#endif
+
+typedef unsigned char des_cblock[8];
+typedef struct des_ks_struct
+	{
+	union	{
+		des_cblock _;
+		/* make sure things are correct size on machines with
+		 * 8 byte longs */
+		DES_LONG pad[2];
+		} ks;
+#undef _
+#define _	ks._
+	} des_key_schedule[16];
+
+#define DES_KEY_SZ 	(sizeof(des_cblock))
+#define DES_SCHEDULE_SZ (sizeof(des_key_schedule))
+
+#define DES_ENCRYPT	1
+#define DES_DECRYPT	0
+
+#define DES_CBC_MODE	0
+#define DES_PCBC_MODE	1
+
+#define des_ecb2_encrypt(i,o,k1,k2,e) \
+	des_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))
+
+#define des_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \
+	des_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))
+
+#define des_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \
+	des_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))
+
+#define des_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \
+	des_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))
+
+#define C_Block des_cblock
+#define Key_schedule des_key_schedule
+#ifdef KERBEROS
+#define ENCRYPT DES_ENCRYPT
+#define DECRYPT DES_DECRYPT
+#endif
+#define KEY_SZ DES_KEY_SZ
+#define string_to_key des_string_to_key
+#define read_pw_string des_read_pw_string
+#define random_key des_random_key
+#define pcbc_encrypt des_pcbc_encrypt
+#define set_key des_set_key
+#define key_sched des_key_sched
+#define ecb_encrypt des_ecb_encrypt
+#define cbc_encrypt des_cbc_encrypt
+#define ncbc_encrypt des_ncbc_encrypt
+#define xcbc_encrypt des_xcbc_encrypt
+#define cbc_cksum des_cbc_cksum
+#define quad_cksum des_quad_cksum
+
+/* For compatibility with the MIT lib - eay 20/05/92 */
+typedef des_key_schedule bit_64;
+#define des_fixup_key_parity des_set_odd_parity
+#define des_check_key_parity check_parity
+
+extern int des_check_key;	/* defaults to false */
+extern int des_rw_mode;		/* defaults to DES_PCBC_MODE */
+
+/* The next line is used to disable full ANSI prototypes, if your
+ * compiler has problems with the prototypes, make sure this line always
+ * evaluates to true :-) */
+#if defined(MSDOS) || defined(__STDC__)
+#undef NOPROTO
+#endif
+#ifndef NOPROTO
+char *des_options(void);
+void des_ecb3_encrypt(des_cblock *input,des_cblock *output,
+	des_key_schedule ks1,des_key_schedule ks2,
+	des_key_schedule ks3, int enc);
+DES_LONG des_cbc_cksum(des_cblock *input,des_cblock *output,
+	long length,des_key_schedule schedule,des_cblock *ivec);
+void des_cbc_encrypt(des_cblock *input,des_cblock *output,long length,
+	des_key_schedule schedule,des_cblock *ivec,int enc);
+void des_ncbc_encrypt(des_cblock *input,des_cblock *output,long length,
+	des_key_schedule schedule,des_cblock *ivec,int enc);
+void des_xcbc_encrypt(des_cblock *input,des_cblock *output,long length,
+	des_key_schedule schedule,des_cblock *ivec,
+	des_cblock *inw,des_cblock *outw,int enc);
+void des_cfb_encrypt(unsigned char *in,unsigned char *out,int numbits,
+	long length,des_key_schedule schedule,des_cblock *ivec,int enc);
+void des_ecb_encrypt(des_cblock *input,des_cblock *output,
+	des_key_schedule ks,int enc);
+void des_encrypt(DES_LONG *data,des_key_schedule ks, int enc);
+void des_encrypt2(DES_LONG *data,des_key_schedule ks, int enc);
+void des_encrypt3(DES_LONG *data, des_key_schedule ks1,
+	des_key_schedule ks2, des_key_schedule ks3);
+void des_decrypt3(DES_LONG *data, des_key_schedule ks1,
+	des_key_schedule ks2, des_key_schedule ks3);
+void des_ede3_cbc_encrypt(des_cblock *input, des_cblock *output, 
+	long length, des_key_schedule ks1, des_key_schedule ks2, 
+	des_key_schedule ks3, des_cblock *ivec, int enc);
+void des_ede3_cfb64_encrypt(unsigned char *in, unsigned char *out,
+	long length, des_key_schedule ks1, des_key_schedule ks2,
+	des_key_schedule ks3, des_cblock *ivec, int *num, int enc);
+void des_ede3_ofb64_encrypt(unsigned char *in, unsigned char *out,
+	long length, des_key_schedule ks1, des_key_schedule ks2,
+	des_key_schedule ks3, des_cblock *ivec, int *num);
+
+void des_xwhite_in2out(des_cblock (*des_key), des_cblock (*in_white),
+	des_cblock (*out_white));
+
+int des_enc_read(int fd,char *buf,int len,des_key_schedule sched,
+	des_cblock *iv);
+int des_enc_write(int fd,char *buf,int len,des_key_schedule sched,
+	des_cblock *iv);
+char *des_fcrypt(const char *buf,const char *salt, char *ret);
+#ifdef PERL5
+char *des_crypt(const char *buf,const char *salt);
+#else
+/* some stupid compilers complain because I have declared char instead
+ * of const char */
+#ifdef HEADER_DES_LOCL_H
+char *crypt(const char *buf,const char *salt);
+#else
+char *crypt();
+#endif
+#endif
+void des_ofb_encrypt(unsigned char *in,unsigned char *out,
+	int numbits,long length,des_key_schedule schedule,des_cblock *ivec);
+void des_pcbc_encrypt(des_cblock *input,des_cblock *output,long length,
+	des_key_schedule schedule,des_cblock *ivec,int enc);
+DES_LONG des_quad_cksum(des_cblock *input,des_cblock *output,
+	long length,int out_count,des_cblock *seed);
+void des_random_seed(des_cblock key);
+void des_random_key(des_cblock ret);
+int des_read_password(des_cblock *key,char *prompt,int verify);
+int des_read_2passwords(des_cblock *key1,des_cblock *key2,
+	char *prompt,int verify);
+int des_read_pw_string(char *buf,int length,char *prompt,int verify);
+void des_set_odd_parity(des_cblock *key);
+int des_is_weak_key(des_cblock *key);
+int des_set_key(des_cblock *key,des_key_schedule schedule);
+int des_key_sched(des_cblock *key,des_key_schedule schedule);
+void des_string_to_key(char *str,des_cblock *key);
+void des_string_to_2keys(char *str,des_cblock *key1,des_cblock *key2);
+void des_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,
+	des_key_schedule schedule, des_cblock *ivec, int *num, int enc);
+void des_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,
+	des_key_schedule schedule, des_cblock *ivec, int *num);
+int des_read_pw(char *buf, char *buff, int size, char *prompt, int verify);
+
+/* Extra functions from Mark Murray <mark@grondar.za> */
+/* The following functions are not in the normal unix build or the
+ * SSLeay build.  When using the SSLeay build, use RAND_seed()
+ * and RAND_bytes() instead. */
+int des_new_random_key(des_cblock *key);
+void des_init_random_number_generator(des_cblock *key);
+void des_set_random_generator_seed(des_cblock *key);
+void des_set_sequence_number(des_cblock new_sequence_number);
+void des_generate_random_block(des_cblock *block);
+
+#else
+
+char *des_options();
+void des_ecb3_encrypt();
+DES_LONG des_cbc_cksum();
+void des_cbc_encrypt();
+void des_ncbc_encrypt();
+void des_xcbc_encrypt();
+void des_cfb_encrypt();
+void des_ede3_cfb64_encrypt();
+void des_ede3_ofb64_encrypt();
+void des_ecb_encrypt();
+void des_encrypt();
+void des_encrypt2();
+void des_encrypt3();
+void des_decrypt3();
+void des_ede3_cbc_encrypt();
+int des_enc_read();
+int des_enc_write();
+char *des_fcrypt();
+#ifdef PERL5
+char *des_crypt();
+#else
+char *crypt();
+#endif
+void des_ofb_encrypt();
+void des_pcbc_encrypt();
+DES_LONG des_quad_cksum();
+void des_random_seed();
+void des_random_key();
+int des_read_password();
+int des_read_2passwords();
+int des_read_pw_string();
+void des_set_odd_parity();
+int des_is_weak_key();
+int des_set_key();
+int des_key_sched();
+void des_string_to_key();
+void des_string_to_2keys();
+void des_cfb64_encrypt();
+void des_ofb64_encrypt();
+int des_read_pw();
+void des_xwhite_in2out();
+
+/* Extra functions from Mark Murray <mark@grondar.za> */
+/* The following functions are not in the normal unix build or the
+ * SSLeay build.  When using the SSLeay build, use RAND_seed()
+ * and RAND_bytes() instead. */
+#ifdef FreeBSD
+int des_new_random_key();
+void des_init_random_number_generator();
+void des_set_random_generator_seed();
+void des_set_sequence_number();
+void des_generate_random_block();
+#endif
+
+#endif
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -druN linux-noipsec/net/ipsec/libdes/des_enc.c linux/net/ipsec/libdes/des_enc.c
--- linux-noipsec/net/ipsec/libdes/des_enc.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/des_enc.c	Thu Feb 18 17:41:12 1999
@@ -0,0 +1,502 @@
+/* crypto/des/des_enc.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include "des_locl.h"
+
+void des_encrypt(data, ks, enc)
+DES_LONG *data;
+des_key_schedule ks;
+int enc;
+	{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register unsigned char *des_SP=(unsigned char *)des_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	IP(r,l);
+	/* Things have been modified so that the initial rotate is
+	 * done outside the loop.  This required the
+	 * des_SPtrans values in sp.h to be rotated 1 bit to the right.
+	 * One perl script later and things have a 5% speed up on a sparc2.
+	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	 * for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	/* shift left by 2 */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=(DES_LONG *)ks;
+	/* I don't know if it is worth the effort of loop unrolling the
+	 * inner loop */
+	if (enc)
+		{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+			{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+			}
+#endif
+		}
+	else
+		{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+			{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+			}
+#endif
+		}
+
+	/* rotate and clear the top bits on machines with 8byte longs */
+	l=ROTATE(l,3)&0xffffffffL;
+	r=ROTATE(r,3)&0xffffffffL;
+
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+	l=r=t=u=0;
+	}
+
+void des_encrypt2(data, ks, enc)
+DES_LONG *data;
+des_key_schedule ks;
+int enc;
+	{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register unsigned char *des_SP=(unsigned char *)des_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	/* Things have been modified so that the initial rotate is
+	 * done outside the loop.  This required the
+	 * des_SPtrans values in sp.h to be rotated 1 bit to the right.
+	 * One perl script later and things have a 5% speed up on a sparc2.
+	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	 * for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=(DES_LONG *)ks;
+	/* I don't know if it is worth the effort of loop unrolling the
+	 * inner loop */
+	if (enc)
+		{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+			{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+			}
+#endif
+		}
+	else
+		{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+			{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+			}
+#endif
+		}
+	/* rotate and clear the top bits on machines with 8byte longs */
+	data[0]=ROTATE(l,3)&0xffffffffL;
+	data[1]=ROTATE(r,3)&0xffffffffL;
+	l=r=t=u=0;
+	}
+
+void des_encrypt3(data,ks1,ks2,ks3)
+DES_LONG *data;
+des_key_schedule ks1;
+des_key_schedule ks2;
+des_key_schedule ks3;
+	{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	des_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);
+	des_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);
+	des_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+	}
+
+void des_decrypt3(data,ks1,ks2,ks3)
+DES_LONG *data;
+des_key_schedule ks1;
+des_key_schedule ks2;
+des_key_schedule ks3;
+	{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	des_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);
+	des_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);
+	des_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+	}
+
+#ifndef DES_DEFAULT_OPTIONS
+
+void des_ncbc_encrypt(input, output, length, schedule, ivec, enc)
+des_cblock (*input);
+des_cblock (*output);
+long length;
+des_key_schedule schedule;
+des_cblock (*ivec);
+int enc;
+	{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register unsigned char *in,*out;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	in=(unsigned char *)input;
+	out=(unsigned char *)output;
+	iv=(unsigned char *)ivec;
+
+	if (enc)
+		{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+			}
+		if (l != -8)
+			{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+			}
+		iv=(unsigned char *)ivec;
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+		}
+	else
+		{
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=tin0;
+			xor1=tin1;
+			}
+		if (l != -8)
+			{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			des_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2cn(tout0,tout1,out,l+8);
+			xor0=tin0;
+			xor1=tin1;
+			}
+
+		iv=(unsigned char *)ivec;
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+		}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+	}
+
+void des_ede3_cbc_encrypt(input, output, length, ks1, ks2, ks3, ivec, enc)
+des_cblock (*input);
+des_cblock (*output);
+long length;
+des_key_schedule ks1;
+des_key_schedule ks2;
+des_key_schedule ks3;
+des_cblock (*ivec);
+int enc;
+	{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register unsigned char *in,*out;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	in=(unsigned char *)input;
+	out=(unsigned char *)output;
+	iv=(unsigned char *)ivec;
+
+	if (enc)
+		{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			des_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+			}
+		if (l != -8)
+			{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			des_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+			}
+		iv=(unsigned char *)ivec;
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+		}
+	else
+		{
+		register DES_LONG t0,t1;
+
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+			{
+			c2l(in,tin0);
+			c2l(in,tin1);
+
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			des_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			tout0^=xor0;
+			tout1^=xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=t0;
+			xor1=t1;
+			}
+		if (l != -8)
+			{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			des_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+		
+			tout0^=xor0;
+			tout1^=xor1;
+			l2cn(tout0,tout1,out,l+8);
+			xor0=t0;
+			xor1=t1;
+			}
+
+		iv=(unsigned char *)ivec;
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+		}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+	}
+
+#endif /* DES_DEFAULT_OPTIONS */
diff -druN linux-noipsec/net/ipsec/libdes/des_locl.h linux/net/ipsec/libdes/des_locl.h
--- linux-noipsec/net/ipsec/libdes/des_locl.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/des_locl.h	Wed Oct  4 16:54:10 2000
@@ -0,0 +1,511 @@
+/* crypto/des/des_locl.org */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+ *
+ * Always modify des_locl.org since des_locl.h is automatically generated from
+ * it during SSLeay configuration.
+ *
+ * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+ */
+
+#ifndef HEADER_DES_LOCL_H
+#define HEADER_DES_LOCL_H
+
+#if defined(WIN32) || defined(WIN16)
+#ifndef MSDOS
+#define MSDOS
+#endif
+#endif
+
+#include "des.h"
+
+#ifndef DES_DEFAULT_OPTIONS
+/* the following is tweaked from a config script, that is why it is a
+ * protected undef/define */
+#ifndef DES_PTR
+#define DES_PTR
+#endif
+
+/* This helps C compiler generate the correct code for multiple functional
+ * units.  It reduces register dependancies at the expense of 2 more
+ * registers */
+#ifndef DES_RISC1
+#define DES_RISC1
+#endif
+
+#ifndef DES_RISC2
+#undef DES_RISC2
+#endif
+
+#if defined(DES_RISC1) && defined(DES_RISC2)
+YOU SHOULD NOT HAVE BOTH DES_RISC1 AND DES_RISC2 DEFINED!!!!!
+#endif
+
+/* Unroll the inner loop, this sometimes helps, sometimes hinders.
+ * Very mucy CPU dependant */
+#ifndef DES_UNROLL
+#define DES_UNROLL
+#endif
+
+/* These default values were supplied by
+ * Peter Gutman <pgut001@cs.auckland.ac.nz>
+ * They are only used if nothing else has been defined */
+#if !defined(DES_PTR) && !defined(DES_RISC1) && !defined(DES_RISC2) && !defined(DES_UNROLL)
+/* Special defines which change the way the code is built depending on the
+   CPU and OS.  For SGI machines you can use _MIPS_SZLONG (32 or 64) to find
+   even newer MIPS CPU's, but at the moment one size fits all for
+   optimization options.  Older Sparc's work better with only UNROLL, but
+   there's no way to tell at compile time what it is you're running on */
+ 
+#if defined( sun )		/* Newer Sparc's */
+  #define DES_PTR
+  #define DES_RISC1
+  #define DES_UNROLL
+#elif defined( __ultrix )	/* Older MIPS */
+  #define DES_PTR
+  #define DES_RISC2
+  #define DES_UNROLL
+#elif defined( __osf1__ )	/* Alpha */
+  #define DES_PTR
+  #define DES_RISC2
+#elif defined ( _AIX )		/* RS6000 */
+  /* Unknown */
+#elif defined( __hpux )		/* HP-PA */
+  /* Unknown */
+#elif defined( __aux )		/* 68K */
+  /* Unknown */
+#elif defined( __dgux )		/* 88K (but P6 in latest boxes) */
+  #define DES_UNROLL
+#elif defined( __sgi )		/* Newer MIPS */
+  #define DES_PTR
+  #define DES_RISC2
+  #define DES_UNROLL
+#elif defined( i386 )		/* x86 boxes, should be gcc */
+  #define DES_PTR
+  #define DES_RISC1
+  #define DES_UNROLL
+#endif /* Systems-specific speed defines */
+#endif
+
+#endif /* DES_DEFAULT_OPTIONS */
+
+#ifdef MSDOS		/* Visual C++ 2.1 (Windows NT/95) */
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include <io.h>
+#ifndef RAND
+#define RAND
+#endif
+#undef NOPROTO
+#endif
+
+#if defined(__STDC__) || defined(VMS) || defined(M_XENIX) || defined(MSDOS)
+#include <string.h>
+#endif
+
+#ifndef RAND
+#define RAND
+#endif
+
+#ifdef linux
+#undef RAND
+#endif
+
+#ifdef MSDOS
+#define getpid() 2
+#define RAND
+#undef NOPROTO
+#endif
+
+#if defined(NOCONST)
+#define const
+#endif
+
+#ifdef __STDC__
+#undef NOPROTO
+#endif
+
+#ifdef RAND
+#define srandom(s) srand(s)
+#define random rand
+#endif
+
+#define ITERATIONS 16
+#define HALF_ITERATIONS 8
+
+/* used in des_read and des_write */
+#define MAXWRITE	(1024*16)
+#define BSIZE		(MAXWRITE+4)
+
+#define c2l(c,l)	(l =((DES_LONG)(*((c)++)))    , \
+			 l|=((DES_LONG)(*((c)++)))<< 8L, \
+			 l|=((DES_LONG)(*((c)++)))<<16L, \
+			 l|=((DES_LONG)(*((c)++)))<<24L)
+
+/* NOTE - c is not incremented as per c2l */
+#define c2ln(c,l1,l2,n)	{ \
+			c+=n; \
+			l1=l2=0; \
+			switch (n) { \
+			case 8: l2 =((DES_LONG)(*(--(c))))<<24L; \
+			case 7: l2|=((DES_LONG)(*(--(c))))<<16L; \
+			case 6: l2|=((DES_LONG)(*(--(c))))<< 8L; \
+			case 5: l2|=((DES_LONG)(*(--(c))));     \
+			case 4: l1 =((DES_LONG)(*(--(c))))<<24L; \
+			case 3: l1|=((DES_LONG)(*(--(c))))<<16L; \
+			case 2: l1|=((DES_LONG)(*(--(c))))<< 8L; \
+			case 1: l1|=((DES_LONG)(*(--(c))));     \
+				} \
+			}
+
+#define l2c(l,c)	(*((c)++)=(unsigned char)(((l)     )&0xff), \
+			 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+			 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+			 *((c)++)=(unsigned char)(((l)>>24L)&0xff))
+
+/* replacements for htonl and ntohl since I have no idea what to do
+ * when faced with machines with 8 byte longs. */
+#define HDRSIZE 4
+
+#define n2l(c,l)	(l =((DES_LONG)(*((c)++)))<<24L, \
+			 l|=((DES_LONG)(*((c)++)))<<16L, \
+			 l|=((DES_LONG)(*((c)++)))<< 8L, \
+			 l|=((DES_LONG)(*((c)++))))
+
+#define l2n(l,c)	(*((c)++)=(unsigned char)(((l)>>24L)&0xff), \
+			 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+			 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+			 *((c)++)=(unsigned char)(((l)     )&0xff))
+
+/* NOTE - c is not incremented as per l2c */
+#define l2cn(l1,l2,c,n)	{ \
+			c+=n; \
+			switch (n) { \
+			case 8: *(--(c))=(unsigned char)(((l2)>>24L)&0xff); \
+			case 7: *(--(c))=(unsigned char)(((l2)>>16L)&0xff); \
+			case 6: *(--(c))=(unsigned char)(((l2)>> 8L)&0xff); \
+			case 5: *(--(c))=(unsigned char)(((l2)     )&0xff); \
+			case 4: *(--(c))=(unsigned char)(((l1)>>24L)&0xff); \
+			case 3: *(--(c))=(unsigned char)(((l1)>>16L)&0xff); \
+			case 2: *(--(c))=(unsigned char)(((l1)>> 8L)&0xff); \
+			case 1: *(--(c))=(unsigned char)(((l1)     )&0xff); \
+				} \
+			}
+
+#if defined(WIN32)
+#define	ROTATE(a,n)	(_lrotr(a,n))
+#else
+#define	ROTATE(a,n)	(((a)>>(n))+((a)<<(32-(n))))
+#endif
+
+/* Don't worry about the LOAD_DATA() stuff, that is used by
+ * fcrypt() to add it's little bit to the front */
+
+#ifdef DES_FCRYPT
+
+#define LOAD_DATA_tmp(R,S,u,t,E0,E1) \
+	{ DES_LONG tmp; LOAD_DATA(R,S,u,t,E0,E1,tmp); }
+
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+	t=R^(R>>16L); \
+	u=t&E0; t&=E1; \
+	tmp=(u<<16); u^=R^s[S  ]; u^=tmp; \
+	tmp=(t<<16); t^=R^s[S+1]; t^=tmp
+#else
+#define LOAD_DATA_tmp(a,b,c,d,e,f) LOAD_DATA(a,b,c,d,e,f,g)
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+	u=R^s[S  ]; \
+	t=R^s[S+1]
+#endif
+
+/* The changes to this macro may help or hinder, depending on the
+ * compiler and the achitecture.  gcc2 always seems to do well :-).
+ * Inspired by Dana How <how@isl.stanford.edu>
+ * DO NOT use the alternative version on machines with 8 byte longs.
+ * It does not seem to work on the Alpha, even when DES_LONG is 4
+ * bytes, probably an issue of accessing non-word aligned objects :-( */
+#ifdef DES_PTR
+
+/* It recently occured to me that 0^0^0^0^0^0^0 == 0, so there
+ * is no reason to not xor all the sub items together.  This potentially
+ * saves a register since things can be xored directly into L */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) { \
+	unsigned int u1,u2,u3; \
+	LOAD_DATA(R,S,u,t,E0,E1,u1); \
+	u2=(int)u>>8L; \
+	u1=(int)u&0xfc; \
+	u2&=0xfc; \
+	t=ROTATE(t,4); \
+	u>>=16L; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP      +u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x200+u2); \
+	u3=(int)(u>>8L); \
+	u1=(int)u&0xfc; \
+	u3&=0xfc; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x400+u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x600+u3); \
+	u2=(int)t>>8L; \
+	u1=(int)t&0xfc; \
+	u2&=0xfc; \
+	t>>=16L; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x100+u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x300+u2); \
+	u3=(int)t>>8L; \
+	u1=(int)t&0xfc; \
+	u3&=0xfc; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x500+u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x700+u3); }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) { \
+	unsigned int u1,u2,s1,s2; \
+	LOAD_DATA(R,S,u,t,E0,E1,u1); \
+	u2=(int)u>>8L; \
+	u1=(int)u&0xfc; \
+	u2&=0xfc; \
+	t=ROTATE(t,4); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP      +u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x200+u2); \
+	s1=(int)(u>>16L); \
+	s2=(int)(u>>24L); \
+	s1&=0xfc; \
+	s2&=0xfc; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x400+s1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x600+s2); \
+	u2=(int)t>>8L; \
+	u1=(int)t&0xfc; \
+	u2&=0xfc; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x100+u1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x300+u2); \
+	s1=(int)(t>>16L); \
+	s2=(int)(t>>24L); \
+	s1&=0xfc; \
+	s2&=0xfc; \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x500+s1); \
+	LL^= *(DES_LONG *)((unsigned char *)des_SP+0x700+s2); }
+#endif
+#else
+#define D_ENCRYPT(LL,R,S) { \
+	LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+	t=ROTATE(t,4); \
+	LL^= \
+	*(DES_LONG *)((unsigned char *)des_SP      +((u     )&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x200+((u>> 8L)&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x400+((u>>16L)&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x600+((u>>24L)&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x100+((t     )&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x300+((t>> 8L)&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x500+((t>>16L)&0xfc))^ \
+	*(DES_LONG *)((unsigned char *)des_SP+0x700+((t>>24L)&0xfc)); }
+#endif
+
+#else /* original version */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) {\
+	unsigned int u1,u2,u3; \
+	LOAD_DATA(R,S,u,t,E0,E1,u1); \
+	u>>=2L; \
+	t=ROTATE(t,6); \
+	u2=(int)u>>8L; \
+	u1=(int)u&0x3f; \
+	u2&=0x3f; \
+	u>>=16L; \
+	LL^=des_SPtrans[0][u1]; \
+	LL^=des_SPtrans[2][u2]; \
+	u3=(int)u>>8L; \
+	u1=(int)u&0x3f; \
+	u3&=0x3f; \
+	LL^=des_SPtrans[4][u1]; \
+	LL^=des_SPtrans[6][u3]; \
+	u2=(int)t>>8L; \
+	u1=(int)t&0x3f; \
+	u2&=0x3f; \
+	t>>=16L; \
+	LL^=des_SPtrans[1][u1]; \
+	LL^=des_SPtrans[3][u2]; \
+	u3=(int)t>>8L; \
+	u1=(int)t&0x3f; \
+	u3&=0x3f; \
+	LL^=des_SPtrans[5][u1]; \
+	LL^=des_SPtrans[7][u3]; }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) {\
+	unsigned int u1,u2,s1,s2; \
+	LOAD_DATA(R,S,u,t,E0,E1,u1); \
+	u>>=2L; \
+	t=ROTATE(t,6); \
+	u2=(int)u>>8L; \
+	u1=(int)u&0x3f; \
+	u2&=0x3f; \
+	LL^=des_SPtrans[0][u1]; \
+	LL^=des_SPtrans[2][u2]; \
+	s1=(int)u>>16L; \
+	s2=(int)u>>24L; \
+	s1&=0x3f; \
+	s2&=0x3f; \
+	LL^=des_SPtrans[4][s1]; \
+	LL^=des_SPtrans[6][s2]; \
+	u2=(int)t>>8L; \
+	u1=(int)t&0x3f; \
+	u2&=0x3f; \
+	LL^=des_SPtrans[1][u1]; \
+	LL^=des_SPtrans[3][u2]; \
+	s1=(int)t>>16; \
+	s2=(int)t>>24L; \
+	s1&=0x3f; \
+	s2&=0x3f; \
+	LL^=des_SPtrans[5][s1]; \
+	LL^=des_SPtrans[7][s2]; }
+#endif
+
+#else
+
+#define D_ENCRYPT(LL,R,S) {\
+	LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+	t=ROTATE(t,4); \
+	LL^=\
+		des_SPtrans[0][(u>> 2L)&0x3f]^ \
+		des_SPtrans[2][(u>>10L)&0x3f]^ \
+		des_SPtrans[4][(u>>18L)&0x3f]^ \
+		des_SPtrans[6][(u>>26L)&0x3f]^ \
+		des_SPtrans[1][(t>> 2L)&0x3f]^ \
+		des_SPtrans[3][(t>>10L)&0x3f]^ \
+		des_SPtrans[5][(t>>18L)&0x3f]^ \
+		des_SPtrans[7][(t>>26L)&0x3f]; }
+#endif
+#endif
+
+	/* IP and FP
+	 * The problem is more of a geometric problem that random bit fiddling.
+	 0  1  2  3  4  5  6  7      62 54 46 38 30 22 14  6
+	 8  9 10 11 12 13 14 15      60 52 44 36 28 20 12  4
+	16 17 18 19 20 21 22 23      58 50 42 34 26 18 10  2
+	24 25 26 27 28 29 30 31  to  56 48 40 32 24 16  8  0
+
+	32 33 34 35 36 37 38 39      63 55 47 39 31 23 15  7
+	40 41 42 43 44 45 46 47      61 53 45 37 29 21 13  5
+	48 49 50 51 52 53 54 55      59 51 43 35 27 19 11  3
+	56 57 58 59 60 61 62 63      57 49 41 33 25 17  9  1
+
+	The output has been subject to swaps of the form
+	0 1 -> 3 1 but the odd and even bits have been put into
+	2 3    2 0
+	different words.  The main trick is to remember that
+	t=((l>>size)^r)&(mask);
+	r^=t;
+	l^=(t<<size);
+	can be used to swap and move bits between words.
+
+	So l =  0  1  2  3  r = 16 17 18 19
+	        4  5  6  7      20 21 22 23
+	        8  9 10 11      24 25 26 27
+	       12 13 14 15      28 29 30 31
+	becomes (for size == 2 and mask == 0x3333)
+	   t =   2^16  3^17 -- --   l =  0  1 16 17  r =  2  3 18 19
+		 6^20  7^21 -- --        4  5 20 21       6  7 22 23
+		10^24 11^25 -- --        8  9 24 25      10 11 24 25
+		14^28 15^29 -- --       12 13 28 29      14 15 28 29
+
+	Thanks for hints from Richard Outerbridge - he told me IP&FP
+	could be done in 15 xor, 10 shifts and 5 ands.
+	When I finally started to think of the problem in 2D
+	I first got ~42 operations without xors.  When I remembered
+	how to use xors :-) I got it to its final state.
+	*/
+#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+	(b)^=(t),\
+	(a)^=((t)<<(n)))
+
+#define IP(l,r) \
+	{ \
+	register DES_LONG tt; \
+	PERM_OP(r,l,tt, 4,0x0f0f0f0fL); \
+	PERM_OP(l,r,tt,16,0x0000ffffL); \
+	PERM_OP(r,l,tt, 2,0x33333333L); \
+	PERM_OP(l,r,tt, 8,0x00ff00ffL); \
+	PERM_OP(r,l,tt, 1,0x55555555L); \
+	}
+
+#define FP(l,r) \
+	{ \
+	register DES_LONG tt; \
+	PERM_OP(l,r,tt, 1,0x55555555L); \
+	PERM_OP(r,l,tt, 8,0x00ff00ffL); \
+	PERM_OP(l,r,tt, 2,0x33333333L); \
+	PERM_OP(r,l,tt,16,0x0000ffffL); \
+	PERM_OP(l,r,tt, 4,0x0f0f0f0fL); \
+	}
+
+extern const DES_LONG des_SPtrans[8][64];
+
+#ifndef NOPROTO
+void fcrypt_body(DES_LONG *out,des_key_schedule ks,
+	DES_LONG Eswap0, DES_LONG Eswap1);
+#else
+void fcrypt_body();
+#endif
+
+#endif
diff -druN linux-noipsec/net/ipsec/libdes/des_opts.c linux/net/ipsec/libdes/des_opts.c
--- linux-noipsec/net/ipsec/libdes/des_opts.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/des_opts.c	Thu Feb 18 17:41:13 1999
@@ -0,0 +1,620 @@
+/* crypto/des/des_opts.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* define PART1, PART2, PART3 or PART4 to build only with a few of the options.
+ * This is for machines with 64k code segment size restrictions. */
+
+#ifndef MSDOS
+#define TIMES
+#endif
+
+#include <stdio.h>
+#ifndef MSDOS
+#include <unistd.h>
+#else
+#include <io.h>
+extern void exit();
+#endif
+#include <signal.h>
+#ifndef VMS
+#ifndef _IRIX
+#include <time.h>
+#endif
+#ifdef TIMES
+#include <sys/types.h>
+#include <sys/times.h>
+#endif
+#else /* VMS */
+#include <types.h>
+struct tms {
+	time_t tms_utime;
+	time_t tms_stime;
+	time_t tms_uchild;	/* I dunno...  */
+	time_t tms_uchildsys;	/* so these names are a guess :-) */
+	}
+#endif
+#ifndef TIMES
+#include <sys/timeb.h>
+#endif
+
+#ifdef sun
+#include <limits.h>
+#include <sys/param.h>
+#endif
+
+#include "des.h"
+#include "spr.h"
+
+#define DES_DEFAULT_OPTIONS
+
+#if !defined(PART1) && !defined(PART2) && !defined(PART3) && !defined(PART4)
+#define PART1
+#define PART2
+#define PART3
+#define PART4
+#endif
+
+#ifdef PART1
+
+#undef DES_UNROLL
+#undef DES_RISC1
+#undef DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#define des_encrypt  des_encrypt_u4_cisc_idx
+#define des_encrypt2 des_encrypt2_u4_cisc_idx
+#define des_encrypt3 des_encrypt3_u4_cisc_idx
+#define des_decrypt3 des_decrypt3_u4_cisc_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#undef DES_RISC1
+#undef DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_cisc_idx
+#define des_encrypt2 des_encrypt2_u16_cisc_idx
+#define des_encrypt3 des_encrypt3_u16_cisc_idx
+#define des_decrypt3 des_decrypt3_u16_cisc_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#undef DES_UNROLL
+#define DES_RISC1
+#undef DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u4_risc1_idx
+#define des_encrypt2 des_encrypt2_u4_risc1_idx
+#define des_encrypt3 des_encrypt3_u4_risc1_idx
+#define des_decrypt3 des_decrypt3_u4_risc1_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#endif
+
+#ifdef PART2
+
+#undef DES_UNROLL
+#undef DES_RISC1
+#define DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u4_risc2_idx
+#define des_encrypt2 des_encrypt2_u4_risc2_idx
+#define des_encrypt3 des_encrypt3_u4_risc2_idx
+#define des_decrypt3 des_decrypt3_u4_risc2_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#define DES_RISC1
+#undef DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_risc1_idx
+#define des_encrypt2 des_encrypt2_u16_risc1_idx
+#define des_encrypt3 des_encrypt3_u16_risc1_idx
+#define des_decrypt3 des_decrypt3_u16_risc1_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#undef DES_RISC1
+#define DES_RISC2
+#undef DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_risc2_idx
+#define des_encrypt2 des_encrypt2_u16_risc2_idx
+#define des_encrypt3 des_encrypt3_u16_risc2_idx
+#define des_decrypt3 des_decrypt3_u16_risc2_idx
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#endif
+
+#ifdef PART3
+
+#undef DES_UNROLL
+#undef DES_RISC1
+#undef DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u4_cisc_ptr
+#define des_encrypt2 des_encrypt2_u4_cisc_ptr
+#define des_encrypt3 des_encrypt3_u4_cisc_ptr
+#define des_decrypt3 des_decrypt3_u4_cisc_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#undef DES_RISC1
+#undef DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_cisc_ptr
+#define des_encrypt2 des_encrypt2_u16_cisc_ptr
+#define des_encrypt3 des_encrypt3_u16_cisc_ptr
+#define des_decrypt3 des_decrypt3_u16_cisc_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#undef DES_UNROLL
+#define DES_RISC1
+#undef DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u4_risc1_ptr
+#define des_encrypt2 des_encrypt2_u4_risc1_ptr
+#define des_encrypt3 des_encrypt3_u4_risc1_ptr
+#define des_decrypt3 des_decrypt3_u4_risc1_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#endif
+
+#ifdef PART4
+
+#undef DES_UNROLL
+#undef DES_RISC1
+#define DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u4_risc2_ptr
+#define des_encrypt2 des_encrypt2_u4_risc2_ptr
+#define des_encrypt3 des_encrypt3_u4_risc2_ptr
+#define des_decrypt3 des_decrypt3_u4_risc2_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#define DES_RISC1
+#undef DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_risc1_ptr
+#define des_encrypt2 des_encrypt2_u16_risc1_ptr
+#define des_encrypt3 des_encrypt3_u16_risc1_ptr
+#define des_decrypt3 des_decrypt3_u16_risc1_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#define DES_UNROLL
+#undef DES_RISC1
+#define DES_RISC2
+#define DES_PTR
+#undef D_ENCRYPT
+#undef des_encrypt
+#undef des_encrypt2
+#undef des_encrypt3
+#undef des_decrypt3
+#define des_encrypt  des_encrypt_u16_risc2_ptr
+#define des_encrypt2 des_encrypt2_u16_risc2_ptr
+#define des_encrypt3 des_encrypt3_u16_risc2_ptr
+#define des_decrypt3 des_decrypt3_u16_risc2_ptr
+#undef HEADER_DES_LOCL_H
+#include "des_enc.c"
+
+#endif
+
+/* The following if from times(3) man page.  It may need to be changed */
+#ifndef HZ
+# ifndef CLK_TCK
+#  ifndef _BSD_CLK_TCK_ /* FreeBSD fix */
+#   ifndef VMS
+#    define HZ	100.0
+#   else /* VMS */
+#    define HZ	100.0
+#   endif
+#  else /* _BSD_CLK_TCK_ */
+#   define HZ ((double)_BSD_CLK_TCK_)
+#  endif
+# else /* CLK_TCK */
+#  define HZ ((double)CLK_TCK)
+# endif
+#endif
+
+#define BUFSIZE	((long)1024)
+long run=0;
+
+#ifndef NOPROTO
+double Time_F(int s);
+#else
+double Time_F();
+#endif
+
+#ifdef SIGALRM
+#if defined(__STDC__) || defined(sgi)
+#define SIGRETTYPE void
+#else
+#define SIGRETTYPE int
+#endif
+
+#ifndef NOPROTO
+SIGRETTYPE sig_done(int sig);
+#else
+SIGRETTYPE sig_done();
+#endif
+
+SIGRETTYPE sig_done(sig)
+int sig;
+	{
+	signal(SIGALRM,sig_done);
+	run=0;
+#ifdef LINT
+	sig=sig;
+#endif
+	}
+#endif
+
+#define START	0
+#define STOP	1
+
+double Time_F(s)
+int s;
+	{
+	double ret;
+#ifdef TIMES
+	static struct tms tstart,tend;
+
+	if (s == START)
+		{
+		times(&tstart);
+		return(0);
+		}
+	else
+		{
+		times(&tend);
+		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
+		return((ret == 0.0)?1e-6:ret);
+		}
+#else /* !times() */
+	static struct timeb tstart,tend;
+	long i;
+
+	if (s == START)
+		{
+		ftime(&tstart);
+		return(0);
+		}
+	else
+		{
+		ftime(&tend);
+		i=(long)tend.millitm-(long)tstart.millitm;
+		ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
+		return((ret == 0.0)?1e-6:ret);
+		}
+#endif
+	}
+
+#ifdef SIGALRM
+#define print_name(name) fprintf(stderr,"Doing %s's for 10 seconds\n",name); alarm(10);
+#else
+#define print_name(name) fprintf(stderr,"Doing %s %ld times\n",name,cb);
+#endif
+	
+#define time_it(func,name,index) \
+	print_name(name); \
+	Time_F(START); \
+	for (count=0,run=1; COND(cb); count++) \
+		{ \
+		unsigned long d[2]; \
+		func(d,&(sch[0]),DES_ENCRYPT); \
+		} \
+	tm[index]=Time_F(STOP); \
+	fprintf(stderr,"%ld %s's in %.2f second\n",count,name,tm[index]); \
+	tm[index]=((double)COUNT(cb))/tm[index];
+
+#define print_it(name,index) \
+	fprintf(stderr,"%s bytes per sec = %12.2f (%5.1fuS)\n",name, \
+		tm[index]*8,1.0e6/tm[index]);
+
+int main(argc,argv)
+int argc;
+char **argv;
+	{
+	long count;
+	static unsigned char buf[BUFSIZE];
+	static des_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
+	static des_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
+	static des_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
+	des_key_schedule sch,sch2,sch3;
+	double d,tm[16],max=0;
+	int rank[16];
+	char *str[16];
+	int max_idx=0,i,num=0,j;
+#ifndef SIGALARM
+	long ca,cb,cc,cd,ce;
+#endif
+
+	for (i=0; i<12; i++)
+		{
+		tm[i]=0.0;
+		rank[i]=0;
+		}
+
+#ifndef TIMES
+	fprintf(stderr,"To get the most acurate results, try to run this\n");
+	fprintf(stderr,"program when this computer is idle.\n");
+#endif
+
+	des_set_key((C_Block *)key,sch);
+	des_set_key((C_Block *)key2,sch2);
+	des_set_key((C_Block *)key3,sch3);
+
+#ifndef SIGALRM
+	fprintf(stderr,"First we calculate the approximate speed ...\n");
+	des_set_key((C_Block *)key,sch);
+	count=10;
+	do	{
+		long i;
+		unsigned long data[2];
+
+		count*=2;
+		Time_F(START);
+		for (i=count; i; i--)
+			des_encrypt(data,&(sch[0]),DES_ENCRYPT);
+		d=Time_F(STOP);
+		} while (d < 3.0);
+	ca=count;
+	cb=count*3;
+	cc=count*3*8/BUFSIZE+1;
+	cd=count*8/BUFSIZE+1;
+
+	ce=count/20+1;
+#define COND(d) (count != (d))
+#define COUNT(d) (d)
+#else
+#define COND(c) (run)
+#define COUNT(d) (count)
+        signal(SIGALRM,sig_done);
+        alarm(10);
+#endif
+
+#ifdef PART1
+	time_it(des_encrypt_u4_cisc_idx,  "des_encrypt_u4_cisc_idx  ", 0);
+	time_it(des_encrypt_u16_cisc_idx, "des_encrypt_u16_cisc_idx ", 1);
+	time_it(des_encrypt_u4_risc1_idx, "des_encrypt_u4_risc1_idx ", 2);
+	num+=3;
+#endif
+#ifdef PART2
+	time_it(des_encrypt_u16_risc1_idx,"des_encrypt_u16_risc1_idx", 3);
+	time_it(des_encrypt_u4_risc2_idx, "des_encrypt_u4_risc2_idx ", 4);
+	time_it(des_encrypt_u16_risc2_idx,"des_encrypt_u16_risc2_idx", 5);
+	num+=3;
+#endif
+#ifdef PART3
+	time_it(des_encrypt_u4_cisc_ptr,  "des_encrypt_u4_cisc_ptr  ", 6);
+	time_it(des_encrypt_u16_cisc_ptr, "des_encrypt_u16_cisc_ptr ", 7);
+	time_it(des_encrypt_u4_risc1_ptr, "des_encrypt_u4_risc1_ptr ", 8);
+	num+=3;
+#endif
+#ifdef PART4
+	time_it(des_encrypt_u16_risc1_ptr,"des_encrypt_u16_risc1_ptr", 9);
+	time_it(des_encrypt_u4_risc2_ptr, "des_encrypt_u4_risc2_ptr ",10);
+	time_it(des_encrypt_u16_risc2_ptr,"des_encrypt_u16_risc2_ptr",11);
+	num+=3;
+#endif
+
+#ifdef PART1
+	str[0]=" 4  c i";
+	print_it("des_encrypt_u4_cisc_idx  ",0);
+	max=tm[0];
+	max_idx=0;
+	str[1]="16  c i";
+	print_it("des_encrypt_u16_cisc_idx ",1);
+	if (max < tm[1]) { max=tm[1]; max_idx=1; }
+	str[2]=" 4 r1 i";
+	print_it("des_encrypt_u4_risc1_idx ",2);
+	if (max < tm[2]) { max=tm[2]; max_idx=2; }
+#endif
+#ifdef PART2
+	str[3]="16 r1 i";
+	print_it("des_encrypt_u16_risc1_idx",3);
+	if (max < tm[3]) { max=tm[3]; max_idx=3; }
+	str[4]=" 4 r2 i";
+	print_it("des_encrypt_u4_risc2_idx ",4);
+	if (max < tm[4]) { max=tm[4]; max_idx=4; }
+	str[5]="16 r2 i";
+	print_it("des_encrypt_u16_risc2_idx",5);
+	if (max < tm[5]) { max=tm[5]; max_idx=5; }
+#endif
+#ifdef PART3
+	str[6]=" 4  c p";
+	print_it("des_encrypt_u4_cisc_ptr  ",6);
+	if (max < tm[6]) { max=tm[6]; max_idx=6; }
+	str[7]="16  c p";
+	print_it("des_encrypt_u16_cisc_ptr ",7);
+	if (max < tm[7]) { max=tm[7]; max_idx=7; }
+	str[8]=" 4 r1 p";
+	print_it("des_encrypt_u4_risc1_ptr ",8);
+	if (max < tm[8]) { max=tm[8]; max_idx=8; }
+#endif
+#ifdef PART4
+	str[9]="16 r1 p";
+	print_it("des_encrypt_u16_risc1_ptr",9);
+	if (max < tm[9]) { max=tm[9]; max_idx=9; }
+	str[10]=" 4 r2 p";
+	print_it("des_encrypt_u4_risc2_ptr ",10);
+	if (max < tm[10]) { max=tm[10]; max_idx=10; }
+	str[11]="16 r2 p";
+	print_it("des_encrypt_u16_risc2_ptr",11);
+	if (max < tm[11]) { max=tm[11]; max_idx=11; }
+#endif
+	printf("options    des ecb/s\n");
+	printf("%s %12.2f 100.0%%\n",str[max_idx],tm[max_idx]);
+	d=tm[max_idx];
+	tm[max_idx]= -2.0;
+	max= -1.0;
+	for (;;)
+		{
+		for (i=0; i<12; i++)
+			{
+			if (max < tm[i]) { max=tm[i]; j=i; }
+			}
+		if (max < 0.0) break;
+		printf("%s %12.2f  %4.1f%%\n",str[j],tm[j],tm[j]/d*100.0);
+		tm[j]= -2.0;
+		max= -1.0;
+		}
+
+	switch (max_idx)
+		{
+	case 0:
+		printf("-DDES_DEFAULT_OPTIONS\n");
+		break;
+	case 1:
+		printf("-DDES_UNROLL\n");
+		break;
+	case 2:
+		printf("-DDES_RISC1\n");
+		break;
+	case 3:
+		printf("-DDES_UNROLL -DDES_RISC1\n");
+		break;
+	case 4:
+		printf("-DDES_RISC2\n");
+		break;
+	case 5:
+		printf("-DDES_UNROLL -DDES_RISC2\n");
+		break;
+	case 6:
+		printf("-DDES_PTR\n");
+		break;
+	case 7:
+		printf("-DDES_UNROLL -DDES_PTR\n");
+		break;
+	case 8:
+		printf("-DDES_RISC1 -DDES_PTR\n");
+		break;
+	case 9:
+		printf("-DDES_UNROLL -DDES_RISC1 -DDES_PTR\n");
+		break;
+	case 10:
+		printf("-DDES_RISC2 -DDES_PTR\n");
+		break;
+	case 11:
+		printf("-DDES_UNROLL -DDES_RISC2 -DDES_PTR\n");
+		break;
+		}
+	exit(0);
+#if defined(LINT) || defined(MSDOS)
+	return(0);
+#endif
+	}
diff -druN linux-noipsec/net/ipsec/libdes/des_ver.h linux/net/ipsec/libdes/des_ver.h
--- linux-noipsec/net/ipsec/libdes/des_ver.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/des_ver.h	Thu Feb 18 17:41:13 1999
@@ -0,0 +1,60 @@
+/* crypto/des/des_ver.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+extern char *DES_version;	/* SSLeay version string */
+extern char *libdes_version;	/* old libdes version string */
diff -druN linux-noipsec/net/ipsec/libdes/destest.c linux/net/ipsec/libdes/destest.c
--- linux-noipsec/net/ipsec/libdes/destest.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/destest.c	Thu Feb 18 17:41:13 1999
@@ -0,0 +1,871 @@
+/* crypto/des/destest.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#if defined(WIN32) || defined(WIN16) || defined(WINDOWS)
+#ifndef MSDOS
+#define MSDOS
+#endif
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifndef MSDOS
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
+#include <string.h>
+#include "des.h"
+
+/* tisk tisk - the test keys don't all have odd parity :-( */
+/* test data */
+#define NUM_TESTS 34
+static unsigned char key_data[NUM_TESTS][8]={
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
+	{0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10},
+	{0x7C,0xA1,0x10,0x45,0x4A,0x1A,0x6E,0x57},
+	{0x01,0x31,0xD9,0x61,0x9D,0xC1,0x37,0x6E},
+	{0x07,0xA1,0x13,0x3E,0x4A,0x0B,0x26,0x86},
+	{0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E},
+	{0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6},
+	{0x01,0x13,0xB9,0x70,0xFD,0x34,0xF2,0xCE},
+	{0x01,0x70,0xF1,0x75,0x46,0x8F,0xB5,0xE6},
+	{0x43,0x29,0x7F,0xAD,0x38,0xE3,0x73,0xFE},
+	{0x07,0xA7,0x13,0x70,0x45,0xDA,0x2A,0x16},
+	{0x04,0x68,0x91,0x04,0xC2,0xFD,0x3B,0x2F},
+	{0x37,0xD0,0x6B,0xB5,0x16,0xCB,0x75,0x46},
+	{0x1F,0x08,0x26,0x0D,0x1A,0xC2,0x46,0x5E},
+	{0x58,0x40,0x23,0x64,0x1A,0xBA,0x61,0x76},
+	{0x02,0x58,0x16,0x16,0x46,0x29,0xB0,0x07},
+	{0x49,0x79,0x3E,0xBC,0x79,0xB3,0x25,0x8F},
+	{0x4F,0xB0,0x5E,0x15,0x15,0xAB,0x73,0xA7},
+	{0x49,0xE9,0x5D,0x6D,0x4C,0xA2,0x29,0xBF},
+	{0x01,0x83,0x10,0xDC,0x40,0x9B,0x26,0xD6},
+	{0x1C,0x58,0x7F,0x1C,0x13,0x92,0x4F,0xEF},
+	{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
+	{0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E},
+	{0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10}};
+
+static unsigned char plain_data[NUM_TESTS][8]={
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
+	{0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
+	{0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},
+	{0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0x01,0xA1,0xD6,0xD0,0x39,0x77,0x67,0x42},
+	{0x5C,0xD5,0x4C,0xA8,0x3D,0xEF,0x57,0xDA},
+	{0x02,0x48,0xD4,0x38,0x06,0xF6,0x71,0x72},
+	{0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A},
+	{0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2},
+	{0x05,0x9B,0x5E,0x08,0x51,0xCF,0x14,0x3A},
+	{0x07,0x56,0xD8,0xE0,0x77,0x47,0x61,0xD2},
+	{0x76,0x25,0x14,0xB8,0x29,0xBF,0x48,0x6A},
+	{0x3B,0xDD,0x11,0x90,0x49,0x37,0x28,0x02},
+	{0x26,0x95,0x5F,0x68,0x35,0xAF,0x60,0x9A},
+	{0x16,0x4D,0x5E,0x40,0x4F,0x27,0x52,0x32},
+	{0x6B,0x05,0x6E,0x18,0x75,0x9F,0x5C,0xCA},
+	{0x00,0x4B,0xD6,0xEF,0x09,0x17,0x60,0x62},
+	{0x48,0x0D,0x39,0x00,0x6E,0xE7,0x62,0xF2},
+	{0x43,0x75,0x40,0xC8,0x69,0x8F,0x3C,0xFA},
+	{0x07,0x2D,0x43,0xA0,0x77,0x07,0x52,0x92},
+	{0x02,0xFE,0x55,0x77,0x81,0x17,0xF1,0x2A},
+	{0x1D,0x9D,0x5C,0x50,0x18,0xF7,0x28,0xC2},
+	{0x30,0x55,0x32,0x28,0x6D,0x6F,0x29,0x5A},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF},
+	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}};
+
+static unsigned char cipher_data[NUM_TESTS][8]={
+	{0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7},
+	{0x73,0x59,0xB2,0x16,0x3E,0x4E,0xDC,0x58},
+	{0x95,0x8E,0x6E,0x62,0x7A,0x05,0x55,0x7B},
+	{0xF4,0x03,0x79,0xAB,0x9E,0x0E,0xC5,0x33},
+	{0x17,0x66,0x8D,0xFC,0x72,0x92,0x53,0x2D},
+	{0x8A,0x5A,0xE1,0xF8,0x1A,0xB8,0xF2,0xDD},
+	{0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7},
+	{0xED,0x39,0xD9,0x50,0xFA,0x74,0xBC,0xC4},
+	{0x69,0x0F,0x5B,0x0D,0x9A,0x26,0x93,0x9B},
+	{0x7A,0x38,0x9D,0x10,0x35,0x4B,0xD2,0x71},
+	{0x86,0x8E,0xBB,0x51,0xCA,0xB4,0x59,0x9A},
+	{0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A},
+	{0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95},
+	{0x86,0xA5,0x60,0xF1,0x0E,0xC6,0xD8,0x5B},
+	{0x0C,0xD3,0xDA,0x02,0x00,0x21,0xDC,0x09},
+	{0xEA,0x67,0x6B,0x2C,0xB7,0xDB,0x2B,0x7A},
+	{0xDF,0xD6,0x4A,0x81,0x5C,0xAF,0x1A,0x0F},
+	{0x5C,0x51,0x3C,0x9C,0x48,0x86,0xC0,0x88},
+	{0x0A,0x2A,0xEE,0xAE,0x3F,0xF4,0xAB,0x77},
+	{0xEF,0x1B,0xF0,0x3E,0x5D,0xFA,0x57,0x5A},
+	{0x88,0xBF,0x0D,0xB6,0xD7,0x0D,0xEE,0x56},
+	{0xA1,0xF9,0x91,0x55,0x41,0x02,0x0B,0x56},
+	{0x6F,0xBF,0x1C,0xAF,0xCF,0xFD,0x05,0x56},
+	{0x2F,0x22,0xE4,0x9B,0xAB,0x7C,0xA1,0xAC},
+	{0x5A,0x6B,0x61,0x2C,0xC2,0x6C,0xCE,0x4A},
+	{0x5F,0x4C,0x03,0x8E,0xD1,0x2B,0x2E,0x41},
+	{0x63,0xFA,0xC0,0xD0,0x34,0xD9,0xF7,0x93},
+	{0x61,0x7B,0x3A,0x0C,0xE8,0xF0,0x71,0x00},
+	{0xDB,0x95,0x86,0x05,0xF8,0xC8,0xC6,0x06},
+	{0xED,0xBF,0xD1,0xC6,0x6C,0x29,0xCC,0xC7},
+	{0x35,0x55,0x50,0xB2,0x15,0x0E,0x24,0x51},
+	{0xCA,0xAA,0xAF,0x4D,0xEA,0xF1,0xDB,0xAE},
+	{0xD5,0xD4,0x4F,0xF7,0x20,0x68,0x3D,0x0D},
+	{0x2A,0x2B,0xB0,0x08,0xDF,0x97,0xC2,0xF2}};
+
+static unsigned char cipher_ecb2[NUM_TESTS-1][8]={
+	{0x92,0x95,0xB5,0x9B,0xB3,0x84,0x73,0x6E},
+	{0x19,0x9E,0x9D,0x6D,0xF3,0x9A,0xA8,0x16},
+	{0x2A,0x4B,0x4D,0x24,0x52,0x43,0x84,0x27},
+	{0x35,0x84,0x3C,0x01,0x9D,0x18,0xC5,0xB6},
+	{0x4A,0x5B,0x2F,0x42,0xAA,0x77,0x19,0x25},
+	{0xA0,0x6B,0xA9,0xB8,0xCA,0x5B,0x17,0x8A},
+	{0xAB,0x9D,0xB7,0xFB,0xED,0x95,0xF2,0x74},
+	{0x3D,0x25,0x6C,0x23,0xA7,0x25,0x2F,0xD6},
+	{0xB7,0x6F,0xAB,0x4F,0xBD,0xBD,0xB7,0x67},
+	{0x8F,0x68,0x27,0xD6,0x9C,0xF4,0x1A,0x10},
+	{0x82,0x57,0xA1,0xD6,0x50,0x5E,0x81,0x85},
+	{0xA2,0x0F,0x0A,0xCD,0x80,0x89,0x7D,0xFA},
+	{0xCD,0x2A,0x53,0x3A,0xDB,0x0D,0x7E,0xF3},
+	{0xD2,0xC2,0xBE,0x27,0xE8,0x1B,0x68,0xE3},
+	{0xE9,0x24,0xCF,0x4F,0x89,0x3C,0x5B,0x0A},
+	{0xA7,0x18,0xC3,0x9F,0xFA,0x9F,0xD7,0x69},
+	{0x77,0x2C,0x79,0xB1,0xD2,0x31,0x7E,0xB1},
+	{0x49,0xAB,0x92,0x7F,0xD0,0x22,0x00,0xB7},
+	{0xCE,0x1C,0x6C,0x7D,0x85,0xE3,0x4A,0x6F},
+	{0xBE,0x91,0xD6,0xE1,0x27,0xB2,0xE9,0x87},
+	{0x70,0x28,0xAE,0x8F,0xD1,0xF5,0x74,0x1A},
+	{0xAA,0x37,0x80,0xBB,0xF3,0x22,0x1D,0xDE},
+	{0xA6,0xC4,0xD2,0x5E,0x28,0x93,0xAC,0xB3},
+	{0x22,0x07,0x81,0x5A,0xE4,0xB7,0x1A,0xAD},
+	{0xDC,0xCE,0x05,0xE7,0x07,0xBD,0xF5,0x84},
+	{0x26,0x1D,0x39,0x2C,0xB3,0xBA,0xA5,0x85},
+	{0xB4,0xF7,0x0F,0x72,0xFB,0x04,0xF0,0xDC},
+	{0x95,0xBA,0xA9,0x4E,0x87,0x36,0xF2,0x89},
+	{0xD4,0x07,0x3A,0xF1,0x5A,0x17,0x82,0x0E},
+	{0xEF,0x6F,0xAF,0xA7,0x66,0x1A,0x7E,0x89},
+	{0xC1,0x97,0xF5,0x58,0x74,0x8A,0x20,0xE7},
+	{0x43,0x34,0xCF,0xDA,0x22,0xC4,0x86,0xC8},
+	{0x08,0xD7,0xB4,0xFB,0x62,0x9D,0x08,0x85}};
+
+static unsigned char cbc_key [8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
+static unsigned char cbc2_key[8]={0xf0,0xe1,0xd2,0xc3,0xb4,0xa5,0x96,0x87};
+static unsigned char cbc3_key[8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
+static unsigned char cbc_iv  [8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
+static char cbc_data[40]="7654321 Now is the time for \0001";
+
+static unsigned char cbc_ok[32]={
+	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
+	0xac,0xd8,0xae,0xfd,0xdf,0xd8,0xa1,0xeb,
+	0x46,0x8e,0x91,0x15,0x78,0x88,0xba,0x68,
+	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
+
+static unsigned char xcbc_ok[32]={
+	0x86,0x74,0x81,0x0D,0x61,0xA4,0xA5,0x48,
+	0xB9,0x93,0x03,0xE1,0xB8,0xBB,0xBD,0xBD,
+	0x64,0x30,0x0B,0xB9,0x06,0x65,0x81,0x76,
+	0x04,0x1D,0x77,0x62,0x17,0xCA,0x2B,0xD2,
+	};
+
+static unsigned char cbc3_ok[32]={
+	0x3F,0xE3,0x01,0xC9,0x62,0xAC,0x01,0xD0,
+	0x22,0x13,0x76,0x3C,0x1C,0xBD,0x4C,0xDC,
+	0x79,0x96,0x57,0xC0,0x64,0xEC,0xF5,0xD4,
+	0x1C,0x67,0x38,0x12,0xCF,0xDE,0x96,0x75};
+
+static unsigned char pcbc_ok[32]={
+	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
+	0x6d,0xec,0xb4,0x70,0xa0,0xe5,0x6b,0x15,
+	0xae,0xa6,0xbf,0x61,0xed,0x7d,0x9c,0x9f,
+	0xf7,0x17,0x46,0x3b,0x8a,0xb3,0xcc,0x88};
+
+static unsigned char cfb_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
+static unsigned char cfb_iv[8]={0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};
+static unsigned char cfb_buf1[40],cfb_buf2[40],cfb_tmp[8];
+static unsigned char plain[24]=
+	{
+	0x4e,0x6f,0x77,0x20,0x69,0x73,
+	0x20,0x74,0x68,0x65,0x20,0x74,
+	0x69,0x6d,0x65,0x20,0x66,0x6f,
+	0x72,0x20,0x61,0x6c,0x6c,0x20
+	};
+static unsigned char cfb_cipher8[24]= {
+	0xf3,0x1f,0xda,0x07,0x01,0x14, 0x62,0xee,0x18,0x7f,0x43,0xd8,
+	0x0a,0x7c,0xd9,0xb5,0xb0,0xd2, 0x90,0xda,0x6e,0x5b,0x9a,0x87 };
+static unsigned char cfb_cipher16[24]={
+	0xF3,0x09,0x87,0x87,0x7F,0x57, 0xF7,0x3C,0x36,0xB6,0xDB,0x70,
+	0xD8,0xD5,0x34,0x19,0xD3,0x86, 0xB2,0x23,0xB7,0xB2,0xAD,0x1B };
+static unsigned char cfb_cipher32[24]={
+	0xF3,0x09,0x62,0x49,0xA4,0xDF, 0xA4,0x9F,0x33,0xDC,0x7B,0xAD,
+	0x4C,0xC8,0x9F,0x64,0xE4,0x53, 0xE5,0xEC,0x67,0x20,0xDA,0xB6 };
+static unsigned char cfb_cipher48[24]={
+	0xF3,0x09,0x62,0x49,0xC7,0xF4, 0x30,0xB5,0x15,0xEC,0xBB,0x85,
+	0x97,0x5A,0x13,0x8C,0x68,0x60, 0xE2,0x38,0x34,0x3C,0xDC,0x1F };
+static unsigned char cfb_cipher64[24]={
+	0xF3,0x09,0x62,0x49,0xC7,0xF4, 0x6E,0x51,0xA6,0x9E,0x83,0x9B,
+	0x1A,0x92,0xF7,0x84,0x03,0x46, 0x71,0x33,0x89,0x8E,0xA6,0x22 };
+
+static unsigned char ofb_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
+static unsigned char ofb_iv[8]={0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};
+static unsigned char ofb_buf1[24],ofb_buf2[24],ofb_tmp[8];
+static unsigned char ofb_cipher[24]=
+	{
+	0xf3,0x09,0x62,0x49,0xc7,0xf4,0x6e,0x51,
+	0x35,0xf2,0x4a,0x24,0x2e,0xeb,0x3d,0x3f,
+	0x3d,0x6d,0x5b,0xe3,0x25,0x5a,0xf8,0xc3
+	};
+
+DES_LONG cbc_cksum_ret=0xB462FEF7L;
+unsigned char cbc_cksum_data[8]={0x1D,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
+
+#ifndef NOPROTO
+static char *pt(unsigned char *p);
+static int cfb_test(int bits, unsigned char *cfb_cipher);
+static int cfb64_test(unsigned char *cfb_cipher);
+static int ede_cfb64_test(unsigned char *cfb_cipher);
+#else
+static char *pt();
+static int cfb_test();
+static int cfb64_test();
+static int ede_cfb64_test();
+#endif
+
+int main(argc,argv)
+int argc;
+char *argv[];
+	{
+	int i,j,err=0;
+	des_cblock in,out,outin,iv3;
+	des_key_schedule ks,ks2,ks3;
+	unsigned char cbc_in[40];
+	unsigned char cbc_out[40];
+	DES_LONG cs;
+	unsigned char qret[4][4],cret[8];
+	DES_LONG lqret[4];
+	int num;
+	char *str;
+
+	printf("Doing ecb\n");
+	for (i=0; i<NUM_TESTS; i++)
+		{
+		if ((j=des_key_sched((C_Block *)(key_data[i]),ks)) != 0)
+			{
+			printf("Key error %2d:%d\n",i+1,j);
+			err=1;
+			}
+		memcpy(in,plain_data[i],8);
+		memset(out,0,8);
+		memset(outin,0,8);
+		des_ecb_encrypt((C_Block *)in,(C_Block *)out,ks,DES_ENCRYPT);
+		des_ecb_encrypt((C_Block *)out,(C_Block *)outin,ks,DES_DECRYPT);
+
+		if (memcmp(out,cipher_data[i],8) != 0)
+			{
+			printf("Encryption error %2d\nk=%s p=%s o=%s act=%s\n",
+				i+1,pt(key_data[i]),pt(in),pt(cipher_data[i]),
+				pt(out));
+			err=1;
+			}
+		if (memcmp(in,outin,8) != 0)
+			{
+			printf("Decryption error %2d\nk=%s p=%s o=%s act=%s\n",
+				i+1,pt(key_data[i]),pt(out),pt(in),pt(outin));
+			err=1;
+			}
+		}
+
+#ifndef LIBDES_LIT
+	printf("Doing ede ecb\n");
+	for (i=0; i<(NUM_TESTS-1); i++)
+		{
+		if ((j=des_key_sched((C_Block *)(key_data[i]),ks)) != 0)
+			{
+			err=1;
+			printf("Key error %2d:%d\n",i+1,j);
+			}
+		if ((j=des_key_sched((C_Block *)(key_data[i+1]),ks2)) != 0)
+			{
+			printf("Key error %2d:%d\n",i+2,j);
+			err=1;
+			}
+		if ((j=des_key_sched((C_Block *)(key_data[i+2]),ks3)) != 0)
+			{
+			printf("Key error %2d:%d\n",i+3,j);
+			err=1;
+			}
+		memcpy(in,plain_data[i],8);
+		memset(out,0,8);
+		memset(outin,0,8);
+		des_ecb2_encrypt((C_Block *)in,(C_Block *)out,ks,ks2,
+			DES_ENCRYPT);
+		des_ecb2_encrypt((C_Block *)out,(C_Block *)outin,ks,ks2,
+			DES_DECRYPT);
+
+		if (memcmp(out,cipher_ecb2[i],8) != 0)
+			{
+			printf("Encryption error %2d\nk=%s p=%s o=%s act=%s\n",
+				i+1,pt(key_data[i]),pt(in),pt(cipher_ecb2[i]),
+				pt(out));
+			err=1;
+			}
+		if (memcmp(in,outin,8) != 0)
+			{
+			printf("Decryption error %2d\nk=%s p=%s o=%s act=%s\n",
+				i+1,pt(key_data[i]),pt(out),pt(in),pt(outin));
+			err=1;
+			}
+		}
+#endif
+
+	printf("Doing cbc\n");
+	if ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	memset(cbc_out,0,40);
+	memset(cbc_in,0,40);
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+	des_ncbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
+		(long)strlen((char *)cbc_data)+1,ks,
+		(C_Block *)iv3,DES_ENCRYPT);
+	if (memcmp(cbc_out,cbc_ok,32) != 0)
+		printf("cbc_encrypt encrypt error\n");
+
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+	des_ncbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
+		(long)strlen((char *)cbc_data)+1,ks,
+		(C_Block *)iv3,DES_DECRYPT);
+	if (memcmp(cbc_in,cbc_data,strlen((char *)cbc_data)) != 0)
+		{
+		printf("cbc_encrypt decrypt error\n");
+		err=1;
+		}
+
+#ifndef LIBDES_LIT
+	printf("Doing desx cbc\n");
+	if ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	memset(cbc_out,0,40);
+	memset(cbc_in,0,40);
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+	des_xcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
+		(long)strlen((char *)cbc_data)+1,ks,
+		(C_Block *)iv3,
+		(C_Block *)cbc2_key, (C_Block *)cbc3_key, DES_ENCRYPT);
+	if (memcmp(cbc_out,xcbc_ok,32) != 0)
+		{
+		printf("des_xcbc_encrypt encrypt error\n");
+		}
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+	des_xcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
+		(long)strlen((char *)cbc_data)+1,ks,
+		(C_Block *)iv3,
+		(C_Block *)cbc2_key, (C_Block *)cbc3_key, DES_DECRYPT);
+	if (memcmp(cbc_in,cbc_data,strlen((char *)cbc_data)+1) != 0)
+		{
+		printf("des_xcbc_encrypt decrypt error\n");
+		err=1;
+		}
+#endif
+
+	printf("Doing ede cbc\n");
+	if ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	if ((j=des_key_sched((C_Block *)cbc2_key,ks2)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	if ((j=des_key_sched((C_Block *)cbc3_key,ks3)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	memset(cbc_out,0,40);
+	memset(cbc_in,0,40);
+	i=strlen((char *)cbc_data)+1;
+	/* i=((i+7)/8)*8; */
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+
+	des_ede3_cbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
+		16L,ks,ks2,ks3,(C_Block *)iv3,DES_ENCRYPT);
+	des_ede3_cbc_encrypt((C_Block *)&(cbc_data[16]),
+		(C_Block *)&(cbc_out[16]),
+		(long)i-16,ks,ks2,ks3,(C_Block *)iv3,DES_ENCRYPT);
+	if (memcmp(cbc_out,cbc3_ok,
+		(unsigned int)(strlen((char *)cbc_data)+1+7)/8*8) != 0)
+		{
+		printf("des_ede3_cbc_encrypt encrypt error\n");
+		err=1;
+		}
+
+	memcpy(iv3,cbc_iv,sizeof(cbc_iv));
+	des_ede3_cbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
+		(long)i,ks,ks2,ks3,(C_Block *)iv3,DES_DECRYPT);
+	if (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)
+		{
+		printf("des_ede3_cbc_encrypt decrypt error\n");
+		err=1;
+		}
+
+#ifndef LIBDES_LIT
+	printf("Doing pcbc\n");
+	if ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)
+		{
+		printf("Key error %d\n",j);
+		err=1;
+		}
+	memset(cbc_out,0,40);
+	memset(cbc_in,0,40);
+	des_pcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
+		(long)strlen(cbc_data)+1,ks,(C_Block *)cbc_iv,DES_ENCRYPT);
+	if (memcmp(cbc_out,pcbc_ok,32) != 0)
+		{
+		printf("pcbc_encrypt encrypt error\n");
+		err=1;
+		}
+	des_pcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
+		(long)strlen(cbc_data)+1,ks,(C_Block *)cbc_iv,DES_DECRYPT);
+	if (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)
+		{
+		printf("pcbc_encrypt decrypt error\n");
+		err=1;
+		}
+
+	printf("Doing ");
+	printf("cfb8 ");
+	err+=cfb_test(8,cfb_cipher8);
+	printf("cfb16 ");
+	err+=cfb_test(16,cfb_cipher16);
+	printf("cfb32 ");
+	err+=cfb_test(32,cfb_cipher32);
+	printf("cfb48 ");
+	err+=cfb_test(48,cfb_cipher48);
+	printf("cfb64 ");
+	err+=cfb_test(64,cfb_cipher64);
+
+	printf("cfb64() ");
+	err+=cfb64_test(cfb_cipher64);
+
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	for (i=0; i<sizeof(plain); i++)
+		des_cfb_encrypt(&(plain[i]),&(cfb_buf1[i]),
+			8,(long)1,ks,(C_Block *)cfb_tmp,DES_ENCRYPT);
+	if (memcmp(cfb_cipher8,cfb_buf1,sizeof(plain)) != 0)
+		{
+		printf("cfb_encrypt small encrypt error\n");
+		err=1;
+		}
+
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	for (i=0; i<sizeof(plain); i++)
+		des_cfb_encrypt(&(cfb_buf1[i]),&(cfb_buf2[i]),
+			8,(long)1,ks,(C_Block *)cfb_tmp,DES_DECRYPT);
+	if (memcmp(plain,cfb_buf2,sizeof(plain)) != 0)
+		{
+		printf("cfb_encrypt small decrypt error\n");
+		err=1;
+		}
+
+	printf("ede_cfb64() ");
+	err+=ede_cfb64_test(cfb_cipher64);
+
+	printf("done\n");
+
+	printf("Doing ofb\n");
+	des_key_sched((C_Block *)ofb_key,ks);
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	des_ofb_encrypt(plain,ofb_buf1,64,(long)sizeof(plain)/8,ks,
+		(C_Block *)ofb_tmp);
+	if (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)
+		{
+		printf("ofb_encrypt encrypt error\n");
+printf("%02X %02X %02X %02X %02X %02X %02X %02X\n",
+ofb_buf1[8+0], ofb_buf1[8+1], ofb_buf1[8+2], ofb_buf1[8+3],
+ofb_buf1[8+4], ofb_buf1[8+5], ofb_buf1[8+6], ofb_buf1[8+7]);
+printf("%02X %02X %02X %02X %02X %02X %02X %02X\n",
+ofb_buf1[8+0], ofb_cipher[8+1], ofb_cipher[8+2], ofb_cipher[8+3],
+ofb_buf1[8+4], ofb_cipher[8+5], ofb_cipher[8+6], ofb_cipher[8+7]);
+		err=1;
+		}
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	des_ofb_encrypt(ofb_buf1,ofb_buf2,64,(long)sizeof(ofb_buf1)/8,ks,
+		(C_Block *)ofb_tmp);
+	if (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)
+		{
+		printf("ofb_encrypt decrypt error\n");
+printf("%02X %02X %02X %02X %02X %02X %02X %02X\n",
+ofb_buf2[8+0], ofb_buf2[8+1], ofb_buf2[8+2], ofb_buf2[8+3],
+ofb_buf2[8+4], ofb_buf2[8+5], ofb_buf2[8+6], ofb_buf2[8+7]);
+printf("%02X %02X %02X %02X %02X %02X %02X %02X\n",
+plain[8+0], plain[8+1], plain[8+2], plain[8+3],
+plain[8+4], plain[8+5], plain[8+6], plain[8+7]);
+		err=1;
+		}
+
+	printf("Doing ofb64\n");
+	des_key_sched((C_Block *)ofb_key,ks);
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	memset(ofb_buf1,0,sizeof(ofb_buf1));
+	memset(ofb_buf2,0,sizeof(ofb_buf1));
+	num=0;
+	for (i=0; i<sizeof(plain); i++)
+		{
+		des_ofb64_encrypt(&(plain[i]),&(ofb_buf1[i]),1,ks,
+			(C_Block *)ofb_tmp,&num);
+		}
+	if (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)
+		{
+		printf("ofb64_encrypt encrypt error\n");
+		err=1;
+		}
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	num=0;
+	des_ofb64_encrypt(ofb_buf1,ofb_buf2,(long)sizeof(ofb_buf1),ks,
+		(C_Block *)ofb_tmp,&num);
+	if (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)
+		{
+		printf("ofb64_encrypt decrypt error\n");
+		err=1;
+		}
+
+	printf("Doing ede_ofb64\n");
+	des_key_sched((C_Block *)ofb_key,ks);
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	memset(ofb_buf1,0,sizeof(ofb_buf1));
+	memset(ofb_buf2,0,sizeof(ofb_buf1));
+	num=0;
+	for (i=0; i<sizeof(plain); i++)
+		{
+		des_ede3_ofb64_encrypt(&(plain[i]),&(ofb_buf1[i]),1,ks,ks,ks,
+			(C_Block *)ofb_tmp,&num);
+		}
+	if (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)
+		{
+		printf("ede_ofb64_encrypt encrypt error\n");
+		err=1;
+		}
+	memcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));
+	num=0;
+	des_ede3_ofb64_encrypt(ofb_buf1,ofb_buf2,(long)sizeof(ofb_buf1),ks,
+		ks,ks,(C_Block *)ofb_tmp,&num);
+	if (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)
+		{
+		printf("ede_ofb64_encrypt decrypt error\n");
+		err=1;
+		}
+
+	printf("Doing cbc_cksum\n");
+	des_key_sched((C_Block *)cbc_key,ks);
+	cs=des_cbc_cksum((C_Block *)cbc_data,(C_Block *)cret,
+		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv);
+	if (cs != cbc_cksum_ret)
+		{
+		printf("bad return value (%08lX), should be %08lX\n",
+			(unsigned long)cs,(unsigned long)cbc_cksum_ret);
+		err=1;
+		}
+	if (memcmp(cret,cbc_cksum_data,8) != 0)
+		{
+		printf("bad cbc_cksum block returned\n");
+		err=1;
+		}
+
+	printf("Doing quad_cksum\n");
+	cs=quad_cksum((C_Block *)cbc_data,(C_Block *)qret,
+		(long)strlen(cbc_data),2,(C_Block *)cbc_iv);
+	for (i=0; i<4; i++)
+		{
+		lqret[i]=0;
+		memcpy(&(lqret[i]),&(qret[i][0]),4);
+		}
+	{ /* Big-endian fix */
+	static DES_LONG l=1;
+	static unsigned char *c=(unsigned char *)&l;
+	DES_LONG ll;
+
+	if (!c[0])
+		{
+		ll=lqret[0]^lqret[3];
+		lqret[0]^=ll;
+		lqret[3]^=ll;
+		ll=lqret[1]^lqret[2];
+		lqret[1]^=ll;
+		lqret[2]^=ll;
+		}
+	}
+	if (cs != 0x70d7a63aL)
+		{
+		printf("quad_cksum error, ret %08lx should be 70d7a63a\n",
+			(unsigned long)cs);
+		err=1;
+		}
+	if (lqret[0] != 0x327eba8dL)
+		{
+		printf("quad_cksum error, out[0] %08lx is not %08lx\n",
+			(unsigned long)lqret[0],0x327eba8dL);
+		err=1;
+		}
+	if (lqret[1] != 0x201a49ccL)
+		{
+		printf("quad_cksum error, out[1] %08lx is not %08lx\n",
+			(unsigned long)lqret[1],0x201a49ccL);
+		err=1;
+		}
+	if (lqret[2] != 0x70d7a63aL)
+		{
+		printf("quad_cksum error, out[2] %08lx is not %08lx\n",
+			(unsigned long)lqret[2],0x70d7a63aL);
+		err=1;
+		}
+	if (lqret[3] != 0x501c2c26L)
+		{
+		printf("quad_cksum error, out[3] %08lx is not %08lx\n",
+			(unsigned long)lqret[3],0x501c2c26L);
+		err=1;
+		}
+#endif
+
+	printf("input word alignment test");
+	for (i=0; i<4; i++)
+		{
+		printf(" %d",i);
+		des_ncbc_encrypt((C_Block *)&(cbc_out[i]),(C_Block *)cbc_in,
+			(long)strlen(cbc_data)+1,ks,(C_Block *)cbc_iv,
+			DES_ENCRYPT);
+		}
+	printf("\noutput word alignment test");
+	for (i=0; i<4; i++)
+		{
+		printf(" %d",i);
+		des_ncbc_encrypt((C_Block *)cbc_out,(C_Block *)&(cbc_in[i]),
+			(long)strlen(cbc_data)+1,ks,(C_Block *)cbc_iv,
+			DES_ENCRYPT);
+		}
+	printf("\n");
+	printf("fast crypt test ");
+	str=crypt("testing","ef");
+	if (strcmp("efGnQx2725bI2",str) != 0)
+		{
+		printf("fast crypt error, %s should be efGnQx2725bI2\n",str);
+		err=1;
+		}
+	str=crypt("bca76;23","yA");
+	if (strcmp("yA1Rp/1hZXIJk",str) != 0)
+		{
+		printf("fast crypt error, %s should be yA1Rp/1hZXIJk\n",str);
+		err=1;
+		}
+	printf("\n");
+	exit(err);
+	return(0);
+	}
+
+static char *pt(p)
+unsigned char *p;
+	{
+	static char bufs[10][20];
+	static int bnum=0;
+	char *ret;
+	int i;
+	static char *f="0123456789ABCDEF";
+
+	ret= &(bufs[bnum++][0]);
+	bnum%=10;
+	for (i=0; i<8; i++)
+		{
+		ret[i*2]=f[(p[i]>>4)&0xf];
+		ret[i*2+1]=f[p[i]&0xf];
+		}
+	ret[16]='\0';
+	return(ret);
+	}
+
+#ifndef LIBDES_LIT
+
+static int cfb_test(bits, cfb_cipher)
+int bits;
+unsigned char *cfb_cipher;
+	{
+	des_key_schedule ks;
+	int i,err=0;
+
+	des_key_sched((C_Block *)cfb_key,ks);
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	des_cfb_encrypt(plain,cfb_buf1,bits,(long)sizeof(plain),ks,
+		(C_Block *)cfb_tmp,DES_ENCRYPT);
+	if (memcmp(cfb_cipher,cfb_buf1,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("cfb_encrypt encrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf1[i])));
+		}
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	des_cfb_encrypt(cfb_buf1,cfb_buf2,bits,(long)sizeof(plain),ks,
+		(C_Block *)cfb_tmp,DES_DECRYPT);
+	if (memcmp(plain,cfb_buf2,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("cfb_encrypt decrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf1[i])));
+		}
+	return(err);
+	}
+
+static int cfb64_test(cfb_cipher)
+unsigned char *cfb_cipher;
+	{
+	des_key_schedule ks;
+	int err=0,i,n;
+
+	des_key_sched((C_Block *)cfb_key,ks);
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	n=0;
+	des_cfb64_encrypt(plain,cfb_buf1,(long)12,ks,
+		(C_Block *)cfb_tmp,&n,DES_ENCRYPT);
+	des_cfb64_encrypt(&(plain[12]),&(cfb_buf1[12]),
+		(long)sizeof(plain)-12,ks,
+		(C_Block *)cfb_tmp,&n,DES_ENCRYPT);
+	if (memcmp(cfb_cipher,cfb_buf1,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("cfb_encrypt encrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf1[i])));
+		}
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	n=0;
+	des_cfb64_encrypt(cfb_buf1,cfb_buf2,(long)17,ks,
+		(C_Block *)cfb_tmp,&n,DES_DECRYPT);
+	des_cfb64_encrypt(&(cfb_buf1[17]),&(cfb_buf2[17]),
+		(long)sizeof(plain)-17,ks,
+		(C_Block *)cfb_tmp,&n,DES_DECRYPT);
+	if (memcmp(plain,cfb_buf2,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("cfb_encrypt decrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf2[i])));
+		}
+	return(err);
+	}
+
+static int ede_cfb64_test(cfb_cipher)
+unsigned char *cfb_cipher;
+	{
+	des_key_schedule ks;
+	int err=0,i,n;
+
+	des_key_sched((C_Block *)cfb_key,ks);
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	n=0;
+	des_ede3_cfb64_encrypt(plain,cfb_buf1,(long)12,ks,ks,ks,
+		(C_Block *)cfb_tmp,&n,DES_ENCRYPT);
+	des_ede3_cfb64_encrypt(&(plain[12]),&(cfb_buf1[12]),
+		(long)sizeof(plain)-12,ks,ks,ks,
+		(C_Block *)cfb_tmp,&n,DES_ENCRYPT);
+	if (memcmp(cfb_cipher,cfb_buf1,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("ede_cfb_encrypt encrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf1[i])));
+		}
+	memcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));
+	n=0;
+	des_ede3_cfb64_encrypt(cfb_buf1,cfb_buf2,(long)17,ks,ks,ks,
+		(C_Block *)cfb_tmp,&n,DES_DECRYPT);
+	des_ede3_cfb64_encrypt(&(cfb_buf1[17]),&(cfb_buf2[17]),
+		(long)sizeof(plain)-17,ks,ks,ks,
+		(C_Block *)cfb_tmp,&n,DES_DECRYPT);
+	if (memcmp(plain,cfb_buf2,sizeof(plain)) != 0)
+		{
+		err=1;
+		printf("ede_cfb_encrypt decrypt error\n");
+		for (i=0; i<24; i+=8)
+			printf("%s\n",pt(&(cfb_buf2[i])));
+		}
+	return(err);
+	}
+
+#endif
+
diff -druN linux-noipsec/net/ipsec/libdes/ecb_enc.c linux/net/ipsec/libdes/ecb_enc.c
--- linux-noipsec/net/ipsec/libdes/ecb_enc.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/ecb_enc.c	Tue Apr  6 00:02:01 1999
@@ -0,0 +1,128 @@
+/* crypto/des/ecb_enc.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include "des_locl.h"
+#include "spr.h"
+
+char *libdes_version="libdes v 3.24 - 20-Apr-1996 - eay";
+char *DES_version="DES part of SSLeay 0.8.2b 08-Jan-1998";
+
+/* RCSID $Id$ */
+/* This function ifdef'ed out for FreeS/WAN project. */
+#ifdef notdef
+char *des_options()
+	{
+	static int init=1;
+	static char buf[32];
+
+	if (init)
+		{
+		char *ptr,*unroll,*risc,*size;
+
+		init=0;
+#ifdef DES_PTR
+		ptr="ptr";
+#else
+		ptr="idx";
+#endif
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+		risc="risc1";
+#endif
+#ifdef DES_RISC2
+		risc="risc2";
+#endif
+#else
+		risc="cisc";
+#endif
+#ifdef DES_UNROLL
+		unroll="16";
+#else
+		unroll="4";
+#endif
+		if (sizeof(DES_LONG) != sizeof(long))
+			size="int";
+		else
+			size="long";
+		sprintf(buf,"des(%s,%s,%s,%s)",ptr,risc,unroll,size);
+		}
+	return(buf);
+	}
+#endif
+		
+
+void des_ecb_encrypt(input, output, ks, enc)
+des_cblock (*input);
+des_cblock (*output);
+des_key_schedule ks;
+int enc;
+	{
+	register DES_LONG l;
+	register unsigned char *in,*out;
+	DES_LONG ll[2];
+
+	in=(unsigned char *)input;
+	out=(unsigned char *)output;
+	c2l(in,l); ll[0]=l;
+	c2l(in,l); ll[1]=l;
+	des_encrypt(ll,ks,enc);
+	l=ll[0]; l2c(l,out);
+	l=ll[1]; l2c(l,out);
+	l=ll[0]=ll[1]=0;
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/fcrypt.c linux/net/ipsec/libdes/fcrypt.c
--- linux-noipsec/net/ipsec/libdes/fcrypt.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/fcrypt.c	Wed Oct  4 16:54:11 2000
@@ -0,0 +1,152 @@
+/* NOCW */
+
+/* This version of crypt has been developed from my MIT compatable
+ * DES library.
+ * The library is available at pub/Crypto/DES at ftp.psy.uq.oz.au
+ * Eric Young (eay@cryptsoft.com)
+ */
+
+/* Modification by Jens Kupferschmidt (Cu)
+ * I have included directive PARA for shared memory computers.
+ * I have included a directive LONGCRYPT to using this routine to cipher
+ * passwords with more then 8 bytes like HP-UX 10.x it used. The MAXPLEN
+ * definition is the maximum of lenght of password and can changed. I have
+ * defined 24.
+ */
+
+#include "des_locl.h"
+
+/* Added more values to handle illegal salt values the way normal
+ * crypt() implementations do.  The patch was sent by 
+ * Bjorn Gronvall <bg@sics.se>
+ */
+static unsigned const char con_salt[128]={
+0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
+0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,
+0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,
+0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,
+0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,
+0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,0x00,0x01,
+0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+0x0A,0x0B,0x05,0x06,0x07,0x08,0x09,0x0A,
+0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,
+0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,
+0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,
+0x23,0x24,0x25,0x20,0x21,0x22,0x23,0x24,
+0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,
+0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,
+0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,
+0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,
+};
+
+static unsigned const char cov_2char[64]={
+0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,
+0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,
+0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,
+0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,
+0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
+0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
+0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,
+0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A
+};
+
+#ifndef NOPROTO
+void fcrypt_body(DES_LONG *out,des_key_schedule ks,
+	DES_LONG Eswap0, DES_LONG Eswap1);
+
+#ifdef PERL5
+char *des_crypt(const char *buf,const char *salt);
+#else
+char *crypt(const char *buf,const char *salt);
+#endif
+#else
+void fcrypt_body();
+#ifdef PERL5
+char *des_crypt();
+#else
+char *crypt();
+#endif
+#endif
+
+#ifdef PERL5
+char *des_crypt(buf,salt)
+#else
+char *crypt(buf,salt)
+#endif
+const char *buf;
+const char *salt;
+	{
+	static char buff[14];
+
+	return(des_fcrypt(buf,salt,buff));
+	}
+
+
+char *des_fcrypt(buf,salt,ret)
+const char *buf;
+const char *salt;
+char *ret;
+	{
+	unsigned int i,j,x,y;
+	DES_LONG Eswap0,Eswap1;
+	DES_LONG out[2],ll;
+	des_cblock key;
+	des_key_schedule ks;
+	unsigned char bb[9];
+	unsigned char *b=bb;
+	unsigned char c,u;
+
+	/* eay 25/08/92
+	 * If you call crypt("pwd","*") as often happens when you
+	 * have * as the pwd field in /etc/passwd, the function
+	 * returns *\0XXXXXXXXX
+	 * The \0 makes the string look like * so the pwd "*" would
+	 * crypt to "*".  This was found when replacing the crypt in
+	 * our shared libraries.  People found that the disbled
+	 * accounts effectivly had no passwd :-(. */
+	x=ret[0]=((salt[0] == '\0')?'A':salt[0]);
+	Eswap0=con_salt[x]<<2;
+	x=ret[1]=((salt[1] == '\0')?'A':salt[1]);
+	Eswap1=con_salt[x]<<6;
+
+/* EAY
+r=strlen(buf);
+r=(r+7)/8;
+*/
+	for (i=0; i<8; i++)
+		{
+		c= *(buf++);
+		if (!c) break;
+		key[i]=(c<<1);
+		}
+	for (; i<8; i++)
+		key[i]=0;
+
+	des_set_key((des_cblock *)(key),ks);
+	fcrypt_body(&(out[0]),ks,Eswap0,Eswap1);
+
+	ll=out[0]; l2c(ll,b);
+	ll=out[1]; l2c(ll,b);
+	y=0;
+	u=0x80;
+	bb[8]=0;
+	for (i=2; i<13; i++)
+		{
+		c=0;
+		for (j=0; j<6; j++)
+			{
+			c<<=1;
+			if (bb[y] & u) c|=1;
+			u>>=1;
+			if (!u)
+				{
+				y++;
+				u=0x80;
+				}
+			}
+		ret[i]=cov_2char[c];
+		}
+	ret[13]='\0';
+	return(ret);
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/fcrypt_b.c linux/net/ipsec/libdes/fcrypt_b.c
--- linux-noipsec/net/ipsec/libdes/fcrypt_b.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/fcrypt_b.c	Thu Feb 18 17:41:14 1999
@@ -0,0 +1,148 @@
+/* crypto/des/fcrypt_b.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+
+/* This version of crypt has been developed from my MIT compatable
+ * DES library.
+ * The library is available at pub/Crypto/DES at ftp.psy.uq.oz.au
+ * Eric Young (eay@cryptsoft.com)
+ */
+
+#define DES_FCRYPT
+#include "des_locl.h"
+#undef DES_FCRYPT
+
+#undef PERM_OP
+#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+	(b)^=(t),\
+	(a)^=((t)<<(n)))
+
+#undef HPERM_OP
+#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
+	(a)=(a)^(t)^(t>>(16-(n))))\
+
+void fcrypt_body(out, ks, Eswap0, Eswap1)
+DES_LONG *out;
+des_key_schedule ks;
+DES_LONG Eswap0;
+DES_LONG Eswap1;
+	{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register unsigned char *des_SP=(unsigned char *)des_SPtrans;
+#endif
+	register DES_LONG *s;
+	register int j;
+	register DES_LONG E0,E1;
+
+	l=0;
+	r=0;
+
+	s=(DES_LONG *)ks;
+	E0=Eswap0;
+	E1=Eswap1;
+
+	for (j=0; j<25; j++)
+		{
+#ifdef DES_UNROLL
+		register int i;
+
+		for (i=0; i<32; i+=8)
+			{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  1 */
+			D_ENCRYPT(r,l,i+6); /*  2 */
+			}
+#else
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#endif
+
+		t=l;
+		l=r;
+		r=t;
+		}
+	l=ROTATE(l,3)&0xffffffffL;
+	r=ROTATE(r,3)&0xffffffffL;
+
+	PERM_OP(l,r,t, 1,0x55555555L);
+	PERM_OP(r,l,t, 8,0x00ff00ffL);
+	PERM_OP(l,r,t, 2,0x33333333L);
+	PERM_OP(r,l,t,16,0x0000ffffL);
+	PERM_OP(l,r,t, 4,0x0f0f0f0fL);
+
+	out[0]=r;
+	out[1]=l;
+	}
+
diff -druN linux-noipsec/net/ipsec/libdes/podd.h linux/net/ipsec/libdes/podd.h
--- linux-noipsec/net/ipsec/libdes/podd.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/podd.h	Thu Feb 18 17:41:15 1999
@@ -0,0 +1,75 @@
+/* crypto/des/podd.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+static const unsigned char odd_parity[256]={
+  1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
+ 16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
+ 32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
+ 49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
+ 64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
+ 81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
+ 97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
+112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
+128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
+145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
+161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
+176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
+193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
+208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
+224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
+241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};
diff -druN linux-noipsec/net/ipsec/libdes/set_key.c linux/net/ipsec/libdes/set_key.c
--- linux-noipsec/net/ipsec/libdes/set_key.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/set_key.c	Thu Feb 18 17:41:15 1999
@@ -0,0 +1,246 @@
+/* crypto/des/set_key.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* set_key.c v 1.4 eay 24/9/91
+ * 1.4 Speed up by 400% :-)
+ * 1.3 added register declarations.
+ * 1.2 unrolled make_key_sched a bit more
+ * 1.1 added norm_expand_bits
+ * 1.0 First working version
+ */
+#include "des_locl.h"
+#include "podd.h"
+#include "sk.h"
+
+#ifndef NOPROTO
+static int check_parity(des_cblock (*key));
+#else
+static int check_parity();
+#endif
+
+int des_check_key=0;
+
+void des_set_odd_parity(key)
+des_cblock (*key);
+	{
+	int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+		(*key)[i]=odd_parity[(*key)[i]];
+	}
+
+static int check_parity(key)
+des_cblock (*key);
+	{
+	int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+		{
+		if ((*key)[i] != odd_parity[(*key)[i]])
+			return(0);
+		}
+	return(1);
+	}
+
+/* Weak and semi week keys as take from
+ * %A D.W. Davies
+ * %A W.L. Price
+ * %T Security for Computer Networks
+ * %I John Wiley & Sons
+ * %D 1984
+ * Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
+ * (and actual cblock values).
+ */
+#define NUM_WEAK_KEY	16
+static des_cblock weak_keys[NUM_WEAK_KEY]={
+	/* weak keys */
+	{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
+	{0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE},
+	{0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F},
+	{0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0},
+	/* semi-weak keys */
+	{0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE},
+	{0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01},
+	{0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1},
+	{0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E},
+	{0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1},
+	{0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01},
+	{0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE},
+	{0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E},
+	{0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E},
+	{0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01},
+	{0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE},
+	{0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1}};
+
+int des_is_weak_key(key)
+des_cblock (*key);
+	{
+	int i;
+
+	for (i=0; i<NUM_WEAK_KEY; i++)
+		/* Added == 0 to comparision, I obviously don't run
+		 * this section very often :-(, thanks to
+		 * engineering@MorningStar.Com for the fix
+		 * eay 93/06/29
+		 * Another problem, I was comparing only the first 4
+		 * bytes, 97/03/18 */
+		if (memcmp(weak_keys[i],key,sizeof(des_cblock)) == 0) return(1);
+	return(0);
+	}
+
+/* NOW DEFINED IN des_local.h
+ * See ecb_encrypt.c for a pseudo description of these macros. 
+ * #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+ * 	(b)^=(t),\
+ * 	(a)=((a)^((t)<<(n))))
+ */
+
+#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
+	(a)=(a)^(t)^(t>>(16-(n))))
+
+/* return 0 if key parity is odd (correct),
+ * return -1 if key parity error,
+ * return -2 if illegal weak key.
+ */
+int des_set_key(key, schedule)
+des_cblock (*key);
+des_key_schedule schedule;
+	{
+	static int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
+	register DES_LONG c,d,t,s,t2;
+	register unsigned char *in;
+	register DES_LONG *k;
+	register int i;
+
+	if (des_check_key)
+		{
+		if (!check_parity(key))
+			return(-1);
+
+		if (des_is_weak_key(key))
+			return(-2);
+		}
+
+	k=(DES_LONG *)schedule;
+	in=(unsigned char *)key;
+
+	c2l(in,c);
+	c2l(in,d);
+
+	/* do PC1 in 60 simple operations */ 
+/*	PERM_OP(d,c,t,4,0x0f0f0f0fL);
+	HPERM_OP(c,t,-2, 0xcccc0000L);
+	HPERM_OP(c,t,-1, 0xaaaa0000L);
+	HPERM_OP(c,t, 8, 0x00ff0000L);
+	HPERM_OP(c,t,-1, 0xaaaa0000L);
+	HPERM_OP(d,t,-8, 0xff000000L);
+	HPERM_OP(d,t, 8, 0x00ff0000L);
+	HPERM_OP(d,t, 2, 0x33330000L);
+	d=((d&0x00aa00aaL)<<7L)|((d&0x55005500L)>>7L)|(d&0xaa55aa55L);
+	d=(d>>8)|((c&0xf0000000L)>>4);
+	c&=0x0fffffffL; */
+
+	/* I now do it in 47 simple operations :-)
+	 * Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
+	 * for the inspiration. :-) */
+	PERM_OP (d,c,t,4,0x0f0f0f0fL);
+	HPERM_OP(c,t,-2,0xcccc0000L);
+	HPERM_OP(d,t,-2,0xcccc0000L);
+	PERM_OP (d,c,t,1,0x55555555L);
+	PERM_OP (c,d,t,8,0x00ff00ffL);
+	PERM_OP (d,c,t,1,0x55555555L);
+	d=	(((d&0x000000ffL)<<16L)| (d&0x0000ff00L)     |
+		 ((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));
+	c&=0x0fffffffL;
+
+	for (i=0; i<ITERATIONS; i++)
+		{
+		if (shifts2[i])
+			{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }
+		else
+			{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }
+		c&=0x0fffffffL;
+		d&=0x0fffffffL;
+		/* could be a few less shifts but I am to lazy at this
+		 * point in time to investigate */
+		s=	des_skb[0][ (c    )&0x3f                ]|
+			des_skb[1][((c>> 6)&0x03)|((c>> 7L)&0x3c)]|
+			des_skb[2][((c>>13)&0x0f)|((c>>14L)&0x30)]|
+			des_skb[3][((c>>20)&0x01)|((c>>21L)&0x06) |
+						  ((c>>22L)&0x38)];
+		t=	des_skb[4][ (d    )&0x3f                ]|
+			des_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|
+			des_skb[6][ (d>>15L)&0x3f                ]|
+			des_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];
+
+		/* table contained 0213 4657 */
+		t2=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;
+		*(k++)=ROTATE(t2,30)&0xffffffffL;
+
+		t2=((s>>16L)|(t&0xffff0000L));
+		*(k++)=ROTATE(t2,26)&0xffffffffL;
+		}
+	return(0);
+	}
+
+int des_key_sched(key, schedule)
+des_cblock (*key);
+des_key_schedule schedule;
+	{
+	return(des_set_key(key,schedule));
+	}
diff -druN linux-noipsec/net/ipsec/libdes/sk.h linux/net/ipsec/libdes/sk.h
--- linux-noipsec/net/ipsec/libdes/sk.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/sk.h	Thu Feb 18 17:41:16 1999
@@ -0,0 +1,204 @@
+/* crypto/des/sk.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+static const DES_LONG des_skb[8][64]={
+{
+/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+0x00000000L,0x00000010L,0x20000000L,0x20000010L,
+0x00010000L,0x00010010L,0x20010000L,0x20010010L,
+0x00000800L,0x00000810L,0x20000800L,0x20000810L,
+0x00010800L,0x00010810L,0x20010800L,0x20010810L,
+0x00000020L,0x00000030L,0x20000020L,0x20000030L,
+0x00010020L,0x00010030L,0x20010020L,0x20010030L,
+0x00000820L,0x00000830L,0x20000820L,0x20000830L,
+0x00010820L,0x00010830L,0x20010820L,0x20010830L,
+0x00080000L,0x00080010L,0x20080000L,0x20080010L,
+0x00090000L,0x00090010L,0x20090000L,0x20090010L,
+0x00080800L,0x00080810L,0x20080800L,0x20080810L,
+0x00090800L,0x00090810L,0x20090800L,0x20090810L,
+0x00080020L,0x00080030L,0x20080020L,0x20080030L,
+0x00090020L,0x00090030L,0x20090020L,0x20090030L,
+0x00080820L,0x00080830L,0x20080820L,0x20080830L,
+0x00090820L,0x00090830L,0x20090820L,0x20090830L,
+},{
+/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
+0x00000000L,0x02000000L,0x00002000L,0x02002000L,
+0x00200000L,0x02200000L,0x00202000L,0x02202000L,
+0x00000004L,0x02000004L,0x00002004L,0x02002004L,
+0x00200004L,0x02200004L,0x00202004L,0x02202004L,
+0x00000400L,0x02000400L,0x00002400L,0x02002400L,
+0x00200400L,0x02200400L,0x00202400L,0x02202400L,
+0x00000404L,0x02000404L,0x00002404L,0x02002404L,
+0x00200404L,0x02200404L,0x00202404L,0x02202404L,
+0x10000000L,0x12000000L,0x10002000L,0x12002000L,
+0x10200000L,0x12200000L,0x10202000L,0x12202000L,
+0x10000004L,0x12000004L,0x10002004L,0x12002004L,
+0x10200004L,0x12200004L,0x10202004L,0x12202004L,
+0x10000400L,0x12000400L,0x10002400L,0x12002400L,
+0x10200400L,0x12200400L,0x10202400L,0x12202400L,
+0x10000404L,0x12000404L,0x10002404L,0x12002404L,
+0x10200404L,0x12200404L,0x10202404L,0x12202404L,
+},{
+/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
+0x00000000L,0x00000001L,0x00040000L,0x00040001L,
+0x01000000L,0x01000001L,0x01040000L,0x01040001L,
+0x00000002L,0x00000003L,0x00040002L,0x00040003L,
+0x01000002L,0x01000003L,0x01040002L,0x01040003L,
+0x00000200L,0x00000201L,0x00040200L,0x00040201L,
+0x01000200L,0x01000201L,0x01040200L,0x01040201L,
+0x00000202L,0x00000203L,0x00040202L,0x00040203L,
+0x01000202L,0x01000203L,0x01040202L,0x01040203L,
+0x08000000L,0x08000001L,0x08040000L,0x08040001L,
+0x09000000L,0x09000001L,0x09040000L,0x09040001L,
+0x08000002L,0x08000003L,0x08040002L,0x08040003L,
+0x09000002L,0x09000003L,0x09040002L,0x09040003L,
+0x08000200L,0x08000201L,0x08040200L,0x08040201L,
+0x09000200L,0x09000201L,0x09040200L,0x09040201L,
+0x08000202L,0x08000203L,0x08040202L,0x08040203L,
+0x09000202L,0x09000203L,0x09040202L,0x09040203L,
+},{
+/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
+0x00000000L,0x00100000L,0x00000100L,0x00100100L,
+0x00000008L,0x00100008L,0x00000108L,0x00100108L,
+0x00001000L,0x00101000L,0x00001100L,0x00101100L,
+0x00001008L,0x00101008L,0x00001108L,0x00101108L,
+0x04000000L,0x04100000L,0x04000100L,0x04100100L,
+0x04000008L,0x04100008L,0x04000108L,0x04100108L,
+0x04001000L,0x04101000L,0x04001100L,0x04101100L,
+0x04001008L,0x04101008L,0x04001108L,0x04101108L,
+0x00020000L,0x00120000L,0x00020100L,0x00120100L,
+0x00020008L,0x00120008L,0x00020108L,0x00120108L,
+0x00021000L,0x00121000L,0x00021100L,0x00121100L,
+0x00021008L,0x00121008L,0x00021108L,0x00121108L,
+0x04020000L,0x04120000L,0x04020100L,0x04120100L,
+0x04020008L,0x04120008L,0x04020108L,0x04120108L,
+0x04021000L,0x04121000L,0x04021100L,0x04121100L,
+0x04021008L,0x04121008L,0x04021108L,0x04121108L,
+},{
+/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+0x00000000L,0x10000000L,0x00010000L,0x10010000L,
+0x00000004L,0x10000004L,0x00010004L,0x10010004L,
+0x20000000L,0x30000000L,0x20010000L,0x30010000L,
+0x20000004L,0x30000004L,0x20010004L,0x30010004L,
+0x00100000L,0x10100000L,0x00110000L,0x10110000L,
+0x00100004L,0x10100004L,0x00110004L,0x10110004L,
+0x20100000L,0x30100000L,0x20110000L,0x30110000L,
+0x20100004L,0x30100004L,0x20110004L,0x30110004L,
+0x00001000L,0x10001000L,0x00011000L,0x10011000L,
+0x00001004L,0x10001004L,0x00011004L,0x10011004L,
+0x20001000L,0x30001000L,0x20011000L,0x30011000L,
+0x20001004L,0x30001004L,0x20011004L,0x30011004L,
+0x00101000L,0x10101000L,0x00111000L,0x10111000L,
+0x00101004L,0x10101004L,0x00111004L,0x10111004L,
+0x20101000L,0x30101000L,0x20111000L,0x30111000L,
+0x20101004L,0x30101004L,0x20111004L,0x30111004L,
+},{
+/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
+0x00000000L,0x08000000L,0x00000008L,0x08000008L,
+0x00000400L,0x08000400L,0x00000408L,0x08000408L,
+0x00020000L,0x08020000L,0x00020008L,0x08020008L,
+0x00020400L,0x08020400L,0x00020408L,0x08020408L,
+0x00000001L,0x08000001L,0x00000009L,0x08000009L,
+0x00000401L,0x08000401L,0x00000409L,0x08000409L,
+0x00020001L,0x08020001L,0x00020009L,0x08020009L,
+0x00020401L,0x08020401L,0x00020409L,0x08020409L,
+0x02000000L,0x0A000000L,0x02000008L,0x0A000008L,
+0x02000400L,0x0A000400L,0x02000408L,0x0A000408L,
+0x02020000L,0x0A020000L,0x02020008L,0x0A020008L,
+0x02020400L,0x0A020400L,0x02020408L,0x0A020408L,
+0x02000001L,0x0A000001L,0x02000009L,0x0A000009L,
+0x02000401L,0x0A000401L,0x02000409L,0x0A000409L,
+0x02020001L,0x0A020001L,0x02020009L,0x0A020009L,
+0x02020401L,0x0A020401L,0x02020409L,0x0A020409L,
+},{
+/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
+0x00000000L,0x00000100L,0x00080000L,0x00080100L,
+0x01000000L,0x01000100L,0x01080000L,0x01080100L,
+0x00000010L,0x00000110L,0x00080010L,0x00080110L,
+0x01000010L,0x01000110L,0x01080010L,0x01080110L,
+0x00200000L,0x00200100L,0x00280000L,0x00280100L,
+0x01200000L,0x01200100L,0x01280000L,0x01280100L,
+0x00200010L,0x00200110L,0x00280010L,0x00280110L,
+0x01200010L,0x01200110L,0x01280010L,0x01280110L,
+0x00000200L,0x00000300L,0x00080200L,0x00080300L,
+0x01000200L,0x01000300L,0x01080200L,0x01080300L,
+0x00000210L,0x00000310L,0x00080210L,0x00080310L,
+0x01000210L,0x01000310L,0x01080210L,0x01080310L,
+0x00200200L,0x00200300L,0x00280200L,0x00280300L,
+0x01200200L,0x01200300L,0x01280200L,0x01280300L,
+0x00200210L,0x00200310L,0x00280210L,0x00280310L,
+0x01200210L,0x01200310L,0x01280210L,0x01280310L,
+},{
+/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
+0x00000000L,0x04000000L,0x00040000L,0x04040000L,
+0x00000002L,0x04000002L,0x00040002L,0x04040002L,
+0x00002000L,0x04002000L,0x00042000L,0x04042000L,
+0x00002002L,0x04002002L,0x00042002L,0x04042002L,
+0x00000020L,0x04000020L,0x00040020L,0x04040020L,
+0x00000022L,0x04000022L,0x00040022L,0x04040022L,
+0x00002020L,0x04002020L,0x00042020L,0x04042020L,
+0x00002022L,0x04002022L,0x00042022L,0x04042022L,
+0x00000800L,0x04000800L,0x00040800L,0x04040800L,
+0x00000802L,0x04000802L,0x00040802L,0x04040802L,
+0x00002800L,0x04002800L,0x00042800L,0x04042800L,
+0x00002802L,0x04002802L,0x00042802L,0x04042802L,
+0x00000820L,0x04000820L,0x00040820L,0x04040820L,
+0x00000822L,0x04000822L,0x00040822L,0x04040822L,
+0x00002820L,0x04002820L,0x00042820L,0x04042820L,
+0x00002822L,0x04002822L,0x00042822L,0x04042822L,
+}};
diff -druN linux-noipsec/net/ipsec/libdes/speed.c linux/net/ipsec/libdes/speed.c
--- linux-noipsec/net/ipsec/libdes/speed.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/speed.c	Thu Feb 18 17:41:16 1999
@@ -0,0 +1,329 @@
+/* crypto/des/speed.c */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
+/* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */
+
+#ifndef MSDOS
+#define TIMES
+#endif
+
+#include <stdio.h>
+#ifndef MSDOS
+#include <unistd.h>
+#else
+#include <io.h>
+extern int exit();
+#endif
+#include <signal.h>
+#ifndef VMS
+#ifndef _IRIX
+#include <time.h>
+#endif
+#ifdef TIMES
+#include <sys/types.h>
+#include <sys/times.h>
+#endif
+#else /* VMS */
+#include <types.h>
+struct tms {
+	time_t tms_utime;
+	time_t tms_stime;
+	time_t tms_uchild;	/* I dunno...  */
+	time_t tms_uchildsys;	/* so these names are a guess :-) */
+	}
+#endif
+#ifndef TIMES
+#include <sys/timeb.h>
+#endif
+
+#ifdef sun
+#include <limits.h>
+#include <sys/param.h>
+#endif
+
+#include "des.h"
+
+/* The following if from times(3) man page.  It may need to be changed */
+#ifndef HZ
+# ifndef CLK_TCK
+#  ifndef _BSD_CLK_TCK_ /* FreeBSD fix */
+#   ifndef VMS
+#    define HZ	100.0
+#   else /* VMS */
+#    define HZ	100.0
+#   endif
+#  else /* _BSD_CLK_TCK_ */
+#   define HZ ((double)_BSD_CLK_TCK_)
+#  endif
+# else /* CLK_TCK */
+#  define HZ ((double)CLK_TCK)
+# endif
+#endif
+
+#define BUFSIZE	((long)1024)
+long run=0;
+
+#ifndef NOPROTO
+double Time_F(int s);
+#else
+double Time_F();
+#endif
+
+#ifdef SIGALRM
+#if defined(__STDC__) || defined(sgi) || defined(_AIX)
+#define SIGRETTYPE void
+#else
+#define SIGRETTYPE int
+#endif
+
+#ifndef NOPROTO
+SIGRETTYPE sig_done(int sig);
+#else
+SIGRETTYPE sig_done();
+#endif
+
+SIGRETTYPE sig_done(sig)
+int sig;
+	{
+	signal(SIGALRM,sig_done);
+	run=0;
+#ifdef LINT
+	sig=sig;
+#endif
+	}
+#endif
+
+#define START	0
+#define STOP	1
+
+double Time_F(s)
+int s;
+	{
+	double ret;
+#ifdef TIMES
+	static struct tms tstart,tend;
+
+	if (s == START)
+		{
+		times(&tstart);
+		return(0);
+		}
+	else
+		{
+		times(&tend);
+		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
+		return((ret == 0.0)?1e-6:ret);
+		}
+#else /* !times() */
+	static struct timeb tstart,tend;
+	long i;
+
+	if (s == START)
+		{
+		ftime(&tstart);
+		return(0);
+		}
+	else
+		{
+		ftime(&tend);
+		i=(long)tend.millitm-(long)tstart.millitm;
+		ret=((double)(tend.time-tstart.time))+((double)i)/1e3;
+		return((ret == 0.0)?1e-6:ret);
+		}
+#endif
+	}
+
+int main(argc,argv)
+int argc;
+char **argv;
+	{
+	long count;
+	static unsigned char buf[BUFSIZE];
+	static des_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
+	static des_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
+	static des_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
+	des_key_schedule sch,sch2,sch3;
+	double a,b,c,d,e;
+#ifndef SIGALRM
+	long ca,cb,cc,cd,ce;
+#endif
+
+#ifndef TIMES
+	printf("To get the most acurate results, try to run this\n");
+	printf("program when this computer is idle.\n");
+#endif
+
+	des_set_key((C_Block *)key2,sch2);
+	des_set_key((C_Block *)key3,sch3);
+
+#ifndef SIGALRM
+	printf("First we calculate the approximate speed ...\n");
+	des_set_key((C_Block *)key,sch);
+	count=10;
+	do	{
+		long i;
+		DES_LONG data[2];
+
+		count*=2;
+		Time_F(START);
+		for (i=count; i; i--)
+			des_encrypt(data,&(sch[0]),DES_ENCRYPT);
+		d=Time_F(STOP);
+		} while (d < 3.0);
+	ca=count;
+	cb=count*3;
+	cc=count*3*8/BUFSIZE+1;
+	cd=count*8/BUFSIZE+1;
+	ce=count/20+1;
+	printf("Doing set_key %ld times\n",ca);
+#define COND(d)	(count != (d))
+#define COUNT(d) (d)
+#else
+#define COND(c)	(run)
+#define COUNT(d) (count)
+	signal(SIGALRM,sig_done);
+	printf("Doing set_key for 10 seconds\n");
+	alarm(10);
+#endif
+
+	Time_F(START);
+	for (count=0,run=1; COND(ca); count++)
+		des_set_key((C_Block *)key,sch);
+	d=Time_F(STOP);
+	printf("%ld set_key's in %.2f seconds\n",count,d);
+	a=((double)COUNT(ca))/d;
+
+#ifdef SIGALRM
+	printf("Doing des_encrypt's for 10 seconds\n");
+	alarm(10);
+#else
+	printf("Doing des_encrypt %ld times\n",cb);
+#endif
+	Time_F(START);
+	for (count=0,run=1; COND(cb); count++)
+		{
+		DES_LONG data[2];
+
+		des_encrypt(data,&(sch[0]),DES_ENCRYPT);
+		}
+	d=Time_F(STOP);
+	printf("%ld des_encrypt's in %.2f second\n",count,d);
+	b=((double)COUNT(cb)*8)/d;
+
+#ifdef SIGALRM
+	printf("Doing des_cbc_encrypt on %ld byte blocks for 10 seconds\n",
+		BUFSIZE);
+	alarm(10);
+#else
+	printf("Doing des_cbc_encrypt %ld times on %ld byte blocks\n",cc,
+		BUFSIZE);
+#endif
+	Time_F(START);
+	for (count=0,run=1; COND(cc); count++)
+		des_ncbc_encrypt((C_Block *)buf,(C_Block *)buf,BUFSIZE,&(sch[0]),
+			(C_Block *)&(key[0]),DES_ENCRYPT);
+	d=Time_F(STOP);
+	printf("%ld des_cbc_encrypt's of %ld byte blocks in %.2f second\n",
+		count,BUFSIZE,d);
+	c=((double)COUNT(cc)*BUFSIZE)/d;
+
+#ifdef SIGALRM
+	printf("Doing des_ede_cbc_encrypt on %ld byte blocks for 10 seconds\n",
+		BUFSIZE);
+	alarm(10);
+#else
+	printf("Doing des_ede_cbc_encrypt %ld times on %ld byte blocks\n",cd,
+		BUFSIZE);
+#endif
+	Time_F(START);
+	for (count=0,run=1; COND(cd); count++)
+		des_ede3_cbc_encrypt((C_Block *)buf,(C_Block *)buf,BUFSIZE,
+			&(sch[0]),
+			&(sch2[0]),
+			&(sch3[0]),
+			(C_Block *)&(key[0]),
+			DES_ENCRYPT);
+	d=Time_F(STOP);
+	printf("%ld des_ede_cbc_encrypt's of %ld byte blocks in %.2f second\n",
+		count,BUFSIZE,d);
+	d=((double)COUNT(cd)*BUFSIZE)/d;
+
+#ifdef SIGALRM
+	printf("Doing crypt for 10 seconds\n");
+	alarm(10);
+#else
+	printf("Doing crypt %ld times\n",ce);
+#endif
+	Time_F(START);
+	for (count=0,run=1; COND(ce); count++)
+		crypt("testing1","ef");
+	e=Time_F(STOP);
+	printf("%ld crypts in %.2f second\n",count,e);
+	e=((double)COUNT(ce))/e;
+
+	printf("set_key            per sec = %12.2f (%9.3fuS)\n",a,1.0e6/a);
+	printf("DES raw ecb bytes  per sec = %12.2f (%9.3fuS)\n",b,8.0e6/b);
+	printf("DES cbc bytes      per sec = %12.2f (%9.3fuS)\n",c,8.0e6/c);
+	printf("DES ede cbc bytes  per sec = %12.2f (%9.3fuS)\n",d,8.0e6/d);
+	printf("crypt              per sec = %12.2f (%9.3fuS)\n",e,1.0e6/e);
+	exit(0);
+#if defined(LINT) || defined(MSDOS)
+	return(0);
+#endif
+	}
diff -druN linux-noipsec/net/ipsec/libdes/spr.h linux/net/ipsec/libdes/spr.h
--- linux-noipsec/net/ipsec/libdes/spr.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libdes/spr.h	Thu Feb 18 17:41:16 1999
@@ -0,0 +1,204 @@
+/* crypto/des/spr.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+const DES_LONG des_SPtrans[8][64]={
+{
+/* nibble 0 */
+0x02080800L, 0x00080000L, 0x02000002L, 0x02080802L,
+0x02000000L, 0x00080802L, 0x00080002L, 0x02000002L,
+0x00080802L, 0x02080800L, 0x02080000L, 0x00000802L,
+0x02000802L, 0x02000000L, 0x00000000L, 0x00080002L,
+0x00080000L, 0x00000002L, 0x02000800L, 0x00080800L,
+0x02080802L, 0x02080000L, 0x00000802L, 0x02000800L,
+0x00000002L, 0x00000800L, 0x00080800L, 0x02080002L,
+0x00000800L, 0x02000802L, 0x02080002L, 0x00000000L,
+0x00000000L, 0x02080802L, 0x02000800L, 0x00080002L,
+0x02080800L, 0x00080000L, 0x00000802L, 0x02000800L,
+0x02080002L, 0x00000800L, 0x00080800L, 0x02000002L,
+0x00080802L, 0x00000002L, 0x02000002L, 0x02080000L,
+0x02080802L, 0x00080800L, 0x02080000L, 0x02000802L,
+0x02000000L, 0x00000802L, 0x00080002L, 0x00000000L,
+0x00080000L, 0x02000000L, 0x02000802L, 0x02080800L,
+0x00000002L, 0x02080002L, 0x00000800L, 0x00080802L,
+},{
+/* nibble 1 */
+0x40108010L, 0x00000000L, 0x00108000L, 0x40100000L,
+0x40000010L, 0x00008010L, 0x40008000L, 0x00108000L,
+0x00008000L, 0x40100010L, 0x00000010L, 0x40008000L,
+0x00100010L, 0x40108000L, 0x40100000L, 0x00000010L,
+0x00100000L, 0x40008010L, 0x40100010L, 0x00008000L,
+0x00108010L, 0x40000000L, 0x00000000L, 0x00100010L,
+0x40008010L, 0x00108010L, 0x40108000L, 0x40000010L,
+0x40000000L, 0x00100000L, 0x00008010L, 0x40108010L,
+0x00100010L, 0x40108000L, 0x40008000L, 0x00108010L,
+0x40108010L, 0x00100010L, 0x40000010L, 0x00000000L,
+0x40000000L, 0x00008010L, 0x00100000L, 0x40100010L,
+0x00008000L, 0x40000000L, 0x00108010L, 0x40008010L,
+0x40108000L, 0x00008000L, 0x00000000L, 0x40000010L,
+0x00000010L, 0x40108010L, 0x00108000L, 0x40100000L,
+0x40100010L, 0x00100000L, 0x00008010L, 0x40008000L,
+0x40008010L, 0x00000010L, 0x40100000L, 0x00108000L,
+},{
+/* nibble 2 */
+0x04000001L, 0x04040100L, 0x00000100L, 0x04000101L,
+0x00040001L, 0x04000000L, 0x04000101L, 0x00040100L,
+0x04000100L, 0x00040000L, 0x04040000L, 0x00000001L,
+0x04040101L, 0x00000101L, 0x00000001L, 0x04040001L,
+0x00000000L, 0x00040001L, 0x04040100L, 0x00000100L,
+0x00000101L, 0x04040101L, 0x00040000L, 0x04000001L,
+0x04040001L, 0x04000100L, 0x00040101L, 0x04040000L,
+0x00040100L, 0x00000000L, 0x04000000L, 0x00040101L,
+0x04040100L, 0x00000100L, 0x00000001L, 0x00040000L,
+0x00000101L, 0x00040001L, 0x04040000L, 0x04000101L,
+0x00000000L, 0x04040100L, 0x00040100L, 0x04040001L,
+0x00040001L, 0x04000000L, 0x04040101L, 0x00000001L,
+0x00040101L, 0x04000001L, 0x04000000L, 0x04040101L,
+0x00040000L, 0x04000100L, 0x04000101L, 0x00040100L,
+0x04000100L, 0x00000000L, 0x04040001L, 0x00000101L,
+0x04000001L, 0x00040101L, 0x00000100L, 0x04040000L,
+},{
+/* nibble 3 */
+0x00401008L, 0x10001000L, 0x00000008L, 0x10401008L,
+0x00000000L, 0x10400000L, 0x10001008L, 0x00400008L,
+0x10401000L, 0x10000008L, 0x10000000L, 0x00001008L,
+0x10000008L, 0x00401008L, 0x00400000L, 0x10000000L,
+0x10400008L, 0x00401000L, 0x00001000L, 0x00000008L,
+0x00401000L, 0x10001008L, 0x10400000L, 0x00001000L,
+0x00001008L, 0x00000000L, 0x00400008L, 0x10401000L,
+0x10001000L, 0x10400008L, 0x10401008L, 0x00400000L,
+0x10400008L, 0x00001008L, 0x00400000L, 0x10000008L,
+0x00401000L, 0x10001000L, 0x00000008L, 0x10400000L,
+0x10001008L, 0x00000000L, 0x00001000L, 0x00400008L,
+0x00000000L, 0x10400008L, 0x10401000L, 0x00001000L,
+0x10000000L, 0x10401008L, 0x00401008L, 0x00400000L,
+0x10401008L, 0x00000008L, 0x10001000L, 0x00401008L,
+0x00400008L, 0x00401000L, 0x10400000L, 0x10001008L,
+0x00001008L, 0x10000000L, 0x10000008L, 0x10401000L,
+},{
+/* nibble 4 */
+0x08000000L, 0x00010000L, 0x00000400L, 0x08010420L,
+0x08010020L, 0x08000400L, 0x00010420L, 0x08010000L,
+0x00010000L, 0x00000020L, 0x08000020L, 0x00010400L,
+0x08000420L, 0x08010020L, 0x08010400L, 0x00000000L,
+0x00010400L, 0x08000000L, 0x00010020L, 0x00000420L,
+0x08000400L, 0x00010420L, 0x00000000L, 0x08000020L,
+0x00000020L, 0x08000420L, 0x08010420L, 0x00010020L,
+0x08010000L, 0x00000400L, 0x00000420L, 0x08010400L,
+0x08010400L, 0x08000420L, 0x00010020L, 0x08010000L,
+0x00010000L, 0x00000020L, 0x08000020L, 0x08000400L,
+0x08000000L, 0x00010400L, 0x08010420L, 0x00000000L,
+0x00010420L, 0x08000000L, 0x00000400L, 0x00010020L,
+0x08000420L, 0x00000400L, 0x00000000L, 0x08010420L,
+0x08010020L, 0x08010400L, 0x00000420L, 0x00010000L,
+0x00010400L, 0x08010020L, 0x08000400L, 0x00000420L,
+0x00000020L, 0x00010420L, 0x08010000L, 0x08000020L,
+},{
+/* nibble 5 */
+0x80000040L, 0x00200040L, 0x00000000L, 0x80202000L,
+0x00200040L, 0x00002000L, 0x80002040L, 0x00200000L,
+0x00002040L, 0x80202040L, 0x00202000L, 0x80000000L,
+0x80002000L, 0x80000040L, 0x80200000L, 0x00202040L,
+0x00200000L, 0x80002040L, 0x80200040L, 0x00000000L,
+0x00002000L, 0x00000040L, 0x80202000L, 0x80200040L,
+0x80202040L, 0x80200000L, 0x80000000L, 0x00002040L,
+0x00000040L, 0x00202000L, 0x00202040L, 0x80002000L,
+0x00002040L, 0x80000000L, 0x80002000L, 0x00202040L,
+0x80202000L, 0x00200040L, 0x00000000L, 0x80002000L,
+0x80000000L, 0x00002000L, 0x80200040L, 0x00200000L,
+0x00200040L, 0x80202040L, 0x00202000L, 0x00000040L,
+0x80202040L, 0x00202000L, 0x00200000L, 0x80002040L,
+0x80000040L, 0x80200000L, 0x00202040L, 0x00000000L,
+0x00002000L, 0x80000040L, 0x80002040L, 0x80202000L,
+0x80200000L, 0x00002040L, 0x00000040L, 0x80200040L,
+},{
+/* nibble 6 */
+0x00004000L, 0x00000200L, 0x01000200L, 0x01000004L,
+0x01004204L, 0x00004004L, 0x00004200L, 0x00000000L,
+0x01000000L, 0x01000204L, 0x00000204L, 0x01004000L,
+0x00000004L, 0x01004200L, 0x01004000L, 0x00000204L,
+0x01000204L, 0x00004000L, 0x00004004L, 0x01004204L,
+0x00000000L, 0x01000200L, 0x01000004L, 0x00004200L,
+0x01004004L, 0x00004204L, 0x01004200L, 0x00000004L,
+0x00004204L, 0x01004004L, 0x00000200L, 0x01000000L,
+0x00004204L, 0x01004000L, 0x01004004L, 0x00000204L,
+0x00004000L, 0x00000200L, 0x01000000L, 0x01004004L,
+0x01000204L, 0x00004204L, 0x00004200L, 0x00000000L,
+0x00000200L, 0x01000004L, 0x00000004L, 0x01000200L,
+0x00000000L, 0x01000204L, 0x01000200L, 0x00004200L,
+0x00000204L, 0x00004000L, 0x01004204L, 0x01000000L,
+0x01004200L, 0x00000004L, 0x00004004L, 0x01004204L,
+0x01000004L, 0x01004200L, 0x01004000L, 0x00004004L,
+},{
+/* nibble 7 */
+0x20800080L, 0x20820000L, 0x00020080L, 0x00000000L,
+0x20020000L, 0x00800080L, 0x20800000L, 0x20820080L,
+0x00000080L, 0x20000000L, 0x00820000L, 0x00020080L,
+0x00820080L, 0x20020080L, 0x20000080L, 0x20800000L,
+0x00020000L, 0x00820080L, 0x00800080L, 0x20020000L,
+0x20820080L, 0x20000080L, 0x00000000L, 0x00820000L,
+0x20000000L, 0x00800000L, 0x20020080L, 0x20800080L,
+0x00800000L, 0x00020000L, 0x20820000L, 0x00000080L,
+0x00800000L, 0x00020000L, 0x20000080L, 0x20820080L,
+0x00020080L, 0x20000000L, 0x00000000L, 0x00820000L,
+0x20800080L, 0x20020080L, 0x20020000L, 0x00800080L,
+0x20820000L, 0x00000080L, 0x00800080L, 0x20020000L,
+0x20820080L, 0x00800000L, 0x20800000L, 0x20000080L,
+0x00820000L, 0x00020080L, 0x20020080L, 0x20800000L,
+0x00000080L, 0x20820000L, 0x00820080L, 0x00000000L,
+0x20000000L, 0x20800080L, 0x00020000L, 0x00820080L,
+}};
diff -druN linux-noipsec/net/ipsec/libfreeswan/Makefile linux/net/ipsec/libfreeswan/Makefile
--- linux-noipsec/net/ipsec/libfreeswan/Makefile	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/Makefile	Fri Sep  8 21:12:57 2000
@@ -0,0 +1,53 @@
+# FreeS/WAN library
+# Copyright (C) 1998, 1999, 2000  Henry Spencer.
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2 of the License, or (at your
+# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# RCSID $Id$
+
+ifndef TOPDIR
+TOPDIR  := /usr/src/linux
+endif
+
+L_TARGET := libkernel.a
+
+L_OBJS := ultoa.o addrtoa.o subnettoa.o subnetof.o goodmask.o datatot.o \
+	rangetoa.o satoa.o pfkey_v2_parse.o pfkey_v2_build.o pfkey_v2_ext_bits.o
+
+HDRS=freeswan.h internal.h
+
+override CFLAGS += -I.
+
+ifeq ($(CONFIG_IPSEC_DEBUG),y)
+override CFLAGS += -g
+endif
+
+override CFLAGS += -Wall 
+#override CFLAGS += -Wconversion 
+#override CFLAGS += -Wmissing-prototypes 
+override CFLAGS += -Wpointer-arith 
+#override CFLAGS += -Wcast-qual 
+#override CFLAGS += -Wmissing-declarations 
+override CFLAGS += -Wstrict-prototypes
+#override CFLAGS += -pedantic
+#override CFLAGS += -O3
+#override CFLAGS += -W
+#override CFLAGS += -Wwrite-strings 
+override CFLAGS += -Wbad-function-cast 
+
+include $(TOPDIR)/Rules.make
+
+$(L_OBJS):	$(HDRS)
+
+clean:
+	rm -f $(L_TARGET) *.o try* core *.core
+	( cd des && $(MAKE) clean )
+
diff -druN linux-noipsec/net/ipsec/libfreeswan/addrtoa.c linux/net/ipsec/libfreeswan/addrtoa.c
--- linux-noipsec/net/ipsec/libfreeswan/addrtoa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/addrtoa.c	Sun Apr 11 01:19:36 1999
@@ -0,0 +1,68 @@
+/*
+ * addresses to ASCII
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+#define	NBYTES	4		/* bytes in an address */
+#define	PERBYTE	4		/* three digits plus a dot or NUL */
+#define	BUFLEN	(NBYTES*PERBYTE)
+
+#if BUFLEN != ADDRTOA_BUF
+#error	"ADDRTOA_BUF in freeswan.h inconsistent with addrtoa() code"
+#endif
+
+/*
+ - addrtoa - convert binary address to ASCII dotted decimal
+ */
+size_t				/* space needed for full conversion */
+addrtoa(addr, format, dst, dstlen)
+struct in_addr addr;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	unsigned long a = ntohl(addr.s_addr);
+	int i;
+	size_t n;
+	unsigned long byte;
+	char buf[BUFLEN];
+	char *p;
+
+	switch (format) {
+	case 0:
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	p = buf;
+	for (i = NBYTES-1; i >= 0; i--) {
+		byte = (a >> (i*8)) & 0xff;
+		p += ultoa(byte, 10, p, PERBYTE);
+		if (i != 0)
+			*(p-1) = '.';
+	}
+	n = p - buf;
+
+	if (dstlen > 0) {
+		if (n > dstlen)
+			buf[dstlen - 1] = '\0';
+		strcpy(dst, buf);
+	}
+	return n;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/addrtot.c linux/net/ipsec/libfreeswan/addrtot.c
--- linux-noipsec/net/ipsec/libfreeswan/addrtot.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/addrtot.c	Tue Sep 12 06:56:39 2000
@@ -0,0 +1,230 @@
+/*
+ * addresses to text
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+#define	IP4BYTES	4	/* bytes in an IPv4 address */
+#define	PERBYTE		4	/* three digits plus a dot or NUL */
+#define	IP6BYTES	16	/* bytes in an IPv6 address */
+
+/* forwards */
+static size_t normal4(const unsigned char *s, size_t len, char *b, char **dp);
+static size_t normal6(const unsigned char *s, size_t len, char *b, char **dp);
+static size_t reverse4(const unsigned char *s, size_t len, char *b, char **dp);
+static size_t reverse6(const unsigned char *s, size_t len, char *b, char **dp);
+static size_t reverse62(const unsigned char *s, size_t len, char *b, char **dp);
+
+/*
+ - addrtot - convert binary address to text (dotted decimal or IPv6 string)
+ */
+size_t				/* space needed for full conversion */
+addrtot(src, format, dst, dstlen)
+const ip_address *src;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	const unsigned char *b;
+	size_t n;
+	char buf[1+ADDRTOT_BUF+1];	/* :address: */
+	char *p;
+	int t = addrtypeof(src);
+#	define	TF(t, f)	(((t)<<8) | (f))
+
+	n = addrbytesptr(src, &b);
+	if (n == 0)
+		return 0;
+
+	switch (TF(t, format)) {
+	case TF(AF_INET, 0):
+		n = normal4(b, n, buf, &p);
+		break;
+	case TF(AF_INET6, 0):
+		n = normal6(b, n, buf, &p);
+		break;
+	case TF(AF_INET, 'r'):
+		n = reverse4(b, n, buf, &p);
+		break;
+	case TF(AF_INET6, 'r'):
+		n = reverse6(b, n, buf, &p);
+		break;
+	case TF(AF_INET6, 'R'):
+		n = reverse62(b, n, buf, &p);
+		break;
+	default:		/* including (AF_INET, 'R') */
+		return 0;
+		break;
+	}
+
+	if (dstlen > 0) {
+		if (dstlen < n)
+			p[dstlen - 1] = '\0';
+		strcpy(dst, p);
+	}
+	return n;
+}
+
+/*
+ - normal4 - normal IPv4 address-text conversion
+ */
+static size_t			/* size of text, including NUL */
+normal4(srcp, srclen, buf, dstp)
+const unsigned char *srcp;
+size_t srclen;
+char *buf;			/* guaranteed large enough */
+char **dstp;			/* where to put result pointer */
+{
+	int i;
+	char *p;
+
+	if (srclen != IP4BYTES)	/* "can't happen" */
+		return 0;
+	p = buf;
+	for (i = 0; i < IP4BYTES; i++) {
+		p += ultot(srcp[i], 10, p, PERBYTE);
+		if (i != IP4BYTES - 1)
+			*(p-1) = '.';	/* overwrites the NUL */
+	}
+	*dstp = buf;
+	return p - buf;
+}
+
+/*
+ - normal6 - normal IPv6 address-text conversion
+ */
+static size_t			/* size of text, including NUL */
+normal6(srcp, srclen, buf, dstp)
+const unsigned char *srcp;
+size_t srclen;
+char *buf;			/* guaranteed large enough, plus 2 */
+char **dstp;			/* where to put result pointer */
+{
+	int i;
+	unsigned long piece;
+	char *p;
+	char *q;
+
+	if (srclen != IP6BYTES)	/* "can't happen" */
+		return 0;
+	p = buf;
+	*p++ = ':';
+	for (i = 0; i < IP6BYTES/2; i++) {
+		piece = (srcp[2*i] << 8) + srcp[2*i + 1];
+		p += ultot(piece, 16, p, 5);	/* 5 = abcd + NUL */
+		*(p-1) = ':';	/* overwrites the NUL */
+	}
+	*p = '\0';
+	q = strstr(buf, ":0:0:");
+	if (q != NULL) {	/* zero squishing is possible */
+		p = q + 1;
+		while (*p == '0' && *(p+1) == ':')
+			p += 2;
+		q++;
+		*q++ = ':';	/* overwrite first 0 */
+		while (*p != '\0')
+			*q++ = *p++;
+		*q = '\0';
+		if (!(*(q-1) == ':' && *(q-2) == ':'))
+			*--q = '\0';	/* strip final : unless :: */
+		p = buf;
+		if (!(*p == ':' && *(p+1) == ':'))
+			p++;	/* skip initial : unless :: */
+	} else {
+		q = p;
+		*--q = '\0';	/* strip final : */
+		p = buf + 1;	/* skip initial : */
+	}
+	*dstp = p;
+	return q - p + 1;
+}
+
+/*
+ - reverse4 - IPv4 reverse-lookup conversion
+ */
+static size_t			/* size of text, including NUL */
+reverse4(srcp, srclen, buf, dstp)
+const unsigned char *srcp;
+size_t srclen;
+char *buf;			/* guaranteed large enough */
+char **dstp;			/* where to put result pointer */
+{
+	int i;
+	char *p;
+
+	if (srclen != IP4BYTES)	/* "can't happen" */
+		return 0;
+	p = buf;
+	for (i = IP4BYTES-1; i >= 0; i--) {
+		p += ultot(srcp[i], 10, p, PERBYTE);
+		*(p-1) = '.';	/* overwrites the NUL */
+	}
+	strcpy(p, "IN-ADDR.ARPA.");
+	*dstp = buf;
+	return strlen(buf) + 1;
+}
+
+/*
+ - reverse62 - obsolete IPv6 reverse-lookup conversion (RFC 1886)
+ * A trifle inefficient, really shouldn't use ultot...
+ */
+static size_t			/* size of text, including NUL */
+reverse62(srcp, srclen, buf, dstp)
+const unsigned char *srcp;
+size_t srclen;
+char *buf;			/* guaranteed large enough */
+char **dstp;			/* where to put result pointer */
+{
+	int i;
+	unsigned long piece;
+	char *p;
+
+	if (srclen != IP6BYTES)	/* "can't happen" */
+		return 0;
+	p = buf;
+	for (i = IP6BYTES-1; i >= 0; i--) {
+		piece = srcp[i];
+		p += ultot(piece&0xf, 16, p, 2);
+		*(p-1) = '.';
+		p += ultot(piece>>4, 16, p, 2);
+		*(p-1) = '.';
+	}
+	strcpy(p, "IP6.INT.");
+	*dstp = buf;
+	return strlen(buf) + 1;
+}
+
+/*
+ - reverse6 - modern IPv6 reverse-lookup conversion (RFC 2874)
+ */
+static size_t			/* size of text, including NUL */
+reverse6(srcp, srclen, buf, dstp)
+const unsigned char *srcp;
+size_t srclen;
+char *buf;			/* guaranteed large enough */
+char **dstp;			/* where to put result pointer */
+{
+	char *p;
+
+	if (srclen != IP6BYTES)	/* "can't happen" */
+		return 0;
+	strcpy(buf, "\\[x");
+	p = buf + strlen(buf);
+	(void) datatot((const char *)srcp, srclen, 16, p, IP6BYTES*2 + 1);
+	strcat(buf, "].IP6.ARPA.");	/* leave count implicit */
+	*dstp = buf;
+	return strlen(buf) + 1;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/addrtypeof.c linux/net/ipsec/libfreeswan/addrtypeof.c
--- linux-noipsec/net/ipsec/libfreeswan/addrtypeof.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/addrtypeof.c	Fri Sep  8 20:03:44 2000
@@ -0,0 +1,94 @@
+/*
+ * extract parts of an ip_address
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - addrtypeof - get the type of an ip_address
+ */
+int
+addrtypeof(src)
+const ip_address *src;
+{
+	return src->u.v4.sin_family;
+}
+
+/*
+ - addrbytesptr - get pointer to the address bytes of an ip_address
+ */
+size_t				/* 0 for error */
+addrbytesptr(src, dstp)
+const ip_address *src;
+const unsigned char **dstp;	/* NULL means just a size query */
+{
+	const unsigned char *p;
+	size_t n;
+
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		p = (const unsigned char *)&src->u.v4.sin_addr.s_addr;
+		n = 4;
+		break;
+	case AF_INET6:
+		p = (const unsigned char *)&src->u.v6.sin6_addr;
+		n = 16;
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	if (dstp != NULL)
+		*dstp = p;
+	return n;
+}
+
+/*
+ - addrlenof - get length of the address bytes of an ip_address
+ */
+size_t				/* 0 for error */
+addrlenof(src)
+const ip_address *src;
+{
+	return addrbytesptr(src, NULL);
+}
+
+/*
+ - addrbytesof - get the address bytes of an ip_address
+ */
+size_t				/* 0 for error */
+addrbytesof(src, dst, dstlen)
+const ip_address *src;
+unsigned char *dst;
+size_t dstlen;
+{
+	const unsigned char *p;
+	size_t n;
+	size_t ncopy;
+
+	n = addrbytesptr(src, &p);
+	if (n == 0)
+		return 0;
+
+	if (dstlen > 0) {
+		ncopy = n;
+		if (ncopy > dstlen)
+			ncopy = dstlen;
+		memcpy(dst, p, ncopy);
+	}
+	return n;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/anyaddr.c linux/net/ipsec/libfreeswan/anyaddr.c
--- linux-noipsec/net/ipsec/libfreeswan/anyaddr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/anyaddr.c	Tue Sep 19 09:09:32 2000
@@ -0,0 +1,146 @@
+/*
+ * special addresses
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/* these are mostly fallbacks for the no-IPv6-support-in-library case */
+#ifndef IN6ADDR_ANY_INIT
+#define	IN6ADDR_ANY_INIT	{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }}
+#endif
+#ifndef IN6ADDR_LOOPBACK_INIT
+#define	IN6ADDR_LOOPBACK_INIT	{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }}
+#endif
+
+static struct in6_addr v6any = IN6ADDR_ANY_INIT;
+static struct in6_addr v6loop = IN6ADDR_LOOPBACK_INIT;
+
+/*
+ - anyaddr - initialize to the any-address value
+ */
+err_t				/* NULL for success, else string literal */
+anyaddr(af, dst)
+int af;				/* address family */
+ip_address *dst;
+{
+	uint32_t v4any = htonl(INADDR_ANY);
+
+	switch (af) {
+	case AF_INET:
+		return initaddr((unsigned char *)&v4any, sizeof(v4any), af, dst);
+		break;
+	case AF_INET6:
+		return initaddr((unsigned char *)&v6any, sizeof(v6any), af, dst);
+		break;
+	default:
+		return "unknown address family in anyaddr/unspecaddr";
+		break;
+	}
+}
+
+/*
+ - unspecaddr - initialize to the unspecified-address value
+ */
+err_t				/* NULL for success, else string literal */
+unspecaddr(af, dst)
+int af;				/* address family */
+ip_address *dst;
+{
+	return anyaddr(af, dst);
+}
+
+/*
+ - loopbackaddr - initialize to the loopback-address value
+ */
+err_t				/* NULL for success, else string literal */
+loopbackaddr(af, dst)
+int af;				/* address family */
+ip_address *dst;
+{
+	uint32_t v4loop = htonl(INADDR_LOOPBACK);
+
+	switch (af) {
+	case AF_INET:
+		return initaddr((unsigned char *)&v4loop, sizeof(v4loop), af, dst);
+		break;
+	case AF_INET6:
+		return initaddr((unsigned char *)&v6loop, sizeof(v6loop), af, dst);
+		break;
+	default:
+		return "unknown address family in loopbackaddr";
+		break;
+	}
+}
+
+/*
+ - isanyaddr - test for the any-address value
+ */
+int
+isanyaddr(src)
+const ip_address *src;
+{
+	uint32_t v4any = htonl(INADDR_ANY);
+	int cmp;
+
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		cmp = memcmp(&src->u.v4.sin_addr.s_addr, &v4any, sizeof(v4any));
+		break;
+	case AF_INET6:
+		cmp = memcmp(&src->u.v6.sin6_addr, &v6any, sizeof(v6any));
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	return (cmp == 0) ? 1 : 0;
+}
+
+/*
+ - isunspecaddr - test for the unspecified-address value
+ */
+int
+isunspecaddr(src)
+const ip_address *src;
+{
+	return isanyaddr(src);
+}
+
+/*
+ - isloopbackaddr - test for the loopback-address value
+ */
+int
+isloopbackaddr(src)
+const ip_address *src;
+{
+	uint32_t v4loop = htonl(INADDR_LOOPBACK);
+	int cmp;
+
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		cmp = memcmp(&src->u.v4.sin_addr.s_addr, &v4loop, sizeof(v4loop));
+		break;
+	case AF_INET6:
+		cmp = memcmp(&src->u.v6.sin6_addr, &v6loop, sizeof(v6loop));
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	return (cmp == 0) ? 1 : 0;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/atoaddr.c linux/net/ipsec/libfreeswan/atoaddr.c
--- linux-noipsec/net/ipsec/libfreeswan/atoaddr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/atoaddr.c	Sat Jan 22 03:17:22 2000
@@ -0,0 +1,238 @@
+/*
+ * conversion from ASCII forms of addresses to internal ones
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ * Define NOLEADINGZEROS to interpret 032 as an error, not as 32.  There
+ * is deliberately no way to interpret it as 26 (i.e., as octal).
+ */
+
+/*
+ * Legal characters in a domain name.  Underscore technically is not,
+ * but is a common misunderstanding.
+ */
+static const char namechars[] = "abcdefghijklmnopqrstuvwxyz0123456789"
+				"ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
+
+static const char *try8hex(const char *, size_t, struct in_addr *);
+static const char *try8hosthex(const char *, size_t, struct in_addr *);
+static const char *trydotted(const char *, size_t, struct in_addr *);
+static const char *getbyte(const char **, const char *, int *);
+
+/*
+ - atoaddr - convert ASCII name or dotted-decimal address to binary address
+ */
+const char *			/* NULL for success, else string literal */
+atoaddr(src, srclen, addrp)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+struct in_addr *addrp;
+{
+	struct hostent *h;
+	struct netent *ne = NULL;
+	const char *oops;
+#	define	HEXLEN	10	/* strlen("0x11223344") */
+#	ifndef ATOADDRBUF
+#	define	ATOADDRBUF	100
+#	endif
+	char namebuf[ATOADDRBUF];
+	char *p = namebuf;
+	char *q;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	/* might it be hex? */
+	if (srclen == HEXLEN && *src == '0' && CIEQ(*(src+1), 'x'))
+		return try8hex(src+2, srclen-2, addrp);
+	if (srclen == HEXLEN && *src == '0' && CIEQ(*(src+1), 'h'))
+		return try8hosthex(src+2, srclen-2, addrp);
+
+	/* try it as dotted decimal */
+	oops = trydotted(src, srclen, addrp);
+	if (oops == NULL)
+		return NULL;		/* it worked */
+	if (*oops != '?')
+		return oops;		/* it *was* probably meant as a d.q. */
+
+	/* try it as a name -- first, NUL-terminate it */
+	if (srclen > sizeof(namebuf)-1) {
+		p = (char *) MALLOC(srclen+1);
+		if (p == NULL)
+			return "unable to allocate temporary space for name";
+	}
+	p[0] = '\0';
+	strncat(p, src, srclen);
+
+	/* next, check that it's a vaguely legal name */
+	for (q = p; *q != '\0'; q++)
+		if (!isprint(*q))
+			return "unprintable character in name";
+	if (strspn(p, namechars) != srclen)
+		return "illegal (non-DNS-name) character in name";
+
+	/* try as host name, failing that as /etc/networks network name */
+	h = gethostbyname(p);
+	if (h == NULL)
+		ne = getnetbyname(p);
+	if (p != namebuf)
+		FREE(p);
+	if (h == NULL && ne == NULL)
+		return "name lookup failed";
+
+	if (h != NULL)
+		memcpy(&addrp->s_addr, h->h_addr, sizeof(addrp->s_addr));
+	else
+		addrp->s_addr = htonl(ne->n_net);
+	return NULL;
+}
+
+/*
+ - try8hosthex - try conversion as an eight-digit host-order hex number
+ */
+const char *			/* NULL for success, else string literal */
+try8hosthex(src, srclen, addrp)
+const char *src;
+size_t srclen;			/* should be 8 */
+struct in_addr *addrp;
+{
+	const char *oops;
+	unsigned long addr;
+
+	if (srclen != 8)
+		return "internal error, try8hex called with bad length";
+
+	oops = atoul(src, srclen, 16, &addr);
+	if (oops != NULL)
+		return oops;
+
+	addrp->s_addr = addr;
+	return NULL;
+}
+
+/*
+ - try8hex - try conversion as an eight-digit network-order hex number
+ */
+const char *			/* NULL for success, else string literal */
+try8hex(src, srclen, addrp)
+const char *src;
+size_t srclen;			/* should be 8 */
+struct in_addr *addrp;
+{
+	const char *oops;
+
+	oops = try8hosthex(src, srclen, addrp);
+	if (oops != NULL)
+		return oops;
+
+	addrp->s_addr = htonl(addrp->s_addr);
+	return NULL;
+}
+
+/*
+ - trydotted - try conversion as dotted decimal
+ *
+ * If the first char of a complaint is '?', that means "didn't look like
+ * dotted decimal at all".
+ */
+const char *			/* NULL for success, else string literal */
+trydotted(src, srclen, addrp)
+const char *src;
+size_t srclen;
+struct in_addr *addrp;
+{
+	const char *stop = src + srclen;	/* just past end */
+	int byte;
+	const char *oops;
+	unsigned long addr;
+	int i;
+#	define	NBYTES	4
+#	define	BYTE	8
+
+	addr = 0;
+	for (i = 0; i < NBYTES && src < stop; i++) {
+		oops = getbyte(&src, stop, &byte);
+		if (oops != NULL) {
+			if (*oops != '?')
+				return oops;	/* bad number */
+			if (i > 1)
+				return oops+1;	/* failed number */
+			return oops;		/* with leading '?' */
+		}
+		addr = (addr << BYTE) | byte;
+		if (i < 3 && src < stop && *src++ != '.') {
+			if (i == 0)
+				return "?syntax error in dotted-decimal address";
+			else
+				return "syntax error in dotted-decimal address";
+		}
+	}
+	addr <<= (NBYTES - i) * BYTE;
+	if (src != stop)
+		return "extra garbage on end of dotted-decimal address";
+
+	addrp->s_addr = htonl(addr);
+	return NULL;
+}
+
+/*
+ - getbyte - try to scan a byte in dotted decimal
+ * A subtlety here is that all this arithmetic on ASCII digits really is
+ * highly portable -- ANSI C guarantees that digits 0-9 are contiguous.
+ * It's easier to just do it ourselves than set up for a call to atoul().
+ *
+ * If the first char of a complaint is '?', that means "didn't look like a
+ * number at all".
+ */
+const char *			/* NULL for success, else string literal */
+getbyte(srcp, stop, retp)
+const char **srcp;		/* *srcp is updated */
+const char *stop;		/* first untouchable char */
+int *retp;			/* return-value pointer */
+{
+	char c;
+	const char *p;
+	int no;
+
+	if (*srcp >= stop)
+		return "?empty number in dotted-decimal address";
+
+	if (stop - *srcp >= 3 && **srcp == '0' && CIEQ(*(*srcp+1), 'x'))
+		return "hex numbers not supported in dotted-decimal addresses";
+#ifdef NOLEADINGZEROS
+	if (stop - *srcp >= 2 && **srcp == '0' && isdigit(*(*srcp+1)))
+		return "octal numbers not supported in dotted-decimal addresses";
+#endif /* NOLEADINGZEROS */
+
+	/* must be decimal, if it's numeric at all */
+	no = 0;
+	p = *srcp;
+	while (p < stop && no <= 255 && (c = *p) >= '0' && c <= '9') {
+		no = no*10 + (c - '0');
+		p++;
+	}
+	if (p == *srcp)
+		return "?non-numeric component in dotted-decimal address";
+	*srcp = p;
+	if (no > 255)
+		return "byte overflow in dotted-decimal address";
+	*retp = no;
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/atoasr.c linux/net/ipsec/libfreeswan/atoasr.c
--- linux-noipsec/net/ipsec/libfreeswan/atoasr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/atoasr.c	Tue Dec  7 06:00:51 1999
@@ -0,0 +1,212 @@
+/*
+ * convert from ASCII form of address/subnet/range to binary
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - atoasr - convert ASCII to address, subnet, or range
+ */
+const char *			/* NULL for success, else string literal */
+atoasr(src, srclen, typep, addrsp)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+char *typep;			/* return type code:  'a', 's', 'r' */
+struct in_addr addrsp[2];
+{
+	const char *punct;
+	const char *stop;
+	const char *oops;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	/* subnet is easy to spot */
+	punct = memchr(src, '/', srclen);
+	if (punct != NULL) {
+		*typep = 's';
+		return atosubnet(src, srclen, &addrsp[0], &addrsp[1]);
+	}
+
+	/* try for a range */
+	stop = src + srclen;
+	for (punct = src; (punct = memchr(punct, '.', stop - punct)) != NULL;
+									punct++)
+		if (stop - punct > 3 && *(punct+1) == '.' && *(punct+2) == '.')
+			break;			/* NOTE BREAK OUT */
+	if (punct == NULL) {
+		/* didn't find the range delimiter, must be plain address */
+		*typep = 'a';
+		return atoaddr(src, srclen, &addrsp[0]);
+	}
+
+	/* looks like a range */
+	*typep = 'r';
+	if (stop - punct > 4 && *(punct+3) == '.')
+		punct++;		/* first dot is trailing dot of name */
+	oops = atoaddr(src, punct - src, &addrsp[0]);
+	if (oops != NULL)
+		return oops;
+	oops = atoaddr(punct+3, stop - (punct+3), &addrsp[1]);
+	if (oops != NULL)
+		return oops;
+	if (ntohl(addrsp[0].s_addr) > ntohl(addrsp[1].s_addr))
+		return "invalid range, begin > end";
+	return NULL;
+}
+
+
+
+#ifdef ATOASR_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	struct in_addr a[2];
+	char buf[100];
+	const char *oops;
+	size_t n;
+	char type;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s {addr|net/mask|begin...end|-r}\n",
+								argv[0]);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	oops = atoasr(argv[1], 0, &type, a);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	switch (type) {
+	case 'a':
+		n = addrtoa(a[0], 0, buf, sizeof(buf));
+		break;
+	case 's':
+		n = subnettoa(a[0], a[1], 0, buf, sizeof(buf));
+		break;
+	case 'r':
+		n = rangetoa(a, 0, buf, sizeof(buf));
+		break;
+	default:
+		fprintf(stderr, "%s: unknown type '%c'\n", argv[0], type);
+		exit(1);
+		break;
+	}
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conversion of ", argv[0]);
+		fprintf(stderr, "%s ", inet_ntoa(a[0]));
+		fprintf(stderr, "%s", inet_ntoa(a[1]));
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	char *input;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	"1.2.3.0",			"1.2.3.0",
+	"1.2.3.0/255.255.255.0",	"1.2.3.0/24",
+	"1.2.3.0...1.2.3.5",		"1.2.3.0...1.2.3.5",
+	"1.2.3.4.5",			NULL,
+	"1.2.3.4/",			NULL,
+	"1.2.3.4...",			NULL,
+	"1.2.3.4....",			NULL,
+	"localhost./32",		"127.0.0.1/32",
+	"localhost....127.0.0.3",	"127.0.0.1...127.0.0.3",
+	"127.0.0.0...localhost.",	"127.0.0.0...127.0.0.1",
+	"127.0.0.3...localhost.",	NULL,
+	NULL,				NULL
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	struct in_addr a[2];
+	struct in_addr m;
+	char in[100];
+	char buf[100];
+	const char *oops;
+	size_t n;
+	char type;
+
+	for (r = rtab; r->input != NULL; r++) {
+		strcpy(in, r->input);
+		oops = atoasr(in, 0, &type, a);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s' atoasr failed: %s\n", r->input, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s' atoasr succeeded unexpectedly '%c'\n",
+							r->input, type);
+			status = 1;
+		} else {
+			switch (type) {
+			case 'a':
+				n = addrtoa(a[0], 0, buf, sizeof(buf));
+				break;
+			case 's':
+				n = subnettoa(a[0], a[1], 0, buf, sizeof(buf));
+				break;
+			case 'r':
+				n = rangetoa(a, 0, buf, sizeof(buf));
+				break;
+			default:
+				fprintf(stderr, "`%s' unknown type '%c'\n",
+							r->input, type);
+				n = 0;
+				status = 1;
+				break;
+			}
+			if (n > sizeof(buf)) {
+				printf("`%s' '%c' reverse failed:  need %ld\n",
+						r->input, type, (long)n);
+				status = 1;
+			} else if (n > 0 && strcmp(r->output, buf) != 0) {
+				printf("`%s' '%c' gave `%s', expected `%s'\n",
+					r->input, type, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* ATOASR_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/atosa.c linux/net/ipsec/libfreeswan/atosa.c
--- linux-noipsec/net/ipsec/libfreeswan/atosa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/atosa.c	Sun Sep 17 20:55:37 2000
@@ -0,0 +1,199 @@
+/*
+ * convert from ASCII form of SA ID to binary
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static struct satype {
+	char *prefix;
+	size_t prelen;		/* strlen(prefix) */
+	int proto;
+} satypes[] = {
+	{ "ah",		2,	SA_AH	},
+	{ "esp",	3,	SA_ESP	},
+	{ "tun",	3,	SA_IPIP },
+	{ "comp",	4,	SA_COMP },
+	{ NULL,		0,	0,	}
+};
+
+/*
+ - atosa - convert ASCII "ah507@10.0.0.1" to SA identifier
+ */
+const char *			/* NULL for success, else string literal */
+atosa(src, srclen, sa)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+struct sa_id *sa;
+{
+	const char *at;
+	const char *addr;
+	const char *spi = NULL;
+	struct satype *sat;
+	unsigned long ul;
+	const char *oops;
+#	define	MINLEN	5	/* ah0@0 is as short as it can get */
+	static char ptname[] = PASSTHROUGHNAME;
+#	define	PTNLEN	(sizeof(ptname)-1)	/* -1 for NUL */
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+	if (srclen < MINLEN)
+		return "string too short to be SA specifier";
+	if (srclen == PTNLEN && memcmp(src, ptname, PTNLEN) == 0) {
+		src = PASSTHROUGHIS;
+		srclen = strlen(src);
+	}
+
+	at = memchr(src, '@', srclen);
+	if (at == NULL)
+		return "no @ in SA specifier";
+
+	for (sat = satypes; sat->prefix != NULL; sat++)
+		if (sat->prelen < srclen &&
+				strncmp(src, sat->prefix, sat->prelen) == 0) {
+			sa->proto = sat->proto;
+			spi = src + sat->prelen;
+			break;			/* NOTE BREAK OUT */
+		}
+	if (sat->prefix == NULL)
+		return "SA specifier lacks valid protocol prefix";
+
+	if (spi >= at)
+		return "no SPI in SA specifier";
+	oops = atoul(spi, at - spi, 13, &ul);
+	if (oops != NULL)
+		return oops;
+	sa->spi = htonl(ul);
+
+	addr = at + 1;
+	oops = atoaddr(addr, srclen - (addr - src), &sa->dst);
+	if (oops != NULL)
+		return oops;
+
+	return NULL;
+}
+
+
+
+#ifdef ATOSA_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	struct sa_id sa;
+	char buf[100];
+	const char *oops;
+	size_t n;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s {ahnnn@aaa|-r}\n", argv[0]);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	oops = atosa(argv[1], 0, &sa);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	n = satoa(sa, 0, buf, sizeof(buf));
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conv of `%d'", argv[0], sa.proto);
+		fprintf(stderr, "%lu@", sa.spi);
+		fprintf(stderr, "%s", inet_ntoa(sa.dst));
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	char *input;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	"esp257@1.2.3.0",		"esp257@1.2.3.0",
+	"ah0x20@1.2.3.4",		"ah32@1.2.3.4",
+	"tun011@111.2.3.99",		"tun11@111.2.3.99",
+	"",				NULL,
+	"_",				NULL,
+	"ah2.2",			NULL,
+	"goo2@1.2.3.4",			NULL,
+	"esp9@1.2.3.4",			"esp9@1.2.3.4",
+	"espp9@1.2.3.4",		NULL,
+	"es9@1.2.3.4",			NULL,
+	"ah@1.2.3.4",			NULL,
+	"esp7x7@1.2.3.4",		NULL,
+	"esp77@1.0x2.3.4",		NULL,
+	PASSTHROUGHNAME,		PASSTHROUGHNAME,
+	NULL,				NULL
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	struct sa_id sa;
+	char in[100];
+	char buf[100];
+	const char *oops;
+	size_t n;
+
+	for (r = rtab; r->input != NULL; r++) {
+		strcpy(in, r->input);
+		oops = atosa(in, 0, &sa);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s' atosa failed: %s\n", r->input, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s' atosa succeeded unexpectedly\n",
+								r->input);
+			status = 1;
+		} else {
+			n = satoa(sa, 'd', buf, sizeof(buf));
+			if (n > sizeof(buf)) {
+				printf("`%s' satoa failed:  need %ld\n",
+							r->input, (long)n);
+				status = 1;
+			} else if (strcmp(r->output, buf) != 0) {
+				printf("`%s' gave `%s', expected `%s'\n",
+						r->input, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* ATOSA_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/atosubnet.c linux/net/ipsec/libfreeswan/atosubnet.c
--- linux-noipsec/net/ipsec/libfreeswan/atosubnet.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/atosubnet.c	Wed Feb 16 19:59:08 2000
@@ -0,0 +1,215 @@
+/*
+ * convert from ASCII form of subnet specification to binary
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+#ifndef DEFAULTSUBNET
+#define	DEFAULTSUBNET	"%default"
+#endif
+
+/*
+ - atosubnet - convert ASCII "addr/mask" to address and mask
+ * Mask can be integer bit count.
+ */
+const char *			/* NULL for success, else string literal */
+atosubnet(src, srclen, addrp, maskp)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+struct in_addr *addrp;
+struct in_addr *maskp;
+{
+	const char *slash;
+	const char *mask;
+	size_t mlen;
+	const char *oops;
+	unsigned long bc;
+	static char def[] = DEFAULTSUBNET;
+#	define	DEFLEN	(sizeof(def) - 1)	/* -1 for NUL */
+	static char defis[] = "0/0";
+#	define	DEFILEN	(sizeof(defis) - 1)
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	if (srclen == DEFLEN && strncmp(src, def, srclen) == 0) {
+		src = defis;
+		srclen = DEFILEN;
+	}
+
+	slash = memchr(src, '/', srclen);
+	if (slash == NULL)
+		return "no / in subnet specification";
+	mask = slash + 1;
+	mlen = srclen - (mask - src);
+
+	oops = atoaddr(src, slash-src, addrp);
+	if (oops != NULL)
+		return oops;
+
+	oops = atoul(mask, mlen, 10, &bc);
+	if (oops == NULL) {
+		/* atoul succeeded, it's a bit-count mask */
+		if (bc > ABITS)
+			return "bit-count mask too large";
+#ifdef NOLEADINGZEROS
+		if (mlen > 1 && *mask == '0')
+			return "octal not allowed in mask";
+#endif /* NOLEADINGZEROS */
+		*maskp = bitstomask((int)bc);
+	} else {
+		oops = atoaddr(mask, mlen, maskp);
+		if (oops != NULL)
+			return oops;
+		if (!goodmask(*maskp))
+			return "non-contiguous mask";
+	}
+
+	addrp->s_addr &= maskp->s_addr;
+	return NULL;
+}
+
+
+
+#ifdef ATOSUBNET_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	struct in_addr a;
+	struct in_addr m;
+	char buf[100];
+	const char *oops;
+	size_t n;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s {addr/mask|-r}\n", argv[0]);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	oops = atosubnet(argv[1], 0, &a, &m);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	n = subnettoa(a, m, 0, buf, sizeof(buf));
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conversion of ", argv[0]);
+		fprintf(stderr, "%s/", inet_ntoa(a));
+		fprintf(stderr, "%s", inet_ntoa(m));
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	char *input;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	"1.2.3.0/255.255.255.0",	"1.2.3.0/24",
+	"1.2.3.0/24",			"1.2.3.0/24",
+	"1.2.3.1/255.255.255.240",	"1.2.3.0/28",
+	"1.2.3.1/32",			"1.2.3.1/32",
+	"1.2.3.1/0",			"0.0.0.0/0",
+/*	"1.2.3.1/255.255.127.0",	"1.2.3.0/255.255.127.0",	*/
+	"1.2.3.1/255.255.127.0",	NULL,
+	"128.009.000.032/32",		"128.9.0.32/32",
+	"128.0x9.0.32/32",		NULL,
+	"0x80090020/32",		"128.9.0.32/32",
+	"0x800x0020/32",		NULL,
+	"128.9.0.32/0xffFF0000",	"128.9.0.0/16",
+	"128.9.0.32/0xff0000FF",	NULL,
+	"128.9.0.32/0x0000ffFF",	NULL,
+	"128.9.0.32/0x00ffFF0000",	NULL,
+	"128.9.0.32/0xffFF",		NULL,
+	"128.9.0.32.27/32",		NULL,
+	"128.9.0k32/32",		NULL,
+	"328.9.0.32/32",		NULL,
+	"128.9..32/32",			NULL,
+	"10/8",				"10.0.0.0/8",
+	"10.0/8",			"10.0.0.0/8",
+	"10.0.0/8",			"10.0.0.0/8",
+	"10.0.1/24",			"10.0.1.0/24",
+	"_",				NULL,
+	"_/_",				NULL,
+	"1.2.3.1",			NULL,
+	"1.2.3.1/_",			NULL,
+	"1.2.3.1/24._",			NULL,
+	"1.2.3.1/99",			NULL,
+	"localhost./32",		"127.0.0.1/32",
+	"%default",			"0.0.0.0/0",
+	NULL,				NULL
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	struct in_addr a;
+	struct in_addr m;
+	char in[100];
+	char buf[100];
+	const char *oops;
+	size_t n;
+
+	for (r = rtab; r->input != NULL; r++) {
+		strcpy(in, r->input);
+		oops = atosubnet(in, 0, &a, &m);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s' atosubnet failed: %s\n", r->input, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s' atosubnet succeeded unexpectedly\n",
+								r->input);
+			status = 1;
+		} else {
+			n = subnettoa(a, m, 0, buf, sizeof(buf));
+			if (n > sizeof(buf)) {
+				printf("`%s' subnettoa failed:  need %ld\n",
+							r->input, (long)n);
+				status = 1;
+			} else if (strcmp(r->output, buf) != 0) {
+				printf("`%s' gave `%s', expected `%s'\n",
+						r->input, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* ATOSUBNET_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/atoul.c linux/net/ipsec/libfreeswan/atoul.c
--- linux-noipsec/net/ipsec/libfreeswan/atoul.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/atoul.c	Tue Dec  7 06:00:52 1999
@@ -0,0 +1,90 @@
+/*
+ * convert from ASCII form of unsigned long to binary
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - atoul - convert ASCII substring to unsigned long number
+ */
+const char *			/* NULL for success, else string literal */
+atoul(src, srclen, base, resultp)
+const char *src;
+size_t srclen;			/* 0 means strlen(src) */
+int base;			/* 0 means figure it out */
+unsigned long *resultp;
+{
+	const char *stop;
+	static char hex[] = "0123456789abcdef";
+	static char uchex[] = "0123456789ABCDEF";
+	int d;
+	char c;
+	char *p;
+	unsigned long r;
+	unsigned long rlimit;
+	int dlimit;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	if (base == 0 || base == 13) {
+		if (srclen > 2 && *src == '0' && CIEQ(*(src+1), 'x'))
+			return atoul(src+2, srclen-2, 16, resultp);
+		if (srclen > 1 && *src == '0' && base != 13)
+			return atoul(src+1, srclen-1, 8, resultp);
+		return atoul(src, srclen, 10, resultp);
+	}
+	if (base != 8 && base != 10 && base != 16)
+		return "unsupported number base";
+
+	r = 0;
+	stop = src + srclen;
+	if (base == 16) {
+		while (src < stop) {
+			c = *src++;
+			p = strchr(hex, c);
+			if (p != NULL)
+				d = p - hex;
+			else {
+				p = strchr(uchex, c);
+				if (p == NULL)
+					return "non-hex-digit in hex number";
+				d = p - uchex;
+			}
+			r = (r << 4) | d;
+		}
+		/* defer length check to catch invalid digits first */
+		if (srclen > sizeof(unsigned long) * 2)
+			return "hex number too long";
+	} else {
+		rlimit = ULONG_MAX / base;
+		dlimit = (int)(ULONG_MAX - rlimit*base);
+		while (src < stop) {
+			c = *src++;
+			d = c - '0';
+			if (d < 0 || d >= base)
+				return "non-digit in number";
+			if (r > rlimit || (r == rlimit && d > dlimit))
+				return "unsigned-long overflow";
+			r = r*base + d;
+		}
+	}
+
+	*resultp = r;
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/datatot.c linux/net/ipsec/libfreeswan/datatot.c
--- linux-noipsec/net/ipsec/libfreeswan/datatot.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/datatot.c	Fri Aug 18 17:09:07 2000
@@ -0,0 +1,225 @@
+/*
+ * convert from binary data (e.g. key) to text form
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static void convert(const char *src, size_t nreal, int format, char *out);
+
+/*
+ - datatot - convert data bytes to text
+ */
+size_t				/* true length (with NUL) for success */
+datatot(src, srclen, format, dst, dstlen)
+const char *src;
+size_t srclen;
+int format;			/* character indicating what format */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t inblocksize;	/* process this many bytes at a time */
+	size_t outblocksize;	/* producing this many */
+	size_t breakevery;	/* add a _ every this many (0 means don't) */
+	size_t sincebreak;	/* output bytes since last _ */
+	char inblock[10];	/* enough for any format */
+	char outblock[10];	/* enough for any format */
+	char fake[1];		/* fake output area for dstlen == 0 */
+	size_t needed;		/* return value */
+	char *stop;		/* where the terminating NUL will go */
+	size_t ntodo;		/* remaining input */
+	size_t nreal;
+	char *out;
+	char *prefix;
+
+	breakevery = 0;
+	switch (format) {
+	case 0:
+	case 'h':
+		format = 'x';
+		breakevery = 8;
+		/* FALLTHROUGH */
+	case 'x':
+		inblocksize = 1;
+		outblocksize = 2;
+		prefix = "0x";
+		break;
+	case 16:
+		inblocksize = 1;
+		outblocksize = 2;
+		prefix = "";
+		format = 'x';
+		break;
+	case 's':
+		inblocksize = 3;
+		outblocksize = 4;
+		prefix = "0s";
+		break;
+	case 64:		/* beware, equals ' ' */
+		inblocksize = 3;
+		outblocksize = 4;
+		prefix = "";
+		format = 's';
+		break;
+	default:
+		return 0;
+		break;
+	}
+	assert(inblocksize < sizeof(inblock));
+	assert(outblocksize < sizeof(outblock));
+	assert(breakevery % outblocksize == 0);
+
+	if (srclen == 0)
+		return 0;
+	ntodo = srclen;
+
+	if (dstlen == 0) {	/* dispose of awkward special case */
+		dst = fake;
+		dstlen = 1;
+	}
+	stop = dst + dstlen - 1;
+
+	nreal = strlen(prefix);
+	needed = nreal;			/* for starters */
+	if (dstlen <= nreal) {		/* prefix won't fit */
+		strncpy(dst, prefix, dstlen - 1);
+		dst += dstlen - 1;
+	} else {
+		strcpy(dst, prefix);
+		dst += nreal;
+	}
+	assert(dst <= stop);
+	sincebreak = 0;
+
+	while (ntodo > 0) {
+		if (ntodo < inblocksize) {	/* incomplete input */
+			memset(inblock, 0, sizeof(inblock));
+			memcpy(inblock, src, ntodo);
+			src = inblock;
+			nreal = ntodo;
+			ntodo = inblocksize;
+		} else
+			nreal = inblocksize;
+		out = (outblocksize > stop - dst) ? outblock : dst;
+
+		convert(src, nreal, format, out);
+		needed += outblocksize;
+		sincebreak += outblocksize;
+		if (dst < stop) {
+			if (out != dst) {
+				assert(outblocksize > stop - dst);
+				memcpy(dst, out, stop - dst);
+				dst = stop;
+			} else
+				dst += outblocksize;
+		}
+
+		src += inblocksize;
+		ntodo -= inblocksize;
+		if (breakevery != 0 && sincebreak >= breakevery && ntodo > 0) {
+			if (dst < stop)
+				*dst++ = '_';
+			needed++;
+			sincebreak = 0;
+		}
+	}
+
+	assert(dst <= stop);
+	*dst++ = '\0';
+	needed++;
+
+	return needed;
+}
+
+/*
+ - convert - convert one input block to one output block
+ */
+static void
+convert(src, nreal, format, out)
+const char *src;
+size_t nreal;			/* how much of the input block is real */
+int format;
+char *out;
+{
+	static char hex[] = "0123456789abcdef";
+	static char base64[] =	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+				"abcdefghijklmnopqrstuvwxyz"
+				"0123456789+/";
+	unsigned char c;
+	unsigned char c1, c2, c3;
+
+	assert(nreal > 0);
+	switch (format) {
+	case 'x':
+		assert(nreal == 1);
+		c = (unsigned char)*src;
+		*out++ = hex[c >> 4];
+		*out++ = hex[c & 0xf];
+		break;
+	case 's':
+		c1 = (unsigned char)*src++;
+		c2 = (unsigned char)*src++;
+		c3 = (unsigned char)*src++;
+		*out++ = base64[c1 >> 2];	/* top 6 bits of c1 */
+		c = (c1 & 0x3) << 4;		/* bottom 2 of c1... */
+		c |= c2 >> 4;			/* ...top 4 of c2 */
+		*out++ = base64[c];
+		if (nreal == 1)
+			*out++ = '=';
+		else {
+			c = (c2 & 0xf) << 2;	/* bottom 4 of c2... */
+			c |= c3 >> 6;		/* ...top 2 of c3 */
+			*out++ = base64[c];
+		}
+		if (nreal <= 2)
+			*out++ = '=';
+		else
+			*out++ = base64[c3 & 0x3f];	/* bottom 6 of c3 */
+		break;
+	default:
+		assert(nreal == 0);	/* unknown format */
+		break;
+	}
+}
+
+/*
+ - datatoa - convert data to ASCII
+ * backward-compatibility synonym for datatot
+ */
+size_t				/* true length (with NUL) for success */
+datatoa(src, srclen, format, dst, dstlen)
+const char *src;
+size_t srclen;
+int format;			/* character indicating what format */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	return datatot(src, srclen, format, dst, dstlen);
+}
+
+/*
+ - bytestoa - convert data bytes to ASCII
+ * backward-compatibility synonym for datatot
+ */
+size_t				/* true length (with NUL) for success */
+bytestoa(src, srclen, format, dst, dstlen)
+const char *src;
+size_t srclen;
+int format;			/* character indicating what format */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	return datatot(src, srclen, format, dst, dstlen);
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/freeswan.h linux/net/ipsec/libfreeswan/freeswan.h
--- linux-noipsec/net/ipsec/libfreeswan/freeswan.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/freeswan.h	Mon Nov  6 05:37:12 2000
@@ -0,0 +1,474 @@
+#ifndef _FREESWAN_H
+/*
+ * header file for FreeS/WAN library functions
+ * Copyright (C) 1998, 1999, 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#define	_FREESWAN_H	/* seen it, no need to see it again */
+
+
+
+/*
+ * First, assorted kernel-version-dependent trickery.
+ */
+#include <linux/version.h>
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+#define HEADER_CACHE_BIND_21
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#define SPINLOCK
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#  define SPINLOCK_23
+#  endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,25)
+#define PROC_FS_2325
+#else
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#  define PROC_FS_21
+#  endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#define NETDEV_23
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+#define NETLINK_SOCK
+#define NET_21
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,30)
+#define PROC_NO_DUMMY
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,35)
+#define SKB_COPY_EXPAND
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,37)
+#define IP_SELECT_IDENT
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,50)) && defined(CONFIG_NETFILTER)
+#define SKB_RESET_NFCT
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,19)
+#define net_device_stats enet_statistics
+#endif                                                                         
+
+
+
+/*
+ * We've just got to have some datatypes defined...  And annoyingly, just
+ * where we get them depends on whether we're in userland or not.
+ */
+#ifdef __KERNEL__
+
+#  include <linux/types.h>
+#  include <linux/in.h>
+
+#  ifdef NET_21
+#    include <linux/in6.h>
+#  else
+     /* old kernel in.h has some IPv6 stuff, but not quite enough */
+#    define	s6_addr16	s6_addr
+#    define	AF_INET6	10
+#    define uint8_t __u8
+#    define uint16_t __u16 
+#    define uint32_t __u32 
+#    define uint64_t __u64 
+#  endif
+
+#  ifndef SPINLOCK
+#    include <linux/bios32.h>
+     /* simulate spin locks and read/write locks */
+     typedef struct {
+       volatile char lock;
+     } spinlock_t;
+
+     typedef struct {
+       volatile unsigned int lock;
+     } rwlock_t;                                                                     
+
+#    define spin_lock_init(x) { (x)->lock = 0;}
+#    define rw_lock_init(x) { (x)->lock = 0; }
+
+#    define spin_lock(x) { while ((x)->lock) barrier(); (x)->lock=1;}
+#    define spin_lock_irq(x) { cli(); spin_lock(x);}
+#    define spin_lock_irqsave(x,flags) { save_flags(flags); spin_lock_irq(x);}
+
+#    define spin_unlock(x) { (x)->lock=0;}
+#    define spin_unlock_irq(x) { spin_unlock(x); sti();}
+#    define spin_unlock_irqrestore(x,flags) { spin_unlock(x); restore_flags(flags);}
+
+#    define read_lock(x) spin_lock(x)
+#    define read_lock_irq(x) spin_lock_irq(x)
+#    define read_lock_irqsave(x,flags) spin_lock_irqsave(x,flags)
+
+#    define read_unlock(x) spin_unlock(x)
+#    define read_unlock_irq(x) spin_unlock_irq(x)
+#    define read_unlock_irqrestore(x,flags) spin_unlock_irqrestore(x,flags)
+
+#    define write_lock(x) spin_lock(x)
+#    define write_lock_irq(x) spin_lock_irq(x)
+#    define write_lock_irqsave(x,flags) spin_lock_irqsave(x,flags)
+
+#    define write_unlock(x) spin_unlock(x)
+#    define write_unlock_irq(x) spin_unlock_irq(x)
+#    define write_unlock_irqrestore(x,flags) spin_unlock_irqrestore(x,flags)
+#  endif /* !SPINLOCK */
+
+#  ifndef SPINLOCK_23
+#    define spin_lock_bh(x)  spin_lock_irq(x)
+#    define spin_unlock_bh(x)  spin_unlock_irq(x)
+
+#    define read_lock_bh(x)  read_lock_irq(x)
+#    define read_unlock_bh(x)  read_unlock_irq(x)
+
+#    define write_lock_bh(x)  write_lock_irq(x)
+#    define write_unlock_bh(x)  write_unlock_irq(x)
+#  endif /* !SPINLOCK_23 */
+
+#ifndef IPPROTO_COMP
+#define IPPROTO_COMP 108
+#endif /* !IPPROTO_COMP */
+
+#ifdef CONFIG_IPSEC_DEBUG
+#define DEBUG_NO_STATIC
+#else /* CONFIG_IPSEC_DEBUG */
+#define DEBUG_NO_STATIC static
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#else /* __KERNEL__ */
+
+#  include <stdio.h>
+#  include <netinet/in.h>
+
+#  define uint8_t u_int8_t
+#  define uint16_t u_int16_t 
+#  define uint32_t u_int32_t 
+#  define uint64_t u_int64_t 
+
+#define DEBUG_NO_STATIC static
+
+#endif /* __KERNEL__ */
+
+
+
+/*
+ * Basic data types for the address-handling functions.
+ * ip_address and ip_subnet are supposed to be opaque types; do not
+ * use their definitions directly, they are subject to change!
+ */
+
+/* first, some quick fakes in case we're on an old system with no IPv6 */
+#ifndef __KERNEL__
+#ifndef IN6ADDR_ANY_INIT
+struct in6_addr {
+	unsigned char s6_addr16[16];
+};
+struct sockaddr_in6 {
+	unsigned short sin6_family;
+	unsigned short sin6_port;
+	unsigned long sin6_flowinfo;
+	struct {
+		unsigned char s6_addr16[16];
+	} sin6_addr;
+};
+#endif	/* !IN6ADDR_ANY_INIT */
+#endif	/* !__KERNEL__ */
+
+/* then the main types */
+typedef struct {
+	union {
+		struct sockaddr_in v4;
+		struct sockaddr_in6 v6;
+	} u;
+} ip_address;
+typedef struct {
+	ip_address addr;
+	int maskbits;
+} ip_subnet;
+
+/* and the SA ID stuff */
+#ifdef __KERNEL__
+typedef __u32 ipsec_spi_t;
+#else
+typedef u_int32_t ipsec_spi_t;
+#endif
+typedef struct {		/* to identify an SA, we need: */
+        ip_address dst;		/* A. destination host */
+        ipsec_spi_t spi;	/* B. 32-bit SPI, assigned by dest. host */
+	int proto;		/* C. protocol */
+#		define	SA_ESP	50	/* IPPROTO_ESP */
+#		define	SA_AH	51	/* IPPROTO_AH */
+#		define	SA_IPIP	4	/* IPPROTO_IPIP */
+#		define	SA_COMP	108	/* IPPROTO_COMP */
+} ip_said;
+struct sa_id {			/* old v4-only version */
+        struct in_addr dst;
+        ipsec_spi_t spi;
+	int proto;
+};
+
+/* misc */
+typedef const char *err_t;	/* error message, or NULL for success */
+
+
+
+/*
+ * new IPv6-compatible functions
+ */
+
+/* text conversions */
+err_t ttoul(const char *src, size_t srclen, int format, unsigned long *dst);
+size_t ultot(unsigned long src, int format, char *buf, size_t buflen);
+#define	ULTOT_BUF	(22+1)	/* holds 64 bits in octal */
+err_t ttoaddr(const char *src, size_t srclen, int af, ip_address *dst);
+err_t tnatoaddr(const char *src, size_t srclen, int af, ip_address *dst);
+size_t addrtot(const ip_address *src, int format, char *buf, size_t buflen);
+/* RFC 1886 old IPv6 reverse-lookup format is the bulkiest */
+#define	ADDRTOT_BUF	(32*2 + 3 + 1 + 3 + 1 + 1)
+err_t ttosubnet(const char *src, size_t srclen, int af, ip_subnet *dst);
+size_t subnettot(const ip_subnet *src, int format, char *buf, size_t buflen);
+#define	SUBNETTOT_BUF	(ADDRTOT_BUF + 1 + 3)
+err_t ttosa(const char *src, size_t srclen, ip_said *dst);
+size_t satot(const ip_said *src, int format, char *bufptr, size_t buflen);
+#define	SATOT_BUF	(5 + ULTOA_BUF + 1 + ADDRTOT_BUF)
+err_t ttodata(const char *src, size_t srclen, int base, char *buf,
+						size_t buflen, size_t *needed);
+size_t datatot(const char *src, size_t srclen, int format, char *buf,
+								size_t buflen);
+
+/* initializations */
+void initsaid(const ip_address *addr, ipsec_spi_t spi, int proto, ip_said *dst);
+err_t loopbackaddr(int af, ip_address *dst);
+err_t unspecaddr(int af, ip_address *dst);
+err_t anyaddr(int af, ip_address *dst);
+err_t initaddr(const unsigned char *src, size_t srclen, int af, ip_address *dst);
+err_t initsubnet(const ip_address *addr, int maskbits, int clash, ip_subnet *dst);
+
+/* misc. conversions and related */
+err_t rangetosubnet(const ip_address *from, const ip_address *to, ip_subnet *dst);
+int addrtypeof(const ip_address *src);
+int subnettypeof(const ip_subnet *src);
+size_t addrlenof(const ip_address *src);
+size_t addrbytesptr(const ip_address *src, const unsigned char **dst);
+size_t addrbytesof(const ip_address *src, unsigned char *dst, size_t dstlen);
+int masktocount(const ip_address *src);
+void networkof(const ip_subnet *src, ip_address *dst);
+void maskof(const ip_subnet *src, ip_address *dst);
+
+/* tests */
+int sameaddr(const ip_address *a, const ip_address *b);
+int addrcmp(const ip_address *a, const ip_address *b);
+int samesubnet(const ip_subnet *a, const ip_subnet *b);
+int addrinsubnet(const ip_address *a, const ip_subnet *s);
+int subnetinsubnet(const ip_subnet *a, const ip_subnet *b);
+int subnetishost(const ip_subnet *s);
+int samesaid(const ip_said *a, const ip_said *b);
+int sameaddrtype(const ip_address *a, const ip_address *b);
+int samesubnettype(const ip_subnet *a, const ip_subnet *b);
+int isanyaddr(const ip_address *src);
+int isunspecaddr(const ip_address *src);
+int isloopbackaddr(const ip_address *src);
+
+/* low-level grot */
+int portof(const ip_address *src);
+void setportof(int port, ip_address *dst);
+struct sockaddr *sockaddrof(ip_address *src);
+size_t sockaddrlenof(const ip_address *src);
+
+
+
+/*
+ * old functions, to be deleted eventually
+ */
+
+/* unsigned long */
+const char *			/* NULL for success, else string literal */
+atoul(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	int base,		/* 0 means figure it out */
+	unsigned long *resultp
+);
+size_t				/* space needed for full conversion */
+ultoa(
+	unsigned long n,
+	int base,
+	char *dst,
+	size_t dstlen
+);
+#define	ULTOA_BUF	21	/* just large enough for largest result, */
+				/* assuming 64-bit unsigned long! */
+
+/* Internet addresses */
+const char *			/* NULL for success, else string literal */
+atoaddr(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	struct in_addr *addr
+);
+size_t				/* space needed for full conversion */
+addrtoa(
+	struct in_addr addr,
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+#define	ADDRTOA_BUF	16	/* just large enough for largest result */
+
+/* subnets */
+const char *			/* NULL for success, else string literal */
+atosubnet(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	struct in_addr *addr,
+	struct in_addr *mask
+);
+size_t				/* space needed for full conversion */
+subnettoa(
+	struct in_addr addr,
+	struct in_addr mask,
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+#define	SUBNETTOA_BUF	32	/* large enough for worst case result */
+
+/* ranges */
+const char *			/* NULL for success, else string literal */
+atoasr(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	char *type,		/* 'a', 's', 'r' */
+	struct in_addr *addrs	/* two-element array */
+);
+size_t				/* space needed for full conversion */
+rangetoa(
+	struct in_addr *addrs,	/* two-element array */
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+#define	RANGETOA_BUF	34	/* large enough for worst case result */
+
+/* data types for SA conversion functions */
+
+/* SAs */
+const char *			/* NULL for success, else string literal */
+atosa(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	struct sa_id *sa
+);
+size_t				/* space needed for full conversion */
+satoa(
+	struct sa_id sa,
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+#define	SATOA_BUF	(3+ULTOA_BUF+ADDRTOA_BUF)
+
+/* generic data, e.g. keys */
+const char *			/* NULL for success, else string literal */
+atobytes(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	char *dst,
+	size_t dstlen,
+	size_t *lenp		/* NULL means don't bother telling me */
+);
+size_t				/* 0 failure, else true size */
+bytestoa(
+	const char *src,
+	size_t srclen,
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+
+/* old versions of generic-data functions; deprecated */
+size_t				/* 0 failure, else true size */
+atodata(
+	const char *src,
+	size_t srclen,		/* 0 means strlen(src) */
+	char *dst,
+	size_t dstlen
+);
+size_t				/* 0 failure, else true size */
+datatoa(
+	const char *src,
+	size_t srclen,
+	int format,		/* character; 0 means default */
+	char *dst,
+	size_t dstlen
+);
+
+/* part extraction and special addresses */
+struct in_addr
+subnetof(
+	struct in_addr addr,
+	struct in_addr mask
+);
+struct in_addr
+hostof(
+	struct in_addr addr,
+	struct in_addr mask
+);
+struct in_addr
+broadcastof(
+	struct in_addr addr,
+	struct in_addr mask
+);
+
+/* mask handling */
+int
+goodmask(
+	struct in_addr mask
+);
+int
+masktobits(
+	struct in_addr mask
+);
+struct in_addr
+bitstomask(
+	int n
+);
+
+
+
+/*
+ * general utilities
+ */
+
+#ifndef __KERNEL__
+/* option pickup from files (userland only because of use of FILE) */
+const char *optionsfrom(const char *filename, int *argcp, char ***argvp,
+						int optind, FILE *errorreport);
+#endif
+
+
+
+#endif /* _FREESWAN_H */
diff -druN linux-noipsec/net/ipsec/libfreeswan/goodmask.c linux/net/ipsec/libfreeswan/goodmask.c
--- linux-noipsec/net/ipsec/libfreeswan/goodmask.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/goodmask.c	Wed Feb 16 19:54:24 2000
@@ -0,0 +1,97 @@
+/*
+ * minor utilities for subnet-mask manipulation
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - goodmask - is this a good (^1*0*$) subnet mask?
+ * You are not expected to understand this.  See Henry S. Warren Jr, 
+ * "Functions realizable with word-parallel logical and two's-complement
+ * addition instructions", CACM 20.6 (June 1977), p.439.
+ */
+int				/* predicate */
+goodmask(mask)
+struct in_addr mask;
+{
+	unsigned long x = ntohl(mask.s_addr);
+	/* clear rightmost contiguous string of 1-bits */
+#	define	CRCS1B(x)	(((x|(x-1))+1)&x)
+#	define	TOPBIT		(1UL << 31)
+
+	/* either zero, or has one string of 1-bits which is left-justified */
+	if (x == 0 || (CRCS1B(x) == 0 && (x&TOPBIT)))
+		return 1;
+	return 0;
+}
+
+/*
+ - masktobits - how many bits in this mask?
+ * The algorithm is essentially a binary search, but highly optimized
+ * for this particular task.
+ */
+int				/* -1 means !goodmask() */
+masktobits(mask)
+struct in_addr mask;
+{
+	unsigned long m = ntohl(mask.s_addr);
+	int masklen;
+
+	if (!goodmask(mask))
+		return -1;
+
+	if (m&0x00000001UL)
+		return 32;
+	masklen = 0;
+	if (m&(0x0000ffffUL<<1)) {	/* <<1 for 1-origin numbering */
+		masklen |= 0x10;
+		m <<= 16;
+	}
+	if (m&(0x00ff0000UL<<1)) {
+		masklen |= 0x08;
+		m <<= 8;
+	}
+	if (m&(0x0f000000UL<<1)) {
+		masklen |= 0x04;
+		m <<= 4;
+	}
+	if (m&(0x30000000UL<<1)) {
+		masklen |= 0x02;
+		m <<= 2;
+	}
+	if (m&(0x40000000UL<<1))
+		masklen |= 0x01;
+
+	return masklen;
+}
+
+/*
+ - bitstomask - return a mask with this many high bits on
+ */
+struct in_addr
+bitstomask(n)
+int n;
+{
+	struct in_addr result;
+
+	if (n > 0 && n <= ABITS)
+		result.s_addr = htonl(~((1UL << (ABITS - n)) - 1));
+	else if (n == 0)
+		result.s_addr = 0;
+	else
+		result.s_addr = 0;	/* best error report we can do */
+	return result;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/initaddr.c linux/net/ipsec/libfreeswan/initaddr.c
--- linux-noipsec/net/ipsec/libfreeswan/initaddr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/initaddr.c	Fri Aug 25 16:40:05 2000
@@ -0,0 +1,51 @@
+/*
+ * initialize address structure
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - initaddr - initialize ip_address from bytes
+ */
+err_t				/* NULL for success, else string literal */
+initaddr(src, srclen, af, dst)
+const unsigned char *src;
+size_t srclen;
+int af;				/* address family */
+ip_address *dst;
+{
+	switch (af) {
+	case AF_INET:
+		if (srclen != 4)
+			return "IPv4 address must be exactly 4 bytes";
+		dst->u.v4.sin_family = af;
+		dst->u.v4.sin_port = 0;		/* unused */
+		memcpy((char *)&dst->u.v4.sin_addr.s_addr, src, srclen);
+		break;
+	case AF_INET6:
+		if (srclen != 16)
+			return "IPv6 address must be exactly 16 bytes";
+		dst->u.v6.sin6_family = af;
+		dst->u.v6.sin6_flowinfo = 0;		/* unused */
+		dst->u.v6.sin6_port = 0;		/* unused */
+		memcpy((char *)&dst->u.v6.sin6_addr, src, srclen);
+		break;
+	default:
+		return "unknown address family in initaddr";
+		break;
+	}
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/initsaid.c linux/net/ipsec/libfreeswan/initsaid.c
--- linux-noipsec/net/ipsec/libfreeswan/initsaid.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/initsaid.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,33 @@
+/*
+ * initialize SA ID structure
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - initsaid - initialize SA ID from bits
+ */
+void
+initsaid(addr, spi, proto, dst)
+const ip_address *addr;
+ipsec_spi_t spi;
+int proto;
+ip_said *dst;
+{
+	dst->dst = *addr;
+	dst->spi = spi;
+	dst->proto = proto;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/initsubnet.c linux/net/ipsec/libfreeswan/initsubnet.c
--- linux-noipsec/net/ipsec/libfreeswan/initsubnet.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/initsubnet.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,77 @@
+/*
+ * initialize subnet structure
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - initsubnet - initialize ip_subnet from address and count
+ *
+ * The only hard part is checking for host-part bits turned on.
+ */
+err_t				/* NULL for success, else string literal */
+initsubnet(addr, count, clash, dst)
+const ip_address *addr;
+int count;
+int clash;			/* '0' zero host-part bits, 'x' die on them */
+ip_subnet *dst;
+{
+	unsigned char *p;
+	int n;
+	int c;
+	unsigned m;
+	int die;
+
+	dst->addr = *addr;
+	n = addrbytesptr(&dst->addr, (const unsigned char **)&p);
+	if (n == 0)
+		return "unknown address family";
+
+	switch (clash) {
+	case '0':
+		die = 0;
+		break;
+	case 'x':
+		die = 1;
+		break;
+	default:
+		return "unknown clash-control value in initsubnet";
+		break;
+	}
+
+	c = count / 8;
+	if (c > n)
+		return "impossible mask count";
+	p += c;
+	n -= c;
+
+	m = 0xff;
+	c = count % 8;
+	if (n > 0 && c != 0)	/* partial byte */
+		m >>= c;
+	for (; n > 0; n--) {
+		if ((*p & m) != 0) {
+			if (die)
+				return "improper subnet, host-part bits on";
+			*p &= ~m;
+		}
+		m = 0xff;
+		p++;
+	}
+
+	dst->maskbits = count;
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/internal.h linux/net/ipsec/libfreeswan/internal.h
--- linux-noipsec/net/ipsec/libfreeswan/internal.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/internal.h	Tue Aug  8 04:34:15 2000
@@ -0,0 +1,81 @@
+/*
+ * internal definitions for use within the library; do not export!
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+
+#ifndef ABITS
+#define	ABITS	32	/* bits in an IPv4 address */
+#endif
+
+/* case-independent ASCII character equality comparison */
+#define	CIEQ(c1, c2)	( ((c1)&~040) == ((c2)&~040) )
+
+/* syntax for passthrough SA */
+#ifndef PASSTHROUGHNAME
+#define	PASSTHROUGHNAME	"%passthrough"
+#define	PASSTHROUGH4NAME	"%passthrough4"
+#define	PASSTHROUGH6NAME	"%passthrough6"
+#define	PASSTHROUGHIS	"tun0@0.0.0.0"
+#define	PASSTHROUGH4IS	"tun0@0.0.0.0"
+#define	PASSTHROUGH6IS	"tun0@::"
+#define	PASSTHROUGHTYPE	"tun"
+#define	PASSTHROUGHSPI	0
+#define	PASSTHROUGHDST	0
+#endif
+
+/*
+ * Headers, greatly complicated by stupid and unnecessary inconsistencies
+ * between the user environment and the kernel environment.  These are done
+ * here so that this mess need exist in only one place.
+ *
+ * It may seem like a -I or two could avoid most of this, but on closer
+ * inspection it is not quite that easy.
+ */
+
+/* things that need to come from one place or the other, depending */
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#define	assert(foo)	/* nothing */
+#else
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#endif
+
+/* things that exist only in userland */
+#ifndef __KERNEL__
+
+/* You'd think this would be okay in the kernel too -- it's just a */
+/* bunch of constants -- but no, in RH5.1 it screws up other things. */
+/* (Credit:  Mike Warfield tracked this problem down.  Thanks Mike!) */
+/* Fortunately, we don't need it in the kernel subset of the library. */
+#include <limits.h>
+
+/* header files for things that should never be called in kernel */
+#include <netdb.h>
+
+/* memory allocation, currently user-only, macro-ized just in case */
+#include <stdlib.h>
+#define	MALLOC(n)	malloc(n)
+#define	FREE(p)		free(p)
+
+#endif /* __KERNEL__ */
+
diff -druN linux-noipsec/net/ipsec/libfreeswan/optionsfrom.c linux/net/ipsec/libfreeswan/optionsfrom.c
--- linux-noipsec/net/ipsec/libfreeswan/optionsfrom.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/optionsfrom.c	Sun Apr 11 01:24:21 1999
@@ -0,0 +1,301 @@
+/*
+ * pick up more options from a file, in the middle of an option scan
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+#include <stdio.h>
+
+#define	MAX	100		/* loop-detection limit */
+
+/* internal work area */
+struct work {
+#	define	LOTS	1024
+	char buf[LOTS];
+	char *line;
+	char *pending;
+};
+
+static const char *dowork(const char *, int *, char ***, int);
+static const char *getanarg(FILE *, struct work *, char **);
+static char *getline(FILE *, char *, size_t);
+
+/*
+ - optionsfrom - add some options, taken from a file, to argc/argv
+ * If errsto is non-NULL, does not return in event of error.
+ */
+const char *			/* NULL for success, else string literal */
+optionsfrom(filename, argcp, argvp, optind, errsto)
+const char *filename;
+int *argcp;			/* pointer to argc */
+char ***argvp;			/* pointer to argv */
+int optind;			/* current optind, number of next argument */
+FILE *errsto;			/* where to report errors (NULL means return) */
+{
+	const char *e;
+	static int nuses = 0;
+
+	if (errsto != NULL) {
+		nuses++;
+		if (nuses >= MAX) {
+			fprintf(errsto,
+				"%s: optionsfrom called %d times, looping?\n",
+				(*argvp)[0], nuses);
+			exit(2);
+		}
+	} else
+		nuses = 0;
+
+	e = dowork(filename, argcp, argvp, optind);
+	if (e != NULL && errsto != NULL) {
+		fprintf(errsto, "%s: optionsfrom failed: %s\n", (*argvp)[0], e);
+		exit(2);
+	}
+	return e;
+}
+
+/*
+ - dowork - do all the real work of optionsfrom
+ * Does not alter the existing arguments, but does relocate and alter
+ * the argv pointer vector.
+ */
+static const char *		/* NULL for success, else string literal */
+dowork(filename, argcp, argvp, optind)
+const char *filename;
+int *argcp;			/* pointer to argc */
+char ***argvp;			/* pointer to argv */
+int optind;			/* current optind, number of next argument */
+{
+	char **newargv;
+	char **tmp;
+	int newargc;
+	int next;		/* place for next argument */
+	int room;		/* how many more new arguments we can hold */
+#	define	SOME	10	/* first guess at how many we'll need */
+	FILE *f;
+	int i;
+	const char *p;
+	struct work wa;		/* for getanarg() */
+
+	f = fopen(filename, "r");
+	if (f == NULL)
+		return "unable to open file";
+
+	newargc = *argcp + SOME;
+	newargv = malloc((newargc+1) * sizeof(char *));
+	if (newargv == NULL)
+		return "unable to allocate memory";
+	memcpy(newargv, *argvp, optind * sizeof(char *));
+	room = SOME;
+	next = optind;
+
+	newargv[next] = NULL;
+	wa.pending = NULL;
+	while ((p = getanarg(f, &wa, &newargv[next])) == NULL) {
+		if (room == 0) {
+			newargc += SOME;
+			tmp = realloc(newargv, (newargc+1) * sizeof(char *));
+			if (tmp == NULL) {
+				p = "out of space for new argv";
+				break;		/* NOTE BREAK OUT */
+			}
+			newargv = tmp;
+			room += SOME;
+		}
+		next++;
+		room--;
+	}
+	if (p != NULL && !feof(f)) {	/* error of some kind */
+		for (i = optind+1; i <= next; i++)
+			if (newargv[i] != NULL)
+				free(newargv[i]);
+		free(newargv);
+		fclose(f);
+		return p;
+	}
+
+	fclose(f);
+	memcpy(newargv + next, *argvp + optind,
+					(*argcp+1-optind) * sizeof(char *));
+	*argcp += next - optind;
+	*argvp = newargv;
+	return NULL;
+}
+
+/*
+ - getanarg - get a malloced argument from the file
+ */
+static const char *		/* NULL for success, else string literal */
+getanarg(f, w, linep)
+FILE *f;
+struct work *w;
+char **linep;			/* where to store pointer if successful */
+{
+	size_t len;
+	char *p;
+	char *endp;
+
+	while (w->pending == NULL) {	/* no pending line */
+		if ((w->line = getline(f, w->buf, sizeof(w->buf))) == NULL)
+			return "error in line read";	/* caller checks EOF */
+		if (w->line[0] != '#' &&
+				*(w->line + strspn(w->line, " \t")) != '\0')
+			w->pending = w->line;
+	}
+
+	if (w->pending == w->line && w->line[0] != '-') {
+		/* fresh plain line */
+		w->pending = NULL;
+		p = w->line;
+		endp = p + strlen(p);
+		if (*p == '"' && endp > p+1 && *(endp-1) == '"') {
+			p++;
+			endp--;
+			*endp = '\0';
+		}
+		if (w->line == w->buf) {
+			*linep = malloc(endp - p + 1);
+			if (*linep == NULL)
+				return "out of memory for new line";
+			strcpy(*linep, p);
+		} else			/* getline already malloced it */
+			*linep = p;
+		return NULL;
+	}
+
+	/* chip off a piece of a pending line */
+	p = w->pending;
+	p += strspn(p, " \t");
+	endp = p + strcspn(p, " \t");
+	len = endp - p;
+	if (*endp != '\0') {
+		*endp++ = '\0';
+		endp += strspn(endp, " \t");
+	}
+	/* endp now points to next real character, or to line-end NUL */
+	*linep = malloc(len + 1);
+	if (*linep == NULL) {
+		if (w->line != w->buf)
+			free(w->line);
+		return "out of memory for new argument";
+	}
+	strcpy(*linep, p);
+	if (*endp == '\0') {
+		w->pending = NULL;
+		if (w->line != w->buf)
+			free(w->line);
+	} else
+		w->pending = endp;
+	return NULL;
+}
+
+/*
+ - getline - read a line from the file, trim newline off
+ */
+static char *			/* pointer to line, NULL for eof/error */
+getline(f, buf, bufsize)
+FILE *f;
+char *buf;			/* buffer to use, if convenient */
+size_t bufsize;			/* size of buf */
+{
+	size_t len;
+
+	if (fgets(buf, bufsize, f) == NULL)
+		return NULL;
+	len = strlen(buf);
+
+	if (len < bufsize-1 || buf[bufsize-1] == '\n') {
+		/* it fit */
+		buf[len-1] = '\0';
+		return buf;
+	}
+
+	/* oh crud, buffer overflow */
+	/* for now, to hell with it */
+	return NULL;
+}
+
+
+
+#ifdef TEST
+
+#include <getopt.h>
+
+char usage[] = "Usage: tester [--foo] [--bar] [--optionsfrom file] arg ...";
+struct option opts[] = {
+	"foo",		0,	NULL,	'f',
+	"bar",		0,	NULL,	'b',
+	"builtin",	0,	NULL,	'B',
+	"optionsfrom",	1,	NULL,	'+',
+	"help",		0,	NULL,	'h',
+	"version",	0,	NULL,	'v',
+	0,		0,	NULL,	0,
+};
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	int opt;
+	extern char *optarg;
+	extern int optind;
+	int errflg = 0;
+	const char *p;
+	int i;
+	FILE *errs = NULL;
+
+	while ((opt = getopt_long(argc, argv, "", opts, NULL)) != EOF)
+		switch (opt) {
+		case 'f':
+		case 'b':
+			break;
+		case 'B':
+			errs = stderr;
+			break;
+		case '+':	/* optionsfrom */
+			p = optionsfrom(optarg, &argc, &argv, optind, errs);
+			if (p != NULL) {
+				fprintf(stderr, "%s: optionsfrom error: %s\n",
+								argv[0], p);
+				exit(1);
+			}
+			break;
+		case 'h':	/* help */
+			printf("%s\n", usage);
+			exit(0);
+			break;
+		case 'v':	/* version */
+			printf("1\n");
+			exit(0);
+			break;
+		case '?':
+		default:
+			errflg = 1;
+			break;
+		}
+	if (errflg) {
+		fprintf(stderr, "%s\n", usage);
+		exit(2);
+	}
+
+	for (i = 1; i < argc; i++)
+		printf("%d: `%s'\n", i, argv[i]);
+	exit(0);
+}
+
+
+#endif /* TEST */
diff -druN linux-noipsec/net/ipsec/libfreeswan/pfkey.h linux/net/ipsec/libfreeswan/pfkey.h
--- linux-noipsec/net/ipsec/libfreeswan/pfkey.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/pfkey.h	Tue Oct 10 22:10:19 2000
@@ -0,0 +1,340 @@
+/*
+ * FreeS/WAN specific PF_KEY headers
+ * Copyright (C) 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+#ifndef __NET_IPSEC_PF_KEY_H
+#define __NET_IPSEC_PF_KEY_H
+#ifdef __KERNEL__
+extern void pfkey_proto_init(struct net_proto *pro);
+extern struct proto_ops pfkey_proto_ops;
+typedef struct sock pfkey_sock;
+extern int debug_pfkey;
+
+extern /* void */ int pfkey_init(void);
+extern /* void */ int pfkey_cleanup(void);
+
+extern struct sock *pfkey_sock_list;
+struct socket_list
+{
+	struct socket *socketp;
+	struct socket_list *next;
+};
+extern int pfkey_list_insert_socket(struct socket*, struct socket_list**);
+extern int pfkey_list_remove_socket(struct socket*, struct socket_list**);
+extern struct socket_list *pfkey_open_sockets;
+extern struct socket_list *pfkey_registered_sockets[SADB_SATYPE_MAX+1];
+
+struct supported
+{
+	uint16_t supported_alg_exttype;
+	uint8_t supported_alg_id;
+	uint8_t supported_alg_ivlen;
+	uint16_t supported_alg_minbits;
+	uint16_t supported_alg_maxbits;
+};
+
+extern struct supported_list *pfkey_supported_list[SADB_SATYPE_MAX+1];
+struct supported_list
+{
+	struct supported *supportedp;
+	struct supported_list *next;
+};
+extern int pfkey_list_insert_supported(struct supported*, struct supported_list**);
+extern int pfkey_list_remove_supported(struct supported*, struct supported_list**);
+
+extern uint8_t sadb_satype2proto[];
+
+/*
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+ */
+struct sockaddr_key
+{
+	uint16_t	key_family;	/* PF_KEY */
+	uint16_t	key_pad;	/* not used */
+	uint32_t	key_pid;	/* process ID */
+};
+/*
+#endif */ /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+ */
+
+struct pfkey_extracted_data
+{
+	struct tdb* tdb;
+	struct tdb* tdb2;
+	struct eroute *eroute;
+};
+
+extern int pfkey_upmsg(struct socket *, struct sadb_msg *);
+extern int pfkey_expire(struct tdb *, int);
+extern int pfkey_acquire(struct tdb *);
+#endif /* __KERNEL__ */
+
+extern uint8_t satype2proto(uint8_t satype);
+extern uint8_t proto2satype(uint8_t proto);
+extern char* proto2name(uint8_t proto);
+
+struct key_opt
+{
+	uint32_t	key_pid;	/* process ID */
+	struct sock	*sk;
+};
+
+#define key_pid(sk) ((struct key_opt*)&((sk)->protinfo))->key_pid
+
+#define IPSEC_PFKEYv2_ALIGN (sizeof(uint64_t)/sizeof(uint8_t))
+#define BITS_PER_OCTET 8
+#define OCTETBITS 8
+#define PFKEYBITS 64
+#define DIVUP(x,y) ((x + y -1) / y) /* divide, rounding upwards */
+#define ALIGN_N(x,y) (DIVUP(x,y) * y) /* align on y boundary */
+
+#define PFKEYv2_MAX_MSGSIZE 4096
+
+/*
+ * PF_KEYv2 permitted and required extensions in and out bitmaps
+ */
+
+extern unsigned int extensions_bitmaps[2/*in/out*/][2/*perm/req*/][SADB_MAX + 1/*ext*/];
+#define EXT_BITS_IN 0
+#define EXT_BITS_OUT 1
+#define EXT_BITS_PERM 0
+#define EXT_BITS_REQ 1
+
+extern void pfkey_extensions_init(struct sadb_ext *extensions[SADB_EXT_MAX + 1]);
+extern void pfkey_extensions_free(struct sadb_ext *extensions[SADB_EXT_MAX + 1]);
+extern void pfkey_msg_free(struct sadb_msg **pfkey_msg);
+
+extern int pfkey_msg_parse(struct sadb_msg *pfkey_msg,
+			   int (*ext_parsers[])(struct sadb_ext* ),
+			   struct sadb_ext **extensions,
+			   int dir);
+
+/*
+ * PF_KEYv2 build function prototypes
+ */
+
+int
+pfkey_msg_hdr_build(struct sadb_ext**	pfkey_ext,
+		    uint8_t		msg_type,
+		    uint8_t		satype,
+		    uint8_t		msg_errno,
+		    uint32_t		seq,
+		    uint32_t		pid);
+
+int
+pfkey_sa_build(struct sadb_ext **	pfkey_ext,
+	       uint16_t			exttype,
+	       uint32_t			spi, /* in network order */
+	       uint8_t			replay_window,
+	       uint8_t			sa_state,
+	       uint8_t			auth,
+	       uint8_t			encrypt,
+	       uint32_t			flags);
+
+int
+pfkey_lifetime_build(struct sadb_ext **	pfkey_ext,
+		     uint16_t		exttype,
+		     uint32_t		allocations,
+		     uint64_t		bytes,
+		     uint64_t		addtime,
+		     uint64_t		usetime);
+
+int
+pfkey_address_build(struct sadb_ext**	pfkey_ext,
+		    uint16_t		exttype,
+		    uint8_t		proto,
+		    uint8_t		prefixlen,
+		    struct sockaddr*	address);
+
+int
+pfkey_key_build(struct sadb_ext**	pfkey_ext,
+		uint16_t		exttype,
+		uint16_t		key_bits,
+		char*			key);
+
+int
+pfkey_ident_build(struct sadb_ext**	pfkey_ext,
+		  uint16_t		exttype,
+		  uint16_t		ident_type,
+		  uint64_t		ident_id,
+		  char*			ident_string);
+
+int
+pfkey_sens_build(struct sadb_ext**	pfkey_ext,
+		 uint32_t		dpd,
+		 uint8_t		sens_level,
+		 uint8_t		sens_len,
+		 uint64_t*		sens_bitmap,
+		 uint8_t		integ_level,
+		 uint8_t		integ_len,
+		 uint64_t*		integ_bitmap);
+
+int
+pfkey_prop_build(struct sadb_ext**	pfkey_ext,
+		 uint8_t		replay,
+		 unsigned int		comb_num,
+		 struct sadb_comb*	comb);
+
+int
+pfkey_supported_build(struct sadb_ext**	pfkey_ext,
+		      uint16_t		exttype,
+		      unsigned int	alg_num,
+		      struct sadb_alg*	alg);
+
+int
+pfkey_spirange_build(struct sadb_ext**	pfkey_ext,
+		     uint16_t		exttype,
+		     uint32_t		min,
+		     uint32_t		max);
+
+int
+pfkey_x_kmprivate_build(struct sadb_ext**	pfkey_ext);
+
+int
+pfkey_x_satype_build(struct sadb_ext**	pfkey_ext,
+		     uint8_t		satype);
+
+int
+pfkey_x_debug_build(struct sadb_ext**	pfkey_ext,
+		    uint32_t            tunnel,
+		    uint32_t		netlink,
+		    uint32_t		xform,
+		    uint32_t		eroute,
+		    uint32_t		spi,
+		    uint32_t		radij,
+		    uint32_t		esp,
+		    uint32_t		ah,
+		    uint32_t		rcv,
+		    uint32_t            pfkey,
+		    uint32_t            ipcomp,
+		    uint32_t            verbose);
+
+int
+pfkey_msg_build(struct sadb_msg**	pfkey_msg,
+		struct sadb_ext*	extensions[],
+		int			dir);
+
+#endif /* __NET_IPSEC_PF_KEY_H */
+
+/*
+ * $Log$
+ * Revision 1.28  2000/10/10 20:10:19  rgb
+ * Added support for debug_ipcomp and debug_verbose to klipsdebug.
+ *
+ * Revision 1.27  2000/09/21 04:20:45  rgb
+ * Fixed array size off-by-one error.  (Thanks Svenning!)
+ *
+ * Revision 1.26  2000/09/12 03:26:05  rgb
+ * Added pfkey_acquire prototype.
+ *
+ * Revision 1.25  2000/09/08 19:21:28  rgb
+ * Fix pfkey_prop_build() parameter to be only single indirection.
+ *
+ * Revision 1.24  2000/09/01 18:46:42  rgb
+ * Added a supported algorithms array lists, one per satype and registered
+ * existing algorithms.
+ * Fixed pfkey_list_{insert,remove}_{socket,support}() to allow change to
+ * list.
+ *
+ * Revision 1.23  2000/08/27 01:55:26  rgb
+ * Define OCTETBITS and PFKEYBITS to avoid using 'magic' numbers in code.
+ *
+ * Revision 1.22  2000/08/20 21:39:23  rgb
+ * Added kernel prototypes for kernel funcitions pfkey_upmsg() and
+ * pfkey_expire().
+ *
+ * Revision 1.21  2000/08/15 17:29:23  rgb
+ * Fixes from SZI to untested pfkey_prop_build().
+ *
+ * Revision 1.20  2000/05/10 20:14:19  rgb
+ * Fleshed out sensitivity, proposal and supported extensions.
+ *
+ * Revision 1.19  2000/03/16 14:07:23  rgb
+ * Renamed ALIGN macro to avoid fighting with others in kernel.
+ *
+ * Revision 1.18  2000/01/22 23:24:06  rgb
+ * Added prototypes for proto2satype(), satype2proto() and proto2name().
+ *
+ * Revision 1.17  2000/01/21 06:26:59  rgb
+ * Converted from double tdb arguments to one structure (extr)
+ * containing pointers to all temporary information structures.
+ * Added klipsdebug switching capability.
+ * Dropped unused argument to pfkey_x_satype_build().
+ *
+ * Revision 1.16  1999/12/29 21:17:41  rgb
+ * Changed pfkey_msg_build() I/F to include a struct sadb_msg**
+ * parameter for cleaner manipulation of extensions[] and to guard
+ * against potential memory leaks.
+ * Changed the I/F to pfkey_msg_free() for the same reason.
+ *
+ * Revision 1.15  1999/12/09 23:12:54  rgb
+ * Added macro for BITS_PER_OCTET.
+ * Added argument to pfkey_sa_build() to do eroutes.
+ *
+ * Revision 1.14  1999/12/08 20:33:25  rgb
+ * Changed sa_family_t to uint16_t for 2.0.xx compatibility.
+ *
+ * Revision 1.13  1999/12/07 19:53:40  rgb
+ * Removed unused first argument from extension parsers.
+ * Changed __u* types to uint* to avoid use of asm/types.h and
+ * sys/types.h in userspace code.
+ * Added function prototypes for pfkey message and extensions
+ * initialisation and cleanup.
+ *
+ * Revision 1.12  1999/12/01 22:19:38  rgb
+ * Change pfkey_sa_build to accept an SPI in network byte order.
+ *
+ * Revision 1.11  1999/11/27 11:55:26  rgb
+ * Added extern sadb_satype2proto to enable moving protocol lookup table
+ * to lib/pfkey_v2_parse.c.
+ * Delete unused, moved typedefs.
+ * Add argument to pfkey_msg_parse() for direction.
+ * Consolidated the 4 1-d extension bitmap arrays into one 4-d array.
+ *
+ * Revision 1.10  1999/11/23 22:29:21  rgb
+ * This file has been moved in the distribution from klips/net/ipsec to
+ * lib.
+ * Add macros for dealing with alignment and rounding up more opaquely.
+ * The uint<n>_t type defines have been moved to freeswan.h to avoid
+ * chicken-and-egg problems.
+ * Add macros for dealing with alignment and rounding up more opaque.
+ * Added prototypes for using extention header bitmaps.
+ * Added prototypes of all the build functions.
+ *
+ * Revision 1.9  1999/11/20 21:59:48  rgb
+ * Moved socketlist type declarations and prototypes for shared use.
+ * Slightly modified scope of sockaddr_key declaration.
+ *
+ * Revision 1.8  1999/11/17 14:34:25  rgb
+ * Protect sa_family_t from being used in userspace with GLIBC<2.
+ *
+ * Revision 1.7  1999/10/27 19:40:35  rgb
+ * Add a maximum PFKEY packet size macro.
+ *
+ * Revision 1.6  1999/10/26 16:58:58  rgb
+ * Created a sockaddr_key and key_opt socket extension structures.
+ *
+ * Revision 1.5  1999/06/10 05:24:41  rgb
+ * Renamed variables to reduce confusion.
+ *
+ * Revision 1.4  1999/04/29 15:21:11  rgb
+ * Add pfkey support to debugging.
+ * Add return values to init and cleanup functions.
+ *
+ * Revision 1.3  1999/04/15 17:58:07  rgb
+ * Add RCSID labels.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_build.c linux/net/ipsec/libfreeswan/pfkey_v2_build.c
--- linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_build.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/pfkey_v2_build.c	Fri Nov 17 19:10:30 2000
@@ -0,0 +1,1265 @@
+/*
+ * RFC2367 PF_KEYv2 Key management API message parser
+ * Copyright (C) 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ *		Template from klips/net/ipsec/ipsec/ipsec_parser.c.
+ */
+
+char pfkey_v2_build_c_version[] = "$Id$";
+
+/*
+ * Some ugly stuff to allow consistent debugging code for use in the
+ * kernel and in user space
+*/
+
+#ifdef __KERNEL__
+
+# include <linux/kernel.h>  /* for printk */
+
+# include <linux/malloc.h> /* kmalloc() */
+# include <linux/errno.h>  /* error codes */
+# include <linux/types.h>  /* size_t */
+# include <linux/interrupt.h> /* mark_bh */
+
+# include <linux/netdevice.h>   /* struct device, and other headers */
+# include <linux/etherdevice.h> /* eth_type_trans */
+# include <linux/ip.h>          /* struct iphdr */ 
+# if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#  include <linux/ipv6.h>        /* struct ipv6hdr */
+# endif /* if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+extern int debug_pfkey;
+
+# define MALLOC(size) kmalloc(size, GFP_ATOMIC)
+# define FREE(obj) kfree(obj)
+#else /* __KERNEL__ */
+
+# include <sys/types.h>
+# include <linux/types.h>
+# include <linux/errno.h>
+# include <malloc.h>
+# include <string.h> /* memset */
+
+# include "../pluto/constants.h" 
+# include "../pluto/defs.h"  /* for PRINTF_LIKE */
+# include "../pluto/log.h"  /* for debugging and DBG_log */
+
+extern unsigned int debugging;  /* bits selecting what to report */
+unsigned int pfkey_lib_debug = 0;
+
+/* #define PLUTO */
+
+# ifdef PLUTO
+#  define DEBUGGING(args...)  { DBG_log("pfkey_lib_debug:" args);  }
+# else
+#  define DEBUGGING(args...)  if(pfkey_lib_debug) { printf("pfkey_lib_debug:" args); } else { ; }
+# endif
+# define MALLOC(size) malloc(size)
+# define FREE(obj) free(obj)
+#endif /* __KERNEL__ */
+
+#include <freeswan.h>
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#ifdef __KERNEL__
+# include "../radij.h"  /* rd_nodes */
+# include "../ipsec_encap.h"  /* sockaddr_encap */
+# include "../ipsec_netlink.h"  /* KLIPS_PRINT */
+# define DEBUGGING(args...) \
+         KLIPS_PRINT(debug_pfkey, "klips_debug:" args)
+/*         ((debug_pfkey) ? printk(KERN_INFO "klips_debug:" format , ## args) : 0) */
+#endif /* __KERNEL__ */
+
+
+#define SENDERR(_x) do { error = -(_x); goto errlab; } while (0)
+
+void
+pfkey_extensions_init(struct sadb_ext *extensions[SADB_EXT_MAX + 1])
+{
+	int i;
+	
+	for (i = 0; i != SADB_EXT_MAX + 1; i++) {
+		extensions[i] = NULL;
+	}
+}
+
+void
+pfkey_extensions_free(struct sadb_ext *extensions[SADB_EXT_MAX + 1])
+{
+	int i;
+	
+	if(!extensions) {
+		return;
+	}
+
+	if(extensions[0]) {
+		memset(extensions[0], 0, sizeof(struct sadb_msg));
+		FREE(extensions[0]);
+		extensions[0] = NULL;
+	}
+	
+	for (i = 1; i != SADB_EXT_MAX + 1; i++) {
+		if(extensions[i]) {
+			memset(extensions[i], 0, extensions[i]->sadb_ext_len * IPSEC_PFKEYv2_ALIGN);
+			FREE(extensions[i]);
+			extensions[i] = NULL;
+		}
+	}
+}
+
+void
+pfkey_msg_free(struct sadb_msg **pfkey_msg)
+{
+	if(*pfkey_msg) {
+		memset(*pfkey_msg, 0, (*pfkey_msg)->sadb_msg_len * IPSEC_PFKEYv2_ALIGN);
+		FREE(*pfkey_msg);
+		*pfkey_msg = NULL;
+	}
+}
+
+/* Default extension builders taken from the KLIPS code */
+
+int
+pfkey_msg_hdr_build(struct sadb_ext**	pfkey_ext,
+		    uint8_t		msg_type,
+		    uint8_t		satype,
+		    uint8_t		msg_errno,
+		    uint32_t		seq,
+		    uint32_t		pid)
+{
+	int error = 0;
+	struct sadb_msg *pfkey_msg = (struct sadb_msg *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_msg_hdr_build:\n");
+	DEBUGGING(
+		"pfkey_msg_hdr_build: on_entry &pfkey_ext=%p pfkey_ext=%p *pfkey_ext=%p.\n",
+		&pfkey_ext,
+		pfkey_ext,
+		*pfkey_ext);
+	/* sanity checks... */
+	if(pfkey_msg) {
+		DEBUGGING(
+			"pfkey_msg_hdr_build:why is pfkey_msg already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if(!msg_type) {
+		DEBUGGING(
+			"pfkey_msg_hdr_build: msg type not set, must be non-zero..\n");
+		SENDERR(EINVAL);
+	}
+
+	if(msg_type > SADB_MAX) {
+		DEBUGGING(
+			"pfkey_msg_hdr_build: msg type too large:%d.\n",
+			msg_type);
+		SENDERR(EINVAL);
+	}
+
+	if(satype > SADB_SATYPE_MAX) {
+		DEBUGGING(
+			"pfkey_msg_hdr_build: satype %d > max %d\n", 
+			satype, SADB_SATYPE_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_msg = (struct sadb_msg*)
+	     MALLOC(sizeof(struct sadb_msg)))) {
+		DEBUGGING(
+			"pfkey_msg_hdr_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_msg, 0, sizeof(struct sadb_msg));
+
+	pfkey_msg->sadb_msg_len = sizeof(struct sadb_msg) / IPSEC_PFKEYv2_ALIGN;
+
+	pfkey_msg->sadb_msg_type = msg_type;
+	pfkey_msg->sadb_msg_satype = satype;
+
+	pfkey_msg->sadb_msg_version = PF_KEY_V2;
+	pfkey_msg->sadb_msg_errno = msg_errno;
+	pfkey_msg->sadb_msg_reserved = 0;
+	pfkey_msg->sadb_msg_seq = seq;
+	pfkey_msg->sadb_msg_pid = pid;
+	DEBUGGING(
+		"pfkey_msg_hdr_build: on_exit &pfkey_ext=%p pfkey_ext=%p *pfkey_ext=%p.\n",
+		&pfkey_ext,
+		pfkey_ext,
+		*pfkey_ext);
+errlab:
+	return error;
+}	
+
+int
+pfkey_sa_build(struct sadb_ext **	pfkey_ext,
+	       uint16_t			exttype,
+	       uint32_t			spi, /* in network order */
+	       uint8_t			replay_window,
+	       uint8_t			sa_state,
+	       uint8_t			auth,
+	       uint8_t			encrypt,
+	       uint32_t			flags)
+{
+	int error = 0;
+	struct sadb_sa *pfkey_sa = (struct sadb_sa *)*pfkey_ext;
+
+	DEBUGGING(
+		    "pfkey_sa_build: spi=%08x replay=%d sa_state=%d auth=%d encrypt=%d flags=%d\n",
+		    ntohl(spi), /* in network order */
+		    replay_window,
+		    sa_state,
+		    auth,
+		    encrypt,
+		    flags);
+	/* sanity checks... */
+	if(pfkey_sa) {
+		DEBUGGING(
+			"pfkey_sa_build:why is pfkey_sa already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if(exttype != SADB_EXT_SA &&
+	   exttype != SADB_X_EXT_SA2) {
+		DEBUGGING(
+			"pfkey_sa_build: invalid exttype=%d.\n",
+			exttype);
+		SENDERR(EINVAL);
+	}
+
+	if(replay_window > 64) {
+		DEBUGGING(
+			"pfkey_sa_build: replay window size: %d"
+			" -- must be 0 <= size <= 64\n",
+			replay_window);
+		SENDERR(EINVAL);
+	}
+
+	if(auth > SADB_AALG_MAX) {
+		DEBUGGING(
+			"pfkey_sa_build: auth=%d > SADB_AALG_MAX=%d.\n",
+			auth,
+			SADB_AALG_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(encrypt > SADB_EALG_MAX) {
+		DEBUGGING(
+			"pfkey_sa_build: encrypt=%d > SADB_EALG_MAX=%d.\n",
+			encrypt,
+			SADB_EALG_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(sa_state > SADB_SASTATE_MAX) {
+		DEBUGGING(
+			"pfkey_sa_build: sa_state=%d exceeds MAX=%d.\n",
+			sa_state,
+			SADB_SASTATE_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(sa_state == SADB_SASTATE_DEAD) {
+		DEBUGGING(
+			"pfkey_sa_build: sa_state=%d is DEAD=%d is not allowed.\n",
+			sa_state,
+			SADB_SASTATE_DEAD);
+		SENDERR(EINVAL);
+	}
+	
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_sa = (struct sadb_sa*)
+	     MALLOC(sizeof(struct sadb_sa)))) {
+		DEBUGGING(
+			"pfkey_sa_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_sa, 0, sizeof(struct sadb_sa));
+	
+	pfkey_sa->sadb_sa_len = sizeof(*pfkey_sa) / IPSEC_PFKEYv2_ALIGN;
+	pfkey_sa->sadb_sa_exttype = exttype;
+	pfkey_sa->sadb_sa_spi = spi;
+	pfkey_sa->sadb_sa_replay = replay_window;
+	pfkey_sa->sadb_sa_state = sa_state;
+	pfkey_sa->sadb_sa_auth = auth;
+	pfkey_sa->sadb_sa_encrypt = encrypt;
+	pfkey_sa->sadb_sa_flags = flags;
+
+errlab:
+	return error;
+}	
+
+int
+pfkey_lifetime_build(struct sadb_ext **	pfkey_ext,
+		     uint16_t		exttype,
+		     uint32_t		allocations,
+		     uint64_t		bytes,
+		     uint64_t		addtime,
+		     uint64_t		usetime)
+{
+	int error = 0;
+	struct sadb_lifetime *pfkey_lifetime = (struct sadb_lifetime *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_lifetime_build:\n");
+	/* sanity checks... */
+	if(pfkey_lifetime) {
+		DEBUGGING(
+			"pfkey_lifetime_build:why is pfkey_lifetime already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if(exttype != SADB_EXT_LIFETIME_CURRENT &&
+	   exttype != SADB_EXT_LIFETIME_HARD &&
+	   exttype != SADB_EXT_LIFETIME_SOFT) {
+		DEBUGGING(
+			"pfkey_lifetime_build: invalid exttype=%d.\n",
+			exttype);
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_lifetime = (struct sadb_lifetime*)
+	     MALLOC(sizeof(struct sadb_lifetime)))) {
+		DEBUGGING(
+			"pfkey_lifetime_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_lifetime, 0, sizeof(struct sadb_lifetime));
+
+	pfkey_lifetime->sadb_lifetime_len = sizeof(struct sadb_lifetime) / IPSEC_PFKEYv2_ALIGN;
+	pfkey_lifetime->sadb_lifetime_exttype = exttype;
+	pfkey_lifetime->sadb_lifetime_allocations = allocations;
+	pfkey_lifetime->sadb_lifetime_bytes = bytes;
+	pfkey_lifetime->sadb_lifetime_addtime = addtime;
+	pfkey_lifetime->sadb_lifetime_usetime = usetime;
+
+errlab:
+	return error;
+}
+
+int
+pfkey_address_build(struct sadb_ext**	pfkey_ext,
+		    uint16_t		exttype,
+		    uint8_t		proto,
+		    uint8_t		prefixlen,
+		    struct sockaddr*	address)
+{
+	int error = 0;
+	int saddr_len = 0;
+	char ipaddr_txt[ADDRTOT_BUF];
+	struct sadb_address *pfkey_address = (struct sadb_address *)*pfkey_ext;
+	
+	DEBUGGING(
+		"pfkey_address_build: exttype=%d proto=%d prefixlen=%d\n", exttype, proto, prefixlen);
+	/* sanity checks... */
+	if(pfkey_address) {
+		DEBUGGING(
+			"pfkey_address_build:why is pfkey_address already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if (!address)  {
+			DEBUGGING("pfkey_address_build: address is NULL\n");
+			SENDERR(EINVAL);
+	}
+	
+	switch(exttype) {	
+	case SADB_EXT_ADDRESS_SRC:
+	case SADB_EXT_ADDRESS_DST:
+	case SADB_EXT_ADDRESS_PROXY:
+	case SADB_X_EXT_ADDRESS_DST2:
+	case SADB_X_EXT_ADDRESS_SRC_FLOW:
+	case SADB_X_EXT_ADDRESS_DST_FLOW:
+	case SADB_X_EXT_ADDRESS_SRC_MASK:
+	case SADB_X_EXT_ADDRESS_DST_MASK:
+		break;
+	default:
+		DEBUGGING( 
+			"pfkey_address_build: unrecognised ext_type=%d.\n", 
+			exttype); 
+		SENDERR(EINVAL); 
+	}
+
+	switch(address->sa_family) {
+	case AF_INET:
+		DEBUGGING(
+			"pfkey_address_build: found address family AF_INET.\n");
+		saddr_len = sizeof(struct sockaddr_in);
+		sprintf(ipaddr_txt, "%d.%d.%d.%d"
+			, (((struct sockaddr_in*)address)->sin_addr.s_addr >>  0) & 0xFF
+			, (((struct sockaddr_in*)address)->sin_addr.s_addr >>  8) & 0xFF
+			, (((struct sockaddr_in*)address)->sin_addr.s_addr >> 16) & 0xFF
+			, (((struct sockaddr_in*)address)->sin_addr.s_addr >> 24) & 0xFF);
+		break;
+	case AF_INET6:
+		DEBUGGING(
+			"pfkey_address_build: found address family AF_INET6.\n");
+		saddr_len = sizeof(struct sockaddr_in6);
+		sprintf(ipaddr_txt, "%x:%x:%x:%x:%x:%x:%x:%x"
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[0])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[1])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[2])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[3])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[4])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[5])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[6])
+			, ntohs(((struct sockaddr_in6*)address)->sin6_addr.s6_addr16[7]));
+		break;
+	default:
+		DEBUGGING(
+			"pfkey_address_build: address->sa_family=%d not supported.\n",
+			address->sa_family);
+		SENDERR(EPFNOSUPPORT);
+	}
+
+	DEBUGGING(
+		"pfkey_address_build: found address=%s.\n",
+		ipaddr_txt);
+	if(prefixlen != 0) {
+		DEBUGGING(
+			"pfkey_address_build: address prefixes not supported yet.\n");
+		SENDERR(EAFNOSUPPORT); /* not supported yet */
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_address = (struct sadb_address*)
+	     MALLOC(ALIGN_N(sizeof(struct sadb_address) + saddr_len, IPSEC_PFKEYv2_ALIGN) ))) {
+		DEBUGGING(
+			"pfkey_lifetime_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_address,
+	       0,
+	       ALIGN_N(sizeof(struct sadb_address) + saddr_len,
+		     IPSEC_PFKEYv2_ALIGN));
+	       
+	pfkey_address->sadb_address_len = DIVUP(sizeof(struct sadb_address) + saddr_len,
+						IPSEC_PFKEYv2_ALIGN);
+	
+	pfkey_address->sadb_address_exttype = exttype;
+	pfkey_address->sadb_address_proto = proto;
+	pfkey_address->sadb_address_prefixlen = prefixlen;
+	pfkey_address->sadb_address_reserved = 0;
+
+	memcpy((char*)pfkey_address + sizeof(struct sadb_address),
+	       address,
+	       saddr_len);
+
+#if 0
+	for(i = 0; i < sizeof(struct sockaddr_in) - offsetof(struct sockaddr_in, sin_zero); i++) {
+		pfkey_address_s_ska.sin_zero[i] = 0;
+	}
+#endif
+	DEBUGGING(
+		"pfkey_address_build: successful.\n");
+
+ errlab:
+	return error;
+}
+
+int
+pfkey_key_build(struct sadb_ext**	pfkey_ext,
+		uint16_t		exttype,
+		uint16_t		key_bits,
+		char*			key)
+{
+	int error = 0;
+	struct sadb_key *pfkey_key = (struct sadb_key *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_key_build:\n");
+	/* sanity checks... */
+	if(pfkey_key) {
+		DEBUGGING(
+			"pfkey_key_build:why is pfkey_key already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if(!key_bits) {
+		DEBUGGING(
+			"pfkey_key_build: key_bits is zero, it must be non-zero.\n");
+		SENDERR(EINVAL);
+	}
+
+	if( !((exttype == SADB_EXT_KEY_AUTH) || (exttype == SADB_EXT_KEY_ENCRYPT))) {
+		DEBUGGING(
+			"pfkey_key_build: unsupported extension type=%d.\n",
+			exttype);
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_key = (struct sadb_key*)
+	     MALLOC(sizeof(struct sadb_key) +
+				    DIVUP(key_bits, 64) * IPSEC_PFKEYv2_ALIGN))) {
+		DEBUGGING(
+			"pfkey_key_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_key,
+	       0,
+	       sizeof(struct sadb_key) +
+	       DIVUP(key_bits, 64) * IPSEC_PFKEYv2_ALIGN);
+	
+	pfkey_key->sadb_key_len = DIVUP(sizeof(struct sadb_key) * IPSEC_PFKEYv2_ALIGN +	key_bits,
+					64);
+	pfkey_key->sadb_key_exttype = exttype;
+	pfkey_key->sadb_key_bits = key_bits;
+	pfkey_key->sadb_key_reserved = 0;
+	memcpy((char*)pfkey_key + sizeof(struct sadb_key),
+	       key,
+	       DIVUP(key_bits, 8));
+
+errlab:
+	return error;
+}
+
+int
+pfkey_ident_build(struct sadb_ext**	pfkey_ext,
+		  uint16_t		exttype,
+		  uint16_t		ident_type,
+		  uint64_t		ident_id,
+		  char*			ident_string)
+{
+	int error = 0;
+	struct sadb_ident *pfkey_ident = (struct sadb_ident *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_ident_build:\n");
+	/* sanity checks... */
+	if(pfkey_ident) {
+		DEBUGGING(
+			"pfkey_ident_build:why is pfkey_ident already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if( ! ((exttype == SADB_EXT_IDENTITY_SRC) ||
+	       (exttype == SADB_EXT_IDENTITY_DST))) {
+		DEBUGGING(
+			"pfkey_ident_build: unsupported extension type=%d.\n",
+			exttype);
+		SENDERR(EINVAL);
+	}
+
+	if((ident_type == SADB_IDENTTYPE_RESERVED)) {
+		DEBUGGING(
+			"pfkey_ident_build: ident_type must be non-zero.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(ident_type > SADB_IDENTTYPE_MAX) {
+		DEBUGGING(
+			"pfkey_ident_build: identtype=%d out of range.\n",
+			ident_type);
+		SENDERR(EINVAL);
+	}
+
+	if(((ident_type == SADB_IDENTTYPE_PREFIX) ||
+	    (ident_type == SADB_IDENTTYPE_FQDN)) &&
+	   !ident_string) {
+		DEBUGGING(
+			"pfkey_ident_build: string required to allocate size of extension.\n");
+		SENDERR(EINVAL);
+	}
+	
+#if 0
+	if((ident_type == SADB_IDENTTYPE_USERFQDN) ) {
+	}
+#endif
+	    
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_ident = (struct sadb_ident*)
+	     MALLOC(ALIGN_N(sizeof(struct sadb_key) + strlen(ident_string), IPSEC_PFKEYv2_ALIGN)))) {
+		DEBUGGING(
+			"pfkey_ident_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_ident,
+	       0,
+	       ALIGN_N(sizeof(struct sadb_ident) + strlen(ident_string),
+		     IPSEC_PFKEYv2_ALIGN));
+	
+	pfkey_ident->sadb_ident_len = DIVUP(sizeof(struct sadb_ident) + strlen(ident_string),
+					    IPSEC_PFKEYv2_ALIGN);
+	
+	pfkey_ident->sadb_ident_exttype = exttype;
+	pfkey_ident->sadb_ident_type = ident_type;
+	pfkey_ident->sadb_ident_reserved = 0;
+	pfkey_ident->sadb_ident_id = ident_id;
+	memcpy((char*)pfkey_ident + sizeof(struct sadb_ident),
+	       ident_string,
+	       strlen(ident_string));
+
+	/* string terminator/padding must be zero */
+	/* Which one is better, I don't know... */
+#if 0
+	for(i = strlen(ident_string);
+	    i < ALIGN_N(sizeof(struct sadb_ident) + strlen(ident_string), IPSEC_PFKEYv2_ALIGN);
+	    i++) {
+		((char*)pfkey_ident)[i] = 0;
+	}
+#else
+	memset(((char*)pfkey_ident) + sizeof(struct sadb_ident) + strlen(ident_string),
+	       0,
+	       ALIGN_N(sizeof(struct sadb_ident) + strlen(ident_string), IPSEC_PFKEYv2_ALIGN) -
+	       sizeof(struct sadb_ident) + strlen(ident_string));
+#endif
+
+errlab:
+	return error;
+}
+
+int
+pfkey_sens_build(struct sadb_ext**	pfkey_ext,
+		 uint32_t		dpd,
+		 uint8_t		sens_level,
+		 uint8_t		sens_len,
+		 uint64_t*		sens_bitmap,
+		 uint8_t		integ_level,
+		 uint8_t		integ_len,
+		 uint64_t*		integ_bitmap)
+{
+	int error = 0;
+	struct sadb_sens *pfkey_sens = (struct sadb_sens *)*pfkey_ext;
+	int i;
+	uint64_t* bitmap;
+
+	DEBUGGING(
+		"pfkey_sens_build:\n");
+	/* sanity checks... */
+	if(pfkey_sens) {
+		DEBUGGING(
+			"pfkey_sens_build:why is pfkey_sens already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	DEBUGGING(
+		"pfkey_sens_build: Sorry, I can't build exttype=%d yet.\n",
+		(*pfkey_ext)->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_sens = (struct sadb_sens*)
+	     MALLOC(sizeof(struct sadb_sens) +
+		    (sens_len + integ_len) * sizeof(uint64_t)))) {
+		DEBUGGING(
+			"pfkey_sens_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_sens,
+	       0,
+	       sizeof(struct sadb_sens) +
+	       (sens_len + integ_len) * sizeof(uint64_t));
+	
+	pfkey_sens->sadb_sens_len = (sizeof(struct sadb_sens) +
+		    (sens_len + integ_len) * sizeof(uint64_t)) / IPSEC_PFKEYv2_ALIGN;
+	pfkey_sens->sadb_sens_exttype = SADB_EXT_SENSITIVITY;
+	pfkey_sens->sadb_sens_dpd = dpd;
+	pfkey_sens->sadb_sens_sens_level = sens_level;
+	pfkey_sens->sadb_sens_sens_len = sens_len;
+	pfkey_sens->sadb_sens_integ_level = integ_level;
+	pfkey_sens->sadb_sens_integ_len = integ_len;
+	pfkey_sens->sadb_sens_reserved = 0;
+
+	bitmap = (uint64_t*)((char*)pfkey_ext + sizeof(struct sadb_sens));
+	for(i = 0; i < sens_len; i++) {
+		*bitmap = sens_bitmap[i];
+		bitmap++;
+	}
+	for(i = 0; i < integ_len; i++) {
+		*bitmap = integ_bitmap[i];
+		bitmap++;
+	}
+
+errlab:
+	return error;
+}
+
+int
+pfkey_prop_build(struct sadb_ext**	pfkey_ext,
+		 uint8_t		replay,
+		 unsigned int		comb_num,
+		 struct sadb_comb*	comb)
+{
+	int error = 0;
+	int i;
+	struct sadb_prop *pfkey_prop = (struct sadb_prop *)*pfkey_ext;
+	struct sadb_comb *combp;
+
+	DEBUGGING(
+		"pfkey_prop_build:\n");
+	/* sanity checks... */
+	if(pfkey_prop) {
+		DEBUGGING(
+			"pfkey_prop_build:why is pfkey_prop already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_prop = (struct sadb_prop*)
+	     MALLOC(sizeof(struct sadb_prop) +
+		    comb_num * sizeof(struct sadb_comb)))) {
+		DEBUGGING(
+			"pfkey_prop_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_prop,
+	       0,
+	       sizeof(struct sadb_prop) +
+		    comb_num * sizeof(struct sadb_comb));
+	
+	pfkey_prop->sadb_prop_len = (sizeof(struct sadb_prop) +
+		    comb_num * sizeof(struct sadb_comb)) / IPSEC_PFKEYv2_ALIGN;
+
+	pfkey_prop->sadb_prop_exttype = SADB_EXT_PROPOSAL;
+	pfkey_prop->sadb_prop_replay = replay;
+
+	for(i=0; i<3; i++) {
+		pfkey_prop->sadb_prop_reserved[i] = 0;
+	}
+
+	combp = (struct sadb_comb*)((char*)*pfkey_ext + sizeof(struct sadb_prop));
+	for(i = 0; i < comb_num; i++) {
+		memcpy (combp, &(comb[i]), sizeof(struct sadb_comb));
+		combp++;
+	}
+
+#if 0
+  uint8_t sadb_comb_auth;
+  uint8_t sadb_comb_encrypt;
+  uint16_t sadb_comb_flags;
+  uint16_t sadb_comb_auth_minbits;
+  uint16_t sadb_comb_auth_maxbits;
+  uint16_t sadb_comb_encrypt_minbits;
+  uint16_t sadb_comb_encrypt_maxbits;
+  uint32_t sadb_comb_reserved;
+  uint32_t sadb_comb_soft_allocations;
+  uint32_t sadb_comb_hard_allocations;
+  uint64_t sadb_comb_soft_bytes;
+  uint64_t sadb_comb_hard_bytes;
+  uint64_t sadb_comb_soft_addtime;
+  uint64_t sadb_comb_hard_addtime;
+  uint64_t sadb_comb_soft_usetime;
+  uint64_t sadb_comb_hard_usetime;
+#endif
+errlab:
+	return error;
+}
+
+int
+pfkey_supported_build(struct sadb_ext**	pfkey_ext,
+		      uint16_t		exttype,
+		      unsigned int	alg_num,
+		      struct sadb_alg*	alg)
+{
+	int error = 0;
+	unsigned int i;
+	struct sadb_supported *pfkey_supported = (struct sadb_supported *)*pfkey_ext;
+	struct sadb_alg *pfkey_alg;
+
+	/* sanity checks... */
+	if(pfkey_supported) {
+		DEBUGGING(
+			"pfkey_supported_build:why is pfkey_supported already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+
+	if( !((exttype == SADB_EXT_SUPPORTED_AUTH) || (exttype == SADB_EXT_SUPPORTED_ENCRYPT))) {
+		DEBUGGING(
+			"pfkey_supported_build: unsupported extension type=%d.\n",
+			exttype);
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_supported = (struct sadb_supported*)
+	     MALLOC(sizeof(struct sadb_supported) +
+					       alg_num *
+					       sizeof(struct sadb_alg)))) {
+		DEBUGGING(
+			"pfkey_supported_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_supported,
+	       0,
+	       sizeof(struct sadb_supported) +
+					       alg_num *
+					       sizeof(struct sadb_alg));
+	
+	pfkey_supported->sadb_supported_len = (sizeof(struct sadb_supported) +
+					       alg_num *
+					       sizeof(struct sadb_alg)) /
+						IPSEC_PFKEYv2_ALIGN;
+	pfkey_supported->sadb_supported_exttype = exttype;
+	pfkey_supported->sadb_supported_reserved = 0;
+
+	pfkey_alg = (struct sadb_alg*)((char*)pfkey_supported + sizeof(struct sadb_supported));
+	for(i = 0; i < alg_num; i++) {
+		memcpy (pfkey_alg, &(alg[i]), sizeof(struct sadb_alg));
+		pfkey_alg->sadb_alg_reserved = 0;
+		pfkey_alg++;
+	}
+	
+#if 0
+	DEBUGGING(
+		"pfkey_supported_build: Sorry, I can't build exttype=%d yet.\n",
+		(*pfkey_ext)->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+  uint8_t sadb_alg_id;
+  uint8_t sadb_alg_ivlen;
+  uint16_t sadb_alg_minbits;
+  uint16_t sadb_alg_maxbits;
+  uint16_t sadb_alg_reserved;
+#endif
+errlab:
+	return error;
+}
+
+int
+pfkey_spirange_build(struct sadb_ext**	pfkey_ext,
+		     uint16_t		exttype,
+		     uint32_t		min, /* in network order */
+		     uint32_t		max) /* in network order */
+{
+	int error = 0;
+	struct sadb_spirange *pfkey_spirange = (struct sadb_spirange *)*pfkey_ext;
+	
+	/* sanity checks... */
+	if(pfkey_spirange) {
+		DEBUGGING(
+			"pfkey_spirange_build:why is pfkey_spirange already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+	
+        if(ntohl(max) < ntohl(min)) {
+		DEBUGGING(
+			"pfkey_spirange_build: minspi=%08x must be < maxspi=%08x.\n",
+			ntohl(min),
+			ntohl(max));
+                SENDERR(EINVAL);
+        }
+	
+	if(ntohl(min) <= 255) {
+		DEBUGGING(
+			"pfkey_spirange_build: minspi=%08x must be > 255.\n",
+			ntohl(min));
+		SENDERR(EEXIST);
+	}
+	
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_spirange = (struct sadb_spirange*)
+	     MALLOC(sizeof(struct sadb_spirange)))) {
+		DEBUGGING(
+			"pfkey_spirange_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_spirange,
+	       0,
+	       sizeof(struct sadb_spirange));
+	
+        pfkey_spirange->sadb_spirange_len = sizeof(struct sadb_spirange) / IPSEC_PFKEYv2_ALIGN;
+
+	pfkey_spirange->sadb_spirange_exttype = SADB_EXT_SPIRANGE;
+	pfkey_spirange->sadb_spirange_min = min;
+	pfkey_spirange->sadb_spirange_max = max;
+	pfkey_spirange->sadb_spirange_reserved = 0;
+ errlab:
+	return error;
+}
+
+int
+pfkey_x_kmprivate_build(struct sadb_ext**	pfkey_ext)
+{
+	int error = 0;
+	struct sadb_x_kmprivate *pfkey_x_kmprivate = (struct sadb_x_kmprivate *)*pfkey_ext;
+
+	/* sanity checks... */
+	if(pfkey_x_kmprivate) {
+		DEBUGGING(
+			"pfkey_x_kmprivate_build:why is pfkey_x_kmprivate already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+	
+	pfkey_x_kmprivate->sadb_x_kmprivate_reserved = 0;
+
+	DEBUGGING(
+		"pfkey_x_kmprivate_build: Sorry, I can't build exttype=%d yet.\n",
+		(*pfkey_ext)->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+	if(!(*pfkey_ext = (struct sadb_ext*)
+	     pfkey_x_kmprivate = (struct sadb_x_kmprivate*)
+	     MALLOC(sizeof(struct sadb_x_kmprivate)))) {
+		DEBUGGING(
+			"pfkey_x_kmprivate_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_x_kmprivate,
+	       0,
+	       sizeof(struct sadb_x_kmprivate));
+	
+        pfkey_x_kmprivate->sadb_x_kmprivate_len =
+		sizeof(struct sadb_x_kmprivate) / IPSEC_PFKEYv2_ALIGN;
+
+        pfkey_x_kmprivate->sadb_x_kmprivate_exttype = SADB_X_EXT_KMPRIVATE;
+        pfkey_x_kmprivate->sadb_x_kmprivate_reserved = 0;
+errlab:
+	return error;
+}
+
+int
+pfkey_x_satype_build(struct sadb_ext**	pfkey_ext,
+		     uint8_t		satype)
+{
+	int error = 0;
+	int i;
+	struct sadb_x_satype *pfkey_x_satype = (struct sadb_x_satype *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_x_satype_build:\n");
+	/* sanity checks... */
+	if(pfkey_x_satype) {
+		DEBUGGING(
+			"pfkey_x_satype_build:why is pfkey_x_satype already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+	
+	if(!satype) {
+		DEBUGGING(
+			"pfkey_x_satype_build: SA type not set, must be non-zero.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(satype > SADB_SATYPE_MAX) {
+		DEBUGGING(
+			"pfkey_x_satype_build: satype %d > max %d\n", 
+			satype, SADB_SATYPE_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(!(*pfkey_ext = (struct sadb_ext*)pfkey_x_satype = (struct sadb_x_satype*)
+	     MALLOC(sizeof(struct sadb_x_satype)))) {
+		DEBUGGING(
+			"pfkey_x_satype_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+	memset(pfkey_x_satype,
+	       0,
+	       sizeof(struct sadb_x_satype));
+	
+        pfkey_x_satype->sadb_x_satype_len = sizeof(struct sadb_x_satype) / IPSEC_PFKEYv2_ALIGN;
+
+	pfkey_x_satype->sadb_x_satype_exttype = SADB_X_EXT_SATYPE2;
+	pfkey_x_satype->sadb_x_satype_satype = satype;
+	for(i=0; i<3; i++) {
+		pfkey_x_satype->sadb_x_satype_reserved[i] = 0;
+	}
+
+errlab:
+	return error;
+}
+
+int
+pfkey_x_debug_build(struct sadb_ext**	pfkey_ext,
+		    uint32_t            tunnel,
+		    uint32_t		netlink,
+		    uint32_t		xform,
+		    uint32_t		eroute,
+		    uint32_t		spi,
+		    uint32_t		radij,
+		    uint32_t		esp,
+		    uint32_t		ah,
+		    uint32_t		rcv,
+		    uint32_t            pfkey,
+		    uint32_t            ipcomp,
+		    uint32_t            verbose)
+{
+	int error = 0;
+	int i;
+	struct sadb_x_debug *pfkey_x_debug = (struct sadb_x_debug *)*pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_x_debug_build:\n");
+	/* sanity checks... */
+	if(pfkey_x_debug) {
+		DEBUGGING(
+			"pfkey_x_debug_build:why is pfkey_x_debug already pointing to something?\n");
+		SENDERR(EINVAL);
+	}
+	
+	DEBUGGING(
+		"pfkey_x_debug_build:tunnel=%x netlink=%x xform=%x eroute=%x spi=%x radij=%x esp=%x ah=%x rcv=%x pfkey=%x ipcomp=%x verbose=%x?\n",
+		tunnel, netlink, xform, eroute, spi, radij, esp, ah, rcv, pfkey, ipcomp, verbose);
+
+	if(!(*pfkey_ext = (struct sadb_ext*)pfkey_x_debug = (struct sadb_x_debug*)
+	     MALLOC(sizeof(struct sadb_x_debug)))) {
+		DEBUGGING(
+			"pfkey_x_debug_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+#if 0
+	memset(pfkey_x_debug,
+	       0,
+	       sizeof(struct sadb_x_debug));
+#endif
+	
+        pfkey_x_debug->sadb_x_debug_len = sizeof(struct sadb_x_debug) / IPSEC_PFKEYv2_ALIGN;
+	pfkey_x_debug->sadb_x_debug_exttype = SADB_X_EXT_DEBUG;
+
+	pfkey_x_debug->sadb_x_debug_tunnel = tunnel;
+	pfkey_x_debug->sadb_x_debug_netlink = netlink;
+	pfkey_x_debug->sadb_x_debug_xform = xform;
+	pfkey_x_debug->sadb_x_debug_eroute = eroute;
+	pfkey_x_debug->sadb_x_debug_spi = spi;
+	pfkey_x_debug->sadb_x_debug_radij = radij;
+	pfkey_x_debug->sadb_x_debug_esp = esp;
+	pfkey_x_debug->sadb_x_debug_ah = ah;
+	pfkey_x_debug->sadb_x_debug_rcv = rcv;
+	pfkey_x_debug->sadb_x_debug_pfkey = pfkey;
+	pfkey_x_debug->sadb_x_debug_ipcomp = ipcomp;
+	pfkey_x_debug->sadb_x_debug_verbose = verbose;
+
+	for(i=0; i<4; i++) {
+		pfkey_x_debug->sadb_x_debug_reserved[i] = 0;
+	}
+
+errlab:
+	return error;
+}
+
+#if I_DONT_THINK_THIS_WILL_BE_USEFUL
+int (*ext_default_builders[SADB_EXT_MAX +1])(struct sadb_msg*, struct sadb_ext*)
+ =
+{
+	NULL, /* pfkey_msg_build, */
+	pfkey_sa_build,
+	pfkey_lifetime_build,
+	pfkey_lifetime_build,
+	pfkey_lifetime_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_key_build,
+	pfkey_key_build,
+	pfkey_ident_build,
+	pfkey_ident_build,
+	pfkey_sens_build,
+	pfkey_prop_build,
+	pfkey_supported_build,
+	pfkey_supported_build,
+	pfkey_spirange_build,
+	pfkey_x_kmprivate_build,
+	pfkey_x_satype_build,
+	pfkey_sa_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_address_build,
+	pfkey_x_ext_debug_build
+};
+#endif
+
+int
+pfkey_msg_build(struct sadb_msg **pfkey_msg, struct sadb_ext *extensions[], int dir)
+{
+	int error = 0;
+	int ext;
+	int total_size;
+	struct sadb_ext *pfkey_ext;
+	int extensions_seen = 0;
+	struct sadb_ext *extensions_check[SADB_EXT_MAX + 1];
+	
+	if(!extensions[0]) {
+		DEBUGGING(
+			"pfkey_msg_build: extensions[0] must be specified (struct sadb_msg).\n");
+		SENDERR(EINVAL);
+	}
+
+	total_size = sizeof(struct sadb_msg) / IPSEC_PFKEYv2_ALIGN;
+	for(ext = 1; ext <= SADB_EXT_MAX; ext++) {
+		if(extensions[ext]) {
+			total_size += (extensions[ext])->sadb_ext_len;
+		}
+        }                
+
+	if(!(*pfkey_msg = (struct sadb_msg*)MALLOC(total_size * IPSEC_PFKEYv2_ALIGN))) {
+		DEBUGGING(
+			"pfkey_msg_build: memory allocation failed\n");
+		SENDERR(ENOMEM);
+	}
+
+	DEBUGGING(
+		"pfkey_msg_build: pfkey_msg=%p allocated %d bytes, &(extensions[0])=%p\n",
+		*pfkey_msg,
+		total_size * IPSEC_PFKEYv2_ALIGN,
+		&(extensions[0]));
+	memcpy(*pfkey_msg,
+	       extensions[0],
+	       sizeof(struct sadb_msg));
+	(*pfkey_msg)->sadb_msg_len = total_size;
+	(*pfkey_msg)->sadb_msg_reserved = 0;
+	extensions_seen =  1 ;
+
+	pfkey_ext = (struct sadb_ext*)(((char*)(*pfkey_msg)) + sizeof(struct sadb_msg));
+
+	for(ext = 1; ext <= SADB_EXT_MAX; ext++) {
+		/* copy from extension[ext] to buffer */
+		if(extensions[ext]) {    
+			/* Is this type of extension permitted for this type of message? */
+			if(!(extensions_bitmaps[dir][EXT_BITS_PERM][(*pfkey_msg)->sadb_msg_type] &
+			     1<<ext)) {
+				DEBUGGING(
+					"pfkey_msg_build: "
+					"ext type %d not permitted, exts_perm=%08x, 1<<type=%08x\n", 
+					ext, 
+					extensions_bitmaps[dir][EXT_BITS_PERM][(*pfkey_msg)->sadb_msg_type],
+					1<<ext);
+				SENDERR(EINVAL);
+			}
+			DEBUGGING(
+				"pfkey_msg_build: copying %d bytes from extensions[%d]=%p to=%p\n",
+				(extensions[ext])->sadb_ext_len * IPSEC_PFKEYv2_ALIGN,
+				ext,
+				(extensions[ext]),
+				pfkey_ext);
+			memcpy(pfkey_ext,
+			       extensions[ext],
+			       (extensions[ext])->sadb_ext_len * IPSEC_PFKEYv2_ALIGN);
+			((char*)pfkey_ext) += (extensions[ext])->sadb_ext_len * IPSEC_PFKEYv2_ALIGN;
+			/* Mark that we have seen this extension and remember the header location */
+			extensions_seen |= ( 1 << ext );
+		}
+	}
+
+	/* check required extensions */
+	DEBUGGING(
+		"pfkey_msg_build: extensions "
+		"permitted=%08x, seen=%08x, required=%08x.\n",
+		extensions_bitmaps[dir][EXT_BITS_PERM][(*pfkey_msg)->sadb_msg_type],
+		extensions_seen,
+		extensions_bitmaps[dir][EXT_BITS_REQ][(*pfkey_msg)->sadb_msg_type]);
+	
+	if((extensions_seen &
+	    extensions_bitmaps[dir][EXT_BITS_REQ][(*pfkey_msg)->sadb_msg_type]) !=
+	   extensions_bitmaps[dir][EXT_BITS_REQ][(*pfkey_msg)->sadb_msg_type]) {
+		DEBUGGING(
+			"pfkey_msg_build: required extensions missing:%08x.\n",
+			extensions_bitmaps[dir][EXT_BITS_REQ][(*pfkey_msg)->sadb_msg_type] -
+			(extensions_seen &
+			 extensions_bitmaps[dir][EXT_BITS_REQ][(*pfkey_msg)->sadb_msg_type]) );
+		SENDERR(EINVAL);
+	}
+	
+	if((error = pfkey_msg_parse(*pfkey_msg, NULL, extensions_check, dir))) {
+		DEBUGGING(
+			"pfkey_msg_build: Trouble parsing newly built pfkey message, error=%d.\n",
+			error);
+		SENDERR(-error);
+	}
+
+errlab:
+
+	return error;
+}
+
+/*
+ * $Log$
+ * Revision 1.21  2000/11/17 18:10:30  rgb
+ * Fixed bugs mostly relating to spirange, to treat all spi variables as
+ * network byte order since this is the way PF_KEYv2 stored spis.
+ *
+ * Revision 1.20  2000/10/12 00:02:39  rgb
+ * Removed 'format, ##' nonsense from debug macros for RH7.0.
+ *
+ * Revision 1.19  2000/10/10 20:10:20  rgb
+ * Added support for debug_ipcomp and debug_verbose to klipsdebug.
+ *
+ * Revision 1.18  2000/09/12 18:59:54  rgb
+ * Added Gerhard's IPv6 support to pfkey parts of libfreeswan.
+ *
+ * Revision 1.17  2000/09/12 03:27:00  rgb
+ * Moved DEBUGGING definition to compile kernel with debug off.
+ *
+ * Revision 1.16  2000/09/08 19:22:12  rgb
+ * Fixed pfkey_prop_build() parameter to be only single indirection.
+ * Fixed struct alg copy.
+ *
+ * Revision 1.15  2000/08/20 21:40:01  rgb
+ * Added an address parameter sanity check to pfkey_address_build().
+ *
+ * Revision 1.14  2000/08/15 17:29:23  rgb
+ * Fixes from SZI to untested pfkey_prop_build().
+ *
+ * Revision 1.13  2000/06/02 22:54:14  rgb
+ * Added Gerhard Gessler's struct sockaddr_storage mods for IPv6 support.
+ *
+ * Revision 1.12  2000/05/10 19:24:01  rgb
+ * Fleshed out sensitivity, proposal and supported extensions.
+ *
+ * Revision 1.11  2000/03/16 14:07:23  rgb
+ * Renamed ALIGN macro to avoid fighting with others in kernel.
+ *
+ * Revision 1.10  2000/01/24 21:14:35  rgb
+ * Added disabled pluto pfkey lib debug flag.
+ *
+ * Revision 1.9  2000/01/21 06:27:32  rgb
+ * Added address cases for eroute flows.
+ * Removed unused code.
+ * Dropped unused argument to pfkey_x_satype_build().
+ * Indented compiler directives for readability.
+ * Added klipsdebug switching capability.
+ * Fixed SADB_EXT_MAX bug not permitting last extension access.
+ *
+ * Revision 1.8  1999/12/29 21:17:41  rgb
+ * Changed pfkey_msg_build() I/F to include a struct sadb_msg**
+ * parameter for cleaner manipulation of extensions[] and to guard
+ * against potential memory leaks.
+ * Changed the I/F to pfkey_msg_free() for the same reason.
+ *
+ * Revision 1.7  1999/12/09 23:12:20  rgb
+ * Removed unused cruft.
+ * Added argument to pfkey_sa_build() to do eroutes.
+ * Fixed exttype check in as yet unused pfkey_lifetime_build().
+ *
+ * Revision 1.6  1999/12/07 19:54:29  rgb
+ * Removed static pluto debug flag.
+ * Added functions for pfkey message and extensions initialisation
+ * and cleanup.
+ *
+ * Revision 1.5  1999/12/01 22:20:06  rgb
+ * Changed pfkey_sa_build to accept an SPI in network byte order.
+ * Added <string.h> to quiet userspace compiler.
+ * Moved pfkey_lib_debug variable into the library.
+ * Removed SATYPE check from pfkey_msg_hdr_build so FLUSH will work.
+ * Added extension assembly debugging.
+ * Isolated assignment with brackets to be sure of scope.
+ *
+ * Revision 1.4  1999/11/27 11:57:35  rgb
+ * Added ipv6 headers.
+ * Remove over-zealous algorithm sanity checkers from pfkey_sa_build.
+ * Debugging error messages added.
+ * Fixed missing auth and encrypt assignment bug.
+ * Add argument to pfkey_msg_parse() for direction.
+ * Move parse-after-build check inside pfkey_msg_build().
+ * Consolidated the 4 1-d extension bitmap arrays into one 4-d array.
+ * Add CVS log entry to bottom of file.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_ext_bits.c linux/net/ipsec/libfreeswan/pfkey_v2_ext_bits.c
--- linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_ext_bits.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/pfkey_v2_ext_bits.c	Wed Sep 13 00:35:37 2000
@@ -0,0 +1,696 @@
+/*
+ * RFC2367 PF_KEYv2 Key management API message parser
+ * Copyright (C) 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ *		Template from klips/net/ipsec/ipsec/ipsec_parse.c.
+ */
+
+char pfkey_v2_ext_bits_c_version[] = "$Id$";
+
+/*
+ * Some ugly stuff to allow consistent debugging code for use in the
+ * kernel and in user space
+*/
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>  /* for printk */
+
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */ 
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#include <linux/ipv6.h>
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+#else /* __KERNEL__ */
+
+#include <sys/types.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#endif
+
+#include <freeswan.h>
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+unsigned int extensions_bitmaps[2/*in/out*/][2/*perm/req*/][SADB_MAX + 1/*ext*/] = {
+
+/* INBOUND EXTENSIONS */
+{
+
+/* PERMITTED IN */
+{
+/* SADB_RESERVED */
+0
+,
+/* SADB_GETSPI */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_SPIRANGE
+,
+/* SADB_UPDATE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_ADD */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_DELETE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_GET */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_ACQUIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+,
+/* SADB_REGISTER */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_EXPIRE */
+0
+,
+/* SADB_FLUSH */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_DUMP */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_X_PROMISC */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_PCHANGE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_GRPSA */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_ADDFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DELFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DEBUG */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_X_EXT_DEBUG
+},
+
+/* REQUIRED IN */
+{
+/* SADB_RESERVED */
+0
+,
+/* SADB_GETSPI */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_SPIRANGE
+,
+/* SADB_UPDATE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+,
+/* SADB_ADD */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+/*| 1<<SADB_EXT_KEY_AUTH*/
+/*| 1<<SADB_EXT_KEY_ENCRYPT*/
+,
+/* SADB_DELETE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_GET */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_ACQUIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_PROPOSAL
+,
+/* SADB_REGISTER */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_EXPIRE */
+0
+,
+/* SADB_FLUSH */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_DUMP */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_X_PROMISC */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_PCHANGE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_GRPSA */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+/*| 1<<SADB_X_EXT_SATYPE2*/
+/*| 1<<SADB_X_EXT_SA2*/
+/*| 1<<SADB_X_EXT_ADDRESS_DST2*/
+,
+/* SADB_X_ADDFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DELFLOW */
+1<<SADB_EXT_RESERVED
+/*| 1<<SADB_EXT_SA*/
+#if 0 /* SADB_X_CLREROUTE doesn't need all these... */
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+#endif
+,
+/* SADB_X_DEBUG */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_X_EXT_DEBUG
+}
+
+},
+
+/* OUTBOUND EXTENSIONS */
+{
+
+/* PERMITTED OUT */
+{
+/* SADB_RESERVED */
+0
+,
+/* SADB_GETSPI */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_UPDATE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_ADD */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_DELETE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_GET */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_ACQUIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+,
+/* SADB_REGISTER */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+,
+/* SADB_EXPIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_FLUSH */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_DUMP */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+,
+/* SADB_X_PROMISC */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_PCHANGE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_GRPSA */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_ADDFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DELFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DEBUG */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_X_EXT_DEBUG
+},
+
+/* REQUIRED OUT */
+{
+/* SADB_RESERVED */
+0
+,
+/* SADB_GETSPI */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_UPDATE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_ADD */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_DELETE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_GET */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+,
+/* SADB_ACQUIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_PROPOSAL
+,
+/* SADB_REGISTER */
+1<<SADB_EXT_RESERVED
+/* | 1<<SADB_EXT_SUPPORTED_AUTH
+   | 1<<SADB_EXT_SUPPORTED_ENCRYPT */
+,
+/* SADB_EXPIRE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+/* | 1<<SADB_EXT_LIFETIME_HARD
+   | 1<<SADB_EXT_LIFETIME_SOFT */
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_FLUSH */
+1<<SADB_EXT_RESERVED
+,
+/* SADB_DUMP */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+,
+/* SADB_X_PROMISC */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_PCHANGE */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_LIFETIME_CURRENT
+| 1<<SADB_EXT_LIFETIME_HARD
+| 1<<SADB_EXT_LIFETIME_SOFT
+| 1<<SADB_EXT_ADDRESS_SRC
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_EXT_ADDRESS_PROXY
+| 1<<SADB_EXT_KEY_AUTH
+| 1<<SADB_EXT_KEY_ENCRYPT
+| 1<<SADB_EXT_IDENTITY_SRC
+| 1<<SADB_EXT_IDENTITY_DST
+| 1<<SADB_EXT_SENSITIVITY
+| 1<<SADB_EXT_PROPOSAL
+| 1<<SADB_EXT_SUPPORTED_AUTH
+| 1<<SADB_EXT_SUPPORTED_ENCRYPT
+| 1<<SADB_EXT_SPIRANGE
+| 1<<SADB_X_EXT_KMPRIVATE
+| 1<<SADB_X_EXT_SATYPE2
+| 1<<SADB_X_EXT_SA2
+| 1<<SADB_X_EXT_ADDRESS_DST2
+,
+/* SADB_X_GRPSA */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+,
+/* SADB_X_ADDFLOW */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_EXT_SA
+| 1<<SADB_EXT_ADDRESS_DST
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DELFLOW */
+1<<SADB_EXT_RESERVED
+/*| 1<<SADB_EXT_SA*/
+| 1<<SADB_X_EXT_ADDRESS_SRC_FLOW
+| 1<<SADB_X_EXT_ADDRESS_DST_FLOW
+| 1<<SADB_X_EXT_ADDRESS_SRC_MASK
+| 1<<SADB_X_EXT_ADDRESS_DST_MASK
+,
+/* SADB_X_DEBUG */
+1<<SADB_EXT_RESERVED
+| 1<<SADB_X_EXT_DEBUG
+}
+}
+};
+
+/*
+ * $Log$
+ * Revision 1.7  2000/09/12 22:35:37  rgb
+ * Restructured to remove unused extensions from CLEARFLOW messages.
+ *
+ * Revision 1.6  2000/09/09 06:39:01  rgb
+ * Added comments for clarity.
+ *
+ * Revision 1.5  2000/06/02 22:54:14  rgb
+ * Added Gerhard Gessler's struct sockaddr_storage mods for IPv6 support.
+ *
+ * Revision 1.4  2000/01/21 06:27:56  rgb
+ * Added address cases for eroute flows.
+ * Added comments for each message type.
+ * Added klipsdebug switching capability.
+ * Fixed GRPSA bitfields.
+ *
+ * Revision 1.3  1999/12/01 22:20:27  rgb
+ * Remove requirement for a proxy address in an incoming getspi message.
+ *
+ * Revision 1.2  1999/11/27 11:57:06  rgb
+ * Consolidated the 4 1-d extension bitmap arrays into one 4-d array.
+ * Add CVS log entry to bottom of file.
+ * Cleaned out unused bits.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_parse.c linux/net/ipsec/libfreeswan/pfkey_v2_parse.c
--- linux-noipsec/net/ipsec/libfreeswan/pfkey_v2_parse.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/pfkey_v2_parse.c	Fri Nov 17 19:10:30 2000
@@ -0,0 +1,1428 @@
+/*
+ * RFC2367 PF_KEYv2 Key management API message parser
+ * Copyright (C) 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ *		Template from klips/net/ipsec/ipsec/ipsec_parser.c.
+ */
+
+char pfkey_v2_parse_c_version[] = "$Id$";
+
+/*
+ * Some ugly stuff to allow consistent debugging code for use in the
+ * kernel and in user space
+*/
+
+#ifdef __KERNEL__
+
+# include <linux/kernel.h>  /* for printk */
+
+# include <linux/malloc.h> /* kmalloc() */
+# include <linux/errno.h>  /* error codes */
+# include <linux/types.h>  /* size_t */
+# include <linux/interrupt.h> /* mark_bh */
+
+# include <linux/netdevice.h>   /* struct device, and other headers */
+# include <linux/etherdevice.h> /* eth_type_trans */
+# include <linux/ip.h>          /* struct iphdr */ 
+# if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#  include <linux/ipv6.h>        /* struct ipv6hdr */
+# endif /* if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+extern int debug_pfkey;
+
+#else /* __KERNEL__ */
+
+# include <sys/types.h>
+# include <linux/types.h>
+# include <linux/errno.h>
+
+# include "../pluto/constants.h" 
+# include "../pluto/defs.h"  /* for PRINTF_LIKE */
+# include "../pluto/log.h"  /* for debugging and DBG_log */
+
+extern unsigned int pfkey_lib_debug;  /* bits selecting what to report */
+
+/* #define PLUTO */
+
+# ifdef PLUTO
+#  define DEBUGGING(args...)  { DBG_log("pfkey_lib_debug:" args);  }
+# else
+#  define DEBUGGING(args...)  if(pfkey_lib_debug) { printf("pfkey_lib_debug:" args); } else { ; }
+# endif
+
+#endif /* __KERNEL__ */
+
+
+#include <freeswan.h>
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+#ifdef __KERNEL__
+# include "../radij.h"  /* rd_nodes */
+# include "../ipsec_encap.h"  /* sockaddr_encap */
+# include "../ipsec_netlink.h"  /* KLIPS_PRINT */
+# define DEBUGGING(args...) \
+         KLIPS_PRINT(debug_pfkey, "klips_debug:" args)
+/*         ((debug_pfkey) ? printk(KERN_INFO "klips_debug:" format , ## args) : 0) */
+#endif /* __KERNEL__ */
+
+
+#define SENDERR(_x) do { error = -(_x); goto errlab; } while (0)
+
+struct satype_tbl {
+	uint8_t proto;
+	uint8_t satype;
+	char* name;
+} static satype_tbl[] = {
+#ifdef __KERNEL__
+	{ IPPROTO_ESP,	SADB_SATYPE_ESP,	"ESP"  },
+	{ IPPROTO_AH,	SADB_SATYPE_AH,		"AH"   },
+	{ IPPROTO_IPIP,	SADB_X_SATYPE_IPIP,	"IPIP" },
+#ifdef CONFIG_IPSEC_IPCOMP
+	{ IPPROTO_COMP,	SADB_X_SATYPE_COMP,	"COMP" },
+#endif /* CONFIG_IPSEC_IPCOMP */
+#else /* __KERNEL__ */
+	{ SA_ESP,	SADB_SATYPE_ESP,	"ESP"  },
+	{ SA_AH,	SADB_SATYPE_AH,		"AH"   },
+	{ SA_IPIP,	SADB_X_SATYPE_IPIP,	"IPIP" },
+	{ SA_COMP,	SADB_X_SATYPE_COMP,	"COMP" },
+#endif /* __KERNEL__ */
+	{ 0, 0 }
+};
+
+uint8_t satype2proto(uint8_t satype) {
+	int i =0;
+
+	while(satype_tbl[i].satype != satype && satype_tbl[i].satype != 0) {
+		i++;
+	}
+	return satype_tbl[i].proto;
+}
+
+uint8_t proto2satype(uint8_t proto) {
+	int i = 0;
+
+	while(satype_tbl[i].proto != proto && satype_tbl[i].proto != 0) {
+		i++;
+	}
+	return satype_tbl[i].satype;
+}
+
+char* proto2name(uint8_t proto) {
+	int i = 0;
+
+	while(satype_tbl[i].proto != proto && satype_tbl[i].proto != 0) {
+		i++;
+	}
+	return satype_tbl[i].name;
+}
+
+uint8_t sadb_satype2proto[] = {
+#ifdef __KERNEL__
+	0,
+	0,
+	IPPROTO_AH,
+	IPPROTO_ESP,
+	0,
+	0,
+	0,
+	0,
+	0,
+	IPPROTO_IPIP,
+	IPPROTO_COMP
+#else /* __KERNEL__ */
+	0,
+	0,
+	SA_AH,
+	SA_ESP,
+	0,
+	0,
+	0,
+	0,
+	0,
+	SA_IPIP,
+	SA_COMP
+#endif /* __KERNEL__ */
+};
+
+/* Default extension parsers taken from the KLIPS code */
+
+DEBUG_NO_STATIC int
+pfkey_sa_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_sa *pfkey_sa = (struct sadb_sa *)pfkey_ext;
+	
+	DEBUGGING(
+		"pfkey_sa_parse:\n");
+	/* sanity checks... */
+	if(!pfkey_sa) {
+		DEBUGGING(
+			"pfkey_sa_parse: NULL pointer passed in.\n");
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_len != sizeof(struct sadb_sa) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_sa_parse: length wrong pfkey_sa->sadb_sa_len=%d sizeof(struct sadb_sa)=%d.\n",
+			pfkey_sa->sadb_sa_len,
+			sizeof(struct sadb_sa));
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_encrypt > SADB_EALG_MAX) {
+		DEBUGGING(
+			"pfkey_sa_parse: pfkey_sa->sadb_sa_encrypt=%d > SADB_EALG_MAX=%d.\n",
+			pfkey_sa->sadb_sa_encrypt,
+			SADB_EALG_MAX);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_auth > SADB_AALG_MAX) {
+		DEBUGGING(
+			"pfkey_sa_parse: pfkey_sa->sadb_sa_auth=%d > SADB_AALG_MAX=%d.\n",
+			pfkey_sa->sadb_sa_auth,
+			SADB_AALG_MAX);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_state > SADB_SASTATE_MAX) {
+		DEBUGGING(
+			"pfkey_sa_parse: state=%d exceeds MAX=%d.\n",
+			pfkey_sa->sadb_sa_state,
+			SADB_SASTATE_MAX);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_state == SADB_SASTATE_DEAD) {
+		DEBUGGING(
+			"pfkey_sa_parse: state=%d is DEAD=%d.\n",
+			pfkey_sa->sadb_sa_state,
+			SADB_SASTATE_DEAD);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_sa->sadb_sa_replay > 64) {
+		DEBUGGING(
+			"pfkey_sa_parse: replay window size: %d"
+			" -- must be 0 <= size <= 64\n",
+			pfkey_sa->sadb_sa_replay);
+		SENDERR(EINVAL);
+	}
+	
+	if(! ((pfkey_sa->sadb_sa_exttype ==  SADB_EXT_SA) ||
+	      (pfkey_sa->sadb_sa_exttype ==  SADB_X_EXT_SA2)))
+	{
+		DEBUGGING(
+			"pfkey_sa_parse: unknown exttype=%d, expecting SADB_EXT_SA=%d or SADB_X_EXT_SA2=%d.\n",
+			pfkey_sa->sadb_sa_exttype,
+			SADB_EXT_SA,
+			SADB_X_EXT_SA2);
+		SENDERR(EINVAL);
+	}
+	DEBUGGING(
+		"pfkey_sa_parse: successfully found len=%d exttype=%d spi=%08lx replay=%d state=%d auth=%d encrypt=%d flags=%d.\n",
+		pfkey_sa->sadb_sa_len,
+		pfkey_sa->sadb_sa_exttype,
+		(long unsigned int)ntohl(pfkey_sa->sadb_sa_spi),
+		pfkey_sa->sadb_sa_replay,
+		pfkey_sa->sadb_sa_state,
+		pfkey_sa->sadb_sa_auth,
+		pfkey_sa->sadb_sa_encrypt,
+		pfkey_sa->sadb_sa_flags);
+
+ errlab:
+	return error;
+}	
+
+DEBUG_NO_STATIC int
+pfkey_lifetime_parse(struct sadb_ext  *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_lifetime *pfkey_lifetime = (struct sadb_lifetime *)pfkey_ext;
+
+	DEBUGGING(
+		    "pfkey_lifetime_parse:\n");
+	/* sanity checks... */
+	if(!pfkey_lifetime) {
+		DEBUGGING(
+			"pfkey_lifetime_parse: NULL pointer passed in.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_lifetime->sadb_lifetime_len !=
+	   sizeof(struct sadb_lifetime) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_lifetime_parse: length wrong pfkey_lifetime->sadb_lifetime_len=%d sizeof(struct sadb_lifetime)=%d.\n",
+			pfkey_lifetime->sadb_lifetime_len,
+			sizeof(struct sadb_lifetime));
+		SENDERR(EINVAL);
+	}
+
+	if((pfkey_lifetime->sadb_lifetime_exttype != SADB_EXT_LIFETIME_HARD) &&
+	   (pfkey_lifetime->sadb_lifetime_exttype != SADB_EXT_LIFETIME_SOFT) &&
+	   (pfkey_lifetime->sadb_lifetime_exttype != SADB_EXT_LIFETIME_CURRENT)) {
+		DEBUGGING( 
+			"pfkey_lifetime_parse: unexpected ext_type=%d.\n", 
+			pfkey_lifetime->sadb_lifetime_exttype); 
+		SENDERR(EINVAL);
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_address_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	int saddr_len = 0;
+	struct sadb_address *pfkey_address = (struct sadb_address *)pfkey_ext;
+	struct sockaddr* s = (struct sockaddr*)((char*)pfkey_address + sizeof(*pfkey_address));
+	char ipaddr_txt[ADDRTOT_BUF];
+	
+	DEBUGGING(
+		"pfkey_address_parse:\n");
+	/* sanity checks... */
+	if(!pfkey_address) {
+		DEBUGGING(
+			"pfkey_address_parse: NULL pointer passed in.\n");
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_address->sadb_address_len <
+	   (sizeof(struct sadb_address) + sizeof(struct sockaddr))/
+	   IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_address_parse: size wrong 1 ext_len=%d, adr_ext_len=%d, saddr_len=%d.\n",
+			pfkey_address->sadb_address_len,
+			sizeof(struct sadb_address),
+			sizeof(struct sockaddr));
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_address->sadb_address_reserved) {
+		DEBUGGING(
+			"pfkey_address_parse: res=%d, must be zero.\n",
+			pfkey_address->sadb_address_reserved);
+		SENDERR(EINVAL);
+	}
+	
+	switch(pfkey_address->sadb_address_exttype) {	
+	case SADB_EXT_ADDRESS_SRC:
+	case SADB_EXT_ADDRESS_DST:
+	case SADB_EXT_ADDRESS_PROXY:
+	case SADB_X_EXT_ADDRESS_DST2:
+	case SADB_X_EXT_ADDRESS_SRC_FLOW:
+	case SADB_X_EXT_ADDRESS_DST_FLOW:
+	case SADB_X_EXT_ADDRESS_SRC_MASK:
+	case SADB_X_EXT_ADDRESS_DST_MASK:
+		break;
+	default:
+		DEBUGGING( 
+			"pfkey_address_parse: unexpected ext_type=%d.\n", 
+			pfkey_address->sadb_address_exttype); 
+		SENDERR(EINVAL); 
+	}
+	
+	switch(s->sa_family) {
+	case AF_INET:
+		DEBUGGING(
+			"pfkey_address_parse: found address family=%d, AF_INET.\n",
+			s->sa_family);
+		saddr_len = sizeof(struct sockaddr_in);
+		sprintf(ipaddr_txt, "%d.%d.%d.%d"
+			, (((struct sockaddr_in*)s)->sin_addr.s_addr >>  0) & 0xFF
+			, (((struct sockaddr_in*)s)->sin_addr.s_addr >>  8) & 0xFF
+			, (((struct sockaddr_in*)s)->sin_addr.s_addr >> 16) & 0xFF
+			, (((struct sockaddr_in*)s)->sin_addr.s_addr >> 24) & 0xFF);
+		DEBUGGING(
+			"pfkey_address_parse: found address=%s.\n",
+			ipaddr_txt);
+		break;
+	case AF_INET6:
+		DEBUGGING(
+			"pfkey_address_parse: found address family=%d, AF_INET6.\n",
+			s->sa_family);
+		saddr_len = sizeof(struct sockaddr_in6);
+		sprintf(ipaddr_txt, "%x:%x:%x:%x:%x:%x:%x:%x"
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[0])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[1])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[2])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[3])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[4])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[5])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[6])
+			, ntohs(((struct sockaddr_in6*)s)->sin6_addr.s6_addr16[7]));
+		DEBUGGING(
+			"pfkey_address_parse: found address=%s.\n",
+			ipaddr_txt);
+		break;
+	default:
+		DEBUGGING(
+			"pfkey_address_parse: s->sa_family=%d not supported.\n",
+			s->sa_family);
+		SENDERR(EPFNOSUPPORT);
+	}
+	
+	if(pfkey_address->sadb_address_len !=
+	   DIVUP(sizeof(struct sadb_address) + saddr_len, IPSEC_PFKEYv2_ALIGN)) {
+		DEBUGGING(
+			"pfkey_address_parse: size wrong 2 ext_len=%d, adr_ext_len=%d, saddr_len=%d.\n",
+			pfkey_address->sadb_address_len,
+			sizeof(struct sadb_address),
+			saddr_len);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_address->sadb_address_prefixlen != 0) {
+		DEBUGGING(
+			"pfkey_address_parse: address prefixes not supported yet.\n");
+		SENDERR(EAFNOSUPPORT); /* not supported yet */
+	}
+	
+	/* XXX check if port!=0 */
+	
+	DEBUGGING(
+		"pfkey_address_parse: successful.\n");
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_key_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_key *pfkey_key = (struct sadb_key *)pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_key_parse:\n");
+	/* sanity checks... */
+
+	if(!pfkey_key) {
+		DEBUGGING(
+			"pfkey_key_parse: NULL pointer passed in.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_key->sadb_key_len < sizeof(struct sadb_key) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_key_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_key->sadb_key_len,
+			sizeof(struct sadb_key));
+		SENDERR(EINVAL);
+	}
+
+	if(!pfkey_key->sadb_key_bits) {
+		DEBUGGING(
+			"pfkey_key_parse: key length set to zero, must be non-zero.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_key->sadb_key_len !=
+	   DIVUP(sizeof(struct sadb_key) * OCTETBITS + pfkey_key->sadb_key_bits,
+		 PFKEYBITS)) {
+		DEBUGGING(
+			"pfkey_key_parse: key length=%d does not agree with extension length=%d.\n",
+			pfkey_key->sadb_key_bits,
+			pfkey_key->sadb_key_len);
+		SENDERR(EINVAL);
+	}
+	
+	if(pfkey_key->sadb_key_reserved) {
+		DEBUGGING(
+			"pfkey_key_parse: res=%d, must be zero.\n",
+			pfkey_key->sadb_key_reserved);
+		SENDERR(EINVAL);
+	}
+
+	if(! ( (pfkey_key->sadb_key_exttype == SADB_EXT_KEY_AUTH) ||
+	       (pfkey_key->sadb_key_exttype == SADB_EXT_KEY_ENCRYPT))) {
+		DEBUGGING(
+			"pfkey_key_parse: expecting extension type AUTH or ENCRYPT, got %d.\n",
+			pfkey_key->sadb_key_exttype);
+		SENDERR(EINVAL);
+	}
+
+	DEBUGGING(
+		"pfkey_key_parse: success, found len=%d exttype=%d bits=%d reserved=%d.\n",
+		pfkey_key->sadb_key_len,
+		pfkey_key->sadb_key_exttype,
+		pfkey_key->sadb_key_bits,
+		pfkey_key->sadb_key_reserved);
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_ident_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_ident *pfkey_ident = (struct sadb_ident *)pfkey_ext;
+
+	/* sanity checks... */
+	if(pfkey_ident->sadb_ident_len < sizeof(struct sadb_ident) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_ident_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_ident->sadb_ident_len,
+			sizeof(struct sadb_ident));
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_ident->sadb_ident_type > SADB_IDENTTYPE_MAX) {
+		DEBUGGING(
+			"pfkey_ident_parse: ident_type=%d out of range, must be less than %d.\n",
+			pfkey_ident->sadb_ident_type,
+			SADB_IDENTTYPE_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_ident->sadb_ident_reserved) {
+		DEBUGGING(
+			"pfkey_ident_parse: res=%d, must be zero.\n",
+			pfkey_ident->sadb_ident_reserved);
+		SENDERR(EINVAL);
+	}
+
+	/* string terminator/padding must be zero */
+	if(pfkey_ident->sadb_ident_len > sizeof(struct sadb_ident) / IPSEC_PFKEYv2_ALIGN) {
+		if(*((char*)pfkey_ident + pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN - 1)) {
+			DEBUGGING(
+				"pfkey_ident_parse: string padding must be zero, last is 0x%02x.\n",
+				*((char*)pfkey_ident +
+				  pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN - 1));
+			SENDERR(EINVAL);
+		}
+	}
+	
+	if( ! ((pfkey_ident->sadb_ident_exttype == SADB_EXT_IDENTITY_SRC) ||
+	       (pfkey_ident->sadb_ident_exttype == SADB_EXT_IDENTITY_DST))) {
+		DEBUGGING(
+			"pfkey_key_parse: expecting extension type IDENTITY_SRC or IDENTITY_DST, got %d.\n",
+			pfkey_ident->sadb_ident_exttype);
+		SENDERR(EINVAL);
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_sens_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_sens *pfkey_sens = (struct sadb_sens *)pfkey_ext;
+
+	/* sanity checks... */
+	if(pfkey_sens->sadb_sens_len < sizeof(struct sadb_sens) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_sens_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_sens->sadb_sens_len,
+			sizeof(struct sadb_sens));
+		SENDERR(EINVAL);
+	}
+
+	DEBUGGING(
+		"pfkey_sens_parse: Sorry, I can't parse exttype=%d yet.\n",
+		pfkey_ext->sadb_ext_type);
+#if 0
+	SENDERR(EINVAL); /* don't process these yet */
+#endif
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_prop_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	int i, num_comb;
+	struct sadb_prop *pfkey_prop = (struct sadb_prop *)pfkey_ext;
+	struct sadb_comb *pfkey_comb = (struct sadb_comb *)((char*)pfkey_ext + sizeof(struct sadb_prop));
+
+	/* sanity checks... */
+	if((pfkey_prop->sadb_prop_len < sizeof(struct sadb_prop) / IPSEC_PFKEYv2_ALIGN) || 
+	   (((pfkey_prop->sadb_prop_len * IPSEC_PFKEYv2_ALIGN) - sizeof(struct sadb_prop)) % sizeof(struct sadb_comb))) {
+		DEBUGGING(
+			"pfkey_prop_parse: size wrong ext_len=%d, prop_ext_len=%d comb_ext_len=%d.\n",
+			pfkey_prop->sadb_prop_len,
+			sizeof(struct sadb_prop),
+			sizeof(struct sadb_comb));
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_prop->sadb_prop_replay > 64) {
+		DEBUGGING(
+			"pfkey_prop_parse: replay window size: %d"
+			" -- must be 0 <= size <= 64\n",
+			pfkey_prop->sadb_prop_replay);
+		SENDERR(EINVAL);
+	}
+	
+	for(i=0; i<3; i++) {
+		if(pfkey_prop->sadb_prop_reserved[i]) {
+			DEBUGGING(
+				"pfkey_prop_parse: res[%d]=%d, must be zero.\n",
+				i, pfkey_prop->sadb_prop_reserved[i]);
+			SENDERR(EINVAL);
+		}
+	}
+
+	num_comb = ((pfkey_prop->sadb_prop_len * IPSEC_PFKEYv2_ALIGN) - sizeof(struct sadb_prop)) / sizeof(struct sadb_comb);
+
+	for(i = 0; i < num_comb; i++) {
+		if(pfkey_comb->sadb_comb_auth > SADB_AALG_MAX) {
+			DEBUGGING(
+				"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth=%d > SADB_AALG_MAX=%d.\n",
+				i,
+				pfkey_comb->sadb_comb_auth,
+				SADB_AALG_MAX);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_auth) {
+			if(!pfkey_comb->sadb_comb_auth_minbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth_minbits=0, fatal.\n",
+					i);
+				SENDERR(EINVAL);
+			}
+			if(!pfkey_comb->sadb_comb_auth_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth_maxbits=0, fatal.\n",
+					i);
+				SENDERR(EINVAL);
+			}
+			if(pfkey_comb->sadb_comb_auth_minbits > pfkey_comb->sadb_comb_auth_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth_minbits=%d > maxbits=%d, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_auth_minbits,
+					pfkey_comb->sadb_comb_auth_maxbits);
+				SENDERR(EINVAL);
+			}
+		} else {
+			if(pfkey_comb->sadb_comb_auth_minbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth_minbits=%d != 0, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_auth_minbits);
+				SENDERR(EINVAL);
+			}
+			if(pfkey_comb->sadb_comb_auth_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_auth_maxbits=%d != 0, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_auth_maxbits);
+				SENDERR(EINVAL);
+			}
+		}
+
+		if(pfkey_comb->sadb_comb_encrypt > SADB_EALG_MAX) {
+			DEBUGGING(
+				"pfkey_comb_parse: pfkey_comb[%d]->sadb_comb_encrypt=%d > SADB_EALG_MAX=%d.\n",
+				i,
+				pfkey_comb->sadb_comb_encrypt,
+				SADB_EALG_MAX);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_encrypt) {
+			if(!pfkey_comb->sadb_comb_encrypt_minbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_encrypt_minbits=0, fatal.\n",
+					i);
+				SENDERR(EINVAL);
+			}
+			if(!pfkey_comb->sadb_comb_encrypt_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_encrypt_maxbits=0, fatal.\n",
+					i);
+				SENDERR(EINVAL);
+			}
+			if(pfkey_comb->sadb_comb_encrypt_minbits > pfkey_comb->sadb_comb_encrypt_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_encrypt_minbits=%d > maxbits=%d, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_encrypt_minbits,
+					pfkey_comb->sadb_comb_encrypt_maxbits);
+				SENDERR(EINVAL);
+			}
+		} else {
+			if(pfkey_comb->sadb_comb_encrypt_minbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_encrypt_minbits=%d != 0, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_encrypt_minbits);
+				SENDERR(EINVAL);
+			}
+			if(pfkey_comb->sadb_comb_encrypt_maxbits) {
+				DEBUGGING(
+					"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_encrypt_maxbits=%d != 0, fatal.\n",
+					i,
+					pfkey_comb->sadb_comb_encrypt_maxbits);
+				SENDERR(EINVAL);
+			}
+		}
+
+		/* XXX do sanity check on flags */
+
+		if(pfkey_comb->sadb_comb_hard_allocations && pfkey_comb->sadb_comb_soft_allocations > pfkey_comb->sadb_comb_hard_allocations) {
+			DEBUGGING(
+				"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_soft_allocations=%d > hard_allocations=%d, fatal.\n",
+				i,
+				pfkey_comb->sadb_comb_soft_allocations,
+				pfkey_comb->sadb_comb_hard_allocations);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_hard_bytes && pfkey_comb->sadb_comb_soft_bytes > pfkey_comb->sadb_comb_hard_bytes) {
+			DEBUGGING(
+				"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_soft_bytes=%Ld > hard_bytes=%Ld, fatal.\n",
+				i,
+				pfkey_comb->sadb_comb_soft_bytes,
+				pfkey_comb->sadb_comb_hard_bytes);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_hard_addtime && pfkey_comb->sadb_comb_soft_addtime > pfkey_comb->sadb_comb_hard_addtime) {
+			DEBUGGING(
+				"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_soft_addtime=%Ld > hard_addtime=%Ld, fatal.\n",
+				i,
+				pfkey_comb->sadb_comb_soft_addtime,
+				pfkey_comb->sadb_comb_hard_addtime);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_hard_usetime && pfkey_comb->sadb_comb_soft_usetime > pfkey_comb->sadb_comb_hard_usetime) {
+			DEBUGGING(
+				"pfkey_prop_parse: pfkey_comb[%d]->sadb_comb_soft_usetime=%Ld > hard_usetime=%Ld, fatal.\n",
+				i,
+				pfkey_comb->sadb_comb_soft_usetime,
+				pfkey_comb->sadb_comb_hard_usetime);
+			SENDERR(EINVAL);
+		}
+
+		if(pfkey_comb->sadb_comb_reserved) {
+			DEBUGGING(
+				"pfkey_prop_parse: comb[%d].res=%d, must be zero.\n",
+				i,
+				pfkey_comb->sadb_comb_reserved);
+			SENDERR(EINVAL);
+		}
+		pfkey_comb++;
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_supported_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	unsigned int i, num_alg;
+	struct sadb_supported *pfkey_supported = (struct sadb_supported *)pfkey_ext;
+	struct sadb_alg *pfkey_alg = (struct sadb_alg*)((char*)pfkey_ext + sizeof(struct sadb_supported));
+
+	/* sanity checks... */
+	if((pfkey_supported->sadb_supported_len <
+	   sizeof(struct sadb_supported) / IPSEC_PFKEYv2_ALIGN) ||
+	   (((pfkey_supported->sadb_supported_len * IPSEC_PFKEYv2_ALIGN) -
+	     sizeof(struct sadb_supported)) % sizeof(struct sadb_alg))) {
+
+		DEBUGGING(
+			"pfkey_supported_parse: size wrong ext_len=%d, supported_ext_len=%d alg_ext_len=%d.\n",
+			pfkey_supported->sadb_supported_len,
+			sizeof(struct sadb_supported),
+			sizeof(struct sadb_alg));
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_supported->sadb_supported_reserved) {
+		DEBUGGING(
+			"pfkey_supported_parse: res=%d, must be zero.\n",
+			pfkey_supported->sadb_supported_reserved);
+		SENDERR(EINVAL);
+	}
+
+	num_alg = ((pfkey_supported->sadb_supported_len * IPSEC_PFKEYv2_ALIGN) - sizeof(struct sadb_supported)) / sizeof(struct sadb_alg);
+
+	for(i = 0; i < num_alg; i++) {
+		/* process algo description */
+		if(pfkey_alg->sadb_alg_reserved) {
+			DEBUGGING(
+				"pfkey_supported_parse: alg[%d], id=%d, ivlen=%d, minbits=%d, maxbits=%d, res=%d, must be zero.\n",
+				i,
+				pfkey_alg->sadb_alg_id,
+				pfkey_alg->sadb_alg_ivlen,
+				pfkey_alg->sadb_alg_minbits,
+				pfkey_alg->sadb_alg_maxbits,
+				pfkey_alg->sadb_alg_reserved);
+			SENDERR(EINVAL);
+		}
+
+		/* XXX can alg_id auth/enc be determined from info given?
+		   Yes, but OpenBSD's method does not iteroperate with rfc2367.
+		   rgb, 2000-04-06 */
+
+		switch(pfkey_supported->sadb_supported_exttype) {
+		case SADB_EXT_SUPPORTED_AUTH:
+			if(pfkey_alg->sadb_alg_id > SADB_AALG_MAX) {
+				DEBUGGING(
+					"pfkey_supported_parse: alg[%d], alg_id=%d > SADB_AALG_MAX=%d, fatal.\n",
+					i,
+					pfkey_alg->sadb_alg_id,
+					SADB_AALG_MAX);
+				SENDERR(EINVAL);
+			}
+			break;
+		case SADB_EXT_SUPPORTED_ENCRYPT:
+			if(pfkey_alg->sadb_alg_id > SADB_EALG_MAX) {
+				DEBUGGING(
+					"pfkey_supported_parse: alg[%d], alg_id=%d > SADB_EALG_MAX=%d, fatal.\n",
+					i,
+					pfkey_alg->sadb_alg_id,
+					SADB_EALG_MAX);
+				SENDERR(EINVAL);
+			}
+			break;
+		default:
+			DEBUGGING(
+				"pfkey_supported_parse: alg[%d], alg_id=%d > SADB_EALG_MAX=%d, fatal.\n",
+				i,
+				pfkey_alg->sadb_alg_id,
+				SADB_EALG_MAX);
+			SENDERR(EINVAL);
+		}
+		pfkey_alg++;
+	}
+	
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_spirange_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_spirange *pfkey_spirange = (struct sadb_spirange *)pfkey_ext;
+	
+	/* sanity checks... */
+        if(pfkey_spirange->sadb_spirange_len !=
+	   sizeof(struct sadb_spirange) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_spirange_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_spirange->sadb_spirange_len,
+			sizeof(struct sadb_spirange));
+                SENDERR(EINVAL);
+        }
+	
+        if(pfkey_spirange->sadb_spirange_reserved) {
+		DEBUGGING(
+			" pfkey_spirange_parse: reserved=%d must be set to zero.\n",
+			pfkey_spirange->sadb_spirange_reserved);
+                SENDERR(EINVAL);
+        }
+	
+        if(ntohl(pfkey_spirange->sadb_spirange_max) < ntohl(pfkey_spirange->sadb_spirange_min)) {
+		DEBUGGING(
+			" pfkey_spirange_parse: minspi=%08x must be < maxspi=%08x.\n",
+			ntohl(pfkey_spirange->sadb_spirange_min),
+			ntohl(pfkey_spirange->sadb_spirange_max));
+                SENDERR(EINVAL);
+        }
+	
+	if(ntohl(pfkey_spirange->sadb_spirange_min) <= 255) {
+		DEBUGGING(
+			" pfkey_spirange_parse: minspi=%08x must be > 255.\n",
+			ntohl(pfkey_spirange->sadb_spirange_min));
+		SENDERR(EEXIST);
+	}
+	
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_kmprivate_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	struct sadb_x_kmprivate *pfkey_x_kmprivate = (struct sadb_x_kmprivate *)pfkey_ext;
+
+	/* sanity checks... */
+	if(pfkey_x_kmprivate->sadb_x_kmprivate_len <
+	   sizeof(struct sadb_x_kmprivate) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_x_kmprivate_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_x_kmprivate->sadb_x_kmprivate_len,
+			sizeof(struct sadb_x_kmprivate));
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_x_kmprivate->sadb_x_kmprivate_reserved) {
+		DEBUGGING(
+			" pfkey_x_kmprivate_parse: reserved=%d must be set to zero.\n",
+			pfkey_x_kmprivate->sadb_x_kmprivate_reserved);
+		SENDERR(EINVAL);
+	}
+
+	DEBUGGING(
+		"pfkey_x_kmprivate_parse: Sorry, I can't parse exttype=%d yet.\n",
+		pfkey_ext->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_satype_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	int i;
+	struct sadb_x_satype *pfkey_x_satype = (struct sadb_x_satype *)pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_x_satype_parse:\n");
+	/* sanity checks... */
+	if(pfkey_x_satype->sadb_x_satype_len !=
+	   sizeof(struct sadb_x_satype) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_x_satype_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_x_satype->sadb_x_satype_len,
+			sizeof(struct sadb_x_satype));
+		SENDERR(EINVAL);
+	}
+	
+	if(!pfkey_x_satype->sadb_x_satype_satype) {
+		DEBUGGING(
+			"pfkey_x_satype_parse: satype is zero, must be non-zero.\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_x_satype->sadb_x_satype_satype > SADB_SATYPE_MAX) {
+		DEBUGGING(
+			"pfkey_x_satype_parse: satype %d > max %d\n", 
+			pfkey_x_satype->sadb_x_satype_satype, SADB_SATYPE_MAX);
+		SENDERR(EINVAL);
+	}
+
+	if(!(satype2proto(pfkey_x_satype->sadb_x_satype_satype))) {
+		DEBUGGING(
+			"pfkey_x_satype_parse: proto lookup from satype=%d failed.\n",
+			pfkey_x_satype->sadb_x_satype_satype);
+		SENDERR(EINVAL);
+	}
+
+	for(i = 0; i < 3; i++) {
+		if(pfkey_x_satype->sadb_x_satype_reserved[i]) {
+			DEBUGGING(
+				" pfkey_x_satype_parse: reserved[%d]=%d must be set to zero.\n",
+				i, pfkey_x_satype->sadb_x_satype_reserved[i]);
+			SENDERR(EINVAL);
+		}
+	}
+	
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_ext_debug_parse(struct sadb_ext *pfkey_ext)
+{
+	int error = 0;
+	int i;
+	struct sadb_x_debug *pfkey_x_debug = (struct sadb_x_debug *)pfkey_ext;
+
+	DEBUGGING(
+		"pfkey_x_debug_parse:\n");
+	/* sanity checks... */
+	if(pfkey_x_debug->sadb_x_debug_len !=
+	   sizeof(struct sadb_x_debug) / IPSEC_PFKEYv2_ALIGN) {
+		DEBUGGING(
+			"pfkey_x_debug_parse: size wrong ext_len=%d, key_ext_len=%d.\n",
+			pfkey_x_debug->sadb_x_debug_len,
+			sizeof(struct sadb_x_debug));
+		SENDERR(EINVAL);
+	}
+	
+	for(i = 0; i < 4; i++) {
+		if(pfkey_x_debug->sadb_x_debug_reserved[i]) {
+			DEBUGGING(
+				" pfkey_x_debug_parse: reserved[%d]=%d must be set to zero.\n",
+				i, pfkey_x_debug->sadb_x_debug_reserved[i]);
+			SENDERR(EINVAL);
+		}
+	}
+	
+errlab:
+	return error;
+}
+
+int (*ext_default_parsers[SADB_EXT_MAX +1])(struct sadb_ext*) =
+{
+	NULL, /* pfkey_msg_parse, */
+	pfkey_sa_parse,
+	pfkey_lifetime_parse,
+	pfkey_lifetime_parse,
+	pfkey_lifetime_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_key_parse,
+	pfkey_key_parse,
+	pfkey_ident_parse,
+	pfkey_ident_parse,
+	pfkey_sens_parse,
+	pfkey_prop_parse,
+	pfkey_supported_parse,
+	pfkey_supported_parse,
+	pfkey_spirange_parse,
+	pfkey_x_kmprivate_parse,
+	pfkey_x_satype_parse,
+	pfkey_sa_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_address_parse,
+	pfkey_x_ext_debug_parse
+};
+
+int
+pfkey_msg_parse(struct sadb_msg *pfkey_msg,
+		int (*ext_parsers[])(struct sadb_ext*),
+		struct sadb_ext *extensions[],
+		int dir)
+{
+	int error = 0;
+	int remain;
+	struct sadb_ext *pfkey_ext;
+	int extensions_seen = 0;
+	
+	DEBUGGING(
+		"pfkey_msg_parse: parsing message "
+		"ver=%d, type=%d, errno=%d, satype=%d, len=%d, res=%d, seq=%d, pid=%d.\n", 
+		pfkey_msg->sadb_msg_version,
+		pfkey_msg->sadb_msg_type,
+		pfkey_msg->sadb_msg_errno,
+		pfkey_msg->sadb_msg_satype,
+		pfkey_msg->sadb_msg_len,
+		pfkey_msg->sadb_msg_reserved,
+		pfkey_msg->sadb_msg_seq,
+		pfkey_msg->sadb_msg_pid);
+	
+	if(ext_parsers == NULL) ext_parsers = ext_default_parsers;
+	
+	pfkey_extensions_init(extensions);
+	
+	remain = pfkey_msg->sadb_msg_len;
+	remain -= sizeof(struct sadb_msg) / IPSEC_PFKEYv2_ALIGN;
+	
+	pfkey_ext = (struct sadb_ext*)((char*)pfkey_msg +
+				       sizeof(struct sadb_msg));
+	
+	extensions[0] = (struct sadb_ext *) pfkey_msg;
+	
+	
+	if(pfkey_msg->sadb_msg_version != PF_KEY_V2) {
+		DEBUGGING(
+			"pfkey_msg_parse: "
+			"not PF_KEY_V2 msg, found %d, should be %d.\n",
+			pfkey_msg->sadb_msg_version,
+			PF_KEY_V2);
+		SENDERR(EINVAL);
+	}
+
+	if(!pfkey_msg->sadb_msg_type) {
+		DEBUGGING(
+			"pfkey_msg_parse: msg type not set, must be non-zero..\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_msg->sadb_msg_type > SADB_MAX) {
+		DEBUGGING(
+			"pfkey_msg_parse: msg type=%d > max=%d.\n",
+			pfkey_msg->sadb_msg_type,
+			SADB_MAX);
+		SENDERR(EINVAL);
+	}
+
+	switch(pfkey_msg->sadb_msg_type) {
+	case SADB_GETSPI:
+	case SADB_UPDATE:
+	case SADB_ADD:
+	case SADB_DELETE:
+	case SADB_GET:
+	case SADB_ACQUIRE:
+	case SADB_REGISTER:
+	case SADB_EXPIRE:
+#if 0
+	case SADB_X_PROMISC:
+	case SADB_X_PCHANGE:
+#endif
+	case SADB_X_GRPSA:
+		if(!pfkey_msg->sadb_msg_satype) {
+			DEBUGGING(
+				"pfkey_msg_parse: satype is zero, must be non-zero for msg_type %d.\n", pfkey_msg->sadb_msg_type);
+			SENDERR(EINVAL);
+		}
+		switch(pfkey_msg->sadb_msg_satype) {
+		case SADB_SATYPE_ESP:
+		case SADB_SATYPE_AH:
+		case SADB_X_SATYPE_IPIP:
+		case SADB_X_SATYPE_COMP:
+			break;
+		default:
+			DEBUGGING(
+				"pfkey_msg_parse: "
+				"satype=%d is not supported yet.\n",
+				pfkey_msg->sadb_msg_satype);
+			SENDERR(EINVAL);
+		}
+		break;
+	default:
+	}
+	
+	/* errno must not be set in downward messages */
+	/* this is not entirely true... a response to an ACQUIRE could return an error */
+	if((dir == EXT_BITS_IN) && (pfkey_msg->sadb_msg_type != SADB_ACQUIRE) && pfkey_msg->sadb_msg_errno) {
+		DEBUGGING(
+			    "pfkey_msg_parse: "
+			    "errno set to %d.\n",
+			    pfkey_msg->sadb_msg_errno);
+		SENDERR(EINVAL);
+	}
+
+	DEBUGGING(
+		"pfkey_msg_parse: remain=%d, ext_type=%d, ext_len=%d.\n", 
+		remain, pfkey_ext->sadb_ext_type, pfkey_ext->sadb_ext_len);
+	
+	DEBUGGING(
+		"pfkey_msg_parse: extensions "
+		"permitted=%08x, required=%08x.\n",
+		extensions_bitmaps[dir][EXT_BITS_PERM][pfkey_msg->sadb_msg_type],
+		extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type]);
+	
+	extensions_seen = 1;
+	
+	while( (remain * IPSEC_PFKEYv2_ALIGN) >= sizeof(struct sadb_ext) ) {
+		/* Is there enough message left to support another extension header? */
+		if(remain < pfkey_ext->sadb_ext_len) {
+			DEBUGGING(
+				"pfkey_msg_parse: remain %d less than ext len %d.\n", 
+				remain, pfkey_ext->sadb_ext_len);
+			SENDERR(EINVAL);
+		}
+		
+		DEBUGGING(
+			"pfkey_msg_parse: parsing ext type=%d remain=%d.\n",
+			pfkey_ext->sadb_ext_type,
+			remain);
+		
+		/* Is the extension header type valid? */
+		if((pfkey_ext->sadb_ext_type > SADB_EXT_MAX) || (!pfkey_ext->sadb_ext_type)) {
+			DEBUGGING(
+				"pfkey_msg_parse: ext type %d invalid, SADB_EXT_MAX=%d.\n", 
+				pfkey_ext->sadb_ext_type, SADB_EXT_MAX);
+			SENDERR(EINVAL);
+		}
+		
+		/* Have we already seen this type of extension? */
+		if((extensions_seen & ( 1 << pfkey_ext->sadb_ext_type )) != 0)
+		{
+			DEBUGGING(
+				"pfkey_msg_parse: ext type %d already seen.\n", 
+				pfkey_ext->sadb_ext_type);
+			SENDERR(EINVAL);
+		}
+
+		/* Do I even know about this type of extension? */
+		if(!(ext_parsers[pfkey_ext->sadb_ext_type])) {
+			DEBUGGING(
+				"pfkey_msg_parse: ext type %d unknown, ignoring.\n", 
+				pfkey_ext->sadb_ext_type);
+			goto next_ext;
+		}
+
+		/* Is this type of extension permitted for this type of message? */
+		if(!(extensions_bitmaps[dir][EXT_BITS_PERM][pfkey_msg->sadb_msg_type] &
+		     1<<pfkey_ext->sadb_ext_type)) {
+			DEBUGGING(
+				"pfkey_msg_parse: ext type %d not permitted, exts_perm_in=%08x, 1<<type=%08x\n", 
+				pfkey_ext->sadb_ext_type, 
+				extensions_bitmaps[dir][EXT_BITS_PERM][pfkey_msg->sadb_msg_type],
+				1<<pfkey_ext->sadb_ext_type);
+			SENDERR(EINVAL);
+		}
+
+		DEBUGGING(
+			"pfkey_msg_parse: About to parse extension %d %p with parser %p.\n",
+			pfkey_ext->sadb_ext_type,
+			pfkey_ext,
+			ext_parsers[pfkey_ext->sadb_ext_type]);
+		/* Parse the extension */
+		if((error = ext_parsers[pfkey_ext->sadb_ext_type](pfkey_ext))) {
+			DEBUGGING(
+				"pfkey_msg_parse: extension parsing for type %d failed with error %d.\n",
+				pfkey_ext->sadb_ext_type, error); 
+			SENDERR(-error);
+		}
+		DEBUGGING(
+			"pfkey_msg_parse: Extension %d parsed.\n",
+			pfkey_ext->sadb_ext_type);
+		
+		/* Mark that we have seen this extension and remember the header location */
+		extensions_seen |= ( 1 << pfkey_ext->sadb_ext_type );
+		extensions[pfkey_ext->sadb_ext_type] = pfkey_ext;
+
+	next_ext:		
+		/* Calculate how much message remains */
+		remain -= pfkey_ext->sadb_ext_len;
+
+		if(!remain) {
+			break;
+		}
+		/* Find the next extension header */
+		pfkey_ext = (struct sadb_ext*)((char*)pfkey_ext +
+			pfkey_ext->sadb_ext_len * IPSEC_PFKEYv2_ALIGN);
+	}
+
+	if(remain) {
+		DEBUGGING(
+			"pfkey_msg_parse: unexpected remainder of %d.\n", 
+			remain);
+		/* why is there still something remaining? */
+		SENDERR(EINVAL);
+	}
+
+	/* check required extensions */
+	DEBUGGING(
+		"pfkey_msg_parse: extensions "
+		"permitted=%08x, seen=%08x, required=%08x.\n",
+		extensions_bitmaps[dir][EXT_BITS_PERM][pfkey_msg->sadb_msg_type],
+		extensions_seen,
+		extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type]);
+
+	/* don't check further if it is an error return message since it
+	   may not have a body */
+	if(pfkey_msg->sadb_msg_errno) {
+		return error;
+	}
+
+	if((extensions_seen &
+	    extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type]) !=
+	   extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type]) {
+		DEBUGGING(
+			"pfkey_msg_parse: required extensions missing:%08x.\n",
+			extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type] -
+			(extensions_seen &
+			 extensions_bitmaps[dir][EXT_BITS_REQ][pfkey_msg->sadb_msg_type]));
+		SENDERR(EINVAL);
+	}
+	
+	if((dir == EXT_BITS_IN) && (pfkey_msg->sadb_msg_type == SADB_X_DELFLOW)
+	   && ((extensions_seen	& SADB_X_EXT_ADDRESS_DELFLOW)
+	       != SADB_X_EXT_ADDRESS_DELFLOW)
+	   && (((extensions_seen & (1<<SADB_EXT_SA)) != (1<<SADB_EXT_SA))
+	   || ((((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_flags
+		& SADB_X_SAFLAGS_CLEARFLOW)
+	       != SADB_X_SAFLAGS_CLEARFLOW))) {
+		DEBUGGING(
+			"pfkey_msg_parse: "
+			"required SADB_X_DELFLOW extensions missing: either %08x must be present or %08x must be present with SADB_X_SAFLAGS_CLEARFLOW set.\n",
+			SADB_X_EXT_ADDRESS_DELFLOW
+			- (extensions_seen & SADB_X_EXT_ADDRESS_DELFLOW),
+			(1<<SADB_EXT_SA) - (extensions_seen & (1<<SADB_EXT_SA)));
+		SENDERR(EINVAL);
+	}
+	
+	if((pfkey_msg->sadb_msg_type == SADB_ADD) ||
+	   (pfkey_msg->sadb_msg_type == SADB_UPDATE)) {
+
+		/* check maturity */
+		if(((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state !=
+		   SADB_SASTATE_MATURE) {
+			DEBUGGING(
+				"pfkey_msg_parse: "
+				"state=%d for add or update should be MATURE=%d.\n",
+				((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state,
+				SADB_SASTATE_MATURE);
+			SENDERR(EINVAL);
+		}
+		
+		/* check AH and ESP */
+		if(((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype ==
+		   SADB_SATYPE_AH) {
+			if(!(((struct sadb_sa*)extensions[SADB_EXT_SA]) &&
+			     ((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_auth !=
+			     SADB_AALG_NONE)) {
+				DEBUGGING(
+					"pfkey_msg_parse: "
+					"auth alg is zero, must be non-zero for AH SAs.\n");
+				SENDERR(EINVAL);
+			}
+			if(((struct sadb_sa*)(extensions[SADB_EXT_SA]))->sadb_sa_encrypt !=
+			   SADB_EALG_NONE) {
+				DEBUGGING(
+					"pfkey_msg_parse: "
+					"AH handed encalg=%d, must be zero.\n",
+					((struct sadb_sa*)(extensions[SADB_EXT_SA]))->sadb_sa_encrypt);
+				SENDERR(EINVAL);
+			}
+		}
+		
+		if(((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype ==
+		   SADB_SATYPE_ESP) {
+			if(!(((struct sadb_sa*)extensions[SADB_EXT_SA]) &&
+			     ((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_encrypt !=
+			     SADB_EALG_NONE)) {
+				DEBUGGING(
+					"pfkey_msg_parse: "
+					"encrypt alg=%d is zero, must be non-zero for ESP=%d SAs.\n",
+					((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_encrypt,
+					((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype);
+				SENDERR(EINVAL);
+			}
+			if((((struct sadb_sa*)(extensions[SADB_EXT_SA]))->sadb_sa_encrypt ==
+			    SADB_EALG_NULL) &&
+			   (((struct sadb_sa*)(extensions[SADB_EXT_SA]))->sadb_sa_auth ==
+			    SADB_AALG_NONE) ) {
+				DEBUGGING(
+					"pfkey_msg_parse: "
+					"ESP handed encNULL+authNONE, illegal combination.\n");
+				SENDERR(EINVAL);
+			}
+		}
+	}
+errlab:
+
+	return error;
+}
+
+/*
+ * $Log$
+ * Revision 1.30  2000/11/17 18:10:30  rgb
+ * Fixed bugs mostly relating to spirange, to treat all spi variables as
+ * network byte order since this is the way PF_KEYv2 stored spis.
+ *
+ * Revision 1.29  2000/10/12 00:02:39  rgb
+ * Removed 'format, ##' nonsense from debug macros for RH7.0.
+ *
+ * Revision 1.28  2000/09/20 16:23:04  rgb
+ * Remove over-paranoid extension check in the presence of sadb_msg_errno.
+ *
+ * Revision 1.27  2000/09/20 04:04:21  rgb
+ * Changed static functions to DEBUG_NO_STATIC to reveal function names in
+ * oopsen.
+ *
+ * Revision 1.26  2000/09/15 11:37:02  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.25  2000/09/12 22:35:37  rgb
+ * Restructured to remove unused extensions from CLEARFLOW messages.
+ *
+ * Revision 1.24  2000/09/12 18:59:54  rgb
+ * Added Gerhard's IPv6 support to pfkey parts of libfreeswan.
+ *
+ * Revision 1.23  2000/09/12 03:27:00  rgb
+ * Moved DEBUGGING definition to compile kernel with debug off.
+ *
+ * Revision 1.22  2000/09/09 06:39:27  rgb
+ * Restrict pfkey errno check to downward messages only.
+ *
+ * Revision 1.21  2000/09/08 19:22:34  rgb
+ * Enabled pfkey_sens_parse().
+ * Added check for errno on downward acquire messages only.
+ *
+ * Revision 1.20  2000/09/01 18:48:23  rgb
+ * Fixed reserved check bug and added debug output in
+ * pfkey_supported_parse().
+ * Fixed debug output label bug in pfkey_ident_parse().
+ *
+ * Revision 1.19  2000/08/27 01:55:26  rgb
+ * Define OCTETBITS and PFKEYBITS to avoid using 'magic' numbers in code.
+ *
+ * Revision 1.18  2000/08/24 17:00:36  rgb
+ * Ignore unknown extensions instead of failing.
+ *
+ * Revision 1.17  2000/06/02 22:54:14  rgb
+ * Added Gerhard Gessler's struct sockaddr_storage mods for IPv6 support.
+ *
+ * Revision 1.16  2000/05/10 19:25:11  rgb
+ * Fleshed out proposal and supported extensions.
+ *
+ * Revision 1.15  2000/01/24 21:15:31  rgb
+ * Added disabled pluto pfkey lib debug flag.
+ * Added algo debugging reporting.
+ *
+ * Revision 1.14  2000/01/22 23:24:29  rgb
+ * Added new functions proto2satype() and satype2proto() and lookup
+ * table satype_tbl.  Also added proto2name() since it was easy.
+ *
+ * Revision 1.13  2000/01/21 09:43:59  rgb
+ * Cast ntohl(spi) as (unsigned long int) to shut up compiler.
+ *
+ * Revision 1.12  2000/01/21 06:28:19  rgb
+ * Added address cases for eroute flows.
+ * Indented compiler directives for readability.
+ * Added klipsdebug switching capability.
+ *
+ * Revision 1.11  1999/12/29 21:14:59  rgb
+ * Fixed debug text cut and paste typo.
+ *
+ * Revision 1.10  1999/12/10 17:45:24  rgb
+ * Added address debugging.
+ *
+ * Revision 1.9  1999/12/09 23:11:42  rgb
+ * Ditched <string.h> include since we no longer use memset().
+ * Use new pfkey_extensions_init() instead of memset().
+ * Added check for SATYPE in pfkey_msg_build().
+ * Tidy up comments and debugging comments.
+ *
+ * Revision 1.8  1999/12/07 19:55:26  rgb
+ * Removed unused first argument from extension parsers.
+ * Removed static pluto debug flag.
+ * Moved message type and state checking to pfkey_msg_parse().
+ * Changed print[fk] type from lx to x to quiet compiler.
+ * Removed redundant remain check.
+ * Changed __u* types to uint* to avoid use of asm/types.h and
+ * sys/types.h in userspace code.
+ *
+ * Revision 1.7  1999/12/01 22:20:51  rgb
+ * Moved pfkey_lib_debug variable into the library.
+ * Added pfkey version check into header parsing.
+ * Added check for SATYPE only for those extensions that require a
+ * non-zero value.
+ *
+ * Revision 1.6  1999/11/27 11:58:05  rgb
+ * Added ipv6 headers.
+ * Moved sadb_satype2proto protocol lookup table from
+ * klips/net/ipsec/pfkey_v2_parser.c.
+ * Enable lifetime_current checking.
+ * Debugging error messages added.
+ * Add argument to pfkey_msg_parse() for direction.
+ * Consolidated the 4 1-d extension bitmap arrays into one 4-d array.
+ * Add CVS log entry to bottom of file.
+ * Moved auth and enc alg check to pfkey_msg_parse().
+ * Enable accidentally disabled spirange parsing.
+ * Moved protocol/algorithm checks from klips/net/ipsec/pfkey_v2_parser.c
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libfreeswan/pfkeyv2.h linux/net/ipsec/libfreeswan/pfkeyv2.h
--- linux-noipsec/net/ipsec/libfreeswan/pfkeyv2.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/pfkeyv2.h	Tue Oct 10 22:10:20 2000
@@ -0,0 +1,317 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+This file defines structures and symbols for the PF_KEY Version 2
+key management interface. It was written at the U.S. Naval Research
+Laboratory. This file is in the public domain. The authors ask that
+you leave this credit intact on any copies of this file.
+*/
+#ifndef __PFKEY_V2_H
+#define __PFKEY_V2_H 1
+
+#define PF_KEY_V2 2
+#define PFKEYV2_REVISION        199806L
+
+#define SADB_RESERVED    0
+#define SADB_GETSPI      1
+#define SADB_UPDATE      2
+#define SADB_ADD         3
+#define SADB_DELETE      4
+#define SADB_GET         5
+#define SADB_ACQUIRE     6
+#define SADB_REGISTER    7
+#define SADB_EXPIRE      8
+#define SADB_FLUSH       9
+#define SADB_DUMP       10
+#define SADB_X_PROMISC  11
+#define SADB_X_PCHANGE  12
+#define SADB_X_GRPSA    13
+#define SADB_X_ADDFLOW	14
+#define SADB_X_DELFLOW	15
+#define SADB_X_DEBUG	16
+#define SADB_MAX        16
+
+struct sadb_msg {
+  uint8_t sadb_msg_version;
+  uint8_t sadb_msg_type;
+  uint8_t sadb_msg_errno;
+  uint8_t sadb_msg_satype;
+  uint16_t sadb_msg_len;
+  uint16_t sadb_msg_reserved;
+  uint32_t sadb_msg_seq;
+  uint32_t sadb_msg_pid;
+};
+
+struct sadb_ext {
+  uint16_t sadb_ext_len;
+  uint16_t sadb_ext_type;
+};
+
+struct sadb_sa {
+  uint16_t sadb_sa_len;
+  uint16_t sadb_sa_exttype;
+  uint32_t sadb_sa_spi;
+  uint8_t sadb_sa_replay;
+  uint8_t sadb_sa_state;
+  uint8_t sadb_sa_auth;
+  uint8_t sadb_sa_encrypt;
+  uint32_t sadb_sa_flags;
+};
+
+struct sadb_lifetime {
+  uint16_t sadb_lifetime_len;
+  uint16_t sadb_lifetime_exttype;
+  uint32_t sadb_lifetime_allocations;
+  uint64_t sadb_lifetime_bytes;
+  uint64_t sadb_lifetime_addtime;
+  uint64_t sadb_lifetime_usetime;
+};
+
+struct sadb_address {
+  uint16_t sadb_address_len;
+  uint16_t sadb_address_exttype;
+  uint8_t sadb_address_proto;
+  uint8_t sadb_address_prefixlen;
+  uint16_t sadb_address_reserved;
+};
+
+struct sadb_key {
+  uint16_t sadb_key_len;
+  uint16_t sadb_key_exttype;
+  uint16_t sadb_key_bits;
+  uint16_t sadb_key_reserved;
+};
+
+struct sadb_ident {
+  uint16_t sadb_ident_len;
+  uint16_t sadb_ident_exttype;
+  uint16_t sadb_ident_type;
+  uint16_t sadb_ident_reserved;
+  uint64_t sadb_ident_id;
+};
+
+struct sadb_sens {
+  uint16_t sadb_sens_len;
+  uint16_t sadb_sens_exttype;
+  uint32_t sadb_sens_dpd;
+  uint8_t sadb_sens_sens_level;
+  uint8_t sadb_sens_sens_len;
+  uint8_t sadb_sens_integ_level;
+  uint8_t sadb_sens_integ_len;
+  uint32_t sadb_sens_reserved;
+};
+
+struct sadb_prop {
+  uint16_t sadb_prop_len;
+  uint16_t sadb_prop_exttype;
+  uint8_t sadb_prop_replay;
+  uint8_t sadb_prop_reserved[3];
+};
+
+struct sadb_comb {
+  uint8_t sadb_comb_auth;
+  uint8_t sadb_comb_encrypt;
+  uint16_t sadb_comb_flags;
+  uint16_t sadb_comb_auth_minbits;
+  uint16_t sadb_comb_auth_maxbits;
+  uint16_t sadb_comb_encrypt_minbits;
+  uint16_t sadb_comb_encrypt_maxbits;
+  uint32_t sadb_comb_reserved;
+  uint32_t sadb_comb_soft_allocations;
+  uint32_t sadb_comb_hard_allocations;
+  uint64_t sadb_comb_soft_bytes;
+  uint64_t sadb_comb_hard_bytes;
+  uint64_t sadb_comb_soft_addtime;
+  uint64_t sadb_comb_hard_addtime;
+  uint64_t sadb_comb_soft_usetime;
+  uint64_t sadb_comb_hard_usetime;
+};
+
+struct sadb_supported {
+  uint16_t sadb_supported_len;
+  uint16_t sadb_supported_exttype;
+  uint32_t sadb_supported_reserved;
+};
+
+struct sadb_alg {
+  uint8_t sadb_alg_id;
+  uint8_t sadb_alg_ivlen;
+  uint16_t sadb_alg_minbits;
+  uint16_t sadb_alg_maxbits;
+  uint16_t sadb_alg_reserved;
+};
+
+struct sadb_spirange {
+  uint16_t sadb_spirange_len;
+  uint16_t sadb_spirange_exttype;
+  uint32_t sadb_spirange_min;
+  uint32_t sadb_spirange_max;
+  uint32_t sadb_spirange_reserved;
+};
+
+struct sadb_x_kmprivate {
+  uint16_t sadb_x_kmprivate_len;
+  uint16_t sadb_x_kmprivate_exttype;
+  uint32_t sadb_x_kmprivate_reserved;
+};
+
+struct sadb_x_satype {
+  uint16_t sadb_x_satype_len;
+  uint16_t sadb_x_satype_exttype;
+  uint8_t sadb_x_satype_satype;
+  uint8_t sadb_x_satype_reserved[3];
+};
+  
+struct sadb_x_debug {
+  uint16_t sadb_x_debug_len;
+  uint16_t sadb_x_debug_exttype;
+  uint32_t sadb_x_debug_tunnel;
+  uint32_t sadb_x_debug_netlink;
+  uint32_t sadb_x_debug_xform;
+  uint32_t sadb_x_debug_eroute;
+  uint32_t sadb_x_debug_spi;
+  uint32_t sadb_x_debug_radij;
+  uint32_t sadb_x_debug_esp;
+  uint32_t sadb_x_debug_ah;
+  uint32_t sadb_x_debug_rcv;
+  uint32_t sadb_x_debug_pfkey;
+  uint32_t sadb_x_debug_ipcomp;
+  uint32_t sadb_x_debug_verbose;
+  uint8_t sadb_x_debug_reserved[4];
+};
+  
+#define SADB_EXT_RESERVED             0
+#define SADB_EXT_SA                   1
+#define SADB_EXT_LIFETIME_CURRENT     2
+#define SADB_EXT_LIFETIME_HARD        3
+#define SADB_EXT_LIFETIME_SOFT        4
+#define SADB_EXT_ADDRESS_SRC          5
+#define SADB_EXT_ADDRESS_DST          6
+#define SADB_EXT_ADDRESS_PROXY        7
+#define SADB_EXT_KEY_AUTH             8
+#define SADB_EXT_KEY_ENCRYPT          9
+#define SADB_EXT_IDENTITY_SRC         10
+#define SADB_EXT_IDENTITY_DST         11
+#define SADB_EXT_SENSITIVITY          12
+#define SADB_EXT_PROPOSAL             13
+#define SADB_EXT_SUPPORTED_AUTH       14
+#define SADB_EXT_SUPPORTED_ENCRYPT    15
+#define SADB_EXT_SPIRANGE             16
+#define SADB_X_EXT_KMPRIVATE          17
+#define SADB_X_EXT_SATYPE2            18
+#define SADB_X_EXT_SA2                19
+#define SADB_X_EXT_ADDRESS_DST2       20
+#define SADB_X_EXT_ADDRESS_SRC_FLOW   21
+#define SADB_X_EXT_ADDRESS_DST_FLOW   22
+#define SADB_X_EXT_ADDRESS_SRC_MASK   23
+#define SADB_X_EXT_ADDRESS_DST_MASK   24
+#define SADB_X_EXT_DEBUG              25
+#define SADB_EXT_MAX                  25
+
+/* SADB_X_DELFLOW required over and above SADB_X_SAFLAGS_CLEARFLOW */
+#define SADB_X_EXT_ADDRESS_DELFLOW \
+	( (1<<SADB_X_EXT_ADDRESS_SRC_FLOW) \
+	| (1<<SADB_X_EXT_ADDRESS_DST_FLOW) \
+	| (1<<SADB_X_EXT_ADDRESS_SRC_MASK) \
+	| (1<<SADB_X_EXT_ADDRESS_DST_MASK))
+
+#define SADB_SATYPE_UNSPEC    0
+#define SADB_SATYPE_AH        2
+#define SADB_SATYPE_ESP       3
+#define SADB_SATYPE_RSVP      5
+#define SADB_SATYPE_OSPFV2    6
+#define SADB_SATYPE_RIPV2     7
+#define SADB_SATYPE_MIP       8
+#define SADB_X_SATYPE_IPIP    9
+#define SADB_X_SATYPE_COMP    10
+#define SADB_SATYPE_MAX       10
+
+#define SADB_SASTATE_LARVAL   0
+#define SADB_SASTATE_MATURE   1
+#define SADB_SASTATE_DYING    2
+#define SADB_SASTATE_DEAD     3
+#define SADB_SASTATE_MAX      3
+
+#define SADB_SAFLAGS_PFS		1
+#define SADB_X_SAFLAGS_REPLACEFLOW	2
+#define SADB_X_SAFLAGS_CLEARFLOW	4
+
+#define SADB_AALG_NONE        0
+#define SADB_AALG_MD5HMAC     2
+#define SADB_AALG_SHA1HMAC    3
+#define SADB_AALG_MAX         3
+
+#define SADB_EALG_NONE        0
+#define SADB_EALG_DESCBC      2
+#define SADB_EALG_3DESCBC     3
+#define SADB_EALG_NULL        11
+#define SADB_EALG_MAX         11
+
+#define SADB_X_CALG_NONE          0
+#define SADB_X_CALG_OUI           1
+#define SADB_X_CALG_DEFLATE       2
+#define SADB_X_CALG_LZS           3
+#define SADB_X_CALG_V42BIS        4
+#define SADB_X_CALG_MAX           4
+
+#define SADB_X_TALG_NONE          0
+#define SADB_X_TALG_IPv4_in_IPv4  1
+#define SADB_X_TALG_IPv6_in_IPv4  2
+#define SADB_X_TALG_IPv4_in_IPv6  3
+#define SADB_X_TALG_IPv6_in_IPv6  4
+#define SADB_X_TALG_MAX           4
+
+
+#define SADB_IDENTTYPE_RESERVED   0
+#define SADB_IDENTTYPE_PREFIX     1
+#define SADB_IDENTTYPE_FQDN       2
+#define SADB_IDENTTYPE_USERFQDN   3
+#define SADB_IDENTTYPE_MAX        3
+
+#define SADB_KEY_FLAGS_MAX     0
+#endif /* __PFKEY_V2_H */
+
+/*
+ * $Log$
+ * Revision 1.13  2000/10/10 20:10:20  rgb
+ * Added support for debug_ipcomp and debug_verbose to klipsdebug.
+ *
+ * Revision 1.12  2000/09/15 06:41:50  rgb
+ * Added V42BIS constant.
+ *
+ * Revision 1.11  2000/09/12 22:35:37  rgb
+ * Restructured to remove unused extensions from CLEARFLOW messages.
+ *
+ * Revision 1.10  2000/09/12 18:50:09  rgb
+ * Added IPIP tunnel types as algo support.
+ *
+ * Revision 1.9  2000/08/21 16:47:19  rgb
+ * Added SADB_X_CALG_* macros for IPCOMP.
+ *
+ * Revision 1.8  2000/08/09 20:43:34  rgb
+ * Fixed bitmask value for SADB_X_SAFLAGS_CLEAREROUTE.
+ *
+ * Revision 1.7  2000/01/21 06:28:37  rgb
+ * Added flow add/delete message type macros.
+ * Added flow address extension type macros.
+ * Tidied up spacing.
+ * Added klipsdebug switching capability.
+ *
+ * Revision 1.6  1999/11/27 11:56:08  rgb
+ * Add SADB_X_SATYPE_COMP for compression, eventually.
+ *
+ * Revision 1.5  1999/11/23 22:23:16  rgb
+ * This file has been moved in the distribution from klips/net/ipsec to
+ * lib.
+ *
+ * Revision 1.4  1999/04/29 15:23:29  rgb
+ * Add GRPSA support.
+ * Add support for a second SATYPE, SA and DST_ADDRESS.
+ * Add IPPROTO_IPIP support.
+ *
+ * Revision 1.3  1999/04/15 17:58:08  rgb
+ * Add RCSID labels.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/libfreeswan/portof.c linux/net/ipsec/libfreeswan/portof.c
--- linux-noipsec/net/ipsec/libfreeswan/portof.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/portof.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,96 @@
+/*
+ * low-level ip_address ugliness
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - portof - get the port field of an ip_address
+ */
+int				/* network order */
+portof(src)
+const ip_address *src;
+{
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		return src->u.v4.sin_port;
+		break;
+	case AF_INET6:
+		return src->u.v6.sin6_port;
+		break;
+	default:
+		return -1;	/* "can't happen" */
+		break;
+	}
+}
+
+/*
+ - setportof - set the port field of an ip_address
+ */
+void
+setportof(port, dst)
+int port;			/* network order */
+ip_address *dst;
+{
+	switch (dst->u.v4.sin_family) {
+	case AF_INET:
+		dst->u.v4.sin_port = port;
+		break;
+	case AF_INET6:
+		dst->u.v6.sin6_port = port;
+		break;
+	}
+}
+
+/*
+ - sockaddrof - get a pointer to the sockaddr hiding inside an ip_address
+ */
+struct sockaddr *
+sockaddrof(src)
+ip_address *src;
+{
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		return (struct sockaddr *)&src->u.v4;
+		break;
+	case AF_INET6:
+		return (struct sockaddr *)&src->u.v6;
+		break;
+	default:
+		return NULL;	/* "can't happen" */
+		break;
+	}
+}
+
+/*
+ - sockaddrlenof - get length of the sockaddr hiding inside an ip_address
+ */
+size_t				/* 0 for error */
+sockaddrlenof(src)
+const ip_address *src;
+{
+	switch (src->u.v4.sin_family) {
+	case AF_INET:
+		return sizeof(src->u.v4);
+		break;
+	case AF_INET6:
+		return sizeof(src->u.v6);
+		break;
+	default:
+		return 0;
+		break;
+	}
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/rangetoa.c linux/net/ipsec/libfreeswan/rangetoa.c
--- linux-noipsec/net/ipsec/libfreeswan/rangetoa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/rangetoa.c	Sun Apr 11 01:24:21 1999
@@ -0,0 +1,61 @@
+/*
+ * convert binary form of address range to ASCII
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - rangetoa - convert address range to ASCII
+ */
+size_t				/* space needed for full conversion */
+rangetoa(addrs, format, dst, dstlen)
+struct in_addr addrs[2];
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t len;
+	size_t rest;
+	int n;
+	char *p;
+
+	switch (format) {
+	case 0:
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	len = addrtoa(addrs[0], 0, dst, dstlen);
+	if (len < dstlen)
+		for (p = dst + len - 1, n = 3; len < dstlen && n > 0;
+								p++, len++, n--)
+			*p = '.';
+	else
+		p = NULL;
+	if (len < dstlen)
+		rest = dstlen - len;
+	else {
+		if (dstlen > 0)
+			*(dst + dstlen - 1) = '\0';
+		rest = 0;
+	}
+
+	len += addrtoa(addrs[1], 0, p, rest);
+
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/rangetosubnet.c linux/net/ipsec/libfreeswan/rangetosubnet.c
--- linux-noipsec/net/ipsec/libfreeswan/rangetosubnet.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/rangetosubnet.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,228 @@
+/*
+ * express an address range as a subnet (if possible)
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - rangetosubnet - turn an address range into a subnet, if possible
+ *
+ * A range which is a valid subnet will have a network part which is the
+ * same in the from value and the to value, followed by a host part which
+ * is all 0 in the from value and all 1 in the to value.
+ */
+err_t
+rangetosubnet(from, to, dst)
+const ip_address *from;
+const ip_address *to;
+ip_subnet *dst;
+{
+	unsigned const char *fp;
+	unsigned const char *tp;
+	unsigned fb;
+	unsigned tb;
+	unsigned const char *f;
+	unsigned const char *t;
+	size_t n;
+	size_t n2;
+	int i;
+	int nnet;
+	unsigned m;
+
+	if (addrtypeof(from) != addrtypeof(to))
+		return "mismatched address types";
+	n = addrbytesptr(from, &fp);
+	if (n == 0)
+		return "unknown address type";
+	n2 = addrbytesptr(to, &tp);
+	if (n != n2)
+		return "internal size mismatch in rangetosubnet";
+
+	f = fp;
+	t = tp;
+	nnet = 0;
+	for (i = n; i > 0 && *f == *t; i--, f++, t++)
+		nnet += 8;
+	if (i > 0 && !(*f == 0x00 && *t == 0xff)) {	/* mid-byte bdry. */
+		fb = *f++;
+		tb = *t++;
+		i--;
+		m = 0x80;
+		while ((fb&m) == (tb&m)) {
+			fb &= ~m;
+			tb |= m;
+			m >>= 1;
+			nnet++;
+		}
+		if (fb != 0x00 || tb != 0xff)
+			return "not a valid subnet";
+	}
+	for (; i > 0 && *f == 0x00 && *t == 0xff; i--, f++, t++)
+		continue;
+
+	if (i != 0)
+		return "invalid subnet";
+
+	return initsubnet(from, nnet, 'x', dst);
+}
+
+
+
+#ifdef RANGETOSUBNET_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	ip_address start;
+	ip_address stop;
+	ip_subnet sub;
+	char buf[100];
+	const char *oops;
+	size_t n;
+	int af;
+	int i;
+
+	if (argc == 2 && strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	if (argc < 3) {
+		fprintf(stderr, "Usage: %s [-6] start stop\n", argv[0]);
+		fprintf(stderr, "   or: %s -r\n", argv[0]);
+		exit(2);
+	}
+
+	af = AF_INET;
+	i = 1;
+	if (strcmp(argv[i], "-6") == 0) {
+		af = AF_INET6;
+		i++;
+	}
+
+	oops = ttoaddr(argv[i], 0, af, &start);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: start conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	oops = ttoaddr(argv[i+1], 0, af, &stop);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: stop conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	oops = rangetosubnet(&start, &stop, &sub);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: rangetosubnet failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	n = subnettot(&sub, 0, buf, sizeof(buf));
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conversion", argv[0]);
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	int family;
+	char *start;
+	char *stop;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	4, "1.2.3.0",		"1.2.3.255",		"1.2.3.0/24",
+	4, "1.2.3.0",		"1.2.3.7",		"1.2.3.0/29",
+	4, "1.2.3.240",		"1.2.3.255",		"1.2.3.240/28",
+	4, "0.0.0.0",		"255.255.255.255",	"0.0.0.0/0",
+	4, "1.2.3.4",		"1.2.3.4",		"1.2.3.4/32",
+	4, "1.2.3.0",		"1.2.3.254",		NULL,
+	4, "1.2.3.0",		"1.2.3.126",		NULL,
+	4, "1.2.3.0",		"1.2.3.125",		NULL,
+	4, "1.2.0.0",		"1.2.255.255",		"1.2.0.0/16",
+	4, "1.2.0.0",		"1.2.0.255",		"1.2.0.0/24",
+	4, "1.2.255.0",		"1.2.255.255",		"1.2.255.0/24",
+	4, "1.2.255.0",		"1.2.254.255",		NULL,
+	4, "1.2.255.1",		"1.2.255.255",		NULL,
+	4, "1.2.0.1",		"1.2.255.255",		NULL,
+	6, "1:2:3:4:5:6:7:0",	"1:2:3:4:5:6:7:ffff",	"1:2:3:4:5:6:7:0/112",
+	6, "1:2:3:4:5:6:7:0",	"1:2:3:4:5:6:7:fff",	"1:2:3:4:5:6:7:0/116",
+	6, "1:2:3:4:5:6:7:f0",	"1:2:3:4:5:6:7:ff",	"1:2:3:4:5:6:7:f0/124",
+	4, NULL,		NULL,			NULL,
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	ip_address start;
+	ip_address stop;
+	ip_subnet sub;
+	char buf[100];
+	const char *oops;
+	size_t n;
+	int af;
+
+	for (r = rtab; r->start != NULL; r++) {
+		af = (r->family == 4) ? AF_INET : AF_INET6;
+		oops = ttoaddr(r->start, 0, af, &start);
+		if (oops != NULL) {
+			printf("surprise failure converting `%s'\n", r->start);
+			exit(1);
+		}
+		oops = ttoaddr(r->stop, 0, af, &stop);
+		if (oops != NULL) {
+			printf("surprise failure converting `%s'\n", r->stop);
+			exit(1);
+		}
+		oops = rangetosubnet(&start, &stop, &sub);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s'-`%s' rangetosubnet failed: %s\n",
+						r->start, r->stop, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s'-`%s' rangetosubnet succeeded unexpectedly\n",
+							r->start, r->stop);
+			status = 1;
+		} else {
+			n = subnettot(&sub, 0, buf, sizeof(buf));
+			if (n > sizeof(buf)) {
+				printf("`%s'-`%s' subnettot failed:  need %ld\n",
+						r->start, r->stop, (long)n);
+				status = 1;
+			} else if (strcmp(r->output, buf) != 0) {
+				printf("`%s'-`%s' gave `%s', expected `%s'\n",
+					r->start, r->stop, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* RANGETOSUBNET_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/sameaddr.c linux/net/ipsec/libfreeswan/sameaddr.c
--- linux-noipsec/net/ipsec/libfreeswan/sameaddr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/sameaddr.c	Wed Nov 29 17:34:01 2000
@@ -0,0 +1,190 @@
+/*
+ * comparisons
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static int samenbits(const ip_address *a, const ip_address *b, int n);
+
+/*
+ - addrcmp - compare two addresses
+ * Caution, the order of the tests is subtle:  doing type test before
+ * size test can yield cases where a<b, b<c, but a>c.
+ */
+int				/* like memcmp */
+addrcmp(a, b)
+const ip_address *a;
+const ip_address *b;
+{
+	int at = addrtypeof(a);
+	int bt = addrtypeof(b);
+	const unsigned char *ap;
+	const unsigned char *bp;
+	size_t as = addrbytesptr(a, &ap);
+	size_t bs = addrbytesptr(b, &bp);
+	size_t n = (as < bs) ? as : bs;		/* min(as, bs) */
+	int c = memcmp(ap, bp, n);
+
+	if (c != 0)		/* bytes differ */
+		return (c < 0) ? -1 : 1;
+	if (as != bs)		/* comparison incomplete:  lexical order */
+		return (as < bs) ? -1 : 1;
+	if (at != bt)		/* bytes same but not same type:  break tie */
+		return (at < bt) ? -1 : 1;
+	return 0;
+}
+
+/*
+ - sameaddr - are two addresses the same?
+ */
+int
+sameaddr(a, b)
+const ip_address *a;
+const ip_address *b;
+{
+	return (addrcmp(a, b) == 0) ? 1 : 0;
+}
+
+/*
+ - samesubnet - are two subnets the same?
+ */
+int
+samesubnet(a, b)
+const ip_subnet *a;
+const ip_subnet *b;
+{
+	if (!sameaddr(&a->addr, &b->addr))	/* also does type check */
+		return 0;
+	if (a->maskbits != b->maskbits)
+		return 0;
+	return 1;
+}
+
+/*
+ - subnetishost - is a subnet in fact a single host?
+ */
+int
+subnetishost(a)
+const ip_subnet *a;
+{
+	return (a->maskbits == addrlenof(&a->addr)*8) ? 1 : 0;
+}
+
+/*
+ - samesaid - are two SA IDs the same?
+ */
+int
+samesaid(a, b)
+const ip_said *a;
+const ip_said *b;
+{
+	if (a->spi != b->spi)	/* test first, most likely to be different */
+		return 0;
+	if (!sameaddr(&a->dst, &b->dst))
+		return 0;
+	if (a->proto != b->proto)
+		return 0;
+	return 1;
+}
+
+/*
+ - sameaddrtype - do two addresses have the same type?
+ */
+int
+sameaddrtype(a, b)
+const ip_address *a;
+const ip_address *b;
+{
+	return (addrtypeof(a) == addrtypeof(b)) ? 1 : 0;
+}
+
+/*
+ - samesubnettype - do two subnets have the same type?
+ */
+int
+samesubnettype(a, b)
+const ip_subnet *a;
+const ip_subnet *b;
+{
+	return (subnettypeof(a) == subnettypeof(b)) ? 1 : 0;
+}
+
+/*
+ - addrinsubnet - is this address in this subnet?
+ */
+int
+addrinsubnet(a, s)
+const ip_address *a;
+const ip_subnet *s;
+{
+	if (addrtypeof(a) != subnettypeof(s))
+		return 0;
+	if (!samenbits(a, &s->addr, s->maskbits))
+		return 0;
+	return 1;
+}
+
+/*
+ - subnetinsubnet - is one subnet within another?
+ */
+int
+subnetinsubnet(a, b)
+const ip_subnet *a;
+const ip_subnet *b;
+{
+	if (subnettypeof(a) != subnettypeof(b))
+		return 0;
+	if (a->maskbits < b->maskbits)	/* a is bigger than b */
+		return 0;
+	if (!samenbits(&a->addr, &b->addr, b->maskbits))
+		return 0;
+	return 1;
+}
+
+/*
+ - samenbits - do two addresses have the same first n bits?
+ */
+static int
+samenbits(a, b, nbits)
+const ip_address *a;
+const ip_address *b;
+int nbits;
+{
+	const unsigned char *ap;
+	const unsigned char *bp;
+	size_t n;
+	int m;
+
+	if (addrtypeof(a) != addrtypeof(b))
+		return 0;	/* arbitrary */
+	n = addrbytesptr(a, &ap);
+	if (n == 0)
+		return 0;	/* arbitrary */
+	(void) addrbytesptr(b, &bp);
+	if (nbits > n*8)
+		return 0;	/* "can't happen" */
+
+	for (; nbits >= 8 && *ap == *bp; nbits -= 8, ap++, bp++)
+		continue;
+	if (nbits >= 8)
+		return 0;
+	if (nbits > 0) {	/* partial byte */
+		m = ~(0xff >> nbits);
+		if ((*ap & m) != (*bp & m))
+			return 0;
+	}
+	return 1;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/satoa.c linux/net/ipsec/libfreeswan/satoa.c
--- linux-noipsec/net/ipsec/libfreeswan/satoa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/satoa.c	Sat Sep 16 08:43:47 2000
@@ -0,0 +1,83 @@
+/*
+ * convert from binary form of SA ID to ASCII
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static struct typename {
+	char type;
+	char *name;
+} typenames[] = {
+	{ SA_AH,	"ah" },
+	{ SA_ESP,	"esp" },
+	{ SA_IPIP,	"tun" },
+	{ SA_COMP,	"comp" },
+	{ 0,		NULL }
+};
+
+/*
+ - satoa - convert SA to ASCII "ah507@1.2.3.4"
+ */
+size_t				/* space needed for full conversion */
+satoa(sa, format, dst, dstlen)
+struct sa_id sa;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t len;
+	int base;
+	struct typename *tn;
+	char buf[30+ADDRTOA_BUF];
+
+	switch (format) {
+	case 0:
+		base = 16;	/* temporarily at least */
+		break;
+	case 'd':
+		base = 10;
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	for (tn = typenames; tn->name != NULL; tn++)
+		if (sa.proto == tn->type)
+			break;
+	if (tn->name == NULL)
+		return 0;
+
+	if (strcmp(tn->name, PASSTHROUGHTYPE) == 0 &&
+					sa.spi == PASSTHROUGHSPI &&
+					sa.dst.s_addr == PASSTHROUGHDST) {
+		strcpy(buf, PASSTHROUGHNAME);
+		len = strlen(buf);
+	} else {
+		strcpy(buf, tn->name);
+		len = strlen(buf);
+		len += ultoa(ntohl(sa.spi), base, buf+len, sizeof(buf)-len);
+		*(buf+len-1) = '@';
+		len += addrtoa(sa.dst, 0, buf+len, sizeof(buf)-len);
+	}
+
+	if (dst != NULL) {
+		if (len > dstlen)
+			*(buf+dstlen-1) = '\0';
+		strcpy(dst, buf);
+	}
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/satot.c linux/net/ipsec/libfreeswan/satot.c
--- linux-noipsec/net/ipsec/libfreeswan/satot.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/satot.c	Fri Sep 15 19:02:52 2000
@@ -0,0 +1,102 @@
+/*
+ * convert from binary form of SA ID to text
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static struct typename {
+	char type;
+	char *name;
+} typenames[] = {
+	{ SA_AH,	"ah" },
+	{ SA_ESP,	"esp" },
+	{ SA_IPIP,	"tun" },
+	{ SA_COMP,	"comp" },
+	{ 0,		NULL }
+};
+
+/*
+ - satot - convert SA to text "ah507@1.2.3.4"
+ */
+size_t				/* space needed for full conversion */
+satot(sa, format, dst, dstlen)
+const ip_said *sa;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t len;
+	int base;
+	int showversion;	/* use delimiter to show IP version? */
+	struct typename *tn;
+	char buf[3+1+ULTOT_BUF+ADDRTOT_BUF];
+
+	switch (format) {
+	case 0:
+		base = 16;
+		showversion = 1;
+		break;
+	case 'f':
+		base = 17;
+		showversion = 1;
+		break;
+	case 'x':
+		base = 'x';
+		showversion = 0;
+		break;
+	case 'd':
+		base = 10;
+		showversion = 0;
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	for (tn = typenames; tn->name != NULL; tn++)
+		if (sa->proto == tn->type)
+			break;
+	if (tn->name == NULL)
+		return 0;
+
+	if (strcmp(tn->name, PASSTHROUGHTYPE) == 0 &&
+					sa->spi == PASSTHROUGHSPI &&
+					isunspecaddr(&sa->dst)) {
+		strcpy(buf, (addrtypeof(&sa->dst) == AF_INET) ?
+							PASSTHROUGH4NAME :
+							PASSTHROUGH6NAME);
+		len = strlen(buf);
+	} else {
+		strcpy(buf, tn->name);
+		len = strlen(buf);
+		if (showversion) {
+			*(buf+len) = (addrtypeof(&sa->dst) == AF_INET) ? '.' :
+									':';
+			len++;
+			*(buf+len) = '\0';
+		}
+		len += ultot(ntohl(sa->spi), base, buf+len, sizeof(buf)-len);
+		*(buf+len-1) = '@';
+		len += addrtot(&sa->dst, 0, buf+len, sizeof(buf)-len);
+	}
+
+	if (dst != NULL) {
+		if (len > dstlen)
+			*(buf+dstlen-1) = '\0';
+		strcpy(dst, buf);
+	}
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/subnetof.c linux/net/ipsec/libfreeswan/subnetof.c
--- linux-noipsec/net/ipsec/libfreeswan/subnetof.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/subnetof.c	Sun Apr 11 01:24:22 1999
@@ -0,0 +1,60 @@
+/*
+ * minor network-address manipulation utilities
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - subnetof - given address and mask, return subnet part
+ */
+struct in_addr
+subnetof(addr, mask)
+struct in_addr addr;
+struct in_addr mask;
+{
+	struct in_addr result;
+
+	result.s_addr = addr.s_addr & mask.s_addr;
+	return result;
+}
+
+/*
+ - hostof - given address and mask, return host part
+ */
+struct in_addr
+hostof(addr, mask)
+struct in_addr addr;
+struct in_addr mask;
+{
+	struct in_addr result;
+
+	result.s_addr = addr.s_addr & ~mask.s_addr;
+	return result;
+}
+
+/*
+ - broadcastof - given (network) address and mask, return broadcast address
+ */
+struct in_addr
+broadcastof(addr, mask)
+struct in_addr addr;
+struct in_addr mask;
+{
+	struct in_addr result;
+
+	result.s_addr = addr.s_addr | ~mask.s_addr;
+	return result;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/subnettoa.c linux/net/ipsec/libfreeswan/subnettoa.c
--- linux-noipsec/net/ipsec/libfreeswan/subnettoa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/subnettoa.c	Sun Apr 11 01:24:22 1999
@@ -0,0 +1,62 @@
+/*
+ * convert binary form of subnet description to ASCII
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - subnettoa - convert address and mask to ASCII "addr/mask"
+ * Output expresses the mask as a bit count if possible, else dotted decimal.
+ */
+size_t				/* space needed for full conversion */
+subnettoa(addr, mask, format, dst, dstlen)
+struct in_addr addr;
+struct in_addr mask;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t len;
+	size_t rest;
+	int n;
+	char *p;
+
+	switch (format) {
+	case 0:
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	len = addrtoa(addr, 0, dst, dstlen);
+	if (len < dstlen) {
+		dst[len - 1] = '/';
+		p = dst + len;
+		rest = dstlen - len;
+	} else {
+		p = NULL;
+		rest = 0;
+	}
+
+	n = masktobits(mask);
+	if (n >= 0)
+		len += ultoa((unsigned long)n, 10, p, rest);
+	else
+		len += addrtoa(mask, 0, p, rest);
+
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/subnettot.c linux/net/ipsec/libfreeswan/subnettot.c
--- linux-noipsec/net/ipsec/libfreeswan/subnettot.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/subnettot.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,56 @@
+/*
+ * convert binary form of subnet description to text
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - subnettot - convert subnet to text "addr/bitcount"
+ */
+size_t				/* space needed for full conversion */
+subnettot(sub, format, dst, dstlen)
+const ip_subnet *sub;
+int format;			/* character */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	size_t len;
+	size_t rest;
+	char *p;
+
+	switch (format) {
+	case 0:
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	len = addrtot(&sub->addr, format, dst, dstlen);
+	if (len < dstlen) {
+		dst[len - 1] = '/';
+		p = dst + len;
+		rest = dstlen - len;
+	} else {
+		p = NULL;
+		rest = 0;
+	}
+
+
+	len += ultoa((unsigned long)sub->maskbits, 10, p, rest);
+
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/subnettypeof.c linux/net/ipsec/libfreeswan/subnettypeof.c
--- linux-noipsec/net/ipsec/libfreeswan/subnettypeof.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/subnettypeof.c	Fri Sep  8 20:03:45 2000
@@ -0,0 +1,109 @@
+/*
+ * extract parts of an ip_subnet, and related
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - subnettypeof - get the address type of an ip_subnet
+ */
+int
+subnettypeof(src)
+const ip_subnet *src;
+{
+	return src->addr.u.v4.sin_family;
+}
+
+/*
+ - networkof - get the network address of a subnet
+ */
+void
+networkof(src, dst)
+const ip_subnet *src;
+ip_address *dst;
+{
+	*dst = src->addr;
+}
+
+/*
+ - maskof - get the mask of a subnet, as an address
+ */
+void
+maskof(src, dst)
+const ip_subnet *src;
+ip_address *dst;
+{
+	int b;
+	unsigned char buf[16];
+	size_t n = addrlenof(&src->addr);
+	unsigned char *p;
+
+	if (src->maskbits > n*8 || n > sizeof(buf))
+		return;		/* "can't happen" */
+
+	p = buf;
+	for (b = src->maskbits; b >= 8; b -= 8)
+		*p++ = 0xff;
+	if (b != 0)
+		*p++ = (0xff << (8 - b)) & 0xff;
+	while (p - buf < n)
+		*p++ = 0;
+
+	(void) initaddr(buf, n, addrtypeof(&src->addr), dst);
+}
+
+/*
+ - masktocount - convert a mask, expressed as an address, to a bit count
+ */
+int				/* -1 if not valid mask */
+masktocount(src)
+const ip_address *src;
+{
+	int b;
+	unsigned const char *bp;
+	size_t n;
+	unsigned const char *p;
+	unsigned const char *stop;
+
+	n = addrbytesptr(src, &bp);
+	if (n == 0)
+		return -1;
+
+	p = bp;
+	stop = bp + n;
+
+	n = 0;
+	while (p < stop && *p == 0xff) {
+		p++;
+		n += 8;
+	}
+	if (p < stop && *p != 0) {	/* boundary in mid-byte */
+		b = *p++;
+		while (b&0x80) {
+			b <<= 1;
+			n++;
+		}
+		if ((b&0xff) != 0)
+			return -1;	/* bits not contiguous */
+	}
+	while (p < stop && *p == 0)
+		p++;
+
+	if (p != stop)
+		return -1;
+
+	return n;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/ttoaddr.c linux/net/ipsec/libfreeswan/ttoaddr.c
--- linux-noipsec/net/ipsec/libfreeswan/ttoaddr.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ttoaddr.c	Mon Oct  2 23:57:20 2000
@@ -0,0 +1,397 @@
+/*
+ * conversion from text forms of addresses to internal ones
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ * Legal ASCII characters in a domain name.  Underscore technically is not,
+ * but is a common misunderstanding.  Non-ASCII characters are simply
+ * exempted from checking at the moment, to allow for UTF-8 encoded stuff;
+ * the purpose of this check is merely to catch blatant errors.
+ */
+static const char namechars[] = "abcdefghijklmnopqrstuvwxyz0123456789"
+				"ABCDEFGHIJKLMNOPQRSTUVWXYZ-_.";
+#define	ISASCII(c)	(((c) & 0x80) == 0)
+
+static err_t tryname(const char *, size_t, int, int, ip_address *);
+static err_t tryhex(const char *, size_t, int, ip_address *);
+static err_t trydotted(const char *, size_t, ip_address *);
+static err_t getbyte(const char **, const char *, int *);
+static err_t colon(const char *, size_t, ip_address *);
+static err_t getpiece(const char **, const char *, unsigned *);
+
+/*
+ - ttoaddr - convert text name or dotted-decimal address to binary address
+ */
+err_t				/* NULL for success, else string literal */
+ttoaddr(src, srclen, af, dst)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+int af;				/* address family */
+ip_address *dst;
+{
+	err_t oops;
+#	define	HEXLEN	10	/* strlen("0x11223344") */
+	int nultermd;
+
+	if (srclen == 0) {
+		srclen = strlen(src);
+		if (srclen == 0)
+			return "empty string";
+		nultermd = 1;
+	} else
+		nultermd = 0;	/* at least, not *known* to be terminated */
+
+	if (af == AF_INET && srclen == HEXLEN && *src == '0') {
+		if (*(src+1) == 'x' || *(src+1) == 'X')
+			return tryhex(src+2, srclen-2, 'x', dst);
+		if (*(src+1) == 'h' || *(src+1) == 'H')
+			return tryhex(src+2, srclen-2, 'h', dst);
+	}
+
+	if (memchr(src, ':', srclen) != NULL) {
+		if (af != AF_INET6)
+			return "non-ipv6 address may not contain `:'";
+		return colon(src, srclen, dst);
+	}
+
+	if (af == AF_INET) {
+		oops = trydotted(src, srclen, dst);
+		if (oops == NULL)
+			return NULL;		/* it worked */
+		if (*oops != '?')
+			return oops;		/* probably meant as d-d */
+	}
+
+	return tryname(src, srclen, nultermd, af, dst);
+}
+
+/*
+ - tnatoaddr - convert text numeric address (only) to binary address
+ */
+err_t				/* NULL for success, else string literal */
+tnatoaddr(src, srclen, af, dst)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+int af;				/* address family */
+ip_address *dst;
+{
+	err_t oops;
+
+	if (srclen == 0) {
+		srclen = strlen(src);
+		if (srclen == 0)
+			return "empty string";
+	}
+
+	switch (af) {
+	case AF_INET6:
+		return colon(src, srclen, dst);
+		break;
+	case AF_INET:
+		oops = trydotted(src, srclen, dst);
+		if (oops == NULL)
+			return NULL;		/* it worked */
+		if (*oops != '?')
+			return oops;		/* probably meant as d-d */
+		return "does not appear to be numeric address";
+		break;
+	default:
+		return "unknown address family in tnatoaddr";
+		break;
+	}
+}
+
+/*
+ - tryname - try it as a name
+ * Slightly complicated by lack of reliable NUL termination in source.
+ */
+static err_t
+tryname(src, srclen, nultermd, af, dst)
+const char *src;
+size_t srclen;
+int nultermd;			/* is it known to be NUL-terminated? */
+int af;
+ip_address *dst;
+{
+	struct hostent *h;
+	struct netent *ne = NULL;
+	char namebuf[100];	/* enough for most DNS names */
+	const char *cp;
+	char *p = namebuf;
+	size_t n;
+
+	for (cp = src, n = srclen; n > 0; cp++, n--)
+		if (ISASCII(*cp) && strchr(namechars, *cp) == NULL)
+			return "illegal (non-DNS-name) character in name";
+
+	if (nultermd)
+		cp = src;
+	else {
+		if (srclen+1 > sizeof(namebuf)) {
+			p = (char *) MALLOC(srclen+1);
+			if (p == NULL)
+				return "unable to get temporary space for name";
+		}
+		p[0] = '\0';	/* strncpy semantics are wrong */
+		strncat(p, src, srclen);
+		cp = (const char *)p;
+	}
+
+	h = gethostbyname2(cp, af);
+	if (h == NULL && af == AF_INET)
+		ne = getnetbyname(cp);
+	if (p != namebuf)
+		FREE(p);
+	if (h == NULL && ne == NULL)
+		return "does not look numeric and name lookup failed";
+
+	if (h != NULL) {
+		if (h->h_addrtype != af)
+			return "address-type mismatch from gethostbyname2!!!";
+		return initaddr((unsigned char *)h->h_addr, h->h_length, af, dst);
+	} else {
+		if (ne->n_addrtype != af)
+			return "address-type mismatch from getnetbyname!!!";
+		ne->n_net = htonl(ne->n_net);
+		return initaddr((unsigned char *)&ne->n_net, sizeof(ne->n_net),
+								af, dst);
+	}
+}
+
+/*
+ - tryhex - try conversion as an eight-digit hex number (AF_INET only)
+ */
+static err_t
+tryhex(src, srclen, flavor, dst)
+const char *src;
+size_t srclen;			/* should be 8 */
+int flavor;			/* 'x' for network order, 'h' for host order */
+ip_address *dst;
+{
+	err_t oops;
+	unsigned long ul;
+	union {
+		uint32_t addr;
+		unsigned char buf[4];
+	} u;
+
+	if (srclen != 8)
+		return "internal error, tryhex called with bad length";
+
+	oops = ttoul(src, srclen, 16, &ul);
+	if (oops != NULL)
+		return oops;
+
+	u.addr = (flavor == 'h') ? ul : htonl(ul);
+	return initaddr(u.buf, sizeof(u.buf), AF_INET, dst);
+}
+
+/*
+ - trydotted - try conversion as dotted decimal (AF_INET only)
+ *
+ * If the first char of a complaint is '?', that means "didn't look like
+ * dotted decimal at all".
+ */
+static err_t
+trydotted(src, srclen, dst)
+const char *src;
+size_t srclen;
+ip_address *dst;
+{
+	const char *stop = src + srclen;	/* just past end */
+	int byte;
+	err_t oops;
+#	define	NBYTES	4
+	unsigned char buf[NBYTES];
+	int i;
+
+	memset(buf, 0, sizeof(buf));
+	for (i = 0; i < NBYTES && src < stop; i++) {
+		oops = getbyte(&src, stop, &byte);
+		if (oops != NULL) {
+			if (*oops != '?')
+				return oops;	/* bad number */
+			if (i > 1)
+				return oops+1;	/* failed number */
+			return oops;		/* with leading '?' */
+		}
+		buf[i] = byte;
+		if (i < 3 && src < stop && *src++ != '.') {
+			if (i == 0)
+				return "?syntax error in dotted-decimal address";
+			else
+				return "syntax error in dotted-decimal address";
+		}
+	}
+	if (src != stop)
+		return "extra garbage on end of dotted-decimal address";
+
+	return initaddr(buf, sizeof(buf), AF_INET, dst);
+}
+
+/*
+ - getbyte - try to scan a byte in dotted decimal
+ * A subtlety here is that all this arithmetic on ASCII digits really is
+ * highly portable -- ANSI C guarantees that digits 0-9 are contiguous.
+ * It's easier to just do it ourselves than set up for a call to ttoul().
+ *
+ * If the first char of a complaint is '?', that means "didn't look like a
+ * number at all".
+ */
+err_t
+getbyte(srcp, stop, retp)
+const char **srcp;		/* *srcp is updated */
+const char *stop;		/* first untouchable char */
+int *retp;			/* return-value pointer */
+{
+	char c;
+	const char *p;
+	int no;
+
+	if (*srcp >= stop)
+		return "?empty number in dotted-decimal address";
+
+	no = 0;
+	p = *srcp;
+	while (p < stop && no <= 255 && (c = *p) >= '0' && c <= '9') {
+		no = no*10 + (c - '0');
+		p++;
+	}
+	if (p == *srcp)
+		return "?non-numeric component in dotted-decimal address";
+	*srcp = p;
+	if (no > 255)
+		return "byte overflow in dotted-decimal address";
+	*retp = no;
+	return NULL;
+}
+
+/*
+ - colon - convert IPv6 "numeric" address
+ */
+static err_t
+colon(src, srclen, dst)
+const char *src;
+size_t srclen;			/* known to be >0 */
+ip_address *dst;
+{
+	const char *stop = src + srclen;	/* just past end */
+	unsigned piece;
+	int gapat;		/* where was empty piece seen */
+	err_t oops;
+#	define	NPIECES	8
+	unsigned char buf[NPIECES*2];	/* short may have wrong byte order */
+	int i;
+	int j;
+#	define	IT	"IPv6 numeric address"
+	int naftergap;
+
+	/* leading or trailing :: becomes single empty field */
+	if (*src == ':') {		/* legal only if leading :: */
+		if (srclen == 1 || *(src+1) != ':')
+			return "illegal leading `:' in " IT;
+		if (srclen == 2) {
+			unspecaddr(AF_INET6, dst);
+			return NULL;
+		}
+		src++;		/* past first but not second */
+		srclen--;
+	}
+	if (*(stop-1) == ':') {		/* legal only if trailing :: */
+		if (srclen == 1 || *(stop-2) != ':')
+			return "illegal trailing `:' in " IT;
+		srclen--;		/* leave one */
+	}
+
+	gapat = -1;
+	for (i = 0; i < NPIECES && src < stop; i++) {
+		oops = getpiece(&src, stop, &piece);
+		if (oops != NULL && *oops == ':') {	/* empty field */
+			if (gapat >= 0)
+				return "more than one :: in " IT;
+			gapat = i;
+		} else if (oops != NULL)
+			return oops;
+		buf[2*i] = piece >> 8;
+		buf[2*i + 1] = piece & 0xff;
+		if (i < NPIECES-1) {	/* there should be more input */
+			if (src == stop && gapat < 0)
+				return IT " ends prematurely";
+			if (src != stop && *src++ != ':')
+				return "syntax error in " IT;
+		}
+	}
+	if (src != stop)
+		return "extra garbage on end of " IT;
+
+	if (gapat < 0 && i < NPIECES)	/* should have been caught earlier */
+		return "incomplete " IT " (internal error)";
+	if (gapat >= 0 && i == NPIECES)
+		return "non-abbreviating empty field in " IT;
+	if (gapat >= 0) {
+		naftergap = i - (gapat + 1);
+		for (i--, j = NPIECES-1; naftergap > 0; i--, j--, naftergap--) {
+			buf[2*j] = buf[2*i];
+			buf[2*j + 1] = buf[2*i + 1];
+		}
+		for (; j >= gapat; j--)
+			buf[2*j] = buf[2*j + 1] = 0;
+	}
+
+	return initaddr(buf, sizeof(buf), AF_INET6, dst);
+}
+
+/*
+ - getpiece - try to scan one 16-bit piece of an IPv6 address
+ */
+err_t				/* ":" means "empty field seen" */
+getpiece(srcp, stop, retp)
+const char **srcp;		/* *srcp is updated */
+const char *stop;		/* first untouchable char */
+unsigned *retp;			/* return-value pointer */
+{
+	const char *p;
+#	define	NDIG	4
+	int d;
+	unsigned long ret;
+	err_t oops;
+
+	if (*srcp >= stop || **srcp == ':') {	/* empty field */
+		*retp = 0;
+		return ":";
+	}
+
+	p = *srcp;
+	d = 0;
+	while (p < stop && d < NDIG && isxdigit(*p)) {
+		p++;
+		d++;
+	}
+	if (d == 0)
+		return "non-hex field in IPv6 numeric address";
+	if (p < stop && d == NDIG && isxdigit(*p))
+		return "field in IPv6 numeric address longer than 4 hex digits";
+
+	oops = ttoul(*srcp, d, 16, &ret);
+	if (oops != NULL)	/* shouldn't happen, really... */
+		return oops;
+
+	*srcp = p;
+	*retp = ret;
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/ttodata.c linux/net/ipsec/libfreeswan/ttodata.c
--- linux-noipsec/net/ipsec/libfreeswan/ttodata.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ttodata.c	Fri Aug 18 17:09:07 2000
@@ -0,0 +1,576 @@
+/*
+ * convert from text form of arbitrary data (e.g., keys) to binary
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/* converters */
+static int unhex(const char *, char *, size_t);
+static int unb64(const char *, char *, size_t);
+static int untext(const char *, char *, size_t);
+
+/* internal error codes for converters */
+#define	BADCHAR	(-1)		/* invalid character */
+#define	SHORT	(-2)		/* string ended prematurely */
+#define	BADPAD	(-3)		/* bad base64 padding */
+
+/*
+ - ttodata - convert text to data
+ * If some of this looks slightly odd, it's because it has changed
+ * repeatedly (from the original atodata()) without a major rewrite.
+ */
+const char *			/* NULL for success, else string literal */
+ttodata(src, srclen, base, dst, dstlen, lenp)
+const char *src;
+size_t srclen;			/* 0 means apply strlen() */
+int base;			/* 0 means figure it out */
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+size_t *lenp;			/* where to record length (NULL is nowhere) */
+{
+	size_t ingroup;		/* number of input bytes converted at once */
+	char buf[4];		/* output from conversion */
+	int nbytes;		/* size of output */
+	int (*decode)(const char *, char *, size_t);
+	char *stop;
+	int ndone;
+	int i;
+	int underscoreok;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (dstlen == 0)
+		dst = buf;	/* point it somewhere valid */
+	stop = dst + dstlen;
+
+	if (base == 0) {
+		if (srclen < 2)
+			return "input too short to be valid";
+		if (*src++ != '0')
+			return "input does not begin with format prefix";
+		switch (*src++) {
+		case 'x':
+		case 'X':
+			base = 16;
+			break;
+		case 's':
+		case 'S':
+			base = 64;
+			break;
+		case 't':
+		case 'T':
+			base = 256;
+			break;
+		default:
+			return "unknown format prefix";
+			break;
+		}
+		srclen -= 2;
+	}
+	switch (base) {
+	case 16:
+		ingroup = 2;
+		decode = unhex;
+		underscoreok = 1;
+		break;
+	case 64:
+		ingroup = 4;
+		decode = unb64;
+		underscoreok = 0;
+		break;
+	case 256:
+		ingroup = 1;
+		decode = untext;
+		underscoreok = 0;
+		break;
+	default:
+		return "unknown base";
+		break;
+	}
+
+	/* proceed */
+	ndone = 0;
+	while (srclen >= ingroup) {
+		nbytes = (*decode)(src, buf, sizeof(buf));
+		switch (nbytes) {
+		case BADCHAR:
+			return "unknown character in input";
+			break;
+		case SHORT:
+			return "input ends prematurely, perhaps truncated";
+			break;
+		case BADPAD:
+			return "non-zero padding in base64 input";
+			break;
+		}
+		if (nbytes <= 0)
+			return "unknown internal error";
+		for (i = 0; i < nbytes; i++) {
+			if (dst < stop)
+				*dst++ = buf[i];
+			ndone++;
+		}
+		src += ingroup;
+		srclen -= ingroup;
+		if (underscoreok && srclen > 1 && *src == '_') {
+			/* srclen > 1 means not last character */
+			src++;
+			srclen--;
+		}
+	}
+	if (srclen != 0)
+		return "input ends in mid-byte, perhaps truncated";
+	if (ndone == 0)
+		return "no data bytes specified by input";
+	if (lenp != NULL)
+		*lenp = ndone;
+	return NULL;
+}
+
+/*
+ - atodata - convert ASCII to data
+ * backward-compatibility interface
+ */
+size_t				/* 0 for failure, true length for success */
+atodata(src, srclen, dst, dstlen)
+const char *src;
+size_t srclen;
+char *dst;
+size_t dstlen;
+{
+	size_t len;
+	const char *err;
+
+	err = ttodata(src, srclen, 0, dst, dstlen, &len);
+	if (err != NULL)
+		return 0;
+	return len;
+}
+
+/*
+ - atobytes - convert ASCII to data bytes
+ * another backward-compatibility interface
+ */
+const char *
+atobytes(src, srclen, dst, dstlen, lenp)
+const char *src;
+size_t srclen;
+char *dst;
+size_t dstlen;
+size_t *lenp;
+{
+	return ttodata(src, srclen, 0, dst, dstlen, lenp);
+}
+
+/*
+ - unhex - convert two ASCII hex digits to byte
+ */
+static int		/* number of result bytes, or error code */
+unhex(src, dst, dstlen)
+const char *src;	/* known to be full length */
+char *dst;
+size_t dstlen;		/* not large enough is a failure */
+{
+	char *p;
+	unsigned byte;
+	static char hex[] = "0123456789abcdef";
+
+	if (dstlen < 1)
+		return SHORT;
+
+	p = strchr(hex, *src);
+	if (p == NULL)
+		p = strchr(hex, tolower(*src));
+	if (p == NULL)
+		return BADCHAR;
+	byte = (p - hex) << 4;
+	src++;
+
+	p = strchr(hex, *src);
+	if (p == NULL)
+		p = strchr(hex, tolower(*src));
+	if (p == NULL)
+		return BADCHAR;
+	byte |= (p - hex);
+
+	*dst = byte;
+	return 1;
+}
+
+/*
+ - unb64 - convert four ASCII base64 digits to three bytes
+ * Note that a base64 digit group is padded out with '=' if it represents
+ * less than three bytes:  one byte is dd==, two is ddd=, three is dddd.
+ */
+static int		/* number of result bytes, or error code */
+unb64(src, dst, dstlen)
+const char *src;	/* known to be full length */
+char *dst;
+size_t dstlen;
+{
+	char *p;
+	unsigned byte1;
+	unsigned byte2;
+	static char base64[] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+	if (dstlen < 3)
+		return SHORT;
+
+	p = strchr(base64, *src++);
+	if (p == NULL)
+		return BADCHAR;
+	byte1 = (p - base64) << 2;	/* first six bits */
+
+	p = strchr(base64, *src++);
+	if (p == NULL)
+		return BADCHAR;
+	byte2 = p - base64;		/* next six:  two plus four */
+	*dst++ = byte1 | (byte2 >> 4);
+	byte1 = (byte2 & 0xf) << 4;
+
+	p = strchr(base64, *src++);
+	if (p == NULL) {
+		if (*(src-1) == '=' && *src == '=') {
+			if (byte1 != 0)		/* bad padding */
+				return BADPAD;
+			return 1;
+		}
+		return BADCHAR;
+	}
+	byte2 = p - base64;		/* next six:  four plus two */
+	*dst++ = byte1 | (byte2 >> 2);
+	byte1 = (byte2 & 0x3) << 6;
+
+	p = strchr(base64, *src++);
+	if (p == NULL) {
+		if (*(src-1) == '=') {
+			if (byte1 != 0)		/* bad padding */
+				return BADPAD;
+			return 2;
+		}
+		return BADCHAR;
+	}
+	byte2 = p - base64;		/* last six */
+	*dst++ = byte1 | byte2;
+	return 3;
+}
+
+/*
+ - untext - convert one ASCII character to byte
+ */
+static int		/* number of result bytes, or error code */
+untext(src, dst, dstlen)
+const char *src;	/* known to be full length */
+char *dst;
+size_t dstlen;		/* not large enough is a failure */
+{
+	if (dstlen < 1)
+		return SHORT;
+
+	*dst = *src;
+	return 1;
+}
+
+
+
+#ifdef TTODATA_MAIN
+
+#include <stdio.h>
+
+void regress();
+void hexout();
+
+/*
+ - main - convert first argument to hex, or run regression
+ */
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	char buf[1024];
+	char buf2[1024];
+	size_t n;
+	size_t i;
+	char *p = buf;
+	char *p2 = buf2;
+	char *pgm = argv[0];
+	const char *oops;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s {0x<hex>|0s<base64>|-r}\n", pgm);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress(pgm);	/* should not return */
+		fprintf(stderr, "%s: regress() returned?!?\n", pgm);
+		exit(1);
+	}
+
+	oops = ttodata(argv[1], 0, 0, buf, sizeof(buf), &n);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: ttodata error `%s' in `%s'\n", pgm,
+								oops, argv[1]);
+		exit(1);
+	}
+
+	if (n > sizeof(buf)) {
+		p = (char *)malloc((size_t)n);
+		if (p == NULL) {
+			fprintf(stderr,
+				"%s: unable to malloc %d bytes for result\n",
+				pgm, n);
+			exit(1);
+		}
+		oops = ttodata(argv[1], 0, 0, p, n, &n);
+		if (oops != NULL) {
+			fprintf(stderr, "%s: error `%s' in ttodata retry?!?\n",
+								pgm, oops);
+			exit(1);
+		}
+	}
+
+	hexout(p, n, stdout);
+	printf("\n");
+
+	i = datatot(buf, n, 'h', buf2, sizeof(buf2));
+	if (i == 0) {
+		fprintf(stderr, "%s: datatot reports error in `%s'\n", pgm,
+								argv[1]);
+		exit(1);
+	}
+
+	if (i > sizeof(buf2)) {
+		p2 = (char *)malloc((size_t)i);
+		if (p == NULL) {
+			fprintf(stderr,
+				"%s: unable to malloc %d bytes for result\n",
+				pgm, i);
+			exit(1);
+		}
+		i = datatot(buf, n, 'h', p2, i);
+		if (i == 0) {
+			fprintf(stderr, "%s: error in datatoa retry?!?\n", pgm);
+			exit(1);
+		}
+	}
+
+	printf("%s\n", p2);
+
+	exit(0);
+}
+
+/*
+ - hexout - output an arbitrary-length string in hex
+ */
+void
+hexout(s, len, f)
+const char *s;
+size_t len;
+FILE *f;
+{
+	size_t i;
+
+	fprintf(f, "0x");
+	for (i = 0; i < len; i++)
+		fprintf(f, "%02x", (unsigned char)s[i]);
+}
+
+struct artab {
+	int base;
+	char *ascii;		/* NULL for end */
+	char *data;		/* NULL for error expected */
+} atodatatab[] = {
+	0, "",			NULL,
+	0, "0",			NULL,
+	0, "0x",		NULL,
+	0, "0xa",		NULL,
+	0, "0xab",		"\xab",
+	0, "0xabc",		NULL,
+	0, "0xabcd",		"\xab\xcd",
+	0, "0x0123456789",	"\x01\x23\x45\x67\x89",
+	0, "0x01x",		NULL,
+	0, "0xabcdef",		"\xab\xcd\xef",
+	0, "0xABCDEF",		"\xab\xcd\xef",
+	0, "0XaBc0eEd81f",	"\xab\xc0\xee\xd8\x1f",
+	0, "0XaBc0_eEd8",	"\xab\xc0\xee\xd8",
+	0, "0XaBc0_",		NULL,
+	0, "0X_aBc0",		NULL,
+	0, "0Xa_Bc0",		NULL,
+	16, "aBc0_eEd8",	"\xab\xc0\xee\xd8",
+	0, "0s",		NULL,
+	0, "0sA",		NULL,
+	0, "0sBA",		NULL,
+	0, "0sCBA",		NULL,
+	0, "0sDCBA",		"\x0c\x20\x40",
+	0, "0SDCBA",		"\x0c\x20\x40",
+	0, "0sDA==",		"\x0c",
+	0, "0sDC==",		NULL,
+	0, "0sDCA=",		"\x0c\x20",
+	0, "0sDCB=",		NULL,
+	0, "0sDCAZ",		"\x0c\x20\x19",
+	0, "0sDCAa",		"\x0c\x20\x1a",
+	0, "0sDCAz",		"\x0c\x20\x33",
+	0, "0sDCA0",		"\x0c\x20\x34",
+	0, "0sDCA9",		"\x0c\x20\x3d",
+	0, "0sDCA+",		"\x0c\x20\x3e",
+	0, "0sDCA/",		"\x0c\x20\x3f",
+	0, "0sAbraCadabra+",	"\x01\xba\xda\x09\xa7\x5a\x6e\xb6\xbe",
+	64, "AbraCadabra+",	"\x01\xba\xda\x09\xa7\x5a\x6e\xb6\xbe",
+	0, "0t",		NULL,
+	0, "0tabc_xyz",		"abc_xyz",
+	256, "abc_xyz",		"abc_xyz",
+	0, NULL,		NULL,
+};
+
+struct drtab {
+	char *data;	/* input; NULL for end */
+	char format;
+	int buflen;	/* -1 means big buffer */
+	int outlen;	/* -1 means strlen(ascii)+1 */
+	char *ascii;	/* NULL for error expected */
+} datatoatab[] = {
+	"",			'x',	-1,	-1,	NULL,
+	"",			'X',	-1,	-1,	NULL,
+	"",			'n',	-1,	-1,	NULL,
+	"0",			'x',	-1,	-1,	"0x30",
+	"0",			'x',	0,	5,	"---",
+	"0",			'x',	1,	5,	"",
+	"0",			'x',	2,	5,	"0",
+	"0",			'x',	3,	5,	"0x",
+	"0",			'x',	4,	5,	"0x3",
+	"0",			'x',	5,	5,	"0x30",
+	"0",			'x',	6,	5,	"0x30",
+	"\xab\xcd",		'x',	-1,	-1,	"0xabcd",
+	"\x01\x23\x45\x67\x89",	'x',	-1,	-1,	"0x0123456789",
+	"\xab\xcd\xef",		'x',	-1,	-1,	"0xabcdef",
+	"\xab\xc0\xee\xd8\x1f",	'x',	-1,	-1,	"0xabc0eed81f",
+	"\x01\x02",		'h',	-1,	-1,	"0x0102",
+	"\x01\x02\x03\x04\x05\x06",	'h',	-1, -1,	"0x01020304_0506",
+	"\xab\xc0\xee\xd8\x1f",	16,	-1,	-1,	"abc0eed81f",
+	"\x0c\x20\x40",		's',	-1,	-1,	"0sDCBA",
+	"\x0c\x20\x40",		's',	0,	7,	"---",
+	"\x0c\x20\x40",		's',	1,	7,	"",
+	"\x0c\x20\x40",		's',	2,	7,	"0",
+	"\x0c\x20\x40",		's',	3,	7,	"0s",
+	"\x0c\x20\x40",		's',	4,	7,	"0sD",
+	"\x0c\x20\x40",		's',	5,	7,	"0sDC",
+	"\x0c\x20\x40",		's',	6,	7,	"0sDCB",
+	"\x0c\x20\x40",		's',	7,	7,	"0sDCBA",
+	"\x0c\x20\x40",		's',	8,	7,	"0sDCBA",
+	"\x0c",			's',	-1,	-1,	"0sDA==",
+	"\x0c\x20",		's',	-1,	-1,	"0sDCA=",
+	"\x0c\x20\x19",		's',	-1,	-1,	"0sDCAZ",
+	"\x0c\x20\x1a",		's',	-1,	-1,	"0sDCAa",
+	"\x0c\x20\x33",		's',	-1,	-1,	"0sDCAz",
+	"\x0c\x20\x34",		's',	-1,	-1,	"0sDCA0",
+	"\x0c\x20\x3d",		's',	-1,	-1,	"0sDCA9",	
+	"\x0c\x20\x3e",		's',	-1,	-1,	"0sDCA+",
+	"\x0c\x20\x3f",		's',	-1,	-1,	"0sDCA/",	
+	"\x01\xba\xda\x09\xa7\x5a\x6e\xb6\xbe", 's', -1, -1, "0sAbraCadabra+",
+	"\x01\xba\xda\x09\xa7\x5a\x6e\xb6\xbe", 64, -1, -1, "AbraCadabra+",
+	NULL,			'x',	-1,	-1,	NULL,
+};
+
+/*
+ - regress - regression-test ttodata() and datatot()
+ */
+void			/* should not return at all, in fact */
+regress(pgm)
+char *pgm;
+{
+	struct artab *r;
+	struct drtab *dr;
+	char buf[100];
+	size_t n;
+	int status = 0;
+	size_t should;
+	const char *oops;
+
+	for (r = atodatatab; r->ascii != NULL; r++) {
+		oops = ttodata(r->ascii, 0, r->base, buf, sizeof(buf), &n);
+		if (oops != NULL && r->data == NULL)
+			{}			/* error expected */
+		else if (oops != NULL) {
+			printf("`%s' gave error `%s', expecting %d `", r->ascii,
+							oops, strlen(r->data));
+			hexout(r->data, strlen(r->data), stdout);
+			printf("'\n");
+			status = 1;
+		} else if (r->data == NULL) {
+			printf("`%s' gave %d `", r->ascii, n);
+			hexout(buf, n, stdout);
+			printf("', expecting error\n");
+			status = 1;
+		} else if (n != strlen(r->data)) {
+			printf("length wrong in `%s': got %d `", r->ascii, n);
+			hexout(buf, n, stdout);
+			printf("', expecting %d `", strlen(r->data));
+			hexout(r->data, strlen(r->data), stdout);
+			printf("'\n");
+			status = 1;
+		} else if (memcmp(buf, r->data, n) != 0) {
+			printf("`%s' gave %d `", r->ascii, n);
+			hexout(buf, n, stdout);
+			printf("', expecting %d `", strlen(r->data));
+			hexout(r->data, strlen(r->data), stdout);
+			printf("'\n");
+			status = 1;
+		}
+		fflush(stdout);
+	}
+	for (dr = datatoatab; dr->data != NULL; dr++) {
+		strcpy(buf, "---");
+		n = datatot(dr->data, strlen(dr->data), dr->format, buf,
+				(dr->buflen == -1) ? sizeof(buf) : dr->buflen);
+		should = (dr->ascii == NULL) ? 0 : strlen(dr->ascii) + 1;
+		if (dr->outlen != -1)
+			should = dr->outlen;
+		if (n == 0 && dr->ascii == NULL)
+			{}			/* error expected */
+		else if (n == 0) {
+			printf("`");
+			hexout(dr->data, strlen(dr->data), stdout);
+			printf("' %c gave error, expecting %d `%s'\n",
+				dr->format, should, dr->ascii);
+			status = 1;
+		} else if (dr->ascii == NULL) {
+			printf("`");
+			hexout(dr->data, strlen(dr->data), stdout);
+			printf("' %c gave %d `%.*s', expecting error\n",
+				dr->format, n, n, buf);
+			status = 1;
+		} else if (n != should) {
+			printf("length wrong in `");
+			hexout(dr->data, strlen(dr->data), stdout);
+			printf("': got %d `%s'", n, buf);
+			printf(", expecting %d `%s'\n", should, dr->ascii);
+			status = 1;
+		} else if (strcmp(buf, dr->ascii) != 0) {
+			printf("`");
+			hexout(dr->data, strlen(dr->data), stdout);
+			printf("' gave %d `%s'", n, buf);
+			printf(", expecting %d `%s'\n", should, dr->ascii);
+			status = 1;
+		}
+		fflush(stdout);
+	}
+	exit(status);
+}
+
+#endif /* TTODATA_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/ttosa.c linux/net/ipsec/libfreeswan/ttosa.c
--- linux-noipsec/net/ipsec/libfreeswan/ttosa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ttosa.c	Fri Sep 15 21:20:33 2000
@@ -0,0 +1,250 @@
+/*
+ * convert from text form of SA ID to binary
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+static struct satype {
+	char *prefix;
+	size_t prelen;		/* strlen(prefix) */
+	int proto;
+} satypes[] = {
+	{ "ah",		2,	SA_AH	},
+	{ "esp",	3,	SA_ESP	},
+	{ "tun",	3,	SA_IPIP },
+	{ "comp",	4,	SA_COMP },
+	{ NULL,		0,	0,	}
+};
+
+/*
+ - ttosa - convert text "ah507@10.0.0.1" to SA identifier
+ */
+err_t				/* NULL for success, else string literal */
+ttosa(src, srclen, sa)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+ip_said *sa;
+{
+	const char *at;
+	const char *addr;
+	size_t alen;
+	const char *spi = NULL;
+	struct satype *sat;
+	unsigned long ul;
+	const char *oops;
+#	define	MINLEN	5	/* ah0@0 is as short as it can get */
+	static char ptname[] = PASSTHROUGHNAME;
+#	define	PTNLEN	(sizeof(ptname)-1)	/* -1 for NUL */
+	static char pt4name[] = PASSTHROUGH4NAME;
+#	define	PT4NLEN	(sizeof(pt4name)-1)	/* -1 for NUL */
+	static char pt6name[] = PASSTHROUGH6NAME;
+#	define	PT6NLEN	(sizeof(pt6name)-1)	/* -1 for NUL */
+	int af;
+	int base;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+	if (srclen < MINLEN)
+		return "string too short to be SA identifier";
+	if (srclen == PTNLEN && memcmp(src, ptname, PTNLEN) == 0) {
+		src = PASSTHROUGH4IS;
+		srclen = strlen(src);
+	} else if (srclen == PT4NLEN && memcmp(src, pt4name, PT4NLEN) == 0) {
+		src = PASSTHROUGH4IS;
+		srclen = strlen(src);
+	} else if (srclen == PT6NLEN && memcmp(src, pt6name, PT6NLEN) == 0) {
+		src = PASSTHROUGH6IS;
+		srclen = strlen(src);
+	}
+
+	at = memchr(src, '@', srclen);
+	if (at == NULL)
+		return "no @ in SA specifier";
+
+	for (sat = satypes; sat->prefix != NULL; sat++)
+		if (sat->prelen < srclen &&
+				strncmp(src, sat->prefix, sat->prelen) == 0) {
+			sa->proto = sat->proto;
+			spi = src + sat->prelen;
+			break;			/* NOTE BREAK OUT */
+		}
+	if (sat->prefix == NULL)
+		return "SA specifier lacks valid protocol prefix";
+
+	if (spi >= at)
+		return "no SPI in SA specifier";
+	switch (*spi) {
+	case '.':
+		af = AF_INET;
+		spi++;
+		base = 16;
+		break;
+	case ':':
+		af = AF_INET6;
+		spi++;
+		base = 16;
+		break;
+	default:
+		af = AF_UNSPEC;		/* not known yet */
+		base = 0;
+		break;
+	}
+	if (spi >= at)
+		return "no SPI found in SA specifier";
+	oops = ttoul(spi, at - spi, base, &ul);
+	if (oops != NULL)
+		return oops;
+	sa->spi = htonl(ul);
+
+	addr = at + 1;
+	alen = srclen - (addr - src);
+	if (af == AF_UNSPEC)
+		af = (memchr(addr, ':', alen) != NULL) ? AF_INET6 : AF_INET;
+	oops = ttoaddr(addr, alen, af, &sa->dst);
+	if (oops != NULL)
+		return oops;
+
+	return NULL;
+}
+
+
+
+#ifdef TTOSA_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	ip_said sa;
+	char buf[100];
+	char buf2[100];
+	const char *oops;
+	size_t n;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s {ahnnn@aaa|-r}\n", argv[0]);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	oops = ttosa(argv[1], 0, &sa);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	n = satot(&sa, 0, buf, sizeof(buf));
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conv of `%d'", argv[0], sa.proto);
+		fprintf(stderr, "%lx@", sa.spi);
+		(void) addrtot(&sa.dst, 0, buf2, sizeof(buf2));
+		fprintf(stderr, "%s", buf2);
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	int format;
+	char *input;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	0, "esp257@1.2.3.0",		"esp.101@1.2.3.0",
+	0, "ah0x20@1.2.3.4",		"ah.20@1.2.3.4",
+	0, "tun20@1.2.3.4",		"tun.14@1.2.3.4",
+	0, "comp20@1.2.3.4",		"comp.14@1.2.3.4",
+	0, "esp257@::1",		"esp:101@::1",
+	0, "esp257@0bc:12de::1",	"esp:101@bc:12de::1",
+	0, "esp78@1049:1::8007:2040",	"esp:4e@1049:1::8007:2040",
+	0, "esp0x78@1049:1::8007:2040",	"esp:78@1049:1::8007:2040",
+	0, "ah78@1049:1::8007:2040",	"ah:4e@1049:1::8007:2040",
+	0, "ah0x78@1049:1::8007:2040",	"ah:78@1049:1::8007:2040",
+	0, "tun78@1049:1::8007:2040",	"tun:4e@1049:1::8007:2040",
+	0, "tun0x78@1049:1::8007:2040",	"tun:78@1049:1::8007:2040",
+	0, "duk99@3ffe:370:400:ff::9001:3001",	NULL,
+	0, "esp78x@1049:1::8007:2040",	NULL,
+	0, "esp0x78@1049:1:0xfff::8007:2040",	NULL,
+	0, "es78@1049:1::8007:2040",	NULL,
+	0, "",				NULL,
+	0, "_",				NULL,
+	0, "ah2.2",			NULL,
+	0, "goo2@1.2.3.4",		NULL,
+	0, "esp9@1.2.3.4",		"esp.9@1.2.3.4",
+	'f', "esp0xa9@1.2.3.4",		"esp.000000a9@1.2.3.4",
+	0, "espp9@1.2.3.4",		NULL,
+	0, "es9@1.2.3.4",		NULL,
+	0, "ah@1.2.3.4",		NULL,
+	0, "esp7x7@1.2.3.4",		NULL,
+	0, "esp77@1.0x2.3.4",		NULL,
+	0, PASSTHROUGHNAME,		PASSTHROUGH4NAME,
+	0, NULL,			NULL
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	ip_said sa;
+	char in[100];
+	char buf[100];
+	const char *oops;
+	size_t n;
+
+	for (r = rtab; r->input != NULL; r++) {
+		strcpy(in, r->input);
+		oops = ttosa(in, 0, &sa);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s' ttosa failed: %s\n", r->input, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s' ttosa succeeded unexpectedly\n",
+								r->input);
+			status = 1;
+		} else {
+			n = satot(&sa, r->format, buf, sizeof(buf));
+			if (n > sizeof(buf)) {
+				printf("`%s' satot failed:  need %ld\n",
+							r->input, (long)n);
+				status = 1;
+			} else if (strcmp(r->output, buf) != 0) {
+				printf("`%s' gave `%s', expected `%s'\n",
+						r->input, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* TTOSA_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/ttosubnet.c linux/net/ipsec/libfreeswan/ttosubnet.c
--- linux-noipsec/net/ipsec/libfreeswan/ttosubnet.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ttosubnet.c	Thu Aug 17 06:14:27 2000
@@ -0,0 +1,275 @@
+/*
+ * convert from text form of subnet specification to binary
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+#ifndef DEFAULTSUBNET
+#define	DEFAULTSUBNET	"%default"
+#endif
+
+/*
+ - ttosubnet - convert text "addr/mask" to address and mask
+ * Mask can be integer bit count.
+ */
+err_t
+ttosubnet(src, srclen, af, dst)
+const char *src;
+size_t srclen;			/* 0 means "apply strlen" */
+int af;				/* AF_INET or AF_INET6 */
+ip_subnet *dst;
+{
+	const char *slash;
+	const char *mask;
+	size_t mlen;
+	const char *oops;
+	unsigned long bc;
+	static char def[] = DEFAULTSUBNET;
+#	define	DEFLEN	(sizeof(def) - 1)	/* -1 for NUL */
+	static char defis4[] = "0/0";
+#	define	DEFIS4LEN	(sizeof(defis4) - 1)
+	static char defis6[] = "::/0";
+#	define	DEFIS6LEN	(sizeof(defis6) - 1)
+	ip_address addrtmp;
+	ip_address masktmp;
+	int nbits;
+	int i;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	switch (af) {
+	case AF_INET:
+		nbits = 32;
+		break;
+	case AF_INET6:
+		nbits = 128;
+		break;
+	default:
+		return "unknown address family in ttosubnet";
+		break;
+	}
+
+	if (srclen == DEFLEN && strncmp(src, def, srclen) == 0) {
+		src = (af == AF_INET) ? defis4 : defis6;
+		srclen = (af == AF_INET) ? DEFIS4LEN : DEFIS6LEN;
+	}
+
+	slash = memchr(src, '/', srclen);
+	if (slash == NULL)
+		return "no / in subnet specification";
+	mask = slash + 1;
+	mlen = srclen - (mask - src);
+
+	oops = ttoaddr(src, slash-src, af, &addrtmp);
+	if (oops != NULL)
+		return oops;
+
+	oops = ttoul(mask, mlen, 10, &bc);
+	if (oops == NULL) {
+		/* ttoul succeeded, it's a bit-count mask */
+		if (bc > nbits)
+			return "subnet mask bit count too large";
+		i = bc;
+	} else {
+		oops = ttoaddr(mask, mlen, af, &masktmp);
+		if (oops != NULL)
+			return oops;
+		i = masktocount(&masktmp);
+		if (i < 0)
+			return "non-contiguous or otherwise erroneous mask";
+	}
+
+	return initsubnet(&addrtmp, i, '0', dst);
+}
+
+
+
+#ifdef TTOSUBNET_MAIN
+
+#include <stdio.h>
+
+void regress();
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	ip_address a;
+	ip_subnet s;
+	char buf[100];
+	char buf2[100];
+	const char *oops;
+	size_t n;
+	int af;
+	char *p;
+
+	if (argc < 2) {
+		fprintf(stderr, "Usage: %s [-6] addr/mask\n", argv[0]);
+		fprintf(stderr, "   or: %s -r\n", argv[0]);
+		exit(2);
+	}
+
+	if (strcmp(argv[1], "-r") == 0) {
+		regress();
+		fprintf(stderr, "regress() returned?!?\n");
+		exit(1);
+	}
+
+	af = AF_INET;
+	p = argv[1];
+	if (strcmp(argv[1], "-6") == 0) {
+		af = AF_INET6;
+		p = argv[2];
+	} else if (strchr(argv[1], ':') != NULL)
+		af = AF_INET6;
+
+	oops = ttosubnet(p, 0, af, &s);
+	if (oops != NULL) {
+		fprintf(stderr, "%s: conversion failed: %s\n", argv[0], oops);
+		exit(1);
+	}
+	n = subnettot(&s, 0, buf, sizeof(buf));
+	if (n > sizeof(buf)) {
+		fprintf(stderr, "%s: reverse conversion of ", argv[0]);
+		(void) addrtot(&s.addr, 0, buf2, sizeof(buf2));
+		fprintf(stderr, "%s/", buf2);
+		fprintf(stderr, "%d", s.maskbits);
+		fprintf(stderr, " failed: need %ld bytes, have only %ld\n",
+						(long)n, (long)sizeof(buf));
+		exit(1);
+	}
+	printf("%s\n", buf);
+
+	exit(0);
+}
+
+struct rtab {
+	int family;
+	char *input;
+	char *output;			/* NULL means error expected */
+} rtab[] = {
+	4, "1.2.3.0/255.255.255.0",	"1.2.3.0/24",
+	4, "1.2.3.0/24",		"1.2.3.0/24",
+	4, "1.2.3.1/255.255.255.240",	"1.2.3.0/28",
+	4, "1.2.3.1/32",		"1.2.3.1/32",
+	4, "1.2.3.1/0",			"0.0.0.0/0",
+/*	4, "1.2.3.1/255.255.127.0",	"1.2.3.0/255.255.127.0",	*/
+	4, "1.2.3.1/255.255.127.0",	NULL,
+	4, "128.009.000.032/32",	"128.9.0.32/32",
+	4, "128.0x9.0.32/32",		NULL,
+	4, "0x80090020/32",		"128.9.0.32/32",
+	4, "0x800x0020/32",		NULL,
+	4, "128.9.0.32/0xffFF0000",	"128.9.0.0/16",
+	4, "128.9.0.32/0xff0000FF",	NULL,
+	4, "128.9.0.32/0x0000ffFF",	NULL,
+	4, "128.9.0.32/0x00ffFF0000",	NULL,
+	4, "128.9.0.32/0xffFF",		NULL,
+	4, "128.9.0.32.27/32",		NULL,
+	4, "128.9.0k32/32",		NULL,
+	4, "328.9.0.32/32",		NULL,
+	4, "128.9..32/32",		NULL,
+	4, "10/8",			"10.0.0.0/8",
+	4, "10.0/8",			"10.0.0.0/8",
+	4, "10.0.0/8",			"10.0.0.0/8",
+	4, "10.0.1/24",			"10.0.1.0/24",
+	4, "_",				NULL,
+	4, "_/_",			NULL,
+	4, "1.2.3.1",			NULL,
+	4, "1.2.3.1/_",			NULL,
+	4, "1.2.3.1/24._",		NULL,
+	4, "1.2.3.1/99",		NULL,
+	4, "localhost./32",		"127.0.0.1/32",
+	4, "%default",			"0.0.0.0/0",
+	6, "3049:1::8007:2040/0",	"::/0",
+	6, "3049:1::8007:2040/128",	"3049:1::8007:2040/128",
+	6, "3049:1::192.168.0.1/128", NULL,	/*"3049:1::c0a8:1/128",*/
+	6, "3049:1::8007::2040/128",	NULL,
+	6, "3049:1::8007:2040/ffff::0",	"3049::/16",
+	6, "3049:1::8007:2040/64",	"3049:1::/64",
+	6, "3049:1::8007:2040/ffff::",	"3049::/16",
+	6, "3049:1::8007:2040/0000:ffff::0",	NULL,
+	6, "3049:1::8007:2040/ff1f::0",	NULL,
+	6, "3049:1::8007:x:2040/128",	NULL,
+	6, "3049:1t::8007:2040/128",	NULL,
+	6, "3049:1::80071:2040/128",	NULL,
+	6, "::/21",			"::/21",
+	6, "::1/128",			"::1/128",
+	6, "1::/21",			"1::/21",
+	6, "1::2/128",			"1::2/128",
+	6, "1:0:0:0:0:0:0:2/128",	"1::2/128",
+	6, "1:0:0:0:3:0:0:2/128",	"1::3:0:0:2/128",
+	6, "1:0:0:3:0:0:0:2/128",	"1::3:0:0:0:2/128",
+	6, "1:0:3:0:0:0:0:2/128",	"1:0:3::2/128",
+	6, "abcd:ef01:2345:6789:0:00a:000:20/128",	"abcd:ef01:2345:6789:0:a:0:20/128",
+	6, "3049:1::8007:2040/ffff:ffff:",	NULL,
+	6, "3049:1::8007:2040/ffff:88::",	NULL,
+	6, "3049:12::9000:3200/ffff:fff0::",	"3049:10::/28",
+	6, "3049:12::9000:3200/28",	"3049:10::/28",
+	6, "3049:12::9000:3200/ff00:::",	NULL,
+	6, "3049:12::9000:3200/ffff:::",	NULL,
+	6, "3049:12::9000:3200/128_",	NULL,
+	6, "3049:12::9000:3200/",	NULL,
+	6, "%default",			"::/0",
+	4, NULL,			NULL
+};
+
+void
+regress()
+{
+	struct rtab *r;
+	int status = 0;
+	ip_address a;
+	ip_subnet s;
+	char in[100];
+	char buf[100];
+	const char *oops;
+	size_t n;
+	int af;
+
+	for (r = rtab; r->input != NULL; r++) {
+		af = (r->family == 4) ? AF_INET : AF_INET6;
+		strcpy(in, r->input);
+		oops = ttosubnet(in, 0, af, &s);
+		if (oops != NULL && r->output == NULL)
+			{}		/* okay, error expected */
+		else if (oops != NULL) {
+			printf("`%s' ttosubnet failed: %s\n", r->input, oops);
+			status = 1;
+		} else if (r->output == NULL) {
+			printf("`%s' ttosubnet succeeded unexpectedly\n",
+								r->input);
+			status = 1;
+		} else {
+			n = subnettot(&s, 0, buf, sizeof(buf));
+			if (n > sizeof(buf)) {
+				printf("`%s' subnettot failed:  need %ld\n",
+							r->input, (long)n);
+				status = 1;
+			} else if (strcmp(r->output, buf) != 0) {
+				printf("`%s' gave `%s', expected `%s'\n",
+						r->input, buf, r->output);
+				status = 1;
+			}
+		}
+	}
+	exit(status);
+}
+
+#endif /* TTOSUBNET_MAIN */
diff -druN linux-noipsec/net/ipsec/libfreeswan/ttoul.c linux/net/ipsec/libfreeswan/ttoul.c
--- linux-noipsec/net/ipsec/libfreeswan/ttoul.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ttoul.c	Thu Aug 17 01:07:16 2000
@@ -0,0 +1,91 @@
+/*
+ * convert from text form of unsigned long to binary
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - ttoul - convert text substring to unsigned long number
+ */
+const char *			/* NULL for success, else string literal */
+ttoul(src, srclen, base, resultp)
+const char *src;
+size_t srclen;			/* 0 means strlen(src) */
+int base;			/* 0 means figure it out */
+unsigned long *resultp;
+{
+	const char *stop;
+	static char hex[] = "0123456789abcdef";
+	static char uchex[] = "0123456789ABCDEF";
+	int d;
+	char c;
+	char *p;
+	unsigned long r;
+	unsigned long rlimit;
+	int dlimit;
+
+	if (srclen == 0)
+		srclen = strlen(src);
+	if (srclen == 0)
+		return "empty string";
+
+	if (base == 0) {
+		if (srclen > 2 && *src == '0' &&
+					(*(src+1) == 'x' || *(src+1) == 'X'))
+			return ttoul(src+2, srclen-2, 16, resultp);
+		if (srclen > 1 && *src == '0')
+			return ttoul(src+1, srclen-1, 8, resultp);
+		return ttoul(src, srclen, 10, resultp);
+	}
+	if (base != 8 && base != 10 && base != 16)
+		return "unsupported number base";
+
+	r = 0;
+	stop = src + srclen;
+	if (base == 16) {
+		while (src < stop) {
+			c = *src++;
+			p = strchr(hex, c);
+			if (p != NULL)
+				d = p - hex;
+			else {
+				p = strchr(uchex, c);
+				if (p == NULL)
+					return "non-hex digit in hex number";
+				d = p - uchex;
+			}
+			r = (r << 4) | d;
+		}
+		/* defer length check to catch invalid digits first */
+		if (srclen > sizeof(unsigned long) * 2)
+			return "hex number too long";
+	} else {
+		rlimit = ULONG_MAX / base;
+		dlimit = (int)(ULONG_MAX - rlimit*base);
+		while (src < stop) {
+			c = *src++;
+			d = c - '0';
+			if (d < 0 || d >= base)
+				return "non-digit in number";
+			if (r > rlimit || (r == rlimit && d > dlimit))
+				return "unsigned-long overflow";
+			r = r*base + d;
+		}
+	}
+
+	*resultp = r;
+	return NULL;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/ultoa.c linux/net/ipsec/libfreeswan/ultoa.c
--- linux-noipsec/net/ipsec/libfreeswan/ultoa.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ultoa.c	Wed Oct 13 20:09:06 1999
@@ -0,0 +1,67 @@
+/*
+ * convert unsigned long to ASCII
+ * Copyright (C) 1998, 1999  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - ultoa - convert unsigned long to decimal ASCII
+ */
+size_t				/* length required for full conversion */
+ultoa(n, base, dst, dstlen)
+unsigned long n;
+int base;
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	char buf[3*sizeof(unsigned long) + 1];
+	char *bufend = buf + sizeof(buf);
+	size_t len;
+	char *p;
+	static char hex[] = "0123456789abcdef";
+
+	p = bufend;
+	*--p = '\0';
+	if (base == 10) {
+		do {
+			*--p = n%10 + '0';
+			n /= 10;
+		} while (n != 0);
+	} else if (base == 16) {
+		do {
+			*--p = hex[n&0xf];
+			n >>= 4;
+		} while (n != 0);
+		*--p = 'x';
+		*--p = '0';
+	} else if (base == 8) {
+		do {
+			*--p = (n&07) + '0';
+			n >>= 3;
+		} while (n != 0);
+		*--p = '0';
+	} else
+		*--p = '?';
+
+	len = bufend - p;
+
+	if (dstlen > 0) {
+		if (len > dstlen)
+			*(p + dstlen - 1) = '\0';
+		strcpy(dst, p);
+	}
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/libfreeswan/ultot.c linux/net/ipsec/libfreeswan/ultot.c
--- linux-noipsec/net/ipsec/libfreeswan/ultot.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/libfreeswan/ultot.c	Thu Aug 17 01:07:16 2000
@@ -0,0 +1,83 @@
+/*
+ * convert unsigned long to text
+ * Copyright (C) 2000  Henry Spencer.
+ * 
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/lgpl.txt>.
+ * 
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+ * License for more details.
+ *
+ * RCSID $Id$
+ */
+#include "internal.h"
+#include "freeswan.h"
+
+/*
+ - ultot - convert unsigned long to text
+ */
+size_t				/* length required for full conversion */
+ultot(n, base, dst, dstlen)
+unsigned long n;
+int base;
+char *dst;			/* need not be valid if dstlen is 0 */
+size_t dstlen;
+{
+	char buf[3*sizeof(unsigned long) + 1];
+	char *bufend = buf + sizeof(buf);
+	size_t len;
+	char *p;
+	static char hex[] = "0123456789abcdef";
+#	define	HEX32	(32/4)
+
+	p = bufend;
+	*--p = '\0';
+	switch (base) {
+	case 10:
+	case 'd':
+		do {
+			*--p = n%10 + '0';
+			n /= 10;
+		} while (n != 0);
+		break;
+	case 16:
+	case 17:
+	case 'x':
+		do {
+			*--p = hex[n&0xf];
+			n >>= 4;
+		} while (n != 0);
+		if (base == 17)
+			while (bufend - p < HEX32 + 1)
+				*--p = '0';
+		if (base == 'x') {
+			*--p = 'x';
+			*--p = '0';
+		}
+		break;
+	case 8:
+	case 'o':
+		do {
+			*--p = (n&07) + '0';
+			n >>= 3;
+		} while (n != 0);
+		if (base == 'o')
+			*--p = '0';
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	len = bufend - p;
+	if (dstlen > 0) {
+		if (len > dstlen)
+			*(p + dstlen - 1) = '\0';
+		strcpy(dst, p);
+	}
+	return len;
+}
diff -druN linux-noipsec/net/ipsec/pfkey_v2.c linux/net/ipsec/pfkey_v2.c
--- linux-noipsec/net/ipsec/pfkey_v2.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/pfkey_v2.c	Mon Nov  6 05:33:47 2000
@@ -0,0 +1,1891 @@
+/*
+ * RFC2367 PF_KEYv2 Key management API domain socket I/F
+ * Copyright (C) 1999, 2000  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ *		Template from /usr/src/linux-2.0.36/net/unix/af_unix.c.
+ *		Hints from /usr/src/linux-2.0.36/net/ipv4/udp.c.
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/socket.h>
+#include <linux/un.h>
+#include <linux/fcntl.h>
+#include <linux/termios.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/net.h> /* struct socket */
+#include <linux/in.h>
+#include <linux/fs.h>
+#include <linux/malloc.h>
+#include <asm/segment.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/sock.h> /* struct sock */
+/* #include <net/tcp.h> */
+#include <net/af_unix.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif /* CONFIG_PROC_FS */
+
+#include <linux/types.h>
+ 
+#include <freeswan.h>
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#endif /* NET_21 */
+#include <pfkeyv2.h>
+#include <pfkey.h>
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_netlink.h"
+
+#ifdef CONFIG_IPSEC_DEBUG
+int debug_pfkey = 0;
+extern int sysctl_ipsec_debug_verbose;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+#define min(a,b)	(((a)<(b))?(a):(b))
+
+#define SENDERR(_x) do { error = -(_x); goto errlab; } while (0)
+
+#ifndef SOCKOPS_WRAPPED
+#define SOCKOPS_WRAPPED(name) name
+#endif
+
+struct proto_ops SOCKOPS_WRAPPED(pfkey_ops);
+struct sock *pfkey_sock_list = NULL;
+struct supported_list *pfkey_supported_list[SADB_SATYPE_MAX+1];
+
+struct socket_list *pfkey_open_sockets = NULL;
+struct socket_list *pfkey_registered_sockets[SADB_SATYPE_MAX+1];
+
+int pfkey_msg_interp(struct sock *, struct sadb_msg *, struct sadb_msg **);
+
+int
+pfkey_list_remove_socket(struct socket *socketp, struct socket_list **sockets)
+{
+	struct socket_list *socket_listp,*prev;
+
+	if(!socketp) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_remove_socket: "
+			    "NULL socketp handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	if(!sockets) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_remove_socket: "
+			    "NULL sockets list handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	socket_listp = *sockets;
+	prev = NULL;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_list_remove_socket: "
+		    "removing sock=%p\n",
+		    socketp);
+	
+	while(socket_listp != NULL) {
+		if(socket_listp->socketp == socketp) {
+			if(prev != NULL) {
+				prev->next = socket_listp->next;
+			} else {
+				*sockets = socket_listp->next;
+			}
+			
+			kfree((void*)socket_listp);
+			
+			break;
+		}
+		prev = socket_listp;
+		socket_listp = socket_listp->next;
+	}
+
+	return 0;
+}
+
+int
+pfkey_list_insert_socket(struct socket *socketp, struct socket_list **sockets)
+{
+	struct socket_list *socket_listp;
+
+	if(!socketp) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_socket: "
+			    "NULL socketp handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	if(!sockets) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_socket: "
+			    "NULL sockets list handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_list_insert_socket: "
+		    "socketp=%p\n",socketp);
+	
+	if((socket_listp = (struct socket_list *)kmalloc(sizeof(struct socket_list), GFP_KERNEL)) == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_socket: "
+			    "memory allocation error.\n");
+		return -ENOMEM;
+	}
+	
+	socket_listp->socketp = socketp;
+	socket_listp->next = *sockets;
+	*sockets = socket_listp;
+
+	return 0;
+}
+  
+int
+pfkey_list_remove_supported(struct supported *supported, struct supported_list **supported_list)
+{
+	struct supported_list *supported_listp = *supported_list, *prev = NULL;
+	
+	if(!supported) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_remove_supported: "
+			    "NULL supported handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	if(!supported_list) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_remove_supported: "
+			    "NULL supported_list handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_list_remove_supported: "
+		    "removing supported=%p\n",
+		    supported);
+	
+	while(supported_listp != NULL) {
+		if(supported_listp->supportedp == supported) {
+			if(prev != NULL) {
+				prev->next = supported_listp->next;
+			} else {
+				*supported_list = supported_listp->next;
+			}
+			
+			kfree((void*)supported_listp);
+			
+			break;
+		}
+		prev = supported_listp;
+		supported_listp = supported_listp->next;
+	}
+
+	return 0;
+}
+
+int
+pfkey_list_insert_supported(struct supported *supported, struct supported_list **supported_list)
+{
+	struct supported_list *supported_listp;
+
+	if(!supported) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_supported: "
+			    "NULL supported handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	if(!supported_list) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_supported: "
+			    "NULL supported_list handed in, failed.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_list_insert_supported: "
+		    "incoming, supported=%p, supported_list=%p\n",
+		    supported,
+		    supported_list);
+	
+	supported_listp = (struct supported_list *)kmalloc(sizeof(struct supported_list), GFP_KERNEL);
+	if(supported_listp == NULL)	{
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_list_insert_supported: "
+			    "memory allocation error.\n");
+		return -ENOMEM;
+	}
+	
+	supported_listp->supportedp = supported;
+	supported_listp->next = *supported_list;
+	*supported_list = supported_listp;
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_list_insert_supported: "
+		    "outgoing, supported=%p, supported_list=%p\n",
+		    supported,
+		    supported_list);
+
+	return 0;
+}
+  
+#ifndef NET_21
+DEBUG_NO_STATIC void
+pfkey_state_change(struct sock *sk)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_state_change: .\n");
+	if(!sk->dead) {
+		wake_up_interruptible(sk->sleep);
+	}
+}
+#endif /* !NET_21 */
+
+#ifndef NET_21
+DEBUG_NO_STATIC void
+pfkey_data_ready(struct sock *sk, int len)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_data_ready: .sk=%p len=%d\n", sk, len);
+	if(!sk->dead) {
+		wake_up_interruptible(sk->sleep);
+		sock_wake_async(sk->socket, 1);
+	}
+}
+
+DEBUG_NO_STATIC void
+pfkey_write_space(struct sock *sk)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_write_space: .\n");
+	if(!sk->dead) {
+		wake_up_interruptible(sk->sleep);
+		sock_wake_async(sk->socket, 2);
+	}
+}
+#endif /* !NET_21 */
+
+DEBUG_NO_STATIC void
+pfkey_insert_socket(struct sock *sk)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_insert_socket: sk=%p\n", sk);
+	cli();
+	sk->next=pfkey_sock_list;
+	pfkey_sock_list=sk;
+	sti();
+}
+
+DEBUG_NO_STATIC void
+pfkey_remove_socket(struct sock *sk)
+{
+	struct sock **s;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_remove_socket: .\n");
+	cli();
+	s=&pfkey_sock_list;
+
+	while(*s!=NULL) {
+		if(*s==sk) {
+			*s=sk->next;
+			sk->next=NULL;
+			sti();
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_remove_socket: succeeded.\n");
+			return;
+		}
+		s=&((*s)->next);
+	}
+	sti();
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_remove_socket: not found.\n");
+	return;
+}
+
+DEBUG_NO_STATIC void
+pfkey_destroy_socket(struct sock *sk)
+{
+	struct sk_buff *skb;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_destroy_socket: .\n");
+	pfkey_remove_socket(sk);
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_destroy_socket: pfkey_remove_socket called.\n");
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_destroy_socket: "
+		    "sk(%p)->(&%p)receive_queue.{next=%p,prev=%p}.\n",
+		    sk,
+		    &(sk->receive_queue),
+		    sk->receive_queue.next,
+		    sk->receive_queue.prev);
+	while(sk && ((skb=skb_dequeue(&(sk->receive_queue)))!=NULL)) {
+#ifdef NET_21
+#ifdef CONFIG_IPSEC_DEBUG
+		if(debug_pfkey && sysctl_ipsec_debug_verbose) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_destroy_socket: skb=%p dequeued.\n", skb);
+			printk(KERN_INFO "klips_debug: pfkey_skb contents:");
+			printk(" next:%p", skb->next);
+			printk(" prev:%p", skb->prev);
+			printk(" list:%p", skb->list);
+			printk(" sk:%p", skb->sk);
+			printk(" stamp:%ld.%ld", skb->stamp.tv_sec, skb->stamp.tv_usec);
+			printk(" dev:%p", skb->dev);
+			if(skb->dev) {
+				if(skb->dev->name) {
+					printk(" dev->name:%s", skb->dev->name);
+				} else {
+					printk(" dev->name:NULL?");
+				}
+			} else {
+				printk(" dev:NULL");
+			}
+			printk(" h:%p", skb->h.raw);
+			printk(" nh:%p", skb->nh.raw);
+			printk(" mac:%p", skb->mac.raw);
+			printk(" dst:%p", skb->dst);
+			if(sysctl_ipsec_debug_verbose) {
+				int i;
+				
+				printk(" cb");
+				for(i=0; i<48; i++) {
+					printk(":%2x", skb->cb[i]);
+				}
+			}
+			printk(" len:%d", skb->len);
+			printk(" csum:%d", skb->csum);
+			printk(" used:%d", skb->used);
+			printk(" is_clone:%d", skb->is_clone);
+			printk(" cloned:%d", skb->cloned);
+			printk(" pkt_type:%d", skb->pkt_type);
+			printk(" ip_summed:%d", skb->ip_summed);
+			printk(" priority:%d", skb->priority);
+			printk(" protocol:%d", skb->protocol);
+			printk(" security:%d", skb->security);
+			printk(" truesize:%d", skb->truesize);
+			printk(" head:%p", skb->head);
+			printk(" data:%p", skb->data);
+			printk(" tail:%p", skb->tail);
+			printk(" end:%p", skb->end);
+			if(sysctl_ipsec_debug_verbose) {
+				unsigned int i;
+				printk(" data");
+				for(i=(unsigned int)(skb->head); i<(unsigned int)(skb->end); i++) {
+					printk(":%2x", (unsigned char)(*(char*)(i)));
+				}
+			}
+			printk(" destructor:%p", skb->destructor);
+			printk("\n");
+		}
+#endif /* CONFIG_IPSEC_DEBUG */
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_destroy_socket: skb=%p freed.\n", skb);
+		kfree_skb(skb);
+
+#else /* NET_21 */
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_destroy_socket: skb=%p dequeued and freed.\n", skb);
+		kfree_skb(skb, FREE_WRITE);
+
+#endif /* NET_21 */
+	}
+
+	sk->dead = 1;
+	sk_free(sk);
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_destroy_socket: destroyed.\n");
+}
+
+int
+pfkey_upmsg(struct socket *sock, struct sadb_msg *pfkey_msg)
+{
+	int error;
+	struct sk_buff * skb = NULL;
+	struct sock *sk;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_upmsg: NULL socket passed in.\n");
+		return -EINVAL;
+	}
+
+	if(pfkey_msg == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_upmsg: NULL pfkey_msg passed in.\n");
+		return -EINVAL;
+	}
+
+#ifdef NET_21
+	sk = sock->sk;
+#else /* NET_21 */
+	sk = sock->data;
+#endif /* NET_21 */
+
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_upmsg: NULL sock passed in.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_upmsg: allocating %d bytes...\n",
+		    pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN);
+	if(!(skb = alloc_skb(pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN, GFP_ATOMIC) )) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_upmsg: no buffers left to send up a message.\n");
+		return -ENOBUFS;
+	}
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_upmsg: ...allocated at %p.\n", skb);
+	
+	skb->dev = NULL;
+	
+	if(skb_tailroom(skb) < pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN) {
+		printk(KERN_WARNING "klips_error:pfkey_upmsg: "
+		       "tried to skb_put %ld, %d available.  "
+		       "This should never happen, please report.\n",
+		       (unsigned long int)pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN,
+		       skb_tailroom(skb));
+#ifdef NET_21
+		kfree_skb(skb);
+#else /* NET_21 */
+		kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+		return -ENOBUFS;
+	}
+	skb->h.raw = skb_put(skb, pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN);
+	memcpy(skb->h.raw, pfkey_msg, pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN);
+
+#ifndef NET_21
+	skb->free = 1;
+#endif /* !NET_21 */
+
+	if((error = sock_queue_rcv_skb(sk, skb)) < 0) {
+		skb->sk=NULL;
+#ifdef NET_21
+		kfree_skb(skb);
+#else /* NET_21 */
+		kfree_skb(skb, FREE_WRITE);
+#endif /* NET_21 */
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_upmsg: "
+			    "error=%d calling sock_queue_rcv_skb with skb=%p.\n",
+			    error, skb);
+		return error;
+	}
+	return 0;
+}
+
+DEBUG_NO_STATIC int
+pfkey_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_create: socket NULL.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_create: sock=%p type:%d state:%d flags:%ld protocol:%d\n",
+		    sock,
+		    sock->type,
+		    (unsigned int)(sock->state),
+		    sock->flags, protocol);
+
+	if(sock->type != SOCK_RAW) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_create: only SOCK_RAW supported.\n");
+		return -ESOCKTNOSUPPORT;
+	}
+
+	if(protocol != PF_KEY_V2) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_create: protocol not PF_KEY_V2.\n");
+		return -EPROTONOSUPPORT;
+	}
+
+	if((current->uid != 0)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_create: must be root to open pfkey sockets.\n");
+		return -EACCES;
+	}
+
+#ifdef NET_21
+	sock->state = SS_UNCONNECTED;
+#endif /* NET_21 */
+	MOD_INC_USE_COUNT;
+#ifdef NET_21
+	if((sk=(struct sock *)sk_alloc(PF_KEY, GFP_KERNEL, 1)) == NULL)
+#else /* NET_21 */
+	if((sk=(struct sock *)sk_alloc(GFP_KERNEL)) == NULL)
+#endif /* NET_21 */
+	{
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_create: Out of memory trying to allocate.\n");
+		MOD_DEC_USE_COUNT;
+		return -ENOMEM;
+	}
+
+#ifndef NET_21
+	memset(sk, 0, sizeof(*sk));
+#endif /* !NET_21 */
+
+#ifdef NET_21
+	sock_init_data(sock, sk);
+
+	sk->destruct = NULL;
+	sk->reuse = 1;
+	sock->ops = &SOCKOPS_WRAPPED(pfkey_ops);
+
+	sk->zapped=0;
+	sk->family = PF_KEY;
+/*	sk->num = protocol; */
+	sk->protocol = protocol;
+	key_pid(sk) = current->pid;
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_create: sock->fasync_list=%p sk->sleep=%p.\n",
+		    sock->fasync_list,
+		    sk->sleep);
+#else /* NET_21 */
+	sk->type=sock->type;
+	init_timer(&sk->timer);
+	skb_queue_head_init(&sk->write_queue);
+	skb_queue_head_init(&sk->receive_queue);
+	skb_queue_head_init(&sk->back_log);
+	sk->rcvbuf=SK_RMEM_MAX;
+	sk->sndbuf=SK_WMEM_MAX;
+	sk->allocation=GFP_KERNEL;
+	sk->state=TCP_CLOSE;
+	sk->priority=SOPRI_NORMAL;
+	sk->state_change=pfkey_state_change;
+	sk->data_ready=pfkey_data_ready;
+	sk->write_space=pfkey_write_space;
+	sk->error_report=pfkey_state_change;
+	sk->mtu=4096;
+	sk->socket=sock;
+	sock->data=(void *)sk;
+	sk->sleep=sock->wait;
+#endif /* NET_21 */
+
+	pfkey_insert_socket(sk);
+	pfkey_list_insert_socket(sock, &pfkey_open_sockets);
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_create: Socket sock=%p sk=%p initialised.\n", sock, sk);
+	return 0;
+}
+
+#ifndef NET_21
+DEBUG_NO_STATIC int
+pfkey_dup(struct socket *newsock, struct socket *oldsock)
+{
+	struct sock *sk;
+
+	if(newsock==NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_dup: No new socket attached.\n");
+		return -EINVAL;
+	}
+		
+	if(oldsock==NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_dup: No old socket attached.\n");
+		return -EINVAL;
+	}
+		
+#ifdef NET_21
+	sk=oldsock->sk;
+#else /* NET_21 */
+	sk=oldsock->data;
+#endif /* NET_21 */
+	
+	/* May not have data attached */
+	if(sk==NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_dup: No sock attached to old socket.\n");
+		return -EINVAL;
+	}
+		
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_dup: .\n");
+
+	return pfkey_create(newsock, sk->protocol);
+}
+#endif /* !NET_21 */
+
+DEBUG_NO_STATIC int
+#ifdef NETDEV_23
+pfkey_release(struct socket *sock)
+#else
+pfkey_release(struct socket *sock, struct socket *peersock)
+#endif
+{
+	struct sock *sk;
+	int i;
+
+	if(sock==NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_release: No socket attached.\n");
+		return 0; /* -EINVAL; */
+	}
+		
+#ifdef NET_21
+	sk=sock->sk;
+#else /* NET_21 */
+	sk=sock->data;
+#endif /* NET_21 */
+	
+	/* May not have data attached */
+	if(sk==NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_release: No sk attached to sock=%p.\n", sock);
+		return 0; /* -EINVAL; */
+	}
+		
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_release: .sock=%p sk=%p\n", sock, sk);
+
+#ifdef NET_21
+	if(!sk->dead)
+#endif /* NET_21 */
+		if(sk->state_change) {
+			sk->state_change(sk);
+		}
+
+#ifdef NET_21
+	sock->sk = NULL;
+#else /* NET_21 */
+	sock->data = NULL;
+#endif /* NET_21 */
+
+	/* Try to flush out this socket. Throw out buffers at least */
+	pfkey_destroy_socket(sk);
+	pfkey_list_remove_socket(sock, &pfkey_open_sockets);
+	for(i = SADB_SATYPE_UNSPEC; i <= SADB_SATYPE_MAX; i++) {
+		pfkey_list_remove_socket(sock, &(pfkey_registered_sockets[i]));
+	}
+
+	MOD_DEC_USE_COUNT;
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_release: succeeded.\n");
+
+	return 0;
+}
+
+#ifndef NET_21
+DEBUG_NO_STATIC int
+pfkey_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_bind: operation not supported.\n");
+	return -EINVAL;
+}
+
+DEBUG_NO_STATIC int
+pfkey_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_connect: operation not supported.\n");
+	return -EINVAL;
+}
+
+DEBUG_NO_STATIC int
+pfkey_socketpair(struct socket *a, struct socket *b)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_socketpair: operation not supported.\n");
+	return -EINVAL;
+}
+
+DEBUG_NO_STATIC int
+pfkey_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_aaccept: operation not supported.\n");
+	return -EINVAL;
+}
+
+DEBUG_NO_STATIC int
+pfkey_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len,
+		int peer)
+{
+	struct sockaddr *ska = (struct sockaddr*)uaddr;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_getname: .\n");
+	ska->sa_family = PF_KEY;
+	*uaddr_len = sizeof(*ska);
+	return 0;
+}
+
+DEBUG_NO_STATIC int
+pfkey_select(struct socket *sock, int sel_type, select_table *wait)
+{
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_select: .sock=%p sk=%p sel_type=%d\n",
+		    sock,
+		    sock->data,
+		    sel_type);
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_select: Null socket passed in.\n");
+		return -EINVAL;
+	}
+	return datagram_select(sock->data, sel_type, wait);
+}
+
+DEBUG_NO_STATIC int
+pfkey_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_ioctl: not supported.\n");
+	return -EINVAL;
+}
+
+DEBUG_NO_STATIC int
+pfkey_listen(struct socket *sock, int backlog)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_listen: not supported.\n");
+	return -EINVAL;
+}
+#endif /* !NET_21 */
+
+DEBUG_NO_STATIC int
+pfkey_shutdown(struct socket *sock, int mode)
+{
+	struct sock *sk;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_shutdown: NULL socket passed in.\n");
+		return -EINVAL;
+	}
+
+#ifdef NET_21
+	sk=sock->sk;
+#else /* NET_21 */
+	sk=sock->data;
+#endif /* NET_21 */
+	
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_shutdown: No sock attached to socket.\n");
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_shutdown: mode=%x.\n", mode);
+	mode++;
+	
+	if(mode&SEND_SHUTDOWN) {
+		sk->shutdown|=SEND_SHUTDOWN;
+		sk->state_change(sk);
+	}
+
+	if(mode&RCV_SHUTDOWN) {
+		sk->shutdown|=RCV_SHUTDOWN;
+		sk->state_change(sk);
+	}
+	return 0;
+}
+
+#ifndef NET_21
+DEBUG_NO_STATIC int
+pfkey_setsockopt(struct socket *sock, int level, int optname, char *optval, int optlen)
+{
+#ifndef NET_21
+	struct sock *sk;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_setsockopt: Null socket passed in.\n");
+		return -EINVAL;
+	}
+	
+	sk=sock->data;
+	
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_setsockopt: Null sock passed in.\n");
+		return -EINVAL;
+	}
+#endif /* !NET_21 */
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_setsockopt: .\n");
+	if(level!=SOL_SOCKET) {
+		return -EOPNOTSUPP;
+	}
+#ifdef NET_21
+	return sock_setsockopt(sock, level, optname, optval, optlen);
+#else /* NET_21 */
+	return sock_setsockopt(sk, level, optname, optval, optlen);
+#endif /* NET_21 */
+}
+
+DEBUG_NO_STATIC int
+pfkey_getsockopt(struct socket *sock, int level, int optname, char *optval, int *optlen)
+{
+#ifndef NET_21
+	struct sock *sk;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_setsockopt: Null socket passed in.\n");
+		return -EINVAL;
+	}
+	
+	sk=sock->data;
+	
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_setsockopt: Null sock passed in.\n");
+		return -EINVAL;
+	}
+#endif /* !NET_21 */
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_getsockopt: .\n");
+	if(level!=SOL_SOCKET) {
+		return -EOPNOTSUPP;
+	}
+#ifdef NET_21
+	return sock_getsockopt(sock, level, optname, optval, optlen);
+#else /* NET_21 */
+	return sock_getsockopt(sk, level, optname, optval, optlen);
+#endif /* NET_21 */
+}
+
+DEBUG_NO_STATIC int
+pfkey_fcntl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_fcntl: "
+		    "not supported.\n");
+	return -EINVAL;
+}
+#endif /* !NET_21 */
+
+/*
+ *	Send PF_KEY data down.
+ */
+		
+DEBUG_NO_STATIC int
+#ifdef NET_21
+pfkey_sendmsg(struct socket *sock, struct msghdr *msg, int len, struct scm_cookie *scm)
+#else /* NET_21 */
+pfkey_sendmsg(struct socket *sock, struct msghdr *msg, int len, int nonblock, int flags)
+#endif /* NET_21 */
+{
+	struct sock *sk;
+	int error = 0;
+	struct sadb_msg *pfkey_msg = NULL, *pfkey_reply = NULL;
+	
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "Null socket passed in.\n");
+		SENDERR(EINVAL);
+	}
+	
+#ifdef NET_21
+	sk = sock->sk;
+#else /* NET_21 */
+	sk = sock->data;
+#endif /* NET_21 */
+
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "Null sock passed in.\n");
+		SENDERR(EINVAL);
+	}
+	
+	if(msg == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "Null msghdr passed in.\n");
+		SENDERR(EINVAL);
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_sendmsg: .\n");
+	if(sk->err) {
+		error = sock_error(sk);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "sk->err is non-zero, returns %d.\n",
+			    error);
+		SENDERR(-error);
+	}
+
+	if((current->uid != 0)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "must be root to send messages to pfkey sockets.\n");
+		SENDERR(EACCES);
+	}
+
+#ifdef NET_21
+	if(msg->msg_control)
+#else /* NET_21 */
+	if(flags || msg->msg_control)
+#endif /* NET_21 */
+	{
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "can't set flags or set msg_control.\n");
+		SENDERR(EINVAL);
+	}
+		
+	if(sk->shutdown & SEND_SHUTDOWN) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "shutdown.\n");
+		send_sig(SIGPIPE, current, 0);
+		SENDERR(EPIPE);
+	}
+	
+	if(len < sizeof(struct sadb_msg)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "bogus msg len of %d, too small.\n", len);
+		SENDERR(EMSGSIZE);
+	}
+
+	if((pfkey_msg = (struct sadb_msg*)kmalloc(len, GFP_KERNEL)) == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "memory allocation error.\n");
+		SENDERR(ENOBUFS);
+	}
+
+	memcpy_fromiovec((void *)pfkey_msg, msg->msg_iov, len);
+
+	if(pfkey_msg->sadb_msg_version != PF_KEY_V2) {
+		KLIPS_PRINT(1 || debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "not PF_KEY_V2 msg, found %d, should be %d.\n",
+			    pfkey_msg->sadb_msg_version,
+			    PF_KEY_V2);
+		kfree((void*)pfkey_msg);
+		return -EINVAL;
+	}
+
+	if(len != pfkey_msg->sadb_msg_len * IPSEC_PFKEYv2_ALIGN) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "bogus msg len of %d, not %d byte aligned.\n",
+			    len, IPSEC_PFKEYv2_ALIGN);
+		SENDERR(EMSGSIZE);
+	}
+
+	/* check PID */
+	if(pfkey_msg->sadb_msg_pid != current->pid) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "pid (%d) does not equal sending process pid (%d).\n",
+			    pfkey_msg->sadb_msg_pid, current->pid);
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_msg->sadb_msg_reserved) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "reserved field must be zero, set to %d.\n",
+			    pfkey_msg->sadb_msg_reserved);
+		SENDERR(EINVAL);
+	}
+	
+	if((pfkey_msg->sadb_msg_type > SADB_MAX) || (!pfkey_msg->sadb_msg_type)){
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: "
+			    "msg type too large or small:%d.\n",
+			    pfkey_msg->sadb_msg_type);
+		SENDERR(EINVAL);
+	}
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_sendmsg: "
+		    "msg sent for parsing.\n");
+	
+	if((error = pfkey_msg_interp(sk, pfkey_msg, &pfkey_reply))) {
+		struct socket_list *pfkey_socketsp;
+
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_sendmsg: "
+			    "pfkey_msg_parse returns %d.\n",
+			    error);
+
+		if((pfkey_reply = (struct sadb_msg*)kmalloc(sizeof(struct sadb_msg), GFP_KERNEL)) == NULL) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_sendmsg: "
+				    "memory allocation error.\n");
+			SENDERR(ENOBUFS);
+		}
+		memcpy((void*)pfkey_reply, (void*)pfkey_msg, sizeof(struct sadb_msg));
+		pfkey_reply->sadb_msg_errno = -error;
+		pfkey_reply->sadb_msg_len = sizeof(struct sadb_msg) / IPSEC_PFKEYv2_ALIGN;
+
+		for(pfkey_socketsp = pfkey_open_sockets;
+		    pfkey_socketsp;
+		    pfkey_socketsp = pfkey_socketsp->next) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_sendmsg: "
+				    "sending up error=%d message=%p to socket=%p.\n",
+				    error,
+				    pfkey_reply,
+				    pfkey_socketsp->socketp);
+			if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+				KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_sendmsg: "
+					    "sending up error message to socket=%p failed with error=%d.\n",
+					    pfkey_socketsp->socketp, error);
+				pfkey_msg_free(&pfkey_reply);
+				goto errlab;
+			}
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_sendmsg: "
+				    "sending up error message to socket=%p succeeded.\n",
+				    pfkey_socketsp->socketp);
+		}
+		
+		pfkey_msg_free(&pfkey_reply);
+		
+		SENDERR(-error);
+	}
+
+ errlab:
+	if (pfkey_msg) {
+		kfree((void*)pfkey_msg);
+	}
+	
+	if(error) {
+		return error;
+	} else {
+		return len;
+	}
+}
+
+/*
+ *	Receive PF_KEY data up.
+ */
+		
+DEBUG_NO_STATIC int
+#ifdef NET_21
+pfkey_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags, struct scm_cookie *scm)
+#else /* NET_21 */
+pfkey_recvmsg(struct socket *sock, struct msghdr *msg, int size, int noblock, int flags, int *addr_len)
+#endif /* NET_21 */
+{
+	struct sock *sk;
+#ifdef NET_21
+	int noblock = flags & MSG_DONTWAIT;
+#endif /* NET_21 */
+	struct sk_buff *skb;
+	int error;
+
+	if(sock == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_recvmsg: Null socket passed in.\n");
+		return -EINVAL;
+	}
+
+#ifdef NET_21
+	sk = sock->sk;
+#else /* NET_21 */
+	sk = sock->data;
+#endif /* NET_21 */
+
+	if(sk == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_recvmsg: Null sock passed in for sock=%p.\n", sock);
+		return -EINVAL;
+	}
+
+	if(msg == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_recvmsg: Null msghdr passed in for sock=%p, sk=%p.\n",
+			    sock, sk);
+		return -EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_recvmsg: sock=%p sk=%p msg=%p size=%d.\n",
+		    sock, sk, msg, size);
+	if(flags & ~MSG_PEEK) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: flags (%d) other than MSG_PEEK not supported.\n",
+			    flags);
+		return -EOPNOTSUPP;
+	}
+		
+#ifdef NET_21
+	msg->msg_namelen = 0; /* sizeof(*ska); */
+#else /* NET_21 */
+	if(addr_len) {
+		*addr_len = 0; /* sizeof(*ska); */
+	}
+#endif /* NET_21 */
+		
+	if(sk->err) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sendmsg: sk->err=%d.\n", sk->err);
+		return sock_error(sk);
+	}
+
+	if((skb = skb_recv_datagram(sk, flags, noblock, &error) ) == NULL) {
+                return error;
+	}
+
+	if(size > skb->len) {
+		size = skb->len;
+	}
+#ifdef NET_21
+	else if(size <skb->len) {
+		msg->msg_flags |= MSG_TRUNC;
+	}
+#endif /* NET_21 */
+
+	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, size);
+        sk->stamp=skb->stamp;
+
+	skb_free_datagram(sk, skb);
+	return size;
+}
+
+#ifdef NET_21
+struct net_proto_family pfkey_family_ops = {
+	PF_KEY,
+	pfkey_create
+};
+
+struct proto_ops SOCKOPS_WRAPPED(pfkey_ops) = {
+#ifdef NETDEV_23
+	family:		PF_KEY,
+	release:	pfkey_release,
+	bind:		sock_no_bind,
+	connect:	sock_no_connect,
+	socketpair:	sock_no_socketpair,
+	accept:		sock_no_accept,
+	getname:	sock_no_getname,
+	poll:		datagram_poll,
+	ioctl:		sock_no_ioctl,
+	listen:		sock_no_listen,
+	shutdown:	pfkey_shutdown,
+	setsockopt:	sock_no_setsockopt,
+	getsockopt:	sock_no_getsockopt,
+	sendmsg:	pfkey_sendmsg,
+	recvmsg:	pfkey_recvmsg,
+	mmap:		sock_no_mmap,
+#else
+	PF_KEY,
+	sock_no_dup,
+	pfkey_release,
+	sock_no_bind,
+	sock_no_connect,
+	sock_no_socketpair,
+	sock_no_accept,
+	sock_no_getname,
+	datagram_poll,
+	sock_no_ioctl,
+	sock_no_listen,
+	pfkey_shutdown,
+	sock_no_setsockopt,
+	sock_no_getsockopt,
+	sock_no_fcntl,
+	pfkey_sendmsg,
+	pfkey_recvmsg
+#endif
+};
+
+#ifdef NETDEV_23
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(pfkey, PF_KEY);
+#endif
+
+#else /* NET_21 */
+struct proto_ops pfkey_proto_ops = {
+	PF_KEY,
+	pfkey_create,
+	pfkey_dup,
+	pfkey_release,
+	pfkey_bind,
+	pfkey_connect,
+	pfkey_socketpair,
+	pfkey_accept,
+	pfkey_getname,
+	pfkey_select,
+	pfkey_ioctl,
+	pfkey_listen,
+	pfkey_shutdown,
+	pfkey_setsockopt,
+	pfkey_getsockopt,
+	pfkey_fcntl,
+	pfkey_sendmsg,
+	pfkey_recvmsg
+};
+#endif /* NET_21 */
+   
+#ifdef CONFIG_PROC_FS
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+pfkey_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef  PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	off_t pos=0;
+	off_t begin=0;
+	int len=0;
+	struct sock *sk=pfkey_sock_list;
+	
+#ifdef CONFIG_IPSEC_DEBUG
+	if(!sysctl_ipsec_debug_verbose) {
+#endif CONFIG_IPSEC_DEBUG
+	len+= sprintf(buffer,"    sock   pid   socket     next     prev e n p sndbf    Flags     Type St\n");
+#ifdef CONFIG_IPSEC_DEBUG
+	} else {
+	len+= sprintf(buffer,"    sock   pid d    sleep   socket     next     prev e r z n p sndbf    stamp    Flags     Type St\n");
+	}
+#endif CONFIG_IPSEC_DEBUG
+	
+	while(sk!=NULL) {
+#ifdef CONFIG_IPSEC_DEBUG
+		if(!sysctl_ipsec_debug_verbose) {
+#endif CONFIG_IPSEC_DEBUG
+		len+=sprintf(buffer+len,"%8p %5d %8p %8p %8p %d %d %d %5d %08lX %8X %2X\n",
+			     sk,
+			     key_pid(sk),
+			     sk->socket,
+			     sk->next,
+			     sk->prev,
+			     sk->err,
+			     sk->num,
+			     sk->protocol,
+			     sk->sndbuf,
+			     sk->socket->flags,
+			     sk->socket->type,
+			     sk->socket->state);
+#ifdef CONFIG_IPSEC_DEBUG
+		} else {
+		len+=sprintf(buffer+len,"%8p %5d %d %8p %8p %8p %8p %d %d %d %d %d %5d %d.%06d %08lX %8X %2X\n",
+			     sk,
+			     key_pid(sk),
+			     sk->dead,
+			     sk->sleep,
+			     sk->socket,
+			     sk->next,
+			     sk->prev,
+			     sk->err,
+			     sk->reuse,
+			     sk->zapped,
+			     sk->num,
+			     sk->protocol,
+			     sk->sndbuf,
+			     (unsigned int)sk->stamp.tv_sec,
+			     (unsigned int)sk->stamp.tv_usec,
+			     sk->socket->flags,
+			     sk->socket->type,
+			     sk->socket->state);
+		}
+#endif CONFIG_IPSEC_DEBUG
+		
+		pos=begin+len;
+		if(pos<offset)
+		{
+			len=0;
+			begin=pos;
+		}
+		if(pos>offset+length)
+			break;
+		sk=sk->next;
+	}
+	*start=buffer+(offset-begin);
+	len-=(offset-begin);
+	if(len>length)
+		len=length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+pfkey_supported_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef  PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	off_t pos=0;
+	off_t begin=0;
+	int len=0;
+	int satype;
+	struct supported_list *pfkey_supported_p;
+	
+	len+= sprintf(buffer,"satype exttype alg_id ivlen minbits maxbits\n");
+	
+	for(satype = SADB_SATYPE_UNSPEC; satype <= SADB_SATYPE_MAX; satype++) {
+		pfkey_supported_p = pfkey_supported_list[satype];
+		while(pfkey_supported_p) {
+			len+=sprintf(buffer+len,"    %2d      %2d     %2d   %3d     %3d     %3d\n",
+				     satype,
+				     pfkey_supported_p->supportedp->supported_alg_exttype,
+				     pfkey_supported_p->supportedp->supported_alg_id,
+				     pfkey_supported_p->supportedp->supported_alg_ivlen,
+				     pfkey_supported_p->supportedp->supported_alg_minbits,
+				     pfkey_supported_p->supportedp->supported_alg_maxbits);
+			
+			pos=begin+len;
+			if(pos<offset) {
+				len=0;
+				begin=pos;
+			}
+			if(pos>offset+length)
+				break;
+			pfkey_supported_p = pfkey_supported_p->next;
+		}
+	}
+	*start=buffer+(offset-begin);
+	len-=(offset-begin);
+	if(len>length)
+		len=length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+DEBUG_NO_STATIC
+#endif /* PROC_FS_2325 */
+int
+pfkey_registered_get_info(char *buffer, char **start, off_t offset, int length
+#ifndef  PROC_NO_DUMMY
+, int dummy
+#endif /* !PROC_NO_DUMMY */
+)
+{
+	off_t pos=0;
+	off_t begin=0;
+	int len=0;
+	int satype;
+	struct socket_list *pfkey_sockets;
+	
+	len+= sprintf(buffer,"satype   socket   pid       sk\n");
+	
+	for(satype = SADB_SATYPE_UNSPEC; satype <= SADB_SATYPE_MAX; satype++) {
+		pfkey_sockets = pfkey_registered_sockets[satype];
+		while(pfkey_sockets) {
+#ifdef NET_21
+			len+=sprintf(buffer+len,"    %2d %8p %5d %8p\n",
+				     satype,
+				     pfkey_sockets->socketp,
+				     key_pid(pfkey_sockets->socketp->sk),
+				     pfkey_sockets->socketp->sk);
+#else /* NET_21 */
+			len+=sprintf(buffer+len,"    %2d %8p   N/A %8p\n",
+				     satype,
+				     pfkey_sockets->socketp,
+#if 0
+				     key_pid((pfkey_sockets->socketp)->data),
+#endif
+				     (pfkey_sockets->socketp)->data);
+#endif /* NET_21 */
+			
+			pos=begin+len;
+			if(pos<offset) {
+				len=0;
+				begin=pos;
+			}
+			if(pos>offset+length)
+				break;
+			pfkey_sockets = pfkey_sockets->next;
+		}
+	}
+	*start=buffer+(offset-begin);
+	len-=(offset-begin);
+	if(len>length)
+		len=length;
+	return len;
+}
+
+#ifndef PROC_FS_2325
+struct proc_dir_entry proc_net_pfkey =
+{
+	0,
+	6, "pf_key",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	pfkey_get_info
+};
+struct proc_dir_entry proc_net_pfkey_supported =
+{
+	0,
+	16, "pf_key_supported",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	pfkey_supported_get_info
+};
+struct proc_dir_entry proc_net_pfkey_registered =
+{
+	0,
+	17, "pf_key_registered",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	pfkey_registered_get_info
+};
+#endif /* !PROC_FS_2325 */
+#endif /* CONFIG_PROC_FS */
+
+DEBUG_NO_STATIC int
+supported_add_all(int satype, struct supported supported[], int size)
+{
+	int i;
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:init_pfkey: "
+		    "sizeof(supported_init_<satype=%d>)[%d]/sizeof(struct supported)[%d]=%d.\n",
+		    satype,
+		    size,
+		    sizeof(struct supported),
+		    size/sizeof(struct supported));
+
+	for(i = 0; i < size / sizeof(struct supported); i++) {
+		
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:init_pfkey: "
+			    "i=%d inserting satype=%d exttype=%d id=%d ivlen=%d minbits=%d maxbits=%d.\n",
+			    i,
+			    satype,
+			    supported[i].supported_alg_exttype,
+			    supported[i].supported_alg_id,
+			    supported[i].supported_alg_ivlen,
+			    supported[i].supported_alg_minbits,
+			    supported[i].supported_alg_maxbits);
+			    
+		error |= pfkey_list_insert_supported(&(supported[i]),
+					    &(pfkey_supported_list[satype]));
+	}
+	return error;
+}
+
+DEBUG_NO_STATIC int
+supported_remove_all(int satype)
+{
+	int error = 0;
+	struct supported*supportedp;
+
+	while(pfkey_supported_list[satype]) {
+		supportedp = pfkey_supported_list[satype]->supportedp;
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:init_pfkey: "
+			    "removing satype=%d exttype=%d id=%d ivlen=%d minbits=%d maxbits=%d.\n",
+			    satype,
+			    supportedp->supported_alg_exttype,
+			    supportedp->supported_alg_id,
+			    supportedp->supported_alg_ivlen,
+			    supportedp->supported_alg_minbits,
+			    supportedp->supported_alg_maxbits);
+			    
+		error |= pfkey_list_remove_supported(supportedp,
+					    &(pfkey_supported_list[satype]));
+	}
+	return error;
+}
+
+int
+pfkey_init(void)
+{
+	int error = 0;
+	int i;
+	
+	static struct supported supported_init_ah[] = {
+		{SADB_EXT_SUPPORTED_AUTH, SADB_AALG_MD5HMAC, 0, 128, 128},
+		{SADB_EXT_SUPPORTED_AUTH, SADB_AALG_SHA1HMAC, 0, 160, 160}
+	};
+	static struct supported supported_init_esp[] = {
+		{SADB_EXT_SUPPORTED_AUTH, SADB_AALG_MD5HMAC, 0, 128, 128},
+		{SADB_EXT_SUPPORTED_AUTH, SADB_AALG_SHA1HMAC, 0, 160, 160},
+		{SADB_EXT_SUPPORTED_ENCRYPT, SADB_EALG_3DESCBC, 128, 168, 168}
+	};
+	static struct supported supported_init_ipip[] = {
+		{SADB_EXT_SUPPORTED_ENCRYPT, SADB_X_TALG_IPv4_in_IPv4, 0, 32, 32}
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+		, {SADB_EXT_SUPPORTED_ENCRYPT, SADB_X_TALG_IPv6_in_IPv4, 0, 128, 32}
+		, {SADB_EXT_SUPPORTED_ENCRYPT, SADB_X_TALG_IPv4_in_IPv6, 0, 32, 128}
+		, {SADB_EXT_SUPPORTED_ENCRYPT, SADB_X_TALG_IPv6_in_IPv6, 0, 128, 128}
+#endif
+	};
+#ifdef CONFIG_IPSEC_IPCOMP
+	static struct supported supported_init_ipcomp[] = {
+		{SADB_EXT_SUPPORTED_ENCRYPT, SADB_X_CALG_DEFLATE, 0, 1, 1}
+	};
+#endif /* CONFIG_IPSEC_IPCOMP */
+
+        printk(KERN_INFO "FreeS/WAN: initialising PF_KEY domain sockets.\n");
+
+	for(i = SADB_SATYPE_UNSPEC; i <= SADB_SATYPE_MAX; i++) {
+		pfkey_registered_sockets[i] = NULL;
+		pfkey_supported_list[i] = NULL;
+	}
+
+	supported_add_all(SADB_SATYPE_AH, supported_init_ah, sizeof(supported_init_ah));
+	supported_add_all(SADB_SATYPE_ESP, supported_init_esp, sizeof(supported_init_esp));
+#ifdef CONFIG_IPSEC_IPCOMP
+	supported_add_all(SADB_X_SATYPE_COMP, supported_init_ipcomp, sizeof(supported_init_ipcomp));
+#endif /* CONFIG_IPSEC_IPCOMP */
+	supported_add_all(SADB_X_SATYPE_IPIP, supported_init_ipip, sizeof(supported_init_ipip));
+
+#ifdef NET_21
+        sock_register(&pfkey_family_ops);
+#else /* NET_21 */
+        sock_register(pfkey_proto_ops.family, &pfkey_proto_ops);
+#endif /* NET_21 */
+
+#ifdef CONFIG_PROC_FS
+#  ifndef PROC_FS_2325
+#    ifdef PROC_FS_21
+	proc_register(proc_net, &proc_net_pfkey);
+	proc_register(proc_net, &proc_net_pfkey_supported);
+	proc_register(proc_net, &proc_net_pfkey_registered);
+#    else /* PROC_FS_21 */
+	proc_register_dynamic(&proc_net, &proc_net_pfkey);
+	proc_register_dynamic(&proc_net, &proc_net_pfkey_supported);
+	proc_register_dynamic(&proc_net, &proc_net_pfkey_registered);
+#    endif /* PROC_FS_21 */
+#  else /* !PROC_FS_2325 */
+	proc_net_create ("pf_key", 0, pfkey_get_info);
+	proc_net_create ("pf_key_supported", 0, pfkey_supported_get_info);
+	proc_net_create ("pf_key_registered", 0, pfkey_registered_get_info);
+#  endif /* !PROC_FS_2325 */
+#endif          /* CONFIG_PROC_FS */
+
+	return error;
+}
+
+int
+pfkey_cleanup(void)
+{
+	int error = 0;
+	
+        printk(KERN_INFO "FreeS/WAN: shutting down PF_KEY domain sockets.\n");
+#ifdef NET_21
+        sock_unregister(PF_KEY);
+#else /* NET_21 */
+        sock_unregister(pfkey_proto_ops.family);
+#endif /* NET_21 */
+
+	supported_remove_all(SADB_SATYPE_AH);
+	supported_remove_all(SADB_SATYPE_ESP);
+#ifdef CONFIG_IPSEC_IPCOMP
+	supported_remove_all(SADB_X_SATYPE_COMP);
+#endif /* CONFIG_IPSEC_IPCOMP */
+	supported_remove_all(SADB_X_SATYPE_IPIP);
+
+#ifdef CONFIG_PROC_FS
+#  ifndef PROC_FS_2325
+	if (proc_net_unregister(proc_net_pfkey.low_ino) != 0)
+		printk("klips_debug:pfkey_cleanup: cannot unregister /proc/net/pf_key\n");
+	if (proc_net_unregister(proc_net_pfkey_supported.low_ino) != 0)
+		printk("klips_debug:pfkey_cleanup: cannot unregister /proc/net/pf_key_supported\n");
+	if (proc_net_unregister(proc_net_pfkey_registered.low_ino) != 0)
+		printk("klips_debug:pfkey_cleanup: cannot unregister /proc/net/pf_key_registered\n");
+#  else /* !PROC_FS_2325 */
+	proc_net_remove ("pf_key");
+	proc_net_remove ("pf_key_supported");
+	proc_net_remove ("pf_key_registered");
+#  endif /* !PROC_FS_2325 */
+#endif          /* CONFIG_PROC_FS */
+
+	/* other module unloading cleanup happens here */
+	return error;
+}
+
+#ifdef MODULE
+#if 0
+int
+init_module(void)
+{
+	pfkey_init();
+	return 0;
+}
+
+void
+cleanup_module(void)
+{
+	pfkey_cleanup();
+}
+#endif /* 0 */
+#else /* MODULE */
+void
+pfkey_proto_init(struct net_proto *pro)
+{
+	pfkey_init();
+}
+#endif /* MODULE */
+
+/*
+ * $Log$
+ * Revision 1.49  2000/11/06 04:33:47  rgb
+ * Changed non-exported functions to DEBUG_NO_STATIC.
+ *
+ * Revision 1.48  2000/09/29 19:47:41  rgb
+ * Update copyright.
+ *
+ * Revision 1.47  2000/09/22 04:23:04  rgb
+ * Added more debugging to pfkey_upmsg() call from pfkey_sendmsg() error.
+ *
+ * Revision 1.46  2000/09/21 04:20:44  rgb
+ * Fixed array size off-by-one error.  (Thanks Svenning!)
+ *
+ * Revision 1.45  2000/09/20 04:01:26  rgb
+ * Changed static functions to DEBUG_NO_STATIC for revealing function names
+ * in oopsen.
+ *
+ * Revision 1.44  2000/09/19 00:33:17  rgb
+ * 2.0 fixes.
+ *
+ * Revision 1.43  2000/09/16 01:28:13  rgb
+ * Fixed use of 0 in p format warning.
+ *
+ * Revision 1.42  2000/09/16 01:09:41  rgb
+ * Fixed debug format warning for pointers that was expecting ints.
+ *
+ * Revision 1.41  2000/09/13 15:54:00  rgb
+ * Rewrote pfkey_get_info(), added pfkey_{supported,registered}_get_info().
+ * Moved supported algos add and remove to functions.
+ *
+ * Revision 1.40  2000/09/12 18:49:28  rgb
+ * Added IPIP tunnel and IPCOMP register support.
+ *
+ * Revision 1.39  2000/09/12 03:23:49  rgb
+ * Converted #if0 debugs to sysctl.
+ * Removed debug_pfkey initialisations that prevented no_debug loading or
+ * linking.
+ *
+ * Revision 1.38  2000/09/09 06:38:02  rgb
+ * Return positive errno in pfkey_reply error message.
+ *
+ * Revision 1.37  2000/09/08 19:19:09  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Clean-up of long-unused crud...
+ * Create pfkey error message on on failure.
+ * Give pfkey_list_{insert,remove}_{socket,supported}() some error
+ * checking.
+ *
+ * Revision 1.36  2000/09/01 18:49:38  rgb
+ * Reap experimental NET_21_ bits.
+ * Turned registered sockets list into an array of one list per satype.
+ * Remove references to deprecated sklist_{insert,remove}_socket.
+ * Removed leaking socket debugging code.
+ * Removed duplicate pfkey_insert_socket in pfkey_create.
+ * Removed all references to pfkey msg->msg_name, since it is not used for
+ * pfkey.
+ * Added a supported algorithms array lists, one per satype and registered
+ * existing algorithms.
+ * Fixed pfkey_list_{insert,remove}_{socket,support}() to allow change to
+ * list.
+ * Only send pfkey_expire() messages to sockets registered for that satype.
+ *
+ * Revision 1.35  2000/08/24 17:03:00  rgb
+ * Corrected message size error return code for PF_KEYv2.
+ * Removed downward error prohibition.
+ *
+ * Revision 1.34  2000/08/21 16:32:26  rgb
+ * Re-formatted for cosmetic consistency and readability.
+ *
+ * Revision 1.33  2000/08/20 21:38:24  rgb
+ * Added a pfkey_reply parameter to pfkey_msg_interp(). (Momchil)
+ * Extended the upward message initiation of pfkey_sendmsg(). (Momchil)
+ *
+ * Revision 1.32  2000/07/28 14:58:31  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.31  2000/05/16 03:04:00  rgb
+ * Updates for 2.3.99pre8 from MB.
+ *
+ * Revision 1.30  2000/05/10 19:22:21  rgb
+ * Use sklist private functions for 2.3.xx compatibility.
+ *
+ * Revision 1.29  2000/03/22 16:17:03  rgb
+ * Fixed SOCKOPS_WRAPPED macro for SMP (MB).
+ *
+ * Revision 1.28  2000/02/21 19:30:45  rgb
+ * Removed references to pkt_bridged for 2.3.47 compatibility.
+ *
+ * Revision 1.27  2000/02/14 21:07:00  rgb
+ * Fixed /proc/net/pf-key legend spacing.
+ *
+ * Revision 1.26  2000/01/22 03:46:59  rgb
+ * Fixed pfkey error return mechanism so that we are able to free the
+ * local copy of the pfkey_msg, plugging a memory leak and silencing
+ * the bad object free complaints.
+ *
+ * Revision 1.25  2000/01/21 06:19:44  rgb
+ * Moved pfkey_list_remove_socket() calls to before MOD_USE_DEC_COUNT.
+ * Added debugging to pfkey_upmsg.
+ *
+ * Revision 1.24  2000/01/10 16:38:23  rgb
+ * MB fixups for 2.3.x.
+ *
+ * Revision 1.23  1999/12/09 23:22:16  rgb
+ * Added more instrumentation for debugging 2.0 socket
+ * selection/reading.
+ * Removed erroneous 2.0 wait==NULL check bug in select.
+ *
+ * Revision 1.22  1999/12/08 20:32:16  rgb
+ * Tidied up 2.0.xx support, after major pfkey work, eliminating
+ * msg->msg_name twiddling in the process, since it is not defined
+ * for PF_KEYv2.
+ *
+ * Revision 1.21  1999/12/01 22:17:19  rgb
+ * Set skb->dev to zero on new skb in case it is a reused skb.
+ * Added check for skb_put overflow and freeing to avoid upmsg on error.
+ * Added check for wrong pfkey version and freeing to avoid upmsg on
+ * error.
+ * Shut off content dumping in pfkey_destroy.
+ * Added debugging message for size of buffer allocated for upmsg.
+ *
+ * Revision 1.20  1999/11/27 12:11:00  rgb
+ * Minor clean-up, enabling quiet operation of pfkey if desired.
+ *
+ * Revision 1.19  1999/11/25 19:04:21  rgb
+ * Update proc_fs code for pfkey to use dynamic registration.
+ *
+ * Revision 1.18  1999/11/25 09:07:17  rgb
+ * Implemented SENDERR macro for propagating error codes.
+ * Fixed error return code bug.
+ *
+ * Revision 1.17  1999/11/23 23:07:20  rgb
+ * Change name of pfkey_msg_parser to pfkey_msg_interp since it no longer
+ * parses. (PJO)
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ *
+ * Revision 1.16  1999/11/20 22:00:22  rgb
+ * Moved socketlist type declarations and prototypes for shared use.
+ * Renamed reformatted and generically extended for use by other socket
+ * lists pfkey_{del,add}_open_socket to pfkey_list_{remove,insert}_socket.
+ *
+ * Revision 1.15  1999/11/18 04:15:09  rgb
+ * Make pfkey_data_ready temporarily available for 2.2.x testing.
+ * Clean up pfkey_destroy_socket() debugging statements.
+ * Add Peter Onion's code to send messages up to all listening sockets.
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ * Replaced all kernel version macros to shorter, readable form.
+ * Added CONFIG_PROC_FS compiler directives in case it is shut off.
+ *
+ * Revision 1.14  1999/11/17 16:01:00  rgb
+ * Make pfkey_data_ready temporarily available for 2.2.x testing.
+ * Clean up pfkey_destroy_socket() debugging statements.
+ * Add Peter Onion's code to send messages up to all listening sockets.
+ * Changed #include "../../../lib/freeswan.h" to #include <freeswan.h>
+ * which works due to -Ilibfreeswan in the klips/net/ipsec/Makefile.
+ *
+ * Revision 1.13  1999/10/27 19:59:51  rgb
+ * Removed af_unix comments that are no longer relevant.
+ * Added debug prink statements.
+ * Added to the /proc output in pfkey_get_info.
+ * Made most functions non-static to enable oops tracing.
+ * Re-enable skb dequeueing and freeing.
+ * Fix skb_alloc() and skb_put() size bug in pfkey_upmsg().
+ *
+ * Revision 1.12  1999/10/26 17:05:42  rgb
+ * Complete re-ordering based on proto_ops structure order.
+ * Separated out proto_ops structures for 2.0.x and 2.2.x for clarity.
+ * Simplification to use built-in socket ops where possible for 2.2.x.
+ * Add shorter macros for compiler directives to visually clean-up.
+ * Add lots of sk skb dequeueing debugging statements.
+ * Added to the /proc output in pfkey_get_info.
+ *
+ * Revision 1.11  1999/09/30 02:55:10  rgb
+ * Bogus skb detection.
+ * Fix incorrect /proc/net/ipsec-eroute printk message.
+ *
+ * Revision 1.10  1999/09/21 15:22:13  rgb
+ * Temporary fix while I figure out the right way to destroy sockets.
+ *
+ * Revision 1.9  1999/07/08 19:19:44  rgb
+ * Fix pointer format warning.
+ * Fix missing member error under 2.0.xx kernels.
+ *
+ * Revision 1.8  1999/06/13 07:24:04  rgb
+ * Add more debugging.
+ *
+ * Revision 1.7  1999/06/10 05:24:17  rgb
+ * Clarified compiler directives.
+ * Renamed variables to reduce confusion.
+ * Used sklist_*_socket() kernel functions to simplify 2.2.x socket support.
+ * Added lots of sanity checking.
+ *
+ * Revision 1.6  1999/06/03 18:59:50  rgb
+ * More updates to 2.2.x socket support.  Almost works, oops at end of call.
+ *
+ * Revision 1.5  1999/05/25 22:44:05  rgb
+ * Start fixing 2.2 sockets.
+ *
+ * Revision 1.4  1999/04/29 15:21:34  rgb
+ * Move log to the end of the file.
+ * Eliminate min/max redefinition in #include <net/tcp.h>.
+ * Correct path for pfkey #includes
+ * Standardise an error return method.
+ * Add debugging instrumentation.
+ * Move message type checking to pfkey_msg_parse().
+ * Add check for errno incorrectly set.
+ * Add check for valid PID.
+ * Add check for reserved illegally set.
+ * Add check for message out of bounds.
+ *
+ * Revision 1.3  1999/04/15 17:58:07  rgb
+ * Add RCSID labels.
+ *
+ * Revision 1.2  1999/04/15 15:37:26  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.1.2.2  1999/04/13 20:37:12  rgb
+ * Header Title correction.
+ *
+ * Revision 1.1.2.1  1999/03/26 20:58:55  rgb
+ * Add pfkeyv2 support to KLIPS.
+ *
+ *
+ * RFC 2367
+ * PF_KEY_v2 Key Management API
+ */
diff -druN linux-noipsec/net/ipsec/pfkey_v2_parser.c linux/net/ipsec/pfkey_v2_parser.c
--- linux-noipsec/net/ipsec/pfkey_v2_parser.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/pfkey_v2_parser.c	Thu Nov 30 22:47:51 2000
@@ -0,0 +1,3433 @@
+/*
+ * RFC2367 PF_KEYv2 Key management API message parser
+ * Copyright (C) 1999  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/*
+ *		Template from klips/net/ipsec/ipsec/ipsec_netlink.c.
+ */
+
+char pfkey_v2_parser_c_version[] = "$Id$";
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef SPINLOCK
+#ifdef SPINLOCK_23
+#include <linux/spinlock.h> /* *lock* */
+#else /* SPINLOCK_23 */
+#include <asm/spinlock.h> /* *lock* */
+#endif /* SPINLOCK_23 */
+#endif /* SPINLOCK */
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#define ip_chk_addr inet_addr_type
+#define IS_MYADDR RTN_LOCAL
+#endif
+#include <asm/checksum.h>
+#include <net/ip.h>
+#ifdef NETLINK_SOCK
+#include <linux/netlink.h>
+#else
+#include <net/netlink.h>
+#endif
+
+#include <linux/random.h>	/* get_random_bytes() */
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+#include "ipsec_xform.h"
+#include "ipsec_ah.h"
+#include "ipsec_esp.h"
+#include "ipsec_tunnel.h"
+#include "ipsec_rcv.h"
+#include "ipcomp.h"
+
+#include <pfkeyv2.h>
+#include <pfkey.h>
+
+
+#define SENDERR(_x) do { error = -(_x); goto errlab; } while (0)
+
+#ifndef min
+#define min(a,b)	(((a)<(b))?(a):(b))
+#endif
+
+extern int des_set_key(caddr_t, caddr_t);
+
+struct sklist_t {
+	struct socket *sk;
+	struct sklist_t* next;
+} pfkey_sklist_head, *pfkey_sklist, *pfkey_sklist_prev;
+
+__u32 pfkey_msg_seq = 0;
+
+DEBUG_NO_STATIC int
+pfkey_alloc_tdb(struct tdb** tdb)
+{
+	int error = 0;
+	if(*tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_alloc_tdb: tdb struct already allocated\n");
+		SENDERR(EEXIST);
+	}
+
+	if((*tdb = kmalloc(sizeof(**tdb), GFP_ATOMIC) ) == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_alloc_tdb: memory allocation error\n");
+		SENDERR(ENOMEM);
+	}
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_alloc_tdb: "
+		    "allocated tdb struct=%p.\n", tdb);
+
+	memset((caddr_t)*tdb, 0, sizeof(**tdb));
+ errlab:
+	return(error);
+}
+
+DEBUG_NO_STATIC int
+pfkey_alloc_eroute(struct eroute** eroute)
+{
+	int error = 0;
+	if(*eroute) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_alloc_eroute: eroute struct already allocated\n");
+		SENDERR(EEXIST);
+	}
+
+	if((*eroute = kmalloc(sizeof(**eroute), GFP_ATOMIC) ) == NULL) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_alloc_eroute: memory allocation error\n");
+		SENDERR(ENOMEM);
+	}
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_alloc_eroute: "
+		    "allocated eroute struct=%p.\n", eroute);
+	memset((caddr_t)*eroute, 0, sizeof(**eroute));
+	(*eroute)->er_eaddr.sen_len =
+		(*eroute)->er_emask.sen_len = sizeof(struct sockaddr_encap);
+	(*eroute)->er_eaddr.sen_family =
+		(*eroute)->er_emask.sen_family = AF_ENCAP;
+	(*eroute)->er_eaddr.sen_type = SENT_IP4;
+	(*eroute)->er_emask.sen_type = 255;
+
+ errlab:
+	return(error);
+}
+
+DEBUG_NO_STATIC int
+pfkey_sa_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	struct sadb_sa *pfkey_sa = (struct sadb_sa *)pfkey_ext;
+	int error = 0;
+	struct tdb* tdbp;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_sa_process: .\n");
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sa_process: "
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	switch(pfkey_ext->sadb_ext_type) {
+	case SADB_EXT_SA:
+		tdbp = extr->tdb;
+		break;
+	case SADB_X_EXT_SA2:
+		if(pfkey_alloc_tdb(&(extr->tdb2)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		tdbp = extr->tdb2;
+		break;
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sa_process: invalid exttype=%d.\n",
+			    pfkey_ext->sadb_ext_type);
+		SENDERR(EINVAL);
+	}
+
+	tdbp->tdb_said.spi = pfkey_sa->sadb_sa_spi;
+	tdbp->tdb_replaywin = pfkey_sa->sadb_sa_replay;
+	tdbp->tdb_state = pfkey_sa->sadb_sa_state;
+	tdbp->tdb_flags = pfkey_sa->sadb_sa_flags;
+	tdbp->tdb_replaywin_lastseq = tdbp->tdb_replaywin_bitmap = 0;
+	
+	switch(tdbp->tdb_said.proto) {
+	case IPPROTO_AH:
+		tdbp->tdb_authalg = pfkey_sa->sadb_sa_auth;
+		tdbp->tdb_encalg = SADB_EALG_NONE;
+		break;
+	case IPPROTO_ESP:
+		tdbp->tdb_authalg = pfkey_sa->sadb_sa_auth;
+		tdbp->tdb_encalg = pfkey_sa->sadb_sa_encrypt;
+		break;
+	case IPPROTO_IPIP:
+		tdbp->tdb_authalg = AH_NONE;
+		tdbp->tdb_encalg = ESP_NONE;
+		break;
+#ifdef CONFIG_IPSEC_IPCOMP
+	case IPPROTO_COMP:
+		tdbp->tdb_authalg = AH_NONE;
+		tdbp->tdb_encalg = pfkey_sa->sadb_sa_encrypt;
+		break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+	case 0:
+		break;
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_sa_process: "
+			    "unknown proto=%d.\n",
+			    tdbp->tdb_said.proto);
+		SENDERR(EINVAL);
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_lifetime_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct sadb_lifetime *pfkey_lifetime = (struct sadb_lifetime *)pfkey_ext;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_lifetime_process: .\n");
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_lifetime_process: "
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	switch(pfkey_lifetime->sadb_lifetime_exttype) {
+	case SADB_EXT_LIFETIME_CURRENT:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_lifetime_process: "
+			    "lifetime_current not supported yet.\n");
+  		SENDERR(EINVAL);
+  		break;
+	case SADB_EXT_LIFETIME_HARD:
+		if(pfkey_lifetime->sadb_lifetime_allocations &&
+		   (!extr->tdb->tdb_lifetime_allocations_h ||
+		    (pfkey_lifetime->sadb_lifetime_allocations < extr->tdb->tdb_lifetime_allocations_h))) {
+			extr->tdb->tdb_lifetime_allocations_h =
+				pfkey_lifetime->sadb_lifetime_allocations;
+			if(!extr->tdb->tdb_lifetime_allocations_s &&
+			   (extr->tdb->tdb_lifetime_allocations_h < extr->tdb->tdb_lifetime_allocations_s)) {
+				extr->tdb->tdb_lifetime_allocations_s = extr->tdb->tdb_lifetime_allocations_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_bytes &&
+		   (!extr->tdb->tdb_lifetime_bytes_h ||
+		    (pfkey_lifetime->sadb_lifetime_bytes < extr->tdb->tdb_lifetime_bytes_h))) {
+			extr->tdb->tdb_lifetime_bytes_h =
+				pfkey_lifetime->sadb_lifetime_bytes;
+			if(!extr->tdb->tdb_lifetime_bytes_s &&
+			   (extr->tdb->tdb_lifetime_bytes_h < extr->tdb->tdb_lifetime_bytes_s)) {
+				extr->tdb->tdb_lifetime_bytes_s = extr->tdb->tdb_lifetime_bytes_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_addtime &&
+		   (!extr->tdb->tdb_lifetime_addtime_h ||
+		    (pfkey_lifetime->sadb_lifetime_addtime < extr->tdb->tdb_lifetime_addtime_h))) {
+			extr->tdb->tdb_lifetime_addtime_h =
+				pfkey_lifetime->sadb_lifetime_addtime;
+			if(extr->tdb->tdb_lifetime_addtime_s &&
+			   (extr->tdb->tdb_lifetime_addtime_h < extr->tdb->tdb_lifetime_addtime_s)) {
+				extr->tdb->tdb_lifetime_addtime_s = extr->tdb->tdb_lifetime_addtime_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_usetime &&
+		   (!extr->tdb->tdb_lifetime_usetime_h ||
+		    (pfkey_lifetime->sadb_lifetime_usetime < extr->tdb->tdb_lifetime_usetime_h))) {
+			extr->tdb->tdb_lifetime_usetime_h =
+				pfkey_lifetime->sadb_lifetime_usetime;
+			if(extr->tdb->tdb_lifetime_usetime_s &&
+			   (extr->tdb->tdb_lifetime_usetime_h < extr->tdb->tdb_lifetime_usetime_s)) {
+				extr->tdb->tdb_lifetime_usetime_s = extr->tdb->tdb_lifetime_usetime_h;
+			}
+		}
+		break;
+	case SADB_EXT_LIFETIME_SOFT:
+		if(pfkey_lifetime->sadb_lifetime_allocations &&
+		   (!extr->tdb->tdb_lifetime_allocations_s ||
+		    (pfkey_lifetime->sadb_lifetime_allocations < extr->tdb->tdb_lifetime_allocations_s))) {
+			extr->tdb->tdb_lifetime_allocations_s =
+				pfkey_lifetime->sadb_lifetime_allocations;
+			if(extr->tdb->tdb_lifetime_allocations_h &&
+			   (extr->tdb->tdb_lifetime_allocations_h < extr->tdb->tdb_lifetime_allocations_s)) {
+				extr->tdb->tdb_lifetime_allocations_s = extr->tdb->tdb_lifetime_allocations_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_bytes &&
+		   (!extr->tdb->tdb_lifetime_bytes_s ||
+		    (pfkey_lifetime->sadb_lifetime_bytes < extr->tdb->tdb_lifetime_bytes_s))) {
+			extr->tdb->tdb_lifetime_bytes_s =
+				pfkey_lifetime->sadb_lifetime_bytes;
+			if(extr->tdb->tdb_lifetime_bytes_h &&
+			   (extr->tdb->tdb_lifetime_bytes_h < extr->tdb->tdb_lifetime_bytes_s)) {
+				extr->tdb->tdb_lifetime_bytes_s = extr->tdb->tdb_lifetime_bytes_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_addtime &&
+		   (!extr->tdb->tdb_lifetime_addtime_s ||
+		    (pfkey_lifetime->sadb_lifetime_addtime < extr->tdb->tdb_lifetime_addtime_s))) {
+			extr->tdb->tdb_lifetime_addtime_s =
+				pfkey_lifetime->sadb_lifetime_addtime;
+			if(extr->tdb->tdb_lifetime_addtime_h &&
+			   (extr->tdb->tdb_lifetime_addtime_h < extr->tdb->tdb_lifetime_addtime_s)) {
+				extr->tdb->tdb_lifetime_addtime_s = extr->tdb->tdb_lifetime_addtime_h;
+			}
+		}
+		if(pfkey_lifetime->sadb_lifetime_usetime &&
+		   (!extr->tdb->tdb_lifetime_usetime_s ||
+		    (pfkey_lifetime->sadb_lifetime_usetime < extr->tdb->tdb_lifetime_usetime_s))) {
+			extr->tdb->tdb_lifetime_usetime_s =
+				pfkey_lifetime->sadb_lifetime_usetime;
+			if(extr->tdb->tdb_lifetime_usetime_h &&
+			   (extr->tdb->tdb_lifetime_usetime_h < extr->tdb->tdb_lifetime_usetime_s)) {
+				extr->tdb->tdb_lifetime_usetime_s = extr->tdb->tdb_lifetime_usetime_h;
+			}
+		}
+		break;
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_lifetime_process: invalid exttype=%d.\n",
+			    pfkey_ext->sadb_ext_type);
+		SENDERR(EINVAL);
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_address_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	int saddr_len = 0;
+	char ipaddr_txt[ADDRTOA_BUF];
+	unsigned char **sap;
+	struct sadb_address *pfkey_address = (struct sadb_address *)pfkey_ext;
+	struct sockaddr* s = (struct sockaddr*)((char*)pfkey_address + sizeof(*pfkey_address));
+	struct tdb* tdbp;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_address_process:\n");
+	
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process:\n"
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	switch(s->sa_family) {
+	case AF_INET:
+		saddr_len = sizeof(struct sockaddr_in);
+		addrtoa(((struct sockaddr_in*)s)->sin_addr, 0, ipaddr_txt, sizeof(ipaddr_txt));
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found address family=%d, AF_INET, %s.\n",
+			    s->sa_family, ipaddr_txt);
+		break;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	case AF_INET6:
+		saddr_len = sizeof(struct sockaddr_in6);
+		break;
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: s->sa_family=%d not supported.\n",
+			    s->sa_family);
+		SENDERR(EPFNOSUPPORT);
+	}
+	
+	switch(pfkey_address->sadb_address_exttype) {
+	case SADB_EXT_ADDRESS_SRC:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found src address.\n");
+		sap = (unsigned char **)&(extr->tdb->tdb_addr_s);
+		extr->tdb->tdb_addr_s_size = saddr_len;
+		break;
+	case SADB_EXT_ADDRESS_DST:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found dst address.\n");
+		sap = (unsigned char **)&(extr->tdb->tdb_addr_d);
+		extr->tdb->tdb_addr_d_size = saddr_len;
+		break;
+	case SADB_EXT_ADDRESS_PROXY:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found proxy address.\n");
+		sap = (unsigned char **)&(extr->tdb->tdb_addr_p);
+		extr->tdb->tdb_addr_p_size = saddr_len;
+		break;
+	case SADB_X_EXT_ADDRESS_DST2:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found 2nd dst address.\n");
+		if(pfkey_alloc_tdb(&(extr->tdb2)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		sap = (unsigned char **)&(extr->tdb2->tdb_addr_d);
+		extr->tdb2->tdb_addr_d_size = saddr_len;
+		break;
+	case SADB_X_EXT_ADDRESS_SRC_FLOW:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found src flow address.\n");
+		if(pfkey_alloc_eroute(&(extr->eroute)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		sap = (unsigned char **)&(extr->eroute->er_eaddr.sen_ip_src);
+		break;
+	case SADB_X_EXT_ADDRESS_DST_FLOW:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found dst flow address.\n");
+		if(pfkey_alloc_eroute(&(extr->eroute)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		sap = (unsigned char **)&(extr->eroute->er_eaddr.sen_ip_dst);
+		break;
+	case SADB_X_EXT_ADDRESS_SRC_MASK:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found src mask address.\n");
+		if(pfkey_alloc_eroute(&(extr->eroute)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		sap = (unsigned char **)&(extr->eroute->er_emask.sen_ip_src);
+		break;
+	case SADB_X_EXT_ADDRESS_DST_MASK:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: found dst mask address.\n");
+		if(pfkey_alloc_eroute(&(extr->eroute)) == ENOMEM) {
+			SENDERR(ENOMEM);
+		}
+		sap = (unsigned char **)&(extr->eroute->er_emask.sen_ip_dst);
+		break;
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_address_process: unrecognised ext_type=%d.\n",
+			    pfkey_address->sadb_address_exttype);
+		SENDERR(EINVAL);
+	}
+	
+	switch(pfkey_address->sadb_address_exttype) {
+	case SADB_EXT_ADDRESS_SRC:
+	case SADB_EXT_ADDRESS_DST:
+	case SADB_EXT_ADDRESS_PROXY:
+	case SADB_X_EXT_ADDRESS_DST2:
+		if(!(*sap = kmalloc(saddr_len, GFP_KERNEL))) {
+			SENDERR(ENOMEM);
+		}
+		memcpy(*sap, s, saddr_len);
+		break;
+	default:
+		if(s->sa_family	!= AF_INET) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_address_process: s->sa_family=%d not supported.\n",
+				    s->sa_family);
+			SENDERR(EPFNOSUPPORT);
+		}
+		(unsigned int)(*sap) = ((struct sockaddr_in*)s)->sin_addr.s_addr;
+#ifdef CONFIG_IPSEC_DEBUG
+		if(extr->eroute) {
+			char buf1[64], buf2[64];
+			if (debug_pfkey) {
+				subnettoa(extr->eroute->er_eaddr.sen_ip_src,
+					  extr->eroute->er_emask.sen_ip_src, 0, buf1, sizeof(buf1));
+				subnettoa(extr->eroute->er_eaddr.sen_ip_dst,
+					  extr->eroute->er_emask.sen_ip_dst, 0, buf2, sizeof(buf2));
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_address_parse: "
+					    "extr->eroute set to %s->%s\n",
+					    buf1, buf2);
+			}
+		}
+#endif /* CONFIG_IPSEC_DEBUG */
+	}
+
+	tdbp = extr->tdb;
+	switch(pfkey_address->sadb_address_exttype) {
+	case SADB_X_EXT_ADDRESS_DST2:
+		tdbp = extr->tdb2;
+	case SADB_EXT_ADDRESS_DST:
+		if(s->sa_family == AF_INET) {
+			tdbp->tdb_said.dst.s_addr = ((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr.s_addr;
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_address_process: tdbp->tdb_said.dst.s_addr=%08x,\n"
+				    "klips_debug:                     ((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr.s_addr=%08x,\n",
+				    tdbp->tdb_said.dst.s_addr,
+				    ((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr.s_addr
+				);
+			addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr,
+				0,
+				ipaddr_txt,
+				sizeof(ipaddr_txt));
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_address_process: tdb_said.dst set to %s.\n",
+				    ipaddr_txt);
+		} else {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_address_process: "
+				    "uh, tdb_said.dst doesn't do address family=%d yet, "
+				    "said will be invalid.\n",
+				    s->sa_family);
+		}
+	default:
+	}
+	
+	/* XXX check if port!=0 */
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_address_process: successful.\n");
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_key_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+        struct sadb_key *pfkey_key = (struct sadb_key *)pfkey_ext;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_key_process: .\n");
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_key_process: "
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+        switch(pfkey_key->sadb_key_exttype) {
+        case SADB_EXT_KEY_AUTH:
+                extr->tdb->tdb_key_bits_a = pfkey_key->sadb_key_bits;
+		if(!(extr->tdb->tdb_key_a = kmalloc(DIVUP(pfkey_key->sadb_key_bits, 8), GFP_KERNEL))) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_key_process: memory allocation error.\n");
+			SENDERR(ENOMEM);
+		}
+		memcpy(extr->tdb->tdb_key_a,
+		       (char*)pfkey_key + sizeof(struct sadb_key),
+		       DIVUP(pfkey_key->sadb_key_bits, 8));
+		break;
+	case SADB_EXT_KEY_ENCRYPT: /* Key(s) */
+		extr->tdb->tdb_key_bits_e = pfkey_key->sadb_key_bits;
+		if(!(extr->tdb->tdb_key_e = kmalloc(DIVUP(pfkey_key->sadb_key_bits, 8), GFP_KERNEL))) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_key_process: memory allocation error.\n");
+			SENDERR(ENOMEM);
+		}
+		memcpy(extr->tdb->tdb_key_e,
+		       (char*)pfkey_key + sizeof(struct sadb_key),
+		       DIVUP(pfkey_key->sadb_key_bits, 8));
+		break;
+	default:
+		SENDERR(EINVAL);
+ 	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_key_process: success.\n");
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_ident_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+        struct sadb_ident *pfkey_ident = (struct sadb_ident *)pfkey_ext;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_ident_process: .\n");
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_ident_process: "
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	switch(pfkey_ident->sadb_ident_exttype) {
+	case SADB_EXT_IDENTITY_SRC:
+		extr->tdb->tdb_ident_type_s = pfkey_ident->sadb_ident_type;
+		extr->tdb->tdb_ident_id_s = pfkey_ident->sadb_ident_id;
+		extr->tdb->tdb_ident_len_s = pfkey_ident->sadb_ident_len -
+			(sizeof(struct sadb_ident) / IPSEC_PFKEYv2_ALIGN);
+		if(extr->tdb->tdb_ident_len_s) {
+			if(!(extr->tdb->tdb_ident_data_s
+			     = kmalloc(pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN,
+				       GFP_KERNEL))) {
+				SENDERR(ENOMEM);
+			}
+			memcpy(extr->tdb->tdb_ident_data_s,
+			       (char*)pfkey_ident + sizeof(struct sadb_ident),
+			       pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN);
+		} else {
+			extr->tdb->tdb_ident_data_s = NULL;
+		}
+		break;
+	case SADB_EXT_IDENTITY_DST: /* Identity(ies) */
+		extr->tdb->tdb_ident_type_d = pfkey_ident->sadb_ident_type;
+		extr->tdb->tdb_ident_id_d = pfkey_ident->sadb_ident_id;
+		extr->tdb->tdb_ident_len_d = pfkey_ident->sadb_ident_len -
+			sizeof(struct sadb_ident) / IPSEC_PFKEYv2_ALIGN;
+		if(extr->tdb->tdb_ident_len_d) {
+			if(!(extr->tdb->tdb_ident_data_d
+			     = kmalloc(pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN,
+				       GFP_KERNEL))) {
+				SENDERR(ENOMEM);
+			}
+			memcpy(extr->tdb->tdb_ident_data_d,
+			       (char*)pfkey_ident + sizeof(struct sadb_ident),
+			       pfkey_ident->sadb_ident_len * IPSEC_PFKEYv2_ALIGN);
+		} else {
+			extr->tdb->tdb_ident_data_d = NULL;
+		}
+		break;
+	default:
+		SENDERR(EINVAL);
+ 	}
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_sens_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_sens_process: Sorry, I can't process exttype=%d yet.\n",
+		    pfkey_ext->sadb_ext_type);
+        SENDERR(EINVAL); /* don't process these yet */
+ errlab:
+        return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_prop_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_prop_process: Sorry, I can't process exttype=%d yet.\n",
+		    pfkey_ext->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+	
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_supported_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_supported_process: Sorry, I can't process exttype=%d yet.\n",
+		    pfkey_ext->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_spirange_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+        int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_spirange_process: .\n");
+/* errlab: */
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_kmprivate_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_x_kmprivate_process: Sorry, I can't process exttype=%d yet.\n",
+		    pfkey_ext->sadb_ext_type);
+	SENDERR(EINVAL); /* don't process these yet */
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_satype_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct sadb_x_satype *pfkey_x_satype = (struct sadb_x_satype *)pfkey_ext;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_x_satype_process: .\n");
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_x_satype_process: "
+			    "extr or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	if(pfkey_alloc_tdb(&(extr->tdb2)) == ENOMEM) {
+		SENDERR(ENOMEM);
+	}
+	if(!(extr->tdb2->tdb_said.proto = satype2proto(pfkey_x_satype->sadb_x_satype_satype))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_x_satype_process: proto lookup from satype=%d failed.\n",
+			    pfkey_x_satype->sadb_x_satype_satype);
+		SENDERR(EINVAL);
+	}
+
+errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_debug_process(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct sadb_x_debug *pfkey_x_debug = (struct sadb_x_debug *)pfkey_ext;
+
+	if(!pfkey_x_debug) {
+		printk("klips_debug:pfkey_x_debug_process: null pointer passed in\n");
+		SENDERR(EINVAL);
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_debug_process: .\n");
+
+#ifdef CONFIG_IPSEC_DEBUG
+		if(pfkey_x_debug->sadb_x_debug_netlink >>
+		   (sizeof(pfkey_x_debug->sadb_x_debug_netlink) * 8 - 1)) {
+			pfkey_x_debug->sadb_x_debug_netlink &=
+				~(1 << (sizeof(pfkey_x_debug->sadb_x_debug_netlink) * 8 -1));
+			debug_tunnel  |= pfkey_x_debug->sadb_x_debug_tunnel;
+			debug_netlink |= pfkey_x_debug->sadb_x_debug_netlink;
+			debug_xform   |= pfkey_x_debug->sadb_x_debug_xform;
+			debug_eroute  |= pfkey_x_debug->sadb_x_debug_eroute;
+			debug_spi     |= pfkey_x_debug->sadb_x_debug_spi;
+			debug_radij   |= pfkey_x_debug->sadb_x_debug_radij;
+			debug_esp     |= pfkey_x_debug->sadb_x_debug_esp;
+			debug_ah      |= pfkey_x_debug->sadb_x_debug_ah;
+			debug_rcv     |= pfkey_x_debug->sadb_x_debug_rcv;
+			debug_pfkey   |= pfkey_x_debug->sadb_x_debug_pfkey;
+#ifdef CONFIG_IPSEC_IPCOMP
+			sysctl_ipsec_debug_ipcomp  |= pfkey_x_debug->sadb_x_debug_ipcomp;
+#endif /* CONFIG_IPSEC_IPCOMP */
+			sysctl_ipsec_debug_verbose |= pfkey_x_debug->sadb_x_debug_verbose;
+			if(debug_netlink)
+				printk("klips_debug:pfkey_x_debug_process: set\n");
+		} else {
+			if(debug_netlink)
+				printk("klips_debug:pfkey_x_debug_process: unset\n");
+			debug_tunnel  &= pfkey_x_debug->sadb_x_debug_tunnel;
+			debug_netlink &= pfkey_x_debug->sadb_x_debug_netlink;
+			debug_xform   &= pfkey_x_debug->sadb_x_debug_xform;
+			debug_eroute  &= pfkey_x_debug->sadb_x_debug_eroute;
+			debug_spi     &= pfkey_x_debug->sadb_x_debug_spi;
+			debug_radij   &= pfkey_x_debug->sadb_x_debug_radij;
+			debug_esp     &= pfkey_x_debug->sadb_x_debug_esp;
+			debug_ah      &= pfkey_x_debug->sadb_x_debug_ah;
+			debug_rcv     &= pfkey_x_debug->sadb_x_debug_rcv;
+			debug_pfkey   &= pfkey_x_debug->sadb_x_debug_pfkey;
+#ifdef CONFIG_IPSEC_IPCOMP
+			sysctl_ipsec_debug_ipcomp  &= pfkey_x_debug->sadb_x_debug_ipcomp;
+#endif /* CONFIG_IPSEC_IPCOMP */
+			sysctl_ipsec_debug_verbose &= pfkey_x_debug->sadb_x_debug_verbose;
+		}
+#else /* CONFIG_IPSEC_DEBUG */
+		printk("klips_debug:pfkey_x_debug_process: debugging not enabled\n");
+		SENDERR(EINVAL);
+#endif /* CONFIG_IPSEC_DEBUG */
+	
+errlab:
+	return error;
+}
+
+
+DEBUG_NO_STATIC int
+pfkey_tdb_init(struct tdb *tdbp, struct sadb_ext **extensions)
+{
+        int i;
+        int error = 0;
+        char sa[SATOA_BUF];
+	char ipaddr_txt[ADDRTOA_BUF];
+	char ipaddr2_txt[ADDRTOA_BUF];
+	unsigned char kb[AHMD596_BLKLEN];
+
+	if(!tdbp) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_tdb_init: "
+			    "tdbp is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(tdbp->tdb_said, 0, sa, SATOA_BUF);
+
+        KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_tdb_init: (pfkey defined) called for SA:%s\n", sa);
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_tdb_init: calling init routine of %s%s%s\n",
+		    TDB_XFORM_NAME(tdbp));
+	
+	switch(tdbp->tdb_said.proto) {
+		
+#ifdef CONFIG_IPSEC_IPIP
+	case IPPROTO_IPIP: {
+		addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_s))->sin_addr,
+			0,
+			ipaddr_txt, sizeof(ipaddr_txt));
+		addrtoa(((struct sockaddr_in*)(tdbp->tdb_addr_d))->sin_addr,
+			0,
+			ipaddr2_txt, sizeof(ipaddr_txt));
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_tdb_init: "
+			    "(pfkey defined) IPIP tdb set for %s->%s.\n",
+			    ipaddr_txt,
+			    ipaddr2_txt);
+	}
+	break;
+#endif /* !CONFIG_IPSEC_IPIP */
+#ifdef CONFIG_IPSEC_AH
+	case IPPROTO_AH:
+		switch(tdbp->tdb_authalg) {
+# ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+		case AH_MD5: {
+			unsigned char *akp;
+			MD5_CTX *ictx;
+			MD5_CTX *octx;
+			
+			if(tdbp->tdb_key_bits_a != (AHMD596_KLEN * 8)) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_tdb_init: incorrect key size: %d bits"
+					    "-- must be %d bits\n"/*octets (bytes)\n"*/,
+					    tdbp->tdb_key_bits_a, AHMD596_KLEN * 8);
+				SENDERR(EINVAL);
+			}
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+					    "klips_debug:pfkey_tdb_init: hmac md5-96 key is 0x%08lx %08lx %08lx %08lx\n",
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+0)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+1)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+2)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+3)));
+#  endif
+			
+			tdbp->tdb_auth_bits = AHMD596_ALEN * 8;
+			
+			/* save the pointer to the key material */
+			akp = tdbp->tdb_key_a;
+			
+			if((tdbp->tdb_key_a = (caddr_t)
+			    kmalloc((tdbp->tdb_key_a_size = sizeof(struct md5_ctx)),
+				    GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+
+			for (i = 0; i < DIVUP(tdbp->tdb_key_bits_a, 8); i++) {
+				kb[i] = akp[i] ^ HMAC_IPAD;
+			}
+			for (; i < AHMD596_BLKLEN; i++) {
+				kb[i] = HMAC_IPAD;
+			}
+
+			ictx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->ictx);
+			MD5Init(ictx);
+			MD5Update(ictx, kb, AHMD596_BLKLEN);
+
+			for (i = 0; i < AHMD596_BLKLEN; i++) {
+				kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+			}
+
+			octx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->octx);
+			MD5Init(octx);
+			MD5Update(octx, kb, AHMD596_BLKLEN);
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: MD5 ictx=0x%08x %08x %08x %08x"
+				    " octx=0x%08x %08x %08x %08x\n",
+				    ((__u32*)ictx)[0],
+				    ((__u32*)ictx)[1],
+				    ((__u32*)ictx)[2],
+				    ((__u32*)ictx)[3],
+				    ((__u32*)octx)[0],
+				    ((__u32*)octx)[1],
+				    ((__u32*)octx)[2],
+				    ((__u32*)octx)[3] );
+#  endif
+			
+				/* zero key buffer -- paranoid */
+			memset(akp, 0, DIVUP(tdbp->tdb_key_bits_a, BITS_PER_OCTET));
+		}
+		break;
+# endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+# ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+		case AH_SHA: {
+			
+			unsigned char *akp;
+			SHA1_CTX *ictx;
+			SHA1_CTX *octx;
+			
+			if(tdbp->tdb_key_bits_a != (AHSHA196_KLEN * 8)) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_tdb_init: incorrect key size: %d bits"
+					    "-- must be %d bits\n"/*octets (bytes)\n"*/,
+					    tdbp->tdb_key_bits_a, AHSHA196_KLEN * 8);
+				SENDERR(EINVAL);
+			}
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: hmac sha1-96 key is 0x%08lx %08lx %08lx %08lx\n",
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+0)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+1)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+2)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+3)));
+#  endif
+			
+			tdbp->tdb_auth_bits = AHSHA196_ALEN * 8;
+			
+			/* save the pointer to the key material */
+			akp = tdbp->tdb_key_a;
+			
+			if((tdbp->tdb_key_a = (caddr_t)
+			    kmalloc((tdbp->tdb_key_a_size = sizeof(struct sha1_ctx)),
+				    GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+			
+			for (i = 0; i < DIVUP(tdbp->tdb_key_bits_a, 8); i++) {
+				kb[i] = akp[i] ^ HMAC_IPAD;
+			}
+			for (; i < AHMD596_BLKLEN; i++) {
+				kb[i] = HMAC_IPAD;
+			}
+
+			ictx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx);
+			SHA1Init(ictx);
+			SHA1Update(ictx, kb, AHSHA196_BLKLEN);
+
+			for (i = 0; i < AHSHA196_BLKLEN; i++) {
+				kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+			}
+
+			octx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->octx);
+			SHA1Init(octx);
+			SHA1Update(octx, kb, AHSHA196_BLKLEN);
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: SHA1 ictx=0x%08x %08x %08x %08x"
+				    " octx=0x%08x %08x %08x %08x\n", 
+				    ((__u32*)ictx)[0],
+				    ((__u32*)ictx)[1],
+				    ((__u32*)ictx)[2],
+				    ((__u32*)ictx)[3],
+				    ((__u32*)octx)[0],
+				    ((__u32*)octx)[1],
+				    ((__u32*)octx)[2],
+				    ((__u32*)octx)[3] );
+#  endif			
+				/* zero key buffer -- paranoid */
+			memset(akp, 0, DIVUP(tdbp->tdb_key_bits_a, BITS_PER_OCTET));
+		}
+		break;
+# endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+		default:
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_tdb_init: "
+				    "authalg=%d support not available in the kernel",
+				    tdbp->tdb_authalg);
+			SENDERR(EINVAL);
+		}
+	break;
+#endif /* CONFIG_IPSEC_AH */
+#ifdef CONFIG_IPSEC_ESP
+	case IPPROTO_ESP: {
+		unsigned char *akp, *ekp;
+		
+		switch(tdbp->tdb_encalg) {
+# ifdef CONFIG_IPSEC_ENC_3DES
+		case ESP_3DES:
+# endif /* CONFIG_IPSEC_ENC_3DES */
+# if defined(CONFIG_IPSEC_ENC_3DES)
+			if((tdbp->tdb_iv = (caddr_t)
+			    kmalloc((tdbp->tdb_iv_size = EMT_ESPDES_IV_SZ), GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+			get_random_bytes((void *)tdbp->tdb_iv, EMT_ESPDES_IV_SZ);
+			tdbp->tdb_iv_bits = tdbp->tdb_iv_size * 8;
+			break;
+# endif /* defined(CONFIG_IPSEC_ENC_3DES) */
+		case ESP_NONE:
+# ifdef CONFIG_IPSEC_ENC_NULL
+		case ESP_NULL:
+# endif /* CONFIG_IPSEC_ENC_NULL */
+			break;
+		default:
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_tdb_init: "
+				    "encalg=%d support not available in the kernel",
+				    tdbp->tdb_encalg);
+			SENDERR(EINVAL);
+		}
+		
+		switch(tdbp->tdb_encalg) {
+# ifdef CONFIG_IPSEC_ENC_3DES
+		case ESP_3DES:
+			if(tdbp->tdb_key_bits_e != (EMT_ESP3DES_KEY_SZ * 8)) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_tdb_init: incorrect encryption"
+					    "key size: %d bits -- must be %d bits\n"/*octets (bytes)\n"*/,
+					    tdbp->tdb_key_bits_e, EMT_ESP3DES_KEY_SZ * 8);
+				SENDERR(EINVAL);
+			}
+			
+			/* save encryption key pointer */
+			ekp = tdbp->tdb_key_e;
+			
+			if((tdbp->tdb_key_e = (caddr_t)
+			    kmalloc((tdbp->tdb_key_e_size = 3 * sizeof(struct des_eks)),
+				    GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+			
+			for(i = 0; i < 3; i++) {
+#  if 0 /* we don't really want to print these unless there are really big problems */
+				KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+					    "klips_debug:pfkey_tdb_init: 3des key %d/3 is 0x%08lx%08lx\n",
+					    i + 1,
+					    ntohl(*((__u32 *)tdbp->tdb_key_e + i * 2)),
+					    ntohl(*((__u32 *)tdbp->tdb_key_e + i * 2 + 1)));
+#  endif
+				error = des_set_key((caddr_t)ekp + EMT_ESPDES_KEY_SZ * i,
+						    (caddr_t)&((struct des_eks*)(tdbp->tdb_key_e))[i]);
+				if (error == -1)
+					printk("klips_debug:pfkey_tdb_init: parity error in des key %d/3\n", i + 1);
+				else if (error == -2)
+					printk("klips_debug:pfkey_tdb_init: illegal weak des key %d/3\n", i + 1);
+				if (error) {
+					memset(tdbp->tdb_key_e, 0, 3 * sizeof(struct des_eks));
+					kfree(tdbp->tdb_key_e);
+					memset(ekp, 0, DIVUP(tdbp->tdb_key_bits_e, BITS_PER_OCTET));
+					SENDERR(EINVAL);
+				}
+			}
+
+			/* paranoid */
+			memset(ekp, 0, DIVUP(tdbp->tdb_key_bits_e, BITS_PER_OCTET));
+			
+			break;
+# endif /* CONFIG_IPSEC_ENC_3DES */
+# ifdef CONFIG_IPSEC_ENC_NULL
+		case ESP_NULL:
+# endif /* CONFIG_IPSEC_ENC_NULL */
+		case ESP_NONE:
+			break;
+		default:
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_tdb_init: "
+				    "encalg=%d support not available in the kernel",
+				    tdbp->tdb_encalg);
+			SENDERR(EINVAL);
+		}
+		
+		switch(tdbp->tdb_authalg) {
+# ifdef CONFIG_IPSEC_AUTH_HMAC_MD5
+		case AH_MD5: {
+			MD5_CTX *ictx;
+			MD5_CTX *octx;
+
+			if(tdbp->tdb_key_bits_a != (AHMD596_KLEN * 8)) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_tdb_init: incorrect authorisation"
+					    " key size: %d bits -- must be %d bits\n"/*octets (bytes)\n"*/,
+					    tdbp->tdb_key_bits_a, AHMD596_KLEN * 8);
+				SENDERR(EINVAL);
+			}
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: hmac md5-96 key is 0x%08lx %08lx %08lx %08lx\n",
+				    ntohl(*(((__u32 *)(tdbp->tdb_key_a))+0)),
+				    ntohl(*(((__u32 *)(tdbp->tdb_key_a))+1)),
+				    ntohl(*(((__u32 *)(tdbp->tdb_key_a))+2)),
+				    ntohl(*(((__u32 *)(tdbp->tdb_key_a))+3)));
+#  endif
+			tdbp->tdb_auth_bits = AHMD596_ALEN * 8;
+			
+			/* save the pointer to the key material */
+			akp = tdbp->tdb_key_a;
+			
+			if((tdbp->tdb_key_a = (caddr_t)
+			    kmalloc((tdbp->tdb_key_a_size = sizeof(struct md5_ctx)),
+				    GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+			
+			for (i = 0; i < DIVUP(tdbp->tdb_key_bits_a, 8); i++) {
+				kb[i] = akp[i] ^ HMAC_IPAD;
+			}
+			for (; i < AHMD596_BLKLEN; i++) {
+				kb[i] = HMAC_IPAD;
+			}
+
+			ictx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->ictx);
+			MD5Init(ictx);
+			MD5Update(ictx, kb, AHMD596_BLKLEN);
+
+			for (i = 0; i < AHMD596_BLKLEN; i++) {
+				kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+			}
+
+			octx = &(((struct md5_ctx*)(tdbp->tdb_key_a))->octx);
+			MD5Init(octx);
+			MD5Update(octx, kb, AHMD596_BLKLEN);
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: MD5 ictx=0x%08x %08x %08x %08x"
+				    " octx=0x%08x %08x %08x %08x\n",
+				    ((__u32*)ictx)[0],
+				    ((__u32*)ictx)[1],
+				    ((__u32*)ictx)[2],
+				    ((__u32*)ictx)[3],
+				    ((__u32*)octx)[0],
+				    ((__u32*)octx)[1],
+				    ((__u32*)octx)[2],
+				    ((__u32*)octx)[3] );
+#  endif
+			/* paranoid */
+			memset(akp, 0, DIVUP(tdbp->tdb_key_bits_a, BITS_PER_OCTET));
+			break;
+		}
+# endif /* CONFIG_IPSEC_AUTH_HMAC_MD5 */
+# ifdef CONFIG_IPSEC_AUTH_HMAC_SHA1
+		case AH_SHA: {
+			SHA1_CTX *ictx;
+			SHA1_CTX *octx;
+
+			if(tdbp->tdb_key_bits_a != (AHSHA196_KLEN * 8)) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_tdb_init: incorrect authorisation"
+					    " key size: %d bits -- must be %d bits\n"/*octets (bytes)\n"*/,
+					    tdbp->tdb_key_bits_a, AHSHA196_KLEN * 8);
+				SENDERR(EINVAL);
+			}
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: hmac sha1-96 key is 0x%08lx %08lx %08lx %08lx\n",
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+0)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+1)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+2)),
+				    ntohl(*(((__u32 *)tdbp->tdb_key_a)+3)));
+#  endif
+			tdbp->tdb_auth_bits = AHSHA196_ALEN * 8;
+			
+			/* save the pointer to the key material */
+			akp = tdbp->tdb_key_a;
+
+			if((tdbp->tdb_key_a = (caddr_t)
+			    kmalloc((tdbp->tdb_key_a_size = sizeof(struct sha1_ctx)),
+				    GFP_ATOMIC)) == NULL) {
+				SENDERR(ENOMEM);
+			}
+			
+			for (i = 0; i < DIVUP(tdbp->tdb_key_bits_a, 8); i++) {
+				kb[i] = akp[i] ^ HMAC_IPAD;
+			}
+			for (; i < AHMD596_BLKLEN; i++) {
+				kb[i] = HMAC_IPAD;
+			}
+
+			ictx = &(((struct sha1_ctx*)(tdbp->tdb_key_a))->ictx);
+			SHA1Init(ictx);
+			SHA1Update(ictx, kb, AHSHA196_BLKLEN);
+
+			for (i = 0; i < AHSHA196_BLKLEN; i++) {
+				kb[i] ^= (HMAC_IPAD ^ HMAC_OPAD);
+			}
+
+			octx = &((struct sha1_ctx*)(tdbp->tdb_key_a))->octx;
+			SHA1Init(octx);
+			SHA1Update(octx, kb, AHSHA196_BLKLEN);
+			
+#  if 0 /* we don't really want to print these unless there are really big problems */
+			KLIPS_PRINT(debug_pfkey && sysctl_ipsec_debug_verbose,
+				    "klips_debug:pfkey_tdb_init: SHA1 ictx=0x%08x %08x %08x %08x"
+				    " octx=0x%08x %08x %08x %08x\n",
+				    ((__u32*)ictx)[0],
+				    ((__u32*)ictx)[1],
+				    ((__u32*)ictx)[2],
+				    ((__u32*)ictx)[3],
+				    ((__u32*)octx)[0],
+				    ((__u32*)octx)[1],
+				    ((__u32*)octx)[2],
+				    ((__u32*)octx)[3] );
+#  endif
+			memset(akp, 0, DIVUP(tdbp->tdb_key_bits_a, BITS_PER_OCTET));
+			break;
+		}
+# endif /* CONFIG_IPSEC_AUTH_HMAC_SHA1 */
+		case AH_NONE:
+			break;
+		default:
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_tdb_init: "
+				    "authalg=%d support not available in the kernel.\n",
+				    tdbp->tdb_authalg);
+			SENDERR(EINVAL);
+		}
+	}
+			break;
+#endif /* !CONFIG_IPSEC_ESP */
+#ifdef CONFIG_IPSEC_IPCOMP
+	case IPPROTO_COMP:
+		tdbp->tdb_comp_adapt_tries = 0;
+		tdbp->tdb_comp_adapt_skip = 0;
+		tdbp->tdb_comp_ratio_cbytes = 0;
+		tdbp->tdb_comp_ratio_dbytes = 0;
+		break;
+#endif /* CONFIG_IPSEC_IPCOMP */
+	default:
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_tdb_init: "
+			    "proto=%d unknown.\n",
+			    tdbp->tdb_said.proto);
+		SENDERR(EINVAL);
+	}
+	
+ errlab:
+	return(error);
+}
+
+
+int
+pfkey_safe_build(int error, struct sadb_ext *extensions[SADB_MAX+1])
+{
+	KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_safe_build: error=%d\n", error);
+	if (!error) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_safe_build:"
+			    "success.\n");
+		return 1;
+	} else {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_safe_build:"
+			    "caught error %d\n", error);
+		pfkey_extensions_free(extensions);
+		return 0;
+	}
+}
+
+
+DEBUG_NO_STATIC int
+pfkey_getspi_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	ipsec_spi_t minspi = htonl(256), maxspi = htonl(-1L);
+	int found_avail = 0;
+	struct tdb *tdbq;
+	char sa[SATOA_BUF];
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_getspi_parse: .\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_getspi_parse: error, extr or extr->tdb pointer NULL\n");
+		SENDERR(EINVAL);
+	}
+
+	if(extensions[SADB_EXT_SPIRANGE]) {
+		minspi = ((struct sadb_spirange *)extensions[SADB_EXT_SPIRANGE])->sadb_spirange_min;
+		maxspi = ((struct sadb_spirange *)extensions[SADB_EXT_SPIRANGE])->sadb_spirange_max;
+	}
+
+	if(maxspi == minspi) {
+		extr->tdb->tdb_said.spi = maxspi;
+		if((tdbq = gettdb(&(extr->tdb->tdb_said)))) {
+			satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug: pfkey_getspi_parse: EMT_GETSPI found an old Tunnel Descriptor Block\n"
+				    "klips_debug:                for SA: %s, delete it first.\n", sa);
+			SENDERR(EEXIST);
+		} else {
+			found_avail = 1;
+		}
+	} else {
+		int i = 0;
+		__u32 rand_val;
+		__u32 spi_diff;
+		while( ( i < (spi_diff = (ntohl(maxspi) - ntohl(minspi)))) && !found_avail ) {
+			get_random_bytes((void*) &(rand_val),
+					 /* sizeof(extr->tdb->tdb_said.spi) */
+					 ( (spi_diff < (2^8))  ? 1 :
+					   ( (spi_diff < (2^16)) ? 2 :
+					     ( (spi_diff < (2^24)) ? 3 :
+					   4 ) ) ) );
+			extr->tdb->tdb_said.spi = htonl(ntohl(minspi) +
+					      (rand_val %
+					      (spi_diff + 1)));
+			i++;
+			tdbq = gettdb(&(extr->tdb->tdb_said));
+			if(!tdbq) {
+				found_avail = 1;
+			}
+		}
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+
+	if (!found_avail) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_getspi_parse: found an old Tunnel Descriptor Block\n"
+			    "klips_debug:                for SA: %s, delete it first.\n", sa);
+		SENDERR(EEXIST);
+	}
+
+	if(ip_chk_addr((unsigned long)extr->tdb->tdb_said.dst.s_addr) == IS_MYADDR) {
+		extr->tdb->tdb_flags |= EMT_INBOUND;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_getspi_parse: existing Tunnel Descriptor Block not found (this\n"
+		    "klips_debug:                is good) for SA: %s, %s-bound, allocating.\n",
+		    sa, extr->tdb->tdb_flags & EMT_INBOUND ? "in" : "out");
+	
+	/* XXX extr->tdb->tdb_rcvif = &(enc_softc[em->em_if].enc_if);*/
+	extr->tdb->tdb_rcvif = NULL;
+	extr->tdb->tdb_lifetime_addtime_c = jiffies/HZ;
+
+	extr->tdb->tdb_state = SADB_SASTATE_LARVAL;
+
+	if(!extr->tdb->tdb_lifetime_allocations_c) {
+		extr->tdb->tdb_lifetime_allocations_c += 1;
+	}
+
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_GETSPI,
+							  satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply) &&
+	     pfkey_safe_build(pfkey_sa_build(&extensions_reply[SADB_EXT_SA],
+					     SADB_EXT_SA,
+					     extr->tdb->tdb_said.spi,
+					     0,
+					     SADB_SASTATE_LARVAL,
+					     0,
+					     0,
+					     0),
+			      extensions_reply) &&
+	     pfkey_safe_build(pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_SRC],
+						  SADB_EXT_ADDRESS_SRC,
+						  0, /*extr->tdb->tdb_said.proto,*/
+						  0,
+						  extr->tdb->tdb_addr_s),
+			      extensions_reply) &&
+	     pfkey_safe_build(pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_DST],
+						  SADB_EXT_ADDRESS_DST,
+						  0, /*extr->tdb->tdb_said.proto,*/
+						  0,
+						  extr->tdb->tdb_addr_d),
+			      extensions_reply) )) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_getspi_parse: "
+			    "failed to build the getspi reply message extensions\n");
+		goto errlab;
+	}
+	
+	if((error = puttdb(extr->tdb))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_getspi_parse: "
+			    "failed to add the larval SA with error=%d.\n",
+			    error);
+		goto errlab;
+	}
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_getspi_parse: successful for SA: %s\n", sa);
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_getspi_parse: "
+			    "failed to build the getspi reply message\n");
+		goto errlab;
+	}
+	for(pfkey_socketsp = pfkey_open_sockets;
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_getspi_parse: "
+				    "sending up getspi reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_getspi_parse: "
+			    "sending up getspi reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+
+ errlab:
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_update_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct tdb* tdbq;
+	char sa[SATOA_BUF];
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_update_parse: .\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	if(((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state != SADB_SASTATE_MATURE) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_update_parse: "
+			    "error, sa_state=%d must be MATURE=%d\n",
+			    ((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state,
+			    SADB_SASTATE_MATURE);
+		SENDERR(EINVAL);
+	}
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_update_parse: error, extr or extr->tdb pointer NULL\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+
+	spin_lock_bh(&tdb_lock);
+
+	tdbq = gettdb(&(extr->tdb->tdb_said));
+	if (!tdbq) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_update_parse: reserved Tunnel Descriptor Block\n"
+			    "klips_debug:            for SA: %s not found.  Call SADB_GETSPI first or call SADB_ADD instead.\n", sa);
+		SENDERR(EEXIST);
+	}
+
+	if(ip_chk_addr((unsigned long)extr->tdb->tdb_said.dst.s_addr) == IS_MYADDR) {
+		extr->tdb->tdb_flags |= EMT_INBOUND;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug: pfkey_update_parse: existing Tunnel Descriptor Block found (this\n"
+		    "klips_debug:                is good) for SA: %s, %s-bound, updating.\n",
+		    sa, extr->tdb->tdb_flags & EMT_INBOUND ? "in" : "out");
+	
+	/* XXX extr->tdb->tdb_rcvif = &(enc_softc[em->em_if].enc_if);*/
+	extr->tdb->tdb_rcvif = NULL;
+	if ((error = pfkey_tdb_init(extr->tdb, extensions))) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_update_parse: "
+			    "not successful for SA: %s, deleting.\n", sa);
+		ipsec_tdbwipe(extr->tdb);
+		SENDERR(-error);
+	}
+
+	extr->tdb->tdb_lifetime_addtime_c = tdbq->tdb_lifetime_addtime_c;
+	if((error = deltdbchain(tdbq))) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_update_parse: "
+			    "error=%d, trouble deleting intermediate tdb for SA=%s.\n",
+			    error, sa);
+		SENDERR(-error);
+	}
+
+	spin_unlock_bh(&tdb_lock);
+
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_UPDATE,
+							  satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply)
+	     && pfkey_safe_build(error = pfkey_sa_build(&extensions_reply[SADB_EXT_SA],
+							SADB_EXT_SA,
+							extr->tdb->tdb_said.spi,
+							extr->tdb->tdb_replaywin,
+							extr->tdb->tdb_state,
+							extr->tdb->tdb_authalg,
+							extr->tdb->tdb_encalg,
+							extr->tdb->tdb_flags),
+				 extensions_reply)
+	     /* FIXME: The 3 lifetime extentions should only be sent if
+		non-zero. */
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_CURRENT],
+							      SADB_EXT_LIFETIME_CURRENT,
+							      extr->tdb->tdb_lifetime_allocations_c,
+							      extr->tdb->tdb_lifetime_bytes_c,
+							      extr->tdb->tdb_lifetime_addtime_c,
+							      extr->tdb->tdb_lifetime_usetime_c),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_HARD],
+							      SADB_EXT_LIFETIME_HARD,
+							      extr->tdb->tdb_lifetime_allocations_h,
+							      extr->tdb->tdb_lifetime_bytes_h,
+							      extr->tdb->tdb_lifetime_addtime_h,
+							      extr->tdb->tdb_lifetime_usetime_h),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_SRC],
+							     SADB_EXT_ADDRESS_SRC,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_s),
+				 extensions_reply)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_DST],
+							     SADB_EXT_ADDRESS_DST,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_d),
+				 extensions_reply)
+#if 0
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_s ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_SRC],
+											 SADB_EXT_IDENTITY_SRC,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_s),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_d ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_DST],
+											 SADB_EXT_IDENTITY_DST,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_d),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_sens_ ? pfkey_safe_build(error = pfkey_sens_build(&extensions_reply[SADB_EXT_SENSITIVITY],
+										 extr->tdb->tdb_sens_dpd,
+										 extr->tdb->tdb_sens_sens_level,
+										 extr->tdb->tdb_sens_sens_len,
+										 extr->tdb->tdb_sens_sens_bitmap,
+										 extr->tdb->tdb_sens_integ_level,
+										 extr->tdb->tdb_sens_integ_len,
+										 extr->tdb->tdb_sens_integ_bitmap),
+							extensions_reply) : 1
+#endif
+		)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_update_parse: "
+			    "failed to build the update reply message extensions\n");
+		goto errlab;
+	}
+		
+	if((error = puttdb(extr->tdb))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_update_parse: "
+			    "failed to add the mature SA with error=%d.\n",
+			    error);
+		goto errlab;
+	}
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_update_parse: successful for SA: %s\n", sa);
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_update_parse: "
+			    "failed to build the update reply message\n");
+		goto errlab;
+	}
+	for(pfkey_socketsp = pfkey_open_sockets;
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_update_parse: "
+				    "sending up update reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_update_parse: "
+			    "sending up update reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_add_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct tdb* tdbq;
+	char sa[SATOA_BUF];
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_add_parse: parsing add message\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	if(((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state != SADB_SASTATE_MATURE) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_add_parse: "
+			    "error, sa_state=%d must be MATURE=%d\n",
+			    ((struct sadb_sa*)extensions[SADB_EXT_SA])->sadb_sa_state,
+			    SADB_SASTATE_MATURE);
+		SENDERR(EINVAL);
+	}
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_add_parse: extr or extr->tdb pointer NULL\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+
+	tdbq = gettdb(&(extr->tdb->tdb_said));
+	if (tdbq) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_add_parse: found an old Tunnel Descriptor Block\n"
+			    "klips_debug:                for SA: %s, delete it first.\n", sa);
+		SENDERR(EEXIST);
+	}
+
+	if(ip_chk_addr((unsigned long)extr->tdb->tdb_said.dst.s_addr) == IS_MYADDR) {
+		extr->tdb->tdb_flags |= EMT_INBOUND;
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_add_parse: existing Tunnel Descriptor Block not found (this\n"
+		    "klips_debug:                is good) for SA: %s, %s-bound, allocating.\n",
+		    sa, extr->tdb->tdb_flags & EMT_INBOUND ? "in" : "out");
+	
+	/* XXX extr->tdb->tdb_rcvif = &(enc_softc[em->em_if].enc_if);*/
+	extr->tdb->tdb_rcvif = NULL;
+	
+	if ((error = pfkey_tdb_init(extr->tdb, extensions))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_add_parse: not successful for SA: %s, deleting.\n", sa);
+		ipsec_tdbwipe(extr->tdb);
+		goto errlab;
+	}
+
+	extr->tdb->tdb_lifetime_addtime_c = jiffies / HZ;
+	if(!extr->tdb->tdb_lifetime_allocations_c) {
+		extr->tdb->tdb_lifetime_allocations_c += 1;
+	}
+
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_ADD,
+							  satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply)
+	     && pfkey_safe_build(error = pfkey_sa_build(&extensions_reply[SADB_EXT_SA],
+							SADB_EXT_SA,
+							extr->tdb->tdb_said.spi,
+							extr->tdb->tdb_replaywin,
+							extr->tdb->tdb_state,
+							extr->tdb->tdb_authalg,
+							extr->tdb->tdb_encalg,
+							extr->tdb->tdb_flags),
+				 extensions_reply)
+	     /* FIXME: The 3 lifetime extentions should only be sent if
+		non-zero. */
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_CURRENT],
+							      SADB_EXT_LIFETIME_CURRENT,
+							      extr->tdb->tdb_lifetime_allocations_c,
+							      extr->tdb->tdb_lifetime_bytes_c,
+							      extr->tdb->tdb_lifetime_addtime_c,
+							      extr->tdb->tdb_lifetime_usetime_c),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_HARD],
+							      SADB_EXT_LIFETIME_HARD,
+							      extr->tdb->tdb_lifetime_allocations_h,
+							      extr->tdb->tdb_lifetime_bytes_h,
+							      extr->tdb->tdb_lifetime_addtime_h,
+							      extr->tdb->tdb_lifetime_usetime_h),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_SRC],
+							     SADB_EXT_ADDRESS_SRC,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_s),
+				 extensions_reply)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_DST],
+							     SADB_EXT_ADDRESS_DST,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_d),
+				 extensions_reply)
+#if 0
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_s ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_SRC],
+											 SADB_EXT_IDENTITY_SRC,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_s),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_d ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_DST],
+											 SADB_EXT_IDENTITY_DST,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_d),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_sens_ ? pfkey_safe_build(error = pfkey_sens_build(&extensions_reply[SADB_EXT_SENSITIVITY],
+										 extr->tdb->tdb_sens_dpd,
+										 extr->tdb->tdb_sens_sens_level,
+										 extr->tdb->tdb_sens_sens_len,
+										 extr->tdb->tdb_sens_sens_bitmap,
+										 extr->tdb->tdb_sens_integ_level,
+										 extr->tdb->tdb_sens_integ_len,
+										 extr->tdb->tdb_sens_integ_bitmap),
+							extensions_reply) : 1
+#endif
+		)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_add_parse: "
+			    "failed to build the add reply message extensions\n");
+		goto errlab;
+	}
+		
+	if((error = puttdb(extr->tdb))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_add_parse: "
+			    "failed to add the mature SA with error=%d.\n",
+			    error);
+		goto errlab;
+	}
+	
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_add_parse: successful for SA: %s\n", sa);
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_add_parse: "
+			    "failed to build the add reply message\n");
+		goto errlab;
+	}
+	for(pfkey_socketsp = pfkey_open_sockets;
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_add_parse: "
+				    "sending up add reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_add_parse: "
+			    "sending up add reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_delete_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	struct tdb *tdbp;
+	char sa[SATOA_BUF];
+	int error = 0;
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_delete_parse: .\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_delete_parse: "
+			    "extr or extr->tdb pointer NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+
+	spin_lock_bh(&tdb_lock);
+
+	tdbp = gettdb(&(extr->tdb->tdb_said));
+	if (tdbp == NULL) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_delete_parse: "
+			    "Tunnel Descriptor Block not found for SA:%s, could not delete.\n",
+			    sa);
+		SENDERR(ESRCH);
+	}
+
+	if((error = deltdbchain(tdbp))) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_delete_parse: "
+			    "error=%d returned trying to delete Tunnel Descriptor Block for SA:%s.\n",
+			    error, sa);
+		SENDERR(-error);
+	}
+	spin_unlock_bh(&tdb_lock);
+
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_DELETE,
+							  satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply)
+	     && pfkey_safe_build(error = pfkey_sa_build(&extensions_reply[SADB_EXT_SA],
+							SADB_EXT_SA,
+							extr->tdb->tdb_said.spi,
+							0,
+							0,
+							0,
+							0,
+							0),
+				 extensions_reply)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_SRC],
+							     SADB_EXT_ADDRESS_SRC,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_s),
+				 extensions_reply)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_DST],
+							     SADB_EXT_ADDRESS_DST,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_d),
+				 extensions_reply)
+		)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_delete_parse: "
+			    "failed to build the delete reply message extensions\n");
+		goto errlab;
+	}
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_delete_parse: "
+			    "failed to build the delete reply message\n");
+		goto errlab;
+	}
+	for(pfkey_socketsp = pfkey_open_sockets;
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_delete_parse: "
+				    "sending up delete reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_delete_parse: "
+			    "sending up delete reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	ipsec_tdbwipe(extr->tdb);
+
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_get_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct tdb *tdbp;
+	char sa[SATOA_BUF];
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_get_parse: .\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_get_parse: "
+			    "extr or extr->tdb pointer NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa, SATOA_BUF);
+
+	spin_lock_bh(&tdb_lock);
+
+	tdbp = gettdb(&(extr->tdb->tdb_said));
+	if (tdbp == NULL) {
+		spin_unlock_bh(&tdb_lock);
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_get_parse: "
+			    "Tunnel Descriptor Block not found for SA=%s, could not get.\n",
+			    sa);
+		SENDERR(ESRCH);
+	}
+	
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_GET,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply)
+	     && pfkey_safe_build(error = pfkey_sa_build(&extensions_reply[SADB_EXT_SA],
+							SADB_EXT_SA,
+							extr->tdb->tdb_said.spi,
+							extr->tdb->tdb_replaywin,
+							extr->tdb->tdb_state,
+							extr->tdb->tdb_authalg,
+							extr->tdb->tdb_encalg,
+							extr->tdb->tdb_flags),
+				 extensions_reply)
+	     /* FIXME: The 3 lifetime extentions should only be sent if
+		non-zero. */
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_CURRENT],
+							      SADB_EXT_LIFETIME_CURRENT,
+							      tdbp->tdb_lifetime_allocations_c,
+							      tdbp->tdb_lifetime_bytes_c,
+							      tdbp->tdb_lifetime_addtime_c,
+							      tdbp->tdb_lifetime_usetime_c),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_HARD],
+							      SADB_EXT_LIFETIME_HARD,
+							      tdbp->tdb_lifetime_allocations_h,
+							      tdbp->tdb_lifetime_bytes_h,
+							      tdbp->tdb_lifetime_addtime_h,
+							      tdbp->tdb_lifetime_usetime_h),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_SOFT],
+							      SADB_EXT_LIFETIME_SOFT,
+							      tdbp->tdb_lifetime_allocations_s,
+							      tdbp->tdb_lifetime_bytes_s,
+							      tdbp->tdb_lifetime_addtime_s,
+							      tdbp->tdb_lifetime_usetime_s),
+				 extensions)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_SRC],
+							     SADB_EXT_ADDRESS_SRC,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_s),
+				 extensions_reply)
+	     && pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_DST],
+							     SADB_EXT_ADDRESS_DST,
+							     0, /*extr->tdb->tdb_said.proto,*/
+							     0,
+							     extr->tdb->tdb_addr_d),
+				 extensions_reply)
+	     && extr->tdb->tdb_addr_d ? pfkey_safe_build(error = pfkey_address_build(&extensions_reply[SADB_EXT_ADDRESS_PROXY],
+										     SADB_EXT_ADDRESS_PROXY,
+										     0, /*extr->tdb->tdb_said.proto,*/
+										     0,
+										     extr->tdb->tdb_addr_p),
+							 extensions_reply) : 1
+#if 0
+	     /* FIXME: This won't work yet because the keys are not
+		stored directly in the tdb.  They are stored as
+		contexts. */
+	     && extr->tdb->tdb_key_a_size ? pfkey_safe_build(error = pfkey_key_build(&extensions_reply[SADB_EXT_KEY_AUTH],
+										     SADB_EXT_KEY_AUTH,
+										     extr->tdb->tdb_key_a_size * 8,
+										     extr->tdb->tdb_key_a),
+							     extensions_reply)
+	     /* FIXME: This won't work yet because the keys are not
+		stored directly in the tdb.  They are stored as
+		key schedules. */
+	     && extr->tdb->tdb_key_e_size ? pfkey_safe_build(error = pfkey_key_build(&extensions_reply[SADB_EXT_KEY_ENCRYPT],
+										     SADB_EXT_KEY_ENCRYPT,
+										     extr->tdb->tdb_key_e_size * 8,
+										     extr->tdb->tdb_key_e),
+							     extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_s ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_SRC],
+											 SADB_EXT_IDENTITY_SRC,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_s),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_ident_data_d ? pfkey_safe_build(error = pfkey_ident_build(&extensions_reply[SADB_EXT_IDENTITY_DST],
+											 SADB_EXT_IDENTITY_DST,
+											 SADB_IDENTTYPE_PREFIX,
+											 0,
+											 extr->tdb->tdb_ident_data_d),
+							       extensions_reply) : 1
+	     /* FIXME: This won't work yet because I have not finished
+		it. */
+	     && extr->tdb->tdb_sens_ ? pfkey_safe_build(error = pfkey_sens_build(&extensions_reply[SADB_EXT_SENSITIVITY],
+										 extr->tdb->tdb_sens_dpd,
+										 extr->tdb->tdb_sens_sens_level,
+										 extr->tdb->tdb_sens_sens_len,
+										 extr->tdb->tdb_sens_sens_bitmap,
+										 extr->tdb->tdb_sens_integ_level,
+										 extr->tdb->tdb_sens_integ_len,
+										 extr->tdb->tdb_sens_integ_bitmap),
+							extensions_reply) : 1
+#endif
+		)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_get_parse: "
+			    "failed to build the get reply message extensions\n");
+		spin_unlock_bh(&tdb_lock);
+		goto errlab;
+	}
+		
+	spin_unlock_bh(&tdb_lock);
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_get_parse: "
+			    "failed to build the get reply message\n");
+		goto errlab;
+	}
+	
+	if((error = pfkey_upmsg(sk->socket, pfkey_reply))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_get_parse: "
+			    "failed to send the get reply message\n");
+		goto errlab;
+	}
+	
+	KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_get_parse: "
+		    "succeeded in sending get reply message.\n");
+	
+ errlab:
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_acquire_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_acquire_parse: .\n");
+
+	/* I don't know if we want an upper bound, since userspace may
+	   want to register itself for an satype > SADB_SATYPE_MAX. */
+	if((satype == 0) || (satype > SADB_SATYPE_MAX)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_acquire_parse: "
+			    "SATYPE=%d invalid.\n",
+			    satype);
+		SENDERR(EINVAL);
+	}
+
+	if(!(pfkey_registered_sockets[satype])) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire_parse: "
+			    "no sockets registered for SAtype=%d.\n",
+			    satype);
+		SENDERR(EPROTONOSUPPORT);
+	}
+
+	for(pfkey_socketsp = pfkey_registered_sockets[satype];
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp,
+					((struct sadb_msg*)extensions[SADB_EXT_RESERVED])))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire_parse: "
+				    "sending up acquire reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire_parse: "
+			    "sending up acquire reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_register_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	unsigned int alg_num_a = 0, alg_num_e = 0;
+	struct sadb_alg *alg_a = NULL, *alg_e = NULL, *alg_ap = NULL, *alg_ep = NULL;
+	struct sadb_ext *extensions_reply[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_reply = NULL;
+	struct supported_list *pfkey_supported_listp;
+	struct socket_list *pfkey_socketsp;
+	int error = 0;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_register_parse: .\n");
+
+	pfkey_extensions_init(extensions_reply);
+
+	/* I don't know if we want an upper bound, since userspace may
+	   want to register itself for an satype > SADB_SATYPE_MAX. */
+	if((satype == 0) || (satype > SADB_SATYPE_MAX)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_register_parse: "
+			    "SATYPE=%d invalid.\n",
+			    satype);
+		SENDERR(EINVAL);
+	}
+
+	if(!pfkey_list_insert_socket(sk->socket,
+				 &(pfkey_registered_sockets[satype]))) {
+		KLIPS_PRINT(1 || debug_pfkey,
+			    "klips_debug:pfkey_register_parse: "
+			    "SATYPE=%02d successfully registered by KMd on pid=%d.\n",
+			    satype, key_pid(sk));
+	};
+	
+	/* send up register msg with supported SATYPE algos */
+	pfkey_supported_listp = pfkey_supported_list[satype];
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_register_parse: "
+		    "pfkey_supported_list[%d]=%p\n",
+		    satype,
+		    pfkey_supported_list[satype]);
+	while(pfkey_supported_listp) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_register_parse: "
+			    "checking supported=%p\n",
+			    pfkey_supported_listp);
+		if(pfkey_supported_listp->supportedp->supported_alg_exttype == SADB_EXT_SUPPORTED_AUTH) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_register_parse: "
+				    "adding auth alg.\n");
+			alg_num_a++;
+		}
+		if(pfkey_supported_listp->supportedp->supported_alg_exttype == SADB_EXT_SUPPORTED_ENCRYPT) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_register_parse: "
+				    "adding encrypt alg.\n");
+			alg_num_e++;
+		}
+		pfkey_supported_listp = pfkey_supported_listp->next;
+	}
+	
+	if(alg_num_a) {
+		if((alg_a = kmalloc(alg_num_a * sizeof(struct sadb_alg), GFP_ATOMIC) ) == NULL) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_register_parse: auth alg memory allocation error\n");
+			SENDERR(ENOMEM);
+		}
+		alg_ap = alg_a;
+	}
+	
+	if(alg_num_e) {
+		if((alg_e = kmalloc(alg_num_e * sizeof(struct sadb_alg), GFP_ATOMIC) ) == NULL) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_register_parse: enc alg memory allocation error\n");
+			SENDERR(ENOMEM);
+		}
+		alg_ep = alg_e;
+	}
+	
+	pfkey_supported_listp = pfkey_supported_list[satype];
+	while(pfkey_supported_listp) {
+		if(alg_num_a) {
+			if(pfkey_supported_listp->supportedp->supported_alg_exttype == SADB_EXT_SUPPORTED_AUTH) {
+				alg_ap->sadb_alg_id = pfkey_supported_listp->supportedp->supported_alg_id;
+				alg_ap->sadb_alg_ivlen = pfkey_supported_listp->supportedp->supported_alg_ivlen;
+				alg_ap->sadb_alg_minbits = pfkey_supported_listp->supportedp->supported_alg_minbits;
+				alg_ap->sadb_alg_maxbits = pfkey_supported_listp->supportedp->supported_alg_maxbits;
+				alg_ap->sadb_alg_reserved = 0;
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_register_parse: "
+					    "adding auth=%p\n",
+					    alg_ap);
+				alg_ap++;
+			}
+		}
+		if(alg_num_e) {
+			if(pfkey_supported_listp->supportedp->supported_alg_exttype == SADB_EXT_SUPPORTED_ENCRYPT) {
+				alg_ep->sadb_alg_id = pfkey_supported_listp->supportedp->supported_alg_id;
+				alg_ep->sadb_alg_ivlen = pfkey_supported_listp->supportedp->supported_alg_ivlen;
+				alg_ep->sadb_alg_minbits = pfkey_supported_listp->supportedp->supported_alg_minbits;
+				alg_ep->sadb_alg_maxbits = pfkey_supported_listp->supportedp->supported_alg_maxbits;
+				alg_ep->sadb_alg_reserved = 0;
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_register_parse: "
+					    "adding encrypt=%p\n",
+					    alg_ep);
+				alg_ep++;
+			}
+		}
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_register_parse: "
+			    "found satype=%d exttype=%d id=%d ivlen=%d minbits=%d maxbits=%d.\n",
+			    satype,
+			    pfkey_supported_listp->supportedp->supported_alg_exttype,
+			    pfkey_supported_listp->supportedp->supported_alg_id,
+			    pfkey_supported_listp->supportedp->supported_alg_ivlen,
+			    pfkey_supported_listp->supportedp->supported_alg_minbits,
+			    pfkey_supported_listp->supportedp->supported_alg_maxbits);
+		pfkey_supported_listp = pfkey_supported_listp->next;
+	}
+	
+	if(!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions_reply[0],
+							  SADB_REGISTER,
+							  satype,
+							  0,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_seq,
+							  ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_pid),
+			      extensions_reply) &&
+	     (alg_num_a ? pfkey_safe_build(error = pfkey_supported_build(&extensions_reply[SADB_EXT_SUPPORTED_AUTH],
+									SADB_EXT_SUPPORTED_AUTH,
+									alg_num_a,
+									alg_a),
+					  extensions_reply) : 1) &&
+	     (alg_num_e ? pfkey_safe_build(error = pfkey_supported_build(&extensions_reply[SADB_EXT_SUPPORTED_ENCRYPT],
+									SADB_EXT_SUPPORTED_ENCRYPT,
+									alg_num_e,
+									alg_e),
+					  extensions_reply) : 1))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_register_parse: "
+			    "failed to build the register message extensions\n");
+		goto errlab;
+	}
+	
+	if((error = pfkey_msg_build(&pfkey_reply, extensions_reply, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_register_parse: "
+			    "failed to build the register message\n");
+		goto errlab;
+	}
+	for(pfkey_socketsp = pfkey_registered_sockets[satype];
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_reply))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_register_parse: "
+				    "sending up register reply message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_register_parse: "
+			    "sending up register reply message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	if (pfkey_reply) {
+		pfkey_msg_free(&pfkey_reply);
+	}
+	pfkey_extensions_free(extensions_reply);
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_expire_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct socket_list *pfkey_socketsp;
+#ifdef CONFIG_IPSEC_DEBUG
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_expire_parse: .\n");
+
+	if(pfkey_open_sockets) {
+		for(pfkey_socketsp = pfkey_open_sockets;
+		    pfkey_socketsp;
+		    pfkey_socketsp = pfkey_socketsp->next) {
+			if((error = pfkey_upmsg(pfkey_socketsp->socketp,
+						((struct sadb_msg*)extensions[SADB_EXT_RESERVED])))) {
+				KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire_parse: "
+					    "sending up expire reply message for satype=%d to socket=%p failed with error=%d.\n",
+					    satype, pfkey_socketsp->socketp, error);
+				goto errlab;
+			}
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire_parse: "
+				    "sending up expire reply message for satype=%d to socket=%p succeeded.\n",
+				    satype, pfkey_socketsp->socketp);
+		}
+	}
+
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_flush_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+	struct socket_list *pfkey_socketsp;
+	uint8_t satype = ((struct sadb_msg*)extensions[SADB_EXT_RESERVED])->sadb_msg_satype;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_flush_parse: "
+		    "flushing type %d SAs\n",
+		    satype);
+
+	if ((error = ipsec_tdbcleanup(satype)))
+		SENDERR(-error);
+
+	if(pfkey_open_sockets) {
+		for(pfkey_socketsp = pfkey_open_sockets;
+		    pfkey_socketsp;
+		    pfkey_socketsp = pfkey_socketsp->next) {
+			if((error = pfkey_upmsg(pfkey_socketsp->socketp,
+						((struct sadb_msg*)extensions[SADB_EXT_RESERVED])))) {
+				KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_flush_parse: "
+					    "sending up flush reply message for satype=%d to socket=%p failed with error=%d.\n",
+					    satype,
+					    pfkey_socketsp->socketp,
+					    error);
+				goto errlab;
+			}
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_flush_parse: "
+				    "sending up flush reply message for satype=%d to socket=%p succeeded.\n",
+				    satype,
+				    pfkey_socketsp->socketp);
+		}
+	}
+
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_dump_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_dump_parse: .\n");
+
+	SENDERR(ENOSYS);
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_promisc_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_promisc_parse: .\n");
+
+	SENDERR(ENOSYS);
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_pchange_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_pchange_parse: .\n");
+
+	SENDERR(ENOSYS);
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_grpsa_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	struct tdb *tdb1p, *tdb2p, *tdbp;
+	char sa1[SATOA_BUF], sa2[SATOA_BUF];
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_grpsa_parse: .\n");
+
+	spin_lock_bh(&tdb_lock);
+
+	if(!extr || !extr->tdb) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_grpsa_parse: "
+			    "extr or extr->tdb is NULL, fatal.\n");
+		SENDERR(EINVAL);
+	}
+
+	satoa(extr->tdb->tdb_said, 0, sa1, SATOA_BUF);
+	if(extr->tdb2) {
+		satoa(extr->tdb2->tdb_said, 0, sa2, SATOA_BUF);
+	}
+
+	if(!(tdb1p = gettdb(&(extr->tdb->tdb_said)))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug: pfkey_x_grpsa_parse: reserved Tunnel Descriptor Block\n"
+			    "klips_debug:            for SA: %s not found.  Call SADB_ADD/UPDATE first.\n", sa1);
+		SENDERR(EEXIST);
+	}
+	if(extr->tdb2) { /* GRPSA */
+		if(!(tdb2p = gettdb(&(extr->tdb2->tdb_said)))) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug: pfkey_x_grpsa_parse: reserved Tunnel Descriptor Block\n"
+				    "klips_debug:            for SA: %s not found.  Call SADB_ADD/UPDATE first.\n", sa2);
+			SENDERR(EEXIST);
+		}
+
+		/* Is either one already linked? */
+		if(tdb1p->tdb_onext) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug: pfkey_x_grpsa_parse: Tunnel Descriptor Block\n"
+				    "klips_debug:                for SA: %s is already linked.\n", sa1);
+			SENDERR(EEXIST);
+		}
+		if(tdb2p->tdb_inext) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug: pfkey_x_grpsa_parse: Tunnel Descriptor Block\n"
+				    "klips_debug:                for SA: %s is already linked.\n", sa2);
+			SENDERR(EEXIST);
+		}
+		
+		/* Is extr->tdb already linked to extr->tdb2? */
+		tdbp = tdb2p;
+		while(tdbp) {
+			if(tdbp == tdb1p) {
+				SENDERR(EEXIST);
+			}
+			tdbp = tdb2p->tdb_onext;
+		}
+		
+		/* link 'em */
+		tdb1p->tdb_onext = tdb2p;
+		tdb2p->tdb_inext = tdb1p;
+	} else { /* UNGRPSA */
+		while(tdb1p->tdb_onext) {
+			tdb1p = tdb1p->tdb_onext;
+		}
+		while(tdb1p->tdb_inext) {
+			tdbp = tdb1p;
+			tdb1p = tdb1p->tdb_inext;
+			tdbp->tdb_inext = NULL;
+			tdb1p->tdb_onext = NULL;
+		}
+	}
+
+ errlab:
+	spin_unlock_bh(&tdb_lock);
+
+	ipsec_tdbwipe(extr->tdb);
+	if(extr->tdb2) {
+		ipsec_tdbwipe(extr->tdb2);
+	}
+
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_addflow_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[64], buf2[64];
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_addflow_parse: .\n");
+
+	if(!extr || !(extr->tdb) || !(extr->eroute)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_addflow_parse: "
+			    "missing extr, tdb or eroute data.\n");
+		SENDERR(EINVAL);
+	}
+
+#ifdef CONFIG_IPSEC_DEBUG
+	if (debug_pfkey) {
+		subnettoa(extr->eroute->er_eaddr.sen_ip_src,
+			  extr->eroute->er_emask.sen_ip_src, 0, buf1, sizeof(buf1));
+		subnettoa(extr->eroute->er_eaddr.sen_ip_dst,
+			  extr->eroute->er_emask.sen_ip_dst, 0, buf2, sizeof(buf2));
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_addflow_parse: "
+			    "calling breakeroute and/or makeroute for %s->%s\n",
+			    buf1, buf2);
+	}
+#endif /* CONFIG_IPSEC_DEBUG */
+	if(extr->tdb->tdb_flags & SADB_X_SAFLAGS_REPLACEFLOW) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_addflow_parse: "
+			    "REPLACEFLOW flag set, calling breakeroute.\n");
+		if ((error = ipsec_breakroute(&(extr->eroute->er_eaddr),
+					      &(extr->eroute->er_emask))) == EINVAL) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_x_addflow_parse: "
+				    "breakeroute returned %d.\n", error);
+			SENDERR(-error);
+		}
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_addflow_parse: "
+		    "calling makeroute.\n");
+
+	if ((error = ipsec_makeroute(&(extr->eroute->er_eaddr),
+				     &(extr->eroute->er_emask),
+				     extr->tdb->tdb_said))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_addflow_parse: "
+			    "makeroute returned %d.\n", error);
+		SENDERR(-error);
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_addflow_parse: "
+		    "makeroute call successful.\n");
+
+	ipsec_tdbwipe(extr->tdb);
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_addflow_parse: "
+		    "extr->tdb cleaned up and freed.\n");
+
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_delflow_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+#ifdef CONFIG_IPSEC_DEBUG
+	char buf1[64], buf2[64];
+#endif /* CONFIG_IPSEC_DEBUG */
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_delflow_parse: .\n");
+
+	if(!extr || !(extr->tdb)) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_delflow_parse: "
+			    "extr, or extr->tdb is NULL, fatal\n");
+		SENDERR(EINVAL);
+	}
+
+	if(extr->tdb->tdb_flags & SADB_X_SAFLAGS_CLEARFLOW) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_x_delflow_parse: "
+			    "CLEARFLOW flag set, calling cleareroutes.\n");
+		if ((error = ipsec_cleareroutes()))
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_x_delflow_parse: "
+				    "cleareroutes returned %d.\n", error);
+			SENDERR(-error);
+	} else {
+		if(!(extr->eroute)) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_x_delflow_parse: "
+				    "extr->eroute is NULL, fatal.\n");
+			SENDERR(EINVAL);
+		}
+		
+#ifdef CONFIG_IPSEC_DEBUG
+		if (debug_pfkey) {
+			subnettoa(extr->eroute->er_eaddr.sen_ip_src,
+				  extr->eroute->er_emask.sen_ip_src, 0, buf1, sizeof(buf1));
+			subnettoa(extr->eroute->er_eaddr.sen_ip_dst,
+				  extr->eroute->er_emask.sen_ip_dst, 0, buf2, sizeof(buf2));
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_x_delflow_parse: "
+				    "calling breakeroute for %s->%s\n",
+				    buf1, buf2);
+		}
+#endif /* CONFIG_IPSEC_DEBUG */
+		if((error = ipsec_breakroute(&(extr->eroute->er_eaddr),
+					     &(extr->eroute->er_emask)))) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_x_delflow_parse: "
+				    "breakeroute returned %d.\n", error);
+			SENDERR(-error);
+		}
+	}
+	
+	ipsec_tdbwipe(extr->tdb);
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_delflow_parse: "
+		    "extr->tdb cleaned up and freed.\n");
+
+ errlab:
+	return error;
+}
+
+DEBUG_NO_STATIC int
+pfkey_x_msg_debug_parse(struct sock *sk, struct sadb_ext **extensions, struct pfkey_extracted_data* extr)
+{
+	int error = 0;
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_x_msg_debug_parse: .\n");
+
+/* errlab:*/
+	return error;
+}
+
+
+int
+pfkey_expire(struct tdb *tdbp, int hard)
+{
+	struct sadb_ext *extensions[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_msg = NULL;
+	struct socket_list *pfkey_socketsp;
+	int error = 0;
+	uint8_t satype = proto2satype(tdbp->tdb_said.proto);
+
+	pfkey_extensions_init(extensions);
+
+	if(!pfkey_open_sockets) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire: "
+			    "no sockets listening.\n");
+		SENDERR(EPROTONOSUPPORT);
+	}
+
+	spin_lock(&tdb_lock);
+	if (!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions[0],
+							   SADB_EXPIRE,
+							   satype,
+							   0,
+							   ++pfkey_msg_seq,
+							   0),
+			       extensions)
+	      && pfkey_safe_build(error = pfkey_sa_build(&extensions[SADB_EXT_SA],
+							 SADB_EXT_SA,
+							 tdbp->tdb_said.spi,
+							 tdbp->tdb_replaywin,
+							 tdbp->tdb_state,
+							 tdbp->tdb_authalg,
+							 tdbp->tdb_encalg,
+							 tdbp->tdb_flags),
+				  extensions)
+	      && pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_CURRENT],
+							       SADB_EXT_LIFETIME_CURRENT,
+							       tdbp->tdb_lifetime_allocations_c,
+							       tdbp->tdb_lifetime_bytes_c,
+							       tdbp->tdb_lifetime_addtime_c,
+							       tdbp->tdb_lifetime_usetime_c),
+				  extensions)
+	      && (hard ? 
+		  pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_HARD],
+								SADB_EXT_LIFETIME_HARD,
+								tdbp->tdb_lifetime_allocations_h,
+								tdbp->tdb_lifetime_bytes_h,
+								tdbp->tdb_lifetime_addtime_h,
+								tdbp->tdb_lifetime_usetime_h),
+				   extensions)
+		  : pfkey_safe_build(error = pfkey_lifetime_build(&extensions[SADB_EXT_LIFETIME_SOFT],
+								  SADB_EXT_LIFETIME_SOFT,
+								  tdbp->tdb_lifetime_allocations_s,
+								  tdbp->tdb_lifetime_bytes_s,
+								  tdbp->tdb_lifetime_addtime_s,
+								  tdbp->tdb_lifetime_usetime_s),
+				     extensions))
+	      && pfkey_safe_build(error = pfkey_address_build(&extensions[SADB_EXT_ADDRESS_SRC],
+							      SADB_EXT_ADDRESS_SRC,
+							      0, /* tdbp->tdb_said.proto, */
+							      0,
+							      tdbp->tdb_addr_s),
+				  extensions)
+	      && pfkey_safe_build(error = pfkey_address_build(&extensions[SADB_EXT_ADDRESS_DST],
+							      SADB_EXT_ADDRESS_DST,
+							      0, /* tdbp->tdb_said.proto, */
+							      0,
+							      tdbp->tdb_addr_d),
+				  extensions))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire: failed to "
+			    "build the expire message extensions\n");
+		spin_unlock(&tdb_lock);
+		goto errlab;
+	}
+	
+	spin_unlock(&tdb_lock);
+
+	if ((error = pfkey_msg_build(&pfkey_msg, extensions, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire: failed to "
+			    "build the expire message\n");
+		goto errlab;
+	}
+	
+	for(pfkey_socketsp = pfkey_open_sockets;
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_msg))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire: "
+				    "sending up expire message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_expire: "
+			    "sending up expire message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	if (pfkey_msg) {
+		pfkey_msg_free(&pfkey_msg);
+	}
+	pfkey_extensions_free(extensions);
+	return error;
+}
+
+int
+pfkey_acquire(struct tdb *tdbp)
+{
+	struct sadb_ext *extensions[SADB_EXT_MAX+1];
+	struct sadb_msg *pfkey_msg = NULL;
+	struct socket_list *pfkey_socketsp;
+	int error = 0;
+	struct sadb_comb comb[] = {
+		/* auth; encrypt; flags; */
+		/* auth_minbits; auth_maxbits; encrypt_minbits; encrypt_maxbits; */
+		/* reserved; soft_allocations; hard_allocations; soft_bytes; hard_bytes; */
+		/* soft_addtime; hard_addtime; soft_usetime; hard_usetime; */
+		{ SADB_AALG_MD5HMAC,  SADB_EALG_3DESCBC, SADB_SAFLAGS_PFS,
+		  128, 128, 168, 168,
+		  0, 0, 0, 0, 0,
+		  57600, 86400, 57600, 86400 },
+		{ SADB_AALG_SHA1HMAC, SADB_EALG_3DESCBC, SADB_SAFLAGS_PFS,
+		  160, 160, 168, 168,
+		  0, 0, 0, 0, 0,
+		  57600, 86400, 57600, 86400 }
+	};
+       
+	/* This should not be hard-coded.  It should be taken from the spdb */
+	uint8_t satype = SADB_SATYPE_ESP;
+
+	pfkey_extensions_init(extensions);
+
+	if((satype == 0) || (satype > SADB_SATYPE_MAX)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: "
+			    "SAtype=%d unspecified or unknown.\n",
+			    satype);
+		SENDERR(EINVAL);
+	}
+
+	if(!(pfkey_registered_sockets[satype])) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: "
+			    "no sockets registered for SAtype=%d.\n",
+			    satype);
+		SENDERR(EPROTONOSUPPORT);
+	}
+	
+	if (!(pfkey_safe_build(error = pfkey_msg_hdr_build(&extensions[0],
+							  SADB_ACQUIRE,
+							  satype,
+							  0,
+							  ++pfkey_msg_seq,
+							  0),
+			      extensions)
+	      && pfkey_safe_build(error = pfkey_address_build(&extensions[SADB_EXT_ADDRESS_SRC],
+							      SADB_EXT_ADDRESS_SRC,
+							      tdbp->tdb_said.proto,
+							      0,
+							      tdbp->tdb_addr_s),
+				  extensions)
+	      && pfkey_safe_build(error = pfkey_address_build(&extensions[SADB_EXT_ADDRESS_DST],
+							      SADB_EXT_ADDRESS_DST,
+							      tdbp->tdb_said.proto,
+							      0,
+							      tdbp->tdb_addr_d),
+				  extensions)
+#if 0
+	      && tdbp->tdb_addr_p ? pfkey_safe_build(error = pfkey_address_build(&extensions[SADB_EXT_ADDRESS_PROXY],
+										 SADB_EXT_ADDRESS_PROXY,
+										 tdbp->tdb_said.proto,
+										 0,
+										 tdbp->tdb_addr_p),
+						     extensions) : 1
+	      /* FIXME: This won't work yet because I have not finished
+		 it. */
+	      && tdbp->tdb_ident_data_s ? pfkey_safe_build(error = pfkey_ident_build(&extensions[SADB_EXT_IDENTITY_SRC],
+											  SADB_EXT_IDENTITY_SRC,
+											  SADB_IDENTTYPE_PREFIX,
+											  0,
+											  tdbp->tdb_ident_data_s),
+								extensions) : 1
+	      /* FIXME: This won't work yet because I have not finished
+		 it. */
+	      && tdbp->tdb_ident_data_d ? pfkey_safe_build(error = pfkey_ident_build(&extensions[SADB_EXT_IDENTITY_DST],
+											  SADB_EXT_IDENTITY_DST,
+											  SADB_IDENTTYPE_PREFIX,
+											  0,
+											  tdbp->tdb_ident_data_d),
+								extensions) : 1
+	      /* FIXME: This won't work yet because I have not finished
+		 it. */
+	      && tdbp->tdb_sens_ ? pfkey_safe_build(error = pfkey_sens_build(&extensions[SADB_EXT_SENSITIVITY],
+										  tdbp->tdb_sens_dpd,
+										  tdbp->tdb_sens_sens_level,
+										  tdbp->tdb_sens_sens_len,
+										  tdbp->tdb_sens_sens_bitmap,
+										  tdbp->tdb_sens_integ_level,
+										  tdbp->tdb_sens_integ_len,
+										  tdbp->tdb_sens_integ_bitmap),
+							 extensions) : 1
+#endif
+	      && pfkey_safe_build(error = pfkey_prop_build(&extensions[SADB_EXT_PROPOSAL],
+							   64, /* replay */
+							   sizeof(comb)/sizeof(struct sadb_comb),
+							   &(comb[0])),
+				  extensions)
+		)) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: failed to "
+			    "build the acquire message extensions\n");
+		goto errlab;
+	}
+	
+	if ((error = pfkey_msg_build(&pfkey_msg, extensions, EXT_BITS_OUT))) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: failed to "
+			    "build the acquire message\n");
+		goto errlab;
+	}
+	
+	/* this should go to all registered sockets for that satype only */
+	for(pfkey_socketsp = pfkey_registered_sockets[satype];
+	    pfkey_socketsp;
+	    pfkey_socketsp = pfkey_socketsp->next) {
+		if((error = pfkey_upmsg(pfkey_socketsp->socketp, pfkey_msg))) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: "
+				    "sending up acquire message for satype=%d to socket=%p failed with error=%d.\n",
+				    satype, pfkey_socketsp->socketp, error);
+			goto errlab;
+		}
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_acquire: "
+			    "sending up acquire message for satype=%d to socket=%p succeeded.\n",
+			    satype, pfkey_socketsp->socketp);
+	}
+	
+ errlab:
+	if (pfkey_msg) {
+		pfkey_msg_free(&pfkey_msg);
+	}
+	pfkey_extensions_free(extensions);
+	return error;
+}
+
+
+DEBUG_NO_STATIC int (*ext_processors[SADB_EXT_MAX+1])(struct sadb_ext *pfkey_ext, struct pfkey_extracted_data* extr) =
+{
+  NULL, /* pfkey_msg_process, */
+        pfkey_sa_process,
+        pfkey_lifetime_process,
+        pfkey_lifetime_process,
+        pfkey_lifetime_process,
+        pfkey_address_process,
+        pfkey_address_process,
+        pfkey_address_process,
+        pfkey_key_process,
+        pfkey_key_process,
+        pfkey_ident_process,
+        pfkey_ident_process,
+        pfkey_sens_process,
+        pfkey_prop_process,
+        pfkey_supported_process,
+        pfkey_supported_process,
+        pfkey_spirange_process,
+        pfkey_x_kmprivate_process,
+        pfkey_x_satype_process,
+        pfkey_sa_process,
+        pfkey_address_process,
+        pfkey_address_process,
+        pfkey_address_process,
+        pfkey_address_process,
+        pfkey_address_process,
+	pfkey_x_debug_process
+};
+
+
+DEBUG_NO_STATIC int (*msg_parsers[SADB_MAX +1])(struct sock *sk, struct sadb_ext *extensions[], struct pfkey_extracted_data* extr)
+ =
+{
+	NULL, /* RESERVED */
+	pfkey_getspi_parse,
+	pfkey_update_parse,
+	pfkey_add_parse,
+	pfkey_delete_parse,
+	pfkey_get_parse,
+	pfkey_acquire_parse,
+	pfkey_register_parse,
+	pfkey_expire_parse,
+	pfkey_flush_parse,
+	pfkey_dump_parse,
+	pfkey_x_promisc_parse,
+	pfkey_x_pchange_parse,
+	pfkey_x_grpsa_parse,
+	pfkey_x_addflow_parse,
+	pfkey_x_delflow_parse,
+	pfkey_x_msg_debug_parse
+};
+
+int
+pfkey_build_reply(struct sadb_msg *pfkey_msg, struct pfkey_extracted_data *extr,
+				struct sadb_msg **pfkey_reply)
+{
+	struct sadb_ext *extensions[SADB_EXT_MAX+1];
+	int error = 0;
+	int msg_type = pfkey_msg->sadb_msg_type;
+	int seq = pfkey_msg->sadb_msg_seq;
+
+	KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_build_reply: building reply"
+					" with type: %d\n", msg_type);
+	pfkey_extensions_init(extensions);
+	if (!extr || !extr->tdb) {
+			KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_build_reply: bad TDB"
+							"passed\n");
+			return EINVAL;
+	}
+	error = pfkey_safe_build(pfkey_msg_hdr_build(&extensions[0],
+						     msg_type,
+						     proto2satype(extr->tdb->tdb_said.proto),
+						     0,
+						     seq,
+						     pfkey_msg->sadb_msg_pid),
+				 extensions) &&
+		(!(extensions_bitmaps[EXT_BITS_OUT][EXT_BITS_REQ][msg_type] &
+		   1 << SADB_EXT_SA)
+		 || pfkey_safe_build(pfkey_sa_build(&extensions[SADB_EXT_SA],
+						    SADB_EXT_SA,
+						    extr->tdb->tdb_said.spi,
+						    extr->tdb->tdb_replaywin,
+						    extr->tdb->tdb_state,
+						    extr->tdb->tdb_authalg,
+						    extr->tdb->tdb_encalg,
+						    extr->tdb->tdb_flags),
+				     extensions)) &&
+		(!(extensions_bitmaps[EXT_BITS_OUT][EXT_BITS_REQ][msg_type] &
+		   1 << SADB_EXT_LIFETIME_CURRENT)
+		 || pfkey_safe_build(pfkey_lifetime_build(&extensions
+							  [SADB_EXT_LIFETIME_CURRENT],
+							  SADB_EXT_LIFETIME_CURRENT,
+							  extr->tdb->tdb_lifetime_allocations_c,
+							  extr->tdb->tdb_lifetime_bytes_c,
+							  extr->tdb->tdb_lifetime_addtime_c,
+							  extr->tdb->tdb_lifetime_usetime_c),
+				     extensions)) &&
+		(!(extensions_bitmaps[EXT_BITS_OUT][EXT_BITS_REQ][msg_type] &
+		   1 << SADB_EXT_ADDRESS_SRC)
+		 || pfkey_safe_build(pfkey_address_build(&extensions[SADB_EXT_ADDRESS_SRC],
+							 SADB_EXT_ADDRESS_SRC,
+							 extr->tdb->tdb_said.proto,
+							 0,
+							 extr->tdb->tdb_addr_s),
+				     extensions)) &&
+		(!(extensions_bitmaps[EXT_BITS_OUT][EXT_BITS_REQ][msg_type] &
+		   1 << SADB_EXT_ADDRESS_DST)
+		 || pfkey_safe_build(pfkey_address_build(&extensions[SADB_EXT_ADDRESS_DST],
+							 SADB_EXT_ADDRESS_DST,
+							 extr->tdb->tdb_said.proto,
+							 0,
+							 extr->tdb->tdb_addr_d),
+				     extensions));
+
+	if (error == 0) {
+		KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_build_reply: "
+			    "building extensions failed\n");
+		return EINVAL;
+	}
+
+	KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_build_reply: built extensions"
+		    ", proceed to build the message\n");
+	KLIPS_PRINT(debug_pfkey, "klips_debug:pfkey_build_reply: extensions[1]="
+		    " %p\n", extensions[1]);
+	error = pfkey_msg_build(pfkey_reply, extensions, EXT_BITS_OUT);
+	pfkey_extensions_free(extensions);
+
+	return error;
+}
+
+int
+pfkey_msg_interp(struct sock *sk, struct sadb_msg *pfkey_msg,
+				struct sadb_msg **pfkey_reply)
+{
+	int error = 0;
+	int i;
+	struct sadb_ext *extensions[SADB_EXT_MAX+1];
+	struct pfkey_extracted_data extr = {NULL, NULL, NULL};
+	
+	pfkey_extensions_init(extensions);
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_msg_interp: parsing message "
+		    "ver=%d, type=%d, errno=%d, satype=%d, len=%d, res=%d, seq=%d, pid=%d.\n", 
+		    pfkey_msg->sadb_msg_version,
+		    pfkey_msg->sadb_msg_type,
+		    pfkey_msg->sadb_msg_errno,
+		    pfkey_msg->sadb_msg_satype,
+		    pfkey_msg->sadb_msg_len,
+		    pfkey_msg->sadb_msg_reserved,
+		    pfkey_msg->sadb_msg_seq,
+		    pfkey_msg->sadb_msg_pid);
+	
+	if((error = pfkey_alloc_tdb(&(extr.tdb)))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_msg_interp: "
+			    "something's really wrong, extr.tdb=%p should be NULL.\n", extr.tdb);
+		SENDERR(-error);
+	}
+
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_msg_interp: "
+		    "allocated extr->tdb=%p.\n", extr.tdb);
+	
+	if(pfkey_msg->sadb_msg_satype > SADB_SATYPE_MAX) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_msg_interp: satype %d > max %d\n", 
+			    pfkey_msg->sadb_msg_satype, SADB_SATYPE_MAX);
+		SENDERR(EINVAL);
+	}
+	
+	switch(pfkey_msg->sadb_msg_type) {
+	case SADB_GETSPI:
+	case SADB_UPDATE:
+	case SADB_ADD:
+	case SADB_DELETE:
+	case SADB_X_GRPSA:
+		if(!(extr.tdb->tdb_said.proto = satype2proto(pfkey_msg->sadb_msg_satype))) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_msg_interp: satype %d lookup failed.\n", 
+				    pfkey_msg->sadb_msg_satype);
+			SENDERR(EINVAL);
+		}
+		break;
+	case SADB_X_ADDFLOW:
+		extr.tdb->tdb_said.proto = satype2proto(pfkey_msg->sadb_msg_satype);
+		break;
+	default:
+	}
+	
+	/* The NULL below causes the default extension parsers to be used */
+	/* Parse the extensions */
+	if((error = pfkey_msg_parse(pfkey_msg, NULL, extensions, EXT_BITS_IN)))
+	{
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_msg_interp: message parsing failed with error %d.\n",
+			    error); 
+		SENDERR(-error);
+	}
+	
+	/* Process the extensions */
+	for(i=1; i <= SADB_EXT_MAX;i++)	{
+		if(extensions[i] != NULL) {
+			KLIPS_PRINT(debug_pfkey,
+				    "klips_debug:pfkey_msg_interp: "
+				    "processing ext %d %p with processor %p.\n", 
+				    i, extensions[i], ext_processors[i]);
+			if((error = ext_processors[i](extensions[i], &extr))) {
+				KLIPS_PRINT(debug_pfkey,
+					    "klips_debug:pfkey_msg_interp: extension processing for type %d failed with error %d.\n",
+					    i,error); 
+				SENDERR(-error);
+			}
+			
+		}
+		
+	}
+	
+	/* Parse the message types */
+	KLIPS_PRINT(debug_pfkey,
+		    "klips_debug:pfkey_msg_interp: "
+		    "parsing message type %d with msg_parser %p.\n",
+		    pfkey_msg->sadb_msg_type,
+		    msg_parsers[pfkey_msg->sadb_msg_type]); 
+	if((error = msg_parsers[pfkey_msg->sadb_msg_type](sk, extensions, &extr))) {
+		KLIPS_PRINT(debug_pfkey,
+			    "klips_debug:pfkey_msg_interp: message parsing failed with error %d.\n",
+			    error); 
+		SENDERR(-error);
+	}
+
+#if 0
+	error = pfkey_build_reply(pfkey_msg, &extr, pfkey_reply);
+	if (error) {
+		*pfkey_reply = NULL;
+	}
+#endif	
+ errlab:
+	return(error);
+}
+
+/*
+ * $Log$
+ * Revision 1.62  2000/11/30 21:47:51  rgb
+ * Fix error return bug after returning from pfkey_tdb_init().
+ *
+ * Revision 1.61  2000/11/17 18:10:29  rgb
+ * Fixed bugs mostly relating to spirange, to treat all spi variables as
+ * network byte order since this is the way PF_KEYv2 stored spis.
+ *
+ * Revision 1.60  2000/11/06 04:34:53  rgb
+ * Changed non-exported functions to DEBUG_NO_STATIC.
+ * Add Svenning's adaptive content compression.
+ * Ditched spin_lock_irqsave in favour of spin_lock/_bh.
+ * Fixed double unlock bug (Svenning).
+ * Fixed pfkey_msg uninitialized bug in pfkey_{expire,acquire}().
+ * Fixed incorrect extension type (prop) in pfkey)acquire().
+ *
+ * Revision 1.59  2000/10/11 15:25:12  rgb
+ * Fixed IPCOMP disabled compile bug.
+ *
+ * Revision 1.58  2000/10/11 14:54:03  rgb
+ * Fixed pfkey_acquire() satype to SADB_SATYPE_ESP and removed pfkey
+ * protocol violations of setting pfkey_address_build() protocol parameter
+ * to non-zero except in the case of pfkey_acquire().
+ *
+ * Revision 1.57  2000/10/10 20:10:18  rgb
+ * Added support for debug_ipcomp and debug_verbose to klipsdebug.
+ *
+ * Revision 1.56  2000/10/06 20:24:36  rgb
+ * Fixes to pfkey_acquire to initialize extensions[] and use correct
+ * ipproto.
+ *
+ * Revision 1.55  2000/10/03 03:20:57  rgb
+ * Added brackets to get a?b:c scope right for pfkey_register reply.
+ *
+ * Revision 1.54  2000/09/29 19:49:30  rgb
+ * As-yet-unused-bits cleanup.
+ *
+ * Revision 1.53  2000/09/28 00:35:45  rgb
+ * Padded SATYPE printout in pfkey_register for vertical alignment.
+ *
+ * Revision 1.52  2000/09/20 16:21:58  rgb
+ * Cleaned up ident string alloc/free.
+ *
+ * Revision 1.51  2000/09/20 04:04:20  rgb
+ * Changed static functions to DEBUG_NO_STATIC to reveal function names in
+ * oopsen.
+ *
+ * Revision 1.50  2000/09/16 01:10:53  rgb
+ * Fixed unused var warning with debug off.
+ *
+ * Revision 1.49  2000/09/15 11:37:02  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.48  2000/09/15 04:57:57  rgb
+ * Cleaned up existing IPCOMP code before svenning addition.
+ * Initialize pfkey_reply and extensions_reply in case of early error in
+ * message parsing functions (thanks Kai!).
+ *
+ * Revision 1.47  2000/09/13 08:02:56  rgb
+ * Added KMd registration notification.
+ *
+ * Revision 1.46  2000/09/12 22:35:36  rgb
+ * Restructured to remove unused extensions from CLEARFLOW messages.
+ *
+ * Revision 1.45  2000/09/12 03:24:23  rgb
+ * Converted #if0 debugs to sysctl.
+ *
+ * Revision 1.44  2000/09/09 06:38:39  rgb
+ * Correct SADB message type for update, add and delete.
+ *
+ * Revision 1.43  2000/09/08 19:19:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ * Removed all references to CONFIG_IPSEC_PFKEYv2.
+ * Put in sanity checks in most msg type parsers to catch invalid satypes
+ * and empty socket lists.
+ * Moved spin-locks in pfkey_get_parse() to simplify.
+ * Added pfkey_acquire().
+ * Added upwards messages to update, add, delete, acquire_parse,
+ * expire_parse and flush.
+ * Fix pfkey_prop_build() parameter to be only single indirection.
+ * Changed all replies to use pfkey_reply.
+ * Check return code on puttdb() and deltdbchain() in getspi, update,
+ * add, delete.
+ * Fixed up all pfkey replies to open and registered sockets.
+ *
+ * Revision 1.42  2000/09/01 18:50:26  rgb
+ * Added a supported algorithms array lists, one per satype and registered
+ * existing algorithms.
+ * Fixed pfkey_list_{insert,remove}_{socket,support}() to allow change to
+ * list.
+ * Only send pfkey_expire() messages to sockets registered for that satype.
+ * Added reply to pfkey_getspi_parse().
+ * Added reply to pfkey_get_parse().
+ * Fixed debug output label bug in pfkey_lifetime_process().
+ * Cleaned up pfkey_sa_process a little.
+ * Moved pfkey_safe_build() above message type parsers to make it available
+ * for creating replies.
+ * Added comments for future work in pfkey_acquire_parse().
+ * Fleshed out guts of pfkey_register_parse().
+ *
+ * Revision 1.41  2000/08/24 16:58:11  rgb
+ * Fixed key debugging variables.
+ * Fixed error return code for a failed search.
+ * Changed order of pfkey_get operations.
+ *
+ * Revision 1.40  2000/08/21 16:32:27  rgb
+ * Re-formatted for cosmetic consistency and readability.
+ *
+ * Revision 1.39  2000/08/20 21:38:57  rgb
+ * Bugfixes to as-yet-unused pfkey_update_parse() and
+ * pfkey_register_parse(). (Momchil)
+ * Added functions pfkey_safe_build(), pfkey_expire() and
+ * pfkey_build_reply(). (Momchil)
+ * Added a pfkey_reply parameter to pfkey_msg_interp(). (Momchil)
+ *
+ * Revision 1.38  2000/08/18 21:30:41  rgb
+ * Purged all tdb_spi, tdb_proto and tdb_dst macros.  They are unclear.
+ *
+ * Revision 1.37  2000/08/18 18:18:02  rgb
+ * Cosmetic and descriptive changes made to debug test.
+ * getspi and update fixes from Momchil.
+ *
+ * Revision 1.36  2000/08/15 15:41:55  rgb
+ * Fixed the (as yet unused and untested) pfkey_getspi() routine.
+ *
+ * Revision 1.35  2000/08/01 14:51:52  rgb
+ * Removed _all_ remaining traces of DES.
+ *
+ * Revision 1.34  2000/07/28 14:58:32  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.33  2000/06/28 05:50:11  rgb
+ * Actually set iv_bits.
+ *
+ * Revision 1.32  2000/05/30 18:36:56  rgb
+ * Fix AH auth hash setup bug.  This breaks interop with previous PF_KEY
+ * FreeS/WAN, but fixes interop with other implementations.
+ *
+ * Revision 1.31  2000/03/16 14:05:48  rgb
+ * Fixed brace scope preventing non-debug compile.
+ * Added null parameter check for pfkey_x_debug().
+ *
+ * Revision 1.30  2000/01/22 23:21:13  rgb
+ * Use new function satype2proto().
+ *
+ * Revision 1.29  2000/01/22 08:40:21  rgb
+ * Invert condition to known value to avoid AF_INET6 in 2.0.36.
+ *
+ * Revision 1.28  2000/01/22 07:58:57  rgb
+ * Fixed REPLACEFLOW bug, missing braces around KLIPS_PRINT *and* SENDERR.
+ *
+ * Revision 1.27  2000/01/22 03:48:01  rgb
+ * Added extr pointer component debugging.
+ *
+ * Revision 1.26  2000/01/21 09:41:25  rgb
+ * Changed a (void*) to (char*) cast to do proper pointer math.
+ * Don't call tdbwipe if tdb2 is NULL.
+ *
+ * Revision 1.25  2000/01/21 06:21:01  rgb
+ * Added address cases for eroute flows.
+ * Tidied up compiler directive indentation for readability.
+ * Added ictx,octx vars for simplification.
+ * Added macros for HMAC padding magic numbers.
+ * Converted from double tdb arguments to one structure (extr)
+ * containing pointers to all temporary information structures
+ * and checking for valid arguments to all ext processors and
+ * msg type parsers.
+ * Added spiungrp'ing.
+ * Added klipsdebug switching capability.
+ * Removed sa_process() check for zero protocol.
+ * Added address case for DST2 for grouping.
+ * Added/changed minor debugging instrumentation.
+ * Fixed spigrp for single said, ungrouping case.
+ * Added code to parse addflow and delflow messages.
+ * Removed redundant statements duplicating tdbwipe() functionality
+ * and causing double kfrees.
+ * Permit addflow to have a protocol of 0.
+ *
+ * Revision 1.24  1999/12/09 23:23:00  rgb
+ * Added check to pfkey_sa_process() to do eroutes.
+ * Converted to DIVUP() macro.
+ * Converted if() to switch() in pfkey_register_parse().
+ * Use new pfkey_extensions_init() instead of memset().
+ *
+ * Revision 1.23  1999/12/01 22:18:13  rgb
+ * Preset minspi and maxspi values in case and spirange extension is not
+ * included and check for the presence of an spirange extension before
+ * using it.  Initialise tdb_sastate to LARVAL.
+ * Fixed debugging output typo.
+ * Fixed authentication context initialisation bugs (4 places).
+ *
+ * Revision 1.22  1999/11/27 11:53:08  rgb
+ * Moved pfkey_msg_parse prototype to pfkey.h
+ * Moved exts_permitted/required prototype to pfkey.h.
+ * Moved sadb_satype2proto protocol lookup table to lib/pfkey_v2_parse.c.
+ * Deleted SADB_X_EXT_SA2 code from pfkey_sa_process() since it will never
+ * be called.
+ * Moved protocol/algorithm checks to lib/pfkey_v2_parse.c
+ * Debugging error messages added.
+ * Enable lifetime_current checking.
+ * Remove illegal requirement for SA extension to be present in an
+ * originating GETSPI call.
+ * Re-instate requirement for UPDATE or ADD message to be MATURE.
+ * Add argument to pfkey_msg_parse() for direction.
+ * Fixed IPIP dst address bug and purged redundant, leaky code.
+ *
+ * Revision 1.21  1999/11/24 05:24:20  rgb
+ * hanged 'void*extensions' to 'struct sadb_ext*extensions'.
+ * Fixed indention.
+ * Ditched redundant replay check.
+ * Fixed debug message text from 'parse' to 'process'.
+ * Added more debug output.
+ * Forgot to zero extensions array causing bug, fixed.
+ *
+ * Revision 1.20  1999/11/23 23:08:13  rgb
+ * Move all common parsing code to lib/pfkey_v2_parse.c and rename
+ * remaining bits to *_process. (PJO)
+ * Add macros for dealing with alignment and rounding up more opaquely.
+ * Use provided macro ADDRTOA_BUF instead of hardcoded value.
+ * Sort out pfkey and freeswan headers, putting them in a library path.
+ * Corrected a couple of bugs in as-yet-inactive code.
+ *
+ * Revision 1.19  1999/11/20 22:01:10  rgb
+ * Add more descriptive error messages for non-zero reserved fields.
+ * Add more descriptive error message for spirange parsing.
+ * Start on supported extension parsing.
+ * Start on register and get message parsing.
+ *
+ * Revision 1.18  1999/11/18 04:09:20  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.17  1999/11/17 15:53:41  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.16  1999/10/26 16:57:43  rgb
+ * Add shorter macros for compiler directives to visually clean-up.
+ * Give ipv6 code meaningful compiler directive.
+ * Add comments to other #if 0 debug code.
+ * Remove unused *_bh_atomic() calls.
+ * Fix mis-placed spinlock.
+ *
+ * Revision 1.15  1999/10/16 18:27:10  rgb
+ * Clean-up unused cruft.
+ * Fix-up lifetime_allocations_c and lifetime_addtime_c initialisations.
+ *
+ * Revision 1.14  1999/10/08 18:37:34  rgb
+ * Fix end-of-line spacing to sate whining PHMs.
+ *
+ * Revision 1.13  1999/10/03 18:49:12  rgb
+ * Spinlock fixes for 2.0.xx and 2.3.xx.
+ *
+ * Revision 1.12  1999/10/01 15:44:54  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.11  1999/10/01 00:05:45  rgb
+ * Added tdb structure locking.
+ * Use 'jiffies' instead of do_get_timeofday().
+ * Fix lifetime assignments.
+ *
+ * Revision 1.10  1999/09/21 15:24:45  rgb
+ * Rework spirange code to save entropy and prevent endless loops.
+ *
+ * Revision 1.9  1999/09/16 12:10:21  rgb
+ * Minor fixes to random spi selection for correctness and entropy conservation.
+ *
+ * Revision 1.8  1999/05/25 22:54:46  rgb
+ * Fix comparison that should be an assignment in an if.
+ *
+ * Revision 1.7  1999/05/09 03:25:37  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.6  1999/05/08 21:32:30  rgb
+ * Fix error return reporting.
+ *
+ * Revision 1.5  1999/05/05 22:02:33  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.4  1999/04/29 15:22:40  rgb
+ * Standardise an error return method.
+ * Add debugging instrumentation.
+ * Add check for existence of macros min/max.
+ * Add extensions permitted/required in/out filters.
+ * Add satype-to-protocol table.
+ * Add a second tdb pointer to each parser to accomodate GRPSA.
+ * Move AH & no_algo_set to GETSPI, UPDATE and ADD.
+ * Add OOO window check.
+ * Add support for IPPROTO_IPIP and hooks for IPPROTO_COMP.
+ * Add timestamp to lifetime parse.
+ * Fix address structure length checking bug.
+ * Fix address structure allocation bug (forgot to kmalloc!).
+ * Add checks for extension lengths.
+ * Add checks for extension reserved illegal values.
+ * Add check for spirange legal values.
+ * Add an extension type for parsing a second satype, SA and
+ * DST_ADDRESS.
+ * Make changes to tdb_init() template to get pfkey_tdb_init(),
+ * eliminating any mention of xformsw.
+ * Implement getspi, update and grpsa (not tested).
+ * Add stubs for as yet unimplemented message types.
+ * Add table of message parsers to substitute for msg_parse switch.
+ *
+ * Revision 1.3  1999/04/15 17:58:07  rgb
+ * Add RCSID labels.
+ *
+ * Revision 1.2  1999/04/15 15:37:26  rgb
+ * Forward check changes from POST1_00 branch.
+ *
+ * Revision 1.1.2.1  1999/03/26 20:58:56  rgb
+ * Add pfkeyv2 support to KLIPS.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/radij.c linux/net/ipsec/radij.c
--- linux-noipsec/net/ipsec/radij.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/radij.c	Mon Nov  6 05:35:21 2000
@@ -0,0 +1,1113 @@
+char radij_c_version[] = "RCSID $Id$";
+
+/*
+ * This file is defived from ${SRC}/sys/net/radix.c of BSD 4.4lite
+ *
+ * Variable and procedure names have been modified so that they don't
+ * conflict with the original BSD code, as a small number of modifications
+ * have been introduced and we may want to reuse this code in BSD.
+ * 
+ * The `j' in `radij' is pronounced as a voiceless guttural (like a Greek
+ * chi or a German ch sound (as `doch', not as in `milch'), or even a 
+ * spanish j as in Juan.  It is not as far back in the throat like
+ * the corresponding Hebrew sound, nor is it a soft breath like the English h.
+ * It has nothing to do with the Dutch ij sound.
+ * 
+ * Here is the appropriate copyright notice:
+ */
+
+/*
+ * Copyright (c) 1988, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)radix.c	8.2 (Berkeley) 1/4/94
+ */
+
+/*
+ * Routines to build and maintain radix trees for routing lookups.
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/malloc.h> /* kmalloc() */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/interrupt.h> /* mark_bh */
+
+#include <linux/netdevice.h>   /* struct device, and other headers */
+#include <linux/etherdevice.h> /* eth_type_trans */
+#include <linux/ip.h>          /* struct iphdr */
+#include <linux/skbuff.h>
+#include <freeswan.h>
+#ifdef NET_21
+#include <asm/uaccess.h>
+#include <linux/in6.h>
+#endif /* NET_21 */
+#include <asm/checksum.h>
+#include <net/ip.h>
+
+#include "radij.h"
+#include "ipsec_encap.h"
+#include "ipsec_radij.h"
+#include "ipsec_netlink.h"
+
+int	maj_keylen;
+struct radij_mask *rj_mkfreelist;
+struct radij_node_head *mask_rjhead;
+static int gotOddMasks;
+static char *maskedKey;
+static char *rj_zeroes, *rj_ones;
+
+#define rj_masktop (mask_rjhead->rnh_treetop)
+#ifdef Bcmp
+#undef Bcmp
+#endif /* Bcmp */
+#define Bcmp(a, b, l) (l == 0 ? 0 : memcmp((caddr_t)(b), (caddr_t)(a), (size_t)l))
+/*
+ * The data structure for the keys is a radix tree with one way
+ * branching removed.  The index rj_b at an internal node n represents a bit
+ * position to be tested.  The tree is arranged so that all descendants
+ * of a node n have keys whose bits all agree up to position rj_b - 1.
+ * (We say the index of n is rj_b.)
+ *
+ * There is at least one descendant which has a one bit at position rj_b,
+ * and at least one with a zero there.
+ *
+ * A route is determined by a pair of key and mask.  We require that the
+ * bit-wise logical and of the key and mask to be the key.
+ * We define the index of a route to associated with the mask to be
+ * the first bit number in the mask where 0 occurs (with bit number 0
+ * representing the highest order bit).
+ * 
+ * We say a mask is normal if every bit is 0, past the index of the mask.
+ * If a node n has a descendant (k, m) with index(m) == index(n) == rj_b,
+ * and m is a normal mask, then the route applies to every descendant of n.
+ * If the index(m) < rj_b, this implies the trailing last few bits of k
+ * before bit b are all 0, (and hence consequently true of every descendant
+ * of n), so the route applies to all descendants of the node as well.
+ *
+ * The present version of the code makes no use of normal routes,
+ * but similar logic shows that a non-normal mask m such that
+ * index(m) <= index(n) could potentially apply to many children of n.
+ * Thus, for each non-host route, we attach its mask to a list at an internal
+ * node as high in the tree as we can go. 
+ */
+
+struct radij_node *
+rj_search(v_arg, head)
+	void *v_arg;
+	struct radij_node *head;
+{
+	register struct radij_node *x;
+	register caddr_t v;
+
+	for (x = head, v = v_arg; x->rj_b >= 0;) {
+		if (x->rj_bmask & v[x->rj_off])
+			x = x->rj_r;
+		else
+			x = x->rj_l;
+	}
+	return (x);
+};
+
+struct radij_node *
+rj_search_m(v_arg, head, m_arg)
+	struct radij_node *head;
+	void *v_arg, *m_arg;
+{
+	register struct radij_node *x;
+	register caddr_t v = v_arg, m = m_arg;
+
+	for (x = head; x->rj_b >= 0;) {
+		if ((x->rj_bmask & m[x->rj_off]) &&
+		    (x->rj_bmask & v[x->rj_off]))
+			x = x->rj_r;
+		else
+			x = x->rj_l;
+	}
+	return x;
+};
+
+int
+rj_refines(m_arg, n_arg)
+	void *m_arg, *n_arg;
+{
+	register caddr_t m = m_arg, n = n_arg;
+	register caddr_t lim, lim2 = lim = n + *(u_char *)n;
+	int longer = (*(u_char *)n++) - (int)(*(u_char *)m++);
+	int masks_are_equal = 1;
+
+	if (longer > 0)
+		lim -= longer;
+	while (n < lim) {
+		if (*n & ~(*m))
+			return 0;
+		if (*n++ != *m++)
+			masks_are_equal = 0;
+			
+	}
+	while (n < lim2)
+		if (*n++)
+			return 0;
+	if (masks_are_equal && (longer < 0))
+		for (lim2 = m - longer; m < lim2; )
+			if (*m++)
+				return 1;
+	return (!masks_are_equal);
+}
+
+
+struct radij_node *
+rj_match(v_arg, head)
+	void *v_arg;
+	struct radij_node_head *head;
+{
+	caddr_t v = v_arg;
+	register struct radij_node *t = head->rnh_treetop, *x;
+	register caddr_t cp = v, cp2, cp3;
+	caddr_t cplim, mstart;
+	struct radij_node *saved_t, *top = t;
+	int off = t->rj_off, vlen = *(u_char *)cp, matched_off;
+
+	/*
+	 * Open code rj_search(v, top) to avoid overhead of extra
+	 * subroutine call.
+	 */
+	for (; t->rj_b >= 0; ) {
+		if (t->rj_bmask & cp[t->rj_off])
+			t = t->rj_r;
+		else
+			t = t->rj_l;
+	}
+	/*
+	 * See if we match exactly as a host destination
+	 */
+	KLIPS_PRINT(debug_radij,
+		    "klips_debug:rj_match: * See if we match exactly as a host destination\n");
+	
+	cp += off; cp2 = t->rj_key + off; cplim = v + vlen;
+	for (; cp < cplim; cp++, cp2++)
+		if (*cp != *cp2)
+			goto on1;
+	/*
+	 * This extra grot is in case we are explicitly asked
+	 * to look up the default.  Ugh!
+	 */
+	if ((t->rj_flags & RJF_ROOT) && t->rj_dupedkey)
+		t = t->rj_dupedkey;
+	return t;
+on1:
+	matched_off = cp - v;
+	saved_t = t;
+	KLIPS_PRINT(debug_radij,
+		    "klips_debug:rj_match: ** try to match a leaf, t=0x%p\n", t);
+	do {
+	    if (t->rj_mask) {
+		/*
+		 * Even if we don't match exactly as a hosts;
+		 * we may match if the leaf we wound up at is
+		 * a route to a net.
+		 */
+		cp3 = matched_off + t->rj_mask;
+		cp2 = matched_off + t->rj_key;
+		for (; cp < cplim; cp++)
+			if ((*cp2++ ^ *cp) & *cp3++)
+				break;
+		if (cp == cplim)
+			return t;
+		cp = matched_off + v;
+	    }
+	} while ((t = t->rj_dupedkey));
+	t = saved_t;
+	/* start searching up the tree */
+	KLIPS_PRINT(debug_radij,
+		    "klips_debug:rj_match: *** start searching up the tree, t=0x%p\n", t);
+	do {
+		register struct radij_mask *m;
+		
+		t = t->rj_p;
+		KLIPS_PRINT(debug_radij,
+			    "klips_debug:rj_match: **** t=0x%p\n", t);
+		if ((m = t->rj_mklist)) {
+			/*
+			 * After doing measurements here, it may
+			 * turn out to be faster to open code
+			 * rj_search_m here instead of always
+			 * copying and masking.
+			 */
+			off = min(t->rj_off, matched_off);
+			mstart = maskedKey + off;
+			do {
+				cp2 = mstart;
+				cp3 = m->rm_mask + off;
+				KLIPS_PRINT(debug_radij,
+					    "klips_debug:rj_match: ***** cp2=0x%p cp3=0x%p\n", cp2, cp3);
+				for (cp = v + off; cp < cplim;)
+					*cp2++ =  *cp++ & *cp3++;
+				x = rj_search(maskedKey, t);
+				while (x && x->rj_mask != m->rm_mask)
+					x = x->rj_dupedkey;
+				if (x &&
+				    (Bcmp(mstart, x->rj_key + off,
+					vlen - off) == 0))
+					    return x;
+			} while ((m = m->rm_mklist));
+		}
+	} while (t != top);
+	KLIPS_PRINT(debug_radij,
+		    "klips_debug:rj_match: ***** not found.\n");
+	return 0;
+};
+		
+#ifdef RJ_DEBUG
+int	rj_nodenum;
+struct	radij_node *rj_clist;
+int	rj_saveinfo;
+DEBUG_NO_STATIC void traverse(struct radij_node *);
+#ifdef RJ_DEBUG2
+int	rj_debug =  1;
+#else
+int	rj_debug =  0;
+#endif /* RJ_DEBUG2 */
+#endif /* RJ_DEBUG */
+
+struct radij_node *
+rj_newpair(v, b, nodes)
+	void *v;
+	int b;
+	struct radij_node nodes[2];
+{
+	register struct radij_node *tt = nodes, *t = tt + 1;
+	t->rj_b = b; t->rj_bmask = 0x80 >> (b & 7);
+	t->rj_l = tt; t->rj_off = b >> 3;
+	tt->rj_b = -1; tt->rj_key = (caddr_t)v; tt->rj_p = t;
+	tt->rj_flags = t->rj_flags = RJF_ACTIVE;
+#ifdef RJ_DEBUG
+	tt->rj_info = rj_nodenum++; t->rj_info = rj_nodenum++;
+	tt->rj_twin = t; tt->rj_ybro = rj_clist; rj_clist = tt;
+#endif /* RJ_DEBUG */
+	return t;
+}
+
+struct radij_node *
+rj_insert(v_arg, head, dupentry, nodes)
+	void *v_arg;
+	struct radij_node_head *head;
+	int *dupentry;
+	struct radij_node nodes[2];
+{
+	caddr_t v = v_arg;
+	struct radij_node *top = head->rnh_treetop;
+	int head_off = top->rj_off, vlen = (int)*((u_char *)v);
+	register struct radij_node *t = rj_search(v_arg, top);
+	register caddr_t cp = v + head_off;
+	register int b;
+	struct radij_node *tt;
+    	/*
+	 *find first bit at which v and t->rj_key differ
+	 */
+    {
+	register caddr_t cp2 = t->rj_key + head_off;
+	register int cmp_res;
+	caddr_t cplim = v + vlen;
+
+	while (cp < cplim)
+		if (*cp2++ != *cp++)
+			goto on1;
+	*dupentry = 1;
+	return t;
+on1:
+	*dupentry = 0;
+	cmp_res = (cp[-1] ^ cp2[-1]) & 0xff;
+	for (b = (cp - v) << 3; cmp_res; b--)
+		cmp_res >>= 1;
+    }
+    {
+	register struct radij_node *p, *x = top;
+	cp = v;
+	do {
+		p = x;
+		if (cp[x->rj_off] & x->rj_bmask) 
+			x = x->rj_r;
+		else x = x->rj_l;
+	} while (b > (unsigned) x->rj_b); /* x->rj_b < b && x->rj_b >= 0 */
+#ifdef RJ_DEBUG
+	if (rj_debug)
+		printk("klips_debug:Going In:\n"), traverse(p);
+#endif /* RJ_DEBUG */
+	t = rj_newpair(v_arg, b, nodes); tt = t->rj_l;
+	if ((cp[p->rj_off] & p->rj_bmask) == 0)
+		p->rj_l = t;
+	else
+		p->rj_r = t;
+	x->rj_p = t; t->rj_p = p; /* frees x, p as temp vars below */
+	if ((cp[t->rj_off] & t->rj_bmask) == 0) {
+		t->rj_r = x;
+	} else {
+		t->rj_r = tt; t->rj_l = x;
+	}
+#ifdef RJ_DEBUG
+	if (rj_debug)
+		printk("klips_debug:Coming out:\n"), traverse(p);
+#endif /* RJ_DEBUG */
+    }
+	return (tt);
+}
+
+struct radij_node *
+rj_addmask(n_arg, search, skip)
+	int search, skip;
+	void *n_arg;
+{
+	caddr_t netmask = (caddr_t)n_arg;
+	register struct radij_node *x;
+	register caddr_t cp, cplim;
+	register int b, mlen, j;
+	int maskduplicated;
+
+	mlen = *(u_char *)netmask;
+	if (search) {
+		x = rj_search(netmask, rj_masktop);
+		mlen = *(u_char *)netmask;
+		if (Bcmp(netmask, x->rj_key, mlen) == 0)
+			return (x);
+	}
+	R_Malloc(x, struct radij_node *, maj_keylen + 2 * sizeof (*x));
+	if (x == 0)
+		return (0);
+	Bzero(x, maj_keylen + 2 * sizeof (*x));
+	cp = (caddr_t)(x + 2);
+	Bcopy(netmask, cp, mlen);
+	netmask = cp;
+	x = rj_insert(netmask, mask_rjhead, &maskduplicated, x);
+	/*
+	 * Calculate index of mask.
+	 */
+	cplim = netmask + mlen;
+	for (cp = netmask + skip; cp < cplim; cp++)
+		if (*(u_char *)cp != 0xff)
+			break;
+	b = (cp - netmask) << 3;
+	if (cp != cplim) {
+		if (*cp != 0) {
+			gotOddMasks = 1;
+			for (j = 0x80; j; b++, j >>= 1)  
+				if ((j & *cp) == 0)
+					break;
+		}
+	}
+	x->rj_b = -1 - b;
+	return (x);
+}
+
+#if 0
+struct radij_node *
+#endif
+int
+rj_addroute(v_arg, n_arg, head, treenodes)
+	void *v_arg, *n_arg;
+	struct radij_node_head *head;
+	struct radij_node treenodes[2];
+{
+	caddr_t v = (caddr_t)v_arg, netmask = (caddr_t)n_arg;
+	register struct radij_node *t, *x=NULL, *tt;
+	struct radij_node *saved_tt, *top = head->rnh_treetop;
+	short b = 0, b_leaf;
+	int mlen, keyduplicated;
+	caddr_t cplim;
+	struct radij_mask *m, **mp;
+
+	/*
+	 * In dealing with non-contiguous masks, there may be
+	 * many different routes which have the same mask.
+	 * We will find it useful to have a unique pointer to
+	 * the mask to speed avoiding duplicate references at
+	 * nodes and possibly save time in calculating indices.
+	 */
+	if (netmask)  {
+		x = rj_search(netmask, rj_masktop);
+		mlen = *(u_char *)netmask;
+		if (Bcmp(netmask, x->rj_key, mlen) != 0) {
+			x = rj_addmask(netmask, 0, top->rj_off);
+			if (x == 0)
+				return /* (0) rgb */ ENOMEM;
+		}
+		netmask = x->rj_key;
+		b = -1 - x->rj_b;
+	}
+	/*
+	 * Deal with duplicated keys: attach node to previous instance
+	 */
+	saved_tt = tt = rj_insert(v, head, &keyduplicated, treenodes);
+	if (keyduplicated) {
+		do {
+			if (tt->rj_mask == netmask)
+				return /* (0) rgb */ ENXIO;
+			t = tt;
+			if (netmask == 0 ||
+			    (tt->rj_mask && rj_refines(netmask, tt->rj_mask)))
+				break;
+		} while ((tt = tt->rj_dupedkey));
+		/*
+		 * If the mask is not duplicated, we wouldn't
+		 * find it among possible duplicate key entries
+		 * anyway, so the above test doesn't hurt.
+		 *
+		 * We sort the masks for a duplicated key the same way as
+		 * in a masklist -- most specific to least specific.
+		 * This may require the unfortunate nuisance of relocating
+		 * the head of the list.
+		 */
+		if (tt && t == saved_tt) {
+			struct	radij_node *xx = x;
+			/* link in at head of list */
+			(tt = treenodes)->rj_dupedkey = t;
+			tt->rj_flags = t->rj_flags;
+			tt->rj_p = x = t->rj_p;
+			if (x->rj_l == t) x->rj_l = tt; else x->rj_r = tt;
+			saved_tt = tt; x = xx;
+		} else {
+			(tt = treenodes)->rj_dupedkey = t->rj_dupedkey;
+			t->rj_dupedkey = tt;
+		}
+#ifdef RJ_DEBUG
+		t=tt+1; tt->rj_info = rj_nodenum++; t->rj_info = rj_nodenum++;
+		tt->rj_twin = t; tt->rj_ybro = rj_clist; rj_clist = tt;
+#endif /* RJ_DEBUG */
+		t = saved_tt;
+		tt->rj_key = (caddr_t) v;
+		tt->rj_b = -1;
+		tt->rj_flags = t->rj_flags & ~RJF_ROOT;
+	}
+	/*
+	 * Put mask in tree.
+	 */
+	if (netmask) {
+		tt->rj_mask = netmask;
+		tt->rj_b = x->rj_b;
+	}
+	t = saved_tt->rj_p;
+	b_leaf = -1 - t->rj_b;
+	if (t->rj_r == saved_tt) x = t->rj_l; else x = t->rj_r;
+	/* Promote general routes from below */
+	if (x->rj_b < 0) { 
+		if (x->rj_mask && (x->rj_b >= b_leaf) && x->rj_mklist == 0) {
+			MKGet(m);
+			if (m) {
+				Bzero(m, sizeof *m);
+				m->rm_b = x->rj_b;
+				m->rm_mask = x->rj_mask;
+				x->rj_mklist = t->rj_mklist = m;
+			}
+		}
+	} else if (x->rj_mklist) {
+		/*
+		 * Skip over masks whose index is > that of new node
+		 */
+		for (mp = &x->rj_mklist; (m = *mp); mp = &m->rm_mklist)
+			if (m->rm_b >= b_leaf)
+				break;
+		t->rj_mklist = m; *mp = 0;
+	}
+	/* Add new route to highest possible ancestor's list */
+	if ((netmask == 0) || (b > t->rj_b ))
+		return /* tt rgb */ 0; /* can't lift at all */
+	b_leaf = tt->rj_b;
+	do {
+		x = t;
+		t = t->rj_p;
+	} while (b <= t->rj_b && x != top);
+	/*
+	 * Search through routes associated with node to
+	 * insert new route according to index.
+	 * For nodes of equal index, place more specific
+	 * masks first.
+	 */
+	cplim = netmask + mlen;
+	for (mp = &x->rj_mklist; (m = *mp); mp = &m->rm_mklist) {
+		if (m->rm_b < b_leaf)
+			continue;
+		if (m->rm_b > b_leaf)
+			break;
+		if (m->rm_mask == netmask) {
+			m->rm_refs++;
+			tt->rj_mklist = m;
+			return /* tt rgb */ 0;
+		}
+		if (rj_refines(netmask, m->rm_mask))
+			break;
+	}
+	MKGet(m);
+	if (m == 0) {
+		printk("klips_debug:Mask for route not entered\n");
+		return /* (tt) rgb */ 0;
+	}
+	Bzero(m, sizeof *m);
+	m->rm_b = b_leaf;
+	m->rm_mask = netmask;
+	m->rm_mklist = *mp;
+	*mp = m;
+	tt->rj_mklist = m;
+	return /* tt rgb */ 0;
+}
+
+int
+rj_delete(v_arg, netmask_arg, head, node)
+	void *v_arg, *netmask_arg;
+	struct radij_node_head *head;
+	struct radij_node **node;
+{
+	register struct radij_node *t, *p, *x, *tt;
+	struct radij_mask *m, *saved_m, **mp;
+	struct radij_node *dupedkey, *saved_tt, *top;
+	caddr_t v, netmask;
+	int b, head_off, vlen;
+
+	v = v_arg;
+	netmask = netmask_arg;
+	x = head->rnh_treetop;
+	tt = rj_search(v, x);
+	head_off = x->rj_off;
+	vlen =  *(u_char *)v;
+	saved_tt = tt;
+	top = x;
+	if (tt == 0 ||
+	    Bcmp(v + head_off, tt->rj_key + head_off, vlen - head_off))
+		return /* (0) rgb */ -EFAULT;
+	/*
+	 * Delete our route from mask lists.
+	 */
+	if ((dupedkey = tt->rj_dupedkey)) {
+		if (netmask) 
+			netmask = rj_search(netmask, rj_masktop)->rj_key;
+		while (tt->rj_mask != netmask)
+			if ((tt = tt->rj_dupedkey) == 0)
+				return /* (0) rgb */ -ENXIO;
+	}
+	if (tt->rj_mask == 0 || (saved_m = m = tt->rj_mklist) == 0)
+		goto on1;
+	if (m->rm_mask != tt->rj_mask) {
+		printk("klips_debug:rj_delete: inconsistent annotation\n");
+		goto on1;
+	}
+	if (--m->rm_refs >= 0)
+		goto on1;
+	b = -1 - tt->rj_b;
+	t = saved_tt->rj_p;
+	if (b > t->rj_b)
+		goto on1; /* Wasn't lifted at all */
+	do {
+		x = t;
+		t = t->rj_p;
+	} while (b <= t->rj_b && x != top);
+	for (mp = &x->rj_mklist; (m = *mp); mp = &m->rm_mklist)
+		if (m == saved_m) {
+			*mp = m->rm_mklist;
+			MKFree(m);
+			break;
+		}
+	if (m == 0)
+		printk("klips_debug:rj_delete: couldn't find our annotation\n");
+on1:
+	/*
+	 * Eliminate us from tree
+	 */
+	if (tt->rj_flags & RJF_ROOT)
+		return /* (0) rgb */ -EFAULT;
+#ifdef RJ_DEBUG
+	/* Get us out of the creation list */
+	for (t = rj_clist; t && t->rj_ybro != tt; t = t->rj_ybro) {}
+	if (t) t->rj_ybro = tt->rj_ybro;
+#endif /* RJ_DEBUG */
+	t = tt->rj_p;
+	if (dupedkey) {
+		if (tt == saved_tt) {
+			x = dupedkey; x->rj_p = t;
+			if (t->rj_l == tt) t->rj_l = x; else t->rj_r = x;
+		} else {
+			for (x = p = saved_tt; p && p->rj_dupedkey != tt;)
+				p = p->rj_dupedkey;
+			if (p) p->rj_dupedkey = tt->rj_dupedkey;
+			else printk("klips_debug:rj_delete: couldn't find us\n");
+		}
+		t = tt + 1;
+		if  (t->rj_flags & RJF_ACTIVE) {
+#ifndef RJ_DEBUG
+			*++x = *t; p = t->rj_p;
+#else
+			b = t->rj_info; *++x = *t; t->rj_info = b; p = t->rj_p;
+#endif /* RJ_DEBUG */
+			if (p->rj_l == t) p->rj_l = x; else p->rj_r = x;
+			x->rj_l->rj_p = x; x->rj_r->rj_p = x;
+		}
+		goto out;
+	}
+	if (t->rj_l == tt) x = t->rj_r; else x = t->rj_l;
+	p = t->rj_p;
+	if (p->rj_r == t) p->rj_r = x; else p->rj_l = x;
+	x->rj_p = p;
+	/*
+	 * Demote routes attached to us.
+	 */
+	if (t->rj_mklist) {
+		if (x->rj_b >= 0) {
+			for (mp = &x->rj_mklist; (m = *mp);)
+				mp = &m->rm_mklist;
+			*mp = t->rj_mklist;
+		} else {
+			for (m = t->rj_mklist; m;) {
+				struct radij_mask *mm = m->rm_mklist;
+				if (m == x->rj_mklist && (--(m->rm_refs) < 0)) {
+					x->rj_mklist = 0;
+					MKFree(m);
+				} else 
+					printk("klips_debug:%s %p at %p\n",
+					    "rj_delete: Orphaned Mask", m, x);
+				m = mm;
+			}
+		}
+	}
+	/*
+	 * We may be holding an active internal node in the tree.
+	 */
+	x = tt + 1;
+	if (t != x) {
+#ifndef RJ_DEBUG
+		*t = *x;
+#else
+		b = t->rj_info; *t = *x; t->rj_info = b;
+#endif /* RJ_DEBUG */
+		t->rj_l->rj_p = t; t->rj_r->rj_p = t;
+		p = x->rj_p;
+		if (p->rj_l == x) p->rj_l = t; else p->rj_r = t;
+	}
+out:
+	tt->rj_flags &= ~RJF_ACTIVE;
+	tt[1].rj_flags &= ~RJF_ACTIVE;
+	*node = tt;
+	return /* (tt) rgb */ 0;
+}
+
+int
+rj_walktree(h, f, w)
+	struct radij_node_head *h;
+	register int (*f)(struct radij_node *,void *);
+	void *w;
+{
+	int error;
+	struct radij_node *base, *next;
+	register struct radij_node *rn;
+
+	if(!h || !f /* || !w */) {
+		return -1;
+	}
+
+	rn = h->rnh_treetop;
+	/*
+	 * This gets complicated because we may delete the node
+	 * while applying the function f to it, so we need to calculate
+	 * the successor node in advance.
+	 */
+	/* First time through node, go left */
+	while (rn->rj_b >= 0)
+		rn = rn->rj_l;
+	for (;;) {
+#ifdef CONFIG_IPSEC_DEBUG
+		if(debug_radij) {
+			printk("klips_debug:RN_WALKTREE: for: rn=%p rj_b=%d rj_flags=%x", rn, rn->rj_b, rn->rj_flags);
+			rn->rj_b >= 0 ?
+				printk(" node off=%x\n", rn->rj_off) :
+				printk(" leaf key = %08x->%08x\n",
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_src.s_addr),
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_dst.s_addr))
+				;
+		}
+#endif /* CONFIG_IPSEC_DEBUG */
+		base = rn;
+		/* If at right child go back up, otherwise, go right */
+		while (rn->rj_p->rj_r == rn && (rn->rj_flags & RJF_ROOT) == 0)
+			rn = rn->rj_p;
+		/* Find the next *leaf* since next node might vanish, too */
+		for (rn = rn->rj_p->rj_r; rn->rj_b >= 0;)
+			rn = rn->rj_l;
+		next = rn;
+#ifdef CONFIG_IPSEC_DEBUG
+		if(debug_radij) {
+			printk("klips_debug:RN_WALKTREE: processing leaves, rn=%p rj_b=%d rj_flags=%x", rn, rn->rj_b, rn->rj_flags);
+			rn->rj_b >= 0 ?
+				printk(" node off=%x\n", rn->rj_off) :
+				printk(" leaf key = %08x->%08x\n",
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_src.s_addr),
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_dst.s_addr))
+				;
+		}
+#endif /* CONFIG_IPSEC_DEBUG */
+		/* Process leaves */
+		while ((rn = base)) {
+			base = rn->rj_dupedkey;
+#ifdef CONFIG_IPSEC_DEBUG
+			if(debug_radij) {
+				printk("klips_debug:RN_WALKTREE: while: base=%p rn=%p rj_b=%d rj_flags=%x",
+				       base, rn, rn->rj_b, rn->rj_flags);
+				rn->rj_b >= 0 ?
+					printk(" node off=%x\n", rn->rj_off) :
+					printk(" leaf key = %08x->%08x\n",
+					       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_src.s_addr),
+					       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_dst.s_addr))
+					;
+			}
+#endif /* CONFIG_IPSEC_DEBUG */
+			if (!(rn->rj_flags & RJF_ROOT) && (error = (*f)(rn, w)))
+				return (-error);
+		}
+		rn = next;
+		if (rn->rj_flags & RJF_ROOT)
+			return (0);
+	}
+	/* NOTREACHED */
+}
+
+int
+rj_inithead(head, off)
+	void **head;
+	int off;
+{
+	register struct radij_node_head *rnh;
+	register struct radij_node *t, *tt, *ttt;
+	if (*head)
+		return (1);
+	R_Malloc(rnh, struct radij_node_head *, sizeof (*rnh));
+	if (rnh == 0)
+		return (0);
+	Bzero(rnh, sizeof (*rnh));
+	*head = rnh;
+	t = rj_newpair(rj_zeroes, off, rnh->rnh_nodes);
+	ttt = rnh->rnh_nodes + 2;
+	t->rj_r = ttt;
+	t->rj_p = t;
+	tt = t->rj_l;
+	tt->rj_flags = t->rj_flags = RJF_ROOT | RJF_ACTIVE;
+	tt->rj_b = -1 - off;
+	*ttt = *tt;
+	ttt->rj_key = rj_ones;
+	rnh->rnh_addaddr = rj_addroute;
+	rnh->rnh_deladdr = rj_delete;
+	rnh->rnh_matchaddr = rj_match;
+	rnh->rnh_walktree = rj_walktree;
+	rnh->rnh_treetop = t;
+	return (1);
+}
+
+void
+rj_init()
+{
+	char *cp, *cplim;
+
+	if (maj_keylen == 0) {
+		printk("klips_debug:rj_init: radij functions require maj_keylen be set\n");
+		return;
+	}
+	R_Malloc(rj_zeroes, char *, 3 * maj_keylen);
+	if (rj_zeroes == NULL)
+		panic("rj_init");
+	Bzero(rj_zeroes, 3 * maj_keylen);
+	rj_ones = cp = rj_zeroes + maj_keylen;
+	maskedKey = cplim = rj_ones + maj_keylen;
+	while (cp < cplim)
+		*cp++ = -1;
+	if (rj_inithead((void **)&mask_rjhead, 0) == 0)
+		panic("rj_init 2");
+}
+
+void
+rj_preorder(struct radij_node *rn, int l)
+{
+	int i;
+	
+	if (rn == NULL){
+		printk("klips_debug:rj_preorder: NULL pointer\n");
+		return;
+	}
+	
+	if (rn->rj_b >= 0){
+		rj_preorder(rn->rj_l, l+1);
+		rj_preorder(rn->rj_r, l+1);
+		printk("klips_debug:");
+		for (i=0; i<l; i++)
+			printk("*");
+		printk(" off = %d\n", rn->rj_off);
+	} else {
+		printk("klips_debug:");
+		for (i=0; i<l; i++)
+			printk("@");
+		printk(" flags = %x", (u_int)rn->rj_flags);
+		if (rn->rj_flags & RJF_ACTIVE) {
+			printk(" @key = %p", rn->rj_key);
+			
+			printk(" key = %08x->%08x",
+			       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_src.s_addr),
+			       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_key)->sen_ip_dst.s_addr));
+
+			printk(" @mask = %p", rn->rj_mask);
+			if (rn->rj_mask)
+				printk(" mask = %08x->%08x",
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_mask)->sen_ip_src.s_addr),
+				       (u_int)ntohl(((struct sockaddr_encap *)rn->rj_mask)->sen_ip_dst.s_addr));
+		
+			if (rn->rj_dupedkey)
+				printk(" dupedkey = %08x", (u_int)rn->rj_dupedkey);
+		}
+		printk("\n");
+	}
+}
+
+#ifdef RJ_DEBUG
+DEBUG_NO_STATIC void traverse(struct radij_node *p)
+{
+  rj_preorder(p, 0);
+}
+#endif /* RJ_DEBUG */
+
+void
+rj_dumptrees(void)
+{
+	rj_preorder(rnh->rnh_treetop, 0);
+}
+
+void
+rj_free_mkfreelist(void)
+{
+	struct radij_mask *mknp, *mknp2;
+
+	mknp = rj_mkfreelist;
+	while(mknp)
+	{
+		mknp2 = mknp;
+		mknp = mknp->rm_mklist;
+		kfree(mknp2);
+	}
+}
+
+int
+radijcleartree(void)
+{
+	return rj_walktree(rnh, ipsec_rj_walker_delete, NULL);
+}
+
+int
+radijcleanup(void)
+{
+	int error = 0;
+
+	error = radijcleartree();
+
+	rj_free_mkfreelist();
+
+/*	rj_walktree(mask_rjhead, ipsec_rj_walker_delete, NULL); */
+  	if(mask_rjhead) {
+		kfree(mask_rjhead);
+	}
+
+	if(rj_zeroes) {
+		kfree(rj_zeroes);
+	}
+
+	if(rnh) {
+		kfree(rnh);
+	}
+
+	return error;
+}
+
+/*
+ * $Log$
+ * Revision 1.31  2000/11/06 04:35:21  rgb
+ * Clear table *before* releasing other items in radijcleanup.
+ *
+ * Revision 1.30  2000/09/20 04:07:40  rgb
+ * Changed static functions to DEBUG_NO_STATIC to reveal function names in
+ * oopsen.
+ *
+ * Revision 1.29  2000/09/12 03:25:02  rgb
+ * Moved radij_c_version printing to ipsec_version_get_info().
+ *
+ * Revision 1.28  2000/09/08 19:12:56  rgb
+ * Change references from DEBUG_IPSEC to CONFIG_IPSEC_DEBUG.
+ *
+ * Revision 1.27  2000/07/28 14:58:32  rgb
+ * Changed kfree_s to kfree, eliminating extra arg to fix 2.4.0-test5.
+ *
+ * Revision 1.26  2000/05/10 23:11:37  rgb
+ * Comment out most of the startup version information.
+ *
+ * Revision 1.25  2000/01/21 06:21:47  rgb
+ * Change return codes to negative on error.
+ *
+ * Revision 1.24  1999/11/18 04:09:20  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.23  1999/11/17 15:53:41  rgb
+ * Changed all occurrences of #include "../../../lib/freeswan.h"
+ * to #include <freeswan.h> which works due to -Ilibfreeswan in the
+ * klips/net/ipsec/Makefile.
+ *
+ * Revision 1.22  1999/10/15 22:17:28  rgb
+ * Modify radijcleanup() to call radijcleartree().
+ *
+ * Revision 1.21  1999/10/08 18:37:34  rgb
+ * Fix end-of-line spacing to sate whining PHMs.
+ *
+ * Revision 1.20  1999/10/01 15:44:54  rgb
+ * Move spinlock header include to 2.1> scope.
+ *
+ * Revision 1.19  1999/10/01 08:35:52  rgb
+ * Add spinlock include to shut up compiler for 2.0.38.
+ *
+ * Revision 1.18  1999/09/23 18:02:52  rgb
+ * De-alarm the search failure message so it doesn't sound so grave.
+ *
+ * Revision 1.17  1999/05/25 21:26:01  rgb
+ * Fix rj_walktree() sanity checking bug.
+ *
+ * Revision 1.16  1999/05/09 03:25:38  rgb
+ * Fix bug introduced by 2.2 quick-and-dirty patch.
+ *
+ * Revision 1.15  1999/05/05 22:02:33  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.14  1999/04/29 15:24:15  rgb
+ * Add sanity checking for null pointer arguments.
+ * Standardise an error return method.
+ *
+ * Revision 1.13  1999/04/11 00:29:02  henry
+ * GPL boilerplate
+ *
+ * Revision 1.12  1999/04/06 04:54:28  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.11  1999/02/17 16:52:53  rgb
+ * Convert DEBUG_IPSEC to KLIPS_PRINT
+ * Clean out unused cruft.
+ *
+ * Revision 1.10  1999/01/22 06:30:05  rgb
+ * Cruft clean-out.
+ * 64-bit clean-up.
+ *
+ * Revision 1.9  1998/12/01 13:22:04  rgb
+ * Added support for debug printing of version info.
+ *
+ * Revision 1.8  1998/11/30 13:22:55  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.7  1998/10/25 02:43:26  rgb
+ * Change return type on rj_addroute and rj_delete and add and argument
+ * to the latter to be able to transmit more infomation about errors.
+ *
+ * Revision 1.6  1998/10/19 14:30:06  rgb
+ * Added inclusion of freeswan.h.
+ *
+ * Revision 1.5  1998/10/09 04:33:27  rgb
+ * Added 'klips_debug' prefix to all klips printk debug statements.
+ * Fixed output formatting slightly.
+ *
+ * Revision 1.4  1998/07/28 00:06:59  rgb
+ * Add debug detail to tree traversing.
+ *
+ * Revision 1.3  1998/07/14 18:07:58  rgb
+ * Add a routine to clear the eroute tree.
+ *
+ * Revision 1.2  1998/06/25 20:03:22  rgb
+ * Cleanup #endif comments.  Debug output for rj_init.
+ *
+ * Revision 1.1  1998/06/18 21:30:22  henry
+ * move sources from klips/src to klips/net/ipsec to keep stupid kernel
+ * build scripts happier about symlinks
+ *
+ * Revision 1.8  1998/05/25 20:34:15  rgb
+ * Remove temporary ipsec_walk, rj_deltree and rj_delnodes functions.
+ *
+ * Rename ipsec_rj_walker (ipsec_walk) to ipsec_rj_walker_procprint and
+ * add ipsec_rj_walker_delete.
+ *
+ * Recover memory for eroute table on unload of module.
+ *
+ * Revision 1.7  1998/05/21 12:58:58  rgb
+ * Moved 'extern' definitions to ipsec_radij.h to support /proc 3k limit fix.
+ *
+ * Revision 1.6  1998/04/23 20:57:29  rgb
+ * Cleaned up compiler warnings for unused debugging functions.
+ *
+ * Revision 1.5  1998/04/22 16:51:38  rgb
+ * Tidy up radij debug code from recent rash of modifications to debug code.
+ *
+ * Revision 1.4  1998/04/21 21:28:56  rgb
+ * Rearrange debug switches to change on the fly debug output from user
+ * space.  Only kernel changes checked in at this time.  radij.c was also
+ * changed to temporarily remove buggy debugging code in rj_delete causing
+ * an OOPS and hence, netlink device open errors.
+ *
+ * Revision 1.3  1998/04/14 17:30:37  rgb
+ * Fix up compiling errors for radij tree memory reclamation.
+ *
+ * Revision 1.2  1998/04/12 22:03:25  rgb
+ * Updated ESP-3DES-HMAC-MD5-96,
+ * 	ESP-DES-HMAC-MD5-96,
+ * 	AH-HMAC-MD5-96,
+ * 	AH-HMAC-SHA1-96 since Henry started freeswan cvs repository
+ * from old standards (RFC182[5-9] to new (as of March 1998) drafts.
+ *
+ * Fixed eroute references in /proc/net/ipsec*.
+ *
+ * Started to patch module unloading memory leaks in ipsec_netlink and
+ * radij tree unloading.
+ *
+ * Revision 1.1  1998/04/09 03:06:15  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:03  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:39:04  ji
+ * Minor cleanups.
+ * Rationalized debugging code.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/radij.h linux/net/ipsec/radij.h
--- linux-noipsec/net/ipsec/radij.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/radij.h	Thu Nov 18 05:09:20 1999
@@ -0,0 +1,291 @@
+/*
+ * RCSID $Id$
+ */
+
+/*
+ * This file is defived from ${SRC}/sys/net/radix.h of BSD 4.4lite
+ *
+ * Variable and procedure names have been modified so that they don't
+ * conflict with the original BSD code, as a small number of modifications
+ * have been introduced and we may want to reuse this code in BSD.
+ * 
+ * The `j' in `radij' is pronounced as a voiceless guttural (like a Greek
+ * chi or a German ch sound (as `doch', not as in `milch'), or even a 
+ * spanish j as in Juan.  It is not as far back in the throat like
+ * the corresponding Hebrew sound, nor is it a soft breath like the English h.
+ * It has nothing to do with the Dutch ij sound.
+ * 
+ * Here is the appropriate copyright notice:
+ */
+
+/*
+ * Copyright (c) 1988, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)radix.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _RADIJ_H_
+#define	_RADIJ_H_
+
+/* 
+#define RJ_DEBUG
+*/
+
+#ifdef __KERNEL__
+
+#ifndef __P
+#ifdef __STDC__
+#define __P(x)  x
+#else
+#define __P(x)  ()
+#endif
+#endif
+
+#ifndef NET_21
+#ifndef min
+static __inline__ int min(unsigned int a, unsigned int b)
+{
+        if (a > b)
+                a = b;
+        return a;
+}
+#endif /* !min */
+
+#ifndef max
+static __inline__ int max(unsigned int a, unsigned int b)
+{
+        if (a < b)
+                a = b;
+        return a;
+}
+#endif /* !max */
+#endif /* NET_21 */
+
+/*
+ * Radix search tree node layout.
+ */
+
+struct radij_node
+{
+	struct	radij_mask *rj_mklist;	/* list of masks contained in subtree */
+	struct	radij_node *rj_p;	/* parent */
+	short	rj_b;			/* bit offset; -1-index(netmask) */
+	char	rj_bmask;		/* node: mask for bit test*/
+	u_char	rj_flags;		/* enumerated next */
+#define RJF_NORMAL	1		/* leaf contains normal route */
+#define RJF_ROOT	2		/* leaf is root leaf for tree */
+#define RJF_ACTIVE	4		/* This node is alive (for rtfree) */
+	union {
+		struct {			/* leaf only data: */
+			caddr_t	rj_Key;	/* object of search */
+			caddr_t	rj_Mask;	/* netmask, if present */
+			struct	radij_node *rj_Dupedkey;
+		} rj_leaf;
+		struct {			/* node only data: */
+			int	rj_Off;		/* where to start compare */
+			struct	radij_node *rj_L;/* progeny */
+			struct	radij_node *rj_R;/* progeny */
+		}rj_node;
+	}		rj_u;
+#ifdef RJ_DEBUG
+	int rj_info;
+	struct radij_node *rj_twin;
+	struct radij_node *rj_ybro;
+#endif
+};
+
+#define rj_dupedkey rj_u.rj_leaf.rj_Dupedkey
+#define rj_key rj_u.rj_leaf.rj_Key
+#define rj_mask rj_u.rj_leaf.rj_Mask
+#define rj_off rj_u.rj_node.rj_Off
+#define rj_l rj_u.rj_node.rj_L
+#define rj_r rj_u.rj_node.rj_R
+
+/*
+ * Annotations to tree concerning potential routes applying to subtrees.
+ */
+
+extern struct radij_mask {
+	short	rm_b;			/* bit offset; -1-index(netmask) */
+	char	rm_unused;		/* cf. rj_bmask */
+	u_char	rm_flags;		/* cf. rj_flags */
+	struct	radij_mask *rm_mklist;	/* more masks to try */
+	caddr_t	rm_mask;		/* the mask */
+	int	rm_refs;		/* # of references to this struct */
+} *rj_mkfreelist;
+
+#define MKGet(m) {\
+	if (rj_mkfreelist) {\
+		m = rj_mkfreelist; \
+		rj_mkfreelist = (m)->rm_mklist; \
+	} else \
+		R_Malloc(m, struct radij_mask *, sizeof (*(m))); }\
+
+#define MKFree(m) { (m)->rm_mklist = rj_mkfreelist; rj_mkfreelist = (m);}
+
+struct radij_node_head {
+	struct	radij_node *rnh_treetop;
+	int	rnh_addrsize;		/* permit, but not require fixed keys */
+	int	rnh_pktsize;		/* permit, but not require fixed keys */
+#if 0
+	struct	radij_node *(*rnh_addaddr)	/* add based on sockaddr */
+		__P((void *v, void *mask,
+		     struct radij_node_head *head, struct radij_node nodes[]));
+#endif
+	int (*rnh_addaddr)	/* add based on sockaddr */
+		__P((void *v, void *mask,
+		     struct radij_node_head *head, struct radij_node nodes[]));
+	struct	radij_node *(*rnh_addpkt)	/* add based on packet hdr */
+		__P((void *v, void *mask,
+		     struct radij_node_head *head, struct radij_node nodes[]));
+#if 0
+	struct	radij_node *(*rnh_deladdr)	/* remove based on sockaddr */
+		__P((void *v, void *mask, struct radij_node_head *head));
+#endif
+	int (*rnh_deladdr)	/* remove based on sockaddr */
+		__P((void *v, void *mask, struct radij_node_head *head, struct radij_node **node));
+	struct	radij_node *(*rnh_delpkt)	/* remove based on packet hdr */
+		__P((void *v, void *mask, struct radij_node_head *head));
+	struct	radij_node *(*rnh_matchaddr)	/* locate based on sockaddr */
+		__P((void *v, struct radij_node_head *head));
+	struct	radij_node *(*rnh_matchpkt)	/* locate based on packet hdr */
+		__P((void *v, struct radij_node_head *head));
+	int	(*rnh_walktree)			/* traverse tree */
+		__P((struct radij_node_head *head, int (*f)(struct radij_node *rn, void *w), void *w));
+	struct	radij_node rnh_nodes[3];	/* empty tree for common case */
+};
+
+
+#define Bcmp(a, b, n) memcmp(((caddr_t)(b)), ((caddr_t)(a)), (unsigned)(n))
+#define Bcopy(a, b, n) memmove(((caddr_t)(b)), ((caddr_t)(a)), (unsigned)(n))
+#define Bzero(p, n) memset((caddr_t)(p), 0, (unsigned)(n))
+#define R_Malloc(p, t, n) ((p = (t) kmalloc((size_t)(n), GFP_ATOMIC)), Bzero((p),(n)))
+#define Free(p) kfree((caddr_t)p);
+
+void	 rj_init __P((void));
+int	 rj_inithead __P((void **, int));
+int	 rj_refines __P((void *, void *));
+int	 rj_walktree __P((struct radij_node_head *head, int (*f)(struct radij_node *rn, void *w), void *w));
+struct radij_node
+	 *rj_addmask __P((void *, int, int)) /* , rgb */ ;
+int /* * */ rj_addroute __P((void *, void *, struct radij_node_head *,
+			struct radij_node [2])) /* , rgb */ ;
+int /* * */ rj_delete __P((void *, void *, struct radij_node_head *, struct radij_node **)) /* , rgb */ ;
+struct radij_node /* rgb */
+	 *rj_insert __P((void *, struct radij_node_head *, int *,
+			struct radij_node [2])),
+	 *rj_match __P((void *, struct radij_node_head *)),
+	 *rj_newpair __P((void *, int, struct radij_node[2])),
+	 *rj_search __P((void *, struct radij_node *)),
+	 *rj_search_m __P((void *, struct radij_node *, void *));
+
+void rj_deltree(struct radij_node_head *);
+void rj_delnodes(struct radij_node *);
+void rj_free_mkfreelist(void);
+int radijcleartree(void);
+int radijcleanup(void);
+
+extern struct radij_node_head *mask_rjhead;
+extern int maj_keylen;
+#endif /* __KERNEL__ */
+
+#endif /* _RADIJ_H_ */
+
+
+/*
+ * $Log$
+ * Revision 1.10  1999/11/18 04:09:20  rgb
+ * Replaced all kernel version macros to shorter, readable form.
+ *
+ * Revision 1.9  1999/05/05 22:02:33  rgb
+ * Add a quick and dirty port to 2.2 kernels by Marc Boucher <marc@mbsi.ca>.
+ *
+ * Revision 1.8  1999/04/29 15:24:58  rgb
+ * Add check for existence of macros min/max.
+ *
+ * Revision 1.7  1999/04/11 00:29:02  henry
+ * GPL boilerplate
+ *
+ * Revision 1.6  1999/04/06 04:54:29  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ * Revision 1.5  1999/01/22 06:30:32  rgb
+ * 64-bit clean-up.
+ *
+ * Revision 1.4  1998/11/30 13:22:55  rgb
+ * Rationalised all the klips kernel file headers.  They are much shorter
+ * now and won't conflict under RH5.2.
+ *
+ * Revision 1.3  1998/10/25 02:43:27  rgb
+ * Change return type on rj_addroute and rj_delete and add and argument
+ * to the latter to be able to transmit more infomation about errors.
+ *
+ * Revision 1.2  1998/07/14 18:09:51  rgb
+ * Add a routine to clear eroute table.
+ * Added #ifdef __KERNEL__ directives to restrict scope of header.
+ *
+ * Revision 1.1  1998/06/18 21:30:22  henry
+ * move sources from klips/src to klips/net/ipsec to keep stupid kernel
+ * build scripts happier about symlinks
+ *
+ * Revision 1.4  1998/05/25 20:34:16  rgb
+ * Remove temporary ipsec_walk, rj_deltree and rj_delnodes functions.
+ *
+ * Rename ipsec_rj_walker (ipsec_walk) to ipsec_rj_walker_procprint and
+ * add ipsec_rj_walker_delete.
+ *
+ * Recover memory for eroute table on unload of module.
+ *
+ * Revision 1.3  1998/04/22 16:51:37  rgb
+ * Tidy up radij debug code from recent rash of modifications to debug code.
+ *
+ * Revision 1.2  1998/04/14 17:30:38  rgb
+ * Fix up compiling errors for radij tree memory reclamation.
+ *
+ * Revision 1.1  1998/04/09 03:06:16  henry
+ * sources moved up from linux/net/ipsec
+ *
+ * Revision 1.1.1.1  1998/04/08 05:35:04  henry
+ * RGB's ipsec-0.8pre2.tar.gz ipsec-0.8
+ *
+ * Revision 0.4  1997/01/15 01:28:15  ji
+ * No changes.
+ *
+ * Revision 0.3  1996/11/20 14:44:45  ji
+ * Release update only.
+ *
+ * Revision 0.2  1996/11/02 00:18:33  ji
+ * First limited release.
+ *
+ *
+ */
diff -druN linux-noipsec/net/ipsec/sysctl_net_ipsec.c linux/net/ipsec/sysctl_net_ipsec.c
--- linux-noipsec/net/ipsec/sysctl_net_ipsec.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/sysctl_net_ipsec.c	Sat Sep 16 03:50:15 2000
@@ -0,0 +1,174 @@
+/*
+ * sysctl interface to net IPSEC subsystem.
+ * Copyright (C) 1998, 1999, 2000  Richard Guy Briggs.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * RCSID $Id$
+ */
+
+/* -*- linux-c -*-
+ *
+ * Initiated April 3, 1998, Richard Guy Briggs <rgb@conscoop.ottawa.on.ca>
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+#ifdef CONFIG_SYSCTL
+
+#define NET_IPSEC 2112 /* Random number */                                        
+#ifdef CONFIG_IPSEC_DEBUG
+extern int       debug_ah;
+extern int       debug_esp;
+extern int       debug_tunnel;
+extern int       debug_eroute;
+extern int       debug_spi;
+extern int       debug_radij;
+extern int       debug_netlink;
+extern int       debug_xform;
+extern int       debug_rcv;
+extern int       debug_pfkey;
+extern int sysctl_ipsec_debug_verbose;
+#ifdef CONFIG_IPSEC_IPCOMP
+extern int sysctl_ipsec_debug_ipcomp;
+#endif /* CONFIG_IPSEC_IPCOMP */
+#endif /* CONFIG_IPSEC_DEBUG */
+
+extern int sysctl_ipsec_icmp;
+extern int sysctl_ipsec_no_eroute_pass;
+extern int sysctl_ipsec_inbound_policy_check;
+extern int sysctl_ipsec_opportunistic;
+extern int sysctl_ipsec_tos;
+
+enum {
+#ifdef CONFIG_IPSEC_DEBUG
+	NET_IPSEC_DEBUG_AH=1,
+	NET_IPSEC_DEBUG_ESP=2,
+	NET_IPSEC_DEBUG_TUNNEL=3,
+	NET_IPSEC_DEBUG_EROUTE=4,
+	NET_IPSEC_DEBUG_SPI=5,
+	NET_IPSEC_DEBUG_RADIJ=6,
+	NET_IPSEC_DEBUG_NETLINK=7,
+	NET_IPSEC_DEBUG_XFORM=8,
+	NET_IPSEC_DEBUG_RCV=9,
+	NET_IPSEC_DEBUG_PFKEY=10,
+	NET_IPSEC_DEBUG_VERBOSE=11,
+	NET_IPSEC_DEBUG_IPCOMP=12,
+#endif /* CONFIG_IPSEC_DEBUG */
+	NET_IPSEC_ICMP=13,
+	NET_IPSEC_NO_EROUTE_PASS=14,
+	NET_IPSEC_INBOUND_POLICY_CHECK=15,
+	NET_IPSEC_OPPORTUNISTIC=16,
+	NET_IPSEC_TOS=17
+};
+
+static ctl_table ipsec_table[] = {
+#ifdef CONFIG_IPSEC_DEBUG
+	{ NET_IPSEC_DEBUG_AH, "debug_ah", &debug_ah,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_ESP, "debug_esp", &debug_esp,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_TUNNEL, "debug_tunnel", &debug_tunnel,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_EROUTE, "debug_eroute", &debug_eroute,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_SPI, "debug_spi", &debug_spi,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_RADIJ, "debug_radij", &debug_radij,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_NETLINK, "debug_netlink", &debug_netlink,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_XFORM, "debug_xform", &debug_xform,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_RCV, "debug_rcv", &debug_rcv,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_PFKEY, "debug_pfkey", &debug_pfkey,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_DEBUG_VERBOSE, "debug_verbose",&sysctl_ipsec_debug_verbose,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+#ifdef CONFIG_IPSEC_IPCOMP
+	{ NET_IPSEC_DEBUG_IPCOMP, "debug_ipcomp", &sysctl_ipsec_debug_ipcomp,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+#endif /* CONFIG_IPSEC_IPCOMP */
+#endif /* CONFIG_IPSEC_DEBUG */
+	{ NET_IPSEC_ICMP, "icmp", &sysctl_ipsec_icmp,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_NO_EROUTE_PASS, "no_eroute_pass", &sysctl_ipsec_no_eroute_pass,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_INBOUND_POLICY_CHECK, "inbound_policy_check", &sysctl_ipsec_inbound_policy_check,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_OPPORTUNISTIC, "opportunistic", &sysctl_ipsec_opportunistic,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{ NET_IPSEC_TOS, "tos", &sysctl_ipsec_tos,
+	  sizeof(int), 0644, NULL, &proc_dointvec},    
+	{0}
+};
+
+static ctl_table ipsec_net_table[] = {
+        { NET_IPSEC, "ipsec", NULL, 0, 0555, ipsec_table },
+        { 0 }
+};
+ 
+static ctl_table ipsec_root_table[] = {
+        { CTL_NET, "net", NULL, 0, 0555, ipsec_net_table },
+        { 0 }
+};
+ 
+static struct ctl_table_header *ipsec_table_header;
+
+int ipsec_sysctl_register(void)
+{
+        ipsec_table_header = register_sysctl_table(ipsec_root_table, 0);
+        if (!ipsec_table_header) {
+                return -ENOMEM;
+	}
+        return 0;
+}
+ 
+void ipsec_sysctl_unregister(void)
+{
+        unregister_sysctl_table(ipsec_table_header);
+}
+
+#endif /* CONFIG_SYSCTL */
+
+/*
+ * $Log$
+ * Revision 1.10  2000/09/16 01:50:15  rgb
+ * Protect sysctl_ipsec_debug_ipcomp with compiler defines too so that the
+ * linker won't blame rj_delete() for missing symbols.  ;->  Damn statics...
+ *
+ * Revision 1.9  2000/09/15 23:17:51  rgb
+ * Moved stuff around to compile with debug off.
+ *
+ * Revision 1.8  2000/09/15 11:37:02  rgb
+ * Merge in heavily modified Svenning Soerensen's <svenning@post5.tele.dk>
+ * IPCOMP zlib deflate code.
+ *
+ * Revision 1.7  2000/09/15 07:37:15  rgb
+ * Munged silly log comment that was causing a warning.
+ *
+ * Revision 1.6  2000/09/15 04:58:23  rgb
+ * Added tos runtime switch.
+ * Removed 'sysctl_ipsec_' prefix from /proc/sys/net/ipsec/ filenames.
+ *
+ * Revision 1.5  2000/09/12 03:25:28  rgb
+ * Filled in and implemented sysctl.
+ *
+ * Revision 1.4  1999/04/11 00:29:03  henry
+ * GPL boilerplate
+ *
+ * Revision 1.3  1999/04/06 04:54:29  rgb
+ * Fix/Add RCSID Id: and Log: bits to make PHMDs happy.  This includes
+ * patch shell fixes.
+ *
+ */
diff -druN linux-noipsec/net/ipsec/version.c linux/net/ipsec/version.c
--- linux-noipsec/net/ipsec/version.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/version.c	Thu Nov 30 06:02:51 2000
@@ -0,0 +1,2 @@
+/* silly pointless RCSID $Id$ */
+static const char freeswan_version[] = "1.8";
diff -druN linux-noipsec/net/ipsec/zlib/Makefile linux/net/ipsec/zlib/Makefile
--- linux-noipsec/net/ipsec/zlib/Makefile	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/Makefile	Fri Sep 29 20:51:33 2000
@@ -0,0 +1,74 @@
+# Makefile for IPCOMP zlib deflate code
+# Copyright (C) 1998, 1999, 2000  Richard Guy Briggs.
+# Copyright (C) 2000  Svenning Soerensen
+# 
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2 of the License, or (at your
+# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
+# 
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# RCSID $Id$
+#
+
+ifndef TOPDIR
+TOPDIR  := /usr/src/linux
+endif
+
+
+L_TARGET := zlib.a
+L_OBJS := adler32.o deflate.o infblock.o infcodes.o inffast.o inflate.o inftrees.o infutil.o trees.o zutil.o
+
+
+ifeq ($(CONFIG_IPSEC_DEBUG),y)
+override CFLAGS += -g
+endif
+
+override CFLAGS += -Wall 
+#override CFLAGS += -Wconversion 
+#override CFLAGS += -Wmissing-prototypes 
+override CFLAGS += -Wpointer-arith 
+#override CFLAGS += -Wcast-qual 
+#override CFLAGS += -Wmissing-declarations 
+override CFLAGS += -Wstrict-prototypes
+#override CFLAGS += -pedantic
+#override CFLAGS += -O3
+#override CFLAGS += -W
+#override CFLAGS += -Wwrite-strings 
+override CFLAGS += -Wbad-function-cast 
+override CFLAGS += -DIPCOMP_PREFIX
+
+.S.o:
+	$(CC) -D__ASSEMBLY__ -DNO_UNDERLINE -traditional -c $< -o $*.o
+
+ifdef CONFIG_M586
+  L_OBJS += match586.o
+  override CFLAGS += -DASMV
+endif
+ifdef CONFIG_M586TSC
+  L_OBJS += match586.o
+  override CFLAGS += -DASMV
+endif
+ifdef CONFIG_M686
+  L_OBJS += match686.o
+  override CFLAGS += -DASMV
+endif
+
+
+include $(TOPDIR)/Rules.make
+
+$(L_OBJS):  $(TOPDIR)/include/linux/config.h $(TOPDIR)/include/linux/autoconf.h
+
+clean:
+	-rm -f *.o *.a
+
+#
+# $Log$
+# Revision 1.1.1.1  2000/09/29 18:51:33  rgb
+# zlib_beginnings
+#
+#
diff -druN linux-noipsec/net/ipsec/zlib/adler32.c linux/net/ipsec/zlib/adler32.c
--- linux-noipsec/net/ipsec/zlib/adler32.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/adler32.c	Fri Sep 29 20:51:33 2000
@@ -0,0 +1,48 @@
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id$ */
+
+#include "zlib.h"
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* ========================================================================= */
+uLong ZEXPORT adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+        k = len < NMAX ? len : NMAX;
+        len -= k;
+        while (k >= 16) {
+            DO16(buf);
+	    buf += 16;
+            k -= 16;
+        }
+        if (k != 0) do {
+            s1 += *buf++;
+	    s2 += s1;
+        } while (--k);
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
diff -druN linux-noipsec/net/ipsec/zlib/deflate.c linux/net/ipsec/zlib/deflate.c
--- linux-noipsec/net/ipsec/zlib/deflate.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/deflate.c	Fri Sep 29 20:51:33 2000
@@ -0,0 +1,1351 @@
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-1998 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin & Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
+ *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* @(#) $Id$ */
+
+#include "deflate.h"
+
+local const char deflate_copyright[] =
+   " deflate 1.1.3 Copyright 1995-1998 Jean-loup Gailly ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+
+#ifdef DEBUG
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+local const config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
+
+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * If this file is compiled with -DFASTEST, the compression level is forced
+ * to 1, and no hash chains are maintained.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#ifdef FASTEST
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#else
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#endif
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s->head[s->hash_size-1] = NIL; \
+    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+
+/* ========================================================================= */
+int ZEXPORT deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+			 Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm->next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+		  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int noheader = 0;
+    static const char* my_version = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is <= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+	return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+    if (strm->zalloc == Z_NULL) {
+      return Z_STREAM_ERROR;
+/*	strm->zalloc = zcalloc;
+	strm->opaque = (voidpf)0;*/
+    }
+    if (strm->zfree == Z_NULL) return Z_STREAM_ERROR; /* strm->zfree = zcfree; */
+
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#ifdef FASTEST
+    level = 1;
+#endif
+
+    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
+        noheader = 1;
+        windowBits = -windowBits;
+    }
+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
+	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm->state = (struct internal_state FAR *)s;
+    s->strm = strm;
+
+    s->noheader = noheader;
+    s->w_bits = windowBits;
+    s->w_size = 1 << s->w_bits;
+    s->w_mask = s->w_size - 1;
+
+    s->hash_bits = memLevel + 7;
+    s->hash_size = 1 << s->hash_bits;
+    s->hash_mask = s->hash_size - 1;
+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+
+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+    s->pending_buf = (uchf *) overlay;
+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+
+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
+        s->pending_buf == Z_NULL) {
+        strm->msg = ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+
+    s->level = level;
+    s->strategy = strategy;
+    s->method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
+        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
+
+    s = strm->state;
+    strm->adler = adler32(strm->adler, dictionary, dictLength);
+
+    if (length < MIN_MATCH) return Z_OK;
+    if (length > MAX_DIST(s)) {
+	length = MAX_DIST(s);
+#ifndef USE_DICT_HEAD
+	dictionary += dictLength - length; /* use the tail of the dictionary */
+#endif
+    }
+    zmemcpy(s->window, dictionary, length);
+    s->strstart = length;
+    s->block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s->lookahead stays null, so s->ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s->ins_h = s->window[0];
+    UPDATE_HASH(s, s->ins_h, s->window[1]);
+    for (n = 0; n <= length - MIN_MATCH; n++) {
+	INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+    
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->pending = 0;
+    s->pending_out = s->pending_buf;
+
+    if (s->noheader < 0) {
+        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
+    }
+    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
+    strm->adler = 1;
+    s->last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm->state;
+
+    if (level == Z_DEFAULT_COMPRESSION) {
+	level = 6;
+    }
+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+	return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s->level].func;
+
+    if (func != configuration_table[level].func && strm->total_in != 0) {
+	/* Flush the last buffer: */
+	err = deflate(strm, Z_PARTIAL_FLUSH);
+    }
+    if (s->level != level) {
+	s->level = level;
+	s->max_lazy_match   = configuration_table[level].max_lazy;
+	s->good_match       = configuration_table[level].good_length;
+	s->nice_match       = configuration_table[level].nice_length;
+	s->max_chain_length = configuration_table[level].max_chain;
+    }
+    s->strategy = strategy;
+    return err;
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b >> 8));
+    put_byte(s, (Byte)(b & 0xff));
+}   
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    unsigned len = strm->state->pending;
+
+    if (len > strm->avail_out) len = strm->avail_out;
+    if (len == 0) return;
+
+    zmemcpy(strm->next_out, strm->state->pending_out, len);
+    strm->next_out  += len;
+    strm->state->pending_out  += len;
+    strm->total_out += len;
+    strm->avail_out  -= len;
+    strm->state->pending -= len;
+    if (strm->state->pending == 0) {
+        strm->state->pending_out = strm->state->pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int ZEXPORT deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+	flush > Z_FINISH || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = strm->state;
+
+    if (strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
+	(s->status == FINISH_STATE && flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s->strm = strm; /* just in case */
+    old_flush = s->last_flush;
+    s->last_flush = flush;
+
+    /* Write the zlib header */
+    if (s->status == INIT_STATE) {
+
+        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+        uInt level_flags = (s->level-1) >> 1;
+
+        if (level_flags > 3) level_flags = 3;
+        header |= (level_flags << 6);
+	if (s->strstart != 0) header |= PRESET_DICT;
+        header += 31 - (header % 31);
+
+        s->status = BUSY_STATE;
+        putShortMSB(s, header);
+
+	/* Save the adler32 of the preset dictionary: */
+	if (s->strstart != 0) {
+	    putShortMSB(s, (uInt)(strm->adler >> 16));
+	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+	}
+	strm->adler = 1L;
+    }
+
+    /* Flush as much pending output as possible */
+    if (s->pending != 0) {
+        flush_pending(strm);
+        if (strm->avail_out == 0) {
+	    /* Since avail_out is 0, deflate will be called again with
+	     * more output space, but possibly with both pending and
+	     * avail_in equal to zero. There won't be anything to do,
+	     * but this is not an error situation so make sure we
+	     * return OK instead of BUF_ERROR at next call of deflate:
+             */
+	    s->last_flush = -1;
+	    return Z_OK;
+	}
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
+     */
+    } else if (strm->avail_in == 0 && flush <= old_flush &&
+	       flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s->status == FINISH_STATE && strm->avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm->avail_in != 0 || s->lookahead != 0 ||
+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
+        block_state bstate;
+
+	bstate = (*(configuration_table[s->level].func))(s, flush);
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s->status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+	    if (strm->avail_out == 0) {
+	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
+	    }
+	    return Z_OK;
+	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+	     * of deflate should use the same flush parameter to make sure
+	     * that the flush is complete. So we don't have to output an
+	     * empty block here, this will be done at next call. This also
+	     * ensures that for a very small output buffer, we emit at most
+	     * one empty block.
+	     */
+	}
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+            } else { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                }
+            }
+            flush_pending(strm);
+	    if (strm->avail_out == 0) {
+	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+	      return Z_OK;
+	    }
+        }
+    }
+    Assert(strm->avail_out > 0, "bug2");
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s->noheader) return Z_STREAM_END;
+
+    /* Write the zlib trailer (adler32) */
+    putShortMSB(s, (uInt)(strm->adler >> 16));
+    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    s->noheader = -1; /* write the trailer only once! */
+    return s->pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+
+    status = strm->state->status;
+    if (status != INIT_STATE && status != BUSY_STATE &&
+	status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, strm->state->pending_buf);
+    TRY_FREE(strm, strm->state->head);
+    TRY_FREE(strm, strm->state->prev);
+    TRY_FREE(strm, strm->state->window);
+
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ * To simplify the source, this is not supported for 16-bit MSDOS (which
+ * doesn't have enough memory anyway to duplicate compression states).
+ */
+int ZEXPORT deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+#ifdef MAXSEG_64K
+    return Z_STREAM_ERROR;
+#else
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
+        return Z_STREAM_ERROR;
+    }
+
+    ss = source->state;
+
+    *dest = *source;
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest->state = (struct internal_state FAR *) ds;
+    *ds = *ss;
+    ds->strm = dest;
+
+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+    ds->pending_buf = (uchf *) overlay;
+
+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
+        ds->pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* following zmemcpy do not work for 16-bit MSDOS */
+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+
+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+
+    ds->l_desc.dyn_tree = ds->dyn_ltree;
+    ds->d_desc.dyn_tree = ds->dyn_dtree;
+    ds->bl_desc.dyn_tree = ds->bl_tree;
+
+    return Z_OK;
+#endif
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    Bytef *buf;
+    unsigned size;
+{
+    unsigned len = strm->avail_in;
+
+    if (len > size) len = size;
+    if (len == 0) return 0;
+
+    strm->avail_in  -= len;
+
+    if (!strm->state->noheader) {
+        strm->adler = adler32(strm->adler, strm->next_in, len);
+    }
+    zmemcpy(buf, strm->next_in, len);
+    strm->next_in  += len;
+    strm->total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s->window_size = (ulg)2L*s->w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s->max_lazy_match   = configuration_table[s->level].max_lazy;
+    s->good_match       = configuration_table[s->level].good_length;
+    s->nice_match       = configuration_table[s->level].nice_length;
+    s->max_chain_length = configuration_table[s->level].max_chain;
+
+    s->strstart = 0;
+    s->block_start = 0L;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    s->ins_h = 0;
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+}
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+#ifndef FASTEST
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s->prev_length;              /* best match length so far */
+    int nice_match = s->nice_match;             /* stop if match long enough */
+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
+        s->strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes <= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s->prev;
+    uInt wmask = s->w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s->prev_length >= s->good_match) {
+        chain_length >>= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    do {
+        Assert(cur_match < s->strstart, "no future");
+        match = s->window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2:
+         */
+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], "scan[2]?");
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 scan < strend);
+        /* The funny "do {}" generates better code on most compilers */
+
+        /* Here, scan <= window+strstart+257 */
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS >= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, "match[2]?");
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 scan < strend);
+
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len > best_len) {
+            s->match_start = cur_match;
+            best_len = len;
+            if (len >= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match & wmask]) > limit
+             && --chain_length != 0);
+
+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
+    return s->lookahead;
+}
+
+#else /* FASTEST */
+/* ---------------------------------------------------------------------------
+ * Optimized version for level == 1 only
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    Assert(cur_match < s->strstart, "no future");
+
+    match = s->window + cur_match;
+
+    /* Return failure if the match length is less than 2:
+     */
+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS >= 8.
+     */
+    scan += 2, match += 2;
+    Assert(*scan == *match, "match[2]?");
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+    } while (*++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     scan < strend);
+
+    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+    len = MAX_MATCH - (int)(strend - scan);
+
+    if (len < MIN_MATCH) return MIN_MATCH - 1;
+
+    s->match_start = cur_match;
+    return len <= s->lookahead ? len : s->lookahead;
+}
+#endif /* FASTEST */
+#endif /* ASMV */
+
+#ifdef DEBUG
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp(s->window + match,
+                s->window + start, length) != EQUAL) {
+        fprintf(stderr, " start %u, match %u, length %d\n",
+		start, match, length);
+        do {
+	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+	} while (--length != 0);
+        z_error("invalid match");
+    }
+    if (z_verbose > 1) {
+        fprintf(stderr,"\\[%d,%d]", start-match, length);
+        do { putc(s->window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s->w_size;
+
+    do {
+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+            more = wsize;
+
+        } else if (more == (unsigned)(-1)) {
+            /* Very unlikely, but possible on 16 bit machine if strstart == 0
+             * and lookahead == 1 (input done one byte at time)
+             */
+            more--;
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        } else if (s->strstart >= wsize+MAX_DIST(s)) {
+
+            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
+            s->match_start -= wsize;
+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            s->block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level > 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+	    n = s->hash_size;
+	    p = &s->head[n];
+	    do {
+		m = *--p;
+		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+	    } while (--n);
+
+	    n = wsize;
+#ifndef FASTEST
+	    p = &s->prev[n];
+	    do {
+		m = *--p;
+		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+		/* If n is not on any hash chain, prev[n] is garbage but
+		 * its value will never be used.
+		 */
+	    } while (--n);
+#endif
+            more += wsize;
+        }
+        if (s->strm->avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+         *    more == window_size - lookahead - strstart
+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * => more >= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &&
+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more >= 2.
+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+         */
+        Assert(more >= 2, "more < 2");
+
+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
+        s->lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s->lookahead >= MIN_MATCH) {
+            s->ins_h = s->window[s->strstart];
+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, eof) { \
+   _tr_flush_block(s, (s->block_start >= 0L ? \
+                   (charf *)&s->window[(unsigned)s->block_start] : \
+                   (charf *)Z_NULL), \
+		(ulg)((long)s->strstart - s->block_start), \
+		(eof)); \
+   s->block_start = s->strstart; \
+   flush_pending(s->strm); \
+   Tracev((stderr,"[FLUSH]")); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, eof) { \
+   FLUSH_BLOCK_ONLY(s, eof); \
+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size > s->pending_buf_size - 5) {
+        max_block_size = s->pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s->lookahead <= 1) {
+
+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+		   s->block_start >= (long)s->w_size, "slide too late");
+
+            fill_window(s);
+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+	Assert(s->block_start >= 0L, "block gone");
+
+	s->strstart += s->lookahead;
+	s->lookahead = 0;
+
+	/* Emit a stored block if pending_buf will be full: */
+ 	max_start = s->block_start + max_block_size;
+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+	    /* strstart == 0 is possible when wraparound on 16-bit machine */
+	    s->lookahead = (uInt)(s->strstart - max_start);
+	    s->strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+	}
+	/* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+	}
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL; /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         * At this point we have always match_length < MIN_MATCH
+         */
+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+        }
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->match_start, s->match_length);
+
+            _tr_tally_dist(s, s->strstart - s->match_start,
+                           s->match_length - MIN_MATCH, bflush);
+
+            s->lookahead -= s->match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+#ifndef FASTEST
+            if (s->match_length <= s->max_insert_length &&
+                s->lookahead >= MIN_MATCH) {
+                s->match_length--; /* string at strstart already in hash table */
+                do {
+                    s->strstart++;
+                    INSERT_STRING(s, s->strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s->match_length != 0);
+                s->strstart++; 
+            } else
+#endif
+	    {
+                s->strstart += s->match_length;
+                s->match_length = 0;
+                s->ins_h = s->window[s->strstart];
+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            _tr_tally_lit (s, s->window[s->strstart], bflush);
+            s->lookahead--;
+            s->strstart++; 
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL;    /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         */
+        s->prev_length = s->match_length, s->prev_match = s->match_start;
+        s->match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
+            s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+
+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
+                 (s->match_length == MIN_MATCH &&
+                  s->strstart - s->match_start > TOO_FAR))) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s->match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+
+            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
+			   s->prev_length - MIN_MATCH, bflush);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s->lookahead -= s->prev_length-1;
+            s->prev_length -= 2;
+            do {
+                if (++s->strstart <= max_insert) {
+                    INSERT_STRING(s, s->strstart, hash_head);
+                }
+            } while (--s->prev_length != 0);
+            s->match_available = 0;
+            s->match_length = MIN_MATCH-1;
+            s->strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s->match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,"%c", s->window[s->strstart-1]));
+	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+	    if (bflush) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s->strstart++;
+            s->lookahead--;
+            if (s->strm->avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s->match_available = 1;
+            s->strstart++;
+            s->lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, "no flush?");
+    if (s->match_available) {
+        Tracevv((stderr,"%c", s->window[s->strstart-1]));
+        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+        s->match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
diff -druN linux-noipsec/net/ipsec/zlib/deflate.h linux/net/ipsec/zlib/deflate.h
--- linux-noipsec/net/ipsec/zlib/deflate.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/deflate.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,318 @@
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-1998 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef _DEFLATE_H
+#define _DEFLATE_H
+
+#include "zutil.h"
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct internal_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    int   pending;       /* nb of bytes in the pending buffer */
+    int   noheader;      /* suppress zlib header and adler32 */
+    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH >= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels >= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels <= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG
+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+        /* in trees.c */
+void _tr_init         OF((deflate_state *s));
+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
+void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+			  int eof));
+void _tr_align        OF((deflate_state *s));
+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+
+#define d_code(dist) \
+   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. _dist_code[256] and _dist_code[257] are never
+ * used.
+ */
+
+#ifndef DEBUG
+/* Inline versions of _tr_tally for speed: */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+  extern uch _length_code[];
+  extern uch _dist_code[];
+#else
+  extern const uch _length_code[];
+  extern const uch _dist_code[];
+#endif
+
+# define _tr_tally_lit(s, c, flush) \
+  { uch cc = (c); \
+    s->d_buf[s->last_lit] = 0; \
+    s->l_buf[s->last_lit++] = cc; \
+    s->dyn_ltree[cc].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+   }
+# define _tr_tally_dist(s, distance, length, flush) \
+  { uch len = (length); \
+    ush dist = (distance); \
+    s->d_buf[s->last_lit] = dist; \
+    s->l_buf[s->last_lit++] = len; \
+    dist--; \
+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
+    s->dyn_dtree[d_code(dist)].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+  }
+#else
+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
+# define _tr_tally_dist(s, distance, length, flush) \
+              flush = _tr_tally(s, distance, length) 
+#endif
+
+#endif /* _DEFLATE_H */
diff -druN linux-noipsec/net/ipsec/zlib/infblock.c linux/net/ipsec/zlib/infblock.c
--- linux-noipsec/net/ipsec/zlib/infblock.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infblock.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,398 @@
+/* infblock.c -- interpret and process block types to last block
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+#include "inftrees.h"
+#include "infcodes.h"
+#include "infutil.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* Table for deflate from PKZIP's appnote.txt. */
+local const uInt border[] = { /* Order of the bit length code lengths */
+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+/*
+   Notes beyond the 1.93a appnote.txt:
+
+   1. Distance pointers never point before the beginning of the output
+      stream.
+   2. Distance pointers can point back across blocks, up to 32k away.
+   3. There is an implied maximum of 7 bits for the bit length table and
+      15 bits for the actual data.
+   4. If only one code exists, then it is encoded using one bit.  (Zero
+      would be more efficient, but perhaps a little confusing.)  If two
+      codes exist, they are coded using one bit each (0 and 1).
+   5. There is no way of sending zero distance codes--a dummy must be
+      sent if there are none.  (History: a pre 2.0 version of PKZIP would
+      store blocks with no distance codes, but this was discovered to be
+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+      zero distance codes, which is sent as one code of zero bits in
+      length.
+   6. There are up to 286 literal/length codes.  Code 256 represents the
+      end-of-block.  Note however that the static length tree defines
+      288 codes just to fill out the Huffman codes.  Codes 286 and 287
+      cannot be used though, since there is no length base or extra bits
+      defined for them.  Similarily, there are up to 30 distance codes.
+      However, static trees define 32 codes (all 5 bits) to fill out the
+      Huffman codes, but the last two had better not show up in the data.
+   7. Unzip can check dynamic Huffman blocks for complete code sets.
+      The exception is that a single code would not be complete (see #4).
+   8. The five bits following the block type is really the number of
+      literal codes sent minus 257.
+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+      (1+6+6).  Therefore, to output three times the length, you output
+      three codes (1+1+1), whereas to output four times the same length,
+      you only need two codes (1+3).  Hmm.
+  10. In the tree reconstruction algorithm, Code = Code + Increment
+      only if BitLength(i) is not zero.  (Pretty obvious.)
+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+  12. Note: length code 284 can represent 227-258, but length code 285
+      really is 258.  The last length deserves its own, short code
+      since it gets used a lot in very redundant files.  The length
+      258 is special since 258 - 3 (the min match length) is 255.
+  13. The literal/length and distance code bit lengths are read as a
+      single stream of lengths.  It is possible (and advantageous) for
+      a repeat code (16, 17, or 18) to go across the boundary between
+      the two sets of lengths.
+ */
+
+
+void inflate_blocks_reset(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  if (c != Z_NULL)
+    *c = s->check;
+  if (s->mode == BTREE || s->mode == DTREE)
+    ZFREE(z, s->sub.trees.blens);
+  if (s->mode == CODES)
+    inflate_codes_free(s->sub.decode.codes, z);
+  s->mode = TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
+  Tracev((stderr, "inflate:   blocks reset\n"));
+}
+
+
+inflate_blocks_statef *inflate_blocks_new(z, c, w)
+z_streamp z;
+check_func c;
+uInt w;
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->hufts =
+       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
+  {
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s->hufts);
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = TYPE;
+  Tracev((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, Z_NULL);
+  return s;
+}
+
+
+int inflate_blocks(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt t;               /* temporary storage */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input based on current state */
+  while (1) switch (s->mode)
+  {
+    case TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+        case 0:                         /* stored */
+          Tracev((stderr, "inflate:     stored block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          t = k & 7;                    /* go to byte boundary */
+          DUMPBITS(t)
+          s->mode = LENS;               /* get length of stored block */
+          break;
+        case 1:                         /* fixed */
+          Tracev((stderr, "inflate:     fixed codes block%s\n",
+                 s->last ? " (last)" : ""));
+          {
+            uInt bl, bd;
+            inflate_huft *tl, *td;
+
+            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+            if (s->sub.decode.codes == Z_NULL)
+            {
+              r = Z_MEM_ERROR;
+              LEAVE
+            }
+          }
+          DUMPBITS(3)
+          s->mode = CODES;
+          break;
+        case 2:                         /* dynamic */
+          Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          s->mode = TABLE;
+          break;
+        case 3:                         /* illegal */
+          DUMPBITS(3)
+          s->mode = BAD;
+          z->msg = (char*)"invalid block type";
+          r = Z_DATA_ERROR;
+          LEAVE
+      }
+      break;
+    case LENS:
+      NEEDBITS(32)
+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
+      {
+        s->mode = BAD;
+        z->msg = (char*)"invalid stored block lengths";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      /* dump bits */
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
+      break;
+    case STORED:
+      if (n == 0)
+        LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      zmemcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+        break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? DRY : TYPE;
+      break;
+    case TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+#ifndef PKZIP_BUG_WORKAROUND
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+        s->mode = BAD;
+        z->msg = (char*)"too many length or distance symbols";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+#endif
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+        r = Z_MEM_ERROR;
+        LEAVE
+      }
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = BTREE;
+    case BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+        NEEDBITS(3)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+        DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+                             &s->sub.trees.tb, s->hufts, z);
+      if (t != Z_OK)
+      {
+        ZFREE(z, s->sub.trees.blens);
+        r = t;
+        if (r == Z_DATA_ERROR)
+          s->mode = BAD;
+        LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = DTREE;
+    case DTREE:
+      while (t = s->sub.trees.table,
+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+        inflate_huft *h;
+        uInt i, j, c;
+
+        t = s->sub.trees.bb;
+        NEEDBITS(t)
+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+        t = h->bits;
+        c = h->base;
+        if (c < 16)
+        {
+          DUMPBITS(t)
+          s->sub.trees.blens[s->sub.trees.index++] = c;
+        }
+        else /* c == 16..18 */
+        {
+          i = c == 18 ? 7 : c - 14;
+          j = c == 18 ? 11 : 3;
+          NEEDBITS(t + i)
+          DUMPBITS(t)
+          j += (uInt)b & inflate_mask[i];
+          DUMPBITS(i)
+          i = s->sub.trees.index;
+          t = s->sub.trees.table;
+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+              (c == 16 && i < 1))
+          {
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = BAD;
+            z->msg = (char*)"invalid bit length repeat";
+            r = Z_DATA_ERROR;
+            LEAVE
+          }
+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+          do {
+            s->sub.trees.blens[i++] = c;
+          } while (--j);
+          s->sub.trees.index = i;
+        }
+      }
+      s->sub.trees.tb = Z_NULL;
+      {
+        uInt bl, bd;
+        inflate_huft *tl, *td;
+        inflate_codes_statef *c;
+
+        bl = 9;         /* must be <= 9 for lookahead assumptions */
+        bd = 6;         /* must be <= 9 for lookahead assumptions */
+        t = s->sub.trees.table;
+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
+                                  s->hufts, z);
+        ZFREE(z, s->sub.trees.blens);
+        if (t != Z_OK)
+        {
+          if (t == (uInt)Z_DATA_ERROR)
+            s->mode = BAD;
+          r = t;
+          LEAVE
+        }
+        Tracev((stderr, "inflate:       trees ok\n"));
+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+        {
+          r = Z_MEM_ERROR;
+          LEAVE
+        }
+        s->sub.decode.codes = c;
+      }
+      s->mode = CODES;
+    case CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+        return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+        s->mode = TYPE;
+        break;
+      }
+      s->mode = DRY;
+    case DRY:
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      s->mode = DONE;
+    case DONE:
+      r = Z_STREAM_END;
+      LEAVE
+    case BAD:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+int inflate_blocks_free(s, z)
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_blocks_reset(s, z, Z_NULL);
+  ZFREE(z, s->window);
+  ZFREE(z, s->hufts);
+  ZFREE(z, s);
+  Tracev((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+
+void inflate_set_dictionary(s, d, n)
+inflate_blocks_statef *s;
+const Bytef *d;
+uInt  n;
+{
+  zmemcpy(s->window, d, n);
+  s->read = s->write = s->window + n;
+}
+
+
+/* Returns true if inflate is currently at the end of a block generated
+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
+ * IN assertion: s != Z_NULL
+ */
+int inflate_blocks_sync_point(s)
+inflate_blocks_statef *s;
+{
+  return s->mode == LENS;
+}
diff -druN linux-noipsec/net/ipsec/zlib/infblock.h linux/net/ipsec/zlib/infblock.h
--- linux-noipsec/net/ipsec/zlib/infblock.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infblock.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,39 @@
+/* infblock.h -- header to use infblock.c
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state FAR inflate_blocks_statef;
+
+extern inflate_blocks_statef * inflate_blocks_new OF((
+    z_streamp z,
+    check_func c,               /* check function */
+    uInt w));                   /* window size */
+
+extern int inflate_blocks OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));                      /* initial return code */
+
+extern void inflate_blocks_reset OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern int inflate_blocks_free OF((
+    inflate_blocks_statef *,
+    z_streamp));
+
+extern void inflate_set_dictionary OF((
+    inflate_blocks_statef *s,
+    const Bytef *d,  /* dictionary */
+    uInt  n));       /* dictionary length */
+
+extern int inflate_blocks_sync_point OF((
+    inflate_blocks_statef *s));
diff -druN linux-noipsec/net/ipsec/zlib/infcodes.c linux/net/ipsec/zlib/infcodes.c
--- linux-noipsec/net/ipsec/zlib/infcodes.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infcodes.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,257 @@
+/* infcodes.c -- process literals and length/distance pairs
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "infblock.h"
+#include "infcodes.h"
+#include "infutil.h"
+#include "inffast.h"
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+      START,    /* x: set up for LEN */
+      LEN,      /* i: get length/literal/eob next */
+      LENEXT,   /* i: getting length extra (have base) */
+      DIST,     /* i: get distance next */
+      DISTEXT,  /* i: getting distance extra */
+      COPY,     /* o: copying bytes in window, waiting for space */
+      LIT,      /* o: got literal, waiting for output space */
+      WASH,     /* o: got eob, possibly still output waiting */
+      END,      /* x: got eob and all data flushed */
+      BADCODE}  /* x: got error */
+inflate_codes_mode;
+
+/* inflate codes private state */
+struct inflate_codes_state {
+
+  /* mode */
+  inflate_codes_mode mode;      /* current inflate_codes mode */
+
+  /* mode dependent information */
+  uInt len;
+  union {
+    struct {
+      inflate_huft *tree;       /* pointer into tree */
+      uInt need;                /* bits needed */
+    } code;             /* if LEN or DIST, where in tree */
+    uInt lit;           /* if LIT, literal */
+    struct {
+      uInt get;                 /* bits to get for extra */
+      uInt dist;                /* distance back to copy from */
+    } copy;             /* if EXT or COPY, where and how much */
+  } sub;                /* submode */
+
+  /* mode independent information */
+  Byte lbits;           /* ltree bits decoded per branch */
+  Byte dbits;           /* dtree bits decoder per branch */
+  inflate_huft *ltree;          /* literal/length/eob tree */
+  inflate_huft *dtree;          /* distance tree */
+
+};
+
+
+inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+z_streamp z;
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+int inflate_codes(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt j;               /* temporary storage */
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  Bytef *f;             /* pointer to copy strings from */
+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input and output based on current state */
+  while (1) switch (c->mode)
+  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+    case START:         /* x: set up for LEN */
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+        UPDATE
+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+        LOAD
+        if (r != Z_OK)
+        {
+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+          break;
+        }
+      }
+#endif /* !SLOW */
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           /* i: get length/literal/eob next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               /* literal */
+      {
+        c->sub.lit = t->base;
+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                 "inflate:         literal '%c'\n" :
+                 "inflate:         literal 0x%02x\n", t->base));
+        c->mode = LIT;
+        break;
+      }
+      if (e & 16)               /* length */
+      {
+        c->sub.copy.get = e & 15;
+        c->len = t->base;
+        c->mode = LENEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      if (e & 32)               /* end of block */
+      {
+        Tracevv((stderr, "inflate:         end of block\n"));
+        c->mode = WASH;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        /* i: getting length extra (have base) */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          /* i: get distance next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               /* distance */
+      {
+        c->sub.copy.get = e & 15;
+        c->sub.copy.dist = t->base;
+        c->mode = DISTEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       /* i: getting distance extra */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          /* o: copying bytes in window, waiting for space */
+#ifndef __TURBOC__ /* Turbo C bug for following expression */
+      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+          s->end - (c->sub.copy.dist - (q - s->window)) :
+          q - c->sub.copy.dist;
+#else
+      f = q - c->sub.copy.dist;
+      if ((uInt)(q - s->window) < c->sub.copy.dist)
+        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
+#endif
+      while (c->len)
+      {
+        NEEDOUT
+        OUTBYTE(*f++)
+        if (f == s->end)
+          f = s->window;
+        c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           /* o: got literal, waiting for output space */
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          /* o: got eob, possibly more output */
+      if (k > 7)        /* return unused byte, if any */
+      {
+        Assert(k < 16, "inflate_codes grabbed too many bytes")
+        k -= 8;
+        n++;
+        p--;            /* can always return one */
+      }
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       /* x: got error */
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+#ifdef NEED_DUMMY_RETURN
+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
+#endif
+}
+
+
+void inflate_codes_free(c, z)
+inflate_codes_statef *c;
+z_streamp z;
+{
+  ZFREE(z, c);
+  Tracev((stderr, "inflate:       codes free\n"));
+}
diff -druN linux-noipsec/net/ipsec/zlib/infcodes.h linux/net/ipsec/zlib/infcodes.h
--- linux-noipsec/net/ipsec/zlib/infcodes.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infcodes.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,31 @@
+/* infcodes.h -- header to use infcodes.c
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFCODES_H
+#define _INFCODES_H
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state FAR inflate_codes_statef;
+
+extern inflate_codes_statef *inflate_codes_new OF((
+    uInt, uInt,
+    inflate_huft *, inflate_huft *,
+    z_streamp ));
+
+extern int inflate_codes OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+extern void inflate_codes_free OF((
+    inflate_codes_statef *,
+    z_streamp ));
+
+#endif /* _INFCODES_H */
diff -druN linux-noipsec/net/ipsec/zlib/inffast.c linux/net/ipsec/zlib/inffast.c
--- linux-noipsec/net/ipsec/zlib/inffast.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inffast.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,170 @@
+/* inffast.c -- process literals and length/distance pairs fast
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "infblock.h"
+#include "infcodes.h"
+#include "infutil.h"
+#include "inffast.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* macros for bit input with no checking and for returning unused bytes */
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}
+
+/* Called with number of bytes left to write in window at least 258
+   (the maximum string length) and number of input bytes available
+   at least ten.  The ten bytes are six bytes for the longest length/
+   distance pair plus four bytes for overloading the bit buffer. */
+
+int inflate_fast(bl, bd, tl, td, s, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  uInt ml;              /* mask for literal/length tree */
+  uInt md;              /* mask for distance tree */
+  uInt c;               /* bytes to copy */
+  uInt d;               /* distance back to copy from */
+  Bytef *r;             /* copy source pointer */
+
+  /* load input, output, bit values */
+  LOAD
+
+  /* initialize masks */
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  /* do until not enough input or output space for fast loop */
+  do {                          /* assume called with m >= 258 && n >= 10 */
+    /* get literal/length code */
+    GRABBITS(20)                /* max bits for literal/length code */
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                "inflate:         * literal '%c'\n" :
+                "inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    do {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+        /* get extra bits for length */
+        e &= 15;
+        c = t->base + ((uInt)b & inflate_mask[e]);
+        DUMPBITS(e)
+        Tracevv((stderr, "inflate:         * length %u\n", c));
+
+        /* decode distance base of block to copy */
+        GRABBITS(15);           /* max bits for distance code */
+        e = (t = td + ((uInt)b & md))->exop;
+        do {
+          DUMPBITS(t->bits)
+          if (e & 16)
+          {
+            /* get extra bits to add to distance base */
+            e &= 15;
+            GRABBITS(e)         /* get extra bits (up to 13) */
+            d = t->base + ((uInt)b & inflate_mask[e]);
+            DUMPBITS(e)
+            Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+            /* do the copy */
+            m -= c;
+            if ((uInt)(q - s->window) >= d)     /* offset before dest */
+            {                                   /*  just copy */
+              r = q - d;
+              *q++ = *r++;  c--;        /* minimum count is three, */
+              *q++ = *r++;  c--;        /*  so unroll loop a little */
+            }
+            else                        /* else offset after destination */
+            {
+              e = d - (uInt)(q - s->window); /* bytes from offset to end */
+              r = s->end - e;           /* pointer to offset */
+              if (c > e)                /* if source crosses, */
+              {
+                c -= e;                 /* copy to end of window */
+                do {
+                  *q++ = *r++;
+                } while (--e);
+                r = s->window;          /* copy rest from start of window */
+              }
+            }
+            do {                        /* copy all or what's left */
+              *q++ = *r++;
+            } while (--c);
+            break;
+          }
+          else if ((e & 64) == 0)
+          {
+            t += t->base;
+            e = (t += ((uInt)b & inflate_mask[e]))->exop;
+          }
+          else
+          {
+            z->msg = (char*)"invalid distance code";
+            UNGRAB
+            UPDATE
+            return Z_DATA_ERROR;
+          }
+        } while (1);
+        break;
+      }
+      if ((e & 64) == 0)
+      {
+        t += t->base;
+        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
+        {
+          DUMPBITS(t->bits)
+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                    "inflate:         * literal '%c'\n" :
+                    "inflate:         * literal 0x%02x\n", t->base));
+          *q++ = (Byte)t->base;
+          m--;
+          break;
+        }
+      }
+      else if (e & 32)
+      {
+        Tracevv((stderr, "inflate:         * end of block\n"));
+        UNGRAB
+        UPDATE
+        return Z_STREAM_END;
+      }
+      else
+      {
+        z->msg = (char*)"invalid literal/length code";
+        UNGRAB
+        UPDATE
+        return Z_DATA_ERROR;
+      }
+    } while (1);
+  } while (m >= 258 && n >= 10);
+
+  /* not enough input or output--restore pointers and return */
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
diff -druN linux-noipsec/net/ipsec/zlib/inffast.h linux/net/ipsec/zlib/inffast.h
--- linux-noipsec/net/ipsec/zlib/inffast.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inffast.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,22 @@
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFFAST_H
+#define _INFFAST_H
+
+extern int inflate_fast OF((
+    uInt,
+    uInt,
+    inflate_huft *,
+    inflate_huft *,
+    inflate_blocks_statef *,
+    z_streamp ));
+
+#endif /* _INFFAST_H */
diff -druN linux-noipsec/net/ipsec/zlib/inffixed.h linux/net/ipsec/zlib/inffixed.h
--- linux-noipsec/net/ipsec/zlib/inffixed.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inffixed.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,151 @@
+/* inffixed.h -- table for decoding fixed codes
+ * Generated automatically by the maketree.c program
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+local uInt fixed_bl = 9;
+local uInt fixed_bd = 5;
+local inflate_huft fixed_tl[] = {
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
+  };
+local inflate_huft fixed_td[] = {
+    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
+    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
+    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
+    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
+    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
+    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
+    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
+    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
+  };
diff -druN linux-noipsec/net/ipsec/zlib/inflate.c linux/net/ipsec/zlib/inflate.c
--- linux-noipsec/net/ipsec/zlib/inflate.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inflate.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,368 @@
+/* inflate.c -- zlib interface to inflate modules
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+
+struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
+
+typedef enum {
+      METHOD,   /* waiting for method byte */
+      FLAG,     /* waiting for flag byte */
+      DICT4,    /* four dictionary check bytes to go */
+      DICT3,    /* three dictionary check bytes to go */
+      DICT2,    /* two dictionary check bytes to go */
+      DICT1,    /* one dictionary check byte to go */
+      DICT0,    /* waiting for inflateSetDictionary */
+      BLOCKS,   /* decompressing blocks */
+      CHECK4,   /* four check bytes to go */
+      CHECK3,   /* three check bytes to go */
+      CHECK2,   /* two check bytes to go */
+      CHECK1,   /* one check byte to go */
+      DONE,     /* finished check, done */
+      BAD}      /* got an error--stay here */
+inflate_mode;
+
+/* inflate private state */
+struct internal_state {
+
+  /* mode */
+  inflate_mode  mode;   /* current inflate mode */
+
+  /* mode dependent information */
+  union {
+    uInt method;        /* if FLAGS, method byte */
+    struct {
+      uLong was;                /* computed check value */
+      uLong need;               /* stream check value */
+    } check;            /* if CHECK, check values to compare */
+    uInt marker;        /* if BAD, inflateSync's marker bytes count */
+  } sub;        /* submode */
+
+  /* mode independent information */
+  int  nowrap;          /* flag for no wrapper */
+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
+  inflate_blocks_statef 
+    *blocks;            /* current inflate_blocks state */
+
+};
+
+
+int ZEXPORT inflateReset(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
+  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
+  Tracev((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateEnd(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z);
+  ZFREE(z, z->state);
+  z->state = Z_NULL;
+  Tracev((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateInit2_(z, w, version, stream_size)
+z_streamp z;
+int w;
+const char *version;
+int stream_size;
+{
+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+      stream_size != sizeof(z_stream))
+      return Z_VERSION_ERROR;
+
+  /* initialize state */
+  if (z == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->msg = Z_NULL;
+  if (z->zalloc == Z_NULL)
+  {
+    return Z_STREAM_ERROR;
+/*    z->zalloc = zcalloc;
+    z->opaque = (voidpf)0;
+*/
+  }
+  if (z->zfree == Z_NULL) return Z_STREAM_ERROR; /* z->zfree = zcfree; */
+  if ((z->state = (struct internal_state FAR *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  /* handle undocumented nowrap option (no zlib header or check) */
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  /* set window size */
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  /* create inflate_blocks state */
+  if ((z->state->blocks =
+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Tracev((stderr, "inflate: allocated\n"));
+
+  /* reset state */
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateInit_(z, version, stream_size)
+z_streamp z;
+const char *version;
+int stream_size;
+{
+  return inflateInit2_(z, DEF_WBITS, version, stream_size);
+}
+
+
+#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int ZEXPORT inflate(z, f)
+z_streamp z;
+int f;
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
+    return Z_STREAM_ERROR;
+  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
+  r = Z_BUF_ERROR;
+  while (1) switch (z->state->mode)
+  {
+    case METHOD:
+      NEEDBYTE
+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"unknown compression method";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"invalid window size";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      z->state->mode = FLAG;
+    case FLAG:
+      NEEDBYTE
+      b = NEXTBYTE;
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect header check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Tracev((stderr, "inflate: zlib header ok\n"));
+      if (!(b & PRESET_DICT))
+      {
+        z->state->mode = BLOCKS;
+        break;
+      }
+      z->state->mode = DICT4;
+    case DICT4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = DICT3;
+    case DICT3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = DICT2;
+    case DICT2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = DICT1;
+    case DICT1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+      z->adler = z->state->sub.check.need;
+      z->state->mode = DICT0;
+      return Z_NEED_DICT;
+    case DICT0:
+      z->state->mode = BAD;
+      z->msg = (char*)"need dictionary";
+      z->state->sub.marker = 0;       /* can try inflateSync */
+      return Z_STREAM_ERROR;
+    case BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (r == Z_DATA_ERROR)
+      {
+        z->state->mode = BAD;
+        z->state->sub.marker = 0;       /* can try inflateSync */
+        break;
+      }
+      if (r == Z_OK)
+        r = f;
+      if (r != Z_STREAM_END)
+        return r;
+      r = f;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+        z->state->mode = DONE;
+        break;
+      }
+      z->state->mode = CHECK4;
+    case CHECK4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = CHECK3;
+    case CHECK3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = CHECK2;
+    case CHECK2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = CHECK1;
+    case CHECK1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect data check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Tracev((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = DONE;
+    case DONE:
+      return Z_STREAM_END;
+    case BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+#ifdef NEED_DUMMY_RETURN
+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
+#endif
+}
+
+
+int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
+z_streamp z;
+const Bytef *dictionary;
+uInt  dictLength;
+{
+  uInt length = dictLength;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
+    return Z_STREAM_ERROR;
+
+  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
+  z->adler = 1L;
+
+  if (length >= ((uInt)1<<z->state->wbits))
+  {
+    length = (1<<z->state->wbits)-1;
+    dictionary += dictLength - length;
+  }
+  inflate_set_dictionary(z->state->blocks, dictionary, length);
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateSync(z)
+z_streamp z;
+{
+  uInt n;       /* number of bytes to look at */
+  Bytef *p;     /* pointer to bytes */
+  uInt m;       /* number of marker bytes found in a row */
+  uLong r, w;   /* temporaries to save total_in and total_out */
+
+  /* set up */
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->mode != BAD)
+  {
+    z->state->mode = BAD;
+    z->state->sub.marker = 0;
+  }
+  if ((n = z->avail_in) == 0)
+    return Z_BUF_ERROR;
+  p = z->next_in;
+  m = z->state->sub.marker;
+
+  /* search */
+  while (n && m < 4)
+  {
+    static const Byte mark[4] = {0, 0, 0xff, 0xff};
+    if (*p == mark[m])
+      m++;
+    else if (*p)
+      m = 0;
+    else
+      m = 4 - m;
+    p++, n--;
+  }
+
+  /* restore */
+  z->total_in += p - z->next_in;
+  z->next_in = p;
+  z->avail_in = n;
+  z->state->sub.marker = m;
+
+  /* return no joy or set up to restart on a new block */
+  if (m != 4)
+    return Z_DATA_ERROR;
+  r = z->total_in;  w = z->total_out;
+  inflateReset(z);
+  z->total_in = r;  z->total_out = w;
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+
+/* Returns true if inflate is currently at the end of a block generated
+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
+ * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
+ * but removes the length bytes of the resulting empty stored block. When
+ * decompressing, PPP checks that at the end of input packet, inflate is
+ * waiting for these length bytes.
+ */
+int ZEXPORT inflateSyncPoint(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
+    return Z_STREAM_ERROR;
+  return inflate_blocks_sync_point(z->state->blocks);
+}
diff -druN linux-noipsec/net/ipsec/zlib/inftrees.c linux/net/ipsec/zlib/inftrees.c
--- linux-noipsec/net/ipsec/zlib/inftrees.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inftrees.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,455 @@
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+
+#if !defined(BUILDFIXED) && !defined(STDC)
+#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
+#endif
+
+local const char inflate_copyright[] =
+   " inflate 1.1.3 Copyright 1995-1998 Mark Adler ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+struct internal_state  {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+
+local int huft_build OF((
+    uIntf *,            /* code lengths in bits */
+    uInt,               /* number of codes */
+    uInt,               /* number of "simple" codes */
+    const uIntf *,      /* list of base values for non-simple codes */
+    const uIntf *,      /* list of extra bits for non-simple codes */
+    inflate_huft * FAR*,/* result: starting table */
+    uIntf *,            /* maximum lookup bits (returns actual) */
+    inflate_huft *,     /* space for trees */
+    uInt *,             /* hufts used in space */
+    uIntf * ));         /* space for values */
+
+/* Tables for deflate from PKZIP's appnote.txt. */
+local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+        /* see note #13 above about 258 */
+local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
+local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577};
+local const uInt cpdext[30] = { /* Extra bits for distance codes */
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+        12, 12, 13, 13};
+
+/*
+   Huffman code decoding is performed using a multi-level table lookup.
+   The fastest way to decode is to simply build a lookup table whose
+   size is determined by the longest code.  However, the time it takes
+   to build this table can also be a factor if the data being decoded
+   is not very long.  The most common codes are necessarily the
+   shortest codes, so those codes dominate the decoding time, and hence
+   the speed.  The idea is you can have a shorter table that decodes the
+   shorter, more probable codes, and then point to subsidiary tables for
+   the longer codes.  The time it costs to decode the longer codes is
+   then traded against the time it takes to make longer tables.
+
+   This results of this trade are in the variables lbits and dbits
+   below.  lbits is the number of bits the first level table for literal/
+   length codes can decode in one step, and dbits is the same thing for
+   the distance codes.  Subsequent tables are also less than or equal to
+   those sizes.  These values may be adjusted either when all of the
+   codes are shorter than that, in which case the longest code length in
+   bits is used, or when the shortest code is *longer* than the requested
+   table size, in which case the length of the shortest code in bits is
+   used.
+
+   There are two different values for the two tables, since they code a
+   different number of possibilities each.  The literal/length table
+   codes 286 possible values, or in a flat code, a little over eight
+   bits.  The distance table codes 30 possible values, or a little less
+   than five bits, flat.  The optimum values for speed end up being
+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+   The optimum values may differ though from machine to machine, and
+   possibly even between compilers.  Your mileage may vary.
+ */
+
+
+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
+#define BMAX 15         /* maximum bit length of any code */
+
+local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
+uInt n;                 /* number of codes (assumed <= 288) */
+uInt s;                 /* number of simple-valued codes (0..s-1) */
+const uIntf *d;         /* list of base values for non-simple codes */
+const uIntf *e;         /* list of extra bits for non-simple codes */
+inflate_huft * FAR *t;  /* result: starting table */
+uIntf *m;               /* maximum lookup bits, returns actual */
+inflate_huft *hp;       /* space for trees */
+uInt *hn;               /* hufts used in space */
+uIntf *v;               /* working area: values in order of bit length */
+/* Given a list of code lengths and a maximum table size, make a set of
+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+   if the given code set is incomplete (the tables are still built in this
+   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
+   lengths), or Z_MEM_ERROR if not enough memory. */
+{
+
+  uInt a;                       /* counter for codes of length k */
+  uInt c[BMAX+1];               /* bit length count table */
+  uInt f;                       /* i repeats in table every f entries */
+  int g;                        /* maximum code length */
+  int h;                        /* table level */
+  register uInt i;              /* counter, current code */
+  register uInt j;              /* counter */
+  register int k;               /* number of bits in current code */
+  int l;                        /* bits per table (returned in m) */
+  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
+  register uIntf *p;            /* pointer into c[], b[], or v[] */
+  inflate_huft *q;              /* points to current table */
+  struct inflate_huft_s r;      /* table entry for structure assignment */
+  inflate_huft *u[BMAX];        /* table stack */
+  register int w;               /* bits before this table == (l * h) */
+  uInt x[BMAX+1];               /* bit offsets, then code stack */
+  uIntf *xp;                    /* pointer into x */
+  int y;                        /* number of dummy codes added */
+  uInt z;                       /* number of entries in current table */
+
+
+  /* Generate counts for each bit length */
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4                            /* clear c[]--assume BMAX+1 is 16 */
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  /* assume all entries <= BMAX */
+  } while (--i);
+  if (c[0] == n)                /* null input--all zero length codes */
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  /* Find minimum and maximum length, bound *m by those */
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        /* minimum code length */
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        /* maximum code length */
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  /* Adjust last length count to fill out codes, if needed */
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  /* Generate starting offsets into the value table for each length */
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 /* note that i == g from above */
+    *xp++ = (j += *p++);
+  }
+
+
+  /* Make a table of values in order of bit lengths */
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+  n = x[g];                     /* set n to length of v */
+
+
+  /* Generate the Huffman codes and for each, make the table entries */
+  x[0] = i = 0;                 /* first Huffman code is zero */
+  p = v;                        /* grab values in bit order */
+  h = -1;                       /* no tables yet--level -1 */
+  w = -l;                       /* bits decoded == (l * h) */
+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
+  q = (inflate_huft *)Z_NULL;   /* ditto */
+  z = 0;                        /* ditto */
+
+  /* go through the bit lengths (k already is bits in shortest code) */
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      /* here i is the Huffman code of length k bits for value *p */
+      /* make tables up to required level */
+      while (k > w + l)
+      {
+        h++;
+        w += l;                 /* previous table always l bits */
+
+        /* compute minimum size table less than or equal to l bits */
+        z = g - w;
+        z = z > (uInt)l ? l : z;        /* table size upper limit */
+        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
+        {                       /* too few codes for k-w bit table */
+          f -= a + 1;           /* deduct codes from patterns left */
+          xp = c + k;
+          if (j < z)
+            while (++j < z)     /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;          /* enough codes to use up j bits */
+              f -= *xp;         /* else deduct codes from patterns */
+            }
+        }
+        z = 1 << j;             /* table entries for j-bit table */
+
+        /* allocate new table */
+        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
+          return Z_MEM_ERROR;   /* not enough memory */
+        u[h] = q = hp + *hn;
+        *hn += z;
+
+        /* connect to last table, if there is one */
+        if (h)
+        {
+          x[h] = i;             /* save pattern for backing up */
+          r.bits = (Byte)l;     /* bits to dump before this table */
+          r.exop = (Byte)j;     /* bits in this table */
+          j = i >> (w - l);
+          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
+          u[h-1][j] = r;        /* connect to last table */
+        }
+        else
+          *t = q;               /* first table is returned result */
+      }
+
+      /* set up table entry in r */
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+        r.exop = 128 + 64;      /* out of values--invalid code */
+      else if (*p < s)
+      {
+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+        r.base = *p++;          /* simple code is just the value */
+      }
+      else
+      {
+        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
+        r.base = d[*p++ - s];
+      }
+
+      /* fill code-like entries with r */
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+        q[j] = r;
+
+      /* backwards increment the k-bit code i */
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+        i ^= j;
+      i ^= j;
+
+      /* backup over finished tables */
+      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
+      while ((i & mask) != x[h])
+      {
+        h--;                    /* don't need to update q */
+        w -= l;
+        mask = (1 << w) - 1;
+      }
+    }
+  }
+
+
+  /* Return Z_BUF_ERROR if we were given an incomplete table */
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+int inflate_trees_bits(c, bb, tb, hp, z)
+uIntf *c;               /* 19 code lengths */
+uIntf *bb;              /* bits tree desired/actual depth */
+inflate_huft * FAR *tb; /* bits tree result */
+inflate_huft *hp;       /* space for trees */
+z_streamp z;            /* for messages */
+{
+  int r;
+  uInt hn = 0;          /* hufts used in space */
+  uIntf *v;             /* work area for huft_build */
+
+  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
+                 tb, bb, hp, &hn, v);
+  if (r == Z_DATA_ERROR)
+    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR || *bb == 0)
+  {
+    z->msg = (char*)"incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  ZFREE(z, v);
+  return r;
+}
+
+
+int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
+uInt nl;                /* number of literal/length codes */
+uInt nd;                /* number of distance codes */
+uIntf *c;               /* that many (total) code lengths */
+uIntf *bl;              /* literal desired/actual bit depth */
+uIntf *bd;              /* distance desired/actual bit depth */
+inflate_huft * FAR *tl; /* literal/length tree result */
+inflate_huft * FAR *td; /* distance tree result */
+inflate_huft *hp;       /* space for trees */
+z_streamp z;            /* for messages */
+{
+  int r;
+  uInt hn = 0;          /* hufts used in space */
+  uIntf *v;             /* work area for huft_build */
+
+  /* allocate work area */
+  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+
+  /* build literal/length tree */
+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
+  if (r != Z_OK || *bl == 0)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed literal/length tree";
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+  }
+
+  /* build distance tree */
+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
+  if (r != Z_OK || (*bd == 0 && nl > 257))
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed distance tree";
+    else if (r == Z_BUF_ERROR) {
+#ifdef PKZIP_BUG_WORKAROUND
+      r = Z_OK;
+    }
+#else
+      z->msg = (char*)"incomplete distance tree";
+      r = Z_DATA_ERROR;
+    }
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"empty distance tree with lengths";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+#endif
+  }
+
+  /* done */
+  ZFREE(z, v);
+  return Z_OK;
+}
+
+
+/* build fixed tables only once--keep them here */
+#ifdef BUILDFIXED
+local int fixed_built = 0;
+#define FIXEDH 544      /* number of hufts used by fixed tables */
+local inflate_huft fixed_mem[FIXEDH];
+local uInt fixed_bl;
+local uInt fixed_bd;
+local inflate_huft *fixed_tl;
+local inflate_huft *fixed_td;
+#else
+#include "inffixed.h"
+#endif
+
+
+int inflate_trees_fixed(bl, bd, tl, td, z)
+uIntf *bl;               /* literal desired/actual bit depth */
+uIntf *bd;               /* distance desired/actual bit depth */
+inflate_huft * FAR *tl;  /* literal/length tree result */
+inflate_huft * FAR *td;  /* distance tree result */
+z_streamp z;             /* for memory allocation */
+{
+#ifdef BUILDFIXED
+  /* build fixed tables if not already */
+  if (!fixed_built)
+  {
+    int k;              /* temporary variable */
+    uInt f = 0;         /* number of hufts used in fixed_mem */
+    uIntf *c;           /* length list for huft_build */
+    uIntf *v;           /* work area for huft_build */
+
+    /* allocate memory */
+    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+      return Z_MEM_ERROR;
+    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+    {
+      ZFREE(z, c);
+      return Z_MEM_ERROR;
+    }
+
+    /* literal table */
+    for (k = 0; k < 144; k++)
+      c[k] = 8;
+    for (; k < 256; k++)
+      c[k] = 9;
+    for (; k < 280; k++)
+      c[k] = 7;
+    for (; k < 288; k++)
+      c[k] = 8;
+    fixed_bl = 9;
+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
+               fixed_mem, &f, v);
+
+    /* distance table */
+    for (k = 0; k < 30; k++)
+      c[k] = 5;
+    fixed_bd = 5;
+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
+               fixed_mem, &f, v);
+
+    /* done */
+    ZFREE(z, v);
+    ZFREE(z, c);
+    fixed_built = 1;
+  }
+#endif
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
diff -druN linux-noipsec/net/ipsec/zlib/inftrees.h linux/net/ipsec/zlib/inftrees.h
--- linux-noipsec/net/ipsec/zlib/inftrees.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/inftrees.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,63 @@
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Huffman code lookup table entry--this entry is four bytes for machines
+   that have 16-bit pointers (e.g. PC's in the small or medium model). */
+
+#ifndef _INFTREES_H
+#define _INFTREES_H
+
+typedef struct inflate_huft_s FAR inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        /* number of extra bits or operation */
+      Byte Bits;        /* number of bits in this code or subcode */
+    } what;
+    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
+  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
+  uInt base;            /* literal, length base, distance base,
+                           or table offset */
+};
+
+/* Maximum size of dynamic tree.  The maximum found in a long but non-
+   exhaustive search was 1004 huft structures (850 for length/literals
+   and 154 for distances, the latter actually the result of an
+   exhaustive search).  The actual maximum is not known, but the
+   value below is more than safe. */
+#define MANY 1440
+
+extern int inflate_trees_bits OF((
+    uIntf *,                    /* 19 code lengths */
+    uIntf *,                    /* bits tree desired/actual depth */
+    inflate_huft * FAR *,       /* bits tree result */
+    inflate_huft *,             /* space for trees */
+    z_streamp));                /* for messages */
+
+extern int inflate_trees_dynamic OF((
+    uInt,                       /* number of literal/length codes */
+    uInt,                       /* number of distance codes */
+    uIntf *,                    /* that many (total) code lengths */
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    inflate_huft *,             /* space for trees */
+    z_streamp));                /* for messages */
+
+extern int inflate_trees_fixed OF((
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    z_streamp));                /* for memory allocation */
+
+#endif /* _INFTREES_H */
diff -druN linux-noipsec/net/ipsec/zlib/infutil.c linux/net/ipsec/zlib/infutil.c
--- linux-noipsec/net/ipsec/zlib/infutil.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infutil.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,87 @@
+/* inflate_util.c -- data and routines common to blocks and codes
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+#include "inftrees.h"
+#include "infcodes.h"
+#include "infutil.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* And'ing with mask[n] masks the lower n bits */
+uInt inflate_mask[17] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+
+/* copy as much as possible from the sliding window to the output area */
+int inflate_flush(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt n;
+  Bytef *p;
+  Bytef *q;
+
+  /* local copies of source and destination pointers */
+  p = z->next_out;
+  q = s->read;
+
+  /* compute number of bytes to copy as far as end of window */
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  /* update counters */
+  z->avail_out -= n;
+  z->total_out += n;
+
+  /* update check information */
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+  /* copy as far as end of window */
+  zmemcpy(p, q, n);
+  p += n;
+  q += n;
+
+  /* see if more to copy at beginning of window */
+  if (q == s->end)
+  {
+    /* wrap pointers */
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    /* compute bytes to copy */
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    /* update counters */
+    z->avail_out -= n;
+    z->total_out += n;
+
+    /* update check information */
+    if (s->checkfn != Z_NULL)
+      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+    /* copy */
+    zmemcpy(p, q, n);
+    p += n;
+    q += n;
+  }
+
+  /* update pointers */
+  z->next_out = p;
+  s->read = q;
+
+  /* done */
+  return r;
+}
diff -druN linux-noipsec/net/ipsec/zlib/infutil.h linux/net/ipsec/zlib/infutil.h
--- linux-noipsec/net/ipsec/zlib/infutil.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/infutil.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,98 @@
+/* infutil.h -- types and macros common to blocks and codes
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFUTIL_H
+#define _INFUTIL_H
+
+typedef enum {
+      TYPE,     /* get type bits (3, including end bit) */
+      LENS,     /* get lengths for stored */
+      STORED,   /* processing stored block */
+      TABLE,    /* get table lengths */
+      BTREE,    /* get bit lengths tree for a dynamic block */
+      DTREE,    /* get length, distance trees for a dynamic block */
+      CODES,    /* processing fixed or dynamic block */
+      DRY,      /* output remaining window bytes */
+      DONE,     /* finished last block, done */
+      BAD}      /* got a data error--stuck here */
+inflate_block_mode;
+
+/* inflate blocks semi-private state */
+struct inflate_blocks_state {
+
+  /* mode */
+  inflate_block_mode  mode;     /* current inflate_block mode */
+
+  /* mode dependent information */
+  union {
+    uInt left;          /* if STORED, bytes left to copy */
+    struct {
+      uInt table;               /* table lengths (14 bits) */
+      uInt index;               /* index into blens (or border) */
+      uIntf *blens;             /* bit lengths of codes */
+      uInt bb;                  /* bit length tree depth */
+      inflate_huft *tb;         /* bit length decoding tree */
+    } trees;            /* if DTREE, decoding info for trees */
+    struct {
+      inflate_codes_statef 
+         *codes;
+    } decode;           /* if CODES, current state */
+  } sub;                /* submode */
+  uInt last;            /* true if this block is the last block */
+
+  /* mode independent information */
+  uInt bitk;            /* bits in bit buffer */
+  uLong bitb;           /* bit buffer */
+  inflate_huft *hufts;  /* single malloc for tree space */
+  Bytef *window;        /* sliding window */
+  Bytef *end;           /* one byte after sliding window */
+  Bytef *read;          /* window read pointer */
+  Bytef *write;         /* window write pointer */
+  check_func checkfn;   /* check function */
+  uLong check;          /* check on output */
+
+};
+
+
+/* defines for inflate input/output */
+/*   update pointers and return */
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+/*   get bytes and bits */
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+/*   output bytes */
+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
+#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+/*   load local pointers */
+#define LOAD {LOADIN LOADOUT}
+
+/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
+extern uInt inflate_mask[17];
+
+/* copy as much as possible from the sliding window to the output area */
+extern int inflate_flush OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+struct internal_state      {int dummy;}; /* for buggy compilers */
+
+#endif /* _INFUTIL_H */
diff -druN linux-noipsec/net/ipsec/zlib/match586.S linux/net/ipsec/zlib/match586.S
--- linux-noipsec/net/ipsec/zlib/match586.S	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/match586.S	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,357 @@
+/* match.s -- Pentium-optimized version of longest_match()
+ * Written for zlib 1.1.2
+ * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License.
+ */
+
+#ifndef NO_UNDERLINE
+#define	match_init	_ipcomp_match_init
+#define	longest_match	_ipcomp_longest_match
+#else
+#define match_init	ipcomp_match_init
+#define longest_match	ipcomp_longest_match
+#endif
+
+#define	MAX_MATCH	(258)
+#define	MIN_MATCH	(3)
+#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
+#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
+
+/* stack frame offsets */
+
+#define	wmask			0	/* local copy of s->wmask	*/
+#define	window			4	/* local copy of s->window	*/
+#define	windowbestlen		8	/* s->window + bestlen		*/
+#define	chainlenscanend		12	/* high word: current chain len	*/
+					/* low word: last bytes sought	*/
+#define	scanstart		16	/* first two bytes of string	*/
+#define	scanalign		20	/* dword-misalignment of string	*/
+#define	nicematch		24	/* a good enough match size	*/
+#define	bestlen			28	/* size of best match so far	*/
+#define	scan			32	/* ptr to string wanting match	*/
+
+#define	LocalVarsSize		(36)
+/*	saved ebx		36 */
+/*	saved edi		40 */
+/*	saved esi		44 */
+/*	saved ebp		48 */
+/*	return address		52 */
+#define	deflatestate		56	/* the function arguments	*/
+#define	curmatch		60
+
+/* Offsets for fields in the deflate_state structure. These numbers
+ * are calculated from the definition of deflate_state, with the
+ * assumption that the compiler will dword-align the fields. (Thus,
+ * changing the definition of deflate_state could easily cause this
+ * program to crash horribly, without so much as a warning at
+ * compile time. Sigh.)
+ */
+#define	dsWSize			36
+#define	dsWMask			44
+#define	dsWindow		48
+#define	dsPrev			56
+#define	dsMatchLen		88
+#define	dsPrevMatch		92
+#define	dsStrStart		100
+#define	dsMatchStart		104
+#define	dsLookahead		108
+#define	dsPrevLen		112
+#define	dsMaxChainLen		116
+#define	dsGoodMatch		132
+#define	dsNiceMatch		136
+
+
+.file "match.S"
+
+.globl	match_init, longest_match
+
+.text
+
+/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
+
+longest_match:
+
+/* Save registers that the compiler may be using, and adjust %esp to	*/
+/* make room for our stack frame.					*/
+
+		pushl	%ebp
+		pushl	%edi
+		pushl	%esi
+		pushl	%ebx
+		subl	$LocalVarsSize, %esp
+
+/* Retrieve the function arguments. %ecx will hold cur_match		*/
+/* throughout the entire function. %edx will hold the pointer to the	*/
+/* deflate_state structure during the function's setup (before		*/
+/* entering the main loop).						*/
+
+		movl	deflatestate(%esp), %edx
+		movl	curmatch(%esp), %ecx
+
+/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
+
+		movl	dsNiceMatch(%edx), %eax
+		movl	dsLookahead(%edx), %ebx
+		cmpl	%eax, %ebx
+		jl	LookaheadLess
+		movl	%eax, %ebx
+LookaheadLess:	movl	%ebx, nicematch(%esp)
+
+/* register Bytef *scan = s->window + s->strstart;			*/
+
+		movl	dsWindow(%edx), %esi
+		movl	%esi, window(%esp)
+		movl	dsStrStart(%edx), %ebp
+		lea	(%esi,%ebp), %edi
+		movl	%edi, scan(%esp)
+
+/* Determine how many bytes the scan ptr is off from being		*/
+/* dword-aligned.							*/
+
+		movl	%edi, %eax
+		negl	%eax
+		andl	$3, %eax
+		movl	%eax, scanalign(%esp)
+
+/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
+/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
+
+		movl	dsWSize(%edx), %eax
+		subl	$MIN_LOOKAHEAD, %eax
+		subl	%eax, %ebp
+		jg	LimitPositive
+		xorl	%ebp, %ebp
+LimitPositive:
+
+/* unsigned chain_length = s->max_chain_length;				*/
+/* if (s->prev_length >= s->good_match) {				*/
+/*     chain_length >>= 2;						*/
+/* }									*/
+
+		movl	dsPrevLen(%edx), %eax
+		movl	dsGoodMatch(%edx), %ebx
+		cmpl	%ebx, %eax
+		movl	dsMaxChainLen(%edx), %ebx
+		jl	LastMatchGood
+		shrl	$2, %ebx
+LastMatchGood:
+
+/* chainlen is decremented once beforehand so that the function can	*/
+/* use the sign flag instead of the zero flag for the exit test.	*/
+/* It is then shifted into the high word, to make room for the scanend	*/
+/* scanend value, which it will always accompany.			*/
+
+		decl	%ebx
+		shll	$16, %ebx
+
+/* int best_len = s->prev_length;					*/
+
+		movl	dsPrevLen(%edx), %eax
+		movl	%eax, bestlen(%esp)
+
+/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
+
+		addl	%eax, %esi
+		movl	%esi, windowbestlen(%esp)
+
+/* register ush scan_start = *(ushf*)scan;				*/
+/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
+
+		movw	(%edi), %bx
+		movw	%bx, scanstart(%esp)
+		movw	-1(%edi,%eax), %bx
+		movl	%ebx, chainlenscanend(%esp)
+
+/* Posf *prev = s->prev;						*/
+/* uInt wmask = s->w_mask;						*/
+
+		movl	dsPrev(%edx), %edi
+		movl	dsWMask(%edx), %edx
+		mov	%edx, wmask(%esp)
+
+/* Jump into the main loop.						*/
+
+		jmp	LoopEntry
+
+.balign 16
+
+/* do {
+ *     match = s->window + cur_match;
+ *     if (*(ushf*)(match+best_len-1) != scan_end ||
+ *         *(ushf*)match != scan_start) continue;
+ *     [...]
+ * } while ((cur_match = prev[cur_match & wmask]) > limit
+ *          && --chain_length != 0);
+ *
+ * Here is the inner loop of the function. The function will spend the
+ * majority of its time in this loop, and majority of that time will
+ * be spent in the first ten instructions.
+ *
+ * Within this loop:
+ * %ebx = chainlenscanend - i.e., ((chainlen << 16) | scanend)
+ * %ecx = curmatch
+ * %edx = curmatch & wmask
+ * %esi = windowbestlen - i.e., (window + bestlen)
+ * %edi = prev
+ * %ebp = limit
+ *
+ * Two optimization notes on the choice of instructions:
+ *
+ * The first instruction uses a 16-bit address, which costs an extra,
+ * unpairable cycle. This is cheaper than doing a 32-bit access and
+ * zeroing the high word, due to the 3-cycle misalignment penalty which
+ * would occur half the time. This also turns out to be cheaper than
+ * doing two separate 8-bit accesses, as the memory is so rarely in the
+ * L1 cache.
+ *
+ * The window buffer, however, apparently spends a lot of time in the
+ * cache, and so it is faster to retrieve the word at the end of the
+ * match string with two 8-bit loads. The instructions that test the
+ * word at the beginning of the match string, however, are executed
+ * much less frequently, and there it was cheaper to use 16-bit
+ * instructions, which avoided the necessity of saving off and
+ * subsequently reloading one of the other registers.
+ */
+LookupLoop:
+							/* 1 U & V  */
+		movw	(%edi,%edx,2), %cx		/* 2 U pipe */
+		movl	wmask(%esp), %edx		/* 2 V pipe */
+		cmpl	%ebp, %ecx			/* 3 U pipe */
+		jbe	LeaveNow			/* 3 V pipe */
+		subl	$0x00010000, %ebx		/* 4 U pipe */
+		js	LeaveNow			/* 4 V pipe */
+LoopEntry:	movb	-1(%esi,%ecx), %al		/* 5 U pipe */
+		andl	%ecx, %edx			/* 5 V pipe */
+		cmpb	%bl, %al			/* 6 U pipe */
+		jnz	LookupLoop			/* 6 V pipe */
+		movb	(%esi,%ecx), %ah
+		cmpb	%bh, %ah
+		jnz	LookupLoop
+		movl	window(%esp), %eax
+		movw	(%eax,%ecx), %ax
+		cmpw	scanstart(%esp), %ax
+		jnz	LookupLoop
+
+/* Store the current value of chainlen.					*/
+
+		movl	%ebx, chainlenscanend(%esp)
+
+/* Point %edi to the string under scrutiny, and %esi to the string we	*/
+/* are hoping to match it up with. In actuality, %esi and %edi are	*/
+/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
+/* initialized to -(MAX_MATCH_8 - scanalign).				*/
+
+		movl	window(%esp), %esi
+		movl	scan(%esp), %edi
+		addl	%ecx, %esi
+		movl	scanalign(%esp), %eax
+		movl	$(-MAX_MATCH_8), %edx
+		lea	MAX_MATCH_8(%edi,%eax), %edi
+		lea	MAX_MATCH_8(%esi,%eax), %esi
+
+/* Test the strings for equality, 8 bytes at a time. At the end,
+ * adjust %edx so that it is offset to the exact byte that mismatched.
+ *
+ * We already know at this point that the first three bytes of the
+ * strings match each other, and they can be safely passed over before
+ * starting the compare loop. So what this code does is skip over 0-3
+ * bytes, as much as necessary in order to dword-align the %edi
+ * pointer. (%esi will still be misaligned three times out of four.)
+ *
+ * It should be confessed that this loop usually does not represent
+ * much of the total running time. Replacing it with a more
+ * straightforward "rep cmpsb" would not drastically degrade
+ * performance.
+ */
+LoopCmps:
+		movl	(%esi,%edx), %eax
+		movl	(%edi,%edx), %ebx
+		xorl	%ebx, %eax
+		jnz	LeaveLoopCmps
+		movl	4(%esi,%edx), %eax
+		movl	4(%edi,%edx), %ebx
+		xorl	%ebx, %eax
+		jnz	LeaveLoopCmps4
+		addl	$8, %edx
+		jnz	LoopCmps
+		jmp	LenMaximum
+LeaveLoopCmps4:	addl	$4, %edx
+LeaveLoopCmps:	testl	$0x0000FFFF, %eax
+		jnz	LenLower
+		addl	$2, %edx
+		shrl	$16, %eax
+LenLower:	subb	$1, %al
+		adcl	$0, %edx
+
+/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
+/* then automatically accept it as the best possible match and leave.	*/
+
+		lea	(%edi,%edx), %eax
+		movl	scan(%esp), %edi
+		subl	%edi, %eax
+		cmpl	$MAX_MATCH, %eax
+		jge	LenMaximum
+
+/* If the length of the match is not longer than the best match we	*/
+/* have so far, then forget it and return to the lookup loop.		*/
+
+		movl	deflatestate(%esp), %edx
+		movl	bestlen(%esp), %ebx
+		cmpl	%ebx, %eax
+		jg	LongerMatch
+		movl	chainlenscanend(%esp), %ebx
+		movl	windowbestlen(%esp), %esi
+		movl	dsPrev(%edx), %edi
+		movl	wmask(%esp), %edx
+		andl	%ecx, %edx
+		jmp	LookupLoop
+
+/*         s->match_start = cur_match;					*/
+/*         best_len = len;						*/
+/*         if (len >= nice_match) break;				*/
+/*         scan_end = *(ushf*)(scan+best_len-1);			*/
+
+LongerMatch:	movl	nicematch(%esp), %ebx
+		movl	%eax, bestlen(%esp)
+		movl	%ecx, dsMatchStart(%edx)
+		cmpl	%ebx, %eax
+		jge	LeaveNow
+		movl	window(%esp), %esi
+		addl	%eax, %esi
+		movl	%esi, windowbestlen(%esp)
+		movl	chainlenscanend(%esp), %ebx
+		movw	-1(%edi,%eax), %bx
+		movl	dsPrev(%edx), %edi
+		movl	%ebx, chainlenscanend(%esp)
+		movl	wmask(%esp), %edx
+		andl	%ecx, %edx
+		jmp	LookupLoop
+
+/* Accept the current string, with the maximum possible length.		*/
+
+LenMaximum:	movl	deflatestate(%esp), %edx
+		movl	$MAX_MATCH, bestlen(%esp)
+		movl	%ecx, dsMatchStart(%edx)
+
+/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
+/* return s->lookahead;							*/
+
+LeaveNow:
+		movl	deflatestate(%esp), %edx
+		movl	bestlen(%esp), %ebx
+		movl	dsLookahead(%edx), %eax
+		cmpl	%eax, %ebx
+		jg	LookaheadRet
+		movl	%ebx, %eax
+LookaheadRet:
+
+/* Restore the stack and return from whence we came.			*/
+
+		addl	$LocalVarsSize, %esp
+		popl	%ebx
+		popl	%esi
+		popl	%edi
+		popl	%ebp
+match_init:	ret
diff -druN linux-noipsec/net/ipsec/zlib/match686.S linux/net/ipsec/zlib/match686.S
--- linux-noipsec/net/ipsec/zlib/match686.S	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/match686.S	Fri Oct 27 05:35:16 2000
@@ -0,0 +1,330 @@
+/* match.s -- Pentium-Pro-optimized version of longest_match()
+ * Written for zlib 1.1.2
+ * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License.
+ */
+
+#ifndef NO_UNDERLINE
+#define	match_init	_ipcomp_match_init
+#define	longest_match	_ipcomp_longest_match
+#else
+#define match_init	ipcomp_match_init
+#define longest_match	ipcomp_longest_match
+#endif
+
+#define	MAX_MATCH	(258)
+#define	MIN_MATCH	(3)
+#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
+#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
+
+/* stack frame offsets */
+
+#define	chainlenwmask		0	/* high word: current chain len	*/
+					/* low word: s->wmask		*/
+#define	window			4	/* local copy of s->window	*/
+#define	windowbestlen		8	/* s->window + bestlen		*/
+#define	scanstart		16	/* first two bytes of string	*/
+#define	scanend			12	/* last two bytes of string	*/
+#define	scanalign		20	/* dword-misalignment of string	*/
+#define	nicematch		24	/* a good enough match size	*/
+#define	bestlen			28	/* size of best match so far	*/
+#define	scan			32	/* ptr to string wanting match	*/
+
+#define	LocalVarsSize		(36)
+/*	saved ebx		36 */
+/*	saved edi		40 */
+/*	saved esi		44 */
+/*	saved ebp		48 */
+/*	return address		52 */
+#define	deflatestate		56	/* the function arguments	*/
+#define	curmatch		60
+
+/* Offsets for fields in the deflate_state structure. These numbers
+ * are calculated from the definition of deflate_state, with the
+ * assumption that the compiler will dword-align the fields. (Thus,
+ * changing the definition of deflate_state could easily cause this
+ * program to crash horribly, without so much as a warning at
+ * compile time. Sigh.)
+ */
+#define	dsWSize			36
+#define	dsWMask			44
+#define	dsWindow		48
+#define	dsPrev			56
+#define	dsMatchLen		88
+#define	dsPrevMatch		92
+#define	dsStrStart		100
+#define	dsMatchStart		104
+#define	dsLookahead		108
+#define	dsPrevLen		112
+#define	dsMaxChainLen		116
+#define	dsGoodMatch		132
+#define	dsNiceMatch		136
+
+
+.file "match.S"
+
+.globl	match_init, longest_match
+
+.text
+
+/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
+
+longest_match:
+
+/* Save registers that the compiler may be using, and adjust %esp to	*/
+/* make room for our stack frame.					*/
+
+		pushl	%ebp
+		pushl	%edi
+		pushl	%esi
+		pushl	%ebx
+		subl	$LocalVarsSize, %esp
+
+/* Retrieve the function arguments. %ecx will hold cur_match		*/
+/* throughout the entire function. %edx will hold the pointer to the	*/
+/* deflate_state structure during the function's setup (before		*/
+/* entering the main loop).						*/
+
+		movl	deflatestate(%esp), %edx
+		movl	curmatch(%esp), %ecx
+
+/* uInt wmask = s->w_mask;						*/
+/* unsigned chain_length = s->max_chain_length;				*/
+/* if (s->prev_length >= s->good_match) {				*/
+/*     chain_length >>= 2;						*/
+/* }									*/
+
+		movl	dsPrevLen(%edx), %eax
+		movl	dsGoodMatch(%edx), %ebx
+		cmpl	%ebx, %eax
+		movl	dsWMask(%edx), %eax
+		movl	dsMaxChainLen(%edx), %ebx
+		jl	LastMatchGood
+		shrl	$2, %ebx
+LastMatchGood:
+
+/* chainlen is decremented once beforehand so that the function can	*/
+/* use the sign flag instead of the zero flag for the exit test.	*/
+/* It is then shifted into the high word, to make room for the wmask	*/
+/* value, which it will always accompany.				*/
+
+		decl	%ebx
+		shll	$16, %ebx
+		orl	%eax, %ebx
+		movl	%ebx, chainlenwmask(%esp)
+
+/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
+
+		movl	dsNiceMatch(%edx), %eax
+		movl	dsLookahead(%edx), %ebx
+		cmpl	%eax, %ebx
+		jl	LookaheadLess
+		movl	%eax, %ebx
+LookaheadLess:	movl	%ebx, nicematch(%esp)
+
+/* register Bytef *scan = s->window + s->strstart;			*/
+
+		movl	dsWindow(%edx), %esi
+		movl	%esi, window(%esp)
+		movl	dsStrStart(%edx), %ebp
+		lea	(%esi,%ebp), %edi
+		movl	%edi, scan(%esp)
+
+/* Determine how many bytes the scan ptr is off from being		*/
+/* dword-aligned.							*/
+
+		movl	%edi, %eax
+		negl	%eax
+		andl	$3, %eax
+		movl	%eax, scanalign(%esp)
+
+/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
+/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
+
+		movl	dsWSize(%edx), %eax
+		subl	$MIN_LOOKAHEAD, %eax
+		subl	%eax, %ebp
+		jg	LimitPositive
+		xorl	%ebp, %ebp
+LimitPositive:
+
+/* int best_len = s->prev_length;					*/
+
+		movl	dsPrevLen(%edx), %eax
+		movl	%eax, bestlen(%esp)
+
+/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
+
+		addl	%eax, %esi
+		movl	%esi, windowbestlen(%esp)
+
+/* register ush scan_start = *(ushf*)scan;				*/
+/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
+/* Posf *prev = s->prev;						*/
+
+		movzwl	(%edi), %ebx
+		movl	%ebx, scanstart(%esp)
+		movzwl	-1(%edi,%eax), %ebx
+		movl	%ebx, scanend(%esp)
+		movl	dsPrev(%edx), %edi
+
+/* Jump into the main loop.						*/
+
+		movl	chainlenwmask(%esp), %edx
+		jmp	LoopEntry
+
+.balign 16
+
+/* do {
+ *     match = s->window + cur_match;
+ *     if (*(ushf*)(match+best_len-1) != scan_end ||
+ *         *(ushf*)match != scan_start) continue;
+ *     [...]
+ * } while ((cur_match = prev[cur_match & wmask]) > limit
+ *          && --chain_length != 0);
+ *
+ * Here is the inner loop of the function. The function will spend the
+ * majority of its time in this loop, and majority of that time will
+ * be spent in the first ten instructions.
+ *
+ * Within this loop:
+ * %ebx = scanend
+ * %ecx = curmatch
+ * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
+ * %esi = windowbestlen - i.e., (window + bestlen)
+ * %edi = prev
+ * %ebp = limit
+ */
+LookupLoop:
+		andl	%edx, %ecx
+		movzwl	(%edi,%ecx,2), %ecx
+		cmpl	%ebp, %ecx
+		jbe	LeaveNow
+		subl	$0x00010000, %edx
+		js	LeaveNow
+LoopEntry:	movzwl	-1(%esi,%ecx), %eax
+		cmpl	%ebx, %eax
+		jnz	LookupLoop
+		movl	window(%esp), %eax
+		movzwl	(%eax,%ecx), %eax
+		cmpl	scanstart(%esp), %eax
+		jnz	LookupLoop
+
+/* Store the current value of chainlen.					*/
+
+		movl	%edx, chainlenwmask(%esp)
+
+/* Point %edi to the string under scrutiny, and %esi to the string we	*/
+/* are hoping to match it up with. In actuality, %esi and %edi are	*/
+/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
+/* initialized to -(MAX_MATCH_8 - scanalign).				*/
+
+		movl	window(%esp), %esi
+		movl	scan(%esp), %edi
+		addl	%ecx, %esi
+		movl	scanalign(%esp), %eax
+		movl	$(-MAX_MATCH_8), %edx
+		lea	MAX_MATCH_8(%edi,%eax), %edi
+		lea	MAX_MATCH_8(%esi,%eax), %esi
+
+/* Test the strings for equality, 8 bytes at a time. At the end,
+ * adjust %edx so that it is offset to the exact byte that mismatched.
+ *
+ * We already know at this point that the first three bytes of the
+ * strings match each other, and they can be safely passed over before
+ * starting the compare loop. So what this code does is skip over 0-3
+ * bytes, as much as necessary in order to dword-align the %edi
+ * pointer. (%esi will still be misaligned three times out of four.)
+ *
+ * It should be confessed that this loop usually does not represent
+ * much of the total running time. Replacing it with a more
+ * straightforward "rep cmpsb" would not drastically degrade
+ * performance.
+ */
+LoopCmps:
+		movl	(%esi,%edx), %eax
+		xorl	(%edi,%edx), %eax
+		jnz	LeaveLoopCmps
+		movl	4(%esi,%edx), %eax
+		xorl	4(%edi,%edx), %eax
+		jnz	LeaveLoopCmps4
+		addl	$8, %edx
+		jnz	LoopCmps
+		jmp	LenMaximum
+LeaveLoopCmps4:	addl	$4, %edx
+LeaveLoopCmps:	testl	$0x0000FFFF, %eax
+		jnz	LenLower
+		addl	$2, %edx
+		shrl	$16, %eax
+LenLower:	subb	$1, %al
+		adcl	$0, %edx
+
+/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
+/* then automatically accept it as the best possible match and leave.	*/
+
+		lea	(%edi,%edx), %eax
+		movl	scan(%esp), %edi
+		subl	%edi, %eax
+		cmpl	$MAX_MATCH, %eax
+		jge	LenMaximum
+
+/* If the length of the match is not longer than the best match we	*/
+/* have so far, then forget it and return to the lookup loop.		*/
+
+		movl	deflatestate(%esp), %edx
+		movl	bestlen(%esp), %ebx
+		cmpl	%ebx, %eax
+		jg	LongerMatch
+		movl	windowbestlen(%esp), %esi
+		movl	dsPrev(%edx), %edi
+		movl	scanend(%esp), %ebx
+		movl	chainlenwmask(%esp), %edx
+		jmp	LookupLoop
+
+/*         s->match_start = cur_match;					*/
+/*         best_len = len;						*/
+/*         if (len >= nice_match) break;				*/
+/*         scan_end = *(ushf*)(scan+best_len-1);			*/
+
+LongerMatch:	movl	nicematch(%esp), %ebx
+		movl	%eax, bestlen(%esp)
+		movl	%ecx, dsMatchStart(%edx)
+		cmpl	%ebx, %eax
+		jge	LeaveNow
+		movl	window(%esp), %esi
+		addl	%eax, %esi
+		movl	%esi, windowbestlen(%esp)
+		movzwl	-1(%edi,%eax), %ebx
+		movl	dsPrev(%edx), %edi
+		movl	%ebx, scanend(%esp)
+		movl	chainlenwmask(%esp), %edx
+		jmp	LookupLoop
+
+/* Accept the current string, with the maximum possible length.		*/
+
+LenMaximum:	movl	deflatestate(%esp), %edx
+		movl	$MAX_MATCH, bestlen(%esp)
+		movl	%ecx, dsMatchStart(%edx)
+
+/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
+/* return s->lookahead;							*/
+
+LeaveNow:
+		movl	deflatestate(%esp), %edx
+		movl	bestlen(%esp), %ebx
+		movl	dsLookahead(%edx), %eax
+		cmpl	%eax, %ebx
+		jg	LookaheadRet
+		movl	%ebx, %eax
+LookaheadRet:
+
+/* Restore the stack and return from whence we came.			*/
+
+		addl	$LocalVarsSize, %esp
+		popl	%ebx
+		popl	%esi
+		popl	%edi
+		popl	%ebp
+match_init:	ret
diff -druN linux-noipsec/net/ipsec/zlib/trees.c linux/net/ipsec/zlib/trees.c
--- linux-noipsec/net/ipsec/zlib/trees.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/trees.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,1214 @@
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-1998 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* @(#) $Id$ */
+
+/* #define GEN_TREES_H */
+
+#include "deflate.h"
+
+#ifdef DEBUG
+#  include <ctype.h>
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local const int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local const uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+/* non ANSI compilers may not accept trees.h */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+uch _dist_code[DIST_CODE_LEN];
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+uch _length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+#else
+#  include "trees.h"
+#endif /* GEN_TREES_H */
+
+struct static_tree_desc_s {
+    const ct_data *static_tree;  /* static tree or NULL */
+    const intf *extra_bits;      /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, const ct_data *ltree,
+                              const ct_data *dtree));
+local void set_data_type  OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifdef GEN_TREES_H
+local void gen_trees_header OF((void));
+#endif
+
+#ifndef DEBUG
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG */
+#  define send_code(s, c, tree) \
+     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) & 0xff)); \
+    put_byte(s, (uch)((ush)(w) >> 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+#ifdef DEBUG
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr," l %2d v %4x ", length, value));
+    Assert(length > 0 && length <= 15, "invalid length");
+    s->bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s->bi_valid > (int)Buf_size - length) {
+        s->bi_buf |= (value << s->bi_valid);
+        put_short(s, s->bi_buf);
+        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_valid += length - Buf_size;
+    } else {
+        s->bi_buf |= value << s->bi_valid;
+        s->bi_valid += length;
+    }
+}
+#else /* !DEBUG */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s->bi_valid > (int)Buf_size - len) {\
+    int val = value;\
+    s->bi_buf |= (val << s->bi_valid);\
+    put_short(s, s->bi_buf);\
+    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_valid += len - Buf_size;\
+  } else {\
+    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_valid += len;\
+  }\
+}
+#endif /* DEBUG */
+
+
+#define MAX(a,b) (a >= b ? a : b)
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+local void tr_static_init()
+{
+#if defined(GEN_TREES_H) || !defined(STDC)
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* For some embedded targets, global variables are not initialized: */
+    static_l_desc.static_tree = static_ltree;
+    static_l_desc.extra_bits = extra_lbits;
+    static_d_desc.static_tree = static_dtree;
+    static_d_desc.extra_bits = extra_dbits;
+    static_bl_desc.extra_bits = extra_blbits;
+
+    /* Initialize the mapping length (0..255) -> length code (0..28) */
+    length = 0;
+    for (code = 0; code < LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n < (1<<extra_lbits[code]); n++) {
+            _length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, "tr_static_init: length != 256");
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    _length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code < 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n < (1<<extra_dbits[code]); n++) {
+            _dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: dist != 256");
+    dist >>= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code < D_CODES; code++) {
+        base_dist[code] = dist << 7;
+        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
+            _dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n < D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+
+#  ifdef GEN_TREES_H
+    gen_trees_header();
+#  endif
+#endif /* defined(GEN_TREES_H) || !defined(STDC) */
+}
+
+/* ===========================================================================
+ * Genererate the file trees.h describing the static trees.
+ */
+#ifdef GEN_TREES_H
+#  ifndef DEBUG
+#    include <stdio.h>
+#  endif
+
+#  define SEPARATOR(i, last, width) \
+      ((i) == (last)? "\n};\n\n" :    \
+       ((i) % (width) == (width)-1 ? ",\n" : ", "))
+
+void gen_trees_header()
+{
+    FILE *header = fopen("trees.h", "w");
+    int i;
+
+    Assert (header != NULL, "Can't open trees.h");
+    fprintf(header,
+	    "/* header created automatically with -DGEN_TREES_H */\n\n");
+
+    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
+    for (i = 0; i < L_CODES+2; i++) {
+	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
+		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
+    }
+
+    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
+		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
+    }
+
+    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
+    for (i = 0; i < DIST_CODE_LEN; i++) {
+	fprintf(header, "%2u%s", _dist_code[i],
+		SEPARATOR(i, DIST_CODE_LEN-1, 20));
+    }
+
+    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
+    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
+	fprintf(header, "%2u%s", _length_code[i],
+		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
+    }
+
+    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
+    for (i = 0; i < LENGTH_CODES; i++) {
+	fprintf(header, "%1u%s", base_length[i],
+		SEPARATOR(i, LENGTH_CODES-1, 20));
+    }
+
+    fprintf(header, "local const int base_dist[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+	fprintf(header, "%5u%s", base_dist[i],
+		SEPARATOR(i, D_CODES-1, 10));
+    }
+
+    fclose(header);
+}
+#endif /* GEN_TREES_H */
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s->l_desc.dyn_tree = s->dyn_ltree;
+    s->l_desc.stat_desc = &static_l_desc;
+
+    s->d_desc.dyn_tree = s->dyn_dtree;
+    s->d_desc.stat_desc = &static_d_desc;
+
+    s->bl_desc.dyn_tree = s->bl_tree;
+    s->bl_desc.stat_desc = &static_bl_desc;
+
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG
+    s->compressed_len = 0L;
+    s->bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+
+    s->dyn_ltree[END_BLOCK].Freq = 1;
+    s->opt_len = s->static_len = 0L;
+    s->last_lit = s->matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s->heap[SMALLEST]; \
+    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq < tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s->heap[k];
+    int j = k << 1;  /* left son of k */
+    while (j <= s->heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j < s->heap_len &&
+            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s->heap[j], s->depth)) break;
+
+        /* Exchange v with the smallest son */
+        s->heap[k] = s->heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j <<= 1;
+    }
+    s->heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree        = desc->dyn_tree;
+    int max_code         = desc->max_code;
+    const ct_data *stree = desc->stat_desc->static_tree;
+    const intf *extra    = desc->stat_desc->extra_bits;
+    int base             = desc->stat_desc->extra_base;
+    int max_length       = desc->stat_desc->max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+        n = s->heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits > max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n > max_code) continue; /* not a leaf node */
+
+        s->bl_count[bits]++;
+        xbits = 0;
+        if (n >= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s->opt_len += (ulg)f * (bits + xbits);
+        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,"\nbit length overflow\n"));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s->bl_count[bits] == 0) bits--;
+        s->bl_count[bits]--;      /* move one leaf down the tree */
+        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s->bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow > 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s->bl_count[bits];
+        while (n != 0) {
+            m = s->heap[--h];
+            if (m > max_code) continue;
+            if (tree[m].Len != (unsigned) bits) {
+                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+                s->opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits <= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+            "inconsistent bit counts");
+    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+    for (n = 0;  n <= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree         = desc->dyn_tree;
+    const ct_data *stree  = desc->stat_desc->static_tree;
+    int elems             = desc->stat_desc->elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s->heap_len = 0, s->heap_max = HEAP_SIZE;
+
+    for (n = 0; n < elems; n++) {
+        if (tree[n].Freq != 0) {
+            s->heap[++(s->heap_len)] = max_code = n;
+            s->depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s->heap_len < 2) {
+        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s->depth[node] = 0;
+        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc->max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s->heap[SMALLEST]; /* m = node of next least frequency */
+
+        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
+        s->heap[--(s->heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s->bl_tree) {
+            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s->heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s->heap_len >= 2);
+
+    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            s->bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+            s->bl_tree[REP_3_6].Freq++;
+        } else if (count <= 10) {
+            s->bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s->bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s->bl_tree); count--;
+            }
+            Assert(count >= 3 && count <= 6, " 3_6?");
+            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count <= 10) {
+            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
+    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
+        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+            s->opt_len, s->static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+            "too many codes");
+    Tracev((stderr, "\nbl counts: "));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank < blcodes; rank++) {
+        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void _tr_stored_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+#ifdef DEBUG
+    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len += (stored_len + 4) << 3;
+#endif
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES<<1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
+#endif
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
+        send_bits(s, STATIC_TREES<<1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+        s->compressed_len += 10L;
+#endif
+        bi_flush(s);
+    }
+    s->last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+void _tr_flush_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s->level > 0) {
+
+	 /* Check if the file is ascii or binary */
+	if (s->data_type == Z_UNKNOWN) set_data_type(s);
+
+	/* Construct the literal and distance trees */
+	build_tree(s, (tree_desc *)(&(s->l_desc)));
+	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+
+	build_tree(s, (tree_desc *)(&(s->d_desc)));
+	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+	/* At this point, opt_len and static_len are the total bit lengths of
+	 * the compressed block data, excluding the tree representations.
+	 */
+
+	/* Build the bit length tree for the above two trees, and get the index
+	 * in bl_order of the last bit length code to send.
+	 */
+	max_blindex = build_bl_tree(s);
+
+	/* Determine the best encoding. Compute first the block length in bytes*/
+	opt_lenb = (s->opt_len+3+7)>>3;
+	static_lenb = (s->static_len+3+7)>>3;
+
+	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+		s->last_lit));
+
+	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, "lost buf");
+	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, eof);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb >= 0) { /* force static trees */
+#else
+    } else if (static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES<<1)+eof, 3);
+        compress_block(s, static_ltree, static_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->static_len;
+#endif
+    } else {
+        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, s->dyn_ltree, s->dyn_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->opt_len;
+#endif
+    }
+    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+    /* The above check is made mod 2^32, for files larger than 512 MB
+     * and uLong implemented on 32 bits.
+     */
+    init_block(s);
+
+    if (eof) {
+        bi_windup(s);
+#ifdef DEBUG
+        s->compressed_len += 7;  /* align on byte boundary */
+#endif
+    }
+    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+           s->compressed_len-7*eof));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s->d_buf[s->last_lit] = (ush)dist;
+    s->l_buf[s->last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s->dyn_ltree[lc].Freq++;
+    } else {
+        s->matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist < (ush)MAX_DIST(s) &&
+               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
+        s->dyn_dtree[d_code(dist)].Freq++;
+    }
+
+#ifdef TRUNCATE_BLOCK
+    /* Try to guess if it is profitable to stop the current block here */
+    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s->last_lit*8L;
+        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        int dcode;
+        for (dcode = 0; dcode < D_CODES; dcode++) {
+            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length >>= 3;
+        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+               s->last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+    }
+#endif
+    return (s->last_lit == s->lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    const ct_data *ltree; /* literal tree */
+    const ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s->last_lit != 0) do {
+        dist = s->d_buf[lx];
+        lc = s->l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = _length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code < D_CODES, "bad d_code");
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
+
+    } while (lx < s->last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s->last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Set the data type to ASCII or BINARY, using a crude approximation:
+ * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
+ * IN assertion: the fields freq of dyn_ltree are set and the total of all
+ * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
+ */
+local void set_data_type(s)
+    deflate_state *s;
+{
+    int n = 0;
+    unsigned ascii_freq = 0;
+    unsigned bin_freq = 0;
+    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
+    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
+    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
+    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code & 1;
+        code >>= 1, res <<= 1;
+    } while (--len > 0);
+    return res >> 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s->bi_valid == 16) {
+        put_short(s, s->bi_buf);
+        s->bi_buf = 0;
+        s->bi_valid = 0;
+    } else if (s->bi_valid >= 8) {
+        put_byte(s, (Byte)s->bi_buf);
+        s->bi_buf >>= 8;
+        s->bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s->bi_valid > 8) {
+        put_short(s, s->bi_buf);
+    } else if (s->bi_valid > 0) {
+        put_byte(s, (Byte)s->bi_buf);
+    }
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+#ifdef DEBUG
+    s->bits_sent = (s->bits_sent+7) & ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);   
+        put_short(s, (ush)~len);
+#ifdef DEBUG
+        s->bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG
+    s->bits_sent += (ulg)len<<3;
+#endif
+    while (len--) {
+        put_byte(s, *buf++);
+    }
+}
diff -druN linux-noipsec/net/ipsec/zlib/trees.h linux/net/ipsec/zlib/trees.h
--- linux-noipsec/net/ipsec/zlib/trees.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/trees.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,128 @@
+/* header created automatically with -DGEN_TREES_H */
+
+local const ct_data static_ltree[L_CODES+2] = {
+{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
+{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
+{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
+{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
+{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
+{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
+{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
+{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
+{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
+{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
+{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
+{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
+{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
+{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
+{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
+{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
+{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
+{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
+{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
+{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
+{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
+{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
+{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
+{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
+{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
+{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
+{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
+{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
+{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
+{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
+{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
+{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
+{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
+{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
+{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
+{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
+{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
+{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
+{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
+{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
+{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
+{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
+{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
+{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
+{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
+{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
+{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
+{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
+{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
+{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
+{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
+{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
+{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
+{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
+{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
+{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
+{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
+{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
+};
+
+local const ct_data static_dtree[D_CODES] = {
+{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
+{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
+{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
+{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
+{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
+{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
+};
+
+const uch _dist_code[DIST_CODE_LEN] = {
+ 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
+ 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
+10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
+18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
+};
+
+const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
+ 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
+13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
+17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
+22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
+};
+
+local const int base_length[LENGTH_CODES] = {
+0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
+64, 80, 96, 112, 128, 160, 192, 224, 0
+};
+
+local const int base_dist[D_CODES] = {
+    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
+   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
+ 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
+};
+
diff -druN linux-noipsec/net/ipsec/zlib/zconf.h linux/net/ipsec/zlib/zconf.h
--- linux-noipsec/net/ipsec/zlib/zconf.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/zconf.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,309 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-1998 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id$ */
+
+#ifndef _ZCONF_H
+#define _ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef IPCOMP_PREFIX
+#  define deflateInit_	ipcomp_deflateInit_
+#  define deflate	ipcomp_deflate
+#  define deflateEnd	ipcomp_deflateEnd
+#  define inflateInit_ 	ipcomp_inflateInit_
+#  define inflate	ipcomp_inflate
+#  define inflateEnd	ipcomp_inflateEnd
+#  define deflateInit2_	ipcomp_deflateInit2_
+#  define deflateSetDictionary ipcomp_deflateSetDictionary
+#  define deflateCopy	ipcomp_deflateCopy
+#  define deflateReset	ipcomp_deflateReset
+#  define deflateParams	ipcomp_deflateParams
+#  define inflateInit2_	ipcomp_inflateInit2_
+#  define inflateSetDictionary ipcomp_inflateSetDictionary
+#  define inflateSync	ipcomp_inflateSync
+#  define inflateSyncPoint ipcomp_inflateSyncPoint
+#  define inflateReset	ipcomp_inflateReset
+#  define compress	ipcomp_compress
+#  define compress2	ipcomp_compress2
+#  define uncompress	ipcomp_uncompress
+#  define adler32	ipcomp_adler32
+#  define crc32		ipcomp_crc32
+#  define get_crc_table ipcomp_get_crc_table
+/* SSS: these also need to be prefixed to avoid clash with ppp_deflate and ext2compression */
+#  define inflate_blocks ipcomp_deflate_blocks
+#  define inflate_blocks_free ipcomp_deflate_blocks_free
+#  define inflate_blocks_new ipcomp_inflate_blocks_new
+#  define inflate_blocks_reset ipcomp_inflate_blocks_reset
+#  define inflate_blocks_sync_point ipcomp_inflate_blocks_sync_point
+#  define inflate_set_dictionary ipcomp_inflate_set_dictionary
+#  define inflate_codes ipcomp_inflate_codes
+#  define inflate_codes_free ipcomp_inflate_codes_free
+#  define inflate_codes_new ipcomp_inflate_codes_new
+#  define inflate_fast ipcomp_inflate_fast
+#  define inflate_trees_bits ipcomp_inflate_trees_bits
+#  define inflate_trees_dynamic ipcomp_inflate_trees_dynamic
+#  define inflate_trees_fixed ipcomp_inflate_trees_fixed
+#  define inflate_flush ipcomp_inflate_flush
+#  define inflate_mask ipcomp_inflate_mask
+#  define _dist_code _ipcomp_dist_code
+#  define _length_code _ipcomp_length_code
+#  define _tr_align _ipcomp_tr_align
+#  define _tr_flush_block _ipcomp_tr_flush_block
+#  define _tr_init _ipcomp_tr_init
+#  define _tr_stored_block _ipcomp_tr_stored_block
+#  define _tr_tally _ipcomp_tr_tally
+#  define zError ipcomp_zError
+#  define z_errmsg ipcomp_z_errmsg
+#  define zlibVersion ipcomp_zlibVersion
+#  define match_init ipcomp_match_init
+#  define longest_match ipcomp_longest_match
+#endif
+
+#ifdef Z_PREFIX
+#  define Byte		z_Byte
+#  define uInt		z_uInt
+#  define uLong		z_uLong
+#  define Bytef	        z_Bytef
+#  define charf		z_charf
+#  define intf		z_intf
+#  define uIntf		z_uIntf
+#  define uLongf	z_uLongf
+#  define voidpf	z_voidpf
+#  define voidp		z_voidp
+#endif
+
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
+#  ifndef __32BIT__
+#    define __32BIT__
+#  endif
+#endif
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#if defined(MSDOS) && !defined(__32BIT__)
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
+#  define STDC
+#endif
+#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
+#  ifndef STDC
+#    define STDC
+#  endif
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Old Borland C incorrectly complains about missing returns: */
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
+#  define NEED_DUMMY_RETURN
+#endif
+
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
+   /* MSC small or medium model */
+#  define SMALL_MEDIUM
+#  ifdef _MSC_VER
+#    define FAR _far
+#  else
+#    define FAR far
+#  endif
+#endif
+#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
+#  ifndef __32BIT__
+#    define SMALL_MEDIUM
+#    define FAR _far
+#  endif
+#endif
+
+/* Compile with -DZLIB_DLL for Windows DLL support */
+#if defined(ZLIB_DLL)
+#  if defined(_WINDOWS) || defined(WINDOWS)
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+#    define ZEXPORT  WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA  WINAPIV
+#    else
+#      define ZEXPORTVA  FAR _cdecl _export
+#    endif
+#  endif
+#  if defined (__BORLANDC__)
+#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
+#      include <windows.h>
+#      define ZEXPORT __declspec(dllexport) WINAPI
+#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
+#    else
+#      if defined (_Windows) && defined (__DLL__)
+#        define ZEXPORT _export
+#        define ZEXPORTVA _export
+#      endif
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  if defined (ZLIB_DLL)
+#    define ZEXTERN extern __declspec(dllexport)
+#  else
+#    define ZEXTERN extern __declspec(dllimport)
+#  endif
+#endif
+
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+
+#ifndef FAR
+#   define FAR
+#endif
+
+#if !defined(MACOS) && !defined(TARGET_OS_MAC)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  define z_off_t  off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define  z_off_t long
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(inflate_blocks,"INBL")
+#   pragma map(inflate_blocks_new,"INBLNE")
+#   pragma map(inflate_blocks_free,"INBLFR")
+#   pragma map(inflate_blocks_reset,"INBLRE")
+#   pragma map(inflate_codes_free,"INCOFR")
+#   pragma map(inflate_codes,"INCO")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_flush,"INFLU")
+#   pragma map(inflate_mask,"INMA")
+#   pragma map(inflate_set_dictionary,"INSEDI2")
+#   pragma map(ipcomp_inflate_copyright,"INCOPY")
+#   pragma map(inflate_trees_bits,"INTRBI")
+#   pragma map(inflate_trees_dynamic,"INTRDY")
+#   pragma map(inflate_trees_fixed,"INTRFI")
+#   pragma map(inflate_trees_free,"INTRFR")
+#endif
+
+#endif /* _ZCONF_H */
diff -druN linux-noipsec/net/ipsec/zlib/zlib.h linux/net/ipsec/zlib/zlib.h
--- linux-noipsec/net/ipsec/zlib/zlib.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/zlib.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,893 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.1.3, July 9th, 1998
+
+  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.1.3"
+
+/* 
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    const char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+/* Allowed flush values; see deflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/* 
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  the compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out).
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+  
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero).
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/* 
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may some
+  introduce some output latency (reading input without producing any output)
+  except when forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
+  output as possible to the output buffer. The flushing behavior of inflate is
+  not specified for values of the flush parameter other than Z_SYNC_FLUSH
+  and Z_FINISH, but the current implementation actually flushes as much output
+  as possible anyway.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+     If a preset dictionary is needed at this point (see inflateSetDictionary
+  below), inflate sets strm-adler to the adler32 checksum of the
+  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
+  it sets strm->adler to the adler32 checksum of all output produced
+  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
+  an error code as described below. At the end of the stream, inflate()
+  checks that its computed adler32 checksum is equal to that saved by the
+  compressor and returns Z_STREAM_END only if the checksum is correct.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect
+  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
+  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
+  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
+  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
+  case, the application may then call inflateSync to look for a good
+  compression block.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*   
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match).  Filtered data consists mostly of small values with a
+   somewhat random distribution. In this case, the compression algorithm is
+   tuned to compress them better. The effect of Z_FILTERED is to force more
+   Huffman coding and less string matching; it is somewhat intermediate
+   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
+   the compression ratio but not the correctness of the compressed output even
+   if it is not set appropriately.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+                            
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front.
+
+     Upon return of this function, strm->adler is set to the Adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The Adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.)
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+				      int level,
+				      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+/*   
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. If a compressed stream with a larger window size is given as
+   input, inflate() will return with the error code Z_DATA_ERROR instead of
+   trying to allocate a larger window.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+   memLevel). msg is set to null if there is no error message.  inflateInit2
+   does not perform any decompression apart from reading the zlib header if
+   present: this will be done by inflate(). (So next_in and avail_in may be
+   modified, but next_out and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate
+   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the Adler32 value returned by this call of
+   inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect Adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/* 
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least 0.1% larger than
+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least 0.1% larger than sourceLen plus
+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h". (See the description
+   of deflateInit2 for more information about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
+				   const voidp buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+				      z_off_t offset, int whence));
+/* 
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int err));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZLIB_H */
diff -druN linux-noipsec/net/ipsec/zlib/zutil.c linux/net/ipsec/zlib/zutil.c
--- linux-noipsec/net/ipsec/zlib/zutil.c	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/zutil.c	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,227 @@
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-1998 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id$ */
+
+#include "zutil.h"
+
+#define MY_ZCALLOC
+
+struct internal_state      {int dummy;}; /* for buggy compilers */
+
+#ifndef STDC
+extern void exit OF((int));
+#endif
+
+const char *z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
+
+
+const char * ZEXPORT zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+#ifdef DEBUG
+
+#  ifndef verbose
+#    define verbose 0
+#  endif
+int z_verbose = verbose;
+
+void z_error (m)
+    char *m;
+{
+    fprintf(stderr, "%s\n", m);
+    exit(1);
+}
+#endif
+
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
+ */
+const char * ZEXPORT zError(err)
+    int err;
+{
+    return ERR_MSG(err);
+}
+
+
+#ifndef HAVE_MEMCPY
+
+void zmemcpy(dest, source, len)
+    Bytef* dest;
+    const Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int zmemcmp(s1, s2, len)
+    const Bytef* s1;
+    const Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j < len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+    }
+    return 0;
+}
+
+void zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+#ifdef __TURBOC__
+#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
+/* Small and medium model in Turbo C are for now limited to near allocation
+ * with reduced MAX_WBITS and MAX_MEM_LEVEL
+ */
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize < 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
+    *(ush*)&buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&ptr != 0) { /* object < 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n < next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n < next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, "zcfree: ptr not found");
+}
+#endif
+#endif /* __TURBOC__ */
+
+
+#if defined(M_I86) && !defined(__32BIT__)
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* MSC */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return (voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
diff -druN linux-noipsec/net/ipsec/zlib/zutil.h linux/net/ipsec/zlib/zutil.h
--- linux-noipsec/net/ipsec/zlib/zutil.h	Thu Jan  1 01:00:00 1970
+++ linux/net/ipsec/zlib/zutil.h	Fri Sep 29 20:51:34 2000
@@ -0,0 +1,223 @@
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-1998 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef _Z_UTIL_H
+#define _Z_UTIL_H
+
+#include "zlib.h"
+
+#include <linux/string.h>
+#define HAVE_MEMCPY
+
+#if 0 // #ifdef STDC
+#  include <stddef.h>
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#ifdef NO_ERRNO_H
+    extern int errno;
+#else
+#   include <errno.h>
+#endif
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#ifdef MSDOS
+#  define OS_CODE  0x00
+#  if defined(__TURBOC__) || defined(__BORLANDC__)
+#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
+       /* Allow compilation with ANSI keywords only enabled */
+       void _Cdecl farfree( void *block );
+       void *_Cdecl farmalloc( unsigned long nbytes );
+#    else
+#     include <alloc.h>
+#    endif
+#  else /* MSC or DJGPP */
+#    include <malloc.h>
+#  endif
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#endif
+
+#ifdef WIN32 /* Window 95 & Windows NT */
+#  define OS_CODE  0x0b
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define F_OPEN(name, mode) \
+     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#if defined(MACOS) || defined(TARGET_OS_MAC)
+#  define OS_CODE  0x07
+#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
+#    include <unix.h> /* for fdopen */
+#  else
+#    ifndef fdopen
+#      define fdopen(fd,mode) NULL /* No fdopen() */
+#    endif
+#  endif
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0F
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+#if (defined(_MSC_VER) && (_MSC_VER > 600))
+#  define fdopen(fd,type)  _fdopen(fd,type)
+#endif
+
+
+        /* Common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef F_OPEN
+#  define F_OPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#ifdef HAVE_STRERROR
+   extern char *strerror OF((int));
+#  define zstrerror(errnum) strerror(errnum)
+#else
+#  define zstrerror(errnum) ""
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
+ /* Use our own functions for small and medium model with MSC <= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  * The __SC__ check is for Symantec.
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
+   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
+   extern void zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  include <stdio.h>
+   extern int z_verbose;
+   extern void z_error    OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
+				       uInt len));
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void   zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* _Z_UTIL_H */
diff -druN linux-noipsec/net/ipv4/af_inet.c linux/net/ipv4/af_inet.c
--- linux-noipsec/net/ipv4/af_inet.c	Fri Dec 15 15:15:47 2000
+++ linux/net/ipv4/af_inet.c	Fri Dec 15 15:18:21 2000
@@ -1149,6 +1149,17 @@
 	ip_mr_init();
 #endif
 
+#if defined(CONFIG_IPSEC)
+	{
+               extern /* void */ int ipsec_init(void);
+		/*
+		 *  Initialise AF_INET ESP and AH protocol support including 
+		 *  e-routing and SA tables
+		 */
+		ipsec_init();
+	}
+#endif /* CONFIG_IPSEC */
+
 #ifdef CONFIG_INET_RARP
 	rarp_ioctl_hook = rarp_ioctl;
 #endif
diff -druN linux-noipsec/net/ipv4/af_inet.c.wipsec linux/net/ipv4/af_inet.c.wipsec
--- linux-noipsec/net/ipv4/af_inet.c.wipsec	Thu Jan  1 01:00:00 1970
+++ linux/net/ipv4/af_inet.c.wipsec	Fri Dec 15 15:18:21 2000
@@ -0,0 +1,1181 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		PF_INET protocol family socket handler.
+ *
+ * Version:	$Id$
+ *
+ * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Florian La Roche, <flla@stud.uni-sb.de>
+ *		Alan Cox, <A.Cox@swansea.ac.uk>
+ *
+ * Changes (see also sock.c)
+ *
+ *		A.N.Kuznetsov	:	Socket death error in accept().
+ *		John Richardson :	Fix non blocking error in connect()
+ *					so sockets that fail to connect
+ *					don't return -EINPROGRESS.
+ *		Alan Cox	:	Asynchronous I/O support
+ *		Alan Cox	:	Keep correct socket pointer on sock structures
+ *					when accept() ed
+ *		Alan Cox	:	Semantics of SO_LINGER aren't state moved
+ *					to close when you look carefully. With
+ *					this fixed and the accept bug fixed 
+ *					some RPC stuff seems happier.
+ *		Niibe Yutaka	:	4.4BSD style write async I/O
+ *		Alan Cox, 
+ *		Tony Gale 	:	Fixed reuse semantics.
+ *		Alan Cox	:	bind() shouldn't abort existing but dead
+ *					sockets. Stops FTP netin:.. I hope.
+ *		Alan Cox	:	bind() works correctly for RAW sockets. Note
+ *					that FreeBSD at least was broken in this respect
+ *					so be careful with compatibility tests...
+ *		Alan Cox	:	routing cache support
+ *		Alan Cox	:	memzero the socket structure for compactness.
+ *		Matt Day	:	nonblock connect error handler
+ *		Alan Cox	:	Allow large numbers of pending sockets
+ *					(eg for big web sites), but only if
+ *					specifically application requested.
+ *		Alan Cox	:	New buffering throughout IP. Used dumbly.
+ *		Alan Cox	:	New buffering now used smartly.
+ *		Alan Cox	:	BSD rather than common sense interpretation of
+ *					listen.
+ *		Germano Caronni	:	Assorted small races.
+ *		Alan Cox	:	sendmsg/recvmsg basic support.
+ *		Alan Cox	:	Only sendmsg/recvmsg now supported.
+ *		Alan Cox	:	Locked down bind (see security list).
+ *		Alan Cox	:	Loosened bind a little.
+ *		Mike McLagan	:	ADD/DEL DLCI Ioctls
+ *	Willy Konynenberg	:	Transparent proxying support.
+ *		David S. Miller	:	New socket lookup architecture.
+ *					Some other random speedups.
+ *		Cyrus Durgin	:	Cleaned up file for kmod hacks.
+ *		Andi Kleen	:	Fix inet_stream_connect TCP race.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <linux/sockios.h>
+#include <linux/net.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/ip.h>
+#include <net/protocol.h>
+#include <net/arp.h>
+#include <net/rarp.h>
+#include <net/route.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <net/raw.h>
+#include <net/icmp.h>
+#include <net/ipip.h>
+#include <net/inet_common.h>
+#include <linux/ip_fw.h>
+#ifdef CONFIG_IP_MROUTE
+#include <linux/mroute.h>
+#endif
+#ifdef CONFIG_IP_MASQUERADE
+#include <net/ip_masq.h>
+#endif
+#ifdef CONFIG_BRIDGE
+#include <net/br.h>
+#endif
+ 
+#ifdef CONFIG_NET_DIVERT
+#include <linux/divert.h>
+#endif /* CONFIG_NET_DIVERT */
+ 
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+#ifdef CONFIG_NET_RADIO
+#include <linux/wireless.h>
+#endif	/* CONFIG_NET_RADIO */
+
+#define min(a,b)	((a)<(b)?(a):(b))
+
+extern int raw_get_info(char *, char **, off_t, int, int);
+extern int snmp_get_info(char *, char **, off_t, int, int);
+extern int netstat_get_info(char *, char **, off_t, int, int);
+extern int afinet_get_info(char *, char **, off_t, int, int);
+extern int tcp_get_info(char *, char **, off_t, int, int);
+extern int udp_get_info(char *, char **, off_t, int, int);
+extern void ip_mc_drop_socket(struct sock *sk);
+
+#ifdef CONFIG_DLCI
+extern int dlci_ioctl(unsigned int, void*);
+#endif
+
+#ifdef CONFIG_DLCI_MODULE
+int (*dlci_ioctl_hook)(unsigned int, void *) = NULL;
+#endif
+
+int (*rarp_ioctl_hook)(unsigned int,void*) = NULL;
+
+/*
+ *	Destroy an AF_INET socket
+ */
+ 
+static __inline__ void kill_sk_queues(struct sock *sk)
+{
+	struct sk_buff *skb;
+
+	/* First the read buffer. */
+	while((skb = skb_dequeue(&sk->receive_queue)) != NULL)
+		kfree_skb(skb);
+
+	/* Next, the error queue. */
+	while((skb = skb_dequeue(&sk->error_queue)) != NULL)
+		kfree_skb(skb);
+
+  	/* Now the backlog. */
+  	while((skb=skb_dequeue(&sk->back_log)) != NULL)
+		kfree_skb(skb);
+}
+
+static __inline__ void kill_sk_now(struct sock *sk)
+{
+	/* No longer exists. */
+	del_from_prot_sklist(sk);
+
+	/* Remove from protocol hash chains. */
+	sk->prot->unhash(sk);
+
+	if(sk->opt)
+		kfree(sk->opt);
+	dst_release(sk->dst_cache);
+	sk_free(sk);
+}
+
+static __inline__ void kill_sk_later(struct sock *sk)
+{
+	/* this should never happen. */
+	/* actually it can if an ack has just been sent. */
+	/* 
+	 * It's more normal than that...
+	 * It can happen because a skb is still in the device queues
+	 * [PR]
+	 */
+		  
+	NETDEBUG(printk(KERN_DEBUG "Socket destroy delayed (r=%d w=%d)\n",
+			atomic_read(&sk->rmem_alloc),
+			atomic_read(&sk->wmem_alloc)));
+
+	sk->ack_backlog = 0;
+	release_sock(sk);
+	net_reset_timer(sk, TIME_DESTROY, SOCK_DESTROY_TIME);
+}
+
+void destroy_sock(struct sock *sk)
+{
+	lock_sock(sk);			/* just to be safe. */
+
+  	/* Now we can no longer get new packets or once the
+  	 * timers are killed, send them.
+  	 */
+  	net_delete_timer(sk);
+
+	if (sk->prot->destroy && !sk->destroy)
+		sk->prot->destroy(sk);
+
+	sk->destroy = 1;
+
+	kill_sk_queues(sk);
+
+	/* Now if everything is gone we can free the socket
+	 * structure, otherwise we need to keep it around until
+	 * everything is gone.
+	 */
+	if (atomic_read(&sk->rmem_alloc) == 0 && atomic_read(&sk->wmem_alloc) == 0)
+		kill_sk_now(sk);
+	else
+		kill_sk_later(sk);
+}
+
+/*
+ *	The routines beyond this point handle the behaviour of an AF_INET
+ *	socket object. Mostly it punts to the subprotocols of IP to do
+ *	the work.
+ */
+ 
+
+/*
+ *	Set socket options on an inet socket.
+ */
+ 
+int inet_setsockopt(struct socket *sock, int level, int optname,
+		    char *optval, int optlen)
+{
+	struct sock *sk=sock->sk;
+	if (sk->prot->setsockopt==NULL)
+		return(-EOPNOTSUPP);
+	return sk->prot->setsockopt(sk,level,optname,optval,optlen);
+}
+
+/*
+ *	Get a socket option on an AF_INET socket.
+ *
+ *	FIX: POSIX 1003.1g is very ambiguous here. It states that
+ *	asynchronous errors should be reported by getsockopt. We assume
+ *	this means if you specify SO_ERROR (otherwise whats the point of it).
+ */
+
+int inet_getsockopt(struct socket *sock, int level, int optname,
+		    char *optval, int *optlen)
+{
+	struct sock *sk=sock->sk;
+	if (sk->prot->getsockopt==NULL)
+		return(-EOPNOTSUPP);
+	return sk->prot->getsockopt(sk,level,optname,optval,optlen);
+}
+
+/*
+ *	Automatically bind an unbound socket.
+ */
+
+static int inet_autobind(struct sock *sk)
+{
+	/* We may need to bind the socket. */
+	if (sk->num == 0) {
+		if (sk->prot->get_port(sk, 0) != 0)
+			return(-EAGAIN);
+		sk->sport = htons(sk->num);
+		sk->prot->hash(sk);
+		add_to_prot_sklist(sk);
+	}
+	return 0;
+}
+
+/*
+ *	Move a socket into listening state.
+ */
+ 
+int inet_listen(struct socket *sock, int backlog)
+{
+	struct sock *sk = sock->sk;
+	unsigned char old_state;
+
+	if (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM ||
+	    !((1<<sk->state)&(TCPF_CLOSE|TCPF_LISTEN)))
+		return(-EINVAL);
+
+	if ((unsigned) backlog == 0)	/* BSDism */
+		backlog = 1;
+	if ((unsigned) backlog > SOMAXCONN)
+		backlog = SOMAXCONN;
+	sk->max_ack_backlog = backlog;
+
+	/* Really, if the socket is already in listen state
+	 * we can only allow the backlog to be adjusted.
+	 */
+	old_state = sk->state;
+	if (old_state != TCP_LISTEN) {
+		sk->state = TCP_LISTEN;
+		sk->ack_backlog = 0;
+		if (sk->num == 0) {
+			if (sk->prot->get_port(sk, 0) != 0) {
+				sk->state = old_state;
+				return -EAGAIN;
+			}
+			sk->sport = htons(sk->num);
+			add_to_prot_sklist(sk);
+		} else {
+			if (sk->prev)
+				((struct tcp_bind_bucket*)sk->prev)->fastreuse = 0;
+		}
+
+		sk->zapped = 0;
+		dst_release(xchg(&sk->dst_cache, NULL));
+		sk->prot->hash(sk);
+		sk->socket->flags |= SO_ACCEPTCON;
+	}
+	return 0;
+}
+
+/*
+ *	Create an inet socket.
+ *
+ *	FIXME: Gcc would generate much better code if we set the parameters
+ *	up in in-memory structure order. Gcc68K even more so
+ */
+
+static int inet_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+	struct proto *prot;
+
+	/* Compatibility */
+	if (sock->type == SOCK_PACKET) {
+		static int warned; 
+		if (net_families[PF_PACKET]==NULL)
+		{
+#if defined(CONFIG_KMOD) && defined(CONFIG_PACKET_MODULE)
+			char module_name[30];
+			sprintf(module_name,"net-pf-%d", PF_PACKET);
+			request_module(module_name);
+			if (net_families[PF_PACKET] == NULL)
+#endif
+			return -ESOCKTNOSUPPORT;
+		}
+		if (!warned++)
+			printk(KERN_INFO "%s uses obsolete (PF_INET,SOCK_PACKET)\n", current->comm);
+		return net_families[PF_PACKET]->create(sock, protocol);
+	}
+
+	sock->state = SS_UNCONNECTED;
+	sk = sk_alloc(PF_INET, GFP_KERNEL, 1);
+	if (sk == NULL) 
+		goto do_oom;
+
+	switch (sock->type) {
+	case SOCK_STREAM:
+		if (protocol && protocol != IPPROTO_TCP)
+			goto free_and_noproto;
+		protocol = IPPROTO_TCP;
+		if (ipv4_config.no_pmtu_disc)
+			sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		else
+			sk->ip_pmtudisc = IP_PMTUDISC_WANT;
+		prot = &tcp_prot;
+		sock->ops = &inet_stream_ops;
+		break;
+	case SOCK_SEQPACKET:
+		goto free_and_badtype;
+	case SOCK_DGRAM:
+		if (protocol && protocol != IPPROTO_UDP)
+			goto free_and_noproto;
+		protocol = IPPROTO_UDP;
+		sk->no_check = UDP_NO_CHECK;
+		sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		prot=&udp_prot;
+		sock->ops = &inet_dgram_ops;
+		break;
+	case SOCK_RAW:
+		if (!capable(CAP_NET_RAW))
+			goto free_and_badperm;
+		if (!protocol)
+			goto free_and_noproto;
+		prot = &raw_prot;
+		sk->reuse = 1;
+		sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		sk->num = protocol;
+		sock->ops = &inet_dgram_ops;
+		if (protocol == IPPROTO_RAW)
+			sk->ip_hdrincl = 1;
+		break;
+	default:
+		goto free_and_badtype;
+	}
+
+	sock_init_data(sock,sk);
+	
+	sk->destruct = NULL;
+
+	sk->zapped=0;
+#ifdef CONFIG_TCP_NAGLE_OFF
+	sk->nonagle = 1;
+#endif  
+	sk->family = PF_INET;
+	sk->protocol = protocol;
+
+	sk->prot = prot;
+	sk->backlog_rcv = prot->backlog_rcv;
+
+	sk->timer.data = (unsigned long)sk;
+	sk->timer.function = &net_timer;
+
+	sk->ip_ttl=ip_statistics.IpDefaultTTL;
+
+	sk->ip_mc_loop=1;
+	sk->ip_mc_ttl=1;
+	sk->ip_mc_index=0;
+	sk->ip_mc_list=NULL;
+	
+	if (sk->num) {
+		/* It assumes that any protocol which allows
+		 * the user to assign a number at socket
+		 * creation time automatically
+		 * shares.
+		 */
+		sk->sport = htons(sk->num);
+
+		/* Add to protocol hash chains. */
+		sk->prot->hash(sk);
+		add_to_prot_sklist(sk);
+	}
+
+	if (sk->prot->init) {
+		int err = sk->prot->init(sk);
+		if (err != 0) {
+			destroy_sock(sk);
+			return(err);
+		}
+	}
+	return(0);
+
+free_and_badtype:
+	sk_free(sk);
+	return -ESOCKTNOSUPPORT;
+
+free_and_badperm:
+	sk_free(sk);
+	return -EPERM;
+
+free_and_noproto:
+	sk_free(sk);
+	return -EPROTONOSUPPORT;
+
+do_oom:
+	return -ENOBUFS;
+}
+
+
+/*
+ *	The peer socket should always be NULL (or else). When we call this
+ *	function we are destroying the object and from then on nobody
+ *	should refer to it.
+ */
+ 
+int inet_release(struct socket *sock, struct socket *peersock)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk) {
+		long timeout;
+
+		/* Begin closedown and wake up sleepers. */
+		if (sock->state != SS_UNCONNECTED)
+			sock->state = SS_DISCONNECTING;
+		sk->state_change(sk);
+
+		/* Applications forget to leave groups before exiting */
+		ip_mc_drop_socket(sk);
+
+		/* If linger is set, we don't return until the close
+		 * is complete.  Otherwise we return immediately. The
+		 * actually closing is done the same either way.
+		 *
+		 * If the close is due to the process exiting, we never
+		 * linger..
+		 */
+		timeout = 0;
+		if (sk->linger && !(current->flags & PF_EXITING)) {
+			timeout = HZ * sk->lingertime;
+			if (!timeout)
+				timeout = MAX_SCHEDULE_TIMEOUT;
+		}
+		sock->sk = NULL;
+		sk->socket = NULL;
+		sk->prot->close(sk, timeout);
+	}
+	return(0);
+}
+
+static int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sockaddr_in *addr=(struct sockaddr_in *)uaddr;
+	struct sock *sk=sock->sk;
+	unsigned short snum;
+	int chk_addr_ret;
+
+	/* If the socket has its own bind function then use it. (RAW) */
+	if(sk->prot->bind)
+		return sk->prot->bind(sk, uaddr, addr_len);
+		
+	/* Check these errors (active socket, bad address length, double bind). */
+	if ((sk->state != TCP_CLOSE)			||
+	    (addr_len < sizeof(struct sockaddr_in))	||
+	    (sk->num != 0))
+		return -EINVAL;
+		
+	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	if (addr->sin_addr.s_addr != 0 && chk_addr_ret != RTN_LOCAL &&
+	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST) {
+#ifdef CONFIG_IP_TRANSPARENT_PROXY
+		/* Superuser may bind to any address to allow transparent proxying. */
+		if(chk_addr_ret != RTN_UNICAST || !capable(CAP_NET_ADMIN))
+#endif
+			return -EADDRNOTAVAIL;	/* Source address MUST be ours! */
+	}
+
+	/*      We keep a pair of addresses. rcv_saddr is the one
+	 *      used by hash lookups, and saddr is used for transmit.
+	 *
+	 *      In the BSD API these are the same except where it
+	 *      would be illegal to use them (multicast/broadcast) in
+	 *      which case the sending device address is used.
+	 */
+	sk->rcv_saddr = sk->saddr = addr->sin_addr.s_addr;
+	if(chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
+		sk->saddr = 0;  /* Use device */
+
+	snum = ntohs(addr->sin_port);
+#ifdef CONFIG_IP_MASQUERADE
+	/* The kernel masquerader needs some ports. */
+	if((snum >= PORT_MASQ_BEGIN) && (snum <= PORT_MASQ_END) && 
+	   chk_addr_ret != RTN_MULTICAST)
+		return -EADDRINUSE;
+#endif		 
+	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))
+		return(-EACCES);
+	
+	/* Make sure we are allowed to bind here. */
+	if (sk->prot->get_port(sk, snum) != 0)
+		return -EADDRINUSE;
+
+	sk->zapped = 0;
+	sk->sport = htons(sk->num);
+	sk->daddr = 0;
+	sk->dport = 0;
+	sk->prot->hash(sk);
+	add_to_prot_sklist(sk);
+	dst_release(sk->dst_cache);
+	sk->dst_cache=NULL;
+	return(0);
+}
+
+int inet_dgram_connect(struct socket *sock, struct sockaddr * uaddr,
+		       int addr_len, int flags)
+{
+	struct sock *sk=sock->sk;
+	int err;
+
+	if (inet_autobind(sk) != 0)
+		return(-EAGAIN);
+	if (sk->prot->connect == NULL) 
+		return(-EOPNOTSUPP);
+	err = sk->prot->connect(sk, (struct sockaddr *)uaddr, addr_len);
+	if (err < 0) 
+		return(err);
+	return(0);
+}
+
+static void inet_wait_for_connect(struct sock *sk)
+{
+	struct wait_queue wait = { current, NULL };
+
+	add_wait_queue(sk->sleep, &wait);
+	current->state = TASK_INTERRUPTIBLE;
+	while (sk->state == TCP_SYN_SENT || sk->state == TCP_SYN_RECV) {
+		if (signal_pending(current))
+			break;
+		if (sk->err)
+			break;
+		schedule();
+		current->state = TASK_INTERRUPTIBLE;
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(sk->sleep, &wait);
+}
+
+/*
+ *	Connect to a remote host. There is regrettably still a little
+ *	TCP 'magic' in here.
+ */
+ 
+int inet_stream_connect(struct socket *sock, struct sockaddr * uaddr,
+			int addr_len, int flags)
+{
+	struct sock *sk=sock->sk;
+	int err;
+
+	if(sock->state != SS_UNCONNECTED && sock->state != SS_CONNECTING) {
+		if(sock->state == SS_CONNECTED)
+			return -EISCONN;
+		return -EINVAL;
+	}
+
+	if(sock->state == SS_CONNECTING) {
+		/* Note: tcp_connected contains SYN_RECV, which may cause
+		   bogus results here. -AK */ 
+		if(tcp_connected(sk->state)) {
+			sock->state = SS_CONNECTED;
+			return 0;
+		}
+		if (sk->zapped || sk->err)
+			goto sock_error;
+		if (flags & O_NONBLOCK)
+			return -EALREADY;
+	} else {
+		if (sk->prot->connect == NULL) 
+			return(-EOPNOTSUPP);
+
+		/* We may need to bind the socket. */
+		if (inet_autobind(sk) != 0)
+			return(-EAGAIN);
+
+		sk->zapped = 0;
+		err = sk->prot->connect(sk, uaddr, addr_len);
+		/* Note: there is a theoretical race here when an wake up
+		   occurred before inet_wait_for_connect is entered. In 2.3
+		   the wait queue setup should be moved before the low level
+		   connect call. -AK*/
+		if (err < 0)
+			return(err);
+  		sock->state = SS_CONNECTING;
+	}
+	
+	if (sk->state > TCP_FIN_WAIT2 && sock->state == SS_CONNECTING)
+		goto sock_error;
+
+	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) 
+	  	return (-EINPROGRESS);
+
+	if (sk->state == TCP_SYN_SENT || sk->state == TCP_SYN_RECV) {
+		inet_wait_for_connect(sk);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+
+	sock->state = SS_CONNECTED;
+	if ((sk->state != TCP_ESTABLISHED) && sk->err)
+		goto sock_error; 
+	return(0);
+
+sock_error:	
+	/* This is ugly but needed to fix a race in the ICMP error handler */
+	if (sk->zapped && sk->state != TCP_CLOSE) { 
+		lock_sock(sk);  
+		tcp_set_state(sk, TCP_CLOSE);
+		release_sock(sk); 
+		sk->zapped = 0;
+	}
+	sock->state = SS_UNCONNECTED;
+	return sock_error(sk);
+}
+
+/*
+ *	Accept a pending connection. The TCP layer now gives BSD semantics.
+ */
+
+int inet_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk1 = sock->sk, *sk2;
+	struct sock *newsk = newsock->sk;
+	int err = -EINVAL;
+
+	if (sock->state != SS_UNCONNECTED || !(sock->flags & SO_ACCEPTCON))
+		goto do_err;
+
+	err = -EOPNOTSUPP;
+	if (sk1->prot->accept == NULL)
+		goto do_err;
+
+	if((sk2 = sk1->prot->accept(sk1,flags)) == NULL)
+		goto do_sk1_err;
+
+	/*
+	 *	We've been passed an extra socket.
+	 *	We need to free it up because the tcp module creates
+	 *	its own when it accepts one.
+	 */
+	sk2->sleep = newsk->sleep;
+
+	newsock->sk = sk2;
+	sk2->socket = newsock;
+	newsk->socket = NULL;
+
+	if(sk2->state == TCP_ESTABLISHED)
+		goto do_full_success;
+	if(sk2->err > 0)
+		goto do_connect_err;
+	err = -ECONNABORTED;
+	if (sk2->state == TCP_CLOSE)
+		goto do_bad_connection;
+do_full_success:
+	destroy_sock(newsk);
+	newsock->state = SS_CONNECTED;
+	return 0;
+
+do_connect_err:
+	err = sock_error(sk2);
+do_bad_connection:
+	sk2->sleep = NULL;
+	sk2->socket = NULL;
+	destroy_sock(sk2);
+	newsock->sk = newsk;
+	newsk->socket = newsock;
+	return err;
+
+do_sk1_err:
+	err = sock_error(sk1);
+do_err:
+	return err;
+}
+
+
+/*
+ *	This does both peername and sockname.
+ */
+ 
+static int inet_getname(struct socket *sock, struct sockaddr *uaddr,
+		 int *uaddr_len, int peer)
+{
+	struct sock *sk		= sock->sk;
+	struct sockaddr_in *sin	= (struct sockaddr_in *)uaddr;
+  
+	sin->sin_family = AF_INET;
+	if (peer) {
+		if (!tcp_connected(sk->state)) 
+			return(-ENOTCONN);
+		sin->sin_port = sk->dport;
+		sin->sin_addr.s_addr = sk->daddr;
+	} else {
+		__u32 addr = sk->rcv_saddr;
+		if (!addr)
+			addr = sk->saddr;
+		sin->sin_port = sk->sport;
+		sin->sin_addr.s_addr = addr;
+	}
+	*uaddr_len = sizeof(*sin);
+	return(0);
+}
+
+
+
+int inet_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+		 int flags, struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+	int addr_len = 0;
+	int err;
+	
+	if (sock->flags & SO_ACCEPTCON)
+		return(-EINVAL);
+	if (sk->prot->recvmsg == NULL) 
+		return(-EOPNOTSUPP);
+	/* We may need to bind the socket. */
+	if (inet_autobind(sk) != 0)
+		return(-EAGAIN);
+	err = sk->prot->recvmsg(sk, msg, size, flags&MSG_DONTWAIT,
+				flags&~MSG_DONTWAIT, &addr_len);
+	if (err >= 0)
+		msg->msg_namelen = addr_len;
+	return err;
+}
+
+
+int inet_sendmsg(struct socket *sock, struct msghdr *msg, int size,
+		 struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk->shutdown & SEND_SHUTDOWN) {
+		if (!(msg->msg_flags&MSG_NOSIGNAL))
+			send_sig(SIGPIPE, current, 1);
+		return(-EPIPE);
+	}
+	if (sk->prot->sendmsg == NULL) 
+		return(-EOPNOTSUPP);
+	if(sk->err)
+		return sock_error(sk);
+
+	/* We may need to bind the socket. */
+	if (inet_autobind(sk) != 0)
+		return -EAGAIN;
+
+	return sk->prot->sendmsg(sk, msg, size);
+}
+
+
+int inet_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+
+	/* This should really check to make sure
+	 * the socket is a TCP socket. (WHY AC...)
+	 */
+	how++; /* maps 0->1 has the advantage of making bit 1 rcvs and
+		       1->2 bit 2 snds.
+		       2->3 */
+	if ((how & ~SHUTDOWN_MASK) || how==0)	/* MAXINT->0 */
+		return(-EINVAL);
+	if (!sk)
+		return(-ENOTCONN);
+	if (sock->state == SS_CONNECTING && sk->state == TCP_ESTABLISHED)
+		sock->state = SS_CONNECTED;
+	if (!tcp_connected(sk->state)) 
+		return(-ENOTCONN);
+	sk->shutdown |= how;
+	if (sk->prot->shutdown)
+		sk->prot->shutdown(sk, how);
+	/* Wake up anyone sleeping in poll. */
+	sk->state_change(sk);
+	return(0);
+}
+
+
+unsigned int inet_poll(struct file * file, struct socket *sock, poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk->prot->poll == NULL)
+		return(0);
+	return sk->prot->poll(file, sock, wait);
+}
+
+/*
+ *	ioctl() calls you can issue on an INET socket. Most of these are
+ *	device configuration and stuff and very rarely used. Some ioctls
+ *	pass on to the socket itself.
+ *
+ *	NOTE: I like the idea of a module for the config stuff. ie ifconfig
+ *	loads the devconfigure module does its configuring and unloads it.
+ *	There's a good 20K of config code hanging around the kernel.
+ */
+
+static int inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	struct sock *sk = sock->sk;
+	int err;
+	int pid;
+
+	switch(cmd) 
+	{
+		case FIOSETOWN:
+		case SIOCSPGRP:
+			err = get_user(pid, (int *) arg);
+			if (err)
+				return err; 
+			if (current->pid != pid && current->pgrp != -pid && 
+			    !capable(CAP_NET_ADMIN))
+				return -EPERM;
+			sk->proc = pid;
+			return(0);
+		case FIOGETOWN:
+		case SIOCGPGRP:
+			return put_user(sk->proc, (int *)arg);
+		case SIOCGSTAMP:
+			if(sk->stamp.tv_sec==0)
+				return -ENOENT;
+			err = copy_to_user((void *)arg,&sk->stamp,sizeof(struct timeval));
+			if (err)
+				err = -EFAULT;
+			return err;
+		case SIOCADDRT:
+		case SIOCDELRT:
+		case SIOCRTMSG:
+			return(ip_rt_ioctl(cmd,(void *) arg));
+		case SIOCDARP:
+		case SIOCGARP:
+		case SIOCSARP:
+			return(arp_ioctl(cmd,(void *) arg));
+		case SIOCDRARP:
+		case SIOCGRARP:
+		case SIOCSRARP:
+#ifdef CONFIG_KMOD
+			if (rarp_ioctl_hook == NULL)
+				request_module("rarp");
+#endif
+			if (rarp_ioctl_hook != NULL)
+				return(rarp_ioctl_hook(cmd,(void *) arg));
+		case SIOCGIFADDR:
+		case SIOCSIFADDR:
+		case SIOCGIFBRDADDR:
+		case SIOCSIFBRDADDR:
+		case SIOCGIFNETMASK:
+		case SIOCSIFNETMASK:
+		case SIOCGIFDSTADDR:
+		case SIOCSIFDSTADDR:
+		case SIOCSIFPFLAGS:	
+		case SIOCGIFPFLAGS:	
+		case SIOCSIFFLAGS:
+			return(devinet_ioctl(cmd,(void *) arg));
+		case SIOCGIFBR:
+		case SIOCSIFBR:
+#ifdef CONFIG_BRIDGE		
+			return(br_ioctl(cmd,(void *) arg));
+#else
+			return -ENOPKG;
+#endif						
+			
+		case SIOCGIFDIVERT:
+		case SIOCSIFDIVERT:
+#ifdef CONFIG_NET_DIVERT
+			return(divert_ioctl(cmd, (struct divert_cf *) arg));
+#else
+			return -ENOPKG;
+#endif	/* CONFIG_NET_DIVERT */
+
+		case SIOCADDDLCI:
+		case SIOCDELDLCI:
+#ifdef CONFIG_DLCI
+			return(dlci_ioctl(cmd, (void *) arg));
+#endif
+
+#ifdef CONFIG_DLCI_MODULE
+
+#ifdef CONFIG_KMOD
+			if (dlci_ioctl_hook == NULL)
+				request_module("dlci");
+#endif
+
+			if (dlci_ioctl_hook)
+				return((*dlci_ioctl_hook)(cmd, (void *) arg));
+#endif
+			return -ENOPKG;
+
+		default:
+			if ((cmd >= SIOCDEVPRIVATE) &&
+			    (cmd <= (SIOCDEVPRIVATE + 15)))
+				return(dev_ioctl(cmd,(void *) arg));
+
+#ifdef CONFIG_NET_RADIO
+			if((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST))
+				return(dev_ioctl(cmd,(void *) arg));
+#endif
+
+			if (sk->prot->ioctl==NULL || (err=sk->prot->ioctl(sk, cmd, arg))==-ENOIOCTLCMD)
+				return(dev_ioctl(cmd,(void *) arg));		
+			return err;
+	}
+	/*NOTREACHED*/
+	return(0);
+}
+
+struct proto_ops inet_stream_ops = {
+	PF_INET,
+
+	sock_no_dup,
+	inet_release,
+	inet_bind,
+	inet_stream_connect,
+	sock_no_socketpair,
+	inet_accept,
+	inet_getname, 
+	inet_poll,
+	inet_ioctl,
+	inet_listen,
+	inet_shutdown,
+	inet_setsockopt,
+	inet_getsockopt,
+	sock_no_fcntl,
+	inet_sendmsg,
+	inet_recvmsg
+};
+
+struct proto_ops inet_dgram_ops = {
+	PF_INET,
+
+	sock_no_dup,
+	inet_release,
+	inet_bind,
+	inet_dgram_connect,
+	sock_no_socketpair,
+	sock_no_accept,
+	inet_getname, 
+	datagram_poll,
+	inet_ioctl,
+	sock_no_listen,
+	inet_shutdown,
+	inet_setsockopt,
+	inet_getsockopt,
+	sock_no_fcntl,
+	inet_sendmsg,
+	inet_recvmsg
+};
+
+struct net_proto_family inet_family_ops = {
+	PF_INET,
+	inet_create
+};
+
+
+#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_INET_RARP
+static struct proc_dir_entry proc_net_rarp = {
+	PROC_NET_RARP, 4, "rarp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	rarp_get_info
+};
+#endif		/* RARP */
+static struct proc_dir_entry proc_net_raw = {
+	PROC_NET_RAW, 3, "raw",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	raw_get_info
+};
+static struct proc_dir_entry proc_net_netstat = {
+	PROC_NET_NETSTAT, 7, "netstat",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	netstat_get_info
+};
+static struct proc_dir_entry proc_net_snmp = {
+	PROC_NET_SNMP, 4, "snmp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	snmp_get_info
+};
+static struct proc_dir_entry proc_net_sockstat = {
+	PROC_NET_SOCKSTAT, 8, "sockstat",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	afinet_get_info
+};
+static struct proc_dir_entry proc_net_tcp = {
+	PROC_NET_TCP, 3, "tcp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	tcp_get_info
+};
+static struct proc_dir_entry proc_net_udp = {
+	PROC_NET_UDP, 3, "udp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	udp_get_info
+};
+#endif		/* CONFIG_PROC_FS */
+
+extern void tcp_init(void);
+extern void tcp_v4_init(struct net_proto_family *);
+
+
+/*
+ *	Called by socket.c on kernel startup.  
+ */
+ 
+__initfunc(void inet_proto_init(struct net_proto *pro))
+{
+	struct sk_buff *dummy_skb;
+	struct inet_protocol *p;
+
+	printk(KERN_INFO "NET4: Linux TCP/IP 1.0 for NET4.0\n");
+
+	if (sizeof(struct inet_skb_parm) > sizeof(dummy_skb->cb))
+	{
+		printk(KERN_CRIT "inet_proto_init: panic\n");
+		return;
+	}
+
+	/*
+	 *	Tell SOCKET that we are alive... 
+	 */
+   
+  	(void) sock_register(&inet_family_ops);
+
+	/*
+	 *	Add all the protocols. 
+	 */
+
+	printk(KERN_INFO "IP Protocols: ");
+	for(p = inet_protocol_base; p != NULL;) 
+	{
+		struct inet_protocol *tmp = (struct inet_protocol *) p->next;
+		inet_add_protocol(p);
+		printk("%s%s",p->name,tmp?", ":"\n");
+		p = tmp;
+	}
+
+	/*
+	 *	Set the ARP module up
+	 */
+
+	arp_init();
+
+  	/*
+  	 *	Set the IP module up
+  	 */
+
+	ip_init();
+
+	tcp_v4_init(&inet_family_ops);
+
+	/* Setup TCP slab cache for open requests. */
+	tcp_init();
+
+
+	/*
+	 *	Set the ICMP layer up
+	 */
+
+	icmp_init(&inet_family_ops);
+
+	/* I wish inet_add_protocol had no constructor hook...
+	   I had to move IPIP from net/ipv4/protocol.c :-( --ANK
+	 */
+#ifdef CONFIG_NET_IPIP
+	ipip_init();
+#endif
+#ifdef CONFIG_NET_IPGRE
+	ipgre_init();
+#endif
+
+	/*
+	 *	Set the firewalling up
+	 */
+#if defined(CONFIG_IP_FIREWALL)
+	ip_fw_init();
+#endif
+
+#ifdef CONFIG_IP_MASQUERADE
+	ip_masq_init();
+#endif
+	
+	/*
+	 *	Initialise the multicast router
+	 */
+#if defined(CONFIG_IP_MROUTE)
+	ip_mr_init();
+#endif
+
+#if defined(CONFIG_IPSEC)
+	{
+               extern /* void */ int ipsec_init(void);
+		/*
+		 *  Initialise AF_INET ESP and AH protocol support including 
+		 *  e-routing and SA tables
+		 */
+		ipsec_init();
+	}
+#endif /* CONFIG_IPSEC */
+
+#ifdef CONFIG_INET_RARP
+	rarp_ioctl_hook = rarp_ioctl;
+#endif
+	/*
+	 *	Create all the /proc entries.
+	 */
+
+#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_INET_RARP
+	proc_net_register(&proc_net_rarp);
+#endif		/* RARP */
+	proc_net_register(&proc_net_raw);
+	proc_net_register(&proc_net_snmp);
+	proc_net_register(&proc_net_netstat);
+	proc_net_register(&proc_net_sockstat);
+	proc_net_register(&proc_net_tcp);
+	proc_net_register(&proc_net_udp);
+#endif		/* CONFIG_PROC_FS */
+}
diff -druN linux-noipsec/net/ipv4/af_inet.c~ linux/net/ipv4/af_inet.c~
--- linux-noipsec/net/ipv4/af_inet.c~	Thu Jan  1 01:00:00 1970
+++ linux/net/ipv4/af_inet.c~	Mon Dec 11 01:49:44 2000
@@ -0,0 +1,1170 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		PF_INET protocol family socket handler.
+ *
+ * Version:	$Id$
+ *
+ * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Florian La Roche, <flla@stud.uni-sb.de>
+ *		Alan Cox, <A.Cox@swansea.ac.uk>
+ *
+ * Changes (see also sock.c)
+ *
+ *		A.N.Kuznetsov	:	Socket death error in accept().
+ *		John Richardson :	Fix non blocking error in connect()
+ *					so sockets that fail to connect
+ *					don't return -EINPROGRESS.
+ *		Alan Cox	:	Asynchronous I/O support
+ *		Alan Cox	:	Keep correct socket pointer on sock structures
+ *					when accept() ed
+ *		Alan Cox	:	Semantics of SO_LINGER aren't state moved
+ *					to close when you look carefully. With
+ *					this fixed and the accept bug fixed 
+ *					some RPC stuff seems happier.
+ *		Niibe Yutaka	:	4.4BSD style write async I/O
+ *		Alan Cox, 
+ *		Tony Gale 	:	Fixed reuse semantics.
+ *		Alan Cox	:	bind() shouldn't abort existing but dead
+ *					sockets. Stops FTP netin:.. I hope.
+ *		Alan Cox	:	bind() works correctly for RAW sockets. Note
+ *					that FreeBSD at least was broken in this respect
+ *					so be careful with compatibility tests...
+ *		Alan Cox	:	routing cache support
+ *		Alan Cox	:	memzero the socket structure for compactness.
+ *		Matt Day	:	nonblock connect error handler
+ *		Alan Cox	:	Allow large numbers of pending sockets
+ *					(eg for big web sites), but only if
+ *					specifically application requested.
+ *		Alan Cox	:	New buffering throughout IP. Used dumbly.
+ *		Alan Cox	:	New buffering now used smartly.
+ *		Alan Cox	:	BSD rather than common sense interpretation of
+ *					listen.
+ *		Germano Caronni	:	Assorted small races.
+ *		Alan Cox	:	sendmsg/recvmsg basic support.
+ *		Alan Cox	:	Only sendmsg/recvmsg now supported.
+ *		Alan Cox	:	Locked down bind (see security list).
+ *		Alan Cox	:	Loosened bind a little.
+ *		Mike McLagan	:	ADD/DEL DLCI Ioctls
+ *	Willy Konynenberg	:	Transparent proxying support.
+ *		David S. Miller	:	New socket lookup architecture.
+ *					Some other random speedups.
+ *		Cyrus Durgin	:	Cleaned up file for kmod hacks.
+ *		Andi Kleen	:	Fix inet_stream_connect TCP race.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <linux/sockios.h>
+#include <linux/net.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/ip.h>
+#include <net/protocol.h>
+#include <net/arp.h>
+#include <net/rarp.h>
+#include <net/route.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <net/raw.h>
+#include <net/icmp.h>
+#include <net/ipip.h>
+#include <net/inet_common.h>
+#include <linux/ip_fw.h>
+#ifdef CONFIG_IP_MROUTE
+#include <linux/mroute.h>
+#endif
+#ifdef CONFIG_IP_MASQUERADE
+#include <net/ip_masq.h>
+#endif
+#ifdef CONFIG_BRIDGE
+#include <net/br.h>
+#endif
+ 
+#ifdef CONFIG_NET_DIVERT
+#include <linux/divert.h>
+#endif /* CONFIG_NET_DIVERT */
+ 
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+#ifdef CONFIG_NET_RADIO
+#include <linux/wireless.h>
+#endif	/* CONFIG_NET_RADIO */
+
+#define min(a,b)	((a)<(b)?(a):(b))
+
+extern int raw_get_info(char *, char **, off_t, int, int);
+extern int snmp_get_info(char *, char **, off_t, int, int);
+extern int netstat_get_info(char *, char **, off_t, int, int);
+extern int afinet_get_info(char *, char **, off_t, int, int);
+extern int tcp_get_info(char *, char **, off_t, int, int);
+extern int udp_get_info(char *, char **, off_t, int, int);
+extern void ip_mc_drop_socket(struct sock *sk);
+
+#ifdef CONFIG_DLCI
+extern int dlci_ioctl(unsigned int, void*);
+#endif
+
+#ifdef CONFIG_DLCI_MODULE
+int (*dlci_ioctl_hook)(unsigned int, void *) = NULL;
+#endif
+
+int (*rarp_ioctl_hook)(unsigned int,void*) = NULL;
+
+/*
+ *	Destroy an AF_INET socket
+ */
+ 
+static __inline__ void kill_sk_queues(struct sock *sk)
+{
+	struct sk_buff *skb;
+
+	/* First the read buffer. */
+	while((skb = skb_dequeue(&sk->receive_queue)) != NULL)
+		kfree_skb(skb);
+
+	/* Next, the error queue. */
+	while((skb = skb_dequeue(&sk->error_queue)) != NULL)
+		kfree_skb(skb);
+
+  	/* Now the backlog. */
+  	while((skb=skb_dequeue(&sk->back_log)) != NULL)
+		kfree_skb(skb);
+}
+
+static __inline__ void kill_sk_now(struct sock *sk)
+{
+	/* No longer exists. */
+	del_from_prot_sklist(sk);
+
+	/* Remove from protocol hash chains. */
+	sk->prot->unhash(sk);
+
+	if(sk->opt)
+		kfree(sk->opt);
+	dst_release(sk->dst_cache);
+	sk_free(sk);
+}
+
+static __inline__ void kill_sk_later(struct sock *sk)
+{
+	/* this should never happen. */
+	/* actually it can if an ack has just been sent. */
+	/* 
+	 * It's more normal than that...
+	 * It can happen because a skb is still in the device queues
+	 * [PR]
+	 */
+		  
+	NETDEBUG(printk(KERN_DEBUG "Socket destroy delayed (r=%d w=%d)\n",
+			atomic_read(&sk->rmem_alloc),
+			atomic_read(&sk->wmem_alloc)));
+
+	sk->ack_backlog = 0;
+	release_sock(sk);
+	net_reset_timer(sk, TIME_DESTROY, SOCK_DESTROY_TIME);
+}
+
+void destroy_sock(struct sock *sk)
+{
+	lock_sock(sk);			/* just to be safe. */
+
+  	/* Now we can no longer get new packets or once the
+  	 * timers are killed, send them.
+  	 */
+  	net_delete_timer(sk);
+
+	if (sk->prot->destroy && !sk->destroy)
+		sk->prot->destroy(sk);
+
+	sk->destroy = 1;
+
+	kill_sk_queues(sk);
+
+	/* Now if everything is gone we can free the socket
+	 * structure, otherwise we need to keep it around until
+	 * everything is gone.
+	 */
+	if (atomic_read(&sk->rmem_alloc) == 0 && atomic_read(&sk->wmem_alloc) == 0)
+		kill_sk_now(sk);
+	else
+		kill_sk_later(sk);
+}
+
+/*
+ *	The routines beyond this point handle the behaviour of an AF_INET
+ *	socket object. Mostly it punts to the subprotocols of IP to do
+ *	the work.
+ */
+ 
+
+/*
+ *	Set socket options on an inet socket.
+ */
+ 
+int inet_setsockopt(struct socket *sock, int level, int optname,
+		    char *optval, int optlen)
+{
+	struct sock *sk=sock->sk;
+	if (sk->prot->setsockopt==NULL)
+		return(-EOPNOTSUPP);
+	return sk->prot->setsockopt(sk,level,optname,optval,optlen);
+}
+
+/*
+ *	Get a socket option on an AF_INET socket.
+ *
+ *	FIX: POSIX 1003.1g is very ambiguous here. It states that
+ *	asynchronous errors should be reported by getsockopt. We assume
+ *	this means if you specify SO_ERROR (otherwise whats the point of it).
+ */
+
+int inet_getsockopt(struct socket *sock, int level, int optname,
+		    char *optval, int *optlen)
+{
+	struct sock *sk=sock->sk;
+	if (sk->prot->getsockopt==NULL)
+		return(-EOPNOTSUPP);
+	return sk->prot->getsockopt(sk,level,optname,optval,optlen);
+}
+
+/*
+ *	Automatically bind an unbound socket.
+ */
+
+static int inet_autobind(struct sock *sk)
+{
+	/* We may need to bind the socket. */
+	if (sk->num == 0) {
+		if (sk->prot->get_port(sk, 0) != 0)
+			return(-EAGAIN);
+		sk->sport = htons(sk->num);
+		sk->prot->hash(sk);
+		add_to_prot_sklist(sk);
+	}
+	return 0;
+}
+
+/*
+ *	Move a socket into listening state.
+ */
+ 
+int inet_listen(struct socket *sock, int backlog)
+{
+	struct sock *sk = sock->sk;
+	unsigned char old_state;
+
+	if (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM ||
+	    !((1<<sk->state)&(TCPF_CLOSE|TCPF_LISTEN)))
+		return(-EINVAL);
+
+	if ((unsigned) backlog == 0)	/* BSDism */
+		backlog = 1;
+	if ((unsigned) backlog > SOMAXCONN)
+		backlog = SOMAXCONN;
+	sk->max_ack_backlog = backlog;
+
+	/* Really, if the socket is already in listen state
+	 * we can only allow the backlog to be adjusted.
+	 */
+	old_state = sk->state;
+	if (old_state != TCP_LISTEN) {
+		sk->state = TCP_LISTEN;
+		sk->ack_backlog = 0;
+		if (sk->num == 0) {
+			if (sk->prot->get_port(sk, 0) != 0) {
+				sk->state = old_state;
+				return -EAGAIN;
+			}
+			sk->sport = htons(sk->num);
+			add_to_prot_sklist(sk);
+		} else {
+			if (sk->prev)
+				((struct tcp_bind_bucket*)sk->prev)->fastreuse = 0;
+		}
+
+		sk->zapped = 0;
+		dst_release(xchg(&sk->dst_cache, NULL));
+		sk->prot->hash(sk);
+		sk->socket->flags |= SO_ACCEPTCON;
+	}
+	return 0;
+}
+
+/*
+ *	Create an inet socket.
+ *
+ *	FIXME: Gcc would generate much better code if we set the parameters
+ *	up in in-memory structure order. Gcc68K even more so
+ */
+
+static int inet_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+	struct proto *prot;
+
+	/* Compatibility */
+	if (sock->type == SOCK_PACKET) {
+		static int warned; 
+		if (net_families[PF_PACKET]==NULL)
+		{
+#if defined(CONFIG_KMOD) && defined(CONFIG_PACKET_MODULE)
+			char module_name[30];
+			sprintf(module_name,"net-pf-%d", PF_PACKET);
+			request_module(module_name);
+			if (net_families[PF_PACKET] == NULL)
+#endif
+			return -ESOCKTNOSUPPORT;
+		}
+		if (!warned++)
+			printk(KERN_INFO "%s uses obsolete (PF_INET,SOCK_PACKET)\n", current->comm);
+		return net_families[PF_PACKET]->create(sock, protocol);
+	}
+
+	sock->state = SS_UNCONNECTED;
+	sk = sk_alloc(PF_INET, GFP_KERNEL, 1);
+	if (sk == NULL) 
+		goto do_oom;
+
+	switch (sock->type) {
+	case SOCK_STREAM:
+		if (protocol && protocol != IPPROTO_TCP)
+			goto free_and_noproto;
+		protocol = IPPROTO_TCP;
+		if (ipv4_config.no_pmtu_disc)
+			sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		else
+			sk->ip_pmtudisc = IP_PMTUDISC_WANT;
+		prot = &tcp_prot;
+		sock->ops = &inet_stream_ops;
+		break;
+	case SOCK_SEQPACKET:
+		goto free_and_badtype;
+	case SOCK_DGRAM:
+		if (protocol && protocol != IPPROTO_UDP)
+			goto free_and_noproto;
+		protocol = IPPROTO_UDP;
+		sk->no_check = UDP_NO_CHECK;
+		sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		prot=&udp_prot;
+		sock->ops = &inet_dgram_ops;
+		break;
+	case SOCK_RAW:
+		if (!capable(CAP_NET_RAW))
+			goto free_and_badperm;
+		if (!protocol)
+			goto free_and_noproto;
+		prot = &raw_prot;
+		sk->reuse = 1;
+		sk->ip_pmtudisc = IP_PMTUDISC_DONT;
+		sk->num = protocol;
+		sock->ops = &inet_dgram_ops;
+		if (protocol == IPPROTO_RAW)
+			sk->ip_hdrincl = 1;
+		break;
+	default:
+		goto free_and_badtype;
+	}
+
+	sock_init_data(sock,sk);
+	
+	sk->destruct = NULL;
+
+	sk->zapped=0;
+#ifdef CONFIG_TCP_NAGLE_OFF
+	sk->nonagle = 1;
+#endif  
+	sk->family = PF_INET;
+	sk->protocol = protocol;
+
+	sk->prot = prot;
+	sk->backlog_rcv = prot->backlog_rcv;
+
+	sk->timer.data = (unsigned long)sk;
+	sk->timer.function = &net_timer;
+
+	sk->ip_ttl=ip_statistics.IpDefaultTTL;
+
+	sk->ip_mc_loop=1;
+	sk->ip_mc_ttl=1;
+	sk->ip_mc_index=0;
+	sk->ip_mc_list=NULL;
+	
+	if (sk->num) {
+		/* It assumes that any protocol which allows
+		 * the user to assign a number at socket
+		 * creation time automatically
+		 * shares.
+		 */
+		sk->sport = htons(sk->num);
+
+		/* Add to protocol hash chains. */
+		sk->prot->hash(sk);
+		add_to_prot_sklist(sk);
+	}
+
+	if (sk->prot->init) {
+		int err = sk->prot->init(sk);
+		if (err != 0) {
+			destroy_sock(sk);
+			return(err);
+		}
+	}
+	return(0);
+
+free_and_badtype:
+	sk_free(sk);
+	return -ESOCKTNOSUPPORT;
+
+free_and_badperm:
+	sk_free(sk);
+	return -EPERM;
+
+free_and_noproto:
+	sk_free(sk);
+	return -EPROTONOSUPPORT;
+
+do_oom:
+	return -ENOBUFS;
+}
+
+
+/*
+ *	The peer socket should always be NULL (or else). When we call this
+ *	function we are destroying the object and from then on nobody
+ *	should refer to it.
+ */
+ 
+int inet_release(struct socket *sock, struct socket *peersock)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk) {
+		long timeout;
+
+		/* Begin closedown and wake up sleepers. */
+		if (sock->state != SS_UNCONNECTED)
+			sock->state = SS_DISCONNECTING;
+		sk->state_change(sk);
+
+		/* Applications forget to leave groups before exiting */
+		ip_mc_drop_socket(sk);
+
+		/* If linger is set, we don't return until the close
+		 * is complete.  Otherwise we return immediately. The
+		 * actually closing is done the same either way.
+		 *
+		 * If the close is due to the process exiting, we never
+		 * linger..
+		 */
+		timeout = 0;
+		if (sk->linger && !(current->flags & PF_EXITING)) {
+			timeout = HZ * sk->lingertime;
+			if (!timeout)
+				timeout = MAX_SCHEDULE_TIMEOUT;
+		}
+		sock->sk = NULL;
+		sk->socket = NULL;
+		sk->prot->close(sk, timeout);
+	}
+	return(0);
+}
+
+static int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sockaddr_in *addr=(struct sockaddr_in *)uaddr;
+	struct sock *sk=sock->sk;
+	unsigned short snum;
+	int chk_addr_ret;
+
+	/* If the socket has its own bind function then use it. (RAW) */
+	if(sk->prot->bind)
+		return sk->prot->bind(sk, uaddr, addr_len);
+		
+	/* Check these errors (active socket, bad address length, double bind). */
+	if ((sk->state != TCP_CLOSE)			||
+	    (addr_len < sizeof(struct sockaddr_in))	||
+	    (sk->num != 0))
+		return -EINVAL;
+		
+	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	if (addr->sin_addr.s_addr != 0 && chk_addr_ret != RTN_LOCAL &&
+	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST) {
+#ifdef CONFIG_IP_TRANSPARENT_PROXY
+		/* Superuser may bind to any address to allow transparent proxying. */
+		if(chk_addr_ret != RTN_UNICAST || !capable(CAP_NET_ADMIN))
+#endif
+			return -EADDRNOTAVAIL;	/* Source address MUST be ours! */
+	}
+
+	/*      We keep a pair of addresses. rcv_saddr is the one
+	 *      used by hash lookups, and saddr is used for transmit.
+	 *
+	 *      In the BSD API these are the same except where it
+	 *      would be illegal to use them (multicast/broadcast) in
+	 *      which case the sending device address is used.
+	 */
+	sk->rcv_saddr = sk->saddr = addr->sin_addr.s_addr;
+	if(chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
+		sk->saddr = 0;  /* Use device */
+
+	snum = ntohs(addr->sin_port);
+#ifdef CONFIG_IP_MASQUERADE
+	/* The kernel masquerader needs some ports. */
+	if((snum >= PORT_MASQ_BEGIN) && (snum <= PORT_MASQ_END) && 
+	   chk_addr_ret != RTN_MULTICAST)
+		return -EADDRINUSE;
+#endif		 
+	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))
+		return(-EACCES);
+	
+	/* Make sure we are allowed to bind here. */
+	if (sk->prot->get_port(sk, snum) != 0)
+		return -EADDRINUSE;
+
+	sk->zapped = 0;
+	sk->sport = htons(sk->num);
+	sk->daddr = 0;
+	sk->dport = 0;
+	sk->prot->hash(sk);
+	add_to_prot_sklist(sk);
+	dst_release(sk->dst_cache);
+	sk->dst_cache=NULL;
+	return(0);
+}
+
+int inet_dgram_connect(struct socket *sock, struct sockaddr * uaddr,
+		       int addr_len, int flags)
+{
+	struct sock *sk=sock->sk;
+	int err;
+
+	if (inet_autobind(sk) != 0)
+		return(-EAGAIN);
+	if (sk->prot->connect == NULL) 
+		return(-EOPNOTSUPP);
+	err = sk->prot->connect(sk, (struct sockaddr *)uaddr, addr_len);
+	if (err < 0) 
+		return(err);
+	return(0);
+}
+
+static void inet_wait_for_connect(struct sock *sk)
+{
+	struct wait_queue wait = { current, NULL };
+
+	add_wait_queue(sk->sleep, &wait);
+	current->state = TASK_INTERRUPTIBLE;
+	while (sk->state == TCP_SYN_SENT || sk->state == TCP_SYN_RECV) {
+		if (signal_pending(current))
+			break;
+		if (sk->err)
+			break;
+		schedule();
+		current->state = TASK_INTERRUPTIBLE;
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(sk->sleep, &wait);
+}
+
+/*
+ *	Connect to a remote host. There is regrettably still a little
+ *	TCP 'magic' in here.
+ */
+ 
+int inet_stream_connect(struct socket *sock, struct sockaddr * uaddr,
+			int addr_len, int flags)
+{
+	struct sock *sk=sock->sk;
+	int err;
+
+	if(sock->state != SS_UNCONNECTED && sock->state != SS_CONNECTING) {
+		if(sock->state == SS_CONNECTED)
+			return -EISCONN;
+		return -EINVAL;
+	}
+
+	if(sock->state == SS_CONNECTING) {
+		/* Note: tcp_connected contains SYN_RECV, which may cause
+		   bogus results here. -AK */ 
+		if(tcp_connected(sk->state)) {
+			sock->state = SS_CONNECTED;
+			return 0;
+		}
+		if (sk->zapped || sk->err)
+			goto sock_error;
+		if (flags & O_NONBLOCK)
+			return -EALREADY;
+	} else {
+		if (sk->prot->connect == NULL) 
+			return(-EOPNOTSUPP);
+
+		/* We may need to bind the socket. */
+		if (inet_autobind(sk) != 0)
+			return(-EAGAIN);
+
+		sk->zapped = 0;
+		err = sk->prot->connect(sk, uaddr, addr_len);
+		/* Note: there is a theoretical race here when an wake up
+		   occurred before inet_wait_for_connect is entered. In 2.3
+		   the wait queue setup should be moved before the low level
+		   connect call. -AK*/
+		if (err < 0)
+			return(err);
+  		sock->state = SS_CONNECTING;
+	}
+	
+	if (sk->state > TCP_FIN_WAIT2 && sock->state == SS_CONNECTING)
+		goto sock_error;
+
+	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) 
+	  	return (-EINPROGRESS);
+
+	if (sk->state == TCP_SYN_SENT || sk->state == TCP_SYN_RECV) {
+		inet_wait_for_connect(sk);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+
+	sock->state = SS_CONNECTED;
+	if ((sk->state != TCP_ESTABLISHED) && sk->err)
+		goto sock_error; 
+	return(0);
+
+sock_error:	
+	/* This is ugly but needed to fix a race in the ICMP error handler */
+	if (sk->zapped && sk->state != TCP_CLOSE) { 
+		lock_sock(sk);  
+		tcp_set_state(sk, TCP_CLOSE);
+		release_sock(sk); 
+		sk->zapped = 0;
+	}
+	sock->state = SS_UNCONNECTED;
+	return sock_error(sk);
+}
+
+/*
+ *	Accept a pending connection. The TCP layer now gives BSD semantics.
+ */
+
+int inet_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk1 = sock->sk, *sk2;
+	struct sock *newsk = newsock->sk;
+	int err = -EINVAL;
+
+	if (sock->state != SS_UNCONNECTED || !(sock->flags & SO_ACCEPTCON))
+		goto do_err;
+
+	err = -EOPNOTSUPP;
+	if (sk1->prot->accept == NULL)
+		goto do_err;
+
+	if((sk2 = sk1->prot->accept(sk1,flags)) == NULL)
+		goto do_sk1_err;
+
+	/*
+	 *	We've been passed an extra socket.
+	 *	We need to free it up because the tcp module creates
+	 *	its own when it accepts one.
+	 */
+	sk2->sleep = newsk->sleep;
+
+	newsock->sk = sk2;
+	sk2->socket = newsock;
+	newsk->socket = NULL;
+
+	if(sk2->state == TCP_ESTABLISHED)
+		goto do_full_success;
+	if(sk2->err > 0)
+		goto do_connect_err;
+	err = -ECONNABORTED;
+	if (sk2->state == TCP_CLOSE)
+		goto do_bad_connection;
+do_full_success:
+	destroy_sock(newsk);
+	newsock->state = SS_CONNECTED;
+	return 0;
+
+do_connect_err:
+	err = sock_error(sk2);
+do_bad_connection:
+	sk2->sleep = NULL;
+	sk2->socket = NULL;
+	destroy_sock(sk2);
+	newsock->sk = newsk;
+	newsk->socket = newsock;
+	return err;
+
+do_sk1_err:
+	err = sock_error(sk1);
+do_err:
+	return err;
+}
+
+
+/*
+ *	This does both peername and sockname.
+ */
+ 
+static int inet_getname(struct socket *sock, struct sockaddr *uaddr,
+		 int *uaddr_len, int peer)
+{
+	struct sock *sk		= sock->sk;
+	struct sockaddr_in *sin	= (struct sockaddr_in *)uaddr;
+  
+	sin->sin_family = AF_INET;
+	if (peer) {
+		if (!tcp_connected(sk->state)) 
+			return(-ENOTCONN);
+		sin->sin_port = sk->dport;
+		sin->sin_addr.s_addr = sk->daddr;
+	} else {
+		__u32 addr = sk->rcv_saddr;
+		if (!addr)
+			addr = sk->saddr;
+		sin->sin_port = sk->sport;
+		sin->sin_addr.s_addr = addr;
+	}
+	*uaddr_len = sizeof(*sin);
+	return(0);
+}
+
+
+
+int inet_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+		 int flags, struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+	int addr_len = 0;
+	int err;
+	
+	if (sock->flags & SO_ACCEPTCON)
+		return(-EINVAL);
+	if (sk->prot->recvmsg == NULL) 
+		return(-EOPNOTSUPP);
+	/* We may need to bind the socket. */
+	if (inet_autobind(sk) != 0)
+		return(-EAGAIN);
+	err = sk->prot->recvmsg(sk, msg, size, flags&MSG_DONTWAIT,
+				flags&~MSG_DONTWAIT, &addr_len);
+	if (err >= 0)
+		msg->msg_namelen = addr_len;
+	return err;
+}
+
+
+int inet_sendmsg(struct socket *sock, struct msghdr *msg, int size,
+		 struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk->shutdown & SEND_SHUTDOWN) {
+		if (!(msg->msg_flags&MSG_NOSIGNAL))
+			send_sig(SIGPIPE, current, 1);
+		return(-EPIPE);
+	}
+	if (sk->prot->sendmsg == NULL) 
+		return(-EOPNOTSUPP);
+	if(sk->err)
+		return sock_error(sk);
+
+	/* We may need to bind the socket. */
+	if (inet_autobind(sk) != 0)
+		return -EAGAIN;
+
+	return sk->prot->sendmsg(sk, msg, size);
+}
+
+
+int inet_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+
+	/* This should really check to make sure
+	 * the socket is a TCP socket. (WHY AC...)
+	 */
+	how++; /* maps 0->1 has the advantage of making bit 1 rcvs and
+		       1->2 bit 2 snds.
+		       2->3 */
+	if ((how & ~SHUTDOWN_MASK) || how==0)	/* MAXINT->0 */
+		return(-EINVAL);
+	if (!sk)
+		return(-ENOTCONN);
+	if (sock->state == SS_CONNECTING && sk->state == TCP_ESTABLISHED)
+		sock->state = SS_CONNECTED;
+	if (!tcp_connected(sk->state)) 
+		return(-ENOTCONN);
+	sk->shutdown |= how;
+	if (sk->prot->shutdown)
+		sk->prot->shutdown(sk, how);
+	/* Wake up anyone sleeping in poll. */
+	sk->state_change(sk);
+	return(0);
+}
+
+
+unsigned int inet_poll(struct file * file, struct socket *sock, poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk->prot->poll == NULL)
+		return(0);
+	return sk->prot->poll(file, sock, wait);
+}
+
+/*
+ *	ioctl() calls you can issue on an INET socket. Most of these are
+ *	device configuration and stuff and very rarely used. Some ioctls
+ *	pass on to the socket itself.
+ *
+ *	NOTE: I like the idea of a module for the config stuff. ie ifconfig
+ *	loads the devconfigure module does its configuring and unloads it.
+ *	There's a good 20K of config code hanging around the kernel.
+ */
+
+static int inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	struct sock *sk = sock->sk;
+	int err;
+	int pid;
+
+	switch(cmd) 
+	{
+		case FIOSETOWN:
+		case SIOCSPGRP:
+			err = get_user(pid, (int *) arg);
+			if (err)
+				return err; 
+			if (current->pid != pid && current->pgrp != -pid && 
+			    !capable(CAP_NET_ADMIN))
+				return -EPERM;
+			sk->proc = pid;
+			return(0);
+		case FIOGETOWN:
+		case SIOCGPGRP:
+			return put_user(sk->proc, (int *)arg);
+		case SIOCGSTAMP:
+			if(sk->stamp.tv_sec==0)
+				return -ENOENT;
+			err = copy_to_user((void *)arg,&sk->stamp,sizeof(struct timeval));
+			if (err)
+				err = -EFAULT;
+			return err;
+		case SIOCADDRT:
+		case SIOCDELRT:
+		case SIOCRTMSG:
+			return(ip_rt_ioctl(cmd,(void *) arg));
+		case SIOCDARP:
+		case SIOCGARP:
+		case SIOCSARP:
+			return(arp_ioctl(cmd,(void *) arg));
+		case SIOCDRARP:
+		case SIOCGRARP:
+		case SIOCSRARP:
+#ifdef CONFIG_KMOD
+			if (rarp_ioctl_hook == NULL)
+				request_module("rarp");
+#endif
+			if (rarp_ioctl_hook != NULL)
+				return(rarp_ioctl_hook(cmd,(void *) arg));
+		case SIOCGIFADDR:
+		case SIOCSIFADDR:
+		case SIOCGIFBRDADDR:
+		case SIOCSIFBRDADDR:
+		case SIOCGIFNETMASK:
+		case SIOCSIFNETMASK:
+		case SIOCGIFDSTADDR:
+		case SIOCSIFDSTADDR:
+		case SIOCSIFPFLAGS:	
+		case SIOCGIFPFLAGS:	
+		case SIOCSIFFLAGS:
+			return(devinet_ioctl(cmd,(void *) arg));
+		case SIOCGIFBR:
+		case SIOCSIFBR:
+#ifdef CONFIG_BRIDGE		
+			return(br_ioctl(cmd,(void *) arg));
+#else
+			return -ENOPKG;
+#endif						
+			
+		case SIOCGIFDIVERT:
+		case SIOCSIFDIVERT:
+#ifdef CONFIG_NET_DIVERT
+			return(divert_ioctl(cmd, (struct divert_cf *) arg));
+#else
+			return -ENOPKG;
+#endif	/* CONFIG_NET_DIVERT */
+
+		case SIOCADDDLCI:
+		case SIOCDELDLCI:
+#ifdef CONFIG_DLCI
+			return(dlci_ioctl(cmd, (void *) arg));
+#endif
+
+#ifdef CONFIG_DLCI_MODULE
+
+#ifdef CONFIG_KMOD
+			if (dlci_ioctl_hook == NULL)
+				request_module("dlci");
+#endif
+
+			if (dlci_ioctl_hook)
+				return((*dlci_ioctl_hook)(cmd, (void *) arg));
+#endif
+			return -ENOPKG;
+
+		default:
+			if ((cmd >= SIOCDEVPRIVATE) &&
+			    (cmd <= (SIOCDEVPRIVATE + 15)))
+				return(dev_ioctl(cmd,(void *) arg));
+
+#ifdef CONFIG_NET_RADIO
+			if((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST))
+				return(dev_ioctl(cmd,(void *) arg));
+#endif
+
+			if (sk->prot->ioctl==NULL || (err=sk->prot->ioctl(sk, cmd, arg))==-ENOIOCTLCMD)
+				return(dev_ioctl(cmd,(void *) arg));		
+			return err;
+	}
+	/*NOTREACHED*/
+	return(0);
+}
+
+struct proto_ops inet_stream_ops = {
+	PF_INET,
+
+	sock_no_dup,
+	inet_release,
+	inet_bind,
+	inet_stream_connect,
+	sock_no_socketpair,
+	inet_accept,
+	inet_getname, 
+	inet_poll,
+	inet_ioctl,
+	inet_listen,
+	inet_shutdown,
+	inet_setsockopt,
+	inet_getsockopt,
+	sock_no_fcntl,
+	inet_sendmsg,
+	inet_recvmsg
+};
+
+struct proto_ops inet_dgram_ops = {
+	PF_INET,
+
+	sock_no_dup,
+	inet_release,
+	inet_bind,
+	inet_dgram_connect,
+	sock_no_socketpair,
+	sock_no_accept,
+	inet_getname, 
+	datagram_poll,
+	inet_ioctl,
+	sock_no_listen,
+	inet_shutdown,
+	inet_setsockopt,
+	inet_getsockopt,
+	sock_no_fcntl,
+	inet_sendmsg,
+	inet_recvmsg
+};
+
+struct net_proto_family inet_family_ops = {
+	PF_INET,
+	inet_create
+};
+
+
+#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_INET_RARP
+static struct proc_dir_entry proc_net_rarp = {
+	PROC_NET_RARP, 4, "rarp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	rarp_get_info
+};
+#endif		/* RARP */
+static struct proc_dir_entry proc_net_raw = {
+	PROC_NET_RAW, 3, "raw",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	raw_get_info
+};
+static struct proc_dir_entry proc_net_netstat = {
+	PROC_NET_NETSTAT, 7, "netstat",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	netstat_get_info
+};
+static struct proc_dir_entry proc_net_snmp = {
+	PROC_NET_SNMP, 4, "snmp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	snmp_get_info
+};
+static struct proc_dir_entry proc_net_sockstat = {
+	PROC_NET_SOCKSTAT, 8, "sockstat",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	afinet_get_info
+};
+static struct proc_dir_entry proc_net_tcp = {
+	PROC_NET_TCP, 3, "tcp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	tcp_get_info
+};
+static struct proc_dir_entry proc_net_udp = {
+	PROC_NET_UDP, 3, "udp",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	udp_get_info
+};
+#endif		/* CONFIG_PROC_FS */
+
+extern void tcp_init(void);
+extern void tcp_v4_init(struct net_proto_family *);
+
+
+/*
+ *	Called by socket.c on kernel startup.  
+ */
+ 
+__initfunc(void inet_proto_init(struct net_proto *pro))
+{
+	struct sk_buff *dummy_skb;
+	struct inet_protocol *p;
+
+	printk(KERN_INFO "NET4: Linux TCP/IP 1.0 for NET4.0\n");
+
+	if (sizeof(struct inet_skb_parm) > sizeof(dummy_skb->cb))
+	{
+		printk(KERN_CRIT "inet_proto_init: panic\n");
+		return;
+	}
+
+	/*
+	 *	Tell SOCKET that we are alive... 
+	 */
+   
+  	(void) sock_register(&inet_family_ops);
+
+	/*
+	 *	Add all the protocols. 
+	 */
+
+	printk(KERN_INFO "IP Protocols: ");
+	for(p = inet_protocol_base; p != NULL;) 
+	{
+		struct inet_protocol *tmp = (struct inet_protocol *) p->next;
+		inet_add_protocol(p);
+		printk("%s%s",p->name,tmp?", ":"\n");
+		p = tmp;
+	}
+
+	/*
+	 *	Set the ARP module up
+	 */
+
+	arp_init();
+
+  	/*
+  	 *	Set the IP module up
+  	 */
+
+	ip_init();
+
+	tcp_v4_init(&inet_family_ops);
+
+	/* Setup TCP slab cache for open requests. */
+	tcp_init();
+
+
+	/*
+	 *	Set the ICMP layer up
+	 */
+
+	icmp_init(&inet_family_ops);
+
+	/* I wish inet_add_protocol had no constructor hook...
+	   I had to move IPIP from net/ipv4/protocol.c :-( --ANK
+	 */
+#ifdef CONFIG_NET_IPIP
+	ipip_init();
+#endif
+#ifdef CONFIG_NET_IPGRE
+	ipgre_init();
+#endif
+
+	/*
+	 *	Set the firewalling up
+	 */
+#if defined(CONFIG_IP_FIREWALL)
+	ip_fw_init();
+#endif
+
+#ifdef CONFIG_IP_MASQUERADE
+	ip_masq_init();
+#endif
+	
+	/*
+	 *	Initialise the multicast router
+	 */
+#if defined(CONFIG_IP_MROUTE)
+	ip_mr_init();
+#endif
+
+#ifdef CONFIG_INET_RARP
+	rarp_ioctl_hook = rarp_ioctl;
+#endif
+	/*
+	 *	Create all the /proc entries.
+	 */
+
+#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_INET_RARP
+	proc_net_register(&proc_net_rarp);
+#endif		/* RARP */
+	proc_net_register(&proc_net_raw);
+	proc_net_register(&proc_net_snmp);
+	proc_net_register(&proc_net_netstat);
+	proc_net_register(&proc_net_sockstat);
+	proc_net_register(&proc_net_tcp);
+	proc_net_register(&proc_net_udp);
+#endif		/* CONFIG_PROC_FS */
+}
