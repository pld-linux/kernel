diff -urNp -x '*.orig' linux-4.4/include/net/inet_sock.h linux-4.4/include/net/inet_sock.h
--- linux-4.4/include/net/inet_sock.h	2021-02-24 16:52:56.472941287 +0100
+++ linux-4.4/include/net/inet_sock.h	2021-02-24 16:53:08.266645321 +0100
@@ -201,6 +201,7 @@ struct inet_sock {
 	__be32			mc_addr;
 	struct ip_mc_socklist __rcu	*mc_list;
 	struct inet_cork_full	cork;
+	__u16			zph_tos;	/* ZPH TOS received on connect */
 };
 
 #define IPCORK_OPT	1	/* ip-options has been held in ipcork.opt */
diff -urNp -x '*.orig' linux-4.4/net/ipv4/ip_sockglue.c linux-4.4/net/ipv4/ip_sockglue.c
--- linux-4.4/net/ipv4/ip_sockglue.c	2021-02-24 16:52:56.629612878 +0100
+++ linux-4.4/net/ipv4/ip_sockglue.c	2021-02-24 16:53:08.266645321 +0100
@@ -1474,6 +1474,10 @@ static int do_ip_getsockopt(struct sock
 			int tos = inet->rcv_tos;
 			put_cmsg(&msg, SOL_IP, IP_TOS, sizeof(tos), &tos);
 		}
+		if (inet->cmsg_flags&IP_CMSG_TOS) {
+			int hlim = inet->zph_tos & 0xFF;
+			put_cmsg(&msg, SOL_IP, IP_TOS, sizeof(hlim), &hlim);
+		}
 		len -= msg.msg_controllen;
 		return put_user(len, optlen);
 	}
diff -urNp -x '*.orig' linux-4.4/net/ipv4/tcp_input.c linux-4.4/net/ipv4/tcp_input.c
--- linux-4.4/net/ipv4/tcp_input.c	2021-02-24 16:52:56.639613193 +0100
+++ linux-4.4/net/ipv4/tcp_input.c	2021-02-24 16:53:08.266645321 +0100
@@ -4631,6 +4631,8 @@ static void tcp_data_queue(struct sock *
 	struct tcp_sock *tp = tcp_sk(sk);
 	bool fragstolen = false;
 	int eaten = -1;
+	struct inet_sock *inet = inet_sk(sk);
+	struct iphdr *iph = ip_hdr(skb);
 
 	if (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {
 		__kfree_skb(skb);
@@ -4643,6 +4645,12 @@ static void tcp_data_queue(struct sock *
 
 	tp->rx_opt.dsack = 0;
 
+	// ZPH: Copy the TOS value of the first data ACK segment
+	// received from the remote peer.
+	if (0==(inet->zph_tos & 0x8000)) {
+		inet->zph_tos = 0x8000 | iph->tos;
+	}
+
 	/*  Queue data for delivery to the user.
 	 *  Packets in sequence go to the receive queue.
 	 *  Out of sequence packets to the out_of_order_queue.
@@ -5679,6 +5687,8 @@ static int tcp_rcv_synsent_state_process
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
+	struct inet_sock *inet = inet_sk(sk);
+	struct iphdr *iph = ip_hdr(skb);
 	struct tcp_fastopen_cookie foc = { .len = -1 };
 	int saved_clamp = tp->rx_opt.mss_clamp;
 	bool fastopen_fail;
@@ -5739,6 +5749,15 @@ static int tcp_rcv_synsent_state_process
 
 		tcp_ecn_rcv_synack(tp, th);
 
+		/* ZPH:
+		 * Copy TOS field from the SYNACK packet to zph_tos field of the af_inet
+		 * member of sock structure. This value shall be overwritten when the first
+		 * data segment is received from the peer. However, for completeness in
+		 * case the socket TOS is being asked befor that, we copy the TOS value from
+		 * the SYNACK packet.
+		 */
+		inet->zph_tos = iph->tos;
+
 		tcp_init_wl(tp, TCP_SKB_CB(skb)->seq);
 		tcp_ack(sk, skb, FLAG_SLOWPATH);
 
