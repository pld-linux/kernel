diff -urN zombi-a/arch/alpha/defconfig zombi-b/arch/alpha/defconfig
--- zombi-a/arch/alpha/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/alpha/defconfig	2003-10-12 01:28:50.997967344 +0200
@@ -555,6 +555,10 @@
 # CONFIG_AUTOFS4_FS is not set
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/i386/config.in zombi-b/arch/i386/config.in
--- zombi-a/arch/i386/config.in	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/i386/config.in	2003-10-12 01:28:51.005966128 +0200
@@ -74,6 +74,7 @@
    define_bool CONFIG_X86_F00F_WORKS_OK n
 fi
 if [ "$CONFIG_M586" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_USE_STRING_486 y
    define_bool CONFIG_X86_ALIGNMENT_16 y
@@ -81,6 +82,7 @@
    define_bool CONFIG_X86_F00F_WORKS_OK n
 fi
 if [ "$CONFIG_M586TSC" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_USE_STRING_486 y
    define_bool CONFIG_X86_ALIGNMENT_16 y
@@ -89,6 +91,7 @@
    define_bool CONFIG_X86_F00F_WORKS_OK n
 fi
 if [ "$CONFIG_M586MMX" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_USE_STRING_486 y
    define_bool CONFIG_X86_ALIGNMENT_16 y
@@ -98,6 +101,7 @@
    define_bool CONFIG_X86_F00F_WORKS_OK n
 fi
 if [ "$CONFIG_M686" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
@@ -107,6 +111,7 @@
    define_bool CONFIG_X86_F00F_WORKS_OK y
 fi
 if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
@@ -116,6 +121,7 @@
    define_bool CONFIG_X86_SFENCE y
 fi
 if [ "$CONFIG_MPENTIUM4" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 7
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
@@ -127,6 +133,7 @@
    define_bool CONFIG_X86_MFENCE y
 fi
 if [ "$CONFIG_MK6" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 5
    define_bool CONFIG_X86_ALIGNMENT_16 y
    define_bool CONFIG_X86_HAS_TSC y
@@ -138,6 +145,7 @@
    define_bool CONFIG_MK7 y
 fi
 if [ "$CONFIG_MK7" = "y" ]; then
+   define_bool CONFIG_X86_CMPXCHG8 y
    define_int  CONFIG_X86_L1_CACHE_SHIFT 6
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
diff -urN zombi-a/arch/ia64/defconfig zombi-b/arch/ia64/defconfig
--- zombi-a/arch/ia64/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/ia64/defconfig	2003-10-12 01:28:51.009965520 +0200
@@ -677,6 +677,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/mips/defconfig zombi-b/arch/mips/defconfig
--- zombi-a/arch/mips/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/mips/defconfig	2003-10-12 01:28:51.021963696 +0200
@@ -525,6 +525,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/mips64/defconfig zombi-b/arch/mips64/defconfig
--- zombi-a/arch/mips64/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/mips64/defconfig	2003-10-12 01:28:51.033961872 +0200
@@ -489,6 +489,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/ppc/defconfig zombi-b/arch/ppc/defconfig
--- zombi-a/arch/ppc/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/ppc/defconfig	2003-10-12 01:28:51.037961264 +0200
@@ -767,6 +767,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/ppc64/defconfig zombi-b/arch/ppc64/defconfig
--- zombi-a/arch/ppc64/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/ppc64/defconfig	2003-10-12 01:28:51.053958832 +0200
@@ -593,6 +593,10 @@
 CONFIG_REISERFS_FS=y
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/s390/defconfig zombi-b/arch/s390/defconfig
--- zombi-a/arch/s390/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/s390/defconfig	2003-10-12 01:28:51.066956856 +0200
@@ -282,6 +282,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/s390x/defconfig zombi-b/arch/s390x/defconfig
--- zombi-a/arch/s390x/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/s390x/defconfig	2003-10-12 01:28:51.073955792 +0200
@@ -224,6 +224,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
diff -urN zombi-a/arch/sparc/defconfig zombi-b/arch/sparc/defconfig
--- zombi-a/arch/sparc/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/sparc/defconfig	2003-10-12 01:28:51.083954272 +0200
@@ -295,6 +295,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 CONFIG_AFFS_FS=m
diff -urN zombi-a/arch/sparc64/defconfig zombi-b/arch/sparc64/defconfig
--- zombi-a/arch/sparc64/defconfig	2003-10-12 01:04:03.000000000 +0200
+++ zombi-b/arch/sparc64/defconfig	2003-10-12 01:28:51.098951992 +0200
@@ -703,6 +703,10 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_FS_XATTR_USER is not set
+# CONFIG_REISERFS_FS_XATTR_SHARING is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
 # CONFIG_ADFS_FS is not set
 # CONFIG_ADFS_FS_RW is not set
 CONFIG_AFFS_FS=m
diff -urN zombi-a/fs/Config.in zombi-b/fs/Config.in
--- zombi-a/fs/Config.in	2003-10-12 01:04:01.000000000 +0200
+++ zombi-b/fs/Config.in	2003-10-12 01:28:51.000000000 +0200
@@ -13,6 +13,10 @@
 tristate 'Reiserfs support' CONFIG_REISERFS_FS
 dep_mbool '  Enable reiserfs debug mode' CONFIG_REISERFS_CHECK $CONFIG_REISERFS_FS
 dep_mbool '  Stats in /proc/fs/reiserfs' CONFIG_REISERFS_PROC_INFO $CONFIG_REISERFS_FS
+dep_mbool '  ReiserFS extended attributes' CONFIG_REISERFS_FS_XATTR $CONFIG_REISERFS_FS
+dep_mbool '  ReiserFS extended user attributes' CONFIG_REISERFS_FS_XATTR_USER $CONFIG_REISERFS_FS_XATTR
+dep_mbool '  ReiserFS trusted extended attributes' CONFIG_REISERFS_FS_XATTR_TRUSTED $CONFIG_REISERFS_FS_XATTR
+dep_mbool '  ReiserFS POSIX Access Control Lists' CONFIG_REISERFS_FS_POSIX_ACL $CONFIG_REISERFS_FS_XATTR $CONFIG_FS_POSIX_ACL
 
 dep_tristate 'ADFS file system support (EXPERIMENTAL)' CONFIG_ADFS_FS $CONFIG_EXPERIMENTAL
 dep_mbool '  ADFS write support (DANGEROUS)' CONFIG_ADFS_FS_RW $CONFIG_ADFS_FS $CONFIG_EXPERIMENTAL
diff -urN zombi-a/fs/inode.c zombi-b/fs/inode.c
--- zombi-a/fs/inode.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/inode.c	2003-10-12 01:28:51.000000000 +0200
@@ -158,6 +158,7 @@
 	sema_init(&inode->i_zombie, 1);
 	init_rwsem(&inode->i_alloc_sem);
 	spin_lock_init(&inode->i_data.i_shared_lock);
+	i_size_ordered_init(inode);
 }
 
 static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
diff -urN zombi-a/fs/reiserfs/dir.c zombi-b/fs/reiserfs/dir.c
--- zombi-a/fs/reiserfs/dir.c	2003-08-28 03:26:33.000000000 +0200
+++ zombi-b/fs/reiserfs/dir.c	2003-10-12 01:28:51.000000000 +0200
@@ -110,6 +110,15 @@
 		    /* too big to send back to VFS */
 		    continue ;
 		}
+
+                /* Ignore the .reiserfs_priv entry */
+		if (reiserfs_xattrs (inode->i_sb) && 
+                    !old_format_only(inode->i_sb) &&
+                    inode->i_sb->u.reiserfs_sb.priv_root &&
+                    inode->i_sb->u.reiserfs_sb.priv_root->d_inode &&
+                    deh_objectid (deh) == le32_to_cpu (INODE_PKEY(inode->i_sb->u.reiserfs_sb.priv_root->d_inode)->k_objectid))
+                  continue;
+
 		d_off = deh_offset (deh);
 		filp->f_pos = d_off ;
 		d_ino = deh_objectid (deh);
diff -urN zombi-a/fs/reiserfs/file.c zombi-b/fs/reiserfs/file.c
--- zombi-a/fs/reiserfs/file.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/file.c	2003-10-12 01:28:51.000000000 +0200
@@ -5,6 +5,8 @@
 
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/quotaops.h>
 
@@ -90,61 +92,6 @@
   return ( n_err < 0 ) ? -EIO : 0;
 }
 
-static int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
-    struct inode *inode = dentry->d_inode ;
-    int error ;
-    unsigned int ia_valid = attr->ia_valid ;
-
-    if (ia_valid & ATTR_SIZE) {
-	/* version 2 items will be caught by the s_maxbytes check
-	** done for us in vmtruncate
-	*/
-	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&
-	    attr->ia_size > MAX_NON_LFS)
-            return -EFBIG ;
-
-        /* During a truncate, we have to make sure the new i_size is in
-	** the transaction before we start dropping updates to data logged
-	** or ordered write data pages.
-	*/
-	if (attr->ia_size < inode->i_size && reiserfs_file_data_log(inode)) {
-	    struct reiserfs_transaction_handle th ;
-	    journal_begin(&th, inode->i_sb, 1) ;
-	    reiserfs_update_sd_size(&th, inode, attr->ia_size) ;
-	    journal_end(&th, inode->i_sb, 1) ;
-	/* fill in hole pointers in the expanding truncate case. */
-        } else if (attr->ia_size > inode->i_size) {
-	    error = generic_cont_expand(inode, attr->ia_size) ;
-	    if (inode->u.reiserfs_i.i_prealloc_count > 0) {
-		struct reiserfs_transaction_handle th ;
-		/* we're changing at most 2 bitmaps, inode + super */
-		journal_begin(&th, inode->i_sb, 4) ;
-		reiserfs_discard_prealloc (&th, inode);
-		journal_end(&th, inode->i_sb, 4) ;
-	    }
-	    if (error)
-	        return error ;
-	}
-    }
-
-    if ((((attr->ia_valid & ATTR_UID) && (attr->ia_uid & ~0xffff)) ||
-	 ((attr->ia_valid & ATTR_GID) && (attr->ia_gid & ~0xffff))) &&
-	(get_inode_sd_version (inode) == STAT_DATA_V1))
-		/* stat data of format v3.5 has 16 bit uid and gid */
-	    return -EINVAL;
-
-    error = inode_change_ok(inode, attr) ;
-    if (!error) {
-	if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
-	    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
-		error = DQUOT_TRANSFER(inode, attr) ? -EDQUOT : 0;
-
-	if (!error)
-	    error = inode_setattr(inode, attr) ;
-    }
-    return error ;
-}
-
 static ssize_t
 reiserfs_file_write(struct file *f, const char *b, size_t count, loff_t *ppos)
 {
@@ -173,6 +120,15 @@
 struct  inode_operations reiserfs_file_inode_operations = {
     truncate:	reiserfs_vfs_truncate_file,
     setattr:    reiserfs_setattr,
+    setxattr:   reiserfs_setxattr, 
+    getxattr:   reiserfs_getxattr, 
+    listxattr:   reiserfs_listxattr, 
+    removexattr:   reiserfs_removexattr, 
+    /*
+    set_posix_acl:  reiserfs_set_acl,
+    get_posix_acl:  reiserfs_get_acl,
+    */
+    permission: reiserfs_permission,
 };
 
 
diff -urN zombi-a/fs/reiserfs/inode.c zombi-b/fs/reiserfs/inode.c
--- zombi-a/fs/reiserfs/inode.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/inode.c	2003-10-12 01:28:51.000000000 +0200
@@ -6,6 +6,8 @@
 #include <linux/sched.h>
 #include <linux/fs.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/locks.h>
 #include <linux/smp_lock.h>
 #include <linux/quotaops.h>
@@ -42,6 +44,8 @@
     if (INODE_PKEY(inode)->k_objectid != 0) { /* also handles bad_inode case */
 	down (&inode->i_sem); 
 
+        reiserfs_delete_xattrs (inode);
+
 	journal_begin(&th, inode->i_sb, jbegin_count) ;
 	reiserfs_update_inode_transaction(inode) ;
 	windex = push_journal_writer("delete_inode") ;
@@ -351,10 +355,10 @@
 	** correct, and when direct item padding results in a few 
 	** extra bytes at the end of the direct item
 	*/
-        if ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)
+        if ((le_ih_k_offset(ih) + path.pos_in_item) > i_size_read(inode))
 	    break ;
-	if ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {
-	    chars = inode->i_size - (le_ih_k_offset(ih) - 1) - path.pos_in_item;
+	if ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > i_size_read(inode)) {
+	    chars = i_size_read(inode) - (le_ih_k_offset(ih) - 1) - path.pos_in_item;
 	    done = 1 ;
 	} else {
 	    chars = ih_item_len(ih) - path.pos_in_item;
@@ -645,7 +649,7 @@
     ** running.  So, if we are nesting into someone else, we have to
     ** make sure and bump the refcount
     */
-    if ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {
+    if ((new_offset + inode->i_sb->s_blocksize - 1) > i_size_read(inode)) {
 	th = reiserfs_persistent_transaction(inode->i_sb, jbegin_count) ;
 	if (IS_ERR(th)) {
 	    retval = PTR_ERR(th) ;
@@ -1022,7 +1026,7 @@
     ** tail, we add 4 bytes to pretend there really is an unformatted
     ** node pointer
     */
-    bytes = ((inode->i_size + (blocksize-1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE + sd_size;
+    bytes = ((i_size_read(inode) + (blocksize-1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE + sd_size;
     return bytes ;
 }
 
@@ -1030,7 +1034,7 @@
                                         int sd_size)
 {
     if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {
-        return inode->i_size + (loff_t)(real_space_diff(inode, sd_size)) ;
+        return i_size_read(inode) + (loff_t)(real_space_diff(inode, sd_size)) ;
     }
     return ((loff_t)real_space_diff(inode, sd_size)) + (((loff_t)blocks) << 9);
 }
@@ -1165,7 +1169,7 @@
 	inode->i_op = &reiserfs_dir_inode_operations;
 	inode->i_fop = &reiserfs_dir_operations;
     } else if (S_ISLNK (inode->i_mode)) {
-	inode->i_op = &page_symlink_inode_operations;
+	inode->i_op = &reiserfs_symlink_inode_operations;
 	inode->i_mapping->a_ops = &reiserfs_address_space_operations;
     } else {
 	inode->i_blocks = 0;
@@ -1843,6 +1847,17 @@
 	goto out_inserted_sd;
     }
 
+    if (reiserfs_posixacl (inode->i_sb)) {
+        retval = reiserfs_inherit_default_acl (dir, dentry, inode);
+        if (retval) {
+            err = retval;
+            reiserfs_check_path(&path_to_key) ;
+            goto out_inserted_sd;
+        }
+    } else if (inode->i_sb->s_flags & MS_POSIXACL) {
+        reiserfs_warning (inode->i_sb, "ACLs aren't enabled in the fs, but vfs thinks they are!\n");
+    }
+
     insert_inode_hash (inode);
     reiserfs_update_sd(th, inode) ;
     reiserfs_check_path(&path_to_key) ;
@@ -1885,6 +1900,8 @@
 
     /* we want the page with the last byte in the file,
     ** not the page that will hold the next byte for appending
+    **
+    ** we are called with i_sem held, so we don't need i_size_read()
     */
     unsigned long index = (p_s_inode->i_size-1) >> PAGE_CACHE_SHIFT ;
     unsigned long pos = 0 ;
@@ -2132,7 +2149,7 @@
 
 	/* are there still bytes left? */
         if (bytes_copied < bh_result->b_size && 
-	    (byte_offset + bytes_copied) < inode->i_size) {
+	    (byte_offset + bytes_copied) < i_size_read(inode)) {
 	    set_cpu_key_k_offset(&key, cpu_key_k_offset(&key) + copy_size) ;
 	    goto research ;
 	}
@@ -2228,7 +2245,7 @@
 
 static int reiserfs_write_full_page(struct page *page) {
     struct inode *inode = page->mapping->host ;
-    loff_t size = inode->i_size;
+    loff_t size = i_size_read(inode);
     unsigned long end_index = size >> PAGE_CACHE_SHIFT ;
     unsigned last_offset = PAGE_CACHE_SIZE;
     int error = 0;
@@ -2482,6 +2499,7 @@
     th.t_flags = 0 ;
     ret = __commit_write(&th, inode, page, from, to, &need_balance) ;
  
+    /* i_sem is held, i_size_read is not required */
     if (pos > inode->i_size) {
 	lock_kernel();
 	/* If the file have grown beyond the border where it
@@ -2495,7 +2513,7 @@
 	    journal_begin(&th, inode->i_sb, 1) ;
 	}
 	reiserfs_update_inode_transaction(inode) ;
-	inode->i_size = pos ;
+	i_size_write(inode, pos);
 	reiserfs_update_sd(&th, inode) ;
 	journal_end(&th, th.t_super, th.t_blocks_allocated) ;
 	unlock_kernel() ;
@@ -2685,6 +2703,79 @@
                              reiserfs_get_block_direct_io) ;
 }
 
+int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
+    struct inode *inode = dentry->d_inode ;
+    int error ;
+    unsigned int ia_valid = attr->ia_valid ;
+
+    if (ia_valid & ATTR_SIZE) {
+	/* version 2 items will be caught by the s_maxbytes check
+	** done for us in vmtruncate
+	*/
+	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&
+	    attr->ia_size > MAX_NON_LFS)
+            return -EFBIG ;
+
+        /* During a truncate, we have to make sure the new i_size is in
+	** the transaction before we start dropping updates to data logged
+	** or ordered write data pages.
+	*/
+	if (attr->ia_size < i_size_read(inode) && reiserfs_file_data_log(inode)) {
+	    struct reiserfs_transaction_handle th ;
+	    journal_begin(&th, inode->i_sb, 1) ;
+	    reiserfs_update_sd_size(&th, inode, attr->ia_size) ;
+	    journal_end(&th, inode->i_sb, 1) ;
+	/* fill in hole pointers in the expanding truncate case. */
+        } else if (attr->ia_size > i_size_read(inode)) {
+	    error = generic_cont_expand(inode, attr->ia_size) ;
+	    if (inode->u.reiserfs_i.i_prealloc_count > 0) {
+		struct reiserfs_transaction_handle th ;
+		/* we're changing at most 2 bitmaps, inode + super */
+		journal_begin(&th, inode->i_sb, 4) ;
+		reiserfs_discard_prealloc (&th, inode);
+		journal_end(&th, inode->i_sb, 4) ;
+	    }
+	    if (error)
+	        return error ;
+	}
+    }
+
+    if ((((attr->ia_valid & ATTR_UID) && (attr->ia_uid & ~0xffff)) ||
+	 ((attr->ia_valid & ATTR_GID) && (attr->ia_gid & ~0xffff))) &&
+	(get_inode_sd_version (inode) == STAT_DATA_V1))
+		/* stat data of format v3.5 has 16 bit uid and gid */
+	    return -EINVAL;
+
+    error = inode_change_ok(inode, attr) ;
+    if (!error) {
+	if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
+	    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid)) {
+                if (!(attr->ia_valid & ATTR_SIZE))
+                    down (&inode->i_sem);
+                error = reiserfs_chown_xattrs (inode, attr);
+                if (!(attr->ia_valid & ATTR_SIZE))
+                    up (&inode->i_sem);
+
+                if (!error)
+                    error = DQUOT_TRANSFER(inode, attr) ? -EDQUOT : 0;
+        }
+	if (!error)
+	    error = inode_setattr(inode, attr) ;
+    }
+
+    if (!error && reiserfs_posixacl (inode->i_sb) && !S_ISLNK(inode->i_mode)) {
+        if (attr->ia_valid & ATTR_MODE) {
+            if (!(attr->ia_valid & ATTR_SIZE))
+                down (&inode->i_sem);
+            error = reiserfs_acl_chmod (inode);
+            if (!(attr->ia_valid & ATTR_SIZE))
+                up (&inode->i_sem);
+        }
+    }
+
+    return error ;
+}
+
 struct address_space_operations reiserfs_address_space_operations = {
     writepage: reiserfs_writepage,
     readpage: reiserfs_readpage, 
diff -urN zombi-a/fs/reiserfs/ioctl.c zombi-b/fs/reiserfs/ioctl.c
--- zombi-a/fs/reiserfs/ioctl.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/ioctl.c	2003-10-12 01:28:51.000000000 +0200
@@ -110,7 +110,7 @@
     unsigned long write_from ;
     unsigned long blocksize = inode->i_sb->s_blocksize ;
     	
-    if (inode->i_size == 0) {
+    if (i_size_read(inode) == 0) {
         inode->u.reiserfs_i.i_flags |= i_nopack_mask;
         return 0 ;
     }
diff -urN zombi-a/fs/reiserfs/Makefile zombi-b/fs/reiserfs/Makefile
--- zombi-a/fs/reiserfs/Makefile	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/Makefile	2003-10-12 01:28:51.000000000 +0200
@@ -12,6 +12,11 @@
 obj-y   := bitmap.o do_balan.o namei.o inode.o file.o dir.o fix_node.o super.o prints.o objectid.o \
 lbalance.o ibalance.o stree.o hashes.o buffer2.o tail_conversion.o journal.o resize.o item_ops.o ioctl.o procfs.o
 
+obj-$(CONFIG_REISERFS_FS_XATTR) += xattr.o
+obj-$(CONFIG_REISERFS_FS_XATTR_USER) += xattr_user.o
+obj-$(CONFIG_REISERFS_FS_XATTR_TRUSTED) += xattr_trusted.o
+obj-$(CONFIG_REISERFS_FS_POSIX_ACL) += xattr_acl.o
+
 obj-m   := $(O_TARGET)
 
 # gcc -O2 (the kernel default)  is overaggressive on ppc32 when many inline
diff -urN zombi-a/fs/reiserfs/namei.c zombi-b/fs/reiserfs/namei.c
--- zombi-a/fs/reiserfs/namei.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/namei.c	2003-10-12 01:28:51.000000000 +0200
@@ -6,6 +6,8 @@
 #include <linux/sched.h>
 #include <linux/bitops.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/quotaops.h>
 
@@ -271,7 +273,7 @@
 
 // may return NAME_FOUND, NAME_FOUND_INVISIBLE, NAME_NOT_FOUND
 // FIXME: should add something like IOERROR
-static int reiserfs_find_entry (struct inode * dir, const char * name, int namelen, 
+int reiserfs_find_entry (struct inode * dir, const char * name, int namelen, 
 				struct path * path_to_entry, struct reiserfs_dir_entry * de)
 {
     struct cpu_key key_to_search;
@@ -324,10 +326,21 @@
     retval = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de);
     pathrelse (&path_to_entry);
     if (retval == NAME_FOUND) {
+        /* Hide the .reiserfs_priv dir */
+	if (reiserfs_xattrs (dir->i_sb) &&
+            !old_format_only(dir->i_sb) &&
+            dir->i_sb->u.reiserfs_sb.priv_root &&
+            dir->i_sb->u.reiserfs_sb.priv_root->d_inode &&
+            de.de_objectid == le32_to_cpu (INODE_PKEY(dir->i_sb->u.reiserfs_sb.priv_root->d_inode)->k_objectid)) {
+            return ERR_PTR (-EACCES);
+	}
 	inode = reiserfs_iget (dir->i_sb, (struct cpu_key *)&(de.de_dir_id));
 	if (!inode || IS_ERR(inode)) {
 	    return ERR_PTR(-EACCES);
         }
+        /* Propogate the priv_object flag so we know we're in the priv tree */
+        if (is_reiserfs_priv_object (dir))
+            inode->u.reiserfs_i.i_flags |= i_priv_object;
     }
     if ( retval == IO_ERROR ) {
 	return ERR_PTR(-EIO);
@@ -534,6 +547,7 @@
     struct inode * inode;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2 ;
     struct reiserfs_transaction_handle th ;
+    int locked;
 
     if (!(inode = new_inode(dir->i_sb))) {
 	return -ENOMEM ;
@@ -542,8 +556,16 @@
     if (retval)
 	return retval ;
 
+    locked = reiserfs_cache_default_acl (dir);
+    if (locked)                                                               
+	reiserfs_write_lock_xattrs (inode->i_sb);
+
     journal_begin(&th, dir->i_sb, jbegin_count) ;
     retval = reiserfs_new_inode (&th, dir, mode, 0, 0/*i_size*/, dentry, inode);
+
+    if (locked)
+	reiserfs_write_unlock_xattrs (inode->i_sb);
+
     if (retval) {
 	goto out_failed ;
     }
@@ -579,6 +601,7 @@
     struct inode * inode;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+    int locked;
 
     if (!(inode = new_inode(dir->i_sb))) {
 	return -ENOMEM ;
@@ -587,9 +610,17 @@
     if (retval)
         return retval ;
 
+    locked = reiserfs_cache_default_acl (dir);
+    if (locked)
+        reiserfs_write_lock_xattrs (inode->i_sb);
+
     journal_begin(&th, dir->i_sb, jbegin_count) ;
 
     retval = reiserfs_new_inode(&th, dir, mode, 0, 0/*i_size*/, dentry, inode);
+
+    if (locked)
+        reiserfs_write_unlock_xattrs (inode->i_sb);
+
     if (retval) {
 	goto out_failed; 
     }
@@ -627,6 +658,7 @@
     struct inode * inode;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+    int locked;
 
     mode = S_IFDIR | mode;
     if (!(inode = new_inode(dir->i_sb))) {
@@ -636,6 +668,10 @@
     if (retval)
 	return retval ;
 
+    locked = reiserfs_cache_default_acl (dir);
+    if (locked)                                                               
+	reiserfs_write_lock_xattrs (inode->i_sb);
+
     journal_begin(&th, dir->i_sb, jbegin_count) ;
 
     /* inc the link count now, so another writer doesn't overflow it while
@@ -651,6 +687,9 @@
 				old_format_only (dir->i_sb) ?
 				EMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE,
 				dentry, inode) ;
+    if (locked)
+        reiserfs_write_unlock_xattrs (inode->i_sb);
+
     if (retval) {
 	dir->i_nlink-- ;
 	goto out_failed ;
@@ -871,7 +910,6 @@
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
 
-
     if (!(inode = new_inode(parent_dir->i_sb))) {
   	return -ENOMEM ;
     }
@@ -896,11 +934,14 @@
     memcpy (name, symname, strlen (symname));
     padd_item (name, item_len, strlen (symname));
 
+    /* We would inherit the default ACL here, but symlinks don't get ACLs */
+
     journal_begin(&th, parent_dir->i_sb, jbegin_count) ;
 
     retval = reiserfs_new_inode(&th, parent_dir, mode, name,
 				strlen(symname), dentry, inode) ;
     reiserfs_kfree (name, item_len, parent_dir->i_sb);
+
     if (retval) {
 	goto out_failed ;
     }
@@ -908,7 +949,7 @@
     reiserfs_update_inode_transaction(inode) ;
     reiserfs_update_inode_transaction(parent_dir) ;
 
-    inode->i_op = &page_symlink_inode_operations;
+    inode->i_op = &reiserfs_symlink_inode_operations;
     inode->i_mapping->a_ops = &reiserfs_address_space_operations;
 
     // must be sure this inode is written with this transaction
@@ -934,10 +975,9 @@
 }
 
 
-static int reiserfs_link (struct dentry * old_dentry, struct inode * dir, struct dentry * dentry)
+int __reiserfs_link (struct inode * inode, struct inode * dir, struct dentry * dentry)
 {
     int retval;
-    struct inode *inode = old_dentry->d_inode;
     int windex ;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
@@ -986,6 +1026,10 @@
     return 0;
 }
 
+static int reiserfs_link (struct dentry * old_dentry, struct inode * dir, struct dentry * dentry)
+{
+    return __reiserfs_link (old_dentry->d_inode, dir, dentry);
+}
 
 // de contains information pointing to an entry which 
 static int de_still_valid (const char * name, int len, struct reiserfs_dir_entry * de)
@@ -1280,5 +1324,33 @@
     rmdir:	reiserfs_rmdir,
     mknod:	reiserfs_mknod,
     rename:	reiserfs_rename,
+    setattr:   reiserfs_setattr, 
+    setxattr:   reiserfs_setxattr, 
+    getxattr:   reiserfs_getxattr, 
+    listxattr:   reiserfs_listxattr, 
+    removexattr:   reiserfs_removexattr, 
+    /*
+    set_posix_acl:  reiserfs_set_acl,
+    get_posix_acl:  reiserfs_get_acl,
+    */
+    permission: reiserfs_permission,
 };
 
+/*
+ * symlink operations.. same as page_symlink_inode_operations, with xattr
+ * stuff added
+ */
+struct inode_operations reiserfs_symlink_inode_operations = {
+    readlink:       page_readlink,
+    follow_link:    page_follow_link,
+    setattr:        reiserfs_setattr,
+    setxattr:       reiserfs_setxattr,
+    getxattr:       reiserfs_getxattr,
+    listxattr:      reiserfs_listxattr,
+    removexattr:    reiserfs_removexattr,
+    /*
+    set_posix_acl:  reiserfs_set_acl,
+    get_posix_acl:  reiserfs_get_acl,
+    */
+    permission: reiserfs_permission,
+};
diff -urN zombi-a/fs/reiserfs/stree.c zombi-b/fs/reiserfs/stree.c
--- zombi-a/fs/reiserfs/stree.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/stree.c	2003-10-12 01:28:51.000000000 +0200
@@ -1451,7 +1451,7 @@
 
 void reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * inode)
 {
-    inode->i_size = 0;
+    i_size_write(inode, 0);
 
     /* for directory this deletes item containing "." and ".." */
     reiserfs_do_truncate (th, inode, NULL, 0/*no timestamp updates*/);
@@ -1483,6 +1483,7 @@
     int n_block_size = p_s_sb->s_blocksize;
     int cut_bytes;
 
+    /* i_sem is held, i_size_read not required */
     if (n_new_file_size != p_s_inode->i_size)
 	BUG ();
 
diff -urN zombi-a/fs/reiserfs/super.c zombi-b/fs/reiserfs/super.c
--- zombi-a/fs/reiserfs/super.c	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/fs/reiserfs/super.c	2003-10-12 01:28:51.000000000 +0200
@@ -9,6 +9,8 @@
 #include <linux/vmalloc.h>
 #include <asm/uaccess.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/locks.h>
 #include <linux/init.h>
@@ -354,7 +356,19 @@
 {
   int i;
   struct reiserfs_transaction_handle th ;
+
+  reiserfs_xattr_cache_clear (s->s_dev);
+
+  if (s->u.reiserfs_sb.xattr_root) {
+    d_invalidate (s->u.reiserfs_sb.xattr_root);
+    dput (s->u.reiserfs_sb.xattr_root);
+  }
   
+  if (s->u.reiserfs_sb.priv_root) {
+    d_invalidate (s->u.reiserfs_sb.priv_root);
+    dput (s->u.reiserfs_sb.priv_root);
+  }
+
   /* change file system state to current state if it was mounted with read-write permissions */
   if (!(s->s_flags & MS_RDONLY)) {
     journal_begin(&th, s, 10) ;
@@ -419,6 +433,22 @@
     unlock_kernel() ;
 }
 
+static void reiserfs_clear_inode (struct inode *inode)
+{
+    struct posix_acl *acl;
+
+    acl = inode->u.reiserfs_i.i_acl_access;
+    if (acl && !IS_ERR (acl))
+        posix_acl_release (acl);
+    inode->u.reiserfs_i.i_acl_access = NULL;
+
+    acl = inode->u.reiserfs_i.i_acl_default;
+    if (acl && !IS_ERR (acl))
+        posix_acl_release (acl);
+    inode->u.reiserfs_i.i_acl_default = NULL;
+}
+
+
 struct super_operations reiserfs_sops = 
 {
   read_inode: reiserfs_read_inode,
@@ -426,6 +456,7 @@
   write_inode: reiserfs_write_inode,
   dirty_inode: reiserfs_dirty_inode,
   delete_inode: reiserfs_delete_inode,
+  clear_inode: reiserfs_clear_inode,
   put_super: reiserfs_put_super,
   write_super: reiserfs_write_super,
   write_super_lockfs: reiserfs_write_super_lockfs,
@@ -639,7 +670,16 @@
 		{"noattrs", 0, 0, 0, 1<<REISERFS_ATTRS},
 		{"usrquota", 0, 0, 0, 0},
 		{"grpquota", 0, 0, 0, 0},
-
+#ifdef CONFIG_REISERFS_FS_XATTR
+# ifdef CONFIG_REISERFS_FS_XATTR_USER
+		{"user_xattr", 0, 0, 1<<REISERFS_XATTRS_USER},
+		{"nouser_xattr", 0, 0, 1<<REISERFS_NO_XATTRS_USER},
+# endif
+# ifdef CONFIG_REISERFS_FS_POSIX_ACL
+		{"acl", 0, 0, 1<<REISERFS_POSIXACL},
+		{"noacl", 0, 0, 1<<REISERFS_NO_POSIXACL},
+# endif
+#endif
 		{NULL, 0, 0, 0, 0}
     };
 	
@@ -757,6 +797,10 @@
   safe_mask |= 1 << REISERFS_HASHED_RELOCATION;
   safe_mask |= 1 << REISERFS_TEST4;
   safe_mask |= 1 << REISERFS_ATTRS;
+  safe_mask |= 1 << REISERFS_XATTRS_USER;
+  safe_mask |= 1 << REISERFS_NO_XATTRS_USER;
+  safe_mask |= 1 << REISERFS_POSIXACL;
+  safe_mask |= 1 << REISERFS_NO_POSIXACL;
 
   /* Update the bitmask, taking care to keep
    * the bits we're not allowed to change here */
@@ -771,6 +815,7 @@
   }
 
   if (*mount_flags & MS_RDONLY) {
+    reiserfs_xattr_init (s, *mount_flags);
     /* remount read-only */
     if (s->s_flags & MS_RDONLY)
       /* it is read-only already */
@@ -789,6 +834,7 @@
   } else {
     /* remount read-write */
     if (!(s->s_flags & MS_RDONLY)) {
+        reiserfs_xattr_init (s, *mount_flags);
 	handle_data_mode(s, mount_options);
 	return 0; /* We are read-write already */
     }
@@ -812,6 +858,7 @@
   if (!( *mount_flags & MS_RDONLY ) ) {
     finish_unfinished( s );
     handle_data_mode(s, mount_options);
+    reiserfs_xattr_init (s, *mount_flags);
   }
   return 0;
 }
@@ -1236,6 +1283,8 @@
     s->u.reiserfs_sb.s_alloc_options.preallocmin = 4;
     /* Preallocate by 8 blocks (9-1) at once */
     s->u.reiserfs_sb.s_alloc_options.preallocsize = 9;
+    /* Initialize the rwsem for xattr dir */
+    init_rwsem(&s->u.reiserfs_sb.xattr_dir_sem);
 
     if (reiserfs_parse_options (s, (char *) data, &(s->u.reiserfs_sb.s_mount_opt), &blocks) == 0) {
       return NULL;
@@ -1378,11 +1427,23 @@
 		
 	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
 	journal_end(&th, s, 1) ;
-	
+
+        if (reiserfs_xattr_init (s, s->s_flags)) {
+            dput (s->s_root);
+            s->s_root = NULL;
+            goto error;
+        }
+
 	/* look for files which were to be removed in previous session */
 	finish_unfinished (s);
 
 	s->s_dirt = 0;
+    } else {
+        if (reiserfs_xattr_init (s, s->s_flags)) {
+            dput (s->s_root);
+            s->s_root = NULL;
+            goto error;
+        }
     }
 
     // mark hash in super block: it could be unset. overwrite should be ok
@@ -1445,10 +1506,37 @@
 	reiserfs_proc_info_global_init();
 	reiserfs_proc_register_global( "version", 
 				       reiserfs_global_version_in_proc );
+
 	ret = reiserfs_journal_cache_init();
-	if (ret)
-	    return ret;
-        return register_filesystem(&reiserfs_fs_type);
+	if (ret) goto failed_reiserfs_journal_cache_init;
+
+	ret = reiserfs_xattr_cache_init();
+	if (ret) goto failed_xattr_cache_init;
+
+	ret = reiserfs_xattr_user_init();
+	if (ret) goto failed_xattr_user_init;
+
+	ret = reiserfs_xattr_trusted_init();
+	if (ret) goto failed_xattr_trusted_init;
+
+	ret = reiserfs_xattr_posix_acl_init();
+	if (ret) goto failed_xattr_posix_acl_init;
+
+	return register_filesystem(&reiserfs_fs_type);
+
+failed_xattr_posix_acl_init:
+	reiserfs_xattr_trusted_exit();
+failed_xattr_trusted_init:
+	reiserfs_xattr_user_exit();
+failed_xattr_user_init:
+	reiserfs_xattr_cache_exit();
+failed_xattr_cache_init:
+	/* reiserfs_journal_cache_exit(); */
+failed_reiserfs_journal_cache_init:
+
+	reiserfs_proc_unregister_global( "version" );
+	reiserfs_proc_info_global_done();
+	return ret;
 }
 
 MODULE_DESCRIPTION("ReiserFS journaled filesystem");
@@ -1457,6 +1545,10 @@
 
 static void __exit exit_reiserfs_fs(void)
 {
+        reiserfs_xattr_posix_acl_exit ();
+        reiserfs_xattr_trusted_exit ();
+        reiserfs_xattr_user_exit ();
+        reiserfs_xattr_cache_exit ();
 	reiserfs_proc_unregister_global( "version" );
 	reiserfs_proc_info_global_done();
         unregister_filesystem(&reiserfs_fs_type);
diff -urN zombi-a/fs/reiserfs/xattr_acl.c zombi-b/fs/reiserfs/xattr_acl.c
--- zombi-a/fs/reiserfs/xattr_acl.c	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/fs/reiserfs/xattr_acl.c	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,653 @@
+#include <linux/posix_acl.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/xattr_acl.h>
+#include <linux/reiserfs_xattr.h>
+#include <linux/reiserfs_acl.h>
+#include <asm/uaccess.h>
+
+static int
+xattr_set_acl(struct inode *inode, int type, const void *value, size_t size)
+{
+	struct posix_acl *acl;
+	int error;
+
+	if (!reiserfs_posixacl(inode->i_sb))
+		return -EOPNOTSUPP;
+	if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
+		return -EPERM;
+
+	if (value) {
+		acl = posix_acl_from_xattr(value, size);
+		if (IS_ERR(acl)) {
+			return PTR_ERR(acl);
+		} else if (acl) {
+			error = posix_acl_valid(acl);
+			if (error)
+				goto release_and_out;
+		}
+	} else
+		acl = NULL;
+
+	error = reiserfs_set_acl (inode, type, acl);
+
+release_and_out:
+	posix_acl_release(acl);
+	return error;
+}
+
+
+static int
+xattr_get_acl(struct inode *inode, int type, void *buffer, size_t size)
+{
+	struct posix_acl *acl;
+	int error;
+
+	if (!reiserfs_posixacl(inode->i_sb))
+		return -EOPNOTSUPP;
+
+	acl = reiserfs_get_acl (inode, type);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl == NULL)
+		return -ENODATA;
+	error = posix_acl_to_xattr(acl, buffer, size);
+	posix_acl_release(acl);
+
+	return error;
+}
+
+
+/*
+ * Convert from filesystem to in-memory representation.
+ */
+static struct posix_acl *
+posix_acl_from_disk(const void *value, size_t size)
+{
+	const char *end = (char *)value + size;
+	int n, count;
+	struct posix_acl *acl;
+
+	if (!value)
+		return NULL;
+	if (size < sizeof(reiserfs_acl_header))
+		 return ERR_PTR(-EINVAL);
+	if (((reiserfs_acl_header *)value)->a_version !=
+	    cpu_to_le32(REISERFS_ACL_VERSION))
+		return ERR_PTR(-EINVAL);
+	value = (char *)value + sizeof(reiserfs_acl_header);
+	count = reiserfs_acl_count(size);
+	if (count < 0)
+		return ERR_PTR(-EINVAL);
+	if (count == 0)
+		return NULL;
+	acl = posix_acl_alloc(count, GFP_NOFS);
+	if (!acl)
+		return ERR_PTR(-ENOMEM);
+	for (n=0; n < count; n++) {
+		reiserfs_acl_entry *entry =
+			(reiserfs_acl_entry *)value;
+		if ((char *)value + sizeof(reiserfs_acl_entry_short) > end)
+			goto fail;
+		acl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);
+		acl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);
+		switch(acl->a_entries[n].e_tag) {
+			case ACL_USER_OBJ:
+			case ACL_GROUP_OBJ:
+			case ACL_MASK:
+			case ACL_OTHER:
+				value = (char *)value +
+					sizeof(reiserfs_acl_entry_short);
+				acl->a_entries[n].e_id = ACL_UNDEFINED_ID;
+				break;
+
+			case ACL_USER:
+			case ACL_GROUP:
+				value = (char *)value + sizeof(reiserfs_acl_entry);
+				if ((char *)value > end)
+					goto fail;
+				acl->a_entries[n].e_id =
+					le32_to_cpu(entry->e_id);
+				break;
+
+			default:
+				goto fail;
+		}
+	}
+	if (value != end)
+		goto fail;
+	return acl;
+
+fail:
+	posix_acl_release(acl);
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * Convert from in-memory to filesystem representation.
+ */
+static void *
+posix_acl_to_disk(const struct posix_acl *acl, size_t *size)
+{
+	reiserfs_acl_header *ext_acl;
+	char *e;
+	int n;
+
+	*size = reiserfs_acl_size(acl->a_count);
+	ext_acl = (reiserfs_acl_header *)kmalloc(sizeof(reiserfs_acl_header) +
+		acl->a_count * sizeof(reiserfs_acl_entry), GFP_NOFS);
+	if (!ext_acl)
+		return ERR_PTR(-ENOMEM);
+	ext_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);
+	e = (char *)ext_acl + sizeof(reiserfs_acl_header);
+	for (n=0; n < acl->a_count; n++) {
+		reiserfs_acl_entry *entry = (reiserfs_acl_entry *)e;
+		entry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);
+		entry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);
+		switch(acl->a_entries[n].e_tag) {
+			case ACL_USER:
+			case ACL_GROUP:
+				entry->e_id =
+					cpu_to_le32(acl->a_entries[n].e_id);
+				e += sizeof(reiserfs_acl_entry);
+				break;
+
+			case ACL_USER_OBJ:
+			case ACL_GROUP_OBJ:
+			case ACL_MASK:
+			case ACL_OTHER:
+				e += sizeof(reiserfs_acl_entry_short);
+				break;
+
+			default:
+				goto fail;
+		}
+	}
+	return (char *)ext_acl;
+
+fail:
+	kfree(ext_acl);
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * Inode operation get_posix_acl().
+ *
+ * inode->i_sem: down
+ * BKL held [before 2.5.x]
+ */
+struct posix_acl *
+reiserfs_get_acl(struct inode *inode, int type)
+{
+	char *name, *value;
+	struct posix_acl *acl, **p_acl;
+	size_t size;
+	int retval;
+
+        switch (type) {
+            case ACL_TYPE_ACCESS:
+                name = XATTR_NAME_ACL_ACCESS;
+                p_acl = &inode->u.reiserfs_i.i_acl_access;
+                break;
+            case ACL_TYPE_DEFAULT:
+                name = XATTR_NAME_ACL_DEFAULT;
+                p_acl = &inode->u.reiserfs_i.i_acl_default;
+                break;
+            default:
+                return ERR_PTR (-EINVAL);
+        }
+
+        if (IS_ERR (*p_acl)) {
+            if (PTR_ERR (*p_acl) == -ENODATA)
+                return NULL;
+        } else if (*p_acl != NULL)
+            return posix_acl_dup (*p_acl);
+
+        size = reiserfs_xattr_get (inode, name, NULL, 0);
+        if ((int)size < 0) {
+            if (size == -ENODATA || size == -ENOSYS) {
+		*p_acl = ERR_PTR (-ENODATA);
+		return NULL;
+            }
+            return ERR_PTR (size);
+        }
+
+        value = kmalloc (size, GFP_NOFS);
+        if (!value)
+            return ERR_PTR (-ENOMEM);
+
+	retval = reiserfs_xattr_get(inode, name, value, size);
+	if (retval == -ENODATA || retval == -ENOSYS) {
+		/* This shouldn't actually happen as it should have
+		   been caught above.. but just in case */
+		acl = NULL;
+		*p_acl = ERR_PTR (-ENODATA);
+        } else if (retval < 0) {
+		acl = ERR_PTR(retval);
+	} else {
+		acl = posix_acl_from_disk(value, retval);
+		*p_acl = posix_acl_dup (acl);
+        }
+
+	kfree(value);
+	return acl;
+}
+
+/*
+ * Inode operation set_posix_acl().
+ *
+ * inode->i_sem: down
+ * BKL held [before 2.5.x]
+ */
+int
+reiserfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)
+{
+        char *name;
+	void *value = NULL;
+	struct posix_acl **p_acl;
+	size_t size;
+	int error;
+
+	if (S_ISLNK(inode->i_mode))
+		return -EOPNOTSUPP;
+
+
+        switch (type) {
+            case ACL_TYPE_ACCESS:
+                name = XATTR_NAME_ACL_ACCESS;
+                p_acl = &inode->u.reiserfs_i.i_acl_access;
+                if (acl) {
+                    mode_t mode = inode->i_mode;
+                    error = posix_acl_equiv_mode (acl, &mode);
+                    if (error < 0)
+                        return error;
+                    else {
+                        inode->i_mode = mode;
+                        if (error == 0)
+                            acl = NULL;
+                    }
+                }
+                break;
+            case ACL_TYPE_DEFAULT:
+                name = XATTR_NAME_ACL_DEFAULT;
+                p_acl = &inode->u.reiserfs_i.i_acl_default;
+                if (!S_ISDIR (inode->i_mode))
+                    return acl ? -EACCES : 0;
+                break;
+            default:
+                return -EINVAL;
+        }
+
+ 	if (acl) {
+            value = posix_acl_to_disk(acl, &size);
+            if (IS_ERR(value))
+                return (int)PTR_ERR(value);
+            error = reiserfs_xattr_set(inode, name, value, size, 0);
+	} else {
+            error = reiserfs_xattr_del (inode, name);
+            if (error == -ENODATA)
+                error = 0;
+        }
+
+	if (value)
+		kfree(value);
+
+        if (!error) {
+            /* Release the old one */
+            if (!IS_ERR (*p_acl) && *p_acl)
+                posix_acl_release (*p_acl);
+
+            if (acl == NULL)
+                *p_acl = ERR_PTR (-ENODATA);
+            else 
+                *p_acl = posix_acl_dup (acl);
+        }
+
+	return error;
+}
+
+/* dir->i_sem: down,
+ * inode is new and not released into the wild yet */
+int
+reiserfs_inherit_default_acl (struct inode *dir, struct dentry *dentry, struct inode *inode)
+{
+    struct posix_acl *acl;
+    int err = 0;
+
+    /* ACLs only get applied to files and directories */
+    if (S_ISLNK (inode->i_mode))
+        return 0;
+
+    /* ACLs can only be used on "new" objects, so if it's an old object
+     * there is nothing to inherit from */
+    if (get_inode_sd_version (dir) == STAT_DATA_V1)
+        goto apply_umask;
+
+    /* Don't apply ACLs to objects in the .reiserfs_priv tree.. This
+     * would be useless since permissions are ignored, and a pain because
+     * it introduces locking cycles */
+    if (is_reiserfs_priv_object (dir)) {
+        inode->u.reiserfs_i.i_flags |= i_priv_object;
+        goto apply_umask;
+    }
+
+    acl = reiserfs_get_acl (dir, ACL_TYPE_DEFAULT);
+    if (IS_ERR (acl)) {
+        if (PTR_ERR (acl) == -ENODATA)
+            goto apply_umask;
+        return PTR_ERR (acl);
+    }
+
+    if (acl) {
+        struct posix_acl *acl_copy;
+        mode_t mode = inode->i_mode;
+        int need_acl;
+
+        /* Copy the default ACL to the default ACL of a new directory */
+        if (S_ISDIR (inode->i_mode)) {
+            err = reiserfs_set_acl (inode, ACL_TYPE_DEFAULT, acl);
+            if (err)
+                goto cleanup;
+        }
+
+        /* Now we reconcile the new ACL and the mode,
+           potentially modifying both */
+        acl_copy = posix_acl_clone (acl, GFP_NOFS);
+        if (!acl_copy) {
+            err = -ENOMEM;
+            goto cleanup;
+        }
+
+
+        need_acl = posix_acl_create_masq (acl_copy, &mode);
+        if (need_acl >= 0) {
+            if (mode != inode->i_mode) {
+                inode->i_mode = mode;
+            }
+
+            /* If we need an ACL.. */
+            if (need_acl > 0) {
+                err = reiserfs_set_acl (inode, ACL_TYPE_ACCESS, acl_copy);
+                if (err) 
+                    goto cleanup_copy;
+            }
+        }
+cleanup_copy:
+        posix_acl_release (acl_copy);
+cleanup:
+        posix_acl_release (acl);
+    } else {
+apply_umask:
+        /* no ACL, apply umask */
+        inode->i_mode &= ~current->fs->umask;
+    }
+
+    return err;
+}
+
+/* Looks up and caches the result of the default ACL.
+ * We do this so that we don't need to carry the xattr_sem into
+ * reiserfs_new_inode if we don't need to */
+int
+reiserfs_cache_default_acl (struct inode *inode)
+{
+    int ret = 0;
+    if (reiserfs_posixacl (inode->i_sb) &&
+        !is_reiserfs_priv_object (inode)) {
+        struct posix_acl *acl;
+        reiserfs_read_lock_xattrs (inode->i_sb);
+        acl = reiserfs_get_acl (inode, ACL_TYPE_DEFAULT);
+        reiserfs_read_unlock_xattrs (inode->i_sb);
+        ret = acl ? 1 : 0;
+        posix_acl_release (acl);
+    }
+
+    return ret;
+}
+
+static int
+__reiserfs_permission (struct inode *inode, int mask, int need_lock)
+{
+	int mode = inode->i_mode;
+
+	/* Nobody gets write access to a read-only fs */
+	if ((mask & MAY_WRITE) && IS_RDONLY(inode) &&
+	    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+		return -EROFS;
+
+	/* Nobody gets write access to an immutable file */
+	if ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))
+	    return -EACCES;
+
+        /* We don't do permission checks on the internal objects.
+         * Permissions are determined by the "owning" object. */
+        if (is_reiserfs_priv_object (inode))
+            return 0;
+
+	if (current->fsuid == inode->i_uid) {
+		mode >>= 6;
+	} else if (reiserfs_posixacl(inode->i_sb) &&
+                   get_inode_sd_version (inode) != STAT_DATA_V1) {
+                struct posix_acl *acl;
+
+		/* ACL can't contain additional permissions if
+		   the ACL_MASK entry is 0 */
+		if (!(mode & S_IRWXG))
+			goto check_groups;
+
+                if (need_lock)
+                    reiserfs_read_lock_xattrs (inode->i_sb);
+                acl = reiserfs_get_acl (inode, ACL_TYPE_ACCESS);
+                if (need_lock)
+                    reiserfs_read_unlock_xattrs (inode->i_sb);
+                if (IS_ERR (acl)) {
+                    if (PTR_ERR (acl) == -ENODATA)
+                        goto check_groups;
+                    return PTR_ERR (acl);
+                }
+
+                if (acl) {
+                    int err = posix_acl_permission (inode, acl, mask);
+                    posix_acl_release (acl);
+                    if (err == -EACCES) {
+                        goto check_capabilities;
+                    }
+                    return err;
+		} else {
+			goto check_groups;
+                }
+
+	} else {
+check_groups:
+		if (in_group_p(inode->i_gid))
+			mode >>= 3;
+	}
+	if ((mode & mask & S_IRWXO) == mask)
+		return 0;
+
+check_capabilities:
+       /* Allowed to override Discretionary Access Control? */
+        if ((mask & (MAY_READ|MAY_WRITE)) || (inode->i_mode & S_IXUGO))
+                if (capable(CAP_DAC_OVERRIDE))
+                        return 0;
+        /* Read and search granted if capable(CAP_DAC_READ_SEARCH) */
+        if (capable(CAP_DAC_READ_SEARCH) && ((mask == MAY_READ) ||
+            (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE))))
+                return 0;
+	return -EACCES;
+}
+
+int
+reiserfs_permission (struct inode *inode, int mask)
+{
+    return __reiserfs_permission (inode, mask, 1);
+}
+
+int
+reiserfs_permission_locked (struct inode *inode, int mask)
+{
+    return __reiserfs_permission (inode, mask, 0);
+}
+
+int
+reiserfs_acl_chmod (struct inode *inode)
+{
+        struct posix_acl *acl, *clone;
+        int error;
+
+        if (S_ISLNK(inode->i_mode))
+                return -EOPNOTSUPP;
+
+	if (get_inode_sd_version (inode) == STAT_DATA_V1 ||
+	    !reiserfs_posixacl(inode->i_sb))
+        {
+	    return 0;
+	}
+
+        reiserfs_read_lock_xattrs (inode->i_sb);
+        acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
+        reiserfs_read_unlock_xattrs (inode->i_sb);
+        if (!acl)
+                return 0;
+        if (IS_ERR(acl))
+                return PTR_ERR(acl);
+        clone = posix_acl_clone(acl, GFP_NOFS);
+        posix_acl_release(acl);
+        if (!clone)
+                return -ENOMEM;
+        error = posix_acl_chmod_masq(clone, inode->i_mode);
+        if (!error) {
+                reiserfs_write_lock_xattrs (inode->i_sb);
+                error = reiserfs_set_acl(inode, ACL_TYPE_ACCESS, clone);
+                reiserfs_write_unlock_xattrs (inode->i_sb);
+        }
+        posix_acl_release(clone);
+        return error;
+}
+
+static int
+posix_acl_access_get(struct inode *inode, const char *name,
+			  void *buffer, size_t size)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+		return -EINVAL;
+	return xattr_get_acl(inode, ACL_TYPE_ACCESS, buffer, size);
+}
+
+static int
+posix_acl_access_set(struct inode *inode, const char *name,
+			  const void *value, size_t size, int flags)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+		return -EINVAL;
+	return xattr_set_acl(inode, ACL_TYPE_ACCESS, value, size);
+}
+
+static int
+posix_acl_access_del (struct inode *inode, const char *name)
+{
+    struct posix_acl **acl = &inode->u.reiserfs_i.i_acl_access;
+    if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+	return -EINVAL;
+    if (!IS_ERR (*acl) && *acl) {
+        posix_acl_release (*acl);
+        *acl = ERR_PTR (-ENODATA);
+    }
+
+    return 0;
+}
+
+static int
+posix_acl_access_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_posixacl (inode->i_sb))
+        return 0;
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+struct reiserfs_xattr_handler posix_acl_access_handler = {
+    prefix: XATTR_NAME_ACL_ACCESS,
+    get: posix_acl_access_get,
+    set: posix_acl_access_set,
+    del: posix_acl_access_del,
+    list: posix_acl_access_list,
+};
+
+static int
+posix_acl_default_get (struct inode *inode, const char *name,
+			   void *buffer, size_t size)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+		return -EINVAL;
+	return xattr_get_acl(inode, ACL_TYPE_DEFAULT, buffer, size);
+}
+
+static int
+posix_acl_default_set(struct inode *inode, const char *name,
+			   const void *value, size_t size, int flags)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+		return -EINVAL;
+	return xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
+}
+
+static int
+posix_acl_default_del (struct inode *inode, const char *name)
+{
+    struct posix_acl **acl = &inode->u.reiserfs_i.i_acl_default;
+    if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+	return -EINVAL;
+    if (!IS_ERR (*acl) && *acl) {
+        posix_acl_release (*acl);
+        *acl = ERR_PTR (-ENODATA);
+    }
+
+    return 0;
+}
+
+static int
+posix_acl_default_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_posixacl (inode->i_sb))
+        return 0;
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+struct reiserfs_xattr_handler posix_acl_default_handler = {
+    prefix: XATTR_NAME_ACL_DEFAULT,
+    get: posix_acl_default_get,
+    set: posix_acl_default_set,
+    del: posix_acl_default_del,
+    list: posix_acl_default_list,
+};
+
+int __init
+reiserfs_xattr_posix_acl_init (void)
+{
+    int err;
+    err = reiserfs_xattr_register_handler (&posix_acl_access_handler);
+    if (!err)
+        err = reiserfs_xattr_register_handler (&posix_acl_default_handler);
+    return err;
+}
+
+int
+reiserfs_xattr_posix_acl_exit (void)
+{
+    int err;
+    err = reiserfs_xattr_unregister_handler (&posix_acl_access_handler);
+    if (!err)
+        err = reiserfs_xattr_unregister_handler (&posix_acl_default_handler);
+    return err;
+}
diff -urN zombi-a/fs/reiserfs/xattr.c zombi-b/fs/reiserfs/xattr.c
--- zombi-a/fs/reiserfs/xattr.c	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/fs/reiserfs/xattr.c	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,1665 @@
+/*
+ * linux/fs/reiserfs/xattr.c
+ *
+ * Copyright (c) 2002 by Jeff Mahoney, <jeffm@suse.com>
+ *
+ */
+
+/*
+ * In order to implement EA/ACLs in a clean, backwards compatible manner,
+ * they are implemented as files in a "private" directory.
+ * Each EA is in it's own file, with the directory layout like so (/ is assumed
+ * to be relative to fs root). Inside the /.reiserfs_priv/xattrs directory,
+ * directories named using the capital-hex form of the objectid and
+ * generation number are used. Inside each directory are individual files
+ * named with the name of the extended attribute.
+ *
+ * So, for objectid 12648430, we could have:
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_access
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_default
+ * /.reiserfs_priv/xattrs/C0FFEE.0/user.Content-Type
+ * .. or similar.
+ *
+ * The file contents are the text of the EA. The size is known based on the
+ * stat data describing the file.
+ *
+ * In the case of system.posix_acl_access and system.posix_acl_default, since
+ * these are special cases for filesystem ACLs, they are interpreted by the
+ * kernel, in addition, they are negatively and positively cached and attached
+ * to the inode so that unnecessary lookups are avoided.
+ */
+
+#include <linux/reiserfs_fs.h>
+#include <linux/dcache.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <linux/mbcache.h>
+#include <asm/uaccess.h>
+#include <asm/checksum.h>
+#include <linux/smp_lock.h>
+#include <linux/stat.h>
+#include <asm/semaphore.h>
+
+#define FL_READONLY 128
+#define FL_DIR_SEM_HELD 256
+#define PRIVROOT_NAME ".reiserfs_priv"
+#define XAROOT_NAME   "xattrs"
+
+#ifdef CONFIG_REISERFS_FS_XATTR_SHARING
+# error "xattr sharing is not fully implemented and buggy. DO NOT USE."
+static int reiserfs_xattr_link_to_inode (struct inode *xattr_inode,
+                                         struct inode *dst_inode,
+                                         const char *dst_name);
+#endif
+
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix (const char *prefix);
+
+/* Return a dentry (or NULL) for the root of the reiserfs-private directory.
+ * The "xattrs" directory is contained here, as may other things in the future
+ */
+static struct dentry *
+reiserfs_get_priv_root (struct super_block *s)
+{
+    struct dentry *dentry = NULL;
+    struct qstr privroot;
+    int retval;
+    struct reiserfs_dir_entry de;
+    INITIALIZE_PATH (path);
+
+    privroot.name = PRIVROOT_NAME;
+    privroot.len = strlen (privroot.name);
+
+    de.de_gen_number_bit_string = 0;
+    retval = reiserfs_find_entry (s->s_root->d_inode, privroot.name,
+                                  privroot.len, &path, &de);
+    pathrelse (&path);
+    if (retval == NAME_FOUND) {
+        struct inode *inode;
+        inode = reiserfs_iget (s, (struct cpu_key *)&(de.de_dir_id));
+
+        /* We don't want this entry hashed. Otherwise, we can't
+         * poison lookup() and readdir() against it */
+        if (inode && !IS_ERR (inode)) {
+            privroot.hash = full_name_hash (privroot.name, privroot.len);
+            dentry = d_alloc (s->s_root, &privroot);
+
+            if (dentry)
+                d_instantiate (dentry, inode);
+            inode->u.reiserfs_i.i_flags |= i_priv_object;
+        }
+    }
+
+    return dentry;
+}
+
+
+static struct dentry *
+reiserfs_create_priv_root (struct super_block *sb)
+{
+    int ret;
+    struct inode *inode = sb->s_root->d_inode;
+    struct dentry *privroot;
+    struct qstr xa;
+
+    xa.name = PRIVROOT_NAME;
+    xa.len = strlen (xa.name);
+    xa.hash = full_name_hash (xa.name, xa.len);
+    privroot = d_alloc (sb->s_root, &xa);
+    if (!privroot)
+        return ERR_PTR (-ENOMEM);
+
+    down (&inode->i_sem);
+    ret = inode->i_op->mkdir (inode, privroot, 0700);
+    up (&inode->i_sem);
+
+    if (ret) {
+        dput (privroot);
+        return ERR_PTR (ret);
+    }
+
+    if (privroot->d_inode) {
+        reiserfs_warning ("reiserfs: Created %s on %s - reserved for "
+                          "xattr storage.\n", PRIVROOT_NAME, 
+                          bdevname (sb->s_dev));
+        privroot->d_inode->u.reiserfs_i.i_flags |= i_priv_object;
+        d_drop (privroot);
+    }
+    return privroot;
+}
+
+static struct dentry *
+create_xa_root (struct super_block *sb)
+{
+    struct dentry *privroot = dget (sb->u.reiserfs_sb.priv_root);
+    struct dentry *xaroot;
+
+    /* This needs to be created at mount-time */
+    if (!privroot)
+        return ERR_PTR(-EOPNOTSUPP);
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        int err;
+        down (&privroot->d_inode->i_sem);
+        err = privroot->d_inode->i_op->mkdir (privroot->d_inode, xaroot, 0700);
+        up (&privroot->d_inode->i_sem);
+
+        if (err) {
+            dput (xaroot);
+            dput (privroot);
+            return ERR_PTR (err);
+        }
+        sb->u.reiserfs_sb.xattr_root = dget (xaroot);
+    }
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* This will return a dentry, or error, refering to the xa root directory.
+ * If the xa root doesn't exist yet, the dentry will be returned without
+ * an associated inode. This dentry can be used with ->mkdir to create
+ * the xa directory. */
+static struct dentry *
+__get_xa_root (struct super_block *s)
+{
+    struct dentry *privroot = dget (s->u.reiserfs_sb.priv_root);
+    struct dentry *xaroot = NULL;
+
+    if (IS_ERR (privroot) || !privroot)
+        return privroot;
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        dput (xaroot);
+        xaroot = NULL;
+        goto out;
+    }
+
+    s->u.reiserfs_sb.xattr_root = dget (xaroot);
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* Returns the dentry (or NULL) referring to the root of the extended
+ * attribute directory tree. If it has already been retreived, it is used.
+ * Otherwise, we attempt to retreive it from disk. It may also return
+ * a pointer-encoded error.
+ */
+static inline struct dentry *
+get_xa_root (struct super_block *s)
+{
+    struct dentry *dentry = s->u.reiserfs_sb.xattr_root;
+
+    if (!dentry)
+        dentry = __get_xa_root (s);
+    else
+        dget (dentry);
+    return dentry;
+}
+
+/* Same as above, but only returns a valid dentry or NULL */
+struct dentry *
+reiserfs_get_xa_root (struct super_block *sb)
+{
+    struct dentry *dentry;
+
+    dentry = get_xa_root (sb);
+    if (IS_ERR (dentry)) {
+        dentry = NULL;
+    } else if (dentry && !dentry->d_inode) {
+        dput (dentry);
+        dentry = NULL;
+    }
+
+    return dentry;
+}
+
+/* Opens the directory corresponding to the inode's extended attribute store.
+ * If flags allow, the tree to the directory may be created. If creation is
+ * prohibited, -ENODATA is returned. */
+static struct dentry *
+open_xa_dir (const struct inode *inode, int flags)
+{
+    struct dentry *xaroot, *xadir;
+    char namebuf[17];
+
+    xaroot = get_xa_root (inode->i_sb);
+    if (IS_ERR (xaroot)) {
+        return xaroot;
+    } else if (!xaroot) {
+        if (flags == 0 || flags & XATTR_CREATE) {
+            xaroot = create_xa_root (inode->i_sb);
+            if (IS_ERR (xaroot))
+                return xaroot;
+        }
+        if (!xaroot)
+            return ERR_PTR (-ENODATA);
+    }
+
+    /* ok, we have xaroot open */
+
+    snprintf (namebuf, sizeof (namebuf), "%X.%X",
+              le32_to_cpu (INODE_PKEY (inode)->k_objectid),
+              inode->i_generation);
+    xadir = lookup_one_len (namebuf, xaroot, strlen (namebuf));
+    if (IS_ERR (xadir)) {
+        dput (xaroot);
+        return xadir;
+    }
+    
+    if (!xadir->d_inode) {
+        int err;
+        if (flags == 0 || flags & XATTR_CREATE) {
+            /* Although there is nothing else trying to create this directory,
+             * another directory with the same hash may be created, so we need
+             * to protect against that */
+            err = xaroot->d_inode->i_op->mkdir (xaroot->d_inode, xadir, 0700);
+            if (err) {
+                dput (xaroot);
+                dput (xadir);
+                return ERR_PTR (err);
+            }
+        }
+        if (!xadir->d_inode) {
+            dput (xaroot);
+            dput (xadir);
+            return ERR_PTR (-ENODATA);
+        }
+    }
+
+    dput (xaroot);
+    return xadir;
+}
+
+/* Returns a dentry corresponding to a specific extended attribute file
+ * for the inode. If flags allow, the file is created. Otherwise, a
+ * valid or negative dentry, or an error is returned. */
+static struct dentry *
+get_xa_file_dentry (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xadir, *xafile;
+    int err = 0;
+
+    xadir = open_xa_dir (inode, flags);
+    if (IS_ERR (xadir)) {
+        return ERR_PTR (PTR_ERR (xadir));
+    } else if (xadir && !xadir->d_inode) {
+        dput (xadir);
+        return ERR_PTR (-ENODATA);
+    }
+
+    xafile = lookup_one_len (name, xadir, strlen (name));
+    if (IS_ERR (xafile)) {
+        dput (xadir);
+        return ERR_PTR (PTR_ERR (xafile));
+    }
+
+    if (xafile->d_inode) { /* file exists */
+        if (flags & XATTR_CREATE) {
+            err = -EEXIST;
+            dput (xafile);
+            goto out;
+        }
+    } else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
+        goto out;
+    } else {
+        /* inode->i_sem is down, so nothing else can try to create
+         * the same xattr */
+        err = xadir->d_inode->i_op->create (xadir->d_inode, xafile,
+                                            0700|S_IFREG);
+
+        if (err) {
+            dput (xafile);
+            goto out;
+        }
+    }
+
+out:
+    dput (xadir);
+    if (err)
+        xafile = ERR_PTR (err);
+    return xafile;
+}
+
+
+/* Opens a file pointer to the attribute associated with inode */
+static struct file *
+open_xa_file (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xafile;
+    struct file *fp;
+
+    xafile = get_xa_file_dentry (inode, name, flags);
+    if (IS_ERR (xafile))
+        return ERR_PTR (PTR_ERR (xafile));
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return ERR_PTR (-ENODATA);
+    }
+
+    fp = dentry_open (xafile, NULL, O_RDWR);
+    /* dentry_open dputs the dentry if it fails */
+
+    return fp;
+}
+
+
+/*
+ * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
+ * we need to drop the path before calling the filldir struct.  That
+ * would be a big performance hit to the non-xattr case, so I've copied
+ * the whole thing for now. --clm
+ *
+ * the big difference is that I go backwards through the directory, 
+ * and don't mess with f->f_pos, but the idea is the same.  Do some
+ * action on each and every entry in the directory.
+ *
+ * we're called with i_sem held, so there are no worries about the directory
+ * changing underneath us.
+ */
+static int __xattr_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+    struct inode *inode = filp->f_dentry->d_inode;
+    struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
+    INITIALIZE_PATH (path_to_entry);
+    struct buffer_head * bh;
+    int entry_num;
+    struct item_head * ih, tmp_ih;
+    int search_res;
+    char * local_buf;
+    loff_t next_pos;
+    char small_buf[32] ; /* avoid kmalloc if we can */
+    struct reiserfs_de_head *deh;
+    int d_reclen;
+    char * d_name;
+    off_t d_off;
+    ino_t d_ino;
+    struct reiserfs_dir_entry de;
+
+
+    /* form key for search the next directory entry using f_pos field of
+       file structure */
+    next_pos = max_reiserfs_offset(inode);
+
+    while (1) {
+research:
+	if (next_pos <= DOT_DOT_OFFSET)
+	    break;
+	make_cpu_key (&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
+
+	search_res = search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry, &de);
+	if (search_res == IO_ERROR) {
+	    // FIXME: we could just skip part of directory which could
+	    // not be read
+	    pathrelse(&path_to_entry);
+	    return -EIO;
+	}
+
+	if (search_res == NAME_NOT_FOUND)
+	    de.de_entry_num--;
+
+	set_de_name_and_namelen(&de);
+	entry_num = de.de_entry_num;
+	deh = &(de.de_deh[entry_num]);
+
+	bh = de.de_bh;
+	ih = de.de_ih;
+
+	if (!is_direntry_le_ih(ih)) {
+reiserfs_warning("not direntry %h\n", ih);
+	    break;
+        }
+	copy_item_head(&tmp_ih, ih);
+		
+	/* we must have found item, that is item of this directory, */
+	RFALSE( COMP_SHORT_KEYS (&(ih->ih_key), &pos_key),
+		"vs-9000: found item %h does not match to dir we readdir %K",
+		ih, &pos_key);
+
+	if (deh_offset(deh) <= DOT_DOT_OFFSET) {
+	    break;
+	}
+
+	/* look for the previous entry in the directory */
+	next_pos = deh_offset (deh) - 1;
+
+	if (!de_visible (deh))
+	    /* it is hidden entry */
+	    continue;
+
+	d_reclen = entry_length(bh, ih, entry_num);
+	d_name = B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh);
+	d_off = deh_offset (deh);
+	d_ino = deh_objectid (deh);
+
+	if (!d_name[d_reclen - 1])
+	    d_reclen = strlen (d_name);
+
+	if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)){
+	    /* too big to send back to VFS */
+	    continue ;
+	}
+
+        /* Ignore the .reiserfs_priv entry */
+        if (reiserfs_xattrs (inode->i_sb) && 
+            !old_format_only(inode->i_sb) &&
+            deh_objectid (deh) == le32_to_cpu (INODE_PKEY(inode->i_sb->u.reiserfs_sb.priv_root->d_inode)->k_objectid))
+          continue;
+
+	if (d_reclen <= 32) {
+	  local_buf = small_buf ;
+	} else {
+	    local_buf = reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb) ;
+	    if (!local_buf) {
+		pathrelse (&path_to_entry);
+		return -ENOMEM ;
+	    }
+	    if (item_moved (&tmp_ih, &path_to_entry)) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+
+		/* sigh, must retry.  Do this same offset again */
+		next_pos = d_off;
+		goto research;
+	    }
+	}
+
+	// Note, that we copy name to user space via temporary
+	// buffer (local_buf) because filldir will block if
+	// user space buffer is swapped out. At that time
+	// entry can move to somewhere else
+	memcpy (local_buf, d_name, d_reclen);
+
+	/* the filldir function might need to start transactions,
+	 * or do who knows what.  Release the path now that we've
+	 * copied all the important stuff out of the deh
+	 */
+	pathrelse (&path_to_entry);
+
+	if (filldir (dirent, local_buf, d_reclen, d_off, d_ino, 
+		     DT_UNKNOWN) < 0) {
+	    if (local_buf != small_buf) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	    }
+	    goto end;
+	}
+	if (local_buf != small_buf) {
+	    reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	}
+    } /* while */
+
+end:
+    pathrelse (&path_to_entry);
+    return 0;
+}
+
+/* 
+ * this could be done with dedicated readdir ops for the xattr files,
+ * but I want to get something working asap
+ * this is stolen from vfs_readdir
+ *
+ */
+static
+int xattr_readdir(struct file *file, filldir_t filler, void *buf)
+{
+        struct inode *inode = file->f_dentry->d_inode;
+        int res = -ENOTDIR;
+        if (!file->f_op || !file->f_op->readdir)
+                goto out;
+        down(&inode->i_sem);
+        down(&inode->i_zombie);
+        res = -ENOENT;
+        if (!IS_DEADDIR(inode)) {
+                lock_kernel();
+                res = __xattr_readdir(file, buf, filler);
+                unlock_kernel();
+        }
+        up(&inode->i_zombie);
+        up(&inode->i_sem);
+out:
+        return res;
+}
+
+
+/* Internal operations on file data */
+static inline void
+reiserfs_put_page(struct page *page)
+{
+        kunmap(page);
+        page_cache_release(page);
+}
+
+static struct page *
+reiserfs_get_page(struct inode *dir, unsigned long n)
+{
+        struct address_space *mapping = dir->i_mapping; 
+        struct page *page;
+        /* We can deadlock if we try to free dentries,
+           and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+        mapping->gfp_mask = GFP_NOFS;
+        page = read_cache_page (mapping, n,
+                                (filler_t*)mapping->a_ops->readpage, NULL);
+        if (!IS_ERR(page)) {
+                wait_on_page(page);
+                kmap(page);
+                if (!Page_Uptodate(page))
+                        goto fail;
+/*
+                if (!PageChecked(page))
+                        ext2_check_page(page);
+*/
+                if (PageError(page))
+                        goto fail;
+        }
+        return page;
+
+fail:
+        reiserfs_put_page(page);
+        return ERR_PTR(-EIO);
+}
+
+static inline __u32
+xattr_hash (const char *msg, int len)
+{
+    return csum_partial (msg, len, 0);
+}
+
+
+
+/* Cache handling */
+#if 0 /* def CONFIG_REISERFS_FS_XATTR_SHARING */
+static struct mb_cache *reiserfs_xattr_cache;
+
+static void
+xa_cache_free_entry (struct mb_cache_entry *ce)
+{
+    struct inode *inode;
+    if (!ce)
+        return;
+
+    inode = (struct inode *)ce->e_block;
+    if (inode) /* inode may not be set if this is called in an error case */
+        iput (inode);
+}
+
+static struct mb_cache_op reiserfs_xa_cache_ops = {
+    xa_cache_free_entry
+};
+
+int __init
+reiserfs_xattr_cache_init (void)
+{
+    reiserfs_xattr_cache = mb_cache_create ("reiser_xa_cache",
+                                           &reiserfs_xa_cache_ops,
+                                           sizeof (struct mb_cache_entry) +
+                                           sizeof (struct mb_cache_entry_index),
+                                           1, 61);
+    if (!reiserfs_xattr_cache)
+        return -ENOMEM;
+
+    return 0;
+}
+
+void
+reiserfs_xattr_cache_exit (void)
+{
+    if (reiserfs_xattr_cache)
+        mb_cache_destroy (reiserfs_xattr_cache);
+}
+
+void
+reiserfs_xattr_cache_clear (kdev_t dev)
+{
+    if (reiserfs_xattr_cache)
+        mb_cache_shrink (reiserfs_xattr_cache, dev);
+}
+
+static struct inode *
+xa_cache_lookup (struct inode *inode, __u32 hash)
+{
+    struct mb_cache_entry *ce;
+    struct inode *xattr_inode;
+
+    if (!reiserfs_xattr_cache)
+        return NULL;
+
+    ce = mb_cache_entry_find_first (reiserfs_xattr_cache, 0,
+                                    inode->i_dev, hash);
+    while (ce) {
+        struct inode *xattr_inode = (struct inode *)ce->e_block;
+        if (!xattr_inode) {
+            ce = mb_cache_entry_find_next (ce, 0, inode->i_dev, hash);
+            continue;
+        }
+        if (xattr_inode->i_uid == inode->i_uid &&
+            xattr_inode->i_gid == inode->i_gid) {
+                break;
+        }
+        ce = mb_cache_entry_find_next (ce, 0, inode->i_dev, hash);
+    }
+
+    if (!ce)
+        return NULL;
+
+    xattr_inode = (struct inode *)ce->e_block;
+    mb_cache_entry_release (ce);
+
+    if (xattr_inode)
+        return igrab (xattr_inode);
+    else
+        return NULL;
+}
+
+/* We don't actually care about the errors since if it's not inserted,
+ * we clean up after ourselves.. and then xa_cache_lookup just fails causing
+ * a lookup. Performance loss, not corruption. */
+static int
+xa_cache_insert (struct inode *xattr_inode, __u32 hash)
+{
+    struct mb_cache_entry *ce;
+    int error;
+    struct inode *inode = igrab (xattr_inode);
+    if (!reiserfs_xattr_cache)
+        return 0;
+
+    if (!inode)
+        return -ENOENT;
+
+    ce = mb_cache_entry_alloc (reiserfs_xattr_cache);
+    if (!ce)
+        return -ENOMEM;
+
+    ce->e_block = 0;
+    error = mb_cache_entry_insert (ce, xattr_inode->i_dev,
+                                   (unsigned long)xattr_inode, &hash);
+    if (error) {
+        mb_cache_entry_free (ce);
+        if (error == -EBUSY)
+            error = 0; /* if it's already there, it's ok */
+    } else
+        mb_cache_entry_release (ce);
+
+    return error;
+}
+
+static void
+xa_cache_remove (struct inode *xattr_inode)
+{
+    struct mb_cache_entry *ce;
+    if (!reiserfs_xattr_cache)
+        return;
+
+    ce = mb_cache_entry_get (reiserfs_xattr_cache, xattr_inode->i_dev,
+                             (unsigned long) xattr_inode);
+    if (ce)
+        mb_cache_entry_free (ce);
+
+    /* we would do an iput() here, but cache_ops->free takes care of that */
+}
+
+#else
+# define xa_cache_insert(inode, hash) while(0) {}
+# define xa_cache_lookup(inode, hash) (NULL)
+# define xa_cache_remove(inode) while(0) {}
+#endif
+
+/* Generic extended attribute operations that can be used by xa plugins */
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_set (struct inode *inode, const char *name, const void *buffer,
+                    size_t buffer_size, int flags)
+{
+    int err = 0;
+    struct file *fp;
+    struct page *page;
+    char *data;
+    struct address_space *mapping;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct inode *xinode;
+    struct iattr newattrs;
+    __u32 xahash = 0;
+#if 0 /* def CONFIG_REISERFS_FS_XATTR_SHARING */
+    struct dentry *xafile;
+    struct inode *link = NULL;
+#endif
+
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    /* Empty xattrs are ok, they're just empty files, no hash */
+    if (buffer && buffer_size)
+        xahash = xattr_hash (buffer, buffer_size);
+
+#if 0 /* def CONFIG_REISERFS_FS_XATTR_SHARING */
+    link = xa_cache_lookup (inode, xahash);
+    xafile = get_xa_file_dentry (inode, name, FL_READONLY);
+
+    if (IS_ERR (xafile) && PTR_ERR (xafile) != -ENODATA) {
+        if (link)
+            iput (link);
+        return PTR_ERR (xafile);
+    }
+
+    if (link) { /* Ok, we found a hit for the contents */
+        if (!IS_ERR (xafile) && xafile->d_inode && xafile->d_inode == link) {
+            /* nothing to do, we're not changing the contents */
+            iput (link);
+            dput (xafile);
+            return 0;
+        } else if (!IS_ERR (xafile) && xafile->d_inode) {
+            /* unlink the old file, since we're linking to a new one */
+            err = reiserfs_xattr_del (inode, name);
+            if (err) {
+                iput (link);
+                dput (xafile);
+                return err;
+            }
+        }
+        dput (xafile);
+        err = reiserfs_xattr_link_to_inode (link, inode, name);
+        iput (link);
+        return err;
+    }
+#endif
+
+open_file:
+    fp = open_xa_file (inode, name, flags);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+
+    /* we need to copy it off.. */
+    if (xinode->i_nlink > 1) {
+	fput(fp);
+        err = reiserfs_xattr_del (inode, name);
+        if (err < 0)
+            goto out;
+        /* We just killed the old one, we're not replacing anymore */
+        if (flags & XATTR_REPLACE)
+            flags &= ~XATTR_REPLACE;
+        goto open_file;
+    }
+
+    /* Resize it so we're ok to write there */
+    newattrs.ia_size = buffer_size;
+    newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+    down (&xinode->i_sem);
+    err = notify_change(fp->f_dentry, &newattrs);
+    if (err)
+        goto out_filp;
+
+    mapping = xinode->i_mapping;
+    while (buffer_pos < buffer_size || buffer_pos == 0) {
+        size_t chunk;
+        size_t skip = 0;
+        size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+        if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = buffer_size - buffer_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_filp;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            if (chunk + skip > PAGE_CACHE_SIZE)
+                chunk = PAGE_CACHE_SIZE - skip;
+            rxh = (struct reiserfs_xattr_header *)data;
+            rxh->h_magic = cpu_to_le32 (REISERFS_XATTR_MAGIC);
+            rxh->h_hash = cpu_to_le32 (xahash);
+        }
+
+        err = mapping->a_ops->prepare_write (fp, page, page_offset,
+                                             page_offset + chunk + skip);
+        if (!err) {
+	    if (buffer)
+		memcpy (data + skip, buffer + buffer_pos, chunk);
+            err = mapping->a_ops->commit_write (fp, page, page_offset,
+                                                page_offset + chunk + skip);
+	}
+        UnlockPage (page);
+        reiserfs_put_page (page);
+        buffer_pos += chunk;
+        file_pos += chunk;
+        skip = 0;
+        if (err || buffer_size == 0 || !buffer)
+            break;
+    }
+
+out_filp:
+    up (&xinode->i_sem);
+    xa_cache_insert (xinode, xahash);
+    fput(fp);
+
+out:
+    return err;
+}
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_get (const struct inode *inode, const char *name, void *buffer,
+                    size_t buffer_size)
+{
+    ssize_t err = 0;
+    struct file *fp;
+    size_t isize;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct page *page;
+    struct inode *xinode;
+    __u32 hash = 0;
+
+    /* We can't have xattrs attached to v1 items since they don't have
+     * generation numbers */
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    fp = open_xa_file (inode, name, FL_READONLY);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+    isize = xinode->i_size;
+
+    /* Just return the size needed */
+    if (buffer == NULL) {
+        err = isize - sizeof (struct reiserfs_xattr_header);
+        goto out_dput;
+    }
+
+    if (buffer_size < isize - sizeof (struct reiserfs_xattr_header)) {
+        err = -ERANGE;
+        goto out_dput;
+    }
+    
+    while (file_pos < isize) {
+        size_t chunk;
+        char *data;
+        size_t page_offset;
+        size_t skip = 0;
+        if (isize - file_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = isize - file_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_dput;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh =
+                                        (struct reiserfs_xattr_header *)data;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            chunk -= skip;
+            /* Magic doesn't match up.. */
+            if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
+                UnlockPage (page);
+                reiserfs_put_page (page);
+                err = -EIO;
+                goto out_dput;
+            }
+            hash = le32_to_cpu (rxh->h_hash);
+        }
+        memcpy (buffer + buffer_pos, data + skip, chunk);
+        UnlockPage (page);
+        reiserfs_put_page (page);
+        file_pos += chunk;
+        buffer_pos += chunk;
+        skip = 0;
+    }
+    err = isize - sizeof (struct reiserfs_xattr_header);
+
+    if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash)
+        err = -EIO;
+
+    /* Insert this inode into the xattr cache so we can attempt to do
+     * decent sharing.. */
+    if (!err)
+        xa_cache_insert (xinode, hash);
+
+out_dput:
+    fput(fp);
+
+out:
+    return err;
+}
+
+static int
+__reiserfs_xattr_del (struct dentry *xadir, const char *name, int namelen)
+{
+    struct dentry *file;
+    struct inode *dir = xadir->d_inode;
+    int err = 0;
+
+    file = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (file)) {
+        err = PTR_ERR (file);
+        goto out;
+    } else if (!file->d_inode) {
+        err = -ENODATA;
+        goto out_file;
+    }
+
+    /* Skip directories.. */
+    if (S_ISDIR (file->d_inode->i_mode))
+        goto out_file;
+
+    /* remove it from the xattr cache if this is the last reference to it */
+    if (file->d_inode->i_nlink <= 1)
+        xa_cache_remove (file->d_inode);
+
+    if (!is_reiserfs_priv_object (file->d_inode)) {
+        reiserfs_warning ("trying to delete objectid %08x, which isn't an xattr!\n", le32_to_cpu (INODE_PKEY (file->d_inode)->k_objectid));
+        dput (file);
+        return -EIO;
+    }
+
+    err = dir->i_op->unlink (dir, file);
+    if (!err)
+        d_delete (file);
+
+out_file:
+    dput (file);
+
+out:
+    return err;
+}
+
+
+int
+reiserfs_xattr_del (struct inode *inode, const char *name)
+{
+    struct dentry *dir;
+    int err;
+
+    dir = open_xa_dir (inode, FL_READONLY);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    }
+
+    err = __reiserfs_xattr_del (dir, name, strlen (name));
+    dput (dir);
+
+out:
+    return err;
+}
+
+#if 0 /* def CONFIG_REISERFS_FS_XATTR_SHARING */
+static int
+reiserfs_xattr_link_to_inode (struct inode *xattr_inode,
+                              struct inode *dst_inode, const char *dst_name)
+{
+    struct dentry *dst_dentry, *xadir;
+    int err;
+
+    xadir = open_xa_dir (dst_inode, 0);
+    if (IS_ERR (xadir))
+        return PTR_ERR (xadir);
+
+    dst_dentry = get_xa_file_dentry (dst_inode, dst_name, FL_READONLY);
+    if (IS_ERR (dst_dentry)) {
+        dput (xadir);
+    } else if (dst_dentry->d_inode) {
+        err = -EEXIST;
+        goto out;
+    }
+
+    err = __reiserfs_link (xattr_inode, xadir->d_inode, dst_dentry);
+
+out:
+    dput (dst_dentry);
+    dput (xadir);
+    return err;
+}
+
+int
+reiserfs_xattr_link (struct inode *src_inode, const char *src_name,
+                     struct inode *dst_inode, const char *dst_name)
+{
+    struct dentry *src_dentry;
+    int err;
+
+    src_dentry = get_xa_file_dentry (src_inode, src_name, FL_READONLY);
+    if (IS_ERR (src_dentry)) {
+        return PTR_ERR (src_dentry);
+    } else if (!src_dentry->d_inode) {
+        dput (src_dentry);
+        return -ENODATA;
+    }
+
+    err = reiserfs_xattr_link_to_inode (src_dentry->d_inode,
+                                        dst_inode, dst_name);
+    dput (src_dentry);
+    return err;
+}
+#endif
+
+/* The following are side effects of other operations that aren't explicitly
+ * modifying extended attributes. This includes operations such as permissions
+ * or ownership changes, object deletions, etc. */
+ 
+static int
+reiserfs_delete_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct dentry *xadir = (struct dentry *)buf;
+
+    return __reiserfs_xattr_del (xadir, name, namelen);
+
+}
+
+int
+reiserfs_delete_xattrs (struct inode *inode)
+{
+    struct file *fp;
+    struct dentry *dir, *root;
+    int err = 0;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 || 
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        return 0;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+    err = xattr_readdir (fp, reiserfs_delete_xattrs_filler, dir);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    /* Leftovers besides . and .. -- that's not good. */
+    if (dir->d_inode->i_nlink <= 2) {
+        root = get_xa_root (inode->i_sb);
+        reiserfs_write_lock_xattrs (inode->i_sb);
+        err = vfs_rmdir (root->d_inode, dir);
+        reiserfs_write_unlock_xattrs (inode->i_sb);
+        dput (root);
+    } else {
+        reiserfs_warning (inode->i_sb, "Couldn't remove all entries in directory\n");
+    }
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    return err;
+}
+
+struct reiserfs_chown_buf {
+    struct inode *inode;
+    struct dentry *xadir;
+    struct iattr *attrs;
+};
+
+/* XXX: If there is a better way to do this, I'd love to hear about it */
+static int
+reiserfs_chown_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
+    struct dentry *xafile, *xadir = chown_buf->xadir;
+    struct iattr *attrs = chown_buf->attrs;
+    int err = 0;
+
+    xafile = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (xafile))
+        return PTR_ERR (xafile);
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return -ENODATA;
+    }
+
+#if 0
+    /* In this case we need to duplicate the file, since we're changing
+     * the ownership of a shared file */
+    if (!S_ISDIR (xafile->d_inode->i_mode) && xafile->d_inode->i_nlink > 1) {
+        struct inode *inode = chown_buf->inode;
+        char *value;
+        int ret, size;
+        char namebuf[32];
+        char *nameptr;
+
+        if (namelen > 31)
+            nameptr = reiserfs_kmalloc (namelen+1, GFP_NOFS, inode->i_sb);
+        else
+            nameptr = namebuf;
+
+        memcpy (nameptr, name, namelen);
+        nameptr[namelen] = 0;
+        size = reiserfs_xattr_get (inode, nameptr, NULL, 0);
+        if (size < 0) {
+            if (nameptr != namebuf)
+                reiserfs_kfree (nameptr, namelen, inode->i_sb);
+            dput (xafile);
+            return size;
+        }
+
+        value = reiserfs_kmalloc (size, GFP_NOFS, inode->i_sb);
+        if (!value) {
+            if (nameptr != namebuf)
+                reiserfs_kfree (nameptr, namelen, inode->i_sb);
+            dput (xafile);
+            return -ENOMEM;
+        }
+
+        ret = reiserfs_xattr_get (inode, nameptr, value, size);
+        if (ret < 0) {
+            if (nameptr != namebuf)
+                reiserfs_kfree (nameptr, namelen, inode->i_sb);
+            reiserfs_kfree (value, size, inode->i_sb);
+            dput (xafile);
+            return ret;
+        }
+
+        ret = reiserfs_xattr_del (inode, nameptr);
+        dput (xafile);
+
+        if (ret < 0) {
+            if (nameptr != namebuf)
+                reiserfs_kfree (nameptr, namelen, inode->i_sb);
+            reiserfs_kfree (value, size, inode->i_sb);
+            return ret;
+        }
+
+        ret = reiserfs_xattr_set (inode, nameptr, value, size, FL_DIR_SEM_HELD);
+        reiserfs_kfree (value, size, inode->i_sb);
+
+        if (nameptr != namebuf)
+            reiserfs_kfree (nameptr, namelen, inode->i_sb);
+
+        if (ret < 0)
+            return ret;
+
+        xafile = lookup_one_len (nameptr, xadir, namelen);
+        if (IS_ERR (xafile))
+            return PTR_ERR (xafile);
+        else if (!xafile->d_inode) {
+            dput (xafile);
+            return -ENODATA;
+        }
+    }
+#endif
+
+    if (!S_ISDIR (xafile->d_inode->i_mode))
+        err = notify_change (xafile, attrs);
+    dput (xafile);
+
+    return err;
+}
+
+int
+reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_chown_buf buf;
+    unsigned int ia_valid = attrs->ia_valid;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 || 
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        if (PTR_ERR (dir) != -ENODATA)
+            err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+
+    attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
+    buf.xadir = dir;
+    buf.attrs = attrs;
+    buf.inode = inode;
+
+    err = xattr_readdir (fp, reiserfs_chown_xattrs_filler, &buf);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    err = notify_change (dir, attrs);
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    attrs->ia_valid = ia_valid;
+    return err;
+}
+
+
+/* Actual operations that are exported to VFS-land */
+
+/*
+ * Inode operation getxattr()
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+reiserfs_getxattr (struct dentry *dentry, const char *name, void *buffer,
+                   size_t size)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+    
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    down(&dentry->d_inode->i_sem);
+    err = xah->get (dentry->d_inode, name, buffer, size);
+    up(&dentry->d_inode->i_sem);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    return err;
+}
+
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+reiserfs_setxattr (struct dentry *dentry, const char *name, const void *value,
+                   size_t size, int flags)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+    
+    
+    reiserfs_write_lock_xattrs (dentry->d_sb);
+    err = xah->set (dentry->d_inode, name, value, size, flags);
+    reiserfs_write_unlock_xattrs (dentry->d_sb);
+
+    dentry->d_inode->i_ctime = CURRENT_TIME;
+    mark_inode_dirty (dentry->d_inode);
+
+    return err;
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+reiserfs_removexattr (struct dentry *dentry, const char *name)
+{
+    int err;
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    down (&dentry->d_inode->i_zombie);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+
+    /* Deletion pre-operation */
+    if (xah->del) {
+        err = xah->del (dentry->d_inode, name);
+        if (err) {
+            reiserfs_read_unlock_xattrs (dentry->d_sb);
+            up (&dentry->d_inode->i_zombie);
+            return err;
+        }
+    }
+
+    err = reiserfs_xattr_del (dentry->d_inode, name);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    up (&dentry->d_inode->i_zombie);
+
+    dentry->d_inode->i_ctime = CURRENT_TIME;
+    mark_inode_dirty (dentry->d_inode);
+    return err;
+}
+
+
+/* This is what filldir will use:
+ * r_pos will always contain the amount of space required for the entire
+ * list. If r_pos becomes larger than r_size, we need more space and we
+ * return an error indicating this. If r_pos is less than r_size, then we've
+ * filled the buffer successfully and we return success */
+struct reiserfs_listxattr_buf {
+    int r_pos;
+    int r_size;
+    char *r_buf;
+    struct inode *r_inode;
+};
+
+static int
+reiserfs_listxattr_filler (void *buf, const char *name, int namelen,
+                           loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
+    int len = 0;
+    if (name[0] != '.' || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
+        struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+        if (!xah) return 0; /* Unsupported xattr name, skip it */
+
+        /* We call ->list() twice because the operation isn't required to just
+         * return the name back - we want to make sure we have enough space */
+        len += xah->list (b->r_inode, name, namelen, NULL);
+
+        if (len) {
+            if (b->r_pos + len + 1 <= b->r_size) {
+                char *p = b->r_buf + b->r_pos;
+                p += xah->list (b->r_inode, name, namelen, p);
+                *p++ = '\0';
+            }
+            b->r_pos += len + 1;
+        }
+    }
+
+    return 0;
+}
+
+static ssize_t
+__reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_listxattr_buf buf;
+
+    if (!dentry->d_inode)
+        return -EINVAL;
+
+    if (!reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    dir = open_xa_dir (dentry->d_inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        if (err == -ENODATA)
+            err = 0; /* Not an error if there aren't any xattrs */
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    buf.r_buf = buffer;
+    buf.r_size = buffer ? size : 0;
+    buf.r_pos = 0;
+    buf.r_inode = dentry->d_inode;
+
+    err = xattr_readdir (fp, reiserfs_listxattr_filler, &buf);
+    if (err)
+        goto out_dir;
+
+    if (buf.r_pos > buf.r_size && buffer != NULL)
+        err = -ERANGE;
+    else
+        err = buf.r_pos;
+
+out_dir:
+    fput(fp);
+
+out:
+    return err;
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size)
+{
+    int error;
+
+    down(&dentry->d_inode->i_sem);
+    error = __reiserfs_listxattr(dentry, buffer, size);
+    up(&dentry->d_inode->i_sem);
+
+    return error;
+}
+
+/* This is the implementation for the xattr plugin infrastructure */
+static struct reiserfs_xattr_handler *xattr_handlers;
+static rwlock_t handler_lock = RW_LOCK_UNLOCKED;
+
+static struct reiserfs_xattr_handler *
+find_xattr_handler_prefix (const char *prefix)
+{
+    struct reiserfs_xattr_handler **xah;
+    read_lock (&handler_lock);
+    for (xah = &xattr_handlers; *xah; xah=&(*xah)->next)
+        if (strncmp ((*xah)->prefix, prefix, strlen ((*xah)->prefix)) == 0)
+            break;
+    read_unlock (&handler_lock);
+    return *xah;
+}
+
+int
+reiserfs_xattr_register_handler (struct reiserfs_xattr_handler *handler)
+{
+    int res = 0;
+    struct reiserfs_xattr_handler **xah;
+
+    if (!handler)
+        return -EINVAL;
+
+    if (handler->next)
+        return -EBUSY;
+
+    write_lock (&handler_lock);
+
+    for (xah = &xattr_handlers; *xah; xah=&(*xah)->next) {
+        if (strcmp ((*xah)->prefix, handler->prefix) == 0)
+            break;
+    }
+    if (*xah)
+        res = -EBUSY;
+    else
+        *xah = handler;
+
+    /*
+    if (!res)
+        printk ("ReiserFS: Registered xattr handler for %s\n", handler->prefix);
+    */
+
+    write_unlock (&handler_lock);
+    return res;
+}
+
+int
+reiserfs_xattr_unregister_handler (struct reiserfs_xattr_handler *handler)
+{
+    struct reiserfs_xattr_handler **xah;
+    write_lock (&handler_lock);
+
+    xah = &xattr_handlers;
+    while (*xah) {
+        if (handler == *xah) {
+            *xah = handler->next;
+            handler->next = NULL;
+            write_unlock (&handler_lock);
+            /*
+            printk ("ReiserFS: Unregistered xattr handler for %s\n",
+                    handler->prefix);
+            */
+            return 0;
+        }
+        xah = &(*xah)->next;
+    }
+    write_unlock (&handler_lock);
+    return -EINVAL;
+}
+
+
+/* We need to take a copy of the mount flags since things like
+ * MS_RDONLY don't get set until *after* we're called.
+ * mount_flags != mount_options */
+int
+reiserfs_xattr_init (struct super_block *s, int mount_flags)
+{
+  int err = 0;
+
+  /* I hate using the _NO_ variant to clear bits. We use the normal variant
+   * everywhere else, so just clear them both here */
+  if (test_bit (REISERFS_NO_XATTRS_USER, &(s->u.reiserfs_sb.s_mount_opt))) {
+    clear_bit (REISERFS_XATTRS_USER, &(s->u.reiserfs_sb.s_mount_opt));
+    clear_bit (REISERFS_NO_XATTRS_USER, &(s->u.reiserfs_sb.s_mount_opt));
+  }
+
+  if (test_bit (REISERFS_NO_POSIXACL, &(s->u.reiserfs_sb.s_mount_opt))) {
+    clear_bit (REISERFS_POSIXACL, &(s->u.reiserfs_sb.s_mount_opt));
+    clear_bit (REISERFS_NO_POSIXACL, &(s->u.reiserfs_sb.s_mount_opt));
+  }
+
+
+#ifdef CONFIG_REISERFS_FS_XATTR_TRUSTED
+  /* If we're a v3.6 filesystem, trusted xattrs are enabled across the board */
+  if (!old_format_only(s))
+    set_bit (REISERFS_XATTRS, &(s->u.reiserfs_sb.s_mount_opt));
+#endif
+
+  /* If the user has requested an optional xattrs type (e.g. user/acl), then
+   * enable xattrs. If we're a v3.5 filesystem, this will get caught and
+   * error out. If no optional xattrs are enabled, and trusted xattrs aren't
+   * enabled, then disable xattrs */
+  if (reiserfs_xattrs_optional (s))
+    set_bit (REISERFS_XATTRS, &(s->u.reiserfs_sb.s_mount_opt));
+  else if (!reiserfs_xattrs_trusted (s))
+    clear_bit (REISERFS_XATTRS, &(s->u.reiserfs_sb.s_mount_opt));
+
+  if (reiserfs_xattrs (s)) {
+    /* We need generation numbers to ensure that the oid mapping is correct
+     * v3.5 filesystems don't have them. */
+    if (old_format_only (s)) {
+      reiserfs_warning (s, "reiserfs: xattrs/ACLs not supported on pre v3.6 "
+                        "format filesystem. Failing mount.\n");
+      err = -EOPNOTSUPP;
+      goto error;
+    } else if (!s->u.reiserfs_sb.priv_root) {
+      struct dentry *dentry = reiserfs_get_priv_root (s);
+      if (!dentry && !(mount_flags & MS_RDONLY))
+          dentry = reiserfs_create_priv_root (s);
+      if (!IS_ERR (dentry) && dentry)
+          s->u.reiserfs_sb.priv_root = dentry;
+      else { /* xattrs are unavailable */
+          /* If we're read-only it just means that the dir hasn't been
+           * created. Not an error -- just no xattrs on the fs. We'll
+           * check again if we go read-write */
+          if (!(mount_flags & MS_RDONLY)) {
+              reiserfs_warning (s, "reiserfs: xattrs/ACLS enabled and couldn't "
+                             "find/create .reiserfs_priv. Failing mount.\n");
+            err = -EOPNOTSUPP;
+            goto error;
+          }
+          /* Just to speed things up a bit since it won't find anything and
+           * we're read-only */
+          clear_bit (REISERFS_XATTRS_USER, &(s->u.reiserfs_sb.s_mount_opt));
+          clear_bit (REISERFS_POSIXACL, &(s->u.reiserfs_sb.s_mount_opt));
+      }
+    } /* otherwise, already mounted, and remounting */
+  }
+
+
+error:
+   /* This is only nonzero if there was an error initializing the xattr
+    * directory or if there is a condition where we don't support them. */
+
+    if (err) {
+          clear_bit (REISERFS_XATTRS_USER, &(s->u.reiserfs_sb.s_mount_opt));
+          clear_bit (REISERFS_POSIXACL, &(s->u.reiserfs_sb.s_mount_opt));
+          clear_bit (REISERFS_XATTRS, &(s->u.reiserfs_sb.s_mount_opt));
+    }
+
+    s->s_flags = (s->s_flags & ~MS_POSIXACL) |
+                 (reiserfs_posixacl (s) ? MS_POSIXACL : 0);
+    return err;
+}
diff -urN zombi-a/fs/reiserfs/xattr_trusted.c zombi-b/fs/reiserfs/xattr_trusted.c
--- zombi-a/fs/reiserfs/xattr_trusted.c	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/fs/reiserfs/xattr_trusted.c	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,97 @@
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+# include <linux/reiserfs_acl.h>
+#endif
+
+#define XATTR_TRUSTED_PREFIX "trusted."
+
+static int
+trusted_get (struct inode *inode, const char *name, void *buffer, size_t size)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_trusted (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return reiserfs_xattr_get (inode, name, buffer, size);
+}
+
+static int
+trusted_set (struct inode *inode, const char *name, const void *buffer,
+          size_t size, int flags)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_trusted (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return reiserfs_xattr_set (inode, name, buffer, size, flags);
+}
+
+static int
+trusted_del (struct inode *inode, const char *name)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_trusted (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return 0;
+}
+
+static int
+trusted_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+
+    if (!reiserfs_xattrs_trusted (inode->i_sb))
+        return 0;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return 0;
+
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+
+struct reiserfs_xattr_handler trusted_handler = {
+    prefix: XATTR_TRUSTED_PREFIX,
+    get: trusted_get,
+    set: trusted_set,
+    del: trusted_del,
+    list: trusted_list,
+};
+
+int __init
+reiserfs_xattr_trusted_init (void)
+{
+    return reiserfs_xattr_register_handler (&trusted_handler);
+}
+
+int
+reiserfs_xattr_trusted_exit (void)
+{
+    return reiserfs_xattr_unregister_handler (&trusted_handler);
+}
diff -urN zombi-a/fs/reiserfs/xattr_user.c zombi-b/fs/reiserfs/xattr_user.c
--- zombi-a/fs/reiserfs/xattr_user.c	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/fs/reiserfs/xattr_user.c	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,112 @@
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+# include <linux/reiserfs_acl.h>
+#endif
+
+#define XATTR_USER_PREFIX "user."
+
+static int
+user_get (struct inode *inode, const char *name, void *buffer, size_t size)
+{
+
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    error = reiserfs_permission_locked (inode, MAY_READ);
+    if (error)
+        return error;
+
+    return reiserfs_xattr_get (inode, name, buffer, size);
+}
+
+static int
+user_set (struct inode *inode, const char *name, const void *buffer,
+          size_t size, int flags)
+{
+
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!S_ISREG (inode->i_mode) &&
+        (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
+        return -EPERM;
+
+    error = reiserfs_permission_locked (inode, MAY_WRITE);
+    if (error)
+        return error;
+
+    return reiserfs_xattr_set (inode, name, buffer, size, flags);
+}
+
+static int
+user_del (struct inode *inode, const char *name)
+{
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!S_ISREG (inode->i_mode) &&
+        (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
+        return -EPERM;
+
+    error = reiserfs_permission_locked (inode, MAY_WRITE);
+    if (error)
+        return error;
+
+    return 0;
+}
+
+static int
+user_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return 0;
+
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+
+struct reiserfs_xattr_handler user_handler = {
+    prefix: XATTR_USER_PREFIX,
+    get: user_get,
+    set: user_set,
+    del: user_del,
+    list: user_list,
+};
+
+int __init
+reiserfs_xattr_user_init (void)
+{
+    return reiserfs_xattr_register_handler (&user_handler);
+}
+
+int
+reiserfs_xattr_user_exit (void)
+{
+    return reiserfs_xattr_unregister_handler (&user_handler);
+}
diff -urN zombi-a/include/asm-i386/bugs.h zombi-b/include/asm-i386/bugs.h
--- zombi-a/include/asm-i386/bugs.h	2002-08-03 15:41:32.000000000 +0200
+++ zombi-b/include/asm-i386/bugs.h	2003-10-12 01:28:51.000000000 +0200
@@ -200,6 +200,11 @@
 	    && (boot_cpu_data.x86_mask < 6 || boot_cpu_data.x86_mask == 11))
 		panic("Kernel compiled for PMMX+, assumes a local APIC without the read-before-write bug!");
 #endif
+
+#ifdef CONFIG_X86_CMPXCHG8
+	if (!cpu_has_cx8)
+		panic("Kernel compiled for Pentium+, requires CMPXCHG8B feature!");
+#endif
 }
 
 static void __init check_bugs(void)
diff -urN zombi-a/include/asm-i386/cpufeature.h zombi-b/include/asm-i386/cpufeature.h
--- zombi-a/include/asm-i386/cpufeature.h	2003-08-28 03:26:34.000000000 +0200
+++ zombi-b/include/asm-i386/cpufeature.h	2003-10-12 01:28:51.000000000 +0200
@@ -78,6 +78,7 @@
 #define cpu_has_pae		boot_cpu_has(X86_FEATURE_PAE)
 #define cpu_has_pge		boot_cpu_has(X86_FEATURE_PGE)
 #define cpu_has_apic		boot_cpu_has(X86_FEATURE_APIC)
+#define cpu_has_cx8   		boot_cpu_has(X86_FEATURE_CX8)
 #define cpu_has_mtrr		boot_cpu_has(X86_FEATURE_MTRR)
 #define cpu_has_mmx		boot_cpu_has(X86_FEATURE_MMX)
 #define cpu_has_fxsr		boot_cpu_has(X86_FEATURE_FXSR)
diff -urN zombi-a/include/asm-i386/system.h zombi-b/include/asm-i386/system.h
--- zombi-a/include/asm-i386/system.h	2003-10-12 01:04:02.000000000 +0200
+++ zombi-b/include/asm-i386/system.h	2003-10-12 01:28:51.000000000 +0200
@@ -143,6 +143,8 @@
 #define __xg(x) ((struct __xchg_dummy *)(x))
 
 
+#ifdef CONFIG_X86_CMPXCHG8
+#define __ARCH_HAS_GET_SET_64BIT 1
 /*
  * The semantics of XCHGCMP8B are a bit strange, this is why
  * there is a loop and the loading of %%eax and %%edx has to
@@ -167,7 +169,7 @@
 		"lock cmpxchg8b (%0)\n\t"
 		"jnz 1b"
 		: /* no outputs */
-		:	"D"(ptr),
+		:	"r"(ptr),
 			"b"(low),
 			"c"(high)
 		:	"ax","dx","memory");
@@ -197,6 +199,32 @@
  __set_64bit(ptr, (unsigned int)(value), (unsigned int)((value)>>32ULL) ) : \
  __set_64bit(ptr, ll_low(value), ll_high(value)) )
 
+
+/*
+ * The memory clobber is needed in the read side only if
+ * there is an unsafe writer before the get_64bit, which should
+ * never be the case, but just to be safe.
+ */
+static inline unsigned long long get_64bit(unsigned long long * ptr)
+{
+        unsigned long low, high;
+
+        __asm__ __volatile__ (
+                "\n1:\t"
+                "movl (%2), %%eax\n\t"
+                "movl 4(%2), %%edx\n\t"
+                "movl %%eax, %%ebx\n\t"
+                "movl %%edx, %%ecx\n\t"
+                "lock cmpxchg8b (%2)\n\t"
+                "jnz 1b"
+                : "=&b" (low), "=&c" (high)
+                : "r" (ptr)
+                : "ax","dx","memory");
+
+        return low | ((unsigned long long) high << 32);
+}
+#endif /* CONFIG_X86_CMPXCHG */
+
 /*
  * Note: no "lock" prefix even on SMP: xchg always implies lock anyway
  * Note 2: xchg has side effect, so that attribute volatile is necessary,
diff -urN zombi-a/include/linux/fs.h zombi-b/include/linux/fs.h
--- zombi-a/include/linux/fs.h	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/include/linux/fs.h	2003-10-12 01:28:51.000000000 +0200
@@ -442,6 +442,13 @@
 	struct list_head	bd_inodes;
 };
 
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP) && !defined(__ARCH_HAS_GET_SET_64BIT)
+#define __NEED_I_SIZE_ORDERED
+#define i_size_ordered_init(inode) do { (inode)->i_size_version1 = (inode)->i_size_version2 = 0; } while (0)
+#else
+#define i_size_ordered_init(inode) do { } while (0)
+#endif
+
 struct inode {
 	struct list_head	i_hash;
 	struct list_head	i_list;
@@ -529,8 +536,65 @@
 		struct squashfs_inode_info      squashfs_i;
 		void				*generic_ip;
 	} u;
+#ifdef __NEED_I_SIZE_ORDERED
+	volatile int		i_size_version1;
+	volatile int		i_size_version2;
+#endif
 };
 
+/*
+ * NOTE: in a 32bit arch with a preemptable kernel and
+ * an UP compile the i_size_read/write must be atomic
+ * with respect to the local cpu (unlike with preempt disabled),
+ * but they don't need to be atomic with respect to other cpus like in
+ * true SMP (so they need either to either locally disable irq around
+ * the read or for example on x86 they can be still implemented as a
+ * cmpxchg8b without the need of the lock prefix). For SMP compiles
+ * and 64bit archs it makes no difference if preempt is enabled or not.
+ */
+static inline loff_t i_size_read(struct inode * inode)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#ifdef __ARCH_HAS_GET_SET_64BIT
+	return (loff_t) get_64bit((unsigned long long *) &inode->i_size);
+#else
+	loff_t i_size;
+	int v1, v2;
+
+	/* Retry if i_size was possibly modified while sampling. */
+	do {
+		v1 = inode->i_size_version1;
+		rmb();
+		i_size = inode->i_size;
+		rmb();
+		v2 = inode->i_size_version2;
+	} while (v1 != v2);
+
+	return i_size;
+#endif
+#elif BITS_PER_LONG==64 || !defined(CONFIG_SMP)
+	return inode->i_size;
+#endif
+}
+
+static inline void i_size_write(struct inode * inode, loff_t i_size)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#ifdef __ARCH_HAS_GET_SET_64BIT
+	set_64bit((unsigned long long *) &inode->i_size, (unsigned long long) i_size);
+#else
+	inode->i_size_version2++;
+	wmb();
+	inode->i_size = i_size;
+	wmb();
+	inode->i_size_version1++;
+	wmb(); /* make it visible ASAP */
+#endif
+#elif BITS_PER_LONG==64 || !defined(CONFIG_SMP)
+	inode->i_size = i_size;
+#endif
+}
+
 static inline void inode_add_bytes(struct inode *inode, loff_t bytes)
 {
 	inode->i_blocks += bytes >> 9;
@@ -828,6 +892,7 @@
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int __vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
@@ -1407,6 +1472,7 @@
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
+extern struct dentry * __lookup_hash(struct qstr *, struct dentry *);
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
diff -urN zombi-a/include/linux/reiserfs_acl.h zombi-b/include/linux/reiserfs_acl.h
--- zombi-a/include/linux/reiserfs_acl.h	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/include/linux/reiserfs_acl.h	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,92 @@
+#include <linux/init.h>
+#include <linux/posix_acl.h>
+#include <linux/xattr_acl.h>
+
+#define REISERFS_ACL_VERSION	0x0001
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+	__u32		e_id;
+} reiserfs_acl_entry;
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+} reiserfs_acl_entry_short;
+
+typedef struct {
+	__u32		a_version;
+} reiserfs_acl_header;
+
+static inline size_t reiserfs_acl_size(int count)
+{
+	if (count <= 4) {
+		return sizeof(reiserfs_acl_header) +
+		       count * sizeof(reiserfs_acl_entry_short);
+	} else {
+		return sizeof(reiserfs_acl_header) +
+		       4 * sizeof(reiserfs_acl_entry_short) +
+		       (count - 4) * sizeof(reiserfs_acl_entry);
+	}
+}
+
+static inline int reiserfs_acl_count(size_t size)
+{
+	ssize_t s;
+	size -= sizeof(reiserfs_acl_header);
+	s = size - 4 * sizeof(reiserfs_acl_entry_short);
+	if (s < 0) {
+		if (size % sizeof(reiserfs_acl_entry_short))
+			return -1;
+		return size / sizeof(reiserfs_acl_entry_short);
+	} else {
+		if (s % sizeof(reiserfs_acl_entry))
+			return -1;
+		return s / sizeof(reiserfs_acl_entry) + 4;
+	}
+}
+
+
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+struct posix_acl * reiserfs_get_acl(struct inode *inode, int type);
+int reiserfs_set_acl(struct inode *inode, int type, struct posix_acl *acl);
+int reiserfs_permission (struct inode *inode, int mask);
+int reiserfs_permission_locked (struct inode *inode, int mask);
+int reiserfs_acl_chmod (struct inode *inode);
+int reiserfs_inherit_default_acl (struct inode *dir, struct dentry *dentry, struct inode *inode);
+int reiserfs_cache_default_acl (struct inode *dir);
+extern int reiserfs_xattr_posix_acl_init (void) __init;
+extern int reiserfs_xattr_posix_acl_exit (void);
+#else
+
+#define reiserfs_permission NULL
+#define reiserfs_set_acl NULL
+#define reiserfs_get_acl NULL
+#define reiserfs_cache_default_acl(inode) 0
+
+static inline int
+reiserfs_xattr_posix_acl_init (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_xattr_posix_acl_exit (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_acl_chmod (struct inode *inode)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_inherit_default_acl (const struct inode *dir, struct dentry *dentry, struct inode *inode)
+{
+    return 0;
+}
+
+#endif
diff -urN zombi-a/include/linux/reiserfs_fs.h zombi-b/include/linux/reiserfs_fs.h
--- zombi-a/include/linux/reiserfs_fs.h	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/include/linux/reiserfs_fs.h	2003-10-12 01:28:51.000000000 +0200
@@ -2007,17 +2007,23 @@
 static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,
                                       struct inode *inode)
 {
-    reiserfs_update_sd_size(th, inode, inode->i_size) ;
+    reiserfs_update_sd_size(th, inode, i_size_read(inode)) ;
 }
 
 void sd_attrs_to_i_attrs( __u16 sd_attrs, struct inode *inode );
 void i_attrs_to_sd_attrs( struct inode *inode, __u16 *sd_attrs );
+int reiserfs_setattr(struct dentry *dentry, struct iattr *attr);
 
 /* namei.c */
 inline void set_de_name_and_namelen (struct reiserfs_dir_entry * de);
 int search_by_entry_key (struct super_block * sb, const struct cpu_key * key, 
 			 struct path * path, 
 			 struct reiserfs_dir_entry * de);
+int __reiserfs_link (struct inode *inode, struct inode *dir, struct dentry *dentry);
+int reiserfs_find_entry (struct inode * dir, const char * name, int namelen,
+			 struct path * path_to_entry,
+			 struct reiserfs_dir_entry * de);
+
 /* procfs.c */
 
 #if defined( CONFIG_PROC_FS ) && defined( CONFIG_REISERFS_PROC_INFO )
@@ -2081,6 +2087,7 @@
 
 /* dir.c */
 extern struct inode_operations reiserfs_dir_inode_operations;
+extern struct inode_operations reiserfs_symlink_inode_operations;
 extern struct file_operations reiserfs_dir_operations;
 
 /* tail_conversion.c */
@@ -2301,6 +2308,9 @@
 #define REISERFS_IOC_GETVERSION 	EXT2_IOC_GETVERSION
 #define REISERFS_IOC_SETVERSION         EXT2_IOC_SETVERSION
  			         
+/* xattr stuff */
+#define REISERFS_XATTR_DIR_SEM(s) ((s)->u.reiserfs_sb.xattr_dir_sem)
+
 #endif /* _LINUX_REISER_FS_H */
 
 
diff -urN zombi-a/include/linux/reiserfs_fs_i.h zombi-b/include/linux/reiserfs_fs_i.h
--- zombi-a/include/linux/reiserfs_fs_i.h	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/include/linux/reiserfs_fs_i.h	2003-10-12 01:28:51.000000000 +0200
@@ -28,6 +28,7 @@
     i_link_saved_truncate_mask =  0x0020,
     /** are we logging data blocks for this file? */
     i_data_log                 =  0x0040,
+    i_priv_object              =  0x0080,
 } reiserfs_inode_flags;
 
 
@@ -64,6 +65,9 @@
      */
     unsigned long i_tail_trans_id;
     struct reiserfs_journal_list *i_tail_jl;
+
+    struct posix_acl *i_acl_access;
+    struct posix_acl *i_acl_default;
 };
 
 #endif
diff -urN zombi-a/include/linux/reiserfs_fs_sb.h zombi-b/include/linux/reiserfs_fs_sb.h
--- zombi-a/include/linux/reiserfs_fs_sb.h	2003-10-12 01:13:50.000000000 +0200
+++ zombi-b/include/linux/reiserfs_fs_sb.h	2003-10-12 01:28:51.000000000 +0200
@@ -6,6 +6,7 @@
 
 #ifdef __KERNEL__
 #include <linux/tqueue.h>
+#include <linux/rwsem.h>
 #endif
 
 //
@@ -442,6 +443,9 @@
     struct proc_dir_entry *procdir;
     int reserved_blocks; /* amount of blocks reserved for further allocations */
     struct list_head s_reiserfs_supers;
+    struct dentry *priv_root; /* root of /.reiserfs_priv */
+    struct dentry *xattr_root; /* root of /.reiserfs_priv/.xa */
+    struct rw_semaphore xattr_dir_sem;
 };
 
 /* Definitions of reiserfs on-disk properties: */
@@ -486,6 +490,11 @@
     REISERFS_DATA_WRITEBACK,
     REISERFS_ATTRS,
     REISERFS_TEST4,
+    REISERFS_XATTRS,
+    REISERFS_XATTRS_USER,
+    REISERFS_POSIXACL,
+    REISERFS_NO_XATTRS_USER,
+    REISERFS_NO_POSIXACL,
 };
 
 #define reiserfs_r5_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_R5_HASH))
@@ -507,6 +516,15 @@
 #define reiserfs_attrs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_ATTRS))
 #define old_format_only(s) ((s)->u.reiserfs_sb.s_properties & (1 << REISERFS_3_5))
 #define convert_reiserfs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_CONVERT))
+#define reiserfs_xattrs_user(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_XATTRS_USER))
+#define reiserfs_posixacl(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_POSIXACL))
+#define reiserfs_xattrs_optional(s) (reiserfs_xattrs_user(s) || reiserfs_posixacl(s))
+#define reiserfs_xattrs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_XATTRS))
+#ifdef CONFIG_REISERFS_FS_XATTR_TRUSTED
+# define reiserfs_xattrs_trusted(s) reiserfs_xattrs(s)
+#else
+# define reiserfs_xattrs_trusted(s) (0)
+#endif
 
 
 void reiserfs_file_buffer (struct buffer_head * bh, int list);
diff -urN zombi-a/include/linux/reiserfs_xattr.h zombi-b/include/linux/reiserfs_xattr.h
--- zombi-a/include/linux/reiserfs_xattr.h	1970-01-01 01:00:00.000000000 +0100
+++ zombi-b/include/linux/reiserfs_xattr.h	2003-10-12 01:28:51.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+  File: linux/reiserfs_xattr.h
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in header */
+#define REISERFS_XATTR_MAGIC 0x52465841 /* "RFXA" */
+
+struct reiserfs_xattr_header {
+    __u32 h_magic;              /* magic number for identification */
+    __u32 h_hash;               /* hash of the value */
+};
+
+#ifdef __KERNEL__
+
+struct reiserfs_xattr_handler {
+	char *prefix;
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+	int (*del)(struct inode *inode, const char *name);
+        int (*list)(struct inode *inode, const char *name, int namelen, char *out);
+        struct reiserfs_xattr_handler *next;
+};
+
+
+#ifdef CONFIG_REISERFS_FS_XATTR
+#define is_reiserfs_priv_object(inode) (((inode)->u.reiserfs_i.i_flags & i_priv_object) == i_priv_object)
+ssize_t reiserfs_getxattr (struct dentry *dentry, const char *name,
+			   void *buffer, size_t size);
+int reiserfs_setxattr (struct dentry *dentry, const char *name,
+                       const void *value, size_t size, int flags);
+ssize_t reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size);
+int reiserfs_removexattr (struct dentry *dentry, const char *name);
+int reiserfs_delete_xattrs (struct inode *inode);
+int reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs);
+int reiserfs_xattr_init (struct super_block *sb, int mount_flags);
+
+static inline void
+reiserfs_write_lock_xattrs(struct super_block *sb)
+{
+    down_write (&REISERFS_XATTR_DIR_SEM(sb));
+}
+static inline void
+reiserfs_write_unlock_xattrs(struct super_block *sb)
+{
+    up_write (&REISERFS_XATTR_DIR_SEM(sb));
+}
+static inline void
+reiserfs_read_lock_xattrs(struct super_block *sb)
+{
+    down_read (&REISERFS_XATTR_DIR_SEM(sb));
+}
+static inline void
+reiserfs_read_unlock_xattrs(struct super_block *sb)
+{
+    up_read (&REISERFS_XATTR_DIR_SEM(sb));
+}
+#else
+#define is_reiserfs_priv_object(inode) 0
+#define reiserfs_getxattr NULL
+#define reiserfs_setxattr NULL
+#define reiserfs_listxattr NULL
+#define reiserfs_removexattr NULL
+#define reiserfs_write_lock_xattrs(sb)
+#define reiserfs_write_unlock_xattrs(sb)
+#define reiserfs_read_lock_xattrs(sb)
+#define reiserfs_read_unlock_xattrs(sb)
+static inline int
+reiserfs_xattr_init (struct super_block *s, int mount_flags)
+{
+    s->s_flags = (s->s_flags & ~MS_POSIXACL); /* to be sure */
+    return 0;
+}
+
+static inline int
+reiserfs_delete_xattrs (struct inode *inode)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
+{
+    return 0;
+}
+#endif
+
+extern int reiserfs_xattr_register_handler(struct reiserfs_xattr_handler *);
+extern int reiserfs_xattr_unregister_handler(struct reiserfs_xattr_handler *);
+extern int reiserfs_xattr_del (struct inode *, const char *);
+extern int reiserfs_xattr_get (const struct inode *, const char *, void *, size_t);
+extern int reiserfs_xattr_set (struct inode *, const char *, const void *,
+                               size_t, int);
+
+#if 0 /* def CONFIG_REISERFS_FS_XATTR_SHARING */
+int reiserfs_xattr_cache_init (void) __init;
+void reiserfs_xattr_cache_exit (void);
+void reiserfs_xattr_cache_clear (kdev_t dev);
+#else
+static inline int 
+reiserfs_xattr_cache_init (void)
+{
+    return 0;
+}
+
+static inline int 
+reiserfs_xattr_cache_exit (void)
+{
+    return 0;
+}
+
+static inline void
+reiserfs_xattr_cache_clear (kdev_t dev)
+{
+};
+#endif
+#ifdef CONFIG_REISERFS_FS_XATTR_USER
+extern int reiserfs_xattr_user_init (void) __init;
+extern int reiserfs_xattr_user_exit (void);
+#else
+static inline int
+reiserfs_xattr_user_init (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_xattr_user_exit (void)
+{
+    return 0;
+}
+#endif
+#ifdef CONFIG_REISERFS_FS_XATTR_TRUSTED
+extern int reiserfs_xattr_trusted_init (void) __init;
+extern int reiserfs_xattr_trusted_exit (void);
+#else
+static inline int
+reiserfs_xattr_trusted_init (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_xattr_trusted_exit (void)
+{
+    return 0;
+}
+#endif
+
+#endif  /* __KERNEL__ */
