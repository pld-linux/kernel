diff -urN linux-2.6.0-orig/Makefile linux-2.6.0/Makefile
--- linux-2.6.0-orig/Makefile	2004-12-21 18:38:42.178680240 +0100
+++ linux-2.6.0/Makefile	2004-12-21 18:38:56.097564248 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 0
-EXTRAVERSION =
+EXTRAVERSION = -X8664-1
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
diff -urN linux-2.6.0-orig/arch/x86_64/Kconfig linux-2.6.0/arch/x86_64/Kconfig
--- linux-2.6.0-orig/arch/x86_64/Kconfig	2004-12-21 18:38:40.601919944 +0100
+++ linux-2.6.0/arch/x86_64/Kconfig	2004-12-21 18:38:56.098564096 +0100
@@ -505,6 +505,7 @@
 	 Normally you should say N.
 
 config IOMMU_DEBUG
+       depends on GART_IOMMU && DEBUG_KERNEL
        bool "Force IOMMU to on" 
        help
          Force the IOMMU to on even when you have less than 4GB of memory and add 
@@ -519,13 +520,6 @@
          Add a simple leak tracer to the IOMMU code. This is useful when you
 	 are debugging a buggy device driver that leaks IOMMU mappings.
        
-config MCE_DEBUG
-       bool "K8 Machine check debugging mode"
-       default y 
-       help
-         Turn on all Machine Check debugging for device driver problems.	  
-	 This can cause panics, but is useful to find device driver problems.
-
 #config X86_REMOTE_DEBUG
 #       bool "kgdb debugging stub"
 
diff -urN linux-2.6.0-orig/arch/x86_64/defconfig linux-2.6.0/arch/x86_64/defconfig
--- linux-2.6.0-orig/arch/x86_64/defconfig	2004-12-21 18:38:40.601919944 +0100
+++ linux-2.6.0/arch/x86_64/defconfig	2004-12-21 18:39:00.826845288 +0100
@@ -59,7 +59,6 @@
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
-# CONFIG_HUGETLB_PAGE is not set
 CONFIG_SMP=y
 # CONFIG_PREEMPT is not set
 CONFIG_K8_NUMA=y
@@ -79,9 +78,9 @@
 #
 # ACPI (Advanced Configuration and Power Interface) Support
 #
-# CONFIG_ACPI_HT is not set
 CONFIG_ACPI=y
 CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_SLEEP=y
 CONFIG_ACPI_SLEEP_PROC_FS=y
 CONFIG_ACPI_AC=y
@@ -94,11 +93,29 @@
 CONFIG_ACPI_TOSHIBA=y
 CONFIG_ACPI_DEBUG=y
 CONFIG_ACPI_BUS=y
-CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_EC=y
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
+CONFIG_ACPI_RELAXED_AML=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_PROC_INTF=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_24_API is not set
+CONFIG_CPU_FREQ_TABLE=y
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_POWERNOW_K8=y
 
 #
 # Bus options (PCI etc.)
@@ -246,6 +263,7 @@
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -325,7 +343,9 @@
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
 # CONFIG_NET_DIVERT is not set
@@ -358,7 +378,7 @@
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -388,7 +408,6 @@
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
 
 #
@@ -421,10 +440,10 @@
 # CONFIG_NET_RADIO is not set
 
 #
-# Token Ring devices (depends on LLC=y)
+# Token Ring devices
 #
+# CONFIG_TR is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
@@ -443,6 +462,11 @@
 # CONFIG_IRDA is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -485,6 +509,7 @@
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
@@ -504,6 +529,7 @@
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 # CONFIG_SERIAL_8250_ACPI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -520,7 +546,11 @@
 # CONFIG_I2C is not set
 
 #
-# I2C Hardware Sensors Mainboard support
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
 #
 
 #
@@ -549,7 +579,6 @@
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
-# CONFIG_SONYPI is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -559,6 +588,7 @@
 # CONFIG_DRM is not set
 # CONFIG_MWAVE is not set
 CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
 CONFIG_HANGCHECK_TIMER=y
 
 #
@@ -619,10 +649,13 @@
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
 
 #
@@ -647,6 +680,7 @@
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
 # CONFIG_NFSD_V4 is not set
@@ -707,13 +741,15 @@
 # CONFIG_SOUND_MAESTRO is not set
 # CONFIG_SOUND_MAESTRO3 is not set
 CONFIG_SOUND_ICH=y
-# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_ALI5455 is not set
 # CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_AD1980 is not set
 
 #
@@ -723,11 +759,6 @@
 # CONFIG_USB_GADGET is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # Profiling support
 #
 CONFIG_PROFILING=y
@@ -743,8 +774,7 @@
 # CONFIG_INIT_DEBUG is not set
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_FRAME_POINTER is not set
-CONFIG_IOMMU_DEBUG=y
-CONFIG_IOMMU_LEAK=y
+# CONFIG_IOMMU_DEBUG is not set
 CONFIG_MCE_DEBUG=y
 
 #
@@ -760,4 +790,4 @@
 #
 # Library routines
 #
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=y
diff -urN linux-2.6.0-orig/arch/x86_64/ia32/ia32_signal.c linux-2.6.0/arch/x86_64/ia32/ia32_signal.c
--- linux-2.6.0-orig/arch/x86_64/ia32/ia32_signal.c	2004-12-21 18:38:40.599920248 +0100
+++ linux-2.6.0/arch/x86_64/ia32/ia32_signal.c	2004-12-21 18:39:00.826845288 +0100
@@ -46,25 +46,25 @@
 
 static int ia32_copy_siginfo_to_user(siginfo_t32 *to, siginfo_t *from)
 {
+	int err;
 	if (!access_ok (VERIFY_WRITE, to, sizeof(siginfo_t)))
 		return -EFAULT;
-	if (from->si_code < 0) { 
-		/* the only field that's different is the alignment
-		   of the pointer in sigval_t. Move that 4 bytes down including
-		   padding. */
-		memmove(&((siginfo_t32 *)&from)->si_int,
-			&from->si_int, 
-			sizeof(siginfo_t) - offsetof(siginfo_t, si_int));
-		/* last 4 bytes stay the same */
-		return __copy_to_user(to, from, sizeof(siginfo_t32));
-	} else {
-		int err;
 
-		/* If you change siginfo_t structure, please be sure
+	/* If you change siginfo_t structure, please make sure that
 		   this code is fixed accordingly.
 		   It should never copy any pad contained in the structure
 		   to avoid security leaks, but must copy the generic
 		   3 ints plus the relevant union member.  */
+	
+	if (from->si_code < 0) {
+		err = __put_user(from->si_signo, &to->si_signo);
+		err |= __put_user(from->si_errno, &to->si_errno); 
+		err |= __put_user(from->si_code, &to->si_code); 
+		err |= __put_user(from->_sifields._rt._pid, &to->_sifields._rt._pid); 
+		err |= __put_user(from->_sifields._rt._uid, &to->_sifields._rt._uid); 
+		err |= __put_user((u32)(u64)from->_sifields._rt._sigval.sival_ptr, 
+				  &to->_sifields._rt._sigval.sival_ptr); 
+	} else {
 		err = __put_user(from->si_signo, &to->si_signo);
 		err |= __put_user(from->si_errno, &to->si_errno);
 		err |= __put_user(from->si_code, &to->si_code);
@@ -86,8 +86,8 @@
 			break;
 		/* case __SI_RT: This is not generated by the kernel as of now.  */
 		}
-		return err;
 	}
+	return err;
 }
 
 asmlinkage long
@@ -173,6 +173,9 @@
 {
 	unsigned int err = 0;
 	
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
+	
 #if DEBUG_SIG
 	printk("SIG restore_sigcontext: sc=%p err(%x) eip(%x) cs(%x) flg(%x)\n",
 		sc, sc->err, sc->eip, sc->cs, sc->eflags);
diff -urN linux-2.6.0-orig/arch/x86_64/ia32/ia32entry.S linux-2.6.0/arch/x86_64/ia32/ia32entry.S
--- linux-2.6.0-orig/arch/x86_64/ia32/ia32entry.S	2004-12-21 18:38:40.598920400 +0100
+++ linux-2.6.0/arch/x86_64/ia32/ia32entry.S	2004-12-21 18:39:00.827845136 +0100
@@ -330,10 +330,10 @@
 	.quad sys32_adjtimex
 	.quad sys32_mprotect		/* 125 */
 	.quad compat_sys_sigprocmask
-	.quad sys32_module_warning	/* create_module */
+	.quad quiet_ni_syscall		/* create_module */
 	.quad sys_init_module
 	.quad sys_delete_module
-	.quad sys32_module_warning	/* 130  get_kernel_syms */
+	.quad quiet_ni_syscall		/* 130  get_kernel_syms */
 	.quad ni_syscall	/* quotactl */ 
 	.quad sys_getpgid
 	.quad sys_fchdir
@@ -396,8 +396,8 @@
 	.quad stub32_vfork            /* 190 */
 	.quad compat_sys_getrlimit
 	.quad sys32_mmap2
-	.quad sys_truncate
-	.quad sys_ftruncate
+	.quad sys32_truncate64
+	.quad sys32_ftruncate64
 	.quad sys32_stat64		/* 195 */
 	.quad sys32_lstat64
 	.quad sys32_fstat64
diff -urN linux-2.6.0-orig/arch/x86_64/ia32/sys_ia32.c linux-2.6.0/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.0-orig/arch/x86_64/ia32/sys_ia32.c	2004-12-21 18:38:40.598920400 +0100
+++ linux-2.6.0/arch/x86_64/ia32/sys_ia32.c	2004-12-21 18:39:00.828844984 +0100
@@ -110,6 +110,21 @@
 	return 0;
 }
 
+extern long sys_truncate(char *, loff_t); 
+extern long sys_ftruncate(int, loff_t); 
+
+asmlinkage long
+sys32_truncate64(char * filename, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_truncate(filename, ((loff_t) offset_high << 32) | offset_low);
+}
+
+asmlinkage long
+sys32_ftruncate64(unsigned int fd, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_ftruncate(fd, ((loff_t) offset_high << 32) | offset_low);
+}
+
 /* Another set for IA32/LFS -- x86_64 struct stat is different due to 
    support for 64bit inode numbers. */
 
@@ -1817,13 +1832,6 @@
 }
 #endif
 
-long sys32_module_warning(void)
-{ 
-		printk(KERN_INFO "%s: 32bit 2.4.x modutils not supported on 64bit kernel\n",
-		       current->comm);
-	return -ENOSYS ;
-} 
-
 extern long sys_io_setup(unsigned nr_reqs, aio_context_t *ctx);
 
 long sys32_io_setup(unsigned nr_reqs, u32 *ctx32p)
@@ -1989,12 +1997,16 @@
 
 long sys32_vm86_warning(void)
 { 
+	struct task_struct *me = current;
+	static char lastcomm[8];
+	if (strcmp(lastcomm, me->comm)) {
 		printk(KERN_INFO "%s: vm86 mode not supported on 64 bit kernel\n",
-		       current->comm);
-	return -ENOSYS ;
+		       me->comm);
+		strcpy(lastcomm, me->comm); 
+	} 
+	return -ENOSYS;
 } 
 
-
 struct exec_domain ia32_exec_domain = { 
 	.name = "linux/x86",
 	.pers_low = PER_LINUX32,
diff -urN linux-2.6.0-orig/arch/x86_64/ia32/syscall32.c linux-2.6.0/arch/x86_64/ia32/syscall32.c
--- linux-2.6.0-orig/arch/x86_64/ia32/syscall32.c	2004-12-21 18:38:40.599920248 +0100
+++ linux-2.6.0/arch/x86_64/ia32/syscall32.c	2004-12-21 18:39:00.828844984 +0100
@@ -30,10 +30,12 @@
 int map_syscall32(struct mm_struct *mm, unsigned long address) 
 { 
 	pte_t *pte;
+	pmd_t *pmd;
 	int err = 0;
+
 	down_read(&mm->mmap_sem);
 	spin_lock(&mm->page_table_lock); 
-	pmd_t *pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
+	pmd = pmd_alloc(mm, pgd_offset(mm, address), address); 
 	if (pmd && (pte = pte_alloc_map(mm, pmd, address)) != NULL) { 
 		if (pte_none(*pte)) { 
 			set_pte(pte, 
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/Makefile linux-2.6.0/arch/x86_64/kernel/Makefile
--- linux-2.6.0-orig/arch/x86_64/kernel/Makefile	2004-12-21 18:38:40.594921008 +0100
+++ linux-2.6.0/arch/x86_64/kernel/Makefile	2004-12-21 18:39:00.829844832 +0100
@@ -18,13 +18,16 @@
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o mpparse.o
 obj-$(CONFIG_PM)		+= suspend.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_asm.o
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
+obj-y				+= topology.o
+
 bootflag-y			+= ../../i386/kernel/bootflag.o
-cpuid-$(CONFIG_X86_CPUID)	+= ../../i386/kernel/cpuid.o
+cpuid-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/cpuid.o
+topology-y                     += ../../i386/mach-default/topology.o
 
-obj-$(CONFIG_CPU_FREQ)	+=	cpufreq/
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/acpi/sleep.c linux-2.6.0/arch/x86_64/kernel/acpi/sleep.c
--- linux-2.6.0-orig/arch/x86_64/kernel/acpi/sleep.c	2004-12-21 18:38:40.589921768 +0100
+++ linux-2.6.0/arch/x86_64/kernel/acpi/sleep.c	2004-12-21 18:39:00.829844832 +0100
@@ -56,6 +56,7 @@
 
 /* address in low memory of the wakeup routine. */
 unsigned long acpi_wakeup_address = 0;
+unsigned long acpi_video_flags;
 extern char wakeup_start, wakeup_end;
 
 extern unsigned long FASTCALL(acpi_copy_wakeup_routine(unsigned long));
@@ -116,6 +117,22 @@
 	printk(KERN_DEBUG "ACPI: have wakeup address 0x%8.8lx\n", acpi_wakeup_address);
 }
 
+static int __init acpi_sleep_setup(char *str)
+{
+	while ((str != NULL) && (*str != '\0')) {
+		if (strncmp(str, "s3_bios", 7) == 0)
+			acpi_video_flags = 1;
+		if (strncmp(str, "s3_mode", 7) == 0)
+			acpi_video_flags |= 2;
+		str = strchr(str, ',');
+		if (str != NULL)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+__setup("acpi_sleep=", acpi_sleep_setup);
+
 #endif /*CONFIG_ACPI_SLEEP*/
 
 void acpi_pci_link_exit(void) {}
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/acpi/wakeup.S linux-2.6.0/arch/x86_64/kernel/acpi/wakeup.S
--- linux-2.6.0-orig/arch/x86_64/kernel/acpi/wakeup.S	2004-12-21 18:38:40.590921616 +0100
+++ linux-2.6.0/arch/x86_64/kernel/acpi/wakeup.S	2004-12-21 18:39:00.829844832 +0100
@@ -41,7 +41,19 @@
 	cmpl	$0x12345678, %eax
 	jne	bogus_real_magic
 
+	testl	$1, video_flags - wakeup_code
+	jz	1f
 	lcall   $0xc000,$3
+	movw	%cs, %ax
+	movw	%ax, %ds					# Bios might have played with that
+	movw	%ax, %ss
+1:
+
+	testl	$2, video_flags - wakeup_code
+	jz	1f
+	mov	video_mode - wakeup_code, %ax
+	call	mode_seta
+1:
 
  	movw	$0xb800, %ax
 	movw	%ax,%fs
@@ -250,6 +262,7 @@
 		.quad 0
 real_magic:	.quad 0
 video_mode:	.quad 0
+video_flags:	.quad 0
 
 bogus_real_magic:
 	movb	$0xba,%al	;  outb %al,$0x80		
@@ -382,8 +395,10 @@
 	movl	%eax, saved_efer
 	movl	%edx, saved_efer2
 
-#	movq	saved_videomode, %rdx				# FIXME:	 videomode
-	movq	%rdx, video_mode - wakeup_start (,%rdi)
+	movl	saved_video_mode, %edx
+	movl	%edx, video_mode - wakeup_start (,%rdi)
+	movl	acpi_video_flags, %edx
+	movl	%edx, video_flags - wakeup_start (,%rdi)
 	movq	$0x12345678, real_magic - wakeup_start (,%rdi)
 	movq	$0x123456789abcdef0, %rdx
 	movq	%rdx, saved_magic
@@ -415,8 +430,6 @@
 .LFB5:
 	subq	$8, %rsp
 .LCFI2:
-	testl	%edi, %edi
-	jne	.L99
 	xorl	%eax, %eax
 	call	save_processor_state
 
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/apic.c linux-2.6.0/arch/x86_64/kernel/apic.c
--- linux-2.6.0-orig/arch/x86_64/kernel/apic.c	2004-12-21 18:38:40.590921616 +0100
+++ linux-2.6.0/arch/x86_64/kernel/apic.c	2004-12-21 18:39:00.830844680 +0100
@@ -42,6 +42,8 @@
 static DEFINE_PER_CPU(int, prof_old_multiplier) = 1;
 static DEFINE_PER_CPU(int, prof_counter) = 1;
 
+static void apic_pm_activate(void);
+
 void enable_NMI_through_LVT0 (void * dummy)
 {
 	unsigned int v, ver;
@@ -435,6 +437,7 @@
 
 	if (nmi_watchdog == NMI_LOCAL_APIC)
 		setup_apic_nmi_watchdog();
+	apic_pm_activate();
 }
 
 #ifdef CONFIG_PM
@@ -556,7 +559,7 @@
 
 #else	/* CONFIG_PM */
 
-static inline void apic_pm_activate(void) { }
+static void apic_pm_activate(void) { }
 
 #endif	/* CONFIG_PM */
 
@@ -579,7 +582,6 @@
 	if (nmi_watchdog != NMI_NONE)
 		nmi_watchdog = NMI_LOCAL_APIC;
 
-	apic_pm_activate();
 	return 0;
 }
 
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/bluesmoke.c linux-2.6.0/arch/x86_64/kernel/bluesmoke.c
--- linux-2.6.0-orig/arch/x86_64/kernel/bluesmoke.c	2004-12-21 18:38:40.594921008 +0100
+++ linux-2.6.0/arch/x86_64/kernel/bluesmoke.c	2004-12-21 18:39:00.831844528 +0100
@@ -26,19 +26,6 @@
 static int banks;
 static unsigned long ignored_banks, disabled_banks;
 
-/* Machine Check on everything dubious. This is a good setting
-   for device driver testing. */
-#define K8_DRIVER_DEBUG ((1<<13)-1)
-/* Report RAM errors and Hyper Transport Problems, but ignore Device
-   aborts and GART errors. */
-#define K8_NORMAL_OP    0xff
-
-#ifdef CONFIG_MCE_DEBUG
-static u32 k8_nb_flags __initdata = K8_DRIVER_DEBUG;
-#else
-static u32 k8_nb_flags __initdata = K8_NORMAL_OP;
-#endif
-
 static void generic_machine_check(struct pt_regs * regs, long error_code)
 {
 	int recover=1;
@@ -200,11 +187,14 @@
 static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
+	u32 statuslow, statushigh;
+	unsigned short errcode;
+	int i;
+
 	nb = find_k8_nb(); 
 	if (nb == NULL)
 		return;
 
-	u32 statuslow, statushigh;
 	pci_read_config_dword(nb, 0x48, &statuslow);
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
@@ -215,50 +205,42 @@
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
 	       statushigh,statuslow); 
 
-	unsigned short errcode = statuslow & 0xffff;	
-	switch (errcode >> 8) { 
-	case 0: 					
+	printk(KERN_ERR "    Error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
+
+	errcode = statuslow & 0xffff;	
+	switch ((statuslow >> 16) & 0xF) { 
+	case 5: 					
 		printk(KERN_ERR "    GART TLB error %s %s\n", 
 		       transaction[(errcode >> 2) & 3], 
 		       cachelevel[errcode & 3]);
 		break;
-	case 1: 
-		if (errcode & (1<<11)) { 
-			printk(KERN_ERR "    bus error %s %s %s %s %s\n",
-			       partproc[(errcode >> 10) & 0x3],
-			       timeout[(errcode >> 9) & 1],
+	case 8:
+		printk(KERN_ERR "    ECC error syndrome %x\n", 
+		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));		
+		/*FALL THROUGH*/
+	default:
+		printk(KERN_ERR "    bus error %s, %s\n    %s\n    %s, %s\n",
+		       partproc[(errcode >> 9) & 0x3],
+		       timeout[(errcode >> 8) & 1],
 			       memtrans[(errcode >> 4) & 0xf],
 			       memoryio[(errcode >> 2) & 0x3], 
 			       cachelevel[(errcode & 0x3)]); 
-		} else if (errcode & (1<<8)) { 
-			printk(KERN_ERR "    memory error %s %s %s\n",
-			       memtrans[(errcode >> 4) & 0xf],
-			       transaction[(errcode >> 2) & 0x3],
-			       cachelevel[(errcode & 0x3)]);
-		} else {
-			printk(KERN_ERR "    unknown error code %x\n", errcode); 
-		}
-		break;
-	} 
-	if (statushigh & ((1<<14)|(1<<13)))
-		printk(KERN_ERR "    ECC syndrome bits %x\n", 
-		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));
-	errcode = (statuslow >> 16) & 0xf;
-	printk(KERN_ERR "    extended error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
-	
 	/* should only print when it was a HyperTransport related error. */
 	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
+ 		break;
+	} 
 
-	int i;
-	for (i = 0; i < 32; i++) 
+	for (i = 0; i < 32; i++) {
+		if (i == 26 || i == 28) 
+			continue;
 		if (highbits[i] && (statushigh & (1<<i)))
 			printk(KERN_ERR "    %s\n", highbits[i]); 
-
+	}
 	if (statushigh & (1<<26)) { 
 		u32 addrhigh, addrlow; 
 		pci_read_config_dword(nb, 0x54, &addrhigh); 
 		pci_read_config_dword(nb, 0x50, &addrlow); 
-		printk(KERN_ERR "    error address %08x%08x\n", addrhigh,addrlow); 
+		printk(KERN_ERR "    NB error address %08x%08x\n", addrhigh,addrlow); 
 	}
 	statushigh &= ~(1<<31); 
 	pci_write_config_dword(nb, 0x4c, statushigh); 		
@@ -307,9 +289,6 @@
 	wrmsrl(MSR_IA32_MC0_STATUS+4*4, 0); 
 	wrmsrl(MSR_IA32_MCG_STATUS, 0);
        
-	if (regs && (status & (1<<1)))
-		printk(KERN_EMERG "MCE at RIP %lx RSP %lx\n", regs->rip, regs->rsp); 
-
  others:
 	generic_machine_check(regs, error_code); 
 
@@ -367,12 +346,13 @@
 	machine_check_vector = k8_machine_check; 
 	for (i = 0; i < banks; i++) { 
 		u64 val = ((1UL<<i) & disabled_banks) ? 0 : ~0UL; 
-		if (val && i == 4) 
-			val = k8_nb_flags;
 		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
 		wrmsrl(MSR_IA32_MC0_STATUS+4*i,0); 
 	}
 
+	if (cap & (1<<8))
+		wrmsrl(MSR_IA32_MCG_CTL, 0xffffffffffffffffULL);
+
 	set_in_cr4(X86_CR4_MCE);	   	
 
 	if (mcheck_interval && (smp_processor_id() == 0)) { 
@@ -469,7 +449,6 @@
    mce=nok8 disable k8 specific features
    mce=disable<NUMBER> disable bank NUMBER
    mce=enable<NUMBER> enable bank number
-   mce=device	Enable device driver test reporting in NB
    mce=NUMBER mcheck timer interval number seconds. 
    Can be also comma separated in a single mce= */
 static int __init mcheck_enable(char *str)
@@ -486,8 +465,6 @@
 			disabled_banks |= ~(1<<simple_strtol(p+7,NULL,0));
 		else if (!strcmp(p,"nok8"))
 			nok8 = 1;
-		else if (!strcmp(p,"device"))
-			k8_nb_flags = K8_DRIVER_DEBUG;
 	}
 	return 0;
 }
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/e820.c linux-2.6.0/arch/x86_64/kernel/e820.c
--- linux-2.6.0-orig/arch/x86_64/kernel/e820.c	2004-12-21 18:38:40.591921464 +0100
+++ linux-2.6.0/arch/x86_64/kernel/e820.c	2004-12-21 18:39:00.831844528 +0100
@@ -2,10 +2,6 @@
  * Handle the memory map.
  * The functions here do the job until bootmem takes over.
  * $Id$
-
- * AK: some of these functions are not used in 2.5 yet but they will be when
- * NUMA is completely merged.
-
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/head.S linux-2.6.0/arch/x86_64/kernel/head.S
--- linux-2.6.0-orig/arch/x86_64/kernel/head.S	2004-12-21 18:38:40.593921160 +0100
+++ linux-2.6.0/arch/x86_64/kernel/head.S	2004-12-21 18:39:00.832844376 +0100
@@ -38,6 +38,9 @@
 
 	movl %ebx,%ebp	/* Save trampoline flag */
 	
+	movl $__KERNEL_DS,%eax
+	movl %eax,%ds
+	
 	/* If the CPU doesn't support CPUID this will double fault.
 	 * Unfortunately it is hard to check for CPUID without a stack. 
 	 */
@@ -114,25 +117,11 @@
 	movl	$(pGDT32 - __START_KERNEL_map), %eax
 	lgdt	(%eax)
 
+second:	
 	movl    $(ljumpvector - __START_KERNEL_map), %eax
 	/* Finally jump in 64bit mode */
 	ljmp	*(%eax)
 
-second:
-	/* abuse syscall to get into 64bit mode. this way we don't need
-	   a working low identity mapping just for the short 32bit roundtrip. 
-	   XXX kludge. this should not be needed. */
-	movl  $MSR_STAR,%ecx
-	xorl  %eax,%eax
-	movl  $(__USER32_CS<<16)|__KERNEL_CS,%edx
-	wrmsr
-
-	movl  $MSR_CSTAR,%ecx
-	movl  $0xffffffff,%edx
-	movl  $0x80100100,%eax	# reach_long64 absolute
-	wrmsr
-	syscall
-
 	.code64
 	.org 0x100	
 reach_long64:
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/io_apic.c linux-2.6.0/arch/x86_64/kernel/io_apic.c
--- linux-2.6.0-orig/arch/x86_64/kernel/io_apic.c	2004-12-21 18:38:40.593921160 +0100
+++ linux-2.6.0/arch/x86_64/kernel/io_apic.c	2004-12-21 18:39:00.833844224 +0100
@@ -147,6 +147,13 @@
 	struct IO_APIC_route_entry entry;
 	unsigned long flags;
 
+	/* Check delivery_mode to be sure we're not clearing an SMI pin */
+	spin_lock_irqsave(&ioapic_lock, flags);
+	*(((int*)&entry) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
+	*(((int*)&entry) + 1) = io_apic_read(apic, 0x11 + 2 * pin);
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+	if (entry.delivery_mode == dest_SMI)
+		return;
 	/*
 	 * Disable it in the IO-APIC irq-routing table:
 	 */
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/mpparse.c linux-2.6.0/arch/x86_64/kernel/mpparse.c
--- linux-2.6.0-orig/arch/x86_64/kernel/mpparse.c	2004-12-21 18:38:40.591921464 +0100
+++ linux-2.6.0/arch/x86_64/kernel/mpparse.c	2004-12-21 18:39:00.833844224 +0100
@@ -226,7 +226,7 @@
 	unsigned char *mpt=((unsigned char *)mpc)+count;
 
 	if (memcmp(mpc->mpc_signature,MPC_SIGNATURE,4)) {
-		panic("SMP mptable: bad signature [%c%c%c%c]!\n",
+		printk("SMP mptable: bad signature [%c%c%c%c]!\n",
 			mpc->mpc_signature[0],
 			mpc->mpc_signature[1],
 			mpc->mpc_signature[2],
@@ -234,7 +234,7 @@
 		return 0;
 	}
 	if (mpf_checksum((unsigned char *)mpc,mpc->mpc_length)) {
-		panic("SMP mptable: checksum error!\n");
+		printk("SMP mptable: checksum error!\n");
 		return 0;
 	}
 	if (mpc->mpc_spec!=0x01 && mpc->mpc_spec!=0x04) {
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/pci-gart.c linux-2.6.0/arch/x86_64/kernel/pci-gart.c
--- linux-2.6.0-orig/arch/x86_64/kernel/pci-gart.c	2004-12-21 18:38:40.592921312 +0100
+++ linux-2.6.0/arch/x86_64/kernel/pci-gart.c	2004-12-21 18:39:00.834844072 +0100
@@ -31,6 +31,10 @@
 #include <asm/kdebug.h>
 #include <asm/proto.h>
 
+/* Workarounds for specific drivers */
+#define FUSION_WORKAROUND 1 
+#define FLUSH_WORKAROUND 1
+
 dma_addr_t bad_dma_address;
 
 unsigned long iommu_bus_base;	/* GART remapping area (physical) */
@@ -44,12 +48,13 @@
 #ifdef CONFIG_IOMMU_DEBUG
 int panic_on_overflow = 1; 
 int force_iommu = 1;
-int sac_force_size = 0; 
 #else
-int panic_on_overflow = 1; /* for testing */
+int panic_on_overflow = 0;
 int force_iommu = 0;
-int sac_force_size = 256*1024*1024;
 #endif
+int iommu_merge = 0; 
+int iommu_sac_force = 0; 
+int iommu_fullflush = 0;
 
 /* Allocation bitmap for the remapping area */ 
 static spinlock_t iommu_bitmap_lock = SPIN_LOCK_UNLOCKED;
@@ -125,7 +130,7 @@
 /* 
  * Use global flush state to avoid races with multiple flushers.
  */
-static void __flush_gart(struct pci_dev *dev)
+static void flush_gart(struct pci_dev *dev)
 { 
 	unsigned long flags;
 	int bus = dev ? dev->bus->number : -1;
@@ -134,13 +139,17 @@
 	int i;
 
 	spin_lock_irqsave(&iommu_bitmap_lock, flags);
-	/* recheck flush count inside lock */
-	if (need_flush) { 
+	if (need_flush || iommu_fullflush) { 
 		for (i = 0; northbridges[i]; i++) {
+			u32 w;
 			if (bus >= 0 && !(cpu_isset_const(i, bus_cpumask)))
 				continue;
 			pci_write_config_dword(northbridges[i], 0x9c, 
 					       northbridge_flush_word[i] | 1); 
+			/* Make sure the hardware actually executed the flush. */
+			do { 
+				pci_read_config_dword(northbridges[i], 0x9c, &w);
+			} while (w & 1);
 			flushed++;
 		} 
 		if (!flushed) 
@@ -150,12 +159,6 @@
 	spin_unlock_irqrestore(&iommu_bitmap_lock, flags);
 } 
 
-static inline void flush_gart(struct pci_dev *dev)
-{ 
-	if (need_flush)
-		__flush_gart(dev);
-} 
-
 /* 
  * Allocate memory for a consistent mapping.
  * All mappings are consistent here, so this is just a wrapper around
@@ -174,11 +177,16 @@
 	} else {
 		dma_mask = hwdev->consistent_dma_mask; 
 	}
+
 	if (dma_mask == 0) 
 		dma_mask = 0xffffffff; 
 	if (dma_mask < 0xffffffff || no_iommu)
 		gfp |= GFP_DMA;
 
+	/* Kludge to make it bug-to-bug compatible with i386. i386
+	   uses the normal dma_mask for alloc_consistent. */
+	dma_mask &= hwdev->dma_mask;
+
 	memory = (void *)__get_free_pages(gfp, get_order(size));
 	if (memory == NULL) {
 		return NULL; 
@@ -394,7 +402,9 @@
 	
 	for (i = start; i < stopat; i++) {
 		struct scatterlist *s = &sg[i];
-		unsigned long start_addr = s->dma_address;
+		unsigned long pages, addr;
+		unsigned long phys_addr = s->dma_address;
+		
 		BUG_ON(i > start && s->offset);
 		if (i == start) {
 			*sout = *s; 
@@ -403,8 +413,10 @@
 		} else { 
 			sout->length += s->length; 
 		}
-		unsigned long addr = start_addr;
-		while (addr < start_addr + s->length) { 
+
+		addr = phys_addr;
+		pages = to_pages(s->offset, s->length); 
+		while (pages--) { 
 			iommu_gatt_base[iommu_page] = GPTE_ENCODE(addr); 
 			SET_LEAK(iommu_page);
 			addr += PAGE_SIZE;
@@ -437,7 +449,7 @@
 	int out;
 	int start;
 	unsigned long pages = 0;
-	int need = 0;
+	int need = 0, nextneed;
 
 	unsigned long size = 0; 
 
@@ -453,13 +465,14 @@
 		BUG_ON(s->length == 0); 
 
 		size += s->length; 
+		nextneed = need_iommu(dev, addr, s->length); 
 
 		/* Handle the previous not yet processed entries */
 		if (i > start) {
 			struct scatterlist *ps = &sg[i-1];
 			/* Can only merge when the last chunk ends on a page 
-			   boundary. */
-			if (!force_iommu || !need || (i-1 > start && ps->offset) ||
+			   boundary and the new one doesn't have an offset. */
+			if (!iommu_merge || !nextneed || !need || s->offset ||
 			    (ps->offset + ps->length) % PAGE_SIZE) { 
 				if (pci_map_cont(sg, start, i, sg+out, pages, 
 						 need) < 0)
@@ -470,7 +483,7 @@
 			}
 	}
 
-		need = need_iommu(dev, addr, s->length); 
+		need = nextneed;
 		pages += to_pages(s->offset, s->length);
 	}
 	if (pci_map_cont(sg, start, i, sg+out, pages, need) < 0)
@@ -539,19 +552,30 @@
         if (mask < 0x00ffffff)
                 return 0;
 
+#ifdef FUSION_WORKAROUND
+	if (dev->vendor == PCI_VENDOR_ID_LSI_LOGIC && mask > 0xffffffff) { 
+		force_iommu = 1;
+		iommu_merge = 1; 
+		return 0; 
+	} 
+#endif
+#ifdef FLUSH_WORKAROUND
+	if ((dev->vendor == PCI_VENDOR_ID_3WARE && mask <= 0xffffffff) ||
+	    (dev->vendor == PCI_VENDOR_ID_QLOGIC && force_iommu))
+		iommu_fullflush = 1;
+#endif
+
 	/* Tell the device to use SAC when IOMMU force is on. 
 	   This allows the driver to use cheaper accesses in some cases.
 
 	   Problem with this is that if we overflow the IOMMU area
 	   and return DAC as fallback address the device may not handle it correctly.
-	   As a compromise we only do this if the IOMMU area is >= 256MB 
-	   which should make overflow unlikely enough.
 	   
 	   As a special case some controllers have a 39bit address mode 
 	   that is as efficient as 32bit (aic79xx). Don't force SAC for these.
 	   Assume all masks <= 40 bits are of this type. Normally this doesn't
 	   make any difference, but gives more gentle handling of IOMMU overflow. */
-	if (force_iommu && (mask > 0xffffffffffULL) && (iommu_size >= sac_force_size)){ 
+	if (iommu_sac_force && (mask >= 0xffffffffffULL)) { 
 		printk(KERN_INFO "%s: Force SAC with mask %Lx\n", dev->slot_name,mask);
 		return 0; 
 	}
@@ -680,7 +704,7 @@
 	unsigned long iommu_start;
 	struct pci_dev *dev;
 		
-#ifndef CONFIG_AGP_AMD_8151
+#ifndef CONFIG_AGP_AMD64
 	no_agp = 1; 
 #else
 	/* Makefile puts PCI initialization via subsys_initcall first. */
@@ -776,7 +800,8 @@
 /* Must execute after PCI subsystem */
 fs_initcall(pci_iommu_init);
 
-/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]]
+/* iommu=[size][,noagp][,off][,force][,noforce][,leak][,memaper[=order]][,merge]
+         [,forcesac][,fullflush][,nomerge]
    size  set size of iommu (in bytes) 
    noagp don't initialize the AGP driver and use full aperture.
    off   don't use the IOMMU
@@ -784,6 +809,10 @@
    memaper[=order] allocate an own aperture over RAM with size 32MB^order.  
    noforce don't force IOMMU usage. Default.
    force  Force IOMMU.
+   merge  Do SG merging. Implies force (experimental)  
+   nomerge Don't do SG merging.
+   forcesac For SAC mode for masks <40bits  (experimental)
+   fullflush Flush IOMMU on each allocation (for testing)
 */
 __init int iommu_setup(char *opt) 
 { 
@@ -797,8 +826,10 @@
 		    no_iommu = 1;
 	    if (!memcmp(p,"force", 5))
 		    force_iommu = 1;
-	    if (!memcmp(p,"noforce", 7))
+	    if (!memcmp(p,"noforce", 7)) { 
+		    iommu_merge = 0;
 		    force_iommu = 0;
+	    }
 	    if (!memcmp(p, "memaper", 7)) { 
 		    fallback_aper_force = 1; 
 		    p += 7; 
@@ -809,6 +840,16 @@
 		    panic_on_overflow = 1;
 	    if (!memcmp(p, "nopanic", 7))
 		    panic_on_overflow = 0;	    
+	    if (!memcmp(p, "merge", 5)) { 
+		    iommu_merge = 1;
+		    force_iommu = 1; 
+	    }
+	    if (!memcmp(p, "nomerge", 7))
+		    iommu_merge = 0;
+	    if (!memcmp(p, "forcesac", 8))
+		    iommu_sac_force = 1;
+	    if (!memcmp(p, "fullflush", 9))
+		    iommu_fullflush = 1;
 #ifdef CONFIG_IOMMU_LEAK
 	    if (!memcmp(p,"leak", 4)) { 
 		    leak_trace = 1;
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/pci-nommu.c linux-2.6.0/arch/x86_64/kernel/pci-nommu.c
--- linux-2.6.0-orig/arch/x86_64/kernel/pci-nommu.c	2004-12-21 18:38:40.589921768 +0100
+++ linux-2.6.0/arch/x86_64/kernel/pci-nommu.c	2004-12-21 18:39:00.835843920 +0100
@@ -4,6 +4,8 @@
 #include <linux/string.h>
 #include <asm/proto.h>
 
+int iommu_merge = 0;
+
 /* 
  * Dummy IO MMU functions
  */
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/process.c linux-2.6.0/arch/x86_64/kernel/process.c
--- linux-2.6.0-orig/arch/x86_64/kernel/process.c	2004-12-21 18:38:40.593921160 +0100
+++ linux-2.6.0/arch/x86_64/kernel/process.c	2004-12-21 18:39:00.835843920 +0100
@@ -152,6 +152,19 @@
 
 __setup("idle=", idle_setup);
 
+void idle_warning(void) 
+{ 
+	static int warned;
+	if (warned)
+		return; 
+	warned = 1;
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) 
+		BUG();
+	printk(KERN_ERR "******* Your BIOS seems to not contain a fix for K8 errata #93\n"); 
+	printk(KERN_ERR "******* Working around it, but it will cost you a lot of power\n");
+	printk(KERN_ERR "******* Please consider a BIOS update.\n");
+	printk(KERN_ERR "******* Disabling USB legacy in the BIOS may also help.\n");
+} 
 
 /* Prints also some state that isn't saved in the pt_regs */ 
 void __show_regs(struct pt_regs * regs)
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/setup.c linux-2.6.0/arch/x86_64/kernel/setup.c
--- linux-2.6.0-orig/arch/x86_64/kernel/setup.c	2004-12-21 18:38:40.589921768 +0100
+++ linux-2.6.0/arch/x86_64/kernel/setup.c	2004-12-21 18:39:00.836843768 +0100
@@ -243,6 +243,9 @@
 		}
 #endif
 
+		if (!memcmp(from,"oops=panic", 10))
+			panic_on_oops = 1;
+
 	next_char:
 		c = *(from++);
 		if (!c)
@@ -338,6 +341,7 @@
 void __init setup_arch(char **cmdline_p)
 {
 	unsigned long low_mem_size;
+	unsigned long kernel_end;
 
  	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
  	drive_info = DRIVE_INFO;
@@ -386,7 +390,6 @@
 				(table_end - table_start) << PAGE_SHIFT);
 
 	/* reserve kernel */
-	unsigned long kernel_end;
 	kernel_end = round_up(__pa_symbol(&_end),PAGE_SIZE);
 	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
 
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/signal.c linux-2.6.0/arch/x86_64/kernel/signal.c
--- linux-2.6.0-orig/arch/x86_64/kernel/signal.c	2004-12-21 18:38:40.593921160 +0100
+++ linux-2.6.0/arch/x86_64/kernel/signal.c	2004-12-21 18:39:00.836843768 +0100
@@ -93,6 +93,8 @@
 {
 	unsigned int err = 0;
 
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
 
 #define COPY(x)		err |= __get_user(regs->x, &sc->x)
 
@@ -355,8 +357,6 @@
 		/* If so, check system call restarting.. */
 		switch (regs->rax) {
 		        case -ERESTART_RESTARTBLOCK:
-				current_thread_info()->restart_block.fn = do_no_restart_syscall;
-				/* FALL THROUGH */
 			case -ERESTARTNOHAND:
 				regs->rax = -EINTR;
 				break;
@@ -371,10 +371,6 @@
 				regs->rax = regs->orig_rax;
 				regs->rip -= 2;
 		}
-		if (regs->rax == (unsigned long)-ERESTART_RESTARTBLOCK){
-			regs->rax = __NR_restart_syscall;
- 			regs->rip -= 2;
- 		}		
 	}
 
 #ifdef CONFIG_IA32_EMULATION
@@ -453,6 +449,10 @@
 			regs->rax = regs->orig_rax;
 			regs->rip -= 2;
 		}
+		if (regs->rax == (unsigned long)-ERESTART_RESTARTBLOCK) {
+			regs->rax = __NR_restart_syscall;
+			regs->rip -= 2;
+		}
 	}
 	return 0;
 }
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/smpboot.c linux-2.6.0/arch/x86_64/kernel/smpboot.c
--- linux-2.6.0-orig/arch/x86_64/kernel/smpboot.c	2004-12-21 18:38:40.595920856 +0100
+++ linux-2.6.0/arch/x86_64/kernel/smpboot.c	2004-12-21 18:39:00.837843616 +0100
@@ -54,7 +54,7 @@
 #include <asm/proto.h>
 
 /* Bitmask of currently online CPUs */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map = { 1 };
 
 static cpumask_t cpu_callin_map;
 cpumask_t cpu_callout_map;
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/time.c linux-2.6.0/arch/x86_64/kernel/time.c
--- linux-2.6.0-orig/arch/x86_64/kernel/time.c	2004-12-21 18:38:40.593921160 +0100
+++ linux-2.6.0/arch/x86_64/kernel/time.c	2004-12-21 18:39:00.837843616 +0100
@@ -111,13 +111,21 @@
 		sec = xtime.tv_sec;
 		usec = xtime.tv_nsec / 1000;
 
+#if 0
 		/*
 		 * If time_adjust is negative then NTP is slowing the clock
 		 * so make sure not to go into next possible interval.
 		 * Better to lose some accuracy than have time go backwards..
 		 */
-		if (unlikely(time_adjust < 0) && usec > tickadj)
-			usec = tickadj;
+		unsigned long lost = jiffies - wall_jiffies;
+		if (unlikely(time_adjust < 0)) {
+			unsigned long max_ntp_tick = tick_usec - tickadj;
+			usec = min_t(unsigned, usec, max_ntp_tick);
+			if (lost)
+				usec += lost * max_ntp_tick;
+		} else if (unlikely(lost))
+			usec += lost * tick_usec;
+#endif			
 
 		t = (jiffies - wall_jiffies) * (1000000L / HZ) +
 			do_gettimeoffset();
@@ -592,6 +600,7 @@
 	if (!vxtime.hpet_address)
 		return -1;
 	set_fixmap_nocache(FIX_HPET_BASE, vxtime.hpet_address);
+	__set_fixmap(VSYSCALL_HPET, vxtime.hpet_address, PAGE_KERNEL_VSYSCALL_NOCACHE);
 
 /*
  * Read the period, compute tick and quotient.
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/traps.c linux-2.6.0/arch/x86_64/kernel/traps.c
--- linux-2.6.0-orig/arch/x86_64/kernel/traps.c	2004-12-21 18:38:40.589921768 +0100
+++ linux-2.6.0/arch/x86_64/kernel/traps.c	2004-12-21 18:39:00.838843464 +0100
@@ -218,8 +218,12 @@
 	// debugging aid: "show_stack(NULL, NULL);" prints the
 	// back trace for this cpu.
 
-	if(rsp==NULL)
-		rsp=(unsigned long*)&rsp;
+	if (rsp == NULL) { 
+		if (tsk)
+			rsp = (unsigned long *)tsk->thread.rsp;
+		else
+			rsp = (unsigned long *)&rsp;
+	}
 
 	stack = rsp;
 	for(i=0; i < kstack_depth_to_print; i++) {
@@ -341,6 +345,8 @@
 	bust_spinlocks(0); 
 	spin_unlock(&die_lock); 
 	local_irq_enable();	/* make sure back scroll still works */
+	if (panic_on_oops)
+		panic("Oops"); 
 } 
 
 void __die(const char * str, struct pt_regs * regs, long err)
@@ -844,3 +850,11 @@
 	cpu_init();
 }
 
+
+/* Actual parsing is done early in setup.c. */
+static int __init oops_dummy(char *s)
+{ 
+	panic_on_oops = 1;
+	return -1; 
+} 
+__setup("oops=", oops_dummy); 
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/vmlinux.lds.S linux-2.6.0/arch/x86_64/kernel/vmlinux.lds.S
--- linux-2.6.0-orig/arch/x86_64/kernel/vmlinux.lds.S	2004-12-21 18:38:40.589921768 +0100
+++ linux-2.6.0/arch/x86_64/kernel/vmlinux.lds.S	2004-12-21 18:39:00.838843464 +0100
@@ -62,7 +62,13 @@
   .sysctl_vsyscall : AT ((LOADADDR(.sys_tz) + SIZEOF(.sys_tz) + 15) & ~(15)) { *(.sysctl_vsyscall) }
   sysctl_vsyscall = LOADADDR(.sysctl_vsyscall);
   . = ALIGN(16);
-  .jiffies : AT ((LOADADDR(.sysctl_vsyscall) + SIZEOF(.sysctl_vsyscall) + 15) & ~(15)) { *(.jiffies) }
+  .time_adjust : AT ((LOADADDR(.sysctl_vsyscall) + SIZEOF(.sysctl_vsyscall) + 16) & ~(15)) { *(.time_adjust) }
+  time_adjust = LOADADDR(.time_adjust);
+  . = ALIGN(16);
+  .tick_usec : AT ((LOADADDR(.time_adjust) + SIZEOF(.time_adjust) + 16) & ~(15)) { *(.tick_usec) }
+  tick_usec = LOADADDR(.tick_usec);	
+  . = ALIGN(16);
+  .jiffies : AT ((LOADADDR(.tick_usec) + SIZEOF(.tick_usec) + 16) & ~(15)) { *(.jiffies) }
   jiffies = LOADADDR(.jiffies);
   . = ALIGN(16);
   .xtime : AT ((LOADADDR(.jiffies) + SIZEOF(.jiffies) + 15) & ~(15)) { *(.xtime) }
diff -urN linux-2.6.0-orig/arch/x86_64/kernel/vsyscall.c linux-2.6.0/arch/x86_64/kernel/vsyscall.c
--- linux-2.6.0-orig/arch/x86_64/kernel/vsyscall.c	2004-12-21 18:38:40.594921008 +0100
+++ linux-2.6.0/arch/x86_64/kernel/vsyscall.c	2004-12-21 18:39:00.839843312 +0100
@@ -49,12 +49,15 @@
 #include <asm/page.h>
 #include <asm/fixmap.h>
 #include <asm/errno.h>
+#include <asm/io.h>
 
 #define __vsyscall(nr) __attribute__ ((unused,__section__(".vsyscall_" #nr)))
 #define force_inline __attribute__((always_inline)) inline
 
 int __sysctl_vsyscall __section_sysctl_vsyscall = 1;
 seqlock_t __xtime_lock __section_xtime_lock = SEQLOCK_UNLOCKED;
+long __time_adjust __section_time_adjust; 
+long __tick_usec __section_tick_usec;
 
 #include <asm/unistd.h>
 
@@ -82,6 +85,22 @@
 		usec = (__xtime.tv_nsec / 1000) +
 			(__jiffies - __wall_jiffies) * (1000000 / HZ);
 
+#if 0
+		/*
+		 * If time_adjust is negative then NTP is slowing the clock
+		 * so make sure not to go into next possible interval.
+		 * Better to lose some accuracy than have time go backwards..
+		 */
+		unsigned long lost = __jiffies - __wall_jiffies;
+		if (unlikely(__time_adjust < 0)) {
+			unsigned long max_ntp_tick = __tick_usec - tickadj;
+			usec = min(usec, max_ntp_tick);
+			if (lost)
+				usec += lost * max_ntp_tick;
+		} else if (unlikely(lost))
+			usec += lost * __tick_usec;
+#endif			
+
 		if (__vxtime.mode == VXTIME_TSC) {
 			sync_core();
 			rdtscll(t);
@@ -89,10 +108,8 @@
 			usec += ((t - __vxtime.last_tsc) *
 				 __vxtime.tsc_quot) >> 32;
 		} else {
-#if 0
 			usec += ((readl(fix_to_virt(VSYSCALL_HPET) + 0xf0) -
 				  __vxtime.last) * __vxtime.quot) >> 32;
-#endif
 		}
 	} while (read_seqretry(&__xtime_lock, sequence));
 
diff -urN linux-2.6.0-orig/arch/x86_64/mm/fault.c linux-2.6.0/arch/x86_64/mm/fault.c
--- linux-2.6.0-orig/arch/x86_64/mm/fault.c	2004-12-21 18:38:40.596920704 +0100
+++ linux-2.6.0/arch/x86_64/mm/fault.c	2004-12-21 18:39:00.839843312 +0100
@@ -73,6 +73,9 @@
 	if (regs->cs & (1<<2))
 		return 0;
 
+	if ((regs->cs & 3) != 0 && regs->rip >= TASK_SIZE)
+		return 0;
+
 	while (scan_more && instr < max_instr) { 
 		unsigned char opcode;
 		unsigned char instr_hi;
@@ -337,7 +340,8 @@
 		}
        
 		tsk->thread.cr2 = address;
-		tsk->thread.error_code = error_code;
+		/* Kernel addresses are always protection faults */
+		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
 		tsk->thread.trap_no = 14;
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
@@ -374,7 +378,7 @@
 	printk_address(regs->rip);
 	dump_pagetable(address);
 	__die("Oops", regs, error_code);
-	/* Execute summary in case the body of the oops scrolled away */
+	/* Executive summary in case the body of the oops scrolled away */
 	printk(KERN_EMERG "CR2: %016lx\n", address);
 	oops_end(); 
 	do_exit(SIGKILL);
diff -urN linux-2.6.0-orig/drivers/block/paride/Kconfig linux-2.6.0/drivers/block/paride/Kconfig
--- linux-2.6.0-orig/drivers/block/paride/Kconfig	2004-12-21 18:38:39.737051424 +0100
+++ linux-2.6.0/drivers/block/paride/Kconfig	2004-12-21 18:39:00.840843160 +0100
@@ -130,7 +130,7 @@
 
 config PARIDE_BPCK6
 	tristate "MicroSolutions backpack (Series 6) protocol"
-	depends on PARIDE
+	depends on PARIDE && !64BIT
 	---help---
 	  This option enables support for the Micro Solutions BACKPACK
 	  parallel port Series 6 IDE protocol.  (Most BACKPACK drives made
diff -urN linux-2.6.0-orig/drivers/char/agp/amd64-agp.c linux-2.6.0/drivers/char/agp/amd64-agp.c
--- linux-2.6.0-orig/drivers/char/agp/amd64-agp.c	2004-12-21 18:38:39.505086688 +0100
+++ linux-2.6.0/drivers/char/agp/amd64-agp.c	2004-12-21 18:39:00.841843008 +0100
@@ -16,11 +16,7 @@
 #include "agp.h"
 
 /* Will need to be increased if AMD64 ever goes >8-way. */
-#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
-#else
-#define MAX_HAMMER_GARTS   1
-#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -35,9 +31,18 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* NVIDIA K8 registers */
+#define NVIDIA_X86_64_0_APBASE		0x10
+#define NVIDIA_X86_64_1_APBASE1		0x50
+#define NVIDIA_X86_64_1_APLIMIT1	0x54
+#define NVIDIA_X86_64_1_APSIZE		0xa8
+#define NVIDIA_X86_64_1_APBASE2		0xd8
+#define NVIDIA_X86_64_1_APLIMIT2	0xdc
+
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
+static struct resource *aperture_resource;
 static int __initdata agp_try_unsupported;
 
 static int gart_iterator;
@@ -250,7 +255,6 @@
 /* Some basic sanity checks for the aperture. */
 static int __devinit aperture_valid(u64 aper, u32 size)
 { 
-	static int not_first_call; 
 	u32 pfn, c;
 	if (aper == 0) { 
 		printk(KERN_ERR PFX "No aperture\n");
@@ -279,12 +283,11 @@
 
 	   Maybe better to use pci_assign_resource/pci_enable_device instead trusting
 	   the bridges? */
-	if (!not_first_call && request_mem_region(aper, size, "aperture") < 0) { 
+	if (!aperture_resource && 
+	    !(aperture_resource = request_mem_region(aper, size, "aperture"))) {
 		printk(KERN_ERR PFX "Aperture conflicts with PCI mapping.\n"); 
 		return 0;
 	}
-
-	not_first_call = 1;
 	return 1;
 } 
 
@@ -347,31 +350,124 @@
 	/* cache pci_devs of northbridges. */
 	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
 			!= NULL) {
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
+			return -1;
+		}
 		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) { 
-			printk(KERN_INFO PFX "No usable aperture found.\n");
+			printk(KERN_ERR PFX "No usable aperture found.\n");
 #ifdef __x86_64__ 
 			/* should port this to i386 */
-			printk(KERN_INFO PFX "Consider rebooting with iommu=memaper=2 to get a good aperture.\n");
+			printk(KERN_ERR PFX "Consider rebooting with iommu=memaper=2 to get a good aperture.\n");
 #endif 
 			return -1;  
 		}
 		hammers[i++] = loop_dev;
+	}
 		nr_garts = i;
-		if (i == MAX_HAMMER_GARTS) { 
-			printk(KERN_INFO PFX "Too many northbridges for AGP\n");
-			return -1;
+	return i == 0 ? -1 : 0;
+}
+
+/* Handle AMD 8151 quirks */
+static void __devinit amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)
+
+{		
+	char *revstring;
+	u8 rev_id;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	switch (rev_id) {
+	case 0x01: revstring="A0"; break;
+	case 0x02: revstring="A1"; break;
+	case 0x11: revstring="B0"; break;
+	case 0x12: revstring="B1"; break;
+	case 0x13: revstring="B2"; break;
+	default:   revstring="??"; break;
 		}
+
+	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
+
+	/*
+	 * Work around errata.
+	 * Chips before B2 stepping incorrectly reporting v3.5
+	 */
+	if (rev_id < 0x13) {
+		printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
+		bridge->major_version = 3;
+		bridge->minor_version = 0;
 	}
-	return i == 0 ? -1 : 0;
+}
+
+static struct aper_size_info_32 nforce3_sizes[5] =
+{
+	{512,  131072, 7, 0x00000000 },
+	{256,  65536,  6, 0x00000008 },
+	{128,  32768,  5, 0x0000000C },
+	{64,   16384,  4, 0x0000000E },
+	{32,   8192,   3, 0x0000000F }
+};
+
+/* Handle shadow device of the Nvidia NForce3 */
+/* CHECK-ME original 2.4 version set up some IORRs. Check if that is needed. */
+static int __devinit nforce3_agp_init(struct pci_dev *pdev) 
+{ 
+	u32 tmp, apbase, apbar, aplimit;
+	struct pci_dev *dev1; 
+	int i;
+	unsigned size = amd64_fetch_size(); 
+
+	printk(KERN_INFO PFX "Setting up Nforce3 AGP.\n");
+
+	dev1 = pci_find_slot((unsigned int)pdev->bus->number, PCI_DEVFN(11, 0));
+	if (dev1 == NULL) {
+		printk(KERN_INFO PFX "agpgart: Detected an NVIDIA "
+			"nForce3 chipset, but could not find "
+			"the secondary device.\n");
+		return -ENODEV;
+	}	
+
+	for (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++) 
+		if (nforce3_sizes[i].size == size)
+			break; 
+
+	if (i == ARRAY_SIZE(nforce3_sizes)) {
+		printk(KERN_INFO PFX "No NForce3 size found for %d\n", size); 
+		return -ENODEV; 
+	}
+	
+	pci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);
+	tmp &= ~(0xf);
+	tmp |= nforce3_sizes[i].size_value;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);
+
+	/* shadow x86-64 registers into NVIDIA registers */
+	pci_read_config_dword (hammers[0], AMD64_GARTAPERTUREBASE, &apbase);
+
+	/* if x86-64 aperture base is beyond 4G, exit here */
+	if ( (apbase & 0x7fff) >> (32 - 25) )
+		 return -ENODEV;
+
+	apbase = (apbase & 0x7fff) << 25;
+
+	pci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);
+	apbar &= ~PCI_BASE_ADDRESS_MEM_MASK;
+	apbar |= apbase;
+	pci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);
+
+	aplimit = apbase + (size * 1024 * 1024) - 1;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);
+
+	return 0;
 }
 
 static int __devinit agp_amd64_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	u8 rev_id;
 	u8 cap_ptr;
-	char *revstring=NULL;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 	if (!cap_ptr)
@@ -385,32 +481,7 @@
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-		switch (rev_id) {
-		case 0x01:	revstring="A0";
-				break;
-		case 0x02:	revstring="A1";
-				break;
-		case 0x11:	revstring="B0";
-				break;
-		case 0x12:	revstring="B1";
-				break;
-		case 0x13:	revstring="B2";
-				break;
-		default:	revstring="??";
-				break;
-		}
-		printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
-		/*
-		 * Work around errata.
-		 * Chips before B2 stepping incorrectly reporting v3.5
-		 */
-		if (rev_id < 0x13) {
-			printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
-			bridge->major_version = 3;
-			bridge->minor_version = 0;
-		}
+		amd8151_init(pdev, bridge);
 	} else {
 		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
 			pdev->devfn);
@@ -428,6 +499,14 @@
 		return -ENODEV;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) { 
+		int ret = nforce3_agp_init(pdev);
+		if (ret) { 
+			agp_put_bridge(bridge); 
+			return ret;
+		}
+	}
+
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
 }
@@ -472,8 +551,25 @@
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_SI,
-	.device		= PCI_DEVICE_ID_SI_755,
+	.vendor		= PCI_VENDOR_ID_VIA,
+	.device		= PCI_DEVICE_ID_VIA_8380_0,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	/* NForce3 */
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S,
 	.subvendor	= PCI_ANY_ID,
 	.subdevice	= PCI_ANY_ID,
 	},
@@ -530,6 +626,8 @@
 
 static void __exit agp_amd64_cleanup(void)
 {
+	if (aperture_resource) 
+		release_resource(aperture_resource);
 	pci_unregister_driver(&agp_amd64_pci_driver);
 }
 
diff -urN linux-2.6.0-orig/drivers/char/drm/Kconfig linux-2.6.0/drivers/char/drm/Kconfig
--- linux-2.6.0-orig/drivers/char/drm/Kconfig	2004-12-21 18:38:39.488089272 +0100
+++ linux-2.6.0/drivers/char/drm/Kconfig	2004-12-21 18:39:00.841843008 +0100
@@ -64,10 +64,9 @@
 	  module will be called i830.  AGP support is required for this driver
 	  to work.
 
-
 config DRM_MGA
 	tristate "Matrox g200/g400"
-	depends on DRM && AGP
+	depends on DRM && AGP && (!X86_64 || BROKEN) 
 	help
 	  Choose this option if you have a Matrox G200, G400 or G450 graphics
 	  card.  If M is selected, the module will be called mga.  AGP
diff -urN linux-2.6.0-orig/drivers/net/pcmcia/Kconfig linux-2.6.0/drivers/net/pcmcia/Kconfig
--- linux-2.6.0-orig/drivers/net/pcmcia/Kconfig	2004-12-21 18:38:39.193134112 +0100
+++ linux-2.6.0/drivers/net/pcmcia/Kconfig	2004-12-21 18:39:00.841843008 +0100
@@ -119,7 +119,7 @@
 
 config PCMCIA_IBMTR
 	tristate "IBM PCMCIA tokenring adapter support"
-	depends on NET_PCMCIA && IBMTR!=y && TR && PCMCIA
+	depends on NET_PCMCIA && IBMTR!=y && TR && PCMCIA && !64BIT
 	help
 	  Say Y here if you intend to attach this type of Token Ring PCMCIA
 	  card to your computer. You then also need to say Y to "Token Ring
diff -urN linux-2.6.0-orig/drivers/scsi/Kconfig linux-2.6.0/drivers/scsi/Kconfig
--- linux-2.6.0-orig/drivers/scsi/Kconfig	2004-12-21 18:38:39.658063432 +0100
+++ linux-2.6.0/drivers/scsi/Kconfig	2004-12-21 18:39:00.842842856 +0100
@@ -1408,7 +1408,7 @@
 
 config SCSI_NSP32
 	tristate "Workbit NinjaSCSI-32Bi/UDE support"
-	depends on PCI && SCSI
+	depends on PCI && SCSI && !64BIT
 	help
 	  This is support for the Workbit NinjaSCSI-32Bi/UDE PCI/Cardbus
 	  SCSI host adapter. Please read the SCSI-HOWTO, available from
diff -urN linux-2.6.0-orig/drivers/scsi/pcmcia/Kconfig linux-2.6.0/drivers/scsi/pcmcia/Kconfig
--- linux-2.6.0-orig/drivers/scsi/pcmcia/Kconfig	2004-12-21 18:38:39.586074376 +0100
+++ linux-2.6.0/drivers/scsi/pcmcia/Kconfig	2004-12-21 18:39:00.843842704 +0100
@@ -27,7 +27,7 @@
 
 config PCMCIA_NINJA_SCSI
 	tristate "NinjaSCSI-3 / NinjaSCSI-32Bi (16bit) PCMCIA support"
-	depends on m
+	depends on m && !64BIT
 	help
 	  If you intend to attach this type of PCMCIA SCSI host adapter to
 	  your computer, say Y here and read
diff -urN linux-2.6.0-orig/include/asm-generic/statfs.h linux-2.6.0/include/asm-generic/statfs.h
--- linux-2.6.0-orig/include/asm-generic/statfs.h	2004-12-21 18:38:40.742898512 +0100
+++ linux-2.6.0/include/asm-generic/statfs.h	2004-12-21 18:39:00.843842704 +0100
@@ -34,4 +34,18 @@
 	__u32 f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -urN linux-2.6.0-orig/include/asm-ia64/statfs.h linux-2.6.0/include/asm-ia64/statfs.h
--- linux-2.6.0-orig/include/asm-ia64/statfs.h	2004-12-21 18:38:40.809888328 +0100
+++ linux-2.6.0/include/asm-ia64/statfs.h	2004-12-21 18:39:00.843842704 +0100
@@ -43,5 +43,18 @@
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
 
 #endif /* _ASM_IA64_STATFS_H */
diff -urN linux-2.6.0-orig/include/asm-mips/statfs.h linux-2.6.0/include/asm-mips/statfs.h
--- linux-2.6.0-orig/include/asm-mips/statfs.h	2004-12-21 18:38:40.769894408 +0100
+++ linux-2.6.0/include/asm-mips/statfs.h	2004-12-21 18:39:00.843842704 +0100
@@ -75,6 +75,20 @@
 	long		f_spare[6];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #endif /* _ASM_STATFS_H */
diff -urN linux-2.6.0-orig/include/asm-parisc/statfs.h linux-2.6.0/include/asm-parisc/statfs.h
--- linux-2.6.0-orig/include/asm-parisc/statfs.h	2004-12-21 18:38:40.638914320 +0100
+++ linux-2.6.0/include/asm-parisc/statfs.h	2004-12-21 18:39:00.844842552 +0100
@@ -41,4 +41,18 @@
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -urN linux-2.6.0-orig/include/asm-ppc64/statfs.h linux-2.6.0/include/asm-ppc64/statfs.h
--- linux-2.6.0-orig/include/asm-ppc64/statfs.h	2004-12-21 18:38:40.738899120 +0100
+++ linux-2.6.0/include/asm-ppc64/statfs.h	2004-12-21 18:39:00.844842552 +0100
@@ -44,4 +44,18 @@
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif  /* _PPC64_STATFS_H */
diff -urN linux-2.6.0-orig/include/asm-s390/statfs.h linux-2.6.0/include/asm-s390/statfs.h
--- linux-2.6.0-orig/include/asm-s390/statfs.h	2004-12-21 18:38:40.951866744 +0100
+++ linux-2.6.0/include/asm-s390/statfs.h	2004-12-21 18:39:00.844842552 +0100
@@ -53,5 +53,19 @@
 	int  f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif /* __s390x__ */
 #endif
diff -urN linux-2.6.0-orig/include/asm-sparc64/statfs.h linux-2.6.0/include/asm-sparc64/statfs.h
--- linux-2.6.0-orig/include/asm-sparc64/statfs.h	2004-12-21 18:38:40.985861576 +0100
+++ linux-2.6.0/include/asm-sparc64/statfs.h	2004-12-21 18:39:00.844842552 +0100
@@ -38,4 +38,18 @@
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+};
+
 #endif
diff -urN linux-2.6.0-orig/include/asm-x86_64/acpi.h linux-2.6.0/include/asm-x86_64/acpi.h
--- linux-2.6.0-orig/include/asm-x86_64/acpi.h	2004-12-21 18:38:40.627915992 +0100
+++ linux-2.6.0/include/asm-x86_64/acpi.h	2004-12-21 18:39:00.845842400 +0100
@@ -52,40 +52,36 @@
 #define ACPI_ENABLE_IRQS()  local_irq_enable()
 #define ACPI_FLUSH_CPU_CACHE()	wbinvd()
 
-/*
- * A brief explanation as GNU inline assembly is a bit hairy
- *  %0 is the output parameter in RAX ("=a")
- *  %1 and %2 are the input parameters in RCX ("c")
- *  and an immediate value ("i") respectively
- *  All actual register references are preceded with "%%" as in "%%edx"
- *  Immediate values in the assembly are preceded by "$" as in "$0x1"
- *  The final asm parameter are the operation altered non-output registers.
- */
+
+static inline int
+__acpi_acquire_global_lock (unsigned int *lock)
+{
+	unsigned int old, new, val;
+	do {
+		old = *lock;
+		new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
+		val = cmpxchg4_locked(lock, new, old);
+	} while (unlikely (val != old));
+	return (new < 3) ? -1 : 0;
+}
+
+static inline int
+__acpi_release_global_lock (unsigned int *lock)
+{
+	unsigned int old, new, val;
+	do {
+		old = *lock;
+		new = old & ~0x3;
+		val = cmpxchg4_locked(lock, new, old);
+	} while (unlikely (val != old));
+	return old & 0x1;
+}
+
 #define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"btsl   $0x1,%%edx;" \
-			"adcl   $0x0,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"cmpb   $0x3,%%dl;" \
-			"sbbl   %%eax,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
-	} while(0)
+	((Acq) = __acpi_acquire_global_lock((unsigned int *) GLptr))
+
 #define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"andl   $0x1,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
-	} while(0)
+	((Acq) = __acpi_release_global_lock((unsigned int *) GLptr))
 
 /*
  * Math helper asm macros
diff -urN linux-2.6.0-orig/include/asm-x86_64/apic.h linux-2.6.0/include/asm-x86_64/apic.h
--- linux-2.6.0-orig/include/asm-x86_64/apic.h	2004-12-21 18:38:40.630915536 +0100
+++ linux-2.6.0/include/asm-x86_64/apic.h	2004-12-21 18:39:00.845842400 +0100
@@ -79,7 +79,7 @@
 extern void enable_lapic_nmi_watchdog(void);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
+extern void nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -urN linux-2.6.0-orig/include/asm-x86_64/bitops.h linux-2.6.0/include/asm-x86_64/bitops.h
--- linux-2.6.0-orig/include/asm-x86_64/bitops.h	2004-12-21 18:38:40.625916296 +0100
+++ linux-2.6.0/include/asm-x86_64/bitops.h	2004-12-21 18:39:00.846842248 +0100
@@ -7,14 +7,6 @@
 
 #include <linux/config.h>
 
-/*
- * These have to be done with inline assembly: that way the bit-setting
- * is guaranteed to be atomic. All bit operations return 0 if the bit
- * was cleared before the operation and != 0 if it was not.
- *
- * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
- */
-
 #ifdef CONFIG_SMP
 #define LOCK_PREFIX "lock ; "
 #else
@@ -363,26 +355,26 @@
  */
 static __inline__ int find_next_bit(const unsigned long * addr, int size, int offset)
 {
-	unsigned int * p = ((unsigned int *) addr) + (offset >> 5);
-	int set = 0, bit = offset & 31, res;
+	const unsigned long * p = addr + (offset >> 6);
+	unsigned long set = 0, bit = offset & 63, res;
 	
 	if (bit) {
 		/*
-		 * Look for nonzero in the first 32 bits:
+		 * Look for nonzero in the first 64 bits:
 		 */
-		__asm__("bsfl %1,%0\n\t"
-			"cmovel %2,%0\n\t"
+		__asm__("bsfq %1,%0\n\t"
+			"cmoveq %2,%0\n\t"
 			: "=r" (set)
-			: "r" (*p >> bit), "r" (32));
-		if (set < (32 - bit))
+			: "r" (*p >> bit), "r" (64L));
+		if (set < (64 - bit))
 			return set + offset;
-		set = 32 - bit;
+		set = 64 - bit;
 		p++;
 	}
 	/*
 	 * No set bit yet, search remaining full words for a bit
 	 */
-	res = find_first_bit ((const unsigned long *)p, size - 32 * (p - (unsigned int *) addr));
+	res = find_first_bit (p, size - 64 * (p - addr));
 	return (offset + set + res);
 }
 
diff -urN linux-2.6.0-orig/include/asm-x86_64/calling.h linux-2.6.0/include/asm-x86_64/calling.h
--- linux-2.6.0-orig/include/asm-x86_64/calling.h	2004-12-21 18:38:40.627915992 +0100
+++ linux-2.6.0/include/asm-x86_64/calling.h	2004-12-21 18:39:00.846842248 +0100
@@ -8,7 +8,7 @@
 #define R14 8
 #define R13 16
 #define R12 24
-#define RBP 36
+#define RBP 32
 #define RBX 40
 /* arguments: interrupts/non tracing syscalls only save upto here*/
 #define R11 48
diff -urN linux-2.6.0-orig/include/asm-x86_64/cpu.h linux-2.6.0/include/asm-x86_64/cpu.h
--- linux-2.6.0-orig/include/asm-x86_64/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0/include/asm-x86_64/cpu.h	2004-12-21 18:39:00.846842248 +0100
@@ -0,0 +1 @@
+#include <asm-i386/cpu.h>
diff -urN linux-2.6.0-orig/include/asm-x86_64/desc.h linux-2.6.0/include/asm-x86_64/desc.h
--- linux-2.6.0-orig/include/asm-x86_64/desc.h	2004-12-21 18:38:40.632915232 +0100
+++ linux-2.6.0/include/asm-x86_64/desc.h	2004-12-21 18:39:00.846842248 +0100
@@ -190,7 +190,7 @@
 /*
  * load one particular LDT into the current CPU
  */
-extern inline void load_LDT_nolock (mm_context_t *pc, int cpu)
+static inline void load_LDT_nolock (mm_context_t *pc, int cpu)
 {
 	int count = pc->size;
 
diff -urN linux-2.6.0-orig/include/asm-x86_64/fixmap.h linux-2.6.0/include/asm-x86_64/fixmap.h
--- linux-2.6.0-orig/include/asm-x86_64/fixmap.h	2004-12-21 18:38:40.624916448 +0100
+++ linux-2.6.0/include/asm-x86_64/fixmap.h	2004-12-21 18:39:00.847842096 +0100
@@ -76,7 +76,7 @@
  * directly without translation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-extern inline unsigned long fix_to_virt(const unsigned int idx)
+static inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -urN linux-2.6.0-orig/include/asm-x86_64/io.h linux-2.6.0/include/asm-x86_64/io.h
--- linux-2.6.0-orig/include/asm-x86_64/io.h	2004-12-21 18:38:40.625916296 +0100
+++ linux-2.6.0/include/asm-x86_64/io.h	2004-12-21 18:39:00.847842096 +0100
@@ -52,7 +52,7 @@
  * Talk about misusing macros..
  */
 #define __OUT1(s,x) \
-extern inline void out##s(unsigned x value, unsigned short port) {
+static inline void out##s(unsigned x value, unsigned short port) {
 
 #define __OUT2(s,s1,s2) \
 __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
@@ -62,7 +62,7 @@
 __OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
 
 #define __IN1(s) \
-extern inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
 
 #define __IN2(s,s1,s2) \
 __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
@@ -72,12 +72,12 @@
 __IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
 
 #define __INS(s) \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; ins" #s \
 : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
 #define __OUTS(s) \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; outs" #s \
 : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
@@ -125,12 +125,12 @@
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return __pa(address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return __va(address);
 }
@@ -148,7 +148,7 @@
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
@@ -304,8 +304,8 @@
 /* Disable vmerge for now. Need to fix the block layer code
    to check for non iommu addresses first.
    When the IOMMU is force it is safe to enable. */
-extern int force_iommu; 
-#define BIO_VERMGE_BOUNDARY (force_iommu ? 4096 : 0)
+extern int iommu_merge;
+#define BIO_VMERGE_BOUNDARY (iommu_merge ? 4096 : 0)
 
 #endif /* __KERNEL__ */
 
diff -urN linux-2.6.0-orig/include/asm-x86_64/memblk.h linux-2.6.0/include/asm-x86_64/memblk.h
--- linux-2.6.0-orig/include/asm-x86_64/memblk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0/include/asm-x86_64/memblk.h	2004-12-21 18:39:00.847842096 +0100
@@ -0,0 +1 @@
+#include <asm-i386/memblk.h>
diff -urN linux-2.6.0-orig/include/asm-x86_64/msr.h linux-2.6.0/include/asm-x86_64/msr.h
--- linux-2.6.0-orig/include/asm-x86_64/msr.h	2004-12-21 18:38:40.630915536 +0100
+++ linux-2.6.0/include/asm-x86_64/msr.h	2004-12-21 18:39:00.848841944 +0100
@@ -67,7 +67,7 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
-extern inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+static inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
 {
 	__asm__("cpuid"
 		: "=a" (*eax),
@@ -80,7 +80,7 @@
 /*
  * CPUID functions returning a single datum
  */
-extern inline unsigned int cpuid_eax(unsigned int op)
+static inline unsigned int cpuid_eax(unsigned int op)
 {
 	unsigned int eax;
 
@@ -90,7 +90,7 @@
 		: "bx", "cx", "dx");
 	return eax;
 }
-extern inline unsigned int cpuid_ebx(unsigned int op)
+static inline unsigned int cpuid_ebx(unsigned int op)
 {
 	unsigned int eax, ebx;
 
@@ -100,7 +100,7 @@
 		: "cx", "dx" );
 	return ebx;
 }
-extern inline unsigned int cpuid_ecx(unsigned int op)
+static inline unsigned int cpuid_ecx(unsigned int op)
 {
 	unsigned int eax, ecx;
 
@@ -110,7 +110,7 @@
 		: "bx", "dx" );
 	return ecx;
 }
-extern inline unsigned int cpuid_edx(unsigned int op)
+static inline unsigned int cpuid_edx(unsigned int op)
 {
 	unsigned int eax, edx;
 
diff -urN linux-2.6.0-orig/include/asm-x86_64/node.h linux-2.6.0/include/asm-x86_64/node.h
--- linux-2.6.0-orig/include/asm-x86_64/node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0/include/asm-x86_64/node.h	2004-12-21 18:39:00.848841944 +0100
@@ -0,0 +1 @@
+#include <asm-i386/node.h>
diff -urN linux-2.6.0-orig/include/asm-x86_64/pgalloc.h linux-2.6.0/include/asm-x86_64/pgalloc.h
--- linux-2.6.0-orig/include/asm-x86_64/pgalloc.h	2004-12-21 18:38:40.626916144 +0100
+++ linux-2.6.0/include/asm-x86_64/pgalloc.h	2004-12-21 18:39:00.848841944 +0100
@@ -69,7 +69,7 @@
 	free_page((unsigned long)pte); 
 }
 
-extern inline void pte_free(struct page *pte)
+static inline void pte_free(struct page *pte)
 {
 	__free_page(pte);
 } 
diff -urN linux-2.6.0-orig/include/asm-x86_64/pgtable.h linux-2.6.0/include/asm-x86_64/pgtable.h
--- linux-2.6.0-orig/include/asm-x86_64/pgtable.h	2004-12-21 18:38:40.628915840 +0100
+++ linux-2.6.0/include/asm-x86_64/pgtable.h	2004-12-21 18:39:00.849841792 +0100
@@ -71,7 +71,7 @@
 #define pml4_none(x)	(!pml4_val(x))
 #define pgd_none(x)	(!pgd_val(x))
 
-extern inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
+static inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
 
 static inline void set_pte(pte_t *dst, pte_t val)
 {
@@ -88,7 +88,7 @@
 	pgd_val(*dst) = pgd_val(val); 
 } 
 
-extern inline void pgd_clear (pgd_t * pgd)
+static inline void pgd_clear (pgd_t * pgd)
 {
 	set_pgd(pgd, __pgd(0));
 }
@@ -180,6 +180,8 @@
 	(_PAGE_PRESENT | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
 #define __PAGE_KERNEL_VSYSCALL \
 	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define __PAGE_KERNEL_VSYSCALL_NOCACHE \
+	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_PCD)
 #define __PAGE_KERNEL_LARGE \
 	(__PAGE_KERNEL | _PAGE_PSE)
 
@@ -191,6 +193,7 @@
 #define PAGE_KERNEL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
 #define PAGE_KERNEL_VSYSCALL MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL)
 #define PAGE_KERNEL_LARGE MAKE_GLOBAL(__PAGE_KERNEL_LARGE)
+#define PAGE_KERNEL_VSYSCALL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL_NOCACHE)
 
 /*         xwr */
 #define __P000	PAGE_NONE
@@ -242,23 +245,23 @@
  * Undefined behaviour if not..
  */
 static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
 static inline int pte_file(pte_t pte)		{ return pte_val(pte) & _PAGE_FILE; }
 
-extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
 static inline  int ptep_test_and_clear_dirty(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep); }
 static inline  int ptep_test_and_clear_young(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
 static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, ptep); }
@@ -359,7 +362,7 @@
 }
  
 /* Change flags of a PTE */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { 
 	pte_val(pte) &= _PAGE_CHG_MASK;
 	pte_val(pte) |= pgprot_val(newprot);
diff -urN linux-2.6.0-orig/include/asm-x86_64/processor.h linux-2.6.0/include/asm-x86_64/processor.h
--- linux-2.6.0-orig/include/asm-x86_64/processor.h	2004-12-21 18:38:40.631915384 +0100
+++ linux-2.6.0/include/asm-x86_64/processor.h	2004-12-21 18:39:00.849841792 +0100
@@ -304,13 +304,13 @@
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
-extern inline void rep_nop(void)
+static inline void rep_nop(void)
 {
 	__asm__ __volatile__("rep;nop": : :"memory");
 }
 
 /* Stop speculative execution */
-extern inline void sync_core(void)
+static inline void sync_core(void)
 { 
 	int tmp;
 	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
diff -urN linux-2.6.0-orig/include/asm-x86_64/smp.h linux-2.6.0/include/asm-x86_64/smp.h
--- linux-2.6.0-orig/include/asm-x86_64/smp.h	2004-12-21 18:38:40.622916752 +0100
+++ linux-2.6.0/include/asm-x86_64/smp.h	2004-12-21 18:39:00.850841640 +0100
@@ -74,7 +74,7 @@
 	return GET_APIC_ID(*(unsigned int *)(APIC_BASE+APIC_ID));
 }
 
-#define safe_smp_processor_id() (cpuid_ebx(1) >> 24) 
+#define safe_smp_processor_id() (disable_apic ? 0 : hard_smp_processor_id())
 
 #define cpu_online(cpu) cpu_isset(cpu, cpu_online_map)
 #endif /* !ASSEMBLY */
diff -urN linux-2.6.0-orig/include/asm-x86_64/statfs.h linux-2.6.0/include/asm-x86_64/statfs.h
--- linux-2.6.0-orig/include/asm-x86_64/statfs.h	2004-12-21 18:38:40.628915840 +0100
+++ linux-2.6.0/include/asm-x86_64/statfs.h	2004-12-21 18:39:00.850841640 +0100
@@ -41,4 +41,18 @@
 	long f_spare[5];
 };
 
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+} __attribute__((packed));
+
 #endif
diff -urN linux-2.6.0-orig/include/asm-x86_64/system.h linux-2.6.0/include/asm-x86_64/system.h
--- linux-2.6.0-orig/include/asm-x86_64/system.h	2004-12-21 18:38:40.629915688 +0100
+++ linux-2.6.0/include/asm-x86_64/system.h	2004-12-21 18:39:00.850841640 +0100
@@ -188,7 +188,7 @@
 
 #define __xg(x) ((volatile long *)(x))
 
-extern inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
 {
 	*ptr = val;
 }
@@ -276,6 +276,13 @@
 	((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
 					(unsigned long)(n),sizeof(*(ptr))))
 
+static inline __u32 cmpxchg4_locked(__u32 *ptr, __u32 old, __u32 new) 
+{
+	asm volatile("lock ; cmpxchgl %k1,%2" :
+		     "=r" (new) : "0" (old), "m" (*(__u32 *)ptr) : "memory");
+	return new; 
+}
+
 #ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
@@ -314,7 +321,21 @@
 #define local_irq_disable() 	__asm__ __volatile__("cli": : :"memory")
 #define local_irq_enable()	__asm__ __volatile__("sti": : :"memory")
 /* used in the idle loop; sti takes one instruction cycle to complete */
-#define safe_halt()		__asm__ __volatile__("sti; hlt": : :"memory")
+
+/* Work around BIOS that don't have K8 Errata #93 fixed. */
+#define safe_halt()	      \
+	asm volatile("   sti\n"					\
+		     "1: hlt\n"						\
+		     "2:\n"							\
+		     ".section .fixup,\"ax\"\n"		\
+		     "3: call idle_warning\n"		\
+		     "   jmp 2b\n"					\
+		     ".previous\n"					\
+		     ".section __ex_table,\"a\"\n\t"	\
+		     ".align 8\n\t"					\
+		     ".quad 1b,3b\n"				\
+		     ".previous" ::: "memory")
+
 #define irqs_disabled()			\
 ({					\
 	unsigned long flags;		\
diff -urN linux-2.6.0-orig/include/asm-x86_64/timex.h linux-2.6.0/include/asm-x86_64/timex.h
--- linux-2.6.0-orig/include/asm-x86_64/timex.h	2004-12-21 18:38:40.627915992 +0100
+++ linux-2.6.0/include/asm-x86_64/timex.h	2004-12-21 18:39:00.851841488 +0100
@@ -60,4 +60,7 @@
 
 extern struct vxtime_data vxtime;
 
+#define ARCH_HAS_TIMEVARS 1
+
+
 #endif
diff -urN linux-2.6.0-orig/include/asm-x86_64/topology.h linux-2.6.0/include/asm-x86_64/topology.h
--- linux-2.6.0-orig/include/asm-x86_64/topology.h	2004-12-21 18:38:40.628915840 +0100
+++ linux-2.6.0/include/asm-x86_64/topology.h	2004-12-21 18:39:00.851841488 +0100
@@ -23,6 +23,7 @@
 
 static inline unsigned long pcibus_to_cpumask(int bus)
 {
+	BUG_ON(bus >= MAX_MP_BUSSES);
 	return mp_bus_to_cpumask[bus] & cpu_online_map; 
 }
 
diff -urN linux-2.6.0-orig/include/asm-x86_64/uaccess.h linux-2.6.0/include/asm-x86_64/uaccess.h
--- linux-2.6.0-orig/include/asm-x86_64/uaccess.h	2004-12-21 18:38:40.624916448 +0100
+++ linux-2.6.0/include/asm-x86_64/uaccess.h	2004-12-21 18:39:00.851841488 +0100
@@ -48,7 +48,7 @@
 
 #define access_ok(type,addr,size) (__range_not_ok(addr,size) == 0)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
diff -urN linux-2.6.0-orig/include/asm-x86_64/unistd.h linux-2.6.0/include/asm-x86_64/unistd.h
--- linux-2.6.0-orig/include/asm-x86_64/unistd.h	2004-12-21 18:38:40.627915992 +0100
+++ linux-2.6.0/include/asm-x86_64/unistd.h	2004-12-21 18:39:00.852841336 +0100
@@ -623,11 +623,11 @@
 type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,type6 arg6) \
 { \
 long __res; \
-__asm__ volatile ("movq %5,%%r10 ; movq %6,%%r8 ; movq %7,%%r9" __syscall \
+__asm__ volatile ("movq %5,%%r10 ; movq %6,%%r8 ; movq %7,%%r9 ; " __syscall \
 	: "=a" (__res) \
 	: "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)), \
-	  "d" ((long)(arg3)),"g" ((long)(arg4)),"g" ((long)(arg5), \
-	  "g" ((long)(arg6),) : \
+	  "d" ((long)(arg3)), "g" ((long)(arg4)), "g" ((long)(arg5)), \
+	  "g" ((long)(arg6)) : \
 	__syscall_clobber,"r8","r10","r9" ); \
 __syscall_return(type,__res); \
 }
diff -urN linux-2.6.0-orig/include/asm-x86_64/vsyscall.h linux-2.6.0/include/asm-x86_64/vsyscall.h
--- linux-2.6.0-orig/include/asm-x86_64/vsyscall.h	2004-12-21 18:38:40.631915384 +0100
+++ linux-2.6.0/include/asm-x86_64/vsyscall.h	2004-12-21 18:39:00.852841336 +0100
@@ -15,6 +15,8 @@
 
 #ifdef __KERNEL__
 
+/* FIXME: put all this into a single section */ 
+
 #define __section_vxtime __attribute__ ((unused, __section__ (".vxtime"), aligned(16)))
 #define __section_wall_jiffies __attribute__ ((unused, __section__ (".wall_jiffies"), aligned(16)))
 #define __section_jiffies __attribute__ ((unused, __section__ (".jiffies"), aligned(16)))
@@ -22,6 +24,8 @@
 #define __section_sysctl_vsyscall __attribute__ ((unused, __section__ (".sysctl_vsyscall"), aligned(16)))
 #define __section_xtime __attribute__ ((unused, __section__ (".xtime"), aligned(16)))
 #define __section_xtime_lock __attribute__ ((unused, __section__ (".xtime_lock"), aligned(L1_CACHE_BYTES)))
+#define __section_time_adjust __attribute__ ((unused, __section__ (".time_adjust"), aligned(16)))
+#define __section_tick_usec __attribute__ ((unused, __section__ (".tick_usec"), aligned(16)))
 
 #define VXTIME_TSC	1
 #define VXTIME_HPET	2
@@ -46,6 +50,8 @@
 extern unsigned long __wall_jiffies;
 extern struct timezone __sys_tz;
 extern seqlock_t __xtime_lock;
+extern long __time_adjust;
+extern long __tick_usec;
 
 /* kernel space (writeable) */
 extern struct vxtime_data vxtime;
@@ -53,6 +59,8 @@
 extern struct timezone sys_tz;
 extern int sysctl_vsyscall;
 extern seqlock_t xtime_lock;
+extern long time_adjust;
+extern unsigned long tick_usec;
 
 #define ARCH_HAVE_XTIME_LOCK 1
 
diff -urN linux-2.6.0-orig/include/linux/compat.h linux-2.6.0/include/linux/compat.h
--- linux-2.6.0-orig/include/linux/compat.h	2004-12-21 18:38:40.685907176 +0100
+++ linux-2.6.0/include/linux/compat.h	2004-12-21 18:39:00.852841336 +0100
@@ -76,20 +76,6 @@
 	compat_long_t	ru_nivcsw;
 };
 
-struct compat_statfs64 {
-	__u32 f_type;
-	__u32 f_bsize;
-	__u64 f_blocks;
-	__u64 f_bfree;
-	__u64 f_bavail;
-	__u64 f_files;
-	__u64 f_ffree;
-	__kernel_fsid_t f_fsid;
-	__u32 f_namelen;
-	__u32 f_frsize;
-	__u32 f_spare[5];
-};
-
 struct compat_dirent {
 	u32		d_ino;
 	compat_off_t	d_off;
diff -urN linux-2.6.0-orig/include/linux/compat_ioctl.h linux-2.6.0/include/linux/compat_ioctl.h
--- linux-2.6.0-orig/include/linux/compat_ioctl.h	2004-12-21 18:38:40.720901856 +0100
+++ linux-2.6.0/include/linux/compat_ioctl.h	2004-12-21 18:39:00.853841184 +0100
@@ -260,6 +260,7 @@
 COMPATIBLE_IOCTL(SIOCSIFLINK)
 COMPATIBLE_IOCTL(SIOCSIFENCAP)
 COMPATIBLE_IOCTL(SIOCGIFENCAP)
+COMPATIBLE_IOCTL(SIOCSIFNAME)
 COMPATIBLE_IOCTL(SIOCSIFBR)
 COMPATIBLE_IOCTL(SIOCGIFBR)
 COMPATIBLE_IOCTL(SIOCSARP)
diff -urN linux-2.6.0-orig/include/linux/pci_ids.h linux-2.6.0/include/linux/pci_ids.h
--- linux-2.6.0-orig/include/linux/pci_ids.h	2004-12-21 18:38:40.681907784 +0100
+++ linux-2.6.0/include/linux/pci_ids.h	2004-12-21 18:39:00.854841032 +0100
@@ -1031,6 +1031,8 @@
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE	0x0085
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA	0x008e
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3		0x00d1
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S  		0x00e1
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE	0x00d5
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA	0x00e3
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE	0x00e5
diff -urN linux-2.6.0-orig/include/linux/timex.h linux-2.6.0/include/linux/timex.h
--- linux-2.6.0-orig/include/linux/timex.h	2004-12-21 18:38:40.660910976 +0100
+++ linux-2.6.0/include/linux/timex.h	2004-12-21 18:39:00.855840880 +0100
@@ -282,7 +282,7 @@
  */
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
 extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
-extern int tickadj;			/* amount of adjustment per tick */
+#define tickadj ((int)(500/HZ ? : 1))
 
 /*
  * phase-lock loop variables
diff -urN linux-2.6.0-orig/kernel/timer.c linux-2.6.0/kernel/timer.c
--- linux-2.6.0-orig/kernel/timer.c	2004-12-21 18:38:42.155683736 +0100
+++ linux-2.6.0/kernel/timer.c	2004-12-21 18:39:00.856840728 +0100
@@ -436,7 +436,18 @@
 /*
  * Timekeeping variables
  */
+
+/* 
+ * Any variables used in low level gettimeofday must be declared
+ * inside ARCH_HAS_TIMEVARS. This is requires for x86-64 who
+ * can run gettimeofday in user context in a vsyscall. The variables
+ * must be mapped in a special way in the low level architecture code
+ * then. -AK
+ */ 
+
+#ifndef ARCH_HAS_TIMEVARS
 unsigned long tick_usec = TICK_USEC; 		/* USER_HZ period (usec) */
+#endif
 unsigned long tick_nsec = TICK_NSEC;		/* ACTHZ period (nsec) */
 
 /* 
@@ -452,10 +463,6 @@
 
 EXPORT_SYMBOL(xtime);
 
-/* Don't completely fail for HZ > 500.  */
-int tickadj = 500/HZ ? : 1;		/* microsecs */
-
-
 /*
  * phase-lock loop variables
  */
@@ -473,7 +480,9 @@
 					/* frequency offset (scaled ppm)*/
 long time_adj;				/* tick adjust (scaled 1 / HZ)	*/
 long time_reftime;			/* time at last adjustment (s)	*/
+#ifndef ARCH_HAS_TIMEVARS
 long time_adjust;
+#endif
 long time_next_adjust;
 
 /*
