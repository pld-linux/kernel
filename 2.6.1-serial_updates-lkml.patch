diff -Nru a/drivers/serial/8250_acpi.c b/drivers/serial/8250_acpi.c
--- a/drivers/serial/8250_acpi.c	Fri Jan 16 22:06:23 2004
+++ b/drivers/serial/8250_acpi.c	Fri Jan 16 22:06:23 2004
@@ -1,6 +1,7 @@
 /*
- * serial/acpi.c
  * Copyright (c) 2002-2003 Matthew Wilcox for Hewlett-Packard
+ * Copyright (C) 2004 Hewlett-Packard Co
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -11,13 +12,21 @@
 #include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/tty.h>
 #include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_core.h>
 
 #include <acpi/acpi_bus.h>
 
 #include <asm/io.h>
 #include <asm/serial.h>
 
+struct serial_private {
+	int	line;
+	void	*iomem_base;
+};
+
 static acpi_status acpi_serial_mmio(struct serial_struct *req,
 				    struct acpi_resource_address64 *addr)
 {
@@ -94,38 +103,72 @@
 
 static int acpi_serial_add(struct acpi_device *device)
 {
+	struct serial_private *priv;
 	acpi_status status;
 	struct serial_struct serial_req;
-	int line;
+	int result;
 
 	memset(&serial_req, 0, sizeof(serial_req));
 
+	priv = kmalloc(sizeof(struct serial_private), GFP_KERNEL);
+	if (!priv) {
+		result = -ENOMEM;
+		goto fail;
+	}
+	memset(priv, 0, sizeof(*priv));
+
 	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
 				     acpi_serial_resource, &serial_req);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+		goto fail;
+	}
 
-	if (!serial_req.iomem_base && !serial_req.port) {
+	if (serial_req.iomem_base)
+		priv->iomem_base = serial_req.iomem_base;
+	else if (!serial_req.port) {
 		printk(KERN_ERR "%s: no iomem or port address in %s _CRS\n",
 			__FUNCTION__, device->pnp.bus_id);
-		return -ENODEV;
+		result = -ENODEV;
+		goto fail;
 	}
 
 	serial_req.baud_base = BASE_BAUD;
-	serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|ASYNC_AUTO_IRQ;
+	serial_req.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF |
+			   UPF_AUTO_IRQ  | UPF_RESOURCES;
 
-	line = register_serial(&serial_req);
-	if (line < 0) {
-		printk(KERN_WARNING "Couldn't register serial port %s: %d",
-			device->pnp.bus_id, line);
-		return -ENODEV;
+	priv->line = register_serial(&serial_req);
+	if (priv->line < 0) {
+		printk(KERN_WARNING "Couldn't register serial port %s: %d\n",
+			device->pnp.bus_id, priv->line);
+		result = -ENODEV;
+		goto fail;
 	}
 
+	acpi_driver_data(device) = priv;
 	return 0;
+
+fail:
+	if (serial_req.iomem_base)
+		iounmap(serial_req.iomem_base);
+	kfree(priv);
+
+	return result;
 }
 
 static int acpi_serial_remove(struct acpi_device *device, int type)
 {
+	struct serial_private *priv;
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
+	priv = acpi_driver_data(device);
+	unregister_serial(priv->line);
+	if (priv->iomem_base)
+		iounmap(priv->iomem_base);
+	kfree(priv);
+
 	return 0;
 }
 
diff -Nru a/drivers/serial/8250_hcdp.c b/drivers/serial/8250_hcdp.c
--- a/drivers/serial/8250_hcdp.c	Fri Jan 16 22:06:23 2004
+++ b/drivers/serial/8250_hcdp.c	Fri Jan 16 22:06:23 2004
@@ -185,7 +185,7 @@
 #else
 		port.irq = gsi;
 #endif
-		port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
+		port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_RESOURCES;
 		if (gsi)
 			port.flags |= ASYNC_AUTO_IRQ;
 
diff -Nru a/drivers/serial/Kconfig b/drivers/serial/Kconfig
--- a/drivers/serial/Kconfig	Fri Jan 16 22:06:23 2004
+++ b/drivers/serial/Kconfig	Fri Jan 16 22:06:23 2004
@@ -62,6 +62,15 @@
 
 	  If unsure, say N.
 
+config SERIAL_8250_HCDP
+	bool "Console device discovery via EFI HCDP table"
+	depends on IA64
+	depends on SERIAL_8250_CONSOLE=y
+	---help---
+	  If you wish to make the serial console port described by the EFI
+	  HCDP table available for use as serial console, say Y here.  See
+	  <http://www.dig64.org/specifications/DIG64_HCDPv10a_01.pdf>.
+
 config SERIAL_8250_CS
 	tristate "8250/16550 PCMCIA device support"
 	depends on PCMCIA && SERIAL_8250
@@ -83,15 +92,6 @@
 	---help---
 	  If you wish to enable serial port discovery via the ACPI
 	  namespace, say Y here.  If unsure, say N.
-
-config SERIAL_8250_HCDP
-	bool "8250/16550 device discovery support via EFI HCDP table"
-	depends on IA64 && SERIAL_8250
-	---help---
-	  If you wish to make the serial console port described by the EFI
-	  HCDP table available for use as serial console or general
-	  purpose port, say Y here. See
-	  <http://www.dig64.org/specifications/DIG64_HCDPv10a_01.pdf>.
 
 config SERIAL_8250_NR_UARTS
 	int "Maximum number of non-legacy 8250/16550 serial ports"
