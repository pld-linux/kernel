diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/Kconfig linux-2.6.6/drivers/usb/media/Kconfig
--- linux-2.6.6.org/drivers/usb/media/Kconfig	2004-05-10 04:31:57.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/Kconfig	2004-05-10 14:18:23.000000000 +0200
@@ -108,7 +108,7 @@
 
 config USB_PWC
 	tristate "USB Philips Cameras"
-	depends on USB && VIDEO_DEV && BROKEN
+	depends on USB && VIDEO_DEV
 	---help---
 	  Say Y or M here if you want to use one of these Philips & OEM
           webcams:
@@ -114,22 +114,22 @@
           webcams:
            * Philips PCA645, PCA646
            * Philips PCVC675, PCVC680, PCVC690
-           * Philips PCVC720/40, PCVC730, PCVC740, PCVC750
+           * Philips PCVC720/40 PCVC730, PCVC740, PCVC750
 	   * Askey VC010
-	   * Logitech QuickCam Pro 3000, 4000, 'Zoom', 'Notebook Pro' 
-             and 'Orbit'/'Sphere'
-           * Samsung MPC-C10, MPC-C30
+	   * Logitech QuickCam Pro 3000, 4000, 'Zoom' and 'Notebook'
+           * Logitech QuickCam Orbit/Sphere
+	   * Samsung MPC-C10, MPC-C30
 	   * Creative Webcam 5, Pro Ex
-	   * SOTEC Afina Eye
+	   * SOTEC Afina Eye / AME Optimedia CU-001
 	   * Visionite VCS-UC300, VCS-UM100
 	   
 	  The PCA635, PCVC665 and PCVC720/20 are not supported by this driver
-	  and never will be, but the 665 and 720/20 are supported by other 
+	  and never will be, but the 665 and 720 are supported by other 
 	  drivers.
 
-	  This driver has an optional plugin (called PWCX), which is 
-	  distributed as a binary module only. It contains code that allow you 
-	  to use higher resolutions and framerates but may not be distributed 
+	  This driver has an optional plugin (called PWCX), which is
+	  distributed with a binary-only part. It contains code that allow you
+	  to use higher resolutions and framerates but may not be distributed
 	  as source. But even without this plugin you can these cams for most
 	  applications.
 
@@ -146,6 +146,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called pwc.
 
+config USB_PWCX
+	tristate "PWCX decompressor module"
+	depends on USB_PWC
+
 config USB_SE401
 	tristate "USB SE401 Camera support"
 	depends on USB && VIDEO_DEV
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/Makefile linux-2.6.6/drivers/usb/media/Makefile
--- linux-2.6.6.org/drivers/usb/media/Makefile	2004-05-10 04:31:55.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/Makefile	2004-05-10 14:18:23.000000000 +0200
@@ -3,6 +3,7 @@
 #
 
 pwc-objs	:= pwc-if.o pwc-misc.o pwc-ctrl.o pwc-uncompress.o
+pwcx-objs	:= pwcx-glue.o libpwcx.a_
 
 obj-$(CONFIG_USB_DABUSB)	+= dabusb.o
 obj-$(CONFIG_USB_DSBR)		+= dsbr100.o
@@ -10,6 +11,7 @@
 obj-$(CONFIG_USB_KONICAWC)	+= konicawc.o usbvideo.o
 obj-$(CONFIG_USB_OV511)		+= ov511.o
 obj-$(CONFIG_USB_PWC)		+= pwc.o
+obj-$(CONFIG_USB_PWCX)		+= pwcx.o
 obj-$(CONFIG_USB_SE401)		+= se401.o
 obj-$(CONFIG_USB_STV680)	+= stv680.o
 obj-$(CONFIG_USB_VICAM)		+= vicam.o usbvideo.o
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-ctrl.c linux-2.6.6/drivers/usb/media/pwc-ctrl.c
--- linux-2.6.6.org/drivers/usb/media/pwc-ctrl.c	2004-05-10 04:33:20.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-ctrl.c	2004-05-07 00:52:23.000000000 +0200
@@ -30,6 +30,7 @@
 #include <asm/uaccess.h> 
 #endif
 #include <asm/errno.h>
+#include <linux/version.h>
  
 #include "pwc.h"
 #include "pwc-ioctl.h"
@@ -127,19 +128,19 @@
 
 /* This tables contains entries for the 675/680/690 (Timon) camera, with
    4 different qualities (no compression, low, medium, high).
-   It lists the bandwidth requirements for said mode by its alternate interface 
+   It lists the bandwidth requirements for said mode by its alternate interface
    number. An alternate of 0 means that the mode is unavailable.
-   
-   There are 6 * 4 * 4 entries: 
+
+   There are 6 * 4 * 4 entries:
      6 different resolutions subqcif, qsif, qcif, sif, cif, vga
      6 framerates: 5, 10, 15, 20, 25, 30
      4 compression modi: none, low, medium, high
-     
-   When an uncompressed mode is not available, the next available compressed mode 
+
+   When an uncompressed mode is not available, the next available compressed mode
    will be chosen (unless the decompressor is absent). Sometimes there are only
    1 or 2 compressed modes available; in that case entries are duplicated.
 */
-struct Timon_table_entry 
+struct Timon_table_entry
 {
 	char alternate;			/* USB alternate interface */
 	unsigned short packetsize;	/* Normal packet size */
@@ -147,7 +148,7 @@
 	unsigned char mode[13];		/* precomputed mode settings for cam */
 };
 
-static struct Timon_table_entry Timon_table[PSZ_MAX][6][4] = 
+static struct Timon_table_entry Timon_table[PSZ_MAX][6][4] =
 {
 #include "pwc_timon.h"
 };
@@ -194,7 +195,7 @@
 	int i;
 	unsigned char *s;
 	char buf[100], *d;
-	
+
 	s = (unsigned char *)p;
 	d = buf;
 	*d = '\0';
@@ -230,7 +231,7 @@
 	unsigned char buf[3];
 	int ret, fps;
 	struct Nala_table_entry *pEntry;
-	int frames2frames[31] = 
+	int frames2frames[31] =
 	{ /* closest match of framerate */
 	   0,  0,  0,  0,  4,  /*  0-4  */
 	   5,  5,  7,  7, 10,  /*  5-9  */
@@ -267,9 +268,12 @@
 		Debug("Failed to send video command... %d\n", ret);
 		return ret;
 	}
-	if (pEntry->compressed && pdev->decompressor != NULL)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-		
+	if (pEntry->compressed && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 3;
+	memcpy(pdev->cmd_buf, buf, 3);
+
 	/* Set various parameters */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -303,13 +307,13 @@
 	if (size == PSZ_VGA && frames > 15)
 		return -EINVAL;
 	fps = (frames / 5) - 1;
-	
+
 	/* Find a supported framerate with progressively higher compression ratios
 	   if the preferred ratio is not available.
 	*/
 	pChoose = NULL;
 	if (pdev->decompressor == NULL) {
-#if PWC_DEBUG	
+#if PWC_DEBUG
 		Debug("Trying to find uncompressed mode.\n");
 #endif
 		pChoose = &Timon_table[size][fps][0];
@@ -319,7 +323,7 @@
 			pChoose = &Timon_table[size][fps][compression];
 			if (pChoose->alternate != 0)
 				break;
-			compression++;	
+			compression++;
 		}
 	}
 	if (pChoose == NULL || pChoose->alternate == 0)
@@ -332,9 +336,12 @@
 	if (ret < 0)
 		return ret;
 
-	if (pChoose->bandlength > 0)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-	
+	if (pChoose->bandlength > 0 && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 13;
+	memcpy(pdev->cmd_buf, buf, 13);
+
 	/* Set various parameters */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -342,7 +349,7 @@
 	pdev->valternate = pChoose->alternate;
 	pdev->image = pwc_image_sizes[size];
 	pdev->vbandlength = pChoose->bandlength;
-	if (pChoose->bandlength > 0) 
+	if (pChoose->bandlength > 0)
 		pdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;
 	else
 		pdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;
@@ -352,33 +359,54 @@
 
 static inline int set_video_mode_Kiara(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)
 {
-	struct Kiara_table_entry *pChoose;
+	struct Kiara_table_entry *pChoose = 0;
 	int fps, ret;
 	unsigned char buf[12];
-	
+	struct Kiara_table_entry RawEntry = {6, 773, 1272, {0xAD, 0xF4, 0x10, 0x27, 0xB6, 0x24, 0x96, 0x02, 0x30, 0x05, 0x03, 0x80}};
+
 	if (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)
 		return -EINVAL;
 	if (size == PSZ_VGA && frames > 15)
 		return -EINVAL;
 	fps = (frames / 5) - 1;
-	
-	/* Find a supported framerate with progressively higher compression ratios
-	   if the preferred ratio is not available.
-	*/
-	pChoose = NULL;
-	if (pdev->decompressor == NULL) {
-#if PWC_DEBUG	
-		Debug("Trying to find uncompressed mode.\n");
-#endif		
-		pChoose = &Kiara_table[size][fps][0];
+
+	/* special case: VGA @ 5 fps and snapshot is raw bayer mode */
+	if (size == PSZ_VGA && frames == 5 && snapshot)
+	{
+		/* Only available in case the raw palette is selected or 
+		   we have the decompressor available. This mode is 
+		   only available in compressed form 
+		*/
+		if (pdev->vpalette == VIDEO_PALETTE_RAW || pdev->decompressor != NULL)
+		{
+	                Info("Choosing VGA/5 BAYER mode (%d).\n", pdev->vpalette);
+			pChoose = &RawEntry;
+		}
+		else
+		{
+			Info("VGA/5 BAYER mode _must_ have a decompressor available, or use RAW palette.\n");
+		}
 	}
-	else {
-		while (compression <= 3) {
-			pChoose = &Kiara_table[size][fps][compression];
-			if (pChoose->alternate != 0)
-				break;
-			compression++;	
+	else
+	{
+        	/* Find a supported framerate with progressively higher compression ratios
+		   if the preferred ratio is not available.
+                   Skip this step when using RAW modes.
+		*/
+		if (pdev->decompressor == NULL && pdev->vpalette != VIDEO_PALETTE_RAW) {
+#if PWC_DEBUG
+			Debug("Trying to find uncompressed mode.\n");
+#endif
+			pChoose = &Kiara_table[size][fps][0];
 		}
+		else {
+			while (compression <= 3) {
+				pChoose = &Kiara_table[size][fps][compression];
+				if (pChoose->alternate != 0)
+					break;
+				compression++;
+			}
+   		}
 	}
 	if (pChoose == NULL || pChoose->alternate == 0)
 		return -ENOENT; /* Not supported. */
@@ -393,9 +421,11 @@
 	if (ret < 0)
 		return ret;
 
-	if (pChoose->bandlength > 0)
-		pdev->decompressor->init(pdev->release, buf, pdev->decompress_data);
-		
+	if (pChoose->bandlength > 0 && pdev->decompressor != 0 && pdev->vpalette != VIDEO_PALETTE_RAW)
+		pdev->decompressor->init(pdev->type, pdev->release, buf, pdev->decompress_data);
+
+	pdev->cmd_len = 12;
+	memcpy(pdev->cmd_buf, buf, 12);
 	/* All set and go */
 	pdev->vframes = frames;
 	pdev->vsize = size;
@@ -403,15 +433,15 @@
 	pdev->valternate = pChoose->alternate;
 	pdev->image = pwc_image_sizes[size];
 	pdev->vbandlength = pChoose->bandlength;
-	if (pChoose->bandlength > 0)
-		pdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;
-	else 
+	if (pdev->vbandlength > 0)
+		pdev->frame_size = (pdev->vbandlength * pdev->image.y) / 4;
+	else
 		pdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;
-	pdev->frame_size += (pdev->frame_header_size + pdev->frame_trailer_size);
 	return 0;
 }
 
 
+
 /**
    @pdev: device structure
    @width: viewport width
@@ -422,14 +452,18 @@
  */
 int pwc_set_video_mode(struct pwc_device *pdev, int width, int height, int frames, int compression, int snapshot)
 {
-	int ret, size;
-	
+
+        int ret, size;
+
+        Trace(TRACE_FLOW, "set_video_mode(%dx%d @ %d, palette %d).\n", width, height, frames, pdev->vpalette);
 	size = pwc_decode_size(pdev, width, height);
 	if (size < 0) {
 		Debug("Could not find suitable size.\n");
 		return -ERANGE;
 	}
-	ret = -EINVAL;	
+	Debug("decode_size = %d.\n", size);
+
+        ret = -EINVAL;
 	switch(pdev->type) {
 	case 645:
 	case 646:
@@ -441,7 +475,7 @@
 	case 690:
 		ret = set_video_mode_Timon(pdev, size, frames, compression, snapshot);
 		break;
-		
+	
 	case 720:
 	case 730:
 	case 740:
@@ -459,6 +493,7 @@
 	}
 	pdev->view.x = width;
 	pdev->view.y = height;
+	pdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;
 	pwc_set_image_buffer_size(pdev);
 	Trace(TRACE_SIZE, "Set viewport to %dx%d, image size is %dx%d.\n", width, height, pwc_image_sizes[size].x, pwc_image_sizes[size].y);
 	return 0;
@@ -467,23 +502,33 @@
 
 void pwc_set_image_buffer_size(struct pwc_device *pdev)
 {
-	int factor, i, filler = 0;
+	int i, factor = 0, filler = 0;
 
-	factor = 6;
-	filler = 128;
+	/* for PALETTE_YUV420P */
+	switch(pdev->vpalette)
+	{
+	case VIDEO_PALETTE_YUV420P:
+		factor = 6;
+		filler = 128;
+		break;
+	case VIDEO_PALETTE_RAW:
+		factor = 6; /* can be uncompressed YUV420P */
+		filler = 0;
+		break;
+	}
 
 	/* Set sizes in bytes */
 	pdev->image.size = pdev->image.x * pdev->image.y * factor / 4;
 	pdev->view.size  = pdev->view.x  * pdev->view.y  * factor / 4;
 
 	/* Align offset, or you'll get some very weird results in
-	   YUV420 mode... x must be multiple of 4 (to get the Y's in 
+	   YUV420 mode... x must be multiple of 4 (to get the Y's in
 	   place), and y even (or you'll mixup U & V). This is less of a
 	   problem for YUV420P.
 	 */
 	pdev->offset.x = ((pdev->view.x - pdev->image.x) / 2) & 0xFFFC;
 	pdev->offset.y = ((pdev->view.y - pdev->image.y) / 2) & 0xFFFE;
-	
+
 	/* Fill buffers with gray or black */
 	for (i = 0; i < MAX_IMAGES; i++) {
 		if (pdev->image_ptr[i] != NULL)
@@ -499,13 +544,8 @@
 {
 	char buf;
 	int ret;
-	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		BRIGHTNESS_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+
+	ret = RecvControlMsg(GET_LUM_CTL, BRIGHTNESS_FORMATTER, 1);	
 	if (ret < 0)
 		return ret;
 	return buf << 9;
@@ -520,12 +560,7 @@
 	if (value > 0xffff)
 		value = 0xffff;
 	buf = (value >> 9) & 0x7f;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		BRIGHTNESS_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_LUM_CTL, BRIGHTNESS_FORMATTER, 1);
 }
 
 /* CONTRAST */
@@ -534,13 +569,8 @@
 {
 	char buf;
 	int ret;
-	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		CONTRAST_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+
+	ret = RecvControlMsg(GET_LUM_CTL, CONTRAST_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
 	return buf << 10;
@@ -555,12 +585,7 @@
 	if (value > 0xffff)
 		value = 0xffff;
 	buf = (value >> 10) & 0x3f;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		CONTRAST_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_LUM_CTL, CONTRAST_FORMATTER, 1);
 }
 
 /* GAMMA */
@@ -570,12 +595,7 @@
 	char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		GAMMA_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_LUM_CTL, GAMMA_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
 	return buf << 11;
@@ -590,12 +610,7 @@
 	if (value > 0xffff)
 		value = 0xffff;
 	buf = (value >> 11) & 0x1f;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		GAMMA_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_LUM_CTL, GAMMA_FORMATTER, 1);
 }
 
 
@@ -608,12 +623,7 @@
 
 	if (pdev->type < 675)
 		return -1;
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_CHROM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_CHROM_CTL, pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1, 1);
 	if (ret < 0)
 		return ret;
 	return 32768 + buf * 327;
@@ -631,12 +641,7 @@
 		value = 0xffff;
 	/* saturation ranges from -100 to +100 */
 	buf = (value - 32768) / 327;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_CHROM_CTL, pdev->type < 730 ? SATURATION_MODE_FORMATTER2 : SATURATION_MODE_FORMATTER1, 1);
 }
 
 /* AGC */
@@ -651,12 +656,7 @@
 	else
 		buf = 0xff; /* fixed */
 
-	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AGC_MODE_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = SendControlMsg(SET_LUM_CTL, AGC_MODE_FORMATTER, 1);
 	
 	if (!mode && ret >= 0) {
 		if (value < 0)
@@ -664,12 +664,7 @@
 		if (value > 0xffff)
 			value = 0xffff;
 		buf = (value >> 10) & 0x3F;
-		ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-			SET_LUM_CTL,
-			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			PRESET_AGC_FORMATTER,
-			pdev->vcinterface,
-			&buf, 1, HZ / 2);
+		ret = SendControlMsg(SET_LUM_CTL, PRESET_AGC_FORMATTER, 1);
 	}
 	if (ret < 0)
 		return ret;
@@ -681,22 +676,12 @@
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AGC_MODE_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_LUM_CTL, AGC_MODE_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
 
 	if (buf != 0) { /* fixed */
-		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-			GET_LUM_CTL,
-			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			PRESET_AGC_FORMATTER,
-			pdev->vcinterface,
-			&buf, 1, HZ / 2);
+		ret = RecvControlMsg(GET_LUM_CTL, PRESET_AGC_FORMATTER, 1);
 		if (ret < 0)
 			return ret;
 		if (buf > 0x3F)
@@ -704,12 +689,7 @@
 		*value = (buf << 10);		
 	}
 	else { /* auto */
-		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-			GET_STATUS_CTL,
-			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			READ_AGC_FORMATTER,
-			pdev->vcinterface,
-			&buf, 1, HZ / 2);
+		ret = RecvControlMsg(GET_STATUS_CTL, READ_AGC_FORMATTER, 1);
 		if (ret < 0)
 			return ret;
 		/* Gah... this value ranges from 0x00 ... 0x9F */
@@ -732,12 +712,7 @@
 	else
 		buf[0] = 0xff; /* fixed */
 	
-	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		SHUTTER_MODE_FORMATTER,
-		pdev->vcinterface,
-		buf, 1, HZ / 2);
+	ret = SendControlMsg(SET_LUM_CTL, SHUTTER_MODE_FORMATTER, 1);
 
 	if (!mode && ret >= 0) {
 		if (value < 0)
@@ -763,12 +738,7 @@
 			break;
 		}
 
-		ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-			SET_LUM_CTL,
-			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			PRESET_SHUTTER_FORMATTER,
-			pdev->vcinterface,
-			&buf, 2, HZ / 2);
+		ret = SendControlMsg(SET_LUM_CTL, PRESET_SHUTTER_FORMATTER, 2);
 	}
 	return ret;
 }	
@@ -787,12 +757,7 @@
 		buf = 0x00; /* active */
 	else
 		buf = 0xFF; /* power save */
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_STATUS_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		SET_POWER_SAVE_MODE_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_STATUS_CTL, SET_POWER_SAVE_MODE_FORMATTER, 1);
 }
 
 
@@ -801,32 +766,20 @@
 
 static inline int pwc_restore_user(struct pwc_device *pdev)
 {
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_STATUS_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		RESTORE_USER_DEFAULTS_FORMATTER,
-		pdev->vcinterface,
-		NULL, 0, HZ / 2);
+	char buf; /* dummy */
+	return SendControlMsg(SET_STATUS_CTL, RESTORE_USER_DEFAULTS_FORMATTER, 0);
 }
 
 static inline int pwc_save_user(struct pwc_device *pdev)
 {
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_STATUS_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		SAVE_USER_DEFAULTS_FORMATTER,
-		pdev->vcinterface,
-		NULL, 0, HZ / 2);
+	char buf; /* dummy */
+	return SendControlMsg(SET_STATUS_CTL, SAVE_USER_DEFAULTS_FORMATTER, 0);
 }
 
 static inline int pwc_restore_factory(struct pwc_device *pdev)
 {
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_STATUS_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		RESTORE_FACTORY_DEFAULTS_FORMATTER,
-		pdev->vcinterface,
-		NULL, 0, HZ / 2);
+	char buf; /* dummy */
+	return SendControlMsg(SET_STATUS_CTL, RESTORE_FACTORY_DEFAULTS_FORMATTER, 0);
 }
 
  /* ************************************************* */
@@ -854,12 +807,7 @@
 	
 	buf = mode & 0x07; /* just the lowest three bits */
 	
-	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		WB_MODE_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = SendControlMsg(SET_CHROM_CTL, WB_MODE_FORMATTER, 1);
 	
 	if (ret < 0)
 		return ret;
@@ -871,12 +819,7 @@
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_CHROM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		WB_MODE_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_CHROM_CTL, WB_MODE_FORMATTER, 1);
 
 	if (ret < 0) 
 		return ret;
@@ -891,34 +834,21 @@
 		value = 0;
 	if (value > 0xffff)
 		value = 0xffff;
-
-	/* only the msb are considered */
+	/* only the msb is considered */
 	buf = value >> 8;
-
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		PRESET_MANUAL_RED_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_CHROM_CTL, PRESET_MANUAL_RED_GAIN_FORMATTER, 1);
 }
 
-static inline int pwc_get_red_gain(struct pwc_device *pdev)
+static inline int pwc_get_red_gain(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
- 	        GET_CHROM_CTL, 
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-	        PRESET_MANUAL_RED_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
-
+	ret = RecvControlMsg(GET_CHROM_CTL, PRESET_MANUAL_RED_GAIN_FORMATTER, 1);
 	if (ret < 0)
 	    return ret;
-	
-	return (buf << 8);
+	*value = buf << 8;
+	return 0;
 }
 
 
@@ -930,34 +860,21 @@
 		value = 0;
 	if (value > 0xffff)
 		value = 0xffff;
-
-	/* linear mapping of 0..0xffff to -0x80..0x7f */
-	buf = (value >> 8);
-
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		PRESET_MANUAL_BLUE_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	/* only the msb is considered */
+	buf = value >> 8;
+	return SendControlMsg(SET_CHROM_CTL, PRESET_MANUAL_BLUE_GAIN_FORMATTER, 1);
 }
 
-static inline int pwc_get_blue_gain(struct pwc_device *pdev)
+static inline int pwc_get_blue_gain(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-   	        GET_CHROM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		PRESET_MANUAL_BLUE_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
-
+	ret = RecvControlMsg(GET_CHROM_CTL, PRESET_MANUAL_BLUE_GAIN_FORMATTER, 1);
 	if (ret < 0)
 	    return ret;
-	
-	return (buf << 8);
+	*value = buf << 8;
+	return 0;
 }
 
 
@@ -965,40 +882,28 @@
    internal red/blue gains, which may be different from the manual 
    gains set or read above.
  */   
-static inline int pwc_read_red_gain(struct pwc_device *pdev)
+static inline int pwc_read_red_gain(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
- 	        GET_STATUS_CTL, 
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-	        READ_RED_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
-
+	ret = RecvControlMsg(GET_STATUS_CTL, READ_RED_GAIN_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	
-	return (buf << 8);
+	*value = buf << 8;
+	return 0;
 }
 
-static inline int pwc_read_blue_gain(struct pwc_device *pdev)
+static inline int pwc_read_blue_gain(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-   	        GET_STATUS_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		READ_BLUE_GAIN_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
-
+	ret = RecvControlMsg(GET_STATUS_CTL, READ_BLUE_GAIN_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	
-	return (buf << 8);
+	*value = buf << 8;
+	return 0;
 }
 
 
@@ -1008,28 +913,19 @@
 	
 	/* useful range is 0x01..0x20 */
 	buf = speed / 0x7f0;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AWB_CONTROL_SPEED_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_CHROM_CTL, AWB_CONTROL_SPEED_FORMATTER, 1);
 }
 
-static inline int pwc_get_wb_speed(struct pwc_device *pdev)
+static inline int pwc_get_wb_speed(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_CHROM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AWB_CONTROL_SPEED_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_CHROM_CTL, AWB_CONTROL_SPEED_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	return (buf * 0x7f0);
+	*value = buf * 0x7f0;
+	return 0;
 }
 
 
@@ -1039,28 +935,19 @@
 	
 	/* useful range is 0x01..0x3F */
 	buf = (delay >> 10);
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_CHROM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AWB_CONTROL_DELAY_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_CHROM_CTL, AWB_CONTROL_DELAY_FORMATTER, 1);
 }
 
-static inline int pwc_get_wb_delay(struct pwc_device *pdev)
+static inline int pwc_get_wb_delay(struct pwc_device *pdev, int *value)
 {
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_CHROM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AWB_CONTROL_DELAY_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_CHROM_CTL, AWB_CONTROL_DELAY_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	return (buf << 10);
+	*value = buf << 10;
+	return 0;
 }
 
 
@@ -1115,12 +1002,7 @@
 		buf = 0xff; /* auto contour on */
 	else
 		buf = 0x0; /* auto contour off */
-	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AUTO_CONTOUR_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = SendControlMsg(SET_LUM_CTL, AUTO_CONTOUR_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
 	
@@ -1130,12 +1012,7 @@
 		contour = 0xffff;
 	
 	buf = (contour >> 10); /* contour preset is [0..3f] */
-	ret = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		PRESET_CONTOUR_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = SendControlMsg(SET_LUM_CTL, PRESET_CONTOUR_FORMATTER, 1);
 	if (ret < 0)	
 		return ret;	
 	return 0;
@@ -1146,26 +1023,16 @@
 	unsigned char buf;
 	int ret;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		AUTO_CONTOUR_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_LUM_CTL, AUTO_CONTOUR_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
 
 	if (buf == 0) {
 		/* auto mode off, query current preset value */
-		ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-			GET_LUM_CTL,
-			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			PRESET_CONTOUR_FORMATTER,
-			pdev->vcinterface,
-			&buf, 1, HZ / 2);
+		ret = RecvControlMsg(GET_LUM_CTL, PRESET_CONTOUR_FORMATTER, 1);
 		if (ret < 0)	
 			return ret;
-		*contour =  (buf << 10);
+		*contour = buf << 10;
 	}
 	else
 		*contour = -1;
@@ -1181,28 +1048,19 @@
 		buf = 0xff;
 	else
 		buf = 0x0;
-	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
-		SET_LUM_CTL,
-		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		BACK_LIGHT_COMPENSATION_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	return SendControlMsg(SET_LUM_CTL, BACK_LIGHT_COMPENSATION_FORMATTER, 1);
 }
 
-static inline int pwc_get_backlight(struct pwc_device *pdev)
+static inline int pwc_get_backlight(struct pwc_device *pdev, int *backlight)
 {
 	int ret;
 	unsigned char buf;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_LUM_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		BACK_LIGHT_COMPENSATION_FORMATTER,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_LUM_CTL, BACK_LIGHT_COMPENSATION_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	return buf;
+	*backlight = buf;
+	return 0;
 }
 
 
@@ -1217,7 +1075,7 @@
 	return SendControlMsg(SET_LUM_CTL, FLICKERLESS_MODE_FORMATTER, 1);
 }
 
-static inline int pwc_get_flicker(struct pwc_device *pdev)
+static inline int pwc_get_flicker(struct pwc_device *pdev, int *flicker)
 {
 	int ret;
 	unsigned char buf;
@@ -1225,7 +1083,8 @@
 	ret = RecvControlMsg(GET_LUM_CTL, FLICKERLESS_MODE_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	return buf;
+	*flicker = buf;
+	return 0;
 }
 
 
@@ -1241,7 +1100,7 @@
 	return SendControlMsg(SET_LUM_CTL, DYNAMIC_NOISE_CONTROL_FORMATTER, 1);
 }
 
-static inline int pwc_get_dynamic_noise(struct pwc_device *pdev)
+static inline int pwc_get_dynamic_noise(struct pwc_device *pdev, int *noise)
 {
 	int ret;
 	unsigned char buf;
@@ -1249,14 +1108,15 @@
 	ret = RecvControlMsg(GET_LUM_CTL, DYNAMIC_NOISE_CONTROL_FORMATTER, 1);
 	if (ret < 0)
 		return ret;
-	return buf;
+	*noise = buf;
+	return 0;
 }
 
 int pwc_mpt_reset(struct pwc_device *pdev, int flags)
 {
 	unsigned char buf;
 	
-	buf = flags & 0x03; // only lower two bits are currently used 
+	buf = flags & 0x03; // only lower two bits are currently used
 	return SendControlMsg(SET_MPT_CTL, PT_RESET_CONTROL_FORMATTER, 1);
 }
 
@@ -1293,7 +1153,7 @@
 }
 
 
-int pwc_get_cmos_sensor(struct pwc_device *pdev)
+int pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor)
 {
 	unsigned char buf;
 	int ret = -1, request;
@@ -1305,24 +1165,60 @@
 	else
 		request = SENSOR_TYPE_FORMATTER2;
 	
-	ret = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
-		GET_STATUS_CTL,
-		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		request,
-		pdev->vcinterface,
-		&buf, 1, HZ / 2);
+	ret = RecvControlMsg(GET_STATUS_CTL, request, 1);
 	if (ret < 0)
 		return ret;
 	if (pdev->type < 675)
-		return buf | 0x100;
+		*sensor = buf | 0x100;
 	else
-		return buf;
+		*sensor = buf;
+	return 0;
 }
 
 
  /* End of Add-Ons                                    */
  /* ************************************************* */
 
+/* Linux 2.5.something and 2.6 pass direct pointers to arguments of
+   ioctl() calls. With 2.4, you have to do tedious copy_from_user()
+   and copy_to_user() calls. With these macros we circumvent this,
+   and let me maintain only one source file. The functionality is
+   exactly the same otherwise.
+ */   
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+
+/* define local variable for arg */
+#define ARG_DEF(ARG_type, ARG_name)\
+	ARG_type *ARG_name = arg;
+/* copy arg to local variable */	
+#define ARG_IN(ARG_name) /* nothing */
+/* argument itself (referenced) */
+#define ARGR(ARG_name) (*ARG_name)
+/* argument address */
+#define ARGA(ARG_name) ARG_name
+/* copy local variable to arg */
+#define ARG_OUT(ARG_name) /* nothing */
+
+#else
+
+#define ARG_DEF(ARG_type, ARG_name)\
+	ARG_type ARG_name;
+#define ARG_IN(ARG_name)\
+	if (copy_from_user(&ARG_name, arg, sizeof(ARG_name))) {\
+		ret = -EFAULT;\
+		break;\
+	}
+#define ARGR(ARG_name) ARG_name
+#define ARGA(ARG_name) &ARG_name
+#define ARG_OUT(ARG_name)\
+	if (copy_to_user(arg, &ARG_name, sizeof(ARG_name))) {\
+		ret = -EFAULT;\
+		break;\
+	}
+
+#endif
+
 int pwc_ioctl(struct pwc_device *pdev, unsigned int cmd, void *arg)
 {
 	int ret = 0;
@@ -1351,225 +1247,245 @@
 	
 	case VIDIOCPWCSCQUAL:
 	{	
-		int *qual = arg;
+		ARG_DEF(int, qual)
 
-		if (*qual < 0 || *qual > 3)
+		ARG_IN(qual)
+		if (ARGR(qual) < 0 || ARGR(qual) > 3)
 			ret = -EINVAL;
 		else
-			ret = pwc_try_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, *qual, pdev->vsnapshot);
+			ret = pwc_try_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, ARGR(qual), pdev->vsnapshot);
 		if (ret >= 0)
-			pdev->vcompression = *qual;
+			pdev->vcompression = ARGR(qual);
 		break;
 	}
 	
 	case VIDIOCPWCGCQUAL:
 	{
-		int *qual = arg;
+		ARG_DEF(int, qual)
 		
-		*qual = pdev->vcompression;
+		ARGR(qual) = pdev->vcompression;
+		ARG_OUT(qual)
 		break;
 	}
 
 	case VIDIOCPWCPROBE:
 	{
-		struct pwc_probe *probe = arg;
+		ARG_DEF(struct pwc_probe, probe)
 		
-		strcpy(probe->name, pdev->vdev.name);
-		probe->type = pdev->type;
+		strcpy(ARGR(probe).name, pdev->vdev.name);
+		ARGR(probe).type = pdev->type;
+		ARG_OUT(probe)
 		break;
 	}
 
 	case VIDIOCPWCSAGC:
 	{
-		int *agc = arg;
+		ARG_DEF(int, agc)
 
-		if (pwc_set_agc(pdev, *agc < 0 ? 1 : 0, *agc))
+		ARG_IN(agc)
+		if (pwc_set_agc(pdev, ARGR(agc) < 0 ? 1 : 0, ARGR(agc)))
 			ret = -EINVAL;
 		break;
 	}
 	
 	case VIDIOCPWCGAGC:
 	{
-		int *agc = arg;
+		ARG_DEF(int, agc)
 		
-		if (pwc_get_agc(pdev, agc))
+		if (pwc_get_agc(pdev, ARGA(agc)))
 			ret = -EINVAL;
+		ARG_OUT(agc)
 		break;
 	}
 	
 	case VIDIOCPWCSSHUTTER:
 	{
-		int *shutter_speed = arg;
+		ARG_DEF(int, shutter_speed)
 
-		ret = pwc_set_shutter_speed(pdev, *shutter_speed < 0 ? 1 : 0, *shutter_speed);
+		ARG_IN(shutter_speed)
+		ret = pwc_set_shutter_speed(pdev, ARGR(shutter_speed) < 0 ? 1 : 0, ARGR(shutter_speed));
 		break;
 	}
 	
         case VIDIOCPWCSAWB:
 	{
-		struct pwc_whitebalance *wb = arg;
+		ARG_DEF(struct pwc_whitebalance, wb)
 		
-		ret = pwc_set_awb(pdev, wb->mode);
-		if (ret >= 0 && wb->mode == PWC_WB_MANUAL) {
-			pwc_set_red_gain(pdev, wb->manual_red);
-			pwc_set_blue_gain(pdev, wb->manual_blue);
+		ARG_IN(wb)
+		ret = pwc_set_awb(pdev, ARGR(wb).mode);
+		if (ret >= 0 && ARGR(wb).mode == PWC_WB_MANUAL) {
+			pwc_set_red_gain(pdev, ARGR(wb).manual_red);
+			pwc_set_blue_gain(pdev, ARGR(wb).manual_blue);
 		}
 		break;
 	}
 
 	case VIDIOCPWCGAWB:
 	{
-		struct pwc_whitebalance *wb = arg;
+		ARG_DEF(struct pwc_whitebalance, wb)
 
-		memset(wb, 0, sizeof(*wb));
-		wb->mode = pwc_get_awb(pdev);
-		if (wb->mode < 0)
+		memset(ARGA(wb), 0, sizeof(struct pwc_whitebalance));
+		ARGR(wb).mode = pwc_get_awb(pdev);
+		if (ARGR(wb).mode < 0)
 			ret = -EINVAL;
 		else {
-			if (wb->mode == PWC_WB_MANUAL) {
-				wb->manual_red = pwc_get_red_gain(pdev);
-				wb->manual_blue = pwc_get_blue_gain(pdev);
+			if (ARGR(wb).mode == PWC_WB_MANUAL) {
+				ret = pwc_get_red_gain(pdev, &ARGR(wb).manual_red);
+				if (ret < 0)
+					break;
+				ret = pwc_get_blue_gain(pdev, &ARGR(wb).manual_blue);
+				if (ret < 0)
+					break;
 			}
-			if (wb->mode == PWC_WB_AUTO) {
-				wb->read_red = pwc_read_red_gain(pdev);
-				wb->read_blue = pwc_read_blue_gain(pdev);
+			if (ARGR(wb).mode == PWC_WB_AUTO) {
+				ret = pwc_read_red_gain(pdev, &ARGR(wb).read_red);
+				if (ret < 0)
+					break;
+ 				ret =pwc_read_blue_gain(pdev, &ARGR(wb).read_blue);
+ 				if (ret < 0)
+ 					break;
 			}
 		}
+		ARG_OUT(wb)
 		break;
 	}
 	
 	case VIDIOCPWCSAWBSPEED:
 	{
-		struct pwc_wb_speed *wbs = arg;
+		ARG_DEF(struct pwc_wb_speed, wbs)
 		
-		if (wbs->control_speed > 0) {
-			ret = pwc_set_wb_speed(pdev, wbs->control_speed);
+		if (ARGR(wbs).control_speed > 0) {
+			ret = pwc_set_wb_speed(pdev, ARGR(wbs).control_speed);
 		}
-		if (wbs->control_delay > 0) {
-			ret = pwc_set_wb_delay(pdev, wbs->control_delay);
+		if (ARGR(wbs).control_delay > 0) {
+			ret = pwc_set_wb_delay(pdev, ARGR(wbs).control_delay);
 		}
 		break;
 	}
 	
 	case VIDIOCPWCGAWBSPEED:
 	{
-		struct pwc_wb_speed *wbs = arg;
+		ARG_DEF(struct pwc_wb_speed, wbs)
 		
-		ret = pwc_get_wb_speed(pdev);
+		ret = pwc_get_wb_speed(pdev, &ARGR(wbs).control_speed);
 		if (ret < 0)
 			break;
-		wbs->control_speed = ret;
-		ret = pwc_get_wb_delay(pdev);
+		ret = pwc_get_wb_delay(pdev, &ARGR(wbs).control_delay);
 		if (ret < 0)
 			break;
-		wbs->control_delay = ret;
+		ARG_OUT(wbs)
 		break;
 	}
 
         case VIDIOCPWCSLED:
 	{
-		struct pwc_leds *leds = arg;
+		ARG_DEF(struct pwc_leds, leds)
 
-		ret = pwc_set_leds(pdev, leds->led_on, leds->led_off);
+		ARG_IN(leds)
+		ret = pwc_set_leds(pdev, ARGR(leds).led_on, ARGR(leds).led_off);
 	    	break;
 	}
 
 
 	case VIDIOCPWCGLED:
 	{
-		struct pwc_leds *leds = arg;
+		ARG_DEF(struct pwc_leds, leds)
 		
-		ret = pwc_get_leds(pdev, &leds->led_on, &leds->led_off); 
+		ret = pwc_get_leds(pdev, &ARGR(leds).led_on, &ARGR(leds).led_off);
+		ARG_OUT(leds)
 		break;
 	}
 
 	case VIDIOCPWCSCONTOUR:
 	{
-		int *contour = arg;
+		ARG_DEF(int, contour)
 
-		ret = pwc_set_contour(pdev, *contour);
+		ARG_IN(contour)
+		ret = pwc_set_contour(pdev, ARGR(contour));
 		break;
 	}
 			
 	case VIDIOCPWCGCONTOUR:
 	{
-		int *contour = arg;
+		ARG_DEF(int, contour)
 		
-		ret = pwc_get_contour(pdev, contour);
+		ret = pwc_get_contour(pdev, ARGA(contour));
+		ARG_OUT(contour)
 		break;
 	}
 	
 	case VIDIOCPWCSBACKLIGHT:
 	{
-		int *backlight = arg;
+		ARG_DEF(int, backlight)
 		
-		ret = pwc_set_backlight(pdev, *backlight);
+		ARG_IN(backlight)
+		ret = pwc_set_backlight(pdev, ARGR(backlight));
 		break;
 	}
 
 	case VIDIOCPWCGBACKLIGHT:
 	{
-		int *backlight = arg;
+		ARG_DEF(int, backlight)
 		
-		ret = pwc_get_backlight(pdev);
-		if (ret >= 0)
-			*backlight = ret;
+		ret = pwc_get_backlight(pdev, ARGA(backlight));
+		ARG_OUT(backlight)
 		break;
 	}
 	
 	case VIDIOCPWCSFLICKER:
 	{
-		int *flicker = arg;
+		ARG_DEF(int, flicker)
 		
-		ret = pwc_set_flicker(pdev, *flicker);
+		ARG_IN(flicker)
+		ret = pwc_set_flicker(pdev, ARGR(flicker));
 		break;
 	}
 
 	case VIDIOCPWCGFLICKER:
 	{
-		int *flicker = arg;
+		ARG_DEF(int, flicker)
 		
-		ret = pwc_get_flicker(pdev);
-		if (ret >= 0)
-			*flicker = ret;
+		ret = pwc_get_flicker(pdev, ARGA(flicker));
+		ARG_OUT(flicker)
 		break;
 	}
 	
 	case VIDIOCPWCSDYNNOISE:
 	{
-		int *dynnoise = arg;
+		ARG_DEF(int, dynnoise)
 		
-		ret = pwc_set_dynamic_noise(pdev, *dynnoise);
+		ARG_IN(dynnoise)
+		ret = pwc_set_dynamic_noise(pdev, ARGR(dynnoise));
 		break;
 	}
 	
 	case VIDIOCPWCGDYNNOISE:
 	{
-		int *dynnoise = arg;
+		ARG_DEF(int, dynnoise)
 
-		ret = pwc_get_dynamic_noise(pdev);
-		if (ret < 0)
-			break;
-		*dynnoise = ret;
+		ret = pwc_get_dynamic_noise(pdev, ARGA(dynnoise));
+		ARG_OUT(dynnoise);
 		break;
 	}
 
 	case VIDIOCPWCGREALSIZE:
 	{
-		struct pwc_imagesize *size = arg;
+		ARG_DEF(struct pwc_imagesize, size)
 		
-		size->width = pdev->image.x;
-		size->height = pdev->image.y;
+		ARGR(size).width = pdev->image.x;
+		ARGR(size).height = pdev->image.y;
+		ARG_OUT(size)
 		break;
  	}
  	
  	case VIDIOCPWCMPTRESET:
  	{
- 		int *flags = arg;
- 		
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
-			ret = pwc_mpt_reset(pdev, *flags);
+	 		ARG_DEF(int, flags)
+
+ 			ARG_IN(flags)
+			ret = pwc_mpt_reset(pdev, ARGR(flags));
  			if (ret >= 0)
  			{
  				pdev->pan_angle = 0;
@@ -1582,11 +1498,15 @@
  		}
  		break;		
  	}
+ 	
  	case VIDIOCPWCMPTGRANGE:
  	{
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
- 			memcpy(arg, &pdev->angle_range, sizeof(struct pwc_mpt_range));
+ 			ARG_DEF(struct pwc_mpt_range, range)
+ 			
+ 			ARGR(range) = pdev->angle_range;
+ 			ARG_OUT(range)
  		}
  		else
  		{	
@@ -1597,23 +1517,25 @@
  	
  	case VIDIOCPWCMPTSANGLE:
  	{
- 		struct pwc_mpt_angles *angles = arg;
  		int new_pan, new_tilt;
  		
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
+	 		ARG_DEF(struct pwc_mpt_angles, angles)
+
+	 		ARG_IN(angles)
 			/* The camera can only set relative angles, so
 			   do some calculations when getting an absolute angle .
 			 */
-			if (angles->absolute)
+			if (ARGR(angles).absolute)
 			{
- 				new_pan  = angles->pan; 
- 				new_tilt = angles->tilt;
+ 				new_pan  = ARGR(angles).pan; 
+ 				new_tilt = ARGR(angles).tilt;
  			}
  			else
  			{
- 				new_pan  = pdev->pan_angle  + angles->pan;
- 				new_tilt = pdev->tilt_angle + angles->tilt;
+ 				new_pan  = pdev->pan_angle  + ARGR(angles).pan;
+ 				new_tilt = pdev->tilt_angle + ARGR(angles).tilt;
 			}
 			/* check absolute ranges */
 			if (new_pan  < pdev->angle_range.pan_min  ||
@@ -1649,17 +1571,19 @@
  			ret = -ENXIO;
  		}
  		break;
- 	} 
- 	
+ 	}
+
  	case VIDIOCPWCMPTGANGLE:
  	{
- 		struct pwc_mpt_angles *angles = arg;
  		
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
- 			angles->absolute = 1;
- 			angles->pan  = pdev->pan_angle;
- 			angles->tilt = pdev->tilt_angle;
+	 		ARG_DEF(struct pwc_mpt_angles, angles)
+
+ 			ARGR(angles).absolute = 1;
+ 			ARGR(angles).pan  = pdev->pan_angle;
+ 			ARGR(angles).tilt = pdev->tilt_angle;
+ 			ARG_OUT(angles)
  		}
  		else
  		{
@@ -1670,19 +1594,34 @@
  
  	case VIDIOCPWCMPTSTATUS:
  	{
- 		struct pwc_mpt_status *status = arg;
- 	
  		if (pdev->features & FEATURE_MOTOR_PANTILT)
  		{
- 			ret = pwc_mpt_get_status(pdev, status);
+ 			ARG_DEF(struct pwc_mpt_status, status)
+ 			
+ 			ret = pwc_mpt_get_status(pdev, ARGA(status));
+ 			ARG_OUT(status)
  		}
  		else
  		{
  			ret = -ENXIO;
  		}
-  		break;
-  	}
-  	
+ 		break;
+	}
+
+	case VIDIOCPWCGVIDCMD:
+	{
+		ARG_DEF(struct pwc_video_command, cmd);
+		
+                ARGR(cmd).type = pdev->type;
+		ARGR(cmd).release = pdev->release;
+		ARGR(cmd).command_len = pdev->cmd_len;
+		memcpy(&ARGR(cmd).command_buf, pdev->cmd_buf, pdev->cmd_len);
+		ARGR(cmd).bandlength = pdev->vbandlength;
+		ARGR(cmd).frame_size = pdev->frame_size;
+		ARG_OUT(cmd)
+		break;
+	}
+
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-if.c linux-2.6.6/drivers/usb/media/pwc-if.c
--- linux-2.6.6.org/drivers/usb/media/pwc-if.c	2004-05-10 04:33:10.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-if.c	2004-05-07 00:52:23.000000000 +0200
@@ -1,4 +1,4 @@
-/* Linux driver for Philips webcam 
+/* Linux driver for Philips webcam
    USB and Video4Linux interface part.
    (C) 1999-2003 Nemosoft Unv.
 
@@ -42,7 +42,7 @@
    - Alistar Moire: QuickCam 3000 Pro device/product ID
    - Tony Hoyle: Creative Labs Webcam 5 device/product ID
    - Mark Burazin: solving hang in VIDIOCSYNC when camera gets unplugged
-   - Jk Fang: SOTEC Afina Eye ID
+   - Jk Fang: Sotec Afina Eye ID
    - Xavier Roche: QuickCam Pro 4000 ID
    - Jens Knudsen: QuickCam Zoom ID
    - J. Debert: QuickCam for Notebooks ID
@@ -90,6 +90,7 @@
 	{ USB_DEVICE(0x041E, 0x400C) }, /* Creative Webcam 5 */
 	{ USB_DEVICE(0x041E, 0x4011) }, /* Creative Webcam Pro Ex */
 	{ USB_DEVICE(0x04CC, 0x8116) }, /* Afina Eye */
+	{ USB_DEVICE(0x06BE, 0x8116) }, /* new Afina Eye */
 	{ USB_DEVICE(0x0d81, 0x1910) }, /* Visionite */
 	{ USB_DEVICE(0x0d81, 0x1900) },
 	{ }
@@ -129,7 +130,7 @@
 
 static int pwc_video_open(struct inode *inode, struct file *file);
 static int pwc_video_close(struct inode *inode, struct file *file);
-static int pwc_video_release(struct video_device *);			  
+static void pwc_video_release(struct video_device *);			  
 static ssize_t pwc_video_read(struct file *file, char *buf,
 			  size_t count, loff_t *ppos);
 static unsigned int pwc_video_poll(struct file *file, poll_table *wait);
@@ -259,7 +260,7 @@
 		return -ENXIO;
 	}
 #endif	
-	/* Allocate Isochronous pipe buffers */
+	/* Allocate Isochronuous pipe buffers */
 	for (i = 0; i < MAX_ISO_BUFS; i++) {
 		if (pdev->sbuf[i].data == NULL) {
 			kbuf = kmalloc(ISO_BUFFER_SIZE, GFP_KERNEL);
@@ -444,7 +445,7 @@
 {
 	int ret;
 	unsigned long flags;
-	
+
 	ret = 0;
 	spin_lock_irqsave(&pdev->ptrlock, flags);
 	if (pdev->fill_frame != NULL) {
@@ -489,7 +490,7 @@
 
 /**
   \brief Reset all buffers, pointers and lists, except for the image_used[] buffer.
-  
+
   If the image_used[] buffer is cleared too, mmap()/VIDIOCSYNC will run into trouble.
  */
 static void pwc_reset_buffers(struct pwc_device *pdev)
@@ -526,7 +527,7 @@
 {
 	int ret = 0;
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&pdev->ptrlock, flags);
 	/* First grab our read_frame; this is removed from all lists, so
 	   we can release the lock after this without problems */
@@ -549,7 +550,7 @@
 			Trace(TRACE_SEQUENCE, "Decompressing frame %d\n", pdev->read_frame->sequence);
 #endif
 			/* Decompression is a lenghty process, so it's outside of the lock.
-			   This gives the isoc_handler the opportunity to fill more frames 
+			   This gives the isoc_handler the opportunity to fill more frames
 			   in the mean time.
 			*/
 			spin_unlock_irqrestore(&pdev->ptrlock, flags);
@@ -644,7 +645,7 @@
 	else {
 		fillptr = fbuf->data + fbuf->filled;
 	}
-	
+
 	/* Reset ISOC error counter. We did get here, after all. */
 	pdev->visoc_errors = 0;
 
@@ -663,8 +664,8 @@
 					pdev->vsync = 2;
 
 					/* ...copy data to frame buffer, if possible */
-					if (flen + fbuf->filled > pdev->frame_size) {
-						Trace(TRACE_FLOW, "Frame buffer overflow (flen = %d, frame_size = %d).\n", flen, pdev->frame_size);
+					if (flen + fbuf->filled > pdev->frame_total_size) {
+						Trace(TRACE_FLOW, "Frame buffer overflow (flen = %d, frame_total_size = %d).\n", flen, pdev->frame_total_size);
 						pdev->vsync = 0; /* Hmm, let's wait for an EOF (end-of-frame) */
 						pdev->vframes_error++;
 					}
@@ -729,7 +730,7 @@
 						pdev->drop_frames--;
 					else {
 						/* Check for underflow first */
-						if (fbuf->filled < pdev->frame_size) {
+						if (fbuf->filled < pdev->frame_total_size) {
 							Trace(TRACE_FLOW, "Frame buffer underflow (%d bytes); discarded.\n", fbuf->filled);
 							pdev->vframes_error++;
 						}
@@ -815,7 +816,7 @@
 	
 	if (pdev->vmax_packet_size < 0 || pdev->vmax_packet_size > ISO_MAX_FRAME_SIZE) {
 		Err("Failed to find packet size for video endpoint in current alternate setting.\n");
-		return -ENFILE; /* Odd error, that should be noticeable */
+		return -ENFILE; /* Odd error, that should be noticable */
 	}
 
 	/* Set alternate interface */
@@ -872,7 +873,7 @@
 		if (ret)
 			Err("isoc_init() submit_urb %d failed with error %d\n", i, ret);
 		else
-			Trace(TRACE_OPEN, "URB 0x%p submitted.\n", pdev->sbuf[i].urb);
+			Trace(TRACE_MEMORY, "URB 0x%p submitted.\n", pdev->sbuf[i].urb);
 	}
 
 	/* All is done... */
@@ -884,7 +885,7 @@
 static void pwc_isoc_cleanup(struct pwc_device *pdev)
 {
 	int i;
-	
+
 	Trace(TRACE_OPEN, ">> pwc_isoc_cleanup()\n");
 	if (pdev == NULL)
 		return;
@@ -935,9 +936,9 @@
 		        Trace(TRACE_FLOW, "pwc_set_video_mode attempt 2 failed.\n");
 		}
 	}
-	if (start == 0) 
+	if (start == 0)
 	{
-		if (pwc_isoc_init(pdev) < 0) 
+		if (pwc_isoc_init(pdev) < 0)
 		{
 			Info("Failed to restart ISOC transfers in pwc_try_video_mode.\n");
 			ret = -EAGAIN; /* let's try again, who knows if it works a second time */
@@ -970,24 +971,28 @@
 		Trace(TRACE_OPEN, "Doing first time initialization.\n");
 		pdev->usb_init = 1;
 		
-		if (pwc_trace & TRACE_OPEN) {
+		if (pwc_trace & TRACE_OPEN)
+		{
 			/* Query sensor type */
 			const char *sensor_type = NULL;
+			int ret;
 
-			i = pwc_get_cmos_sensor(pdev);
-			switch(i) {
-			case -1: /* Unknown, show nothing */; break;
-			case 0x00:  sensor_type = "Hyundai CMOS sensor"; break;
-			case 0x20:  sensor_type = "Sony CCD sensor + TDA8787"; break;
-			case 0x2E:  sensor_type = "Sony CCD sensor + Exas 98L59"; break;
-			case 0x2F:  sensor_type = "Sony CCD sensor + ADI 9804"; break;
-			case 0x30:  sensor_type = "Sharp CCD sensor + TDA8787"; break;
-			case 0x3E:  sensor_type = "Sharp CCD sensor + Exas 98L59"; break;
-			case 0x3F:  sensor_type = "Sharp CCD sensor + ADI 9804"; break;
-			case 0x40:  sensor_type = "UPA 1021 sensor"; break;
-			case 0x100: sensor_type = "VGA sensor"; break;
-			case 0x101: sensor_type = "PAL MR sensor"; break;
-			default:    sensor_type = "unknown type of sensor"; break;
+			ret = pwc_get_cmos_sensor(pdev, &i);
+			if (ret >= 0)
+			{
+				switch(i) {
+				case 0x00:  sensor_type = "Hyundai CMOS sensor"; break;
+				case 0x20:  sensor_type = "Sony CCD sensor + TDA8787"; break;
+				case 0x2E:  sensor_type = "Sony CCD sensor + Exas 98L59"; break;
+				case 0x2F:  sensor_type = "Sony CCD sensor + ADI 9804"; break;
+				case 0x30:  sensor_type = "Sharp CCD sensor + TDA8787"; break;
+				case 0x3E:  sensor_type = "Sharp CCD sensor + Exas 98L59"; break;
+				case 0x3F:  sensor_type = "Sharp CCD sensor + ADI 9804"; break;
+				case 0x40:  sensor_type = "UPA 1021 sensor"; break;
+				case 0x100: sensor_type = "VGA sensor"; break;
+				case 0x101: sensor_type = "PAL MR sensor"; break;
+				default:    sensor_type = "unknown type of sensor"; break;
+				}
 			}
 			if (sensor_type != NULL)
 				Info("This %s camera is equipped with a %s (%d).\n", pdev->vdev.name, sensor_type, i);
@@ -1035,6 +1040,7 @@
 
 	/* Set some defaults */
 	pdev->vsnapshot = 0;
+
 	/* Start iso pipe for video; first try the last used video size
 	   (or the default one); if that fails try QCIF/10 or QSIF/10;
 	   it that fails too, give up.
@@ -1088,7 +1094,7 @@
 
 	/* Dump statistics, but only if a reasonable amount of frames were
 	   processed (to prevent endless log-entries in case of snap-shot
-	   programs) 
+	   programs)
 	 */
 	if (pdev->vframe_count > 20)
 		Info("Closing video device: %d frames received, dumped %d frames, %d frames with errors.\n", pdev->vframe_count, pdev->vframes_dumped, pdev->vframes_error);
@@ -1109,7 +1115,7 @@
 			Info("Failed to set LED on/off time.\n");
 		if (power_save) {
 			i = pwc_camera_power(pdev, 0);
-			if (i < 0) 
+			if (i < 0)
 				Err("Failed to power down camera (%d)\n", i);
 		}
 	}
@@ -1118,9 +1124,9 @@
 	return 0;
 }
 
-static int pwc_video_release(struct video_device *vfd)
+static void pwc_video_release(struct video_device *vfd)
 {
-	Trace(TRACE_OPEN, "pwc_video_release() called. Now what?\n");
+	Trace(TRACE_OPEN, "pwc_video_release() called. Nothing to do here. Honestly.\n");
 }
 		
 
@@ -1143,6 +1149,7 @@
 	struct pwc_device *pdev;
 	int noblock = file->f_flags & O_NONBLOCK;
 	DECLARE_WAITQUEUE(wait, current);
+        int bytes_to_read;
 
 	Trace(TRACE_READ, "video_read(0x%p, %p, %d) called.\n", vdev, buf, count);
 	if (vdev == NULL)
@@ -1179,20 +1186,25 @@
 		}
 		remove_wait_queue(&pdev->frameq, &wait);
 		set_current_state(TASK_RUNNING);
-	                                                                                                                                                                                
+                                                                                                                                                                                
 		/* Decompress and release frame */
 		if (pwc_handle_frame(pdev))
 			return -EFAULT;
 	}
 
 	Trace(TRACE_READ, "Copying data to user space.\n");
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+		bytes_to_read = pdev->frame_size;
+	else
+ 		bytes_to_read = pdev->view.size;
+
 	/* copy bytes to user space; we allow for partial reads */
-	if (count + pdev->image_read_pos > pdev->view.size)
-		count = pdev->view.size - pdev->image_read_pos;
+	if (count + pdev->image_read_pos > bytes_to_read)
+		count = bytes_to_read - pdev->image_read_pos;
 	if (copy_to_user(buf, pdev->image_ptr[pdev->fill_image] + pdev->image_read_pos, count))
 		return -EFAULT;
 	pdev->image_read_pos += count;
-	if (pdev->image_read_pos >= pdev->view.size) { /* All data has been read */
+	if (pdev->image_read_pos >= bytes_to_read) { /* All data has been read */
 		pdev->image_read_pos = 0;
 		pwc_next_image(pdev);
 	}
@@ -1264,7 +1276,7 @@
 		}
 
 		case VIDIOCSCHAN:
-		{	
+		{
 			/* The spec says the argument is an integer, but
 			   the bttv driver uses a video_channel arg, which
 			   makes sense becasue it also has the norm flag.
@@ -1282,8 +1294,6 @@
 			struct video_picture *p = arg;
 			int val;
 
-			p->colour = 0x8000;
-			p->hue = 0x8000;
 			val = pwc_get_brightness(pdev);
 			if (val >= 0)
 				p->brightness = val;
@@ -1306,11 +1316,11 @@
 			else
 				p->colour = 0xffff;
 			p->depth = 24;
-			p->palette = VIDEO_PALETTE_YUV420P;
+			p->palette = pdev->vpalette;
 			p->hue = 0xFFFF; /* N/A */
 			break;
 		}
-		
+
 		case VIDIOCSPICT:
 		{
 			struct video_picture *p = arg;
@@ -1322,13 +1332,22 @@
 			                is used exactly once in the uncompress
 			                routine.
 			 */
-			if (p->palette && p->palette != VIDEO_PALETTE_YUV420P) {
-				return -EINVAL;
-			}
 			pwc_set_brightness(pdev, p->brightness);
 			pwc_set_contrast(pdev, p->contrast);
 			pwc_set_gamma(pdev, p->whiteness);
 			pwc_set_saturation(pdev, p->colour);
+			if (p->palette && p->palette != pdev->vpalette) {
+				switch (p->palette) {
+					case VIDEO_PALETTE_YUV420P:
+					case VIDEO_PALETTE_RAW:
+						pdev->vpalette = p->palette;
+						return pwc_try_video_mode(pdev, pdev->image.x, pdev->image.y, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
+						break;
+					default:
+						return -EINVAL;
+						break;
+				}
+			}
 			break;
 		}
 
@@ -1402,13 +1421,23 @@
 			   various palettes... The driver doesn't support
 			   such small images, so I'm working around it.
 			 */
-			if (vm->format && vm->format != VIDEO_PALETTE_YUV420P)
-				return -EINVAL;
-			 
+			if (vm->format)
+			{
+				switch (vm->format)
+				{
+					case VIDEO_PALETTE_YUV420P:
+					case VIDEO_PALETTE_RAW:
+						break;
+					default:
+						return -EINVAL;
+						break;
+				}
+			}
+
 			if ((vm->width != pdev->view.x || vm->height != pdev->view.y) &&
 			    (vm->width >= pdev->view_min.x && vm->height >= pdev->view_min.y)) {
 				int ret;
-				
+
 				Trace(TRACE_OPEN, "VIDIOCMCAPTURE: changing size to please xawtv :-(.\n");
 				ret = pwc_try_video_mode(pdev, vm->width, vm->height, pdev->vframes, pdev->vcompression, pdev->vsnapshot);
 				if (ret)
@@ -1640,12 +1669,12 @@
 			type_id = 690;
 			break;
 		case 0x0310:
-			Info("Philips PCVC730K (ToUCam Fun) USB webcam detected.\n");
+			Info("Philips PCVC730K (ToUCam Fun)/PCVC830 (ToUCam II) USB webcam detected.\n");
 			name = "Philips 730 webcam";
 			type_id = 730;
 			break;
 		case 0x0311:
-			Info("Philips PCVC740K (ToUCam Pro) USB webcam detected.\n");
+			Info("Philips PCVC740K (ToUCam Pro)/PCVC840 (ToUCam II) USB webcam detected.\n");
 			name = "Philips 740 webcam";
 			type_id = 740;
 			break;
@@ -1759,18 +1788,45 @@
 			break;
 		}
 	}
-	else if (vendor_id == 0x04cc) { 
+	else if (vendor_id == 0x04cc) {
 		switch(product_id) {
 		case 0x8116:
 			Info("Sotec Afina Eye USB webcam detected.\n");
 			name = "Sotec Afina Eye";
 			type_id = 730;
-			break;  
+			break;
 		default:
 			return -ENODEV;
 			break;
 		}
 	}
+	else if (vendor_id == 0x06be) {
+		switch(product_id) {
+		case 0x8116:
+			/* Basicly the same as the Sotec Afina Eye */                
+			Info("AME CU-001 USB webcam detected.\n");
+			name = "AME CU-001";
+			type_id = 730;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	}
+	else if (vendor_id == 0x06be) {
+		switch(product_id) {
+		case 0x8116:
+			/* This is essentially the same cam as the Sotec Afina Eye */
+			Info("AME Co. Afina Eye USB webcam detected.\n");
+			name = "AME Co. Afina Eye";
+			type_id = 750;
+			break;
+		default:
+			return -ENODEV;
+			break;
+		}
+	
+	}
 	else if (vendor_id == 0x0d81) {
 		switch(product_id) {
 		case 0x1900:
@@ -1819,8 +1875,6 @@
 		pdev->angle_range.pan_max  =  7000;
 		pdev->angle_range.tilt_min = -3000;
 		pdev->angle_range.tilt_max =  2500;
-		pdev->angle_range.zoom_min = -1;
-		pdev->angle_range.zoom_max = -1;
 	}
 
 	init_MUTEX(&pdev->modlock);
@@ -1834,7 +1888,7 @@
 	strcpy(pdev->vdev.name, name);
 	pdev->vdev.owner = THIS_MODULE;
 	pdev->vdev.priv = pdev;
-	
+
 	pdev->release = udev->descriptor.bcdDevice;
 	Trace(TRACE_PROBE, "Release: %04x\n", pdev->release);
 
@@ -1898,14 +1952,14 @@
 		Err("pwc_disconnect() Magic number failed. Consult your scrolls and try again.\n");
 		goto disconnect_out;
 	}
-#endif	
+#endif
 	
 	/* We got unplugged; this is signalled by an EPIPE error code */
 	if (pdev->vopen) {
 		Info("Disconnected while webcam is in use!\n");
 		pdev->error_status = EPIPE;
 	}
-	
+
 	/* Alert waiting processes */
 	wake_up_interruptible(&pdev->frameq);
 	/* Wait until device is closed */
@@ -1913,7 +1967,7 @@
 		schedule();
 	/* Device is now closed, so we can safely unregister it */
 	Trace(TRACE_PROBE, "Unregistering video device in disconnect().\n");
-	video_unregister_device(&pdev->vdev); 
+	video_unregister_device(&pdev->vdev);
 
 	/* Free memory (don't set pdev to 0 just yet) */
 	kfree(pdev);
@@ -1932,7 +1986,7 @@
 static int pwc_atoi(const char *s)
 {
 	int k = 0;
-	
+
 	k = 0;
 	while (*s != '\0' && *s >= '0' && *s <= '9') {
 		k = 10 * k + (*s - '0');
@@ -1975,7 +2029,7 @@
 MODULE_PARM_DESC(dev_hint, "Device node hints");
 
 MODULE_DESCRIPTION("Philips & OEM USB webcam driver");
-MODULE_AUTHOR("Nemosoft Unv. <nemosoft@smcc.demon.nl>");
+MODULE_AUTHOR("Nemosoft Unv. <webcam@smcc.demon.nl>");
 MODULE_LICENSE("GPL");
 
 static int __init usb_pwc_init(void)
@@ -1983,9 +2037,10 @@
 	int i, sz;
 	char *sizenames[PSZ_MAX] = { "sqcif", "qsif", "qcif", "sif", "cif", "vga" };
 
-	Info("Philips PCA645/646 + PCVC675/680/690 + PCVC730/740/750 webcam module version " PWC_VERSION " loaded.\n");
-	Info("Also supports the Askey VC010, various Logitech QuickCams, Samsung MPC-C10 and MPC-C30,\n");
-	Info("the Creative WebCam 5, SOTEC Afina Eye and Visionite VCS-UC300 and VCS-UM100.\n");
+	Info("Philips webcam module version " PWC_VERSION " loaded.\n");
+	Info("Supports Philips PCA645/646, PCVC675/680/690, PCVC720[40]/730/740/750 & PCVC830/840.\n");
+	Info("Also supports the Askey VC010, various Logitech Quickcams, Samsung MPC-C10 and MPC-C30,\n");
+	Info("the Creative WebCam 5 & Pro Ex, SOTEC Afina Eye and Visionite VCS-UC300 and VCS-UM100.\n");
 
 	if (fps) {
 		if (fps < 4 || fps > 30) {
@@ -1995,7 +2050,7 @@
 		default_fps = fps;
 		Info("Default framerate set to %d.\n", default_fps);
 	}
-	
+
 	if (size) {
 		/* string; try matching with array */
 		for (sz = 0; sz < PSZ_MAX; sz++) {
@@ -2045,12 +2100,12 @@
 	if (leds[1] >= 0)
 		led_off = leds[1];
 
-	/* Big device node whoopla. Basically, it allows you to assign a 
-	   device node (/dev/videoX) to a camera, based on its type 
+	/* Big device node whoopla. Basicly, it allows you to assign a
+	   device node (/dev/videoX) to a camera, based on its type
 	   & serial number. The format is [type[.serialnumber]:]node.
 
-           Any camera that isn't matched by these rules gets the next 
-           available free device node.
+	   Any camera that isn't matched by these rules gets the next
+	   available free device node.
 	 */
 	for (i = 0; i < MAX_DEV_HINTS; i++) {
 		char *s, *colon, *dot;
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-ioctl.h linux-2.6.6/drivers/usb/media/pwc-ioctl.h
--- linux-2.6.6.org/drivers/usb/media/pwc-ioctl.h	2004-05-10 04:32:29.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-ioctl.h	2004-05-07 00:52:23.000000000 +0200
@@ -1,8 +1,8 @@
 #ifndef PWC_IOCTL_H
 #define PWC_IOCTL_H
 
-/* (C) 2001-2003 Nemosoft Unv.    webcam@smcc.demon.nl
-   
+/* (C) 2001-2004 Nemosoft Unv.    webcam@smcc.demon.nl
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
@@ -18,19 +18,24 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-/*         This is pwc-ioctl.h belonging to PWC 8.10                        */
+/* This is pwc-ioctl.h belonging to PWC 8.12.1
+   It contains structures and defines to communicate from user space
+   directly to the driver.
+ */
 
-/* 
+/*
    Changes
-   2001/08/03  Alvarado   Added ioctl constants to access methods for 
+   2001/08/03  Alvarado   Added ioctl constants to access methods for
                           changing white balance and red/blue gains
    2002/12/15  G. H. Fernandez-Toribio   VIDIOCGREALSIZE
+   2003/12/13  Nemosft Unv. Some modifications to make interfacing to
+               PWCX easier
  */
 
 /* These are private ioctl() commands, specific for the Philips webcams.
    They contain functions not found in other webcams, and settings not
-   specified in the Video4Linux API. 
-   
+   specified in the Video4Linux API.
+
    The #define names are built up like follows:
    VIDIOC		VIDeo IOCtl prefix
          PWC		Philps WebCam
@@ -40,13 +45,21 @@
  */
 
 
+ /* Enumeration of image sizes */
+#define PSZ_SQCIF	0x00
+#define PSZ_QSIF	0x01
+#define PSZ_QCIF	0x02
+#define PSZ_SIF		0x03
+#define PSZ_CIF		0x04
+#define PSZ_VGA		0x05
+#define PSZ_MAX		6
 
 
 /* The frame rate is encoded in the video_window.flags parameter using
    the upper 16 bits, since some flags are defined nowadays. The following
    defines provide a mask and shift to filter out this value.
-   
-   In 'Snapshot' mode the camera freezes its automatic exposure and colour 
+
+   In 'Snapshot' mode the camera freezes its automatic exposure and colour
    balance controls.
  */
 #define PWC_FPS_SHIFT		16
@@ -55,7 +68,15 @@
 #define PWC_FPS_SNAPSHOT	0x00400000
 
 
+/* structure for transfering x & y coordinates */
+struct pwc_coord
+{
+	int x, y;		/* guess what */
+	int size;		/* size, or offset */
+};
+
 
+/* Used with VIDIOCPWCPROBE */
 struct pwc_probe
 {
 	char name[32];
@@ -78,7 +99,6 @@
    otherwise undefined.
    'read_red' and 'read_blue' are read-only.
 */   
-   
 struct pwc_whitebalance
 {
 	int mode;
@@ -117,7 +137,7 @@
 #define PWC_MPT_TILT		0x02
 #define PWC_MPT_TIMEOUT		0x04 /* for status */
 
-/* Set angles; when absolute = 1, the angle is absolute and the 
+/* Set angles; when absolute != 0, the angle is absolute and the 
    driver calculates the relative offset for you. This can only
    be used with VIDIOCPWCSANGLE; VIDIOCPWCGANGLE always returns
    absolute angles.
@@ -127,18 +147,14 @@
 	int absolute;		/* write-only */
 	int pan;		/* degrees * 100 */
 	int tilt;		/* degress * 100 */
-	int zoom;		/* N/A, set to -1 */
 };
 
 /* Range of angles of the camera, both horizontally and vertically.
-   The zoom is not used, maybe in the future...
-
  */
 struct pwc_mpt_range
 {
 	int pan_min, pan_max;		/* degrees * 100 */
 	int tilt_min, tilt_max;
-	int zoom_min, zoom_max;		/* -1, -1 */
 };
 
 struct pwc_mpt_status
@@ -149,6 +165,30 @@
 };
 
 
+/* This is used for out-of-kernel decompression. With it, you can get
+   all the necessary information to initialize and use the decompressor
+   routines in standalone applications.
+ */   
+struct pwc_video_command
+{
+	int type;		/* camera type (645, 675, 730, etc.) */
+	int release;		/* release number */
+
+        int size;		/* one of PSZ_* */
+        int alternate;
+	int command_len;	/* length of USB video command */
+	unsigned char command_buf[13];	/* Actual USB video command */
+	int bandlength;		/* >0 = compressed */
+	int frame_size;		/* Size of one (un)compressed frame */
+};
+
+/* Flags for PWCX subroutines. Not all modules honour all flags. */
+#define PWCX_FLAG_PLANAR	0x0001
+#define PWCX_FLAG_BAYER		0x0008
+
+
+/* IOCTL definitions */
+
  /* Restore user settings */
 #define VIDIOCPWCRUSER		_IO('v', 192)
  /* Save user settings */
@@ -172,13 +212,13 @@
  /* This is a probe function; since so many devices are supported, it
     becomes difficult to include all the names in programs that want to
     check for the enhanced Philips stuff. So in stead, try this PROBE;
-    it returns a structure with the original name, and the corresponding 
+    it returns a structure with the original name, and the corresponding
     Philips type.
     To use, fill the structure with zeroes, call PROBE and if that succeeds,
     compare the name with that returned from VIDIOCGCAP; they should be the
     same. If so, you can be assured it is a Philips (OEM) cam and the type
     is valid.
- */    
+ */
 #define VIDIOCPWCPROBE		_IOR('v', 199, struct pwc_probe)
 
  /* Set AGC (Automatic Gain Control); int < 0 = auto, 0..65535 = fixed */
@@ -225,5 +265,8 @@
 #define VIDIOCPWCMPTSANGLE	_IOW('v', 212, struct pwc_mpt_angles)
 #define VIDIOCPWCMPTGANGLE	_IOR('v', 212, struct pwc_mpt_angles)
 #define VIDIOCPWCMPTSTATUS	_IOR('v', 213, struct pwc_mpt_status)
- 
+
+ /* Get the USB set-video command; needed for initializing libpwcx */
+#define VIDIOCPWCGVIDCMD	_IOR('v', 215, struct pwc_video_command)
+
 #endif
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-misc.c linux-2.6.6/drivers/usb/media/pwc-misc.c
--- linux-2.6.6.org/drivers/usb/media/pwc-misc.c	2004-05-10 04:32:28.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-misc.c	2004-05-07 00:52:23.000000000 +0200
@@ -15,13 +15,13 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/  
+*/
 
 #include <linux/slab.h>
 
 #include "pwc.h"
 
-struct pwc_coord pwc_image_sizes[PSZ_MAX] = 
+struct pwc_coord pwc_image_sizes[PSZ_MAX] =
 {
 	{ 128,  96, 0 },
 	{ 160, 120, 0 },
@@ -36,11 +36,30 @@
 {
 	int i, find;
 
-	/* Make sure we don't go beyond our max size */
-	if (width > pdev->view_max.x || height > pdev->view_max.y)
-		return -1;
+	/* Make sure we don't go beyond our max size.
+           NB: we have different limits for RAW and normal modes. In case
+           you don't have the decompressor loaded or use RAW mode, 
+           the maximum viewable size is smaller.
+        */
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+	{
+		if (width > pdev->abs_max.x || height > pdev->abs_max.y)
+		{
+			Debug("VIDEO_PALETTE_RAW: going beyond abs_max.\n");
+                	return -1;
+                }
+	}
+	else
+	{
+		if (width > pdev->view_max.x || height > pdev->view_max.y)
+		{
+			Debug("VIDEO_PALETTE_ not RAW: going beyond view_max.\n");
+			return -1;
+		}
+	}
+
 	/* Find the largest size supported by the camera that fits into the
-	   requested size. 
+	   requested size.
 	 */
 	find = -1;
 	for (i = 0; i < PSZ_MAX; i++) {
@@ -62,6 +81,8 @@
 		pdev->view_min.y =  96;
 		pdev->view_max.x = 352;
 		pdev->view_max.y = 288;
+                pdev->abs_max.x  = 352;
+                pdev->abs_max.y  = 288;
 		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QCIF | 1 << PSZ_CIF;
 		pdev->vcinterface = 2;
 		pdev->vendpoint = 4;
@@ -77,13 +98,14 @@
 		if (pdev->decompressor != NULL) {
 			pdev->view_max.x = 640;
 			pdev->view_max.y = 480;
-			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
 		}
 		else {
 			pdev->view_max.x = 352;
 			pdev->view_max.y = 288;
-			pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF;
 		}
+		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
+                pdev->abs_max.x = 640;
+                pdev->abs_max.y = 480;
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 4;
 		pdev->frame_header_size = 0;
@@ -99,24 +121,26 @@
 		if (pdev->decompressor != NULL) {
 			pdev->view_max.x = 640;
 			pdev->view_max.y = 480;
-			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
 		}
 		else {
-			/* Tell CIF, even though SIF really is the maximum, but some tools really need CIF */
+			/* We use CIF, not SIF since some tools really need CIF. So we cheat a bit. */
 			pdev->view_max.x = 352;
 			pdev->view_max.y = 288;
-			pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF;
 		}
+		pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
+                pdev->abs_max.x = 640;
+                pdev->abs_max.y = 480;
 		pdev->vcinterface = 3;
 		pdev->vendpoint = 5;
 		pdev->frame_header_size = TOUCAM_HEADER_SIZE;
 		pdev->frame_trailer_size = TOUCAM_TRAILER_SIZE;
 		break;
 	}
+	pdev->vpalette = VIDEO_PALETTE_YUV420P; /* default */
 	pdev->view_min.size = pdev->view_min.x * pdev->view_min.y;
 	pdev->view_max.size = pdev->view_max.x * pdev->view_max.y;
-	/* length of image, in YUV format */
-	pdev->len_per_image = (pdev->view_max.size * 3) / 2;
+	/* length of image, in YUV format; always allocate enough memory. */
+	pdev->len_per_image = (pdev->abs_max.x * pdev->abs_max.y * 3) / 2;
 }
 
 
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-uncompress.c linux-2.6.6/drivers/usb/media/pwc-uncompress.c
--- linux-2.6.6.org/drivers/usb/media/pwc-uncompress.c	2004-05-10 04:32:37.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-uncompress.c	2004-05-07 00:52:23.000000000 +0200
@@ -1,4 +1,4 @@
-/* Linux driver for Philips webcam 
+/* Linux driver for Philips webcam
    Decompression frontend.
    (C) 1999-2003 Nemosoft Unv. (webcam@smcc.demon.nl)
 
@@ -21,7 +21,9 @@
    themselves. It also has a decompressor wrapper function.
 */
 
+#include <asm/current.h>
 #include <asm/types.h>
+// #include <linux/sched.h>
 
 #include "pwc.h"
 #include "pwc-uncompress.h"
@@ -81,7 +83,6 @@
 	u16 *src;
 	u16 *dsty, *dstu, *dstv;
 
-	
 	if (pdev == NULL)
 		return -EFAULT;
 #if defined(__KERNEL__) && defined(PWC_MAGIC)
@@ -97,16 +98,24 @@
 	image = pdev->image_ptr[pdev->fill_image];
 	if (!image)
 		return -EFAULT;
-	
+
 	yuv = fbuf->data + pdev->frame_header_size;  /* Skip header */
-	if (pdev->vbandlength == 0) { 
+
+	/* Raw format; that's easy... */
+	if (pdev->vpalette == VIDEO_PALETTE_RAW)
+	{
+		memcpy(image, yuv, pdev->frame_size);
+		return 0;
+	}
+
+	if (pdev->vbandlength == 0) {
 		/* Uncompressed mode. We copy the data into the output buffer,
 		   using the viewport size (which may be larger than the image
 		   size). Unfortunately we have to do a bit of byte stuffing
 		   to get the desired output format/size.
 		 */
-			/* 
-			 * We do some byte shuffling here to go from the 
+			/*
+			 * We do some byte shuffling here to go from the
 			 * native format to YUV420P.
 			 */
 			src = (u16 *)yuv;
@@ -140,15 +149,21 @@
 					dstu += (stride >> 1);
 			}
 	}
-	else { 
-		/* Compressed; the decompressor routines will write the data 
+	else {
+		/* Compressed; the decompressor routines will write the data
 		   in planar format immediately.
 		 */
+		int flags;
+                
+                flags = PWCX_FLAG_PLANAR;
+                if (pdev->vsize == PSZ_VGA && pdev->vframes == 5 && pdev->vsnapshot)
+                	flags |= PWCX_FLAG_BAYER;
+
 		if (pdev->decompressor)
 			pdev->decompressor->decompress(
 				&pdev->image, &pdev->view, &pdev->offset,
 				yuv, image,
-				1,
+				flags,
 				pdev->decompress_data, pdev->vbandlength);
 		else
 			return -ENXIO; /* No such device or address: missing decompressor */
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc-uncompress.h linux-2.6.6/drivers/usb/media/pwc-uncompress.h
--- linux-2.6.6.org/drivers/usb/media/pwc-uncompress.h	2004-05-10 04:32:27.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc-uncompress.h	2004-05-07 00:52:23.000000000 +0200
@@ -24,10 +24,16 @@
 #define PWC_UNCOMPRESS_H
 
 #include <linux/config.h>
+#include <linux/linkage.h>
 #include <linux/list.h>
 
 #include "pwc.h"
 
+/* from pwc-dec.h */
+#define PWCX_FLAG_PLANAR        0x0001
+/* */
+
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -42,10 +48,10 @@
 	int  type;		/* type of camera (645, 680, etc) */
 	int  table_size;	/* memory needed */
 
-	void (* init)(int release, void *buffer, void *table);	/* Initialization routine; should be called after each set_video_mode */
-	void (* exit)(void);	/* Cleanup routine */
-	void (* decompress)(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset,
-                            void *src, void *dst, int planar,
+	asmlinkage void (* init)(int type, int release, void *buffer, void *table);	/* Initialization routine; should be called after each set_video_mode */
+	asmlinkage void (* exit)(void);	/* Cleanup routine */
+	asmlinkage void (* decompress)(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset,
+                            void *src, void *dst, int flags,
 	                    void *table, int bandlength);
 	void (* lock)(void);	/* make sure module cannot be unloaded */
 	void (* unlock)(void);	/* release lock on module */
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwc.h linux-2.6.6/drivers/usb/media/pwc.h
--- linux-2.6.6.org/drivers/usb/media/pwc.h	2004-05-10 04:32:51.000000000 +0200
+++ linux-2.6.6/drivers/usb/media/pwc.h	2004-05-07 00:52:23.000000000 +0200
@@ -22,12 +22,11 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/smp_lock.h>
-#include <linux/spinlock.h>
 #include <linux/usb.h>
+#include <linux/spinlock.h>
 #include <linux/videodev.h>
 #include <linux/wait.h>
-
+#include <linux/smp_lock.h>
 #include <asm/semaphore.h>
 #include <asm/errno.h>
 
@@ -65,9 +64,9 @@
 #define FEATURE_MOTOR_PANTILT		0x0001
 
 /* Version block */
-#define PWC_MAJOR	8
-#define PWC_MINOR	12
-#define PWC_VERSION 	"8.12"
+#define PWC_MAJOR	9
+#define PWC_MINOR	0
+#define PWC_VERSION 	"9.0-BETA-2"
 #define PWC_NAME 	"pwc"
 
 /* Turn certain features on/off */
@@ -90,12 +89,6 @@
 /* Absolute maximum number of buffers available for mmap() */
 #define MAX_IMAGES 		10
 
-struct pwc_coord
-{
-	int x, y;		/* guess what */
-	int size;		/* size, or offset */
-};
-
 /* The following structures were based on cpia.h. Why reinvent the wheel? :-) */
 struct pwc_iso_buf
 {
@@ -137,6 +130,7 @@
    int vcinterface;		/* video control interface */
    int valternate;		/* alternate interface needed */
    int vframes, vsize;		/* frames-per-second & size (see PSZ_*) */
+   int vpalette;		/* palette: 420P, RAW or RGBBAYER */
    int vframe_count;		/* received frames */
    int vframes_dumped; 		/* counter for dumped frames */
    int vframes_error;		/* frames received in error */
@@ -148,6 +142,9 @@
    char vsnapshot;		/* snapshot mode */
    char vsync;			/* used by isoc handler */
    char vmirror;		/* for ToUCaM series */
+   
+   int cmd_len;
+   unsigned char cmd_buf[13];
 
    /* The image acquisition requires 3 to 4 steps:
       1. data is gathered in short packets from the USB controller
@@ -169,8 +166,9 @@
    struct pwc_frame_buf *full_frames, *full_frames_tail;	/* all filled frames */
    struct pwc_frame_buf *fill_frame;	/* frame currently being filled */
    struct pwc_frame_buf *read_frame;	/* frame currently read by user process */
-   int frame_size;
    int frame_header_size, frame_trailer_size;
+   int frame_size;
+   int frame_total_size; /* including header & trailer */
    int drop_frames;
 #if PWC_DEBUG
    int sequence;			/* Debugging aid */
@@ -187,7 +185,8 @@
       a gray or black border. view_min <= image <= view <= view_max;
     */
    int image_mask;			/* bitmask of supported sizes */
-   struct pwc_coord view_min, view_max;	/* minimum and maximum sizes */
+   struct pwc_coord view_min, view_max;	/* minimum and maximum viewable sizes */
+   struct pwc_coord abs_max;            /* maximum supported size with compression */
    struct pwc_coord image, view;	/* image and viewport size */
    struct pwc_coord offset;		/* offset within the viewport */
 
@@ -213,16 +212,6 @@
 #endif
 };
 
-/* Enumeration of image sizes */
-#define PSZ_SQCIF	0x00
-#define PSZ_QSIF	0x01
-#define PSZ_QCIF	0x02
-#define PSZ_SIF		0x03
-#define PSZ_CIF		0x04
-#define PSZ_VGA		0x05
-#define PSZ_MAX		6
-
-
 
 #ifdef __cplusplus
 extern "C" {
@@ -259,7 +248,7 @@
 extern int pwc_set_saturation(struct pwc_device *pdev, int value);
 extern int pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value);
 extern int pwc_get_leds(struct pwc_device *pdev, int *on_value, int *off_value);
-extern int pwc_get_cmos_sensor(struct pwc_device *pdev);
+extern int pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor);
 
 /* Power down or up the camera; not supported by all models */
 extern int pwc_camera_power(struct pwc_device *pdev, int power);
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwcx-glue.c linux-2.6.6/drivers/usb/media/pwcx-glue.c
--- linux-2.6.6.org/drivers/usb/media/pwcx-glue.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.6/drivers/usb/media/pwcx-glue.c	2004-05-07 01:10:43.000000000 +0200
@@ -0,0 +1,193 @@
+/* PWCX module glue code. */
+
+#include <linux/config.h>
+
+#include "pwc.h"
+#include "pwcx.h"
+#include "pwc-uncompress.h"
+
+#define PWCX_MAJOR	9
+#define PWCX_MINOR	0
+
+#ifdef CONFIG_USB_PWCX_MODULE
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+MODULE_DESCRIPTION("Philips webcam decompressor routines");
+MODULE_AUTHOR("Nemosoft Unv. <webcam@smcc.demon.nl>");
+MODULE_LICENSE("Proprietary. See http://www.smcc.demon.nl/webcam/tainting.html");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+EXPORT_NO_SYMBOLS;
+#endif
+
+static void lock_pwcx(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	MOD_INC_USE_COUNT;
+#endif	
+}
+
+static void unlock_pwcx(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	MOD_DEC_USE_COUNT;
+#endif	
+}
+
+#else
+
+static void lock_pwcx(void)
+{
+}
+
+static void unlock_pwcx(void)
+{
+}
+
+#endif
+
+static struct pwc_decompressor Nala[2] = 
+{
+   {
+      645,
+      5000,
+      pwcx_init_decompress_Nala,
+      pwcx_exit_decompress_Nala,
+      pwcx_decompress_Nala,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      646,
+      5000,
+      pwcx_init_decompress_Nala,
+      pwcx_exit_decompress_Nala,
+      pwcx_decompress_Nala,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+};
+
+static struct pwc_decompressor Timon[3] =
+{
+   {
+      675,
+      60000,
+      pwcx_init_decompress_Timon,
+      pwcx_exit_decompress_Timon,
+      pwcx_decompress_Timon,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      680,
+      60000,
+      pwcx_init_decompress_Timon,
+      pwcx_exit_decompress_Timon,
+      pwcx_decompress_Timon,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      690,
+      60000,
+      pwcx_init_decompress_Timon,
+      pwcx_exit_decompress_Timon,
+      pwcx_decompress_Timon,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+};
+
+static struct pwc_decompressor Kiara[4] =
+{
+   {
+      720,
+      60000,
+      pwcx_init_decompress_Kiara,
+      pwcx_exit_decompress_Kiara,
+      pwcx_decompress_Kiara,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      730,
+      60000,
+      pwcx_init_decompress_Kiara,
+      pwcx_exit_decompress_Kiara,
+      pwcx_decompress_Kiara,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      740,
+      60000,
+      pwcx_init_decompress_Kiara,
+      pwcx_exit_decompress_Kiara,
+      pwcx_decompress_Kiara,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+   {
+      750,
+      60000,
+      pwcx_init_decompress_Kiara,
+      pwcx_exit_decompress_Kiara,
+      pwcx_decompress_Kiara,
+      lock_pwcx,
+      unlock_pwcx,
+   },
+};
+
+#ifdef CONFIG_USB_PWCX_MODULE
+static int __init usb_pwcx_init(void)
+#else
+int usb_pwcx_init(void)
+#endif
+{
+	Info("Philips webcam decompressor routines version %d.%d-BETA-2\n", PWCX_MAJOR, PWCX_MINOR);
+	Info("Supports all cameras supported by the main module (pwc).\n");
+
+	/* register decompression modules */
+	if (pwc_decompressor_version != PWCX_MAJOR) {
+		Err("Version mismatch! These decompression routines are version %d.*, while the\n"
+		    "main module expects version %d.*. Please consult the Philips webcam Linux\n"
+                    "driver page for the correct version and downloads.\n", PWCX_MAJOR, pwc_decompressor_version);
+		    return -EINVAL;
+	}
+	pwc_register_decompressor(&Nala[0]);
+	pwc_register_decompressor(&Nala[1]);
+	pwc_register_decompressor(&Timon[0]);
+	pwc_register_decompressor(&Timon[1]);
+	pwc_register_decompressor(&Timon[2]);
+	pwc_register_decompressor(&Kiara[0]);
+	pwc_register_decompressor(&Kiara[1]);
+	pwc_register_decompressor(&Kiara[2]);
+	pwc_register_decompressor(&Kiara[3]);
+	return 0;
+}
+
+#ifdef CONFIG_USB_PWCX_MODULE
+static void __exit usb_pwcx_exit(void)
+#else
+void usb_pwcx_exit(void)
+#endif
+{
+	pwc_unregister_decompressor(Nala[0].type);
+	pwc_unregister_decompressor(Nala[1].type);
+	pwc_unregister_decompressor(Timon[0].type);
+	pwc_unregister_decompressor(Timon[1].type);
+	pwc_unregister_decompressor(Timon[2].type);
+	pwc_unregister_decompressor(Kiara[0].type);
+	pwc_unregister_decompressor(Kiara[1].type);
+	pwc_unregister_decompressor(Kiara[2].type);
+	pwc_unregister_decompressor(Kiara[3].type);
+	Info("Philips webcam decompressor routines removed.\n");
+}
+
+#ifdef CONFIG_USB_PWCX_MODULE
+module_init(usb_pwcx_init);
+module_exit(usb_pwcx_exit);
+#endif
diff -Nur --exclude '*.orig' linux-2.6.6.org/drivers/usb/media/pwcx.h linux-2.6.6/drivers/usb/media/pwcx.h
--- linux-2.6.6.org/drivers/usb/media/pwcx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.6/drivers/usb/media/pwcx.h	2004-05-07 01:10:43.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef PWCX_H
+#define PWCX_H
+
+#include <linux/linkage.h>
+#include "pwc-ioctl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+/** functions **/
+extern asmlinkage void pwcx_init_decompress_Nala(int type, int release, void *mode, void *table);
+extern asmlinkage void pwcx_exit_decompress_Nala(void);
+extern asmlinkage void pwcx_decompress_Nala(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset, void *src, void *dst, int flags, void *table, int bandlength);
+
+extern asmlinkage void pwcx_init_decompress_Timon(int type, int release, void *mode, void *table);
+extern asmlinkage void pwcx_exit_decompress_Timon(void);
+extern asmlinkage void pwcx_decompress_Timon(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset, void *src, void *dst, int flags, void *table, int bandlength);
+
+extern asmlinkage void pwcx_init_decompress_Kiara(int type, int release, void *mode, void *table);
+extern asmlinkage void pwcx_exit_decompress_Kiara(void);
+extern asmlinkage void pwcx_decompress_Kiara(struct pwc_coord *image, struct pwc_coord *view, struct pwc_coord *offset, void *src, void *dst, int flags, void *table, int bandlength);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
