 Documentation/acpi-hotkey.txt                     |   38 
 arch/frv/mb93090-mb00/pci-irq.c                   |    2 
 arch/i386/kernel/acpi/Makefile                    |    4 
 arch/i386/kernel/acpi/cstate.c                    |  103 +
 arch/i386/kernel/acpi/wakeup.S                    |    5 
 arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c       |    7 
 arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c |    2 
 arch/i386/pci/acpi.c                              |    1 
 arch/i386/pci/common.c                            |    6 
 arch/i386/pci/irq.c                               |   17 
 arch/i386/pci/pci.h                               |    1 
 arch/i386/pci/visws.c                             |    2 
 arch/ia64/kernel/acpi.c                           |   54 +
 arch/ia64/kernel/mca.c                            |    2 
 arch/ia64/kernel/process.c                        |    1 
 arch/ia64/kernel/setup.c                          |    3 
 arch/ia64/kernel/topology.c                       |    7 
 drivers/acpi/Kconfig                              |   40 
 drivers/acpi/Makefile                             |    5 
 drivers/acpi/asus_acpi.c                          |    4 
 drivers/acpi/bus.c                                |    8 
 drivers/acpi/button.c                             |  245 ----
 drivers/acpi/dispatcher/dsfield.c                 |   58 -
 drivers/acpi/dispatcher/dsinit.c                  |   48 
 drivers/acpi/dispatcher/dsmethod.c                |   78 -
 drivers/acpi/dispatcher/dsmthdat.c                |  198 ++-
 drivers/acpi/dispatcher/dsobject.c                |   82 +
 drivers/acpi/dispatcher/dsopcode.c                |  120 +-
 drivers/acpi/dispatcher/dsutils.c                 |   41 
 drivers/acpi/dispatcher/dswexec.c                 |   57 -
 drivers/acpi/dispatcher/dswload.c                 |  168 ++-
 drivers/acpi/dispatcher/dswscope.c                |   31 
 drivers/acpi/dispatcher/dswstate.c                |  464 ++++----
 drivers/acpi/ec.c                                 |  990 ++++++++++++++++---
 drivers/acpi/events/evevent.c                     |   33 
 drivers/acpi/events/evgpe.c                       |   44 
 drivers/acpi/events/evgpeblk.c                    |  122 +-
 drivers/acpi/events/evmisc.c                      |  104 +
 drivers/acpi/events/evregion.c                    |   35 
 drivers/acpi/events/evrgnini.c                    |   24 
 drivers/acpi/events/evsci.c                       |   12 
 drivers/acpi/events/evxface.c                     |   29 
 drivers/acpi/events/evxfevnt.c                    |   31 
 drivers/acpi/executer/exconfig.c                  |   79 -
 drivers/acpi/executer/exconvrt.c                  |   44 
 drivers/acpi/executer/excreate.c                  |   50 
 drivers/acpi/executer/exdump.c                    |  278 ++++-
 drivers/acpi/executer/exfield.c                   |   30 
 drivers/acpi/executer/exfldio.c                   |  133 +-
 drivers/acpi/executer/exmisc.c                    |    9 
 drivers/acpi/executer/exmutex.c                   |   45 
 drivers/acpi/executer/exnames.c                   |   77 -
 drivers/acpi/executer/exoparg1.c                  |  123 +-
 drivers/acpi/executer/exoparg2.c                  |   69 -
 drivers/acpi/executer/exoparg3.c                  |   84 +
 drivers/acpi/executer/exoparg6.c                  |   26 
 drivers/acpi/executer/exprep.c                    |  104 +
 drivers/acpi/executer/exregion.c                  |   34 
 drivers/acpi/executer/exresnte.c                  |   24 
 drivers/acpi/executer/exresolv.c                  |   63 -
 drivers/acpi/executer/exresop.c                   |   96 +
 drivers/acpi/executer/exstore.c                   |  264 +++--
 drivers/acpi/executer/exstoren.c                  |   24 
 drivers/acpi/executer/exstorob.c                  |    9 
 drivers/acpi/executer/exsystem.c                  |   48 
 drivers/acpi/executer/exutils.c                   |   37 
 drivers/acpi/glue.c                               |  360 ++++++
 drivers/acpi/hardware/hwacpi.c                    |   19 
 drivers/acpi/hardware/hwgpe.c                     |   51 
 drivers/acpi/hardware/hwregs.c                    |  116 +-
 drivers/acpi/hardware/hwsleep.c                   |  113 +-
 drivers/acpi/hardware/hwtimer.c                   |    4 
 drivers/acpi/hotkey.c                             | 1019 +++++++++++++++++++
 drivers/acpi/ibm_acpi.c                           |    8 
 drivers/acpi/namespace/nsaccess.c                 |   18 
 drivers/acpi/namespace/nsalloc.c                  |  145 --
 drivers/acpi/namespace/nsdump.c                   |  185 ++-
 drivers/acpi/namespace/nsdumpdv.c                 |   18 
 drivers/acpi/namespace/nseval.c                   |   80 +
 drivers/acpi/namespace/nsinit.c                   |   28 
 drivers/acpi/namespace/nsload.c                   |   70 -
 drivers/acpi/namespace/nsnames.c                  |   12 
 drivers/acpi/namespace/nsobject.c                 |   14 
 drivers/acpi/namespace/nsparse.c                  |    6 
 drivers/acpi/namespace/nssearch.c                 |   29 
 drivers/acpi/namespace/nsutils.c                  |  167 +--
 drivers/acpi/namespace/nswalk.c                   |    2 
 drivers/acpi/namespace/nsxfeval.c                 |   16 
 drivers/acpi/namespace/nsxfname.c                 |    8 
 drivers/acpi/namespace/nsxfobj.c                  |    4 
 drivers/acpi/osl.c                                |  208 +++
 drivers/acpi/parser/Makefile                      |    2 
 drivers/acpi/parser/psargs.c                      |   55 -
 drivers/acpi/parser/psloop.c                      |  781 ++++++++++++++
 drivers/acpi/parser/psopcode.c                    |  324 ------
 drivers/acpi/parser/psparse.c                     |  729 -------------
 drivers/acpi/parser/psscope.c                     |   45 
 drivers/acpi/parser/pstree.c                      |  159 +--
 drivers/acpi/parser/psutils.c                     |   52 
 drivers/acpi/parser/pswalk.c                      |   11 
 drivers/acpi/parser/psxface.c                     |  254 ++--
 drivers/acpi/pci_irq.c                            |   85 +
 drivers/acpi/pci_link.c                           |  130 +-
 drivers/acpi/processor_core.c                     |   37 
 drivers/acpi/processor_idle.c                     |  163 ++-
 drivers/acpi/processor_perflib.c                  |   33 
 drivers/acpi/resources/rsaddr.c                   |  480 +++------
 drivers/acpi/resources/rscalc.c                   |  144 +-
 drivers/acpi/resources/rscreate.c                 |   45 
 drivers/acpi/resources/rsdump.c                   |  402 ++++---
 drivers/acpi/resources/rsio.c                     |  197 +--
 drivers/acpi/resources/rsirq.c                    |  167 +--
 drivers/acpi/resources/rslist.c                   |   68 -
 drivers/acpi/resources/rsmemory.c                 |  236 +---
 drivers/acpi/resources/rsmisc.c                   |  160 +--
 drivers/acpi/resources/rsutils.c                  |   53 -
 drivers/acpi/resources/rsxface.c                  |   43 
 drivers/acpi/scan.c                               |   12 
 drivers/acpi/sleep/main.c                         |   74 -
 drivers/acpi/sleep/poweroff.c                     |   81 +
 drivers/acpi/sleep/proc.c                         |    9 
 drivers/acpi/tables/tbconvrt.c                    |  113 +-
 drivers/acpi/tables/tbget.c                       |   63 -
 drivers/acpi/tables/tbgetall.c                    |   45 
 drivers/acpi/tables/tbinstal.c                    |   61 -
 drivers/acpi/tables/tbrsdt.c                      |   74 -
 drivers/acpi/tables/tbutils.c                     |  134 ++
 drivers/acpi/tables/tbxface.c                     |   56 -
 drivers/acpi/tables/tbxfroot.c                    |  231 ++--
 drivers/acpi/toshiba_acpi.c                       |    8 
 drivers/acpi/utilities/Makefile                   |    2 
 drivers/acpi/utilities/utalloc.c                  |  360 +++---
 drivers/acpi/utilities/utcache.c                  |  328 ++++++
 drivers/acpi/utilities/utcopy.c                   |  172 ++-
 drivers/acpi/utilities/utdebug.c                  |  320 +++---
 drivers/acpi/utilities/utdelete.c                 |  199 +--
 drivers/acpi/utilities/uteval.c                   |   36 
 drivers/acpi/utilities/utglobal.c                 |  231 +---
 drivers/acpi/utilities/utinit.c                   |   38 
 drivers/acpi/utilities/utmath.c                   |    2 
 drivers/acpi/utilities/utmisc.c                   | 1146 +++++-----------------
 drivers/acpi/utilities/utmutex.c                  |  380 +++++++
 drivers/acpi/utilities/utobject.c                 |  102 -
 drivers/acpi/utilities/utstate.c                  |  376 +++++++
 drivers/acpi/utilities/utxface.c                  |   84 -
 drivers/acpi/video.c                              |   15 
 drivers/base/sys.c                                |    1 
 drivers/net/b44.c                                 |    3 
 drivers/net/ne2k-pci.c                            |    3 
 drivers/net/sk98lin/skge.c                        |   63 +
 drivers/pci/pci-acpi.c                            |  110 ++
 drivers/pci/pci.c                                 |   22 
 drivers/pci/pci.h                                 |    4 
 drivers/pcmcia/yenta_socket.c                     |   12 
 drivers/pnp/pnpacpi/rsparser.c                    |   15 
 drivers/pnp/pnpbios/rsparser.c                    |    2 
 drivers/pnp/resource.c                            |    2 
 drivers/usb/core/hcd-pci.c                        |    1 
 include/acpi/acconfig.h                           |   14 
 include/acpi/acdebug.h                            |  152 --
 include/acpi/acdisasm.h                           |  117 --
 include/acpi/acdispat.h                           |  169 ---
 include/acpi/acevents.h                           |   86 -
 include/acpi/acexcep.h                            |   11 
 include/acpi/acglobal.h                           |   41 
 include/acpi/achware.h                            |   58 -
 include/acpi/acinterp.h                           |  243 +---
 include/acpi/aclocal.h                            |   92 -
 include/acpi/acmacros.h                           |  112 +-
 include/acpi/acnames.h                            |   89 +
 include/acpi/acnamesp.h                           |  165 ---
 include/acpi/acobject.h                           |    4 
 include/acpi/acopcode.h                           |  325 ++++++
 include/acpi/acoutput.h                           |    2 
 include/acpi/acparser.h                           |  127 +-
 include/acpi/acpi.h                               |    1 
 include/acpi/acpi_bus.h                           |   21 
 include/acpi/acpi_drivers.h                       |    8 
 include/acpi/acpiosxf.h                           |   53 -
 include/acpi/acpixf.h                             |   15 
 include/acpi/acresrc.h                            |   67 -
 include/acpi/acstruct.h                           |   16 
 include/acpi/actables.h                           |   72 -
 include/acpi/actbl.h                              |   60 -
 include/acpi/actbl1.h                             |   52 
 include/acpi/actbl2.h                             |  109 +-
 include/acpi/actypes.h                            |   17 
 include/acpi/acutils.h                            |  359 ++----
 include/acpi/amlcode.h                            |   14 
 include/acpi/pdc_intel.h                          |   29 
 include/acpi/platform/acenv.h                     |   57 -
 include/acpi/platform/acgcc.h                     |    8 
 include/acpi/platform/aclinux.h                   |   11 
 include/acpi/processor.h                          |   34 
 include/asm-alpha/pci.h                           |    2 
 include/asm-arm/pci.h                             |    2 
 include/asm-h8300/pci.h                           |    2 
 include/asm-i386/acpi.h                           |   10 
 include/asm-i386/apicdef.h                        |    6 
 include/asm-i386/pci.h                            |    2 
 include/asm-ia64/acpi.h                           |    9 
 include/asm-ia64/pci.h                            |    2 
 include/asm-m68k/pci.h                            |    2 
 include/asm-mips/pci.h                            |    2 
 include/asm-ppc/pci.h                             |    2 
 include/asm-ppc64/pci.h                           |    2 
 include/asm-sh/pci.h                              |    2 
 include/asm-sh64/pci.h                            |    2 
 include/asm-sparc/pci.h                           |    2 
 include/asm-sparc64/pci.h                         |    2 
 include/asm-x86_64/acpi.h                         |    8 
 include/asm-x86_64/pci.h                          |    2 
 include/linux/acpi.h                              |   11 
 include/linux/device.h                            |    6 
 include/linux/pm.h                                |    2 
 kernel/power/main.c                               |   16 
 sound/pci/intel8x0.c                              |    6 
 217 files changed, 12228 insertions(+), 8305 deletions(-)
diff --git a/Documentation/acpi-hotkey.txt b/Documentation/acpi-hotkey.txt
new file mode 100644
--- /dev/null
+++ b/Documentation/acpi-hotkey.txt
@@ -0,0 +1,38 @@
+driver/acpi/hotkey.c implement:
+1. /proc/acpi/hotkey/event_config 
+(event based hotkey or event config interface):
+a. add a  event based hotkey(event) : 
+echo "0:bus::action:method:num:num" > event_config
+
+b. delete a event based hotkey(event): 
+echo "1:::::num:num" > event_config
+
+c.  modify a event based hotkey(event):    
+echo "2:bus::action:method:num:num" > event_config
+
+2. /proc/acpi/hotkey/poll_config 
+(polling based hotkey or event config interface):
+a.add a polling based hotkey(event) : 	
+echo "0:bus:method:action:method:num" > poll_config
+this adding command will create a proc file 
+/proc/acpi/hotkey/method, which is used to get 
+result of polling.
+
+b.delete a polling based hotkey(event): 	
+echo "1:::::num" > event_config
+
+c.modify a polling based hotkey(event):    
+echo "2:bus:method:action:method:num" > poll_config
+
+3./proc/acpi/hotkey/action 
+(interface to call aml method associated with a 
+specific hotkey(event))
+echo "event_num:event_type:event_argument" > 
+	/proc/acpi/hotkey/action.
+The result of the execution of this aml method is 
+attached to /proc/acpi/hotkey/poll_method, which is dnyamically
+created.  Please use command "cat /proc/acpi/hotkey/polling_method" 
+to retrieve it.
+
+Note: Use cmdline "acpi_specific_hotkey" to enable legacy platform
+specific drivers.
diff --git a/arch/frv/mb93090-mb00/pci-irq.c b/arch/frv/mb93090-mb00/pci-irq.c
--- a/arch/frv/mb93090-mb00/pci-irq.c
+++ b/arch/frv/mb93090-mb00/pci-irq.c
@@ -60,7 +60,7 @@ void __init pcibios_fixup_irqs(void)
 	}
 }
 
-void __init pcibios_penalize_isa_irq(int irq)
+void __init pcibios_penalize_isa_irq(int irq, int active)
 {
 }
 
diff --git a/arch/i386/kernel/acpi/Makefile b/arch/i386/kernel/acpi/Makefile
--- a/arch/i386/kernel/acpi/Makefile
+++ b/arch/i386/kernel/acpi/Makefile
@@ -2,3 +2,7 @@ obj-$(CONFIG_ACPI_BOOT)		:= boot.o
 obj-$(CONFIG_X86_IO_APIC)	+= earlyquirk.o
 obj-$(CONFIG_ACPI_SLEEP)	+= sleep.o wakeup.o
 
+ifneq ($(CONFIG_ACPI_PROCESSOR),)
+obj-y				+= cstate.o
+endif
+
diff --git a/arch/i386/kernel/acpi/cstate.c b/arch/i386/kernel/acpi/cstate.c
new file mode 100644
--- /dev/null
+++ b/arch/i386/kernel/acpi/cstate.c
@@ -0,0 +1,103 @@
+/*
+ * arch/i386/kernel/acpi/cstate.c
+ *
+ * Copyright (C) 2005 Intel Corporation
+ * 	Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
+ * 	- Added _PDC for SMP C-states on Intel CPUs
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/acpi.h>
+
+#include <acpi/processor.h>
+#include <asm/acpi.h>
+
+static void acpi_processor_power_init_intel_pdc(struct acpi_processor_power
+						*pow)
+{
+	struct acpi_object_list *obj_list;
+	union acpi_object *obj;
+	u32 *buf;
+
+	/* allocate and initialize pdc. It will be used later. */
+	obj_list = kmalloc(sizeof(struct acpi_object_list), GFP_KERNEL);
+	if (!obj_list) {
+		printk(KERN_ERR "Memory allocation error\n");
+		return;
+	}
+
+	obj = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+	if (!obj) {
+		printk(KERN_ERR "Memory allocation error\n");
+		kfree(obj_list);
+		return;
+	}
+
+	buf = kmalloc(12, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_ERR "Memory allocation error\n");
+		kfree(obj);
+		kfree(obj_list);
+		return;
+	}
+
+	buf[0] = ACPI_PDC_REVISION_ID;
+	buf[1] = 1;
+	buf[2] = ACPI_PDC_C_CAPABILITY_SMP;
+
+	obj->type = ACPI_TYPE_BUFFER;
+	obj->buffer.length = 12;
+	obj->buffer.pointer = (u8 *) buf;
+	obj_list->count = 1;
+	obj_list->pointer = obj;
+	pow->pdc = obj_list;
+
+	return;
+}
+
+/* Initialize _PDC data based on the CPU vendor */
+void acpi_processor_power_init_pdc(struct acpi_processor_power *pow,
+				   unsigned int cpu)
+{
+	struct cpuinfo_x86 *c = cpu_data + cpu;
+
+	pow->pdc = NULL;
+	if (c->x86_vendor == X86_VENDOR_INTEL)
+		acpi_processor_power_init_intel_pdc(pow);
+
+	return;
+}
+
+EXPORT_SYMBOL(acpi_processor_power_init_pdc);
+
+/*
+ * Initialize bm_flags based on the CPU cache properties
+ * On SMP it depends on cache configuration
+ * - When cache is not shared among all CPUs, we flush cache
+ *   before entering C3.
+ * - When cache is shared among all CPUs, we use bm_check
+ *   mechanism as in UP case
+ *
+ * This routine is called only after all the CPUs are online
+ */
+void acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags,
+					unsigned int cpu)
+{
+	struct cpuinfo_x86 *c = cpu_data + cpu;
+
+	flags->bm_check = 0;
+	if (num_online_cpus() == 1)
+		flags->bm_check = 1;
+	else if (c->x86_vendor == X86_VENDOR_INTEL) {
+		/*
+		 * Today all CPUs that support C3 share cache.
+		 * TBD: This needs to look at cache shared map, once
+		 * multi-core detection patch makes to the base.
+		 */
+		flags->bm_check = 1;
+	}
+}
+
+EXPORT_SYMBOL(acpi_processor_power_init_bm_check);
diff --git a/arch/i386/kernel/acpi/wakeup.S b/arch/i386/kernel/acpi/wakeup.S
--- a/arch/i386/kernel/acpi/wakeup.S
+++ b/arch/i386/kernel/acpi/wakeup.S
@@ -74,8 +74,9 @@ wakeup_code:
 	movw	%ax,%fs
 	movw	$0x0e00 + 'i', %fs:(0x12)
 	
-	# need a gdt
-	lgdt	real_save_gdt - wakeup_code
+	# need a gdt -- use lgdtl to force 32-bit operands, in case
+	# the GDT is located past 16 megabytes.
+	lgdtl	real_save_gdt - wakeup_code
 
 	movl	real_save_cr0 - wakeup_code, %eax
 	movl	%eax, %cr0
diff --git a/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c b/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
--- a/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
+++ b/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
@@ -442,6 +442,13 @@ acpi_cpufreq_cpu_init (
 			(u32) data->acpi_data.states[i].transition_latency);
 
 	cpufreq_frequency_table_get_attr(data->freq_table, policy->cpu);
+	
+	/*
+	 * the first call to ->target() should result in us actually
+	 * writing something to the appropriate registers.
+	 */
+	data->resume = 1;
+	
 	return (result);
 
  err_freqfree:
diff --git a/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c b/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
--- a/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
+++ b/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
@@ -375,7 +375,7 @@ static int centrino_cpu_init_acpi(struct
 	arg0.buffer.pointer = (u8 *) arg0_buf;
 	arg0_buf[0] = ACPI_PDC_REVISION_ID;
 	arg0_buf[1] = 1;
-	arg0_buf[2] = ACPI_PDC_EST_CAPABILITY_SMP | ACPI_PDC_EST_CAPABILITY_MSR;
+	arg0_buf[2] = ACPI_PDC_EST_CAPABILITY_SMP_MSR;
 
 	p.pdc = &arg_list;
 
diff --git a/arch/i386/pci/acpi.c b/arch/i386/pci/acpi.c
--- a/arch/i386/pci/acpi.c
+++ b/arch/i386/pci/acpi.c
@@ -30,6 +30,7 @@ static int __init pci_acpi_init(void)
 	acpi_irq_penalty_init();
 	pcibios_scanned++;
 	pcibios_enable_irq = acpi_pci_irq_enable;
+	pcibios_disable_irq = acpi_pci_irq_disable;
 
 	if (pci_routeirq) {
 		/*
diff --git a/arch/i386/pci/common.c b/arch/i386/pci/common.c
--- a/arch/i386/pci/common.c
+++ b/arch/i386/pci/common.c
@@ -249,3 +249,9 @@ int pcibios_enable_device(struct pci_dev
 
 	return pcibios_enable_irq(dev);
 }
+
+void pcibios_disable_device (struct pci_dev *dev)
+{
+	if (pcibios_disable_irq)
+		pcibios_disable_irq(dev);
+}
diff --git a/arch/i386/pci/irq.c b/arch/i386/pci/irq.c
--- a/arch/i386/pci/irq.c
+++ b/arch/i386/pci/irq.c
@@ -56,6 +56,7 @@ struct irq_router_handler {
 };
 
 int (*pcibios_enable_irq)(struct pci_dev *dev) = NULL;
+void (*pcibios_disable_irq)(struct pci_dev *dev) = NULL;
 
 /*
  *  Search 0xf0000 -- 0xfffff for the PCI IRQ Routing Table.
@@ -1006,24 +1007,28 @@ static int __init pcibios_irq_init(void)
 subsys_initcall(pcibios_irq_init);
 
 
-static void pirq_penalize_isa_irq(int irq)
+static void pirq_penalize_isa_irq(int irq, int active)
 {
 	/*
 	 *  If any ISAPnP device reports an IRQ in its list of possible
 	 *  IRQ's, we try to avoid assigning it to PCI devices.
 	 */
-	if (irq < 16)
-		pirq_penalty[irq] += 100;
+	if (irq < 16) {
+		if (active)
+			pirq_penalty[irq] += 1000;
+		else
+			pirq_penalty[irq] += 100;
+	}
 }
 
-void pcibios_penalize_isa_irq(int irq)
+void pcibios_penalize_isa_irq(int irq, int active)
 {
 #ifdef CONFIG_ACPI_PCI
 	if (!acpi_noirq)
-		acpi_penalize_isa_irq(irq);
+		acpi_penalize_isa_irq(irq, active);
 	else
 #endif
-		pirq_penalize_isa_irq(irq);
+		pirq_penalize_isa_irq(irq, active);
 }
 
 static int pirq_enable_irq(struct pci_dev *dev)
diff --git a/arch/i386/pci/pci.h b/arch/i386/pci/pci.h
--- a/arch/i386/pci/pci.h
+++ b/arch/i386/pci/pci.h
@@ -72,3 +72,4 @@ extern int pcibios_scanned;
 extern spinlock_t pci_config_lock;
 
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
+extern void (*pcibios_disable_irq)(struct pci_dev *dev);
diff --git a/arch/i386/pci/visws.c b/arch/i386/pci/visws.c
--- a/arch/i386/pci/visws.c
+++ b/arch/i386/pci/visws.c
@@ -21,7 +21,7 @@ static int pci_visws_enable_irq(struct p
 
 int (*pcibios_enable_irq)(struct pci_dev *dev) = &pci_visws_enable_irq;
 
-void __init pcibios_penalize_isa_irq(int irq) {}
+void __init pcibios_penalize_isa_irq(int irq, int active) {}
 
 
 unsigned int pci_bus0, pci_bus1;
diff --git a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
--- a/arch/ia64/kernel/acpi.c
+++ b/arch/ia64/kernel/acpi.c
@@ -11,6 +11,7 @@
  *  Copyright (C) 2001 Jenna Hall <jenna.s.hall@intel.com>
  *  Copyright (C) 2001 Takayoshi Kochi <t-kochi@bq.jp.nec.com>
  *  Copyright (C) 2002 Erich Focht <efocht@ess.nec.de>
+ *  Copyright (C) 2004 Ashok Raj <ashok.raj@intel.com>
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -67,6 +68,11 @@ EXPORT_SYMBOL(pm_power_off);
 unsigned char acpi_kbd_controller_present = 1;
 unsigned char acpi_legacy_devices;
 
+static unsigned int __initdata acpi_madt_rev;
+
+unsigned int acpi_cpei_override;
+unsigned int acpi_cpei_phys_cpuid;
+
 #define MAX_SAPICS 256
 u16 ia64_acpiid_to_sapicid[MAX_SAPICS] =
 	{ [0 ... MAX_SAPICS - 1] = -1 };
@@ -267,10 +273,56 @@ acpi_parse_plat_int_src (
 						(plintsrc->flags.trigger == 1) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
 
 	platform_intr_list[plintsrc->type] = vector;
+	if (acpi_madt_rev > 1) {
+		acpi_cpei_override = plintsrc->plint_flags.cpei_override_flag;
+	}
+
+	/*
+	 * Save the physical id, so we can check when its being removed
+	 */
+	acpi_cpei_phys_cpuid = ((plintsrc->id << 8) | (plintsrc->eid)) & 0xffff;
+
 	return 0;
 }
 
 
+unsigned int can_cpei_retarget(void)
+{
+	extern int cpe_vector;
+
+	/*
+	 * Only if CPEI is supported and the override flag
+	 * is present, otherwise return that its re-targettable
+	 * if we are in polling mode.
+	 */
+	if (cpe_vector > 0 && !acpi_cpei_override)
+		return 0;
+	else
+		return 1;
+}
+
+unsigned int is_cpu_cpei_target(unsigned int cpu)
+{
+	unsigned int logical_id;
+
+	logical_id = cpu_logical_id(acpi_cpei_phys_cpuid);
+
+	if (logical_id == cpu)
+		return 1;
+	else
+		return 0;
+}
+
+void set_cpei_target_cpu(unsigned int cpu)
+{
+	acpi_cpei_phys_cpuid = cpu_physical_id(cpu);
+}
+
+unsigned int get_cpei_target_cpu(void)
+{
+	return acpi_cpei_phys_cpuid;
+}
+
 static int __init
 acpi_parse_int_src_ovr (
 	acpi_table_entry_header *header, const unsigned long end)
@@ -328,6 +380,8 @@ acpi_parse_madt (unsigned long phys_addr
 
 	acpi_madt = (struct acpi_table_madt *) __va(phys_addr);
 
+	acpi_madt_rev = acpi_madt->header.revision;
+
 	/* remember the value for reference after free_initmem() */
 #ifdef CONFIG_ITANIUM
 	has_8259 = 1; /* Firmware on old Itanium systems is broken */
diff --git a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
--- a/arch/ia64/kernel/mca.c
+++ b/arch/ia64/kernel/mca.c
@@ -271,7 +271,7 @@ ia64_mca_log_sal_error_record(int sal_in
 
 #ifdef CONFIG_ACPI
 
-static int cpe_vector = -1;
+int cpe_vector = -1;
 
 static irqreturn_t
 ia64_mca_cpe_int_handler (int cpe_irq, void *arg, struct pt_regs *ptregs)
diff --git a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
--- a/arch/ia64/kernel/process.c
+++ b/arch/ia64/kernel/process.c
@@ -195,6 +195,7 @@ update_pal_halt_status(int status)
 void
 default_idle (void)
 {
+	local_irq_enable();
 	while (!need_resched())
 		if (can_do_pal_halt)
 			safe_halt();
diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
--- a/arch/ia64/kernel/setup.c
+++ b/arch/ia64/kernel/setup.c
@@ -40,6 +40,8 @@
 #include <linux/serial_core.h>
 #include <linux/efi.h>
 #include <linux/initrd.h>
+#include <linux/platform.h>
+#include <linux/pm.h>
 
 #include <asm/ia32.h>
 #include <asm/machvec.h>
@@ -779,6 +781,7 @@ cpu_init (void)
 	/* size of physical stacked register partition plus 8 bytes: */
 	__get_cpu_var(ia64_phys_stacked_size_p8) = num_phys_stacked*8 + 8;
 	platform_cpu_init();
+	pm_idle = default_idle;
 }
 
 void
diff --git a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
--- a/arch/ia64/kernel/topology.c
+++ b/arch/ia64/kernel/topology.c
@@ -36,6 +36,13 @@ int arch_register_cpu(int num)
 	parent = &sysfs_nodes[cpu_to_node(num)];
 #endif /* CONFIG_NUMA */
 
+	/*
+	 * If CPEI cannot be re-targetted, and this is
+	 * CPEI target, then dont create the control file
+	 */
+	if (!can_cpei_retarget() && is_cpu_cpei_target(num))
+		sysfs_cpus[num].cpu.no_control = 1;
+
 	return register_cpu(&sysfs_cpus[num].cpu, num, parent);
 }
 
diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -3,6 +3,7 @@
 #
 
 menu "ACPI (Advanced Configuration and Power Interface) Support"
+	depends on PM
 	depends on !X86_VISWS
 	depends on !IA64_HP_SIM
 	depends on IA64 || X86
@@ -48,7 +49,6 @@ config ACPI_BOOT
 
 config ACPI_INTERPRETER
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 if ACPI_INTERPRETER
@@ -56,7 +56,7 @@ if ACPI_INTERPRETER
 config ACPI_SLEEP
 	bool "Sleep States (EXPERIMENTAL)"
 	depends on X86
-	depends on EXPERIMENTAL && PM
+	depends on EXPERIMENTAL
 	default y
 	---help---
 	  This option adds support for ACPI suspend states. 
@@ -79,6 +79,14 @@ config ACPI_SLEEP_PROC_FS
 	depends on ACPI_SLEEP && PROC_FS
 	default y
 
+config ACPI_SLEEP_PROC_SLEEP
+	bool "/proc/acpi/sleep (deprecated)"
+	depends on ACPI_SLEEP_PROC_FS
+	default n
+	---help---
+	  Create /proc/acpi/sleep
+	  Deprecated by /sys/power/state
+
 config ACPI_AC
 	tristate "AC Adapter"
 	depends on X86
@@ -99,7 +107,6 @@ config ACPI_BATTERY
 
 config ACPI_BUTTON
 	tristate "Button"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver registers for events based on buttons, such as the
@@ -111,7 +118,6 @@ config ACPI_BUTTON
 config ACPI_VIDEO
 	tristate "Video"
 	depends on EXPERIMENTAL
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver implement the ACPI Extensions For Display Adapters
@@ -122,9 +128,17 @@ config ACPI_VIDEO
 	  Note that this is an ref. implementation only.  It may or may not work
 	  for your integrated video device.
 
+config ACPI_HOTKEY
+	tristate "Generic Hotkey"
+	depends on ACPI_INTERPRETER
+	depends on EXPERIMENTAL
+	depends on !IA64_SGI_SN
+	default m
+	help
+	ACPI generic hotkey
+
 config ACPI_FAN
 	tristate "Fan"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver adds support for ACPI fan devices, allowing user-mode 
@@ -132,7 +146,6 @@ config ACPI_FAN
 
 config ACPI_PROCESSOR
 	tristate "Processor"
-	depends on !IA64_SGI_SN
 	default m
 	help
 	  This driver installs ACPI as the idle handler for Linux, and uses
@@ -142,7 +155,6 @@ config ACPI_PROCESSOR
 config ACPI_HOTPLUG_CPU
 	bool "Processor Hotplug (EXPERIMENTAL)"
 	depends on ACPI_PROCESSOR && HOTPLUG_CPU && EXPERIMENTAL
-	depends on !IA64_SGI_SN
 	select ACPI_CONTAINER
 	default n
 	 ---help---
@@ -262,7 +274,6 @@ config ACPI_BLACKLIST_YEAR
 
 config ACPI_DEBUG
 	bool "Debug Statements"
-	depends on !IA64_SGI_SN
 	default n
 	help
 	  The ACPI driver can optionally report errors with a great deal
@@ -271,7 +282,6 @@ config ACPI_DEBUG
 
 config ACPI_BUS
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 config ACPI_EC
@@ -285,17 +295,14 @@ config ACPI_EC
 
 config ACPI_POWER
 	bool
-	depends on !IA64_SGI_SN
 	default y
 
 config ACPI_PCI
 	bool
-	depends on !IA64_SGI_SN
 	default PCI
 
 config ACPI_SYSTEM
 	bool
-	depends on !IA64_SGI_SN
 	default y
 	help
 	  This driver will enable your system to shut down using ACPI, and
@@ -327,8 +334,13 @@ config ACPI_CONTAINER
 	depends on EXPERIMENTAL
 	default (ACPI_HOTPLUG_MEMORY || ACPI_HOTPLUG_CPU || ACPI_HOTPLUG_IO)
 	 ---help---
-	 	This is the ACPI generic container driver which supports
-		ACPI0004, PNP0A05 and PNP0A06 devices
+	  This allows _physical_ insertion and removal of CPUs and memory.
+	  This can be useful, for example, on NUMA machines that support
+	  ACPI based physical hotplug of nodes, or non-NUMA machines that
+	  support physical cpu/memory hot-plug.
+
+	  If one selects "m", this driver can be loaded with
+	  "modprobe acpi_container".
 
 config ACPI_HOTPLUG_MEMORY
 	tristate "Memory Hotplug"
diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -36,13 +36,14 @@ processor-objs	+= processor_perflib.o			
 endif
 
 obj-$(CONFIG_ACPI_BUS)		+= sleep/
-obj-$(CONFIG_ACPI_BUS)		+= bus.o
+obj-$(CONFIG_ACPI_BUS)		+= bus.o glue.o
 obj-$(CONFIG_ACPI_AC) 		+= ac.o
 obj-$(CONFIG_ACPI_BATTERY)	+= battery.o
 obj-$(CONFIG_ACPI_BUTTON)	+= button.o
 obj-$(CONFIG_ACPI_EC)		+= ec.o
 obj-$(CONFIG_ACPI_FAN)		+= fan.o
-obj-$(CONFIG_ACPI_VIDEO)	+= video.o
+obj-$(CONFIG_ACPI_VIDEO)	+= video.o 
+obj-$(CONFIG_ACPI_HOTKEY)	+= hotkey.o
 obj-$(CONFIG_ACPI_PCI)		+= pci_root.o pci_link.o pci_irq.o pci_bind.o
 obj-$(CONFIG_ACPI_POWER)	+= power.o
 obj-$(CONFIG_ACPI_PROCESSOR)	+= processor.o
diff --git a/drivers/acpi/asus_acpi.c b/drivers/acpi/asus_acpi.c
--- a/drivers/acpi/asus_acpi.c
+++ b/drivers/acpi/asus_acpi.c
@@ -1204,6 +1204,10 @@ static int __init asus_acpi_init(void)
 	if (acpi_disabled)
 		return -ENODEV;
 
+	if (!acpi_specific_hotkey_enabled){
+		printk(KERN_ERR "Using generic hotkey driver\n");
+		return -ENODEV;	
+	}
 	asus_proc_dir = proc_mkdir(PROC_ASUS, acpi_root_dir);
 	if (!asus_proc_dir) {
 		printk(KERN_ERR "Asus ACPI: Unable to create /proc entry\n");
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -212,6 +212,12 @@ acpi_bus_set_power (
 		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
 		return_VALUE(-ENODEV);
 	}
+	/*
+	 * Get device's current power state if it's unknown
+	 * This means device power state isn't initialized or previous setting failed
+	 */
+	if (device->power.state == ACPI_STATE_UNKNOWN)
+		acpi_bus_get_power(device->handle, &device->power.state);
 	if (state == device->power.state) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
 		return_VALUE(0);
@@ -231,7 +237,7 @@ acpi_bus_set_power (
 	 * On transitions to a high-powered state we first apply power (via
 	 * power resources) then evalute _PSx.  Conversly for transitions to
 	 * a lower-powered state.
-	 */ 
+	 */
 	if (state < device->power.state) {
 		if (device->power.flags.power_resources) {
 			result = acpi_power_transition(device, state);
diff --git a/drivers/acpi/button.c b/drivers/acpi/button.c
--- a/drivers/acpi/button.c
+++ b/drivers/acpi/button.c
@@ -26,9 +26,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -36,9 +33,6 @@
 #define ACPI_BUTTON_COMPONENT		0x00080000
 #define ACPI_BUTTON_DRIVER_NAME		"ACPI Button Driver"
 #define ACPI_BUTTON_CLASS		"button"
-#define ACPI_BUTTON_FILE_INFO		"info"
-#define ACPI_BUTTON_FILE_STATE		"state"
-#define ACPI_BUTTON_TYPE_UNKNOWN	0x00
 #define ACPI_BUTTON_NOTIFY_STATUS	0x80
 
 #define ACPI_BUTTON_SUBCLASS_POWER	"power"
@@ -70,8 +64,6 @@ MODULE_LICENSE("GPL");
 
 static int acpi_button_add (struct acpi_device *device);
 static int acpi_button_remove (struct acpi_device *device, int type);
-static int acpi_button_info_open_fs(struct inode *inode, struct file *file);
-static int acpi_button_state_open_fs(struct inode *inode, struct file *file);
 
 static struct acpi_driver acpi_button_driver = {
 	.name =		ACPI_BUTTON_DRIVER_NAME,
@@ -90,187 +82,6 @@ struct acpi_button {
 	unsigned long		pushed;
 };
 
-static struct file_operations acpi_button_info_fops = {
-	.open		= acpi_button_info_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct file_operations acpi_button_state_fops = {
-	.open		= acpi_button_state_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-static struct proc_dir_entry	*acpi_button_dir;
-
-static int acpi_button_info_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_button	*button = (struct acpi_button *) seq->private;
-
-	ACPI_FUNCTION_TRACE("acpi_button_info_seq_show");
-
-	if (!button || !button->device)
-		return_VALUE(0);
-
-	seq_printf(seq, "type:                    %s\n", 
-		acpi_device_name(button->device));
-
-	return_VALUE(0);
-}
-
-static int acpi_button_info_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_button_info_seq_show, PDE(inode)->data);
-}
-	
-static int acpi_button_state_seq_show(struct seq_file *seq, void *offset)
-{
-	struct acpi_button	*button = (struct acpi_button *) seq->private;
-	acpi_status		status;
-	unsigned long		state;
-
-	ACPI_FUNCTION_TRACE("acpi_button_state_seq_show");
-
-	if (!button || !button->device)
-		return_VALUE(0);
-
-	status = acpi_evaluate_integer(button->handle,"_LID",NULL,&state);
-	if (ACPI_FAILURE(status)) {
-		seq_printf(seq, "state:      unsupported\n");
-	}
-	else{
-		seq_printf(seq, "state:      %s\n", (state ? "open" : "closed")); 
-	}
-
-	return_VALUE(0);
-}
-
-static int acpi_button_state_open_fs(struct inode *inode, struct file *file)
-{
-	return single_open(file, acpi_button_state_seq_show, PDE(inode)->data);
-}
-
-static int
-acpi_button_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_add_fs");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	button = acpi_driver_data(device);
-
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWER:
-	case ACPI_BUTTON_TYPE_POWERF:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_POWER, 
-				acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_SLEEP:
-	case ACPI_BUTTON_TYPE_SLEEPF:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_SLEEP, 
-				acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_LID:
-			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, 
-				acpi_button_dir);
-		break;
-	}
-
-	if (!entry)
-		return_VALUE(-ENODEV);
-	entry->owner = THIS_MODULE;
-
-	acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), entry);
-	if (!acpi_device_dir(device))
-		return_VALUE(-ENODEV);
-	acpi_device_dir(device)->owner = THIS_MODULE;
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_BUTTON_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BUTTON_FILE_INFO));
-	else {
-		entry->proc_fops = &acpi_button_info_fops;
-		entry->data = acpi_driver_data(device);
-		entry->owner = THIS_MODULE;
-	}
-
-	/* show lid state [R] */
-	if (button->type == ACPI_BUTTON_TYPE_LID) {
-		entry = create_proc_entry(ACPI_BUTTON_FILE_STATE,
-			S_IRUGO, acpi_device_dir(device));
-		if (!entry)
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Unable to create '%s' fs entry\n",
-				ACPI_BUTTON_FILE_INFO));
-		else {
-			entry->proc_fops = &acpi_button_state_fops;
-			entry->data = acpi_driver_data(device);
-			entry->owner = THIS_MODULE;
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_button_remove_fs (
-	struct acpi_device	*device)
-{
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_remove_fs");
-
-	button = acpi_driver_data(device);
-	if (acpi_device_dir(device)) {
-		if (button->type == ACPI_BUTTON_TYPE_LID)
-			remove_proc_entry(ACPI_BUTTON_FILE_STATE,
-					     acpi_device_dir(device));
-		remove_proc_entry(ACPI_BUTTON_FILE_INFO,
-				     acpi_device_dir(device));
-
-		remove_proc_entry(acpi_device_bid(device),
-				     acpi_device_dir(device)->parent);
-
-
-		switch (button->type) {
-			case ACPI_BUTTON_TYPE_POWER:
-			case ACPI_BUTTON_TYPE_POWERF:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_POWER, 
-					acpi_button_dir);
-				break;
-			case ACPI_BUTTON_TYPE_SLEEP:
-			case ACPI_BUTTON_TYPE_SLEEPF:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_SLEEP, 
-					acpi_button_dir);
-				break;
-			case ACPI_BUTTON_TYPE_LID:
-				remove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, 
-					acpi_button_dir);
-				break;
-		}
-		acpi_device_dir(device) = NULL;
-	}
-
-	return_VALUE(0);
-}
-
-
 /* --------------------------------------------------------------------------
                                 Driver Interface
    -------------------------------------------------------------------------- */
@@ -310,8 +121,7 @@ acpi_button_notify_fixed (
 	
 	ACPI_FUNCTION_TRACE("acpi_button_notify_fixed");
 
-	if (!button)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	BUG_ON(!button);
 
 	acpi_button_notify(button->handle, ACPI_BUTTON_NOTIFY_STATUS, button);
 
@@ -327,10 +137,6 @@ acpi_button_add (
 	acpi_status		status = AE_OK;
 	struct acpi_button	*button = NULL;
 
-	static struct acpi_device *power_button;
-	static struct acpi_device *sleep_button;
-	static struct acpi_device *lid_button;
-
 	ACPI_FUNCTION_TRACE("acpi_button_add");
 
 	if (!device)
@@ -391,42 +197,6 @@ acpi_button_add (
 		goto end;
 	}
 
-	/*
-	 * Ensure only one button of each type is used.
-	 */
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWER:
-	case ACPI_BUTTON_TYPE_POWERF:
-		if (!power_button)
-			power_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	case ACPI_BUTTON_TYPE_SLEEP:
-	case ACPI_BUTTON_TYPE_SLEEPF:
-		if (!sleep_button)
-			sleep_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	case ACPI_BUTTON_TYPE_LID:
-		if (!lid_button)
-			lid_button = device;
-		else {
-			kfree(button);
-			return_VALUE(-ENODEV);
-		}
-		break;
-	}
-
-	result = acpi_button_add_fs(device);
-	if (result)
-		goto end;
-
 	switch (button->type) {
 	case ACPI_BUTTON_TYPE_POWERF:
 		status = acpi_install_fixed_event_handler (
@@ -470,7 +240,6 @@ acpi_button_add (
 
 end:
 	if (result) {
-		acpi_button_remove_fs(device);
 		kfree(button);
 	}
 
@@ -511,8 +280,6 @@ acpi_button_remove (struct acpi_device *
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 			"Error removing notify handler\n"));
 
-	acpi_button_remove_fs(device);	
-
 	kfree(button);
 
 	return_VALUE(0);
@@ -526,21 +293,14 @@ acpi_button_init (void)
 
 	ACPI_FUNCTION_TRACE("acpi_button_init");
 
-	acpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);
-	if (!acpi_button_dir)
-		return_VALUE(-ENODEV);
-	acpi_button_dir->owner = THIS_MODULE;
-
 	result = acpi_bus_register_driver(&acpi_button_driver);
 	if (result < 0) {
-		remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
 		return_VALUE(-ENODEV);
 	}
 
 	return_VALUE(0);
 }
 
-
 static void __exit
 acpi_button_exit (void)
 {
@@ -548,11 +308,8 @@ acpi_button_exit (void)
 
 	acpi_bus_unregister_driver(&acpi_button_driver);
 
-	remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
-
 	return_VOID;
 }
 
-
 module_init(acpi_button_init);
 module_exit(acpi_button_exit);
diff --git a/drivers/acpi/dispatcher/dsfield.c b/drivers/acpi/dispatcher/dsfield.c
--- a/drivers/acpi/dispatcher/dsfield.c
+++ b/drivers/acpi/dispatcher/dsfield.c
@@ -53,13 +53,20 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsfield")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ds_get_field_names (
+	struct acpi_create_field_info   *info,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_create_buffer_field
  *
- * PARAMETERS:  Opcode              - The opcode to be executed
- *              Operands            - List of operands for the opcode
+ * PARAMETERS:  Op                  - Current parse op (create_xXField)
  *              walk_state          - Current state
  *
  * RETURN:      Status
@@ -70,7 +77,7 @@
  *              create_word_field_op,
  *              create_dword_field_op,
  *              create_qword_field_op,
- *              create_field_op     (all of which define fields in buffers)
+ *              create_field_op     (all of which define a field in a buffer)
  *
  ******************************************************************************/
 
@@ -119,7 +126,8 @@ acpi_ds_create_buffer_field (
 			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE;
 		}
 		else {
-			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND;
+			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+					ACPI_NS_ERROR_IF_FOUND;
 		}
 
 		/*
@@ -134,16 +142,16 @@ acpi_ds_create_buffer_field (
 		}
 	}
 
-	/* We could put the returned object (Node) on the object stack for later, but
-	 * for now, we will put it in the "op" object that the parser uses, so we
-	 * can get it again at the end of this scope
+	/* We could put the returned object (Node) on the object stack for later,
+	 * but for now, we will put it in the "op" object that the parser uses,
+	 * so we can get it again at the end of this scope
 	 */
 	op->common.node = node;
 
 	/*
-	 * If there is no object attached to the node, this node was just created and
-	 * we need to create the field object.  Otherwise, this was a lookup of an
-	 * existing node and we don't want to create the field object again.
+	 * If there is no object attached to the node, this node was just created
+	 * and we need to create the field object.  Otherwise, this was a lookup
+	 * of an existing node and we don't want to create the field object again.
 	 */
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (obj_desc) {
@@ -205,7 +213,7 @@ cleanup:
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_get_field_names (
 	struct acpi_create_field_info   *info,
 	struct acpi_walk_state          *walk_state,
@@ -238,7 +246,8 @@ acpi_ds_get_field_names (
 					 + (acpi_integer) arg->common.value.size;
 
 			if (position > ACPI_UINT32_MAX) {
-				ACPI_REPORT_ERROR (("Bit offset within field too large (> 0xFFFFFFFF)\n"));
+				ACPI_REPORT_ERROR ((
+					"Bit offset within field too large (> 0xFFFFFFFF)\n"));
 				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
@@ -250,12 +259,15 @@ acpi_ds_get_field_names (
 
 			/*
 			 * Get a new access_type and access_attribute -- to be used for all
-			 * field units that follow, until field end or another access_as keyword.
+			 * field units that follow, until field end or another access_as
+			 * keyword.
 			 *
-			 * In field_flags, preserve the flag bits other than the ACCESS_TYPE bits
+			 * In field_flags, preserve the flag bits other than the
+			 * ACCESS_TYPE bits
 			 */
-			info->field_flags = (u8) ((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
-					  ((u8) ((u32) arg->common.value.integer >> 8)));
+			info->field_flags = (u8)
+				((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
+				((u8) ((u32) arg->common.value.integer >> 8)));
 
 			info->attribute = (u8) (arg->common.value.integer);
 			break;
@@ -267,7 +279,8 @@ acpi_ds_get_field_names (
 
 			status = acpi_ns_lookup (walk_state->scope_info,
 					  (char *) &arg->named.name,
-					  info->field_type, ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+					  info->field_type, ACPI_IMODE_EXECUTE,
+					  ACPI_NS_DONT_OPEN_SCOPE,
 					  walk_state, &info->field_node);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
@@ -295,8 +308,9 @@ acpi_ds_get_field_names (
 					 + (acpi_integer) arg->common.value.size;
 
 			if (position > ACPI_UINT32_MAX) {
-				ACPI_REPORT_ERROR (("Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
-						(char *) &info->field_node->name));
+				ACPI_REPORT_ERROR ((
+					"Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
+					(char *) &info->field_node->name));
 				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
@@ -306,7 +320,8 @@ acpi_ds_get_field_names (
 
 		default:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid opcode in field list: %X\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Invalid opcode in field list: %X\n",
 				arg->common.aml_opcode));
 			return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 		}
@@ -435,7 +450,8 @@ acpi_ds_init_field_objects (
 			status = acpi_ns_lookup (walk_state->scope_info,
 					  (char *) &arg->named.name,
 					  type, ACPI_IMODE_LOAD_PASS1,
-					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,
+					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+					  ACPI_NS_ERROR_IF_FOUND,
 					  walk_state, &node);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
diff --git a/drivers/acpi/dispatcher/dsinit.c b/drivers/acpi/dispatcher/dsinit.c
--- a/drivers/acpi/dispatcher/dsinit.c
+++ b/drivers/acpi/dispatcher/dsinit.c
@@ -49,12 +49,21 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsinit")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ds_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_one_object
  *
- * PARAMETERS:  obj_handle      - Node
+ * PARAMETERS:  obj_handle      - Node for the object
  *              Level           - Current nesting level
  *              Context         - Points to a init info struct
  *              return_value    - Not used
@@ -70,27 +79,27 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_init_one_object (
 	acpi_handle                     obj_handle,
 	u32                             level,
 	void                            *context,
 	void                            **return_value)
 {
+	struct acpi_init_walk_info      *info = (struct acpi_init_walk_info *) context;
+	struct acpi_namespace_node      *node = (struct acpi_namespace_node *) obj_handle;
 	acpi_object_type                type;
 	acpi_status                     status;
-	struct acpi_init_walk_info      *info = (struct acpi_init_walk_info *) context;
 
 
 	ACPI_FUNCTION_NAME ("ds_init_one_object");
 
 
 	/*
-	 * We are only interested in objects owned by the table that
+	 * We are only interested in NS nodes owned by the table that
 	 * was just loaded
 	 */
-	if (((struct acpi_namespace_node *) obj_handle)->owner_id !=
-			info->table_desc->table_id) {
+	if (node->owner_id != info->table_desc->owner_id) {
 		return (AE_OK);
 	}
 
@@ -105,7 +114,8 @@ acpi_ds_init_one_object (
 
 		status = acpi_ds_initialize_region (obj_handle);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %p [%4.4s] - Init failure, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Region %p [%4.4s] - Init failure, %s\n",
 				obj_handle, acpi_ut_get_node_name (obj_handle),
 				acpi_format_exception (status)));
 		}
@@ -116,10 +126,10 @@ acpi_ds_init_one_object (
 
 	case ACPI_TYPE_METHOD:
 
-		info->method_count++;
-
-		/* Print a dot for each method unless we are going to print the entire pathname */
-
+		/*
+		 * Print a dot for each method unless we are going to print
+		 * the entire pathname
+		 */
 		if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
 			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
 		}
@@ -131,7 +141,7 @@ acpi_ds_init_one_object (
 		 * on a per-table basis. Currently, we just use a global for the width.
 		 */
 		if (info->table_desc->pointer->revision == 1) {
-			((struct acpi_namespace_node *) obj_handle)->flags |= ANOBJ_DATA_WIDTH_32;
+			node->flags |= ANOBJ_DATA_WIDTH_32;
 		}
 
 		/*
@@ -140,21 +150,15 @@ acpi_ds_init_one_object (
 		 */
 		status = acpi_ds_parse_method (obj_handle);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Method %p [%4.4s] - parse failure, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"\n+Method %p [%4.4s] - parse failure, %s\n",
 				obj_handle, acpi_ut_get_node_name (obj_handle),
 				acpi_format_exception (status)));
 
 			/* This parse failed, but we will continue parsing more methods */
-
-			break;
 		}
 
-		/*
-		 * Delete the parse tree.  We simply re-parse the method
-		 * for every execution since there isn't much overhead
-		 */
-		acpi_ns_delete_namespace_subtree (obj_handle);
-		acpi_ns_delete_namespace_by_owner (((struct acpi_namespace_node *) obj_handle)->object->method.owning_id);
+		info->method_count++;
 		break;
 
 
@@ -223,7 +227,7 @@ acpi_ds_initialize_objects (
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
 		"\nTable [%4.4s](id %4.4X) - %hd Objects with %hd Devices %hd Methods %hd Regions\n",
-		table_desc->pointer->signature, table_desc->table_id, info.object_count,
+		table_desc->pointer->signature, table_desc->owner_id, info.object_count,
 		info.device_count, info.method_count, info.op_region_count));
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
diff --git a/drivers/acpi/dispatcher/dsmethod.c b/drivers/acpi/dispatcher/dsmethod.c
--- a/drivers/acpi/dispatcher/dsmethod.c
+++ b/drivers/acpi/dispatcher/dsmethod.c
@@ -58,12 +58,11 @@
  *
  * FUNCTION:    acpi_ds_parse_method
  *
- * PARAMETERS:  obj_handle      - Method node
+ * PARAMETERS:  Node        - Method node
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Call the parser and parse the AML that is associated with the
- *              method.
+ * DESCRIPTION: Parse the AML that is associated with the method.
  *
  * MUTEX:       Assumes parser is locked
  *
@@ -71,31 +70,28 @@
 
 acpi_status
 acpi_ds_parse_method (
-	acpi_handle                     obj_handle)
+	struct acpi_namespace_node      *node)
 {
 	acpi_status                     status;
 	union acpi_operand_object       *obj_desc;
 	union acpi_parse_object         *op;
-	struct acpi_namespace_node      *node;
-	acpi_owner_id                   owner_id;
 	struct acpi_walk_state          *walk_state;
 
 
-	ACPI_FUNCTION_TRACE_PTR ("ds_parse_method", obj_handle);
+	ACPI_FUNCTION_TRACE_PTR ("ds_parse_method", node);
 
 
 	/* Parameter Validation */
 
-	if (!obj_handle) {
+	if (!node) {
 		return_ACPI_STATUS (AE_NULL_ENTRY);
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Parsing [%4.4s] **** named_obj=%p\n",
-		acpi_ut_get_node_name (obj_handle), obj_handle));
+		acpi_ut_get_node_name (node), node));
 
 	/* Extract the method object from the method Node */
 
-	node = (struct acpi_namespace_node *) obj_handle;
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_NULL_OBJECT);
@@ -132,14 +128,18 @@ acpi_ds_parse_method (
 	 * objects (such as Operation Regions) can be created during the
 	 * first pass parse.
 	 */
-	owner_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
-	obj_desc->method.owning_id = owner_id;
+	status = acpi_ut_allocate_owner_id (&obj_desc->method.owner_id);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (owner_id, NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (
+			  obj_desc->method.owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto cleanup2;
 	}
 
 	status = acpi_ds_init_aml_walk (walk_state, op, node,
@@ -147,28 +147,39 @@ acpi_ds_parse_method (
 			  obj_desc->method.aml_length, NULL, 1);
 	if (ACPI_FAILURE (status)) {
 		acpi_ds_delete_walk_state (walk_state);
-		return_ACPI_STATUS (status);
+		goto cleanup2;
 	}
 
 	/*
 	 * Parse the method, first pass
 	 *
-	 * The first pass load is where newly declared named objects are
-	 * added into the namespace.  Actual evaluation of
-	 * the named objects (what would be called a "second
-	 * pass") happens during the actual execution of the
-	 * method so that operands to the named objects can
-	 * take on dynamic run-time values.
+	 * The first pass load is where newly declared named objects are added into
+	 * the namespace.  Actual evaluation of the named objects (what would be
+	 * called a "second pass") happens during the actual execution of the
+	 * method so that operands to the named objects can take on dynamic
+	 * run-time values.
 	 */
 	status = acpi_ps_parse_aml (walk_state);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		goto cleanup2;
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 		"**** [%4.4s] Parsed **** named_obj=%p Op=%p\n",
-		acpi_ut_get_node_name (obj_handle), obj_handle, op));
+		acpi_ut_get_node_name (node), node, op));
+
+	/*
+	 * Delete the parse tree. We simply re-parse the method for every
+	 * execution since there isn't much overhead (compared to keeping lots
+	 * of parse trees around)
+	 */
+	acpi_ns_delete_namespace_subtree (node);
+	acpi_ns_delete_namespace_by_owner (obj_desc->method.owner_id);
+
+cleanup2:
+	acpi_ut_release_owner_id (&obj_desc->method.owner_id);
 
+cleanup:
 	acpi_ps_delete_parse_tree (op);
 	return_ACPI_STATUS (status);
 }
@@ -264,7 +275,7 @@ acpi_ds_call_control_method (
 {
 	acpi_status                     status;
 	struct acpi_namespace_node      *method_node;
-	struct acpi_walk_state          *next_walk_state;
+	struct acpi_walk_state          *next_walk_state = NULL;
 	union acpi_operand_object       *obj_desc;
 	struct acpi_parameter_info      info;
 	u32                             i;
@@ -288,20 +299,23 @@ acpi_ds_call_control_method (
 		return_ACPI_STATUS (AE_NULL_OBJECT);
 	}
 
-	obj_desc->method.owning_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
+	status = acpi_ut_allocate_owner_id (&obj_desc->method.owner_id);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Init for new method, wait on concurrency semaphore */
 
 	status = acpi_ds_begin_method_execution (method_node, obj_desc,
 			  this_walk_state->method_node);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	if (!(obj_desc->method.method_flags & AML_METHOD_INTERNAL_ONLY)) {
 		/* 1) Parse: Create a new walk state for the preempting walk */
 
-		next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
+		next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owner_id,
 				  op, obj_desc, NULL);
 		if (!next_walk_state) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
@@ -331,7 +345,7 @@ acpi_ds_call_control_method (
 
 	/* 2) Execute: Create a new state for the preempting walk */
 
-	next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
+	next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owner_id,
 			  NULL, obj_desc, thread);
 	if (!next_walk_state) {
 		status = AE_NO_MEMORY;
@@ -382,6 +396,7 @@ acpi_ds_call_control_method (
 	/* On error, we must delete the new walk state */
 
 cleanup:
+	acpi_ut_release_owner_id (&obj_desc->method.owner_id);
 	if (next_walk_state && (next_walk_state->method_desc)) {
 		/* Decrement the thread count on the method parse tree */
 
@@ -553,8 +568,7 @@ acpi_ds_terminate_control_method (
 		 */
 		if ((walk_state->method_desc->method.concurrency == 1) &&
 			(!walk_state->method_desc->method.semaphore)) {
-			status = acpi_os_create_semaphore (1,
-					 1,
+			status = acpi_os_create_semaphore (1, 1,
 					 &walk_state->method_desc->method.semaphore);
 		}
 
@@ -583,8 +597,10 @@ acpi_ds_terminate_control_method (
 		 * Delete any namespace entries created anywhere else within
 		 * the namespace
 		 */
-		acpi_ns_delete_namespace_by_owner (walk_state->method_desc->method.owning_id);
+		acpi_ns_delete_namespace_by_owner (walk_state->method_desc->method.owner_id);
 		status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		acpi_ut_release_owner_id (&walk_state->method_desc->method.owner_id);
+
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
diff --git a/drivers/acpi/dispatcher/dsmthdat.c b/drivers/acpi/dispatcher/dsmthdat.c
--- a/drivers/acpi/dispatcher/dsmthdat.c
+++ b/drivers/acpi/dispatcher/dsmthdat.c
@@ -52,6 +52,29 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsmthdat")
 
+/* Local prototypes */
+
+static void
+acpi_ds_method_data_delete_value (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+static acpi_status
+acpi_ds_method_data_set_value (
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_object_type
+acpi_ds_method_data_get_type (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+#endif
+
 
 /*******************************************************************************
  *
@@ -62,8 +85,8 @@
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the data structures that hold the method's arguments
- *              and locals.  The data struct is an array of NTEs for each.
- *              This allows ref_of and de_ref_of to work properly for these
+ *              and locals.  The data struct is an array of namespace nodes for
+ *              each - this allows ref_of and de_ref_of to work properly for these
  *              special data types.
  *
  * NOTES:       walk_state fields are initialized to zero by the
@@ -92,7 +115,8 @@ acpi_ds_method_data_init (
 		walk_state->arguments[i].name.integer |= (i << 24);
 		walk_state->arguments[i].descriptor   = ACPI_DESC_TYPE_NAMED;
 		walk_state->arguments[i].type         = ACPI_TYPE_ANY;
-		walk_state->arguments[i].flags        = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_ARG;
+		walk_state->arguments[i].flags        = ANOBJ_END_OF_PEER_LIST |
+				  ANOBJ_METHOD_ARG;
 	}
 
 	/* Init the method locals */
@@ -104,7 +128,8 @@ acpi_ds_method_data_init (
 		walk_state->local_variables[i].name.integer |= (i << 24);
 		walk_state->local_variables[i].descriptor  = ACPI_DESC_TYPE_NAMED;
 		walk_state->local_variables[i].type        = ACPI_TYPE_ANY;
-		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_LOCAL;
+		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST |
+				 ANOBJ_METHOD_LOCAL;
 	}
 
 	return_VOID;
@@ -198,15 +223,18 @@ acpi_ds_method_data_init_args (
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/* Copy passed parameters into the new method stack frame  */
+	/* Copy passed parameters into the new method stack frame */
 
-	while ((index < ACPI_METHOD_NUM_ARGS) && (index < max_param_count) && params[index]) {
+	while ((index < ACPI_METHOD_NUM_ARGS) &&
+		   (index < max_param_count)      &&
+			params[index]) {
 		/*
 		 * A valid parameter.
 		 * Store the argument in the method/walk descriptor.
 		 * Do not copy the arg in order to implement call by reference
 		 */
-		status = acpi_ds_method_data_set_value (AML_ARG_OP, index, params[index], walk_state);
+		status = acpi_ds_method_data_set_value (AML_ARG_OP, index,
+				 params[index], walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -224,11 +252,13 @@ acpi_ds_method_data_init_args (
  * FUNCTION:    acpi_ds_method_data_get_node
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument whose type
- *                                      to get
+ *              Index               - Which Local or Arg whose type to get
  *              walk_state          - Current walk state object
+ *              Node                - Where the node is returned.
  *
- * RETURN:      Get the Node associated with a local or arg.
+ * RETURN:      Status and node
+ *
+ * DESCRIPTION: Get the Node associated with a local or arg.
  *
  ******************************************************************************/
 
@@ -249,7 +279,8 @@ acpi_ds_method_data_get_node (
 	case AML_LOCAL_OP:
 
 		if (index > ACPI_METHOD_MAX_LOCAL) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Local index %d is invalid (max %d)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Local index %d is invalid (max %d)\n",
 				index, ACPI_METHOD_MAX_LOCAL));
 			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
@@ -262,7 +293,8 @@ acpi_ds_method_data_get_node (
 	case AML_ARG_OP:
 
 		if (index > ACPI_METHOD_MAX_ARG) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Arg index %d is invalid (max %d)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Arg index %d is invalid (max %d)\n",
 				index, ACPI_METHOD_MAX_ARG));
 			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
@@ -286,7 +318,7 @@ acpi_ds_method_data_get_node (
  * FUNCTION:    acpi_ds_method_data_set_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument to get
+ *              Index               - Which Local or Arg to get
  *              Object              - Object to be inserted into the stack entry
  *              walk_state          - Current walk state object
  *
@@ -297,7 +329,7 @@ acpi_ds_method_data_get_node (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_method_data_set_value (
 	u16                             opcode,
 	u32                             index,
@@ -340,68 +372,16 @@ acpi_ds_method_data_set_value (
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_method_data_get_type
- *
- * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument whose type
- *                                      to get
- *              walk_state          - Current walk state object
- *
- * RETURN:      Data type of current value of the selected Arg or Local
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_object_type
-acpi_ds_method_data_get_type (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-	acpi_status                     status;
-	struct acpi_namespace_node      *node;
-	union acpi_operand_object       *object;
-
-
-	ACPI_FUNCTION_TRACE ("ds_method_data_get_type");
-
-
-	/* Get the namespace node for the arg/local */
-
-	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
-	if (ACPI_FAILURE (status)) {
-		return_VALUE ((ACPI_TYPE_NOT_FOUND));
-	}
-
-	/* Get the object */
-
-	object = acpi_ns_get_attached_object (node);
-	if (!object) {
-		/* Uninitialized local/arg, return TYPE_ANY */
-
-		return_VALUE (ACPI_TYPE_ANY);
-	}
-
-	/* Get the object type */
-
-	return_VALUE (ACPI_GET_OBJECT_TYPE (object));
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_method_data_get_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
  *              Index               - which local_var or argument to get
  *              walk_state          - Current walk state object
- *              *dest_desc          - Ptr to Descriptor into which selected Arg
- *                                    or Local value should be copied
+ *              dest_desc           - Where Arg or Local value is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieve value of selected Arg or Local from the method frame
- *              at the current top of the method stack.
+ * DESCRIPTION: Retrieve value of selected Arg or Local for this method
  *              Used only in acpi_ex_resolve_to_value().
  *
  ******************************************************************************/
@@ -467,14 +447,16 @@ acpi_ds_method_data_get_value (
 		else switch (opcode) {
 		case AML_ARG_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Arg[%d] at node %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Uninitialized Arg[%d] at node %p\n",
 				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_ARG);
 
 		case AML_LOCAL_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Local[%d] at node %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Uninitialized Local[%d] at node %p\n",
 				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_LOCAL);
@@ -506,12 +488,12 @@ acpi_ds_method_data_get_value (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Delete the entry at Opcode:Index on the method stack.  Inserts
+ * DESCRIPTION: Delete the entry at Opcode:Index.  Inserts
  *              a null into the stack slot after the object is deleted.
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ds_method_data_delete_value (
 	u16                             opcode,
 	u32                             index,
@@ -562,7 +544,7 @@ acpi_ds_method_data_delete_value (
  * FUNCTION:    acpi_ds_store_object_to_local
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - which local_var or argument to set
+ *              Index               - Which Local or Arg to set
  *              obj_desc            - Value to be stored
  *              walk_state          - Current walk state
  *
@@ -651,21 +633,11 @@ acpi_ds_store_object_to_local (
 		 */
 		if (opcode == AML_ARG_OP) {
 			/*
-			 * Make sure that the object is the correct type.  This may be overkill, but
-			 * it is here because references were NS nodes in the past.  Now they are
-			 * operand objects of type Reference.
+			 * If we have a valid reference object that came from ref_of(),
+			 * do the indirect store
 			 */
-			if (ACPI_GET_DESCRIPTOR_TYPE (current_obj_desc) != ACPI_DESC_TYPE_OPERAND) {
-				ACPI_REPORT_ERROR (("Invalid descriptor type while storing to method arg: [%s]\n",
-						acpi_ut_get_descriptor_name (current_obj_desc)));
-				return_ACPI_STATUS (AE_AML_INTERNAL);
-			}
-
-			/*
-			 * If we have a valid reference object that came from ref_of(), do the
-			 * indirect store
-			 */
-			if ((current_obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) &&
+			if ((ACPI_GET_DESCRIPTOR_TYPE (current_obj_desc) == ACPI_DESC_TYPE_OPERAND) &&
+				(current_obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) &&
 				(current_obj_desc->reference.opcode == AML_REF_OF_OP)) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 						"Arg (%p) is an obj_ref(Node), storing in node %p\n",
@@ -713,3 +685,55 @@ acpi_ds_store_object_to_local (
 }
 
 
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_get_type
+ *
+ * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
+ *              Index               - Which Local or Arg whose type to get
+ *              walk_state          - Current walk state object
+ *
+ * RETURN:      Data type of current value of the selected Arg or Local
+ *
+ * DESCRIPTION: Get the type of the object stored in the Local or Arg
+ *
+ ******************************************************************************/
+
+acpi_object_type
+acpi_ds_method_data_get_type (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *object;
+
+
+	ACPI_FUNCTION_TRACE ("ds_method_data_get_type");
+
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
+	if (ACPI_FAILURE (status)) {
+		return_VALUE ((ACPI_TYPE_NOT_FOUND));
+	}
+
+	/* Get the object */
+
+	object = acpi_ns_get_attached_object (node);
+	if (!object) {
+		/* Uninitialized local/arg, return TYPE_ANY */
+
+		return_VALUE (ACPI_TYPE_ANY);
+	}
+
+	/* Get the object type */
+
+	return_VALUE (ACPI_GET_OBJECT_TYPE (object));
+}
+#endif
+
+
diff --git a/drivers/acpi/dispatcher/dsobject.c b/drivers/acpi/dispatcher/dsobject.c
--- a/drivers/acpi/dispatcher/dsobject.c
+++ b/drivers/acpi/dispatcher/dsobject.c
@@ -52,9 +52,15 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsobject")
 
+static acpi_status
+acpi_ds_build_internal_object (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       **obj_desc_ptr);
+
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_object
  *
@@ -67,9 +73,9 @@
  * DESCRIPTION: Translate a parser Op object to the equivalent namespace object
  *              Simple objects are any objects other than a package object!
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_build_internal_object (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op,
@@ -90,9 +96,11 @@ acpi_ds_build_internal_object (
 		 * Otherwise, go ahead and look it up now
 		 */
 		if (!op->common.node) {
-			status = acpi_ns_lookup (walk_state->scope_info, op->common.value.string,
+			status = acpi_ns_lookup (walk_state->scope_info,
+					  op->common.value.string,
 					  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
+					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+					  NULL,
 					  (struct acpi_namespace_node **) &(op->common.node));
 
 			if (ACPI_FAILURE (status)) {
@@ -104,12 +112,14 @@ acpi_ds_build_internal_object (
 
 	/* Create and init the internal ACPI object */
 
-	obj_desc = acpi_ut_create_internal_object ((acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
+	obj_desc = acpi_ut_create_internal_object (
+			 (acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode, &obj_desc);
+	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode,
+			 &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_remove_reference (obj_desc);
 		return_ACPI_STATUS (status);
@@ -120,7 +130,7 @@ acpi_ds_build_internal_object (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_buffer_obj
  *
@@ -134,7 +144,7 @@ acpi_ds_build_internal_object (
  * DESCRIPTION: Translate a parser Op package object to the equivalent
  *              namespace object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_build_internal_buffer_obj (
@@ -229,7 +239,7 @@ acpi_ds_build_internal_buffer_obj (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_build_internal_package_obj
  *
@@ -243,7 +253,7 @@ acpi_ds_build_internal_buffer_obj (
  * DESCRIPTION: Translate a parser Op package object to the equivalent
  *              namespace object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_build_internal_package_obj (
@@ -331,11 +341,12 @@ acpi_ds_build_internal_package_obj (
 		if (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
 			/* Object (package or buffer) is already built */
 
-			obj_desc->package.elements[i] = ACPI_CAST_PTR (union acpi_operand_object, arg->common.node);
+			obj_desc->package.elements[i] =
+				ACPI_CAST_PTR (union acpi_operand_object, arg->common.node);
 		}
 		else {
 			status = acpi_ds_build_internal_object (walk_state, arg,
-					  &obj_desc->package.elements[i]);
+					 &obj_desc->package.elements[i]);
 		}
 
 		i++;
@@ -348,7 +359,7 @@ acpi_ds_build_internal_package_obj (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_create_node
  *
@@ -360,7 +371,7 @@ acpi_ds_build_internal_package_obj (
  *
  * DESCRIPTION: Create the object to be associated with a namespace node
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_create_node (
@@ -392,7 +403,8 @@ acpi_ds_create_node (
 
 	/* Build an internal object for the argument(s) */
 
-	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg, &obj_desc);
+	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg,
+			 &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -414,7 +426,7 @@ acpi_ds_create_node (
 #endif /* ACPI_NO_METHOD_EXECUTION */
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_object_from_op
  *
@@ -429,7 +441,7 @@ acpi_ds_create_node (
  *              associated arguments.  The namespace object is a more compact
  *              representation of the Op and its arguments.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_init_object_from_op (
@@ -462,7 +474,8 @@ acpi_ds_init_object_from_op (
 		/*
 		 * Defer evaluation of Buffer term_arg operand
 		 */
-		obj_desc->buffer.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->buffer.node     = (struct acpi_namespace_node *)
+				   walk_state->operands[0];
 		obj_desc->buffer.aml_start = op->named.data;
 		obj_desc->buffer.aml_length = op->named.length;
 		break;
@@ -473,7 +486,8 @@ acpi_ds_init_object_from_op (
 		/*
 		 * Defer evaluation of Package term_arg operand
 		 */
-		obj_desc->package.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->package.node     = (struct acpi_namespace_node *)
+				   walk_state->operands[0];
 		obj_desc->package.aml_start = op->named.data;
 		obj_desc->package.aml_length = op->named.length;
 		break;
@@ -486,9 +500,10 @@ acpi_ds_init_object_from_op (
 			/*
 			 * Resolve AML Constants here - AND ONLY HERE!
 			 * All constants are integers.
-			 * We mark the integer with a flag that indicates that it started life
-			 * as a constant -- so that stores to constants will perform as expected (noop).
-			 * (zero_op is used as a placeholder for optional target operands.)
+			 * We mark the integer with a flag that indicates that it started
+			 * life as a constant -- so that stores to constants will perform
+			 * as expected (noop). zero_op is used as a placeholder for optional
+			 * target operands.
 			 */
 			obj_desc->common.flags = AOPOBJ_AML_CONSTANT;
 
@@ -521,7 +536,8 @@ acpi_ds_init_object_from_op (
 
 			default:
 
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown constant opcode %X\n", opcode));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Unknown constant opcode %X\n", opcode));
 				status = AE_AML_OPERAND_TYPE;
 				break;
 			}
@@ -531,11 +547,15 @@ acpi_ds_init_object_from_op (
 		case AML_TYPE_LITERAL:
 
 			obj_desc->integer.value = op->common.value.integer;
+#ifndef ACPI_NO_METHOD_EXECUTION
+			acpi_ex_truncate_for32bit_table (obj_desc);
+#endif
 			break;
 
 
 		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Integer type %X\n", op_info->type));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Integer type %X\n",
+				op_info->type));
 			status = AE_AML_OPERAND_TYPE;
 			break;
 		}
@@ -570,8 +590,10 @@ acpi_ds_init_object_from_op (
 			obj_desc->reference.offset = opcode - AML_LOCAL_OP;
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-			status = acpi_ds_method_data_get_node (AML_LOCAL_OP, obj_desc->reference.offset,
-					 walk_state, (struct acpi_namespace_node **) &obj_desc->reference.object);
+			status = acpi_ds_method_data_get_node (AML_LOCAL_OP,
+					 obj_desc->reference.offset,
+					 walk_state,
+					 (struct acpi_namespace_node **) &obj_desc->reference.object);
 #endif
 			break;
 
@@ -584,8 +606,10 @@ acpi_ds_init_object_from_op (
 			obj_desc->reference.offset = opcode - AML_ARG_OP;
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-			status = acpi_ds_method_data_get_node (AML_ARG_OP, obj_desc->reference.offset,
-					 walk_state, (struct acpi_namespace_node **) &obj_desc->reference.object);
+			status = acpi_ds_method_data_get_node (AML_ARG_OP,
+					 obj_desc->reference.offset,
+					 walk_state,
+					 (struct acpi_namespace_node **) &obj_desc->reference.object);
 #endif
 			break;
 
diff --git a/drivers/acpi/dispatcher/dsopcode.c b/drivers/acpi/dispatcher/dsopcode.c
--- a/drivers/acpi/dispatcher/dsopcode.c
+++ b/drivers/acpi/dispatcher/dsopcode.c
@@ -54,12 +54,31 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsopcode")
 
+/* Local prototypes */
 
-/*****************************************************************************
+static acpi_status
+acpi_ds_execute_arguments (
+	struct acpi_namespace_node      *node,
+	struct acpi_namespace_node      *scope_node,
+	u32                             aml_length,
+	u8                              *aml_start);
+
+static acpi_status
+acpi_ds_init_buffer_field (
+	u16                             aml_opcode,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *buffer_desc,
+	union acpi_operand_object       *offset_desc,
+	union acpi_operand_object       *length_desc,
+	union acpi_operand_object       *result_desc);
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_execute_arguments
  *
- * PARAMETERS:  Node                - Parent NS node
+ * PARAMETERS:  Node                - Object NS node
+ *              scope_node          - Parent NS node
  *              aml_length          - Length of executable AML
  *              aml_start           - Pointer to the AML
  *
@@ -67,9 +86,9 @@
  *
  * DESCRIPTION: Late (deferred) execution of region or field arguments
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_execute_arguments (
 	struct acpi_namespace_node      *node,
 	struct acpi_namespace_node      *scope_node,
@@ -100,14 +119,15 @@ acpi_ds_execute_arguments (
 
 	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
 	if (!walk_state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto cleanup;
 	}
 
 	status = acpi_ds_init_aml_walk (walk_state, op, NULL, aml_start,
 			  aml_length, NULL, 1);
 	if (ACPI_FAILURE (status)) {
 		acpi_ds_delete_walk_state (walk_state);
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	/* Mark this parse as a deferred opcode */
@@ -119,8 +139,7 @@ acpi_ds_execute_arguments (
 
 	status = acpi_ps_parse_aml (walk_state);
 	if (ACPI_FAILURE (status)) {
-		acpi_ps_delete_parse_tree (op);
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	/* Get and init the Op created above */
@@ -141,7 +160,8 @@ acpi_ds_execute_arguments (
 
 	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
 	if (!walk_state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		status = AE_NO_MEMORY;
+		goto cleanup;
 	}
 
 	/* Execute the opcode and arguments */
@@ -150,19 +170,21 @@ acpi_ds_execute_arguments (
 			  aml_length, NULL, 3);
 	if (ACPI_FAILURE (status)) {
 		acpi_ds_delete_walk_state (walk_state);
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	/* Mark this execution as a deferred opcode */
 
 	walk_state->deferred_node = node;
 	status = acpi_ps_parse_aml (walk_state);
+
+cleanup:
 	acpi_ps_delete_parse_tree (op);
 	return_ACPI_STATUS (status);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_buffer_field_arguments
  *
@@ -173,7 +195,7 @@ acpi_ds_execute_arguments (
  * DESCRIPTION: Get buffer_field Buffer and Index. This implements the late
  *              evaluation of these field attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_buffer_field_arguments (
@@ -208,7 +230,7 @@ acpi_ds_get_buffer_field_arguments (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_buffer_arguments
  *
@@ -219,7 +241,7 @@ acpi_ds_get_buffer_field_arguments (
  * DESCRIPTION: Get Buffer length and initializer byte list.  This implements
  *              the late evaluation of these attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_buffer_arguments (
@@ -255,7 +277,7 @@ acpi_ds_get_buffer_arguments (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_get_package_arguments
  *
@@ -266,7 +288,7 @@ acpi_ds_get_buffer_arguments (
  * DESCRIPTION: Get Package length and initializer byte list.  This implements
  *              the late evaluation of these attributes.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_get_package_arguments (
@@ -353,17 +375,17 @@ acpi_ds_get_region_arguments (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_initialize_region
  *
- * PARAMETERS:  Op              - A valid region Op object
+ * PARAMETERS:  obj_handle      - Region namespace node
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Front end to ev_initialize_region
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_initialize_region (
@@ -382,7 +404,7 @@ acpi_ds_initialize_region (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_init_buffer_field
  *
@@ -390,16 +412,16 @@ acpi_ds_initialize_region (
  *              obj_desc        - buffer_field object
  *              buffer_desc     - Host Buffer
  *              offset_desc     - Offset into buffer
- *              Length          - Length of field (CREATE_FIELD_OP only)
- *              Result          - Where to store the result
+ *              length_desc     - Length of field (CREATE_FIELD_OP only)
+ *              result_desc     - Where to store the result
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Perform actual initialization of a buffer field
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ds_init_buffer_field (
 	u16                             aml_opcode,
 	union acpi_operand_object       *obj_desc,
@@ -435,8 +457,10 @@ acpi_ds_init_buffer_field (
 	 * after resolution in acpi_ex_resolve_operands().
 	 */
 	if (ACPI_GET_DESCRIPTOR_TYPE (result_desc) != ACPI_DESC_TYPE_NAMED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) destination not a NS Node [%s]\n",
-				acpi_ps_get_opcode_name (aml_opcode), acpi_ut_get_descriptor_name (result_desc)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(%s) destination not a NS Node [%s]\n",
+				acpi_ps_get_opcode_name (aml_opcode),
+				acpi_ut_get_descriptor_name (result_desc)));
 
 		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
@@ -452,9 +476,18 @@ acpi_ds_init_buffer_field (
 
 		/* Offset is in bits, count is in bits */
 
+		field_flags = AML_FIELD_ACCESS_BYTE;
 		bit_offset = offset;
 		bit_count  = (u32) length_desc->integer.value;
-		field_flags = AML_FIELD_ACCESS_BYTE;
+
+		/* Must have a valid (>0) bit count */
+
+		if (bit_count == 0) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Attempt to create_field of length 0\n"));
+			status = AE_AML_OPERAND_VALUE;
+			goto cleanup;
+		}
 		break;
 
 	case AML_CREATE_BIT_FIELD_OP:
@@ -527,7 +560,8 @@ acpi_ds_init_buffer_field (
 
 	/*
 	 * Initialize areas of the field object that are common to all fields
-	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
+	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK),
+	 * UPDATE_RULE = 0 (UPDATE_PRESERVE)
 	 */
 	status = acpi_ex_prep_common_field_object (obj_desc, field_flags, 0,
 			  bit_offset, bit_count);
@@ -539,8 +573,8 @@ acpi_ds_init_buffer_field (
 
 	/* Reference count for buffer_desc inherits obj_desc count */
 
-	buffer_desc->common.reference_count = (u16) (buffer_desc->common.reference_count +
-			  obj_desc->common.reference_count);
+	buffer_desc->common.reference_count = (u16)
+		(buffer_desc->common.reference_count + obj_desc->common.reference_count);
 
 
 cleanup:
@@ -569,7 +603,7 @@ cleanup:
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_buffer_field_operands
  *
@@ -581,7 +615,7 @@ cleanup:
  * DESCRIPTION: Get buffer_field Buffer and Index
  *              Called from acpi_ds_exec_end_op during buffer_field parse tree walk
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_buffer_field_operands (
@@ -656,7 +690,7 @@ acpi_ds_eval_buffer_field_operands (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_region_operands
  *
@@ -668,7 +702,7 @@ acpi_ds_eval_buffer_field_operands (
  * DESCRIPTION: Get region address and length
  *              Called from acpi_ds_exec_end_op during op_region parse tree walk
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_region_operands (
@@ -686,7 +720,8 @@ acpi_ds_eval_region_operands (
 
 
 	/*
-	 * This is where we evaluate the address and length fields of the op_region declaration
+	 * This is where we evaluate the address and length fields of the
+	 * op_region declaration
 	 */
 	node =  op->common.node;
 
@@ -707,7 +742,8 @@ acpi_ds_eval_region_operands (
 
 	/* Resolve the length and address operands to numbers */
 
-	status = acpi_ex_resolve_operands (op->common.aml_opcode, ACPI_WALK_OPERANDS, walk_state);
+	status = acpi_ex_resolve_operands (op->common.aml_opcode,
+			 ACPI_WALK_OPERANDS, walk_state);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -736,7 +772,8 @@ acpi_ds_eval_region_operands (
 	 */
 	operand_desc = walk_state->operands[walk_state->num_operands - 2];
 
-	obj_desc->region.address = (acpi_physical_address) operand_desc->integer.value;
+	obj_desc->region.address = (acpi_physical_address)
+			  operand_desc->integer.value;
 	acpi_ut_remove_reference (operand_desc);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "rgn_obj %p Addr %8.8X%8.8X Len %X\n",
@@ -752,7 +789,7 @@ acpi_ds_eval_region_operands (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ds_eval_data_object_operands
  *
@@ -765,7 +802,7 @@ acpi_ds_eval_region_operands (
  * DESCRIPTION: Get the operands and complete the following data object types:
  *              Buffer, Package.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ds_eval_data_object_operands (
@@ -830,7 +867,7 @@ acpi_ds_eval_data_object_operands (
 
 	if (ACPI_SUCCESS (status)) {
 		/*
-		 * Return the object in the walk_state, unless the parent is a package --
+		 * Return the object in the walk_state, unless the parent is a package -
 		 * in this case, the return object will be stored in the parse tree
 		 * for the package.
 		 */
@@ -988,7 +1025,8 @@ acpi_ds_exec_end_control_op (
 			status = AE_CTRL_PENDING;
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[WHILE_OP] termination! Op=%p\n", op));
+		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+			"[WHILE_OP] termination! Op=%p\n",op));
 
 		/* Pop this control state and free it */
 
diff --git a/drivers/acpi/dispatcher/dsutils.c b/drivers/acpi/dispatcher/dsutils.c
--- a/drivers/acpi/dispatcher/dsutils.c
+++ b/drivers/acpi/dispatcher/dsutils.c
@@ -100,7 +100,6 @@ acpi_ds_clear_implicit_return (
 
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_do_implicit_return
@@ -205,7 +204,7 @@ acpi_ds_is_result_used (
 	 * NOTE: this is optional because the ASL language does not actually
 	 * support this behavior.
 	 */
-	acpi_ds_do_implicit_return (walk_state->result_obj, walk_state, TRUE);
+	(void) acpi_ds_do_implicit_return (walk_state->result_obj, walk_state, TRUE);
 
 	/*
 	 * Now determine if the parent will use the result
@@ -219,8 +218,9 @@ acpi_ds_is_result_used (
 		(op->common.parent->common.aml_opcode == AML_SCOPE_OP)) {
 		/* No parent, the return value cannot possibly be used */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "At Method level, result of [%s] not used\n",
-				acpi_ps_get_opcode_name (op->common.aml_opcode)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+			"At Method level, result of [%s] not used\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode)));
 		return_VALUE (FALSE);
 	}
 
@@ -228,7 +228,8 @@ acpi_ds_is_result_used (
 
 	parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 	if (parent_info->class == AML_CLASS_UNKNOWN) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown parent opcode. Op=%p\n", op));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown parent opcode. Op=%p\n", op));
 		return_VALUE (FALSE);
 	}
 
@@ -309,17 +310,19 @@ acpi_ds_is_result_used (
 
 
 result_used:
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->common.aml_opcode),
-			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Result of [%s] used by Parent [%s] Op=%p\n",
+		acpi_ps_get_opcode_name (op->common.aml_opcode),
+		acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (TRUE);
 
 
 result_not_used:
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] not used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->common.aml_opcode),
-			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Result of [%s] not used by Parent [%s] Op=%p\n",
+		acpi_ps_get_opcode_name (op->common.aml_opcode),
+		acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (FALSE);
 }
@@ -522,7 +525,8 @@ acpi_ds_create_operand (
 		if ((walk_state->deferred_node) &&
 			(walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD) &&
 			(arg_index != 0)) {
-			obj_desc = ACPI_CAST_PTR (union acpi_operand_object, walk_state->deferred_node);
+			obj_desc = ACPI_CAST_PTR (
+					 union acpi_operand_object, walk_state->deferred_node);
 			status = AE_OK;
 		}
 		else    /* All other opcodes */ {
@@ -565,7 +569,8 @@ acpi_ds_create_operand (
 					 * indicate this to the interpreter, set the
 					 * object to the root
 					 */
-					obj_desc = ACPI_CAST_PTR (union acpi_operand_object, acpi_gbl_root_node);
+					obj_desc = ACPI_CAST_PTR (
+							 union acpi_operand_object, acpi_gbl_root_node);
 					status = AE_OK;
 				}
 				else {
@@ -612,7 +617,8 @@ acpi_ds_create_operand (
 			 */
 			opcode = AML_ZERO_OP;       /* Has no arguments! */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Null namepath: Arg=%p\n", arg));
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"Null namepath: Arg=%p\n", arg));
 		}
 		else {
 			opcode = arg->common.aml_opcode;
@@ -642,7 +648,8 @@ acpi_ds_create_operand (
 				 * Only error is underflow, and this indicates
 				 * a missing or null operand!
 				 */
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Missing or null operand, %s\n",
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Missing or null operand, %s\n",
 					acpi_format_exception (status)));
 				return_ACPI_STATUS (status);
 			}
@@ -657,8 +664,8 @@ acpi_ds_create_operand (
 
 			/* Initialize the new object */
 
-			status = acpi_ds_init_object_from_op (walk_state, arg,
-					 opcode, &obj_desc);
+			status = acpi_ds_init_object_from_op (
+					 walk_state, arg, opcode, &obj_desc);
 			if (ACPI_FAILURE (status)) {
 				acpi_ut_delete_object_desc (obj_desc);
 				return_ACPI_STATUS (status);
diff --git a/drivers/acpi/dispatcher/dswexec.c b/drivers/acpi/dispatcher/dswexec.c
--- a/drivers/acpi/dispatcher/dswexec.c
+++ b/drivers/acpi/dispatcher/dswexec.c
@@ -73,11 +73,13 @@ static ACPI_EXECUTE_OP      acpi_gbl_op_
 			  acpi_ex_opcode_3A_1T_1R,
 			  acpi_ex_opcode_6A_0T_1R};
 
+
 /*****************************************************************************
  *
  * FUNCTION:    acpi_ds_get_predicate_value
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              result_obj      - if non-zero, pop result from result stack
  *
  * RETURN:      Status
  *
@@ -124,7 +126,8 @@ acpi_ds_get_predicate_value (
 	}
 
 	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No predicate obj_desc=%p State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"No predicate obj_desc=%p State=%p\n",
 			obj_desc, walk_state));
 
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
@@ -197,7 +200,7 @@ cleanup:
  * FUNCTION:    acpi_ds_exec_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              out_op          - Return op if a new one is created
+ *              out_op          - Where to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -233,7 +236,8 @@ acpi_ds_exec_begin_op (
 		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 
 		if (acpi_ns_opens_scope (walk_state->op_info->object_type)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"(%s) Popping scope for Op %p\n",
 				acpi_ut_get_type_name (walk_state->op_info->object_type), op));
 
 			status = acpi_ds_scope_stack_pop (walk_state);
@@ -297,11 +301,10 @@ acpi_ds_exec_begin_op (
 
 		if (walk_state->walk_type == ACPI_WALK_METHOD) {
 			/*
-			 * Found a named object declaration during method
-			 * execution;  we must enter this object into the
-			 * namespace.  The created object is temporary and
-			 * will be deleted upon completion of the execution
-			 * of this method.
+			 * Found a named object declaration during method execution;
+			 * we must enter this object into the namespace.  The created
+			 * object is temporary and will be deleted upon completion of
+			 * the execution of this method.
 			 */
 			status = acpi_ds_load2_begin_op (walk_state, NULL);
 		}
@@ -338,8 +341,6 @@ acpi_ds_exec_begin_op (
  * FUNCTION:    acpi_ds_exec_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -389,7 +390,7 @@ acpi_ds_exec_end_op (
 	/* Decode the Opcode Class */
 
 	switch (op_class) {
-	case AML_CLASS_ARGUMENT:    /* constants, literals, etc. -- do nothing */
+	case AML_CLASS_ARGUMENT:    /* constants, literals, etc. - do nothing */
 		break;
 
 
@@ -417,12 +418,12 @@ acpi_ds_exec_end_op (
 			/* Resolve all operands */
 
 			status = acpi_ex_resolve_operands (walk_state->opcode,
-					  &(walk_state->operands [walk_state->num_operands -1]),
-					  walk_state);
+					 &(walk_state->operands [walk_state->num_operands -1]),
+					 walk_state);
 			if (ACPI_SUCCESS (status)) {
 				ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
-						  acpi_ps_get_opcode_name (walk_state->opcode),
-						  walk_state->num_operands, "after ex_resolve_operands");
+					acpi_ps_get_opcode_name (walk_state->opcode),
+					walk_state->num_operands, "after ex_resolve_operands");
 			}
 		}
 
@@ -506,7 +507,8 @@ acpi_ds_exec_end_op (
 			if ((op->asl.parent) &&
 			   ((op->asl.parent->asl.aml_opcode == AML_PACKAGE_OP) ||
 				(op->asl.parent->asl.aml_opcode == AML_VAR_PACKAGE_OP))) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Method Reference in a Package, Op=%p\n", op));
+				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+					"Method Reference in a Package, Op=%p\n", op));
 				op->common.node = (struct acpi_namespace_node *) op->asl.value.arg->asl.node->object;
 				acpi_ut_add_reference (op->asl.value.arg->asl.node->object);
 				return_ACPI_STATUS (AE_OK);
@@ -583,13 +585,15 @@ acpi_ds_exec_end_op (
 			case AML_NAME_OP:
 
 				/*
-				 * Put the Node on the object stack (Contains the ACPI Name of
-				 * this object)
+				 * Put the Node on the object stack (Contains the ACPI Name
+				 * of this object)
 				 */
 				walk_state->operands[0] = (void *) op->common.parent->common.node;
 				walk_state->num_operands = 1;
 
-				status = acpi_ds_create_node (walk_state, op->common.parent->common.node, op->common.parent);
+				status = acpi_ds_create_node (walk_state,
+						 op->common.parent->common.node,
+						 op->common.parent);
 				if (ACPI_FAILURE (status)) {
 					break;
 				}
@@ -600,7 +604,7 @@ acpi_ds_exec_end_op (
 			case AML_INT_EVAL_SUBTREE_OP:
 
 				status = acpi_ds_eval_data_object_operands (walk_state, op,
-						  acpi_ns_get_attached_object (op->common.parent->common.node));
+						 acpi_ns_get_attached_object (op->common.parent->common.node));
 				break;
 
 			default:
@@ -609,7 +613,7 @@ acpi_ds_exec_end_op (
 				break;
 			}
 
-			/* Done with this result state (Now that operand stack is built) */
+			/* Done with result state (Now that operand stack is built) */
 
 			status = acpi_ds_result_stack_pop (walk_state);
 			if (ACPI_FAILURE (status)) {
@@ -620,8 +624,7 @@ acpi_ds_exec_end_op (
 			 * If a result object was returned from above, push it on the
 			 * current result stack
 			 */
-			if (ACPI_SUCCESS (status) &&
-				walk_state->result_obj) {
+			if (walk_state->result_obj) {
 				status = acpi_ds_result_push (walk_state->result_obj, walk_state);
 			}
 			break;
@@ -654,7 +657,8 @@ acpi_ds_exec_end_op (
 
 		case AML_TYPE_UNDEFINED:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Undefined opcode type Op=%p\n", op));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Undefined opcode type Op=%p\n", op));
 			return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 
 
@@ -709,13 +713,14 @@ cleanup:
 		status = acpi_gbl_exception_handler (status,
 				 walk_state->method_node->name.integer, walk_state->opcode,
 				 walk_state->aml_offset, NULL);
-		acpi_ex_enter_interpreter ();
+		(void) acpi_ex_enter_interpreter ();
 	}
 
 	if (walk_state->result_obj) {
 		/* Break to debugger to display result */
 
-		ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj, walk_state));
+		ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj,
+				 walk_state));
 
 		/*
 		 * Delete the result op if and only if:
diff --git a/drivers/acpi/dispatcher/dswload.c b/drivers/acpi/dispatcher/dswload.c
--- a/drivers/acpi/dispatcher/dswload.c
+++ b/drivers/acpi/dispatcher/dswload.c
@@ -50,7 +50,7 @@
 #include <acpi/acnamesp.h>
 #include <acpi/acevents.h>
 
-#ifdef _ACPI_ASL_COMPILER
+#ifdef ACPI_ASL_COMPILER
 #include <acpi/acdisasm.h>
 #endif
 
@@ -79,20 +79,23 @@ acpi_ds_init_callbacks (
 
 	switch (pass_number) {
 	case 1:
-		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_load1_begin_op;
 		walk_state->ascending_callback = acpi_ds_load1_end_op;
 		break;
 
 	case 2:
-		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags       = ACPI_PARSE_LOAD_PASS1 |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_load2_begin_op;
 		walk_state->ascending_callback = acpi_ds_load2_end_op;
 		break;
 
 	case 3:
 #ifndef ACPI_NO_METHOD_EXECUTION
-		walk_state->parse_flags      |= ACPI_PARSE_EXECUTE  | ACPI_PARSE_DELETE_TREE;
+		walk_state->parse_flags      |= ACPI_PARSE_EXECUTE  |
+				   ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_exec_begin_op;
 		walk_state->ascending_callback = acpi_ds_exec_end_op;
 #endif
@@ -111,8 +114,7 @@ acpi_ds_init_callbacks (
  * FUNCTION:    acpi_ds_load1_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been reached in the
- *                                walk;  Arguments have not been evaluated yet.
+ *              out_op          - Where to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -143,14 +145,6 @@ acpi_ds_load1_begin_op (
 
 	if (op) {
 		if (!(walk_state->op_info->flags & AML_NAMED)) {
-#if 0
-			if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
-				(walk_state->op_info->class == AML_CLASS_CONTROL)) {
-				acpi_os_printf ("\n\n***EXECUTABLE OPCODE %s***\n\n", walk_state->op_info->name);
-				*out_op = op;
-				return (AE_CTRL_SKIP);
-			}
-#endif
 			*out_op = op;
 			return (AE_OK);
 		}
@@ -182,7 +176,7 @@ acpi_ds_load1_begin_op (
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
 				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
-#ifdef _ACPI_ASL_COMPILER
+#ifdef ACPI_ASL_COMPILER
 		if (status == AE_NOT_FOUND) {
 			/*
 			 * Table disassembly:
@@ -191,7 +185,8 @@ acpi_ds_load1_begin_op (
 			 */
 			acpi_dm_add_to_external_list (path);
 			status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
-					   ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+					   ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,
+					   walk_state, &(node));
 		}
 #endif
 		if (ACPI_FAILURE (status)) {
@@ -224,10 +219,12 @@ acpi_ds_load1_begin_op (
 			 *  Name (DEB, 0)
 			 *  Scope (DEB) { ... }
 			 *
-			 * Note: silently change the type here.  On the second pass, we will report a warning
+			 * Note: silently change the type here.  On the second pass, we will report
+			 * a warning
 			 */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+				"Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
 				path, acpi_ut_get_type_name (node->type)));
 
 			node->type = ACPI_TYPE_ANY;
@@ -238,7 +235,8 @@ acpi_ds_load1_begin_op (
 
 			/* All other types are an error */
 
-			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s] (Cannot override)\n",
+			ACPI_REPORT_ERROR ((
+				"Invalid type (%s) for target of Scope operator [%4.4s] (Cannot override)\n",
 				acpi_ut_get_type_name (node->type), path));
 
 			return (AE_AML_OPERAND_TYPE);
@@ -249,7 +247,8 @@ acpi_ds_load1_begin_op (
 	default:
 
 		/*
-		 * For all other named opcodes, we will enter the name into the namespace.
+		 * For all other named opcodes, we will enter the name into
+		 * the namespace.
 		 *
 		 * Setup the search flags.
 		 * Since we are entering a name into the namespace, we do not want to
@@ -279,14 +278,16 @@ acpi_ds_load1_begin_op (
 					acpi_ut_get_type_name (object_type)));
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[%s] Both Find or Create allowed\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"[%s] Both Find or Create allowed\n",
 					acpi_ut_get_type_name (object_type)));
 		}
 
 		/*
 		 * Enter the named type into the internal namespace.  We enter the name
-		 * as we go downward in the parse tree.  Any necessary subobjects that involve
-		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 * as we go downward in the parse tree.  Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
 				  ACPI_IMODE_LOAD_PASS1, flags, walk_state, &(node));
@@ -335,8 +336,6 @@ acpi_ds_load1_begin_op (
  * FUNCTION:    acpi_ds_load1_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -383,7 +382,9 @@ acpi_ds_load1_end_op (
 
 	if (op->common.aml_opcode == AML_REGION_OP) {
 		status = acpi_ex_create_region (op->named.data, op->named.length,
-				   (acpi_adr_space_type) ((op->common.value.arg)->common.value.integer), walk_state);
+				   (acpi_adr_space_type)
+						 ((op->common.value.arg)->common.value.integer),
+						 walk_state);
 		if (ACPI_FAILURE (status)) {
 			return (status);
 		}
@@ -394,7 +395,8 @@ acpi_ds_load1_end_op (
 		/* For Name opcode, get the object type from the argument */
 
 		if (op->common.value.arg) {
-			object_type = (acpi_ps_get_opcode_info ((op->common.value.arg)->common.aml_opcode))->object_type;
+			object_type = (acpi_ps_get_opcode_info (
+				(op->common.value.arg)->common.aml_opcode))->object_type;
 			op->common.node->type = (u8) object_type;
 		}
 	}
@@ -448,8 +450,7 @@ acpi_ds_load1_end_op (
  * FUNCTION:    acpi_ds_load2_begin_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been reached in the
- *                                walk;  Arguments have not been evaluated yet.
+ *              out_op          - Wher to return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -476,16 +477,36 @@ acpi_ds_load2_begin_op (
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 
 	if (op) {
+		if ((walk_state->control_state) &&
+			(walk_state->control_state->common.state ==
+				ACPI_CONTROL_CONDITIONAL_EXECUTING)) {
+			/* We are executing a while loop outside of a method */
+
+			status = acpi_ds_exec_begin_op (walk_state, out_op);
+			return_ACPI_STATUS (status);
+		}
+
 		/* We only care about Namespace opcodes here */
 
-		if ((!(walk_state->op_info->flags & AML_NSOPCODE) && (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
+		if ((!(walk_state->op_info->flags & AML_NSOPCODE) &&
+			  (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
 			(!(walk_state->op_info->flags & AML_NAMED))) {
+			if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
+				(walk_state->op_info->class == AML_CLASS_CONTROL)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+					"Begin/EXEC: %s (fl %8.8X)\n", walk_state->op_info->name,
+					walk_state->op_info->flags));
+
+				/* Executing a type1 or type2 opcode outside of a method */
+
+				status = acpi_ds_exec_begin_op (walk_state, out_op);
+				return_ACPI_STATUS (status);
+			}
 			return_ACPI_STATUS (AE_OK);
 		}
 
-		/*
-		 * Get the name we are going to enter or lookup in the namespace
-		 */
+		/* Get the name we are going to enter or lookup in the namespace */
+
 		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
 			/* For Namepath op, get the path string */
 
@@ -528,23 +549,27 @@ acpi_ds_load2_begin_op (
 	case AML_INT_NAMEPATH_OP:
 
 		/*
-		 * The name_path is an object reference to an existing object. Don't enter the
-		 * name into the namespace, but look it up for use later
+		 * The name_path is an object reference to an existing object.
+		 * Don't enter the name into the namespace, but look it up
+		 * for use later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				  walk_state, &(node));
 		break;
 
 	case AML_SCOPE_OP:
 
 		/*
-		 * The Path is an object reference to an existing object.  Don't enter the
-		 * name into the namespace, but look it up for use later
+		 * The Path is an object reference to an existing object.
+		 * Don't enter the name into the namespace, but look it up
+		 * for use later.
 		 */
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				  walk_state, &(node));
 		if (ACPI_FAILURE (status)) {
-#ifdef _ACPI_ASL_COMPILER
+#ifdef ACPI_ASL_COMPILER
 			if (status == AE_NOT_FOUND) {
 				status = AE_OK;
 			}
@@ -582,7 +607,8 @@ acpi_ds_load2_begin_op (
 			 *  Scope (DEB) { ... }
 			 */
 
-			ACPI_REPORT_WARNING (("Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+			ACPI_REPORT_WARNING ((
+				"Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
 				buffer_ptr, acpi_ut_get_type_name (node->type)));
 
 			node->type = ACPI_TYPE_ANY;
@@ -593,7 +619,8 @@ acpi_ds_load2_begin_op (
 
 			/* All other types are an error */
 
-			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s]\n",
+			ACPI_REPORT_ERROR ((
+				"Invalid type (%s) for target of Scope operator [%4.4s]\n",
 				acpi_ut_get_type_name (node->type), buffer_ptr));
 
 			return (AE_AML_OPERAND_TYPE);
@@ -621,8 +648,9 @@ acpi_ds_load2_begin_op (
 
 		/*
 		 * Enter the named type into the internal namespace.  We enter the name
-		 * as we go downward in the parse tree.  Any necessary subobjects that involve
-		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 * as we go downward in the parse tree.  Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
 		 *
 		 * Note: Name may already exist if we are executing a deferred opcode.
 		 */
@@ -634,8 +662,11 @@ acpi_ds_load2_begin_op (
 			break;
 		}
 
+		/* Add new entry into namespace */
+
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
-				  ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, walk_state, &(node));
+				  ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH,
+				  walk_state, &(node));
 		break;
 	}
 
@@ -644,7 +675,6 @@ acpi_ds_load2_begin_op (
 		return_ACPI_STATUS (status);
 	}
 
-
 	if (!op) {
 		/* Create a new op */
 
@@ -658,9 +688,7 @@ acpi_ds_load2_begin_op (
 		if (node) {
 			op->named.name = node->name.integer;
 		}
-		if (out_op) {
-			*out_op = op;
-		}
+		*out_op = op;
 	}
 
 	/*
@@ -678,8 +706,6 @@ acpi_ds_load2_begin_op (
  * FUNCTION:    acpi_ds_load2_end_op
  *
  * PARAMETERS:  walk_state      - Current state of the parse tree walk
- *              Op              - Op that has been just been completed in the
- *                                walk;  Arguments have now been evaluated.
  *
  * RETURN:      Status
  *
@@ -709,9 +735,24 @@ acpi_ds_load2_end_op (
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Opcode [%s] Op %p State %p\n",
 			walk_state->op_info->name, op, walk_state));
 
-	/* Only interested in opcodes that have namespace objects */
+	/* Check if opcode had an associated namespace object */
 
 	if (!(walk_state->op_info->flags & AML_NSOBJECT)) {
+#ifndef ACPI_NO_METHOD_EXECUTION
+		/* No namespace object. Executable opcode? */
+
+		if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
+			(walk_state->op_info->class == AML_CLASS_CONTROL)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"End/EXEC:   %s (fl %8.8X)\n", walk_state->op_info->name,
+				walk_state->op_info->flags));
+
+			/* Executing a type1 or type2 opcode outside of a method */
+
+			status = acpi_ds_exec_end_op (walk_state);
+			return_ACPI_STATUS (status);
+		}
+#endif
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -720,7 +761,6 @@ acpi_ds_load2_end_op (
 			"Ending scope Op=%p State=%p\n", op, walk_state));
 	}
 
-
 	object_type = walk_state->op_info->object_type;
 
 	/*
@@ -738,7 +778,8 @@ acpi_ds_load2_end_op (
 
 	/* Pop the scope stack */
 
-	if (acpi_ns_opens_scope (object_type) && (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
+	if (acpi_ns_opens_scope (object_type) &&
+	   (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
 			acpi_ut_get_type_name (object_type), op));
 
@@ -803,7 +844,7 @@ acpi_ds_load2_end_op (
 		case AML_INDEX_FIELD_OP:
 
 			status = acpi_ds_create_index_field (op, (acpi_handle) arg->common.node,
-					   walk_state);
+					 walk_state);
 			break;
 
 		case AML_BANK_FIELD_OP:
@@ -884,14 +925,16 @@ acpi_ds_load2_end_op (
 #ifndef ACPI_NO_METHOD_EXECUTION
 		case AML_REGION_OP:
 			/*
-			 * The op_region is not fully parsed at this time. Only valid argument is the space_id.
-			 * (We must save the address of the AML of the address and length operands)
+			 * The op_region is not fully parsed at this time. Only valid
+			 * argument is the space_id. (We must save the address of the
+			 * AML of the address and length operands)
 			 */
 			/*
 			 * If we have a valid region, initialize it
 			 * Namespace is NOT locked at this point.
 			 */
-			status = acpi_ev_initialize_region (acpi_ns_get_attached_object (node), FALSE);
+			status = acpi_ev_initialize_region (acpi_ns_get_attached_object (node),
+					 FALSE);
 			if (ACPI_FAILURE (status)) {
 				/*
 				 *  If AE_NOT_EXIST is returned, it is not fatal
@@ -942,15 +985,16 @@ acpi_ds_load2_end_op (
 		if (ACPI_SUCCESS (status)) {
 			/*
 			 * Make sure that what we found is indeed a method
-			 * We didn't search for a method on purpose, to see if the name would resolve
+			 * We didn't search for a method on purpose, to see if the name
+			 * would resolve
 			 */
 			if (new_node->type != ACPI_TYPE_METHOD) {
 				status = AE_AML_OPERAND_TYPE;
 			}
 
-			/* We could put the returned object (Node) on the object stack for later, but
-			 * for now, we will put it in the "op" object that the parser uses, so we
-			 * can get it again at the end of this scope
+			/* We could put the returned object (Node) on the object stack for
+			 * later, but for now, we will put it in the "op" object that the
+			 * parser uses, so we can get it again at the end of this scope
 			 */
 			op->common.node = new_node;
 		}
diff --git a/drivers/acpi/dispatcher/dswscope.c b/drivers/acpi/dispatcher/dswscope.c
--- a/drivers/acpi/dispatcher/dswscope.c
+++ b/drivers/acpi/dispatcher/dswscope.c
@@ -50,14 +50,13 @@
 	 ACPI_MODULE_NAME    ("dswscope")
 
 
-#define STACK_POP(head) head
-
-
 /****************************************************************************
  *
  * FUNCTION:    acpi_ds_scope_stack_clear
  *
- * PARAMETERS:  None
+ * PARAMETERS:  walk_state      - Current state
+ *
+ * RETURN:      None
  *
  * DESCRIPTION: Pop (and free) everything on the scope stack except the
  *              root scope object (which remains at the stack top.)
@@ -80,7 +79,8 @@ acpi_ds_scope_stack_clear (
 		walk_state->scope_info = scope_info->scope.next;
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Popped object type (%s)\n", acpi_ut_get_type_name (scope_info->common.value)));
+			"Popped object type (%s)\n",
+			acpi_ut_get_type_name (scope_info->common.value)));
 		acpi_ut_delete_generic_state (scope_info);
 	}
 }
@@ -90,8 +90,11 @@ acpi_ds_scope_stack_clear (
  *
  * FUNCTION:    acpi_ds_scope_stack_push
  *
- * PARAMETERS:  *Node,              - Name to be made current
- *              Type,               - Type of frame being pushed
+ * PARAMETERS:  Node            - Name to be made current
+ *              Type            - Type of frame being pushed
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Push the current scope on the scope stack, and make the
  *              passed Node current.
@@ -121,7 +124,8 @@ acpi_ds_scope_stack_push (
 	/* Make sure object type is valid */
 
 	if (!acpi_ut_valid_object_type (type)) {
-		ACPI_REPORT_WARNING (("ds_scope_stack_push: Invalid object type: 0x%X\n", type));
+		ACPI_REPORT_WARNING ((
+			"ds_scope_stack_push: Invalid object type: 0x%X\n", type));
 	}
 
 	/* Allocate a new scope object */
@@ -170,16 +174,11 @@ acpi_ds_scope_stack_push (
  *
  * FUNCTION:    acpi_ds_scope_stack_pop
  *
- * PARAMETERS:  Type                - The type of frame to be found
+ * PARAMETERS:  walk_state      - Current state
  *
- * DESCRIPTION: Pop the scope stack until a frame of the requested type
- *              is found.
+ * RETURN:      Status
  *
- * RETURN:      Count of frames popped.  If no frame of the requested type
- *              was found, the count is returned as a negative number and
- *              the scope stack is emptied (which sets the current scope
- *              to the root).  If the scope stack was empty at entry, the
- *              function is a no-op and returns 0.
+ * DESCRIPTION: Pop the scope stack once.
  *
  ***************************************************************************/
 
diff --git a/drivers/acpi/dispatcher/dswstate.c b/drivers/acpi/dispatcher/dswstate.c
--- a/drivers/acpi/dispatcher/dswstate.c
+++ b/drivers/acpi/dispatcher/dswstate.c
@@ -50,67 +50,31 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dswstate")
 
+/* Local prototypes */
 
-#ifdef ACPI_FUTURE_USAGE
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ds_result_insert
- *
- * PARAMETERS:  Object              - Object to push
- *              Index               - Where to insert the object
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Insert an object onto this walk's result stack
- *
- ******************************************************************************/
-
+#ifdef ACPI_OBSOLETE_FUNCTIONS
 acpi_status
 acpi_ds_result_insert (
 	void                            *object,
 	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-	union acpi_generic_state        *state;
+	struct acpi_walk_state          *walk_state);
 
+acpi_status
+acpi_ds_obj_stack_delete_all (
+	struct acpi_walk_state          *walk_state);
 
-	ACPI_FUNCTION_NAME ("ds_result_insert");
-
-
-	state = walk_state->results;
-	if (!state) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result object pushed! State=%p\n",
-			walk_state));
-		return (AE_NOT_EXIST);
-	}
-
-	if (index >= ACPI_OBJ_NUM_OPERANDS) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Index out of range: %X Obj=%p State=%p Num=%X\n",
-			index, object, walk_state, state->results.num_results));
-		return (AE_BAD_PARAMETER);
-	}
-
-	if (!object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Null Object! Index=%X Obj=%p State=%p Num=%X\n",
-			index, object, walk_state, state->results.num_results));
-		return (AE_BAD_PARAMETER);
-	}
-
-	state->results.obj_desc [index] = object;
-	state->results.num_results++;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"Obj=%p [%s] State=%p Num=%X Cur=%X\n",
-		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
-		walk_state, state->results.num_results, walk_state->current_result));
+acpi_status
+acpi_ds_obj_stack_pop_object (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state);
 
-	return (AE_OK);
-}
+void *
+acpi_ds_obj_stack_get_value (
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+#endif
 
+#ifdef ACPI_FUTURE_USAGE
 
 /*******************************************************************************
  *
@@ -178,7 +142,6 @@ acpi_ds_result_remove (
 
 #endif  /*  ACPI_FUTURE_USAGE  */
 
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_result_pop
@@ -227,15 +190,18 @@ acpi_ds_result_pop (
 			*object = state->results.obj_desc [index -1];
 			state->results.obj_desc [index -1] = NULL;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] Index=%X State=%p Num=%X\n",
-				*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Obj=%p [%s] Index=%X State=%p Num=%X\n",
+				*object,
+				(*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 				(u32) index -1, walk_state, state->results.num_results));
 
 			return (AE_OK);
 		}
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+		"No result objects! State=%p\n", walk_state));
 	return (AE_AML_NO_RETURN_VALUE);
 }
 
@@ -274,7 +240,8 @@ acpi_ds_result_pop_from_bottom (
 	}
 
 	if (!state->results.num_results) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n",
+			walk_state));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
 
@@ -293,12 +260,13 @@ acpi_ds_result_pop_from_bottom (
 	/* Check for a valid result object */
 
 	if (!*object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null operand! State=%p #Ops=%X, Index=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null operand! State=%p #Ops=%X Index=%X\n",
 			walk_state, state->results.num_results, (u32) index));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s], Results=%p State=%p\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] Results=%p State=%p\n",
 		*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 		state, walk_state));
 
@@ -344,7 +312,8 @@ acpi_ds_result_push (
 	}
 
 	if (!object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null Object! Obj=%p State=%p Num=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null Object! Obj=%p State=%p Num=%X\n",
 			object, walk_state, state->results.num_results));
 		return (AE_BAD_PARAMETER);
 	}
@@ -439,43 +408,6 @@ acpi_ds_result_stack_pop (
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_obj_stack_delete_all
- *
- * PARAMETERS:  walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Clear the object stack by deleting all objects that are on it.
- *              Should be used with great care, if at all!
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ds_obj_stack_delete_all (
-	struct acpi_walk_state          *walk_state)
-{
-	u32                             i;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_delete_all", walk_state);
-
-
-	/* The stack size is configurable, but fixed */
-
-	for (i = 0; i < ACPI_OBJ_NUM_OPERANDS; i++) {
-		if (walk_state->operands[i]) {
-			acpi_ut_remove_reference (walk_state->operands[i]);
-			walk_state->operands[i] = NULL;
-		}
-	}
-
-	return_ACPI_STATUS (AE_OK);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_obj_stack_push
  *
  * PARAMETERS:  Object              - Object to push
@@ -517,67 +449,6 @@ acpi_ds_obj_stack_push (
 }
 
 
-#if 0
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ds_obj_stack_pop_object
- *
- * PARAMETERS:  pop_count           - Number of objects/entries to pop
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
- *              deleted by this routine.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ds_obj_stack_pop_object (
-	union acpi_operand_object       **object,
-	struct acpi_walk_state          *walk_state)
-{
-	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_object");
-
-
-	/* Check for stack underflow */
-
-	if (walk_state->num_operands == 0) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Missing operand/stack empty! State=%p #Ops=%X\n",
-			walk_state, walk_state->num_operands));
-		*object = NULL;
-		return (AE_AML_NO_OPERAND);
-	}
-
-	/* Pop the stack */
-
-	walk_state->num_operands--;
-
-	/* Check for a valid operand */
-
-	if (!walk_state->operands [walk_state->num_operands]) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Null operand! State=%p #Ops=%X\n",
-			walk_state, walk_state->num_operands));
-		*object = NULL;
-		return (AE_AML_NO_OPERAND);
-	}
-
-	/* Get operand and set stack entry to null */
-
-	*object = walk_state->operands [walk_state->num_operands];
-	walk_state->operands [walk_state->num_operands] = NULL;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
-			  *object, acpi_ut_get_object_type_name (*object),
-			  walk_state, walk_state->num_operands));
-
-	return (AE_OK);
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_obj_stack_pop
@@ -680,48 +551,6 @@ acpi_ds_obj_stack_pop_and_delete (
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ds_obj_stack_get_value
- *
- * PARAMETERS:  Index               - Stack index whose value is desired.  Based
- *                                    on the top of the stack (index=0 == top)
- *              walk_state          - Current Walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Retrieve an object from this walk's object stack.  Index must
- *              be within the range of the current stack pointer.
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-void *
-acpi_ds_obj_stack_get_value (
-	u32                             index,
-	struct acpi_walk_state          *walk_state)
-{
-
-	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_get_value", walk_state);
-
-
-	/* Can't do it if the stack is empty */
-
-	if (walk_state->num_operands == 0) {
-		return_PTR (NULL);
-	}
-
-	/* or if the index is past the top of the stack */
-
-	if (index > (walk_state->num_operands - (u32) 1)) {
-		return_PTR (NULL);
-	}
-
-	return_PTR (walk_state->operands[(acpi_native_uint)(walk_state->num_operands - 1) -
-			  index]);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ds_get_current_walk_state
  *
  * PARAMETERS:  Thread          - Get current active state for this Thread
@@ -757,11 +586,11 @@ acpi_ds_get_current_walk_state (
  * FUNCTION:    acpi_ds_push_walk_state
  *
  * PARAMETERS:  walk_state      - State to push
- *              walk_list       - The list that owns the walk stack
+ *              Thread          - Thread state object
  *
  * RETURN:      None
  *
- * DESCRIPTION: Place the walk_state at the head of the state list.
+ * DESCRIPTION: Place the Thread state at the head of the state list.
  *
  ******************************************************************************/
 
@@ -784,9 +613,9 @@ acpi_ds_push_walk_state (
  *
  * FUNCTION:    acpi_ds_pop_walk_state
  *
- * PARAMETERS:  walk_list       - The list that owns the walk stack
+ * PARAMETERS:  Thread      - Current thread state
  *
- * RETURN:      A walk_state object popped from the stack
+ * RETURN:      A walk_state object popped from the thread's stack
  *
  * DESCRIPTION: Remove and return the walkstate object that is at the head of
  *              the walk stack for the given walk list.  NULL indicates that
@@ -814,7 +643,7 @@ acpi_ds_pop_walk_state (
 		/*
 		 * Don't clear the NEXT field, this serves as an indicator
 		 * that there is a parent WALK STATE
-		 *     NO: walk_state->Next = NULL;
+		 * Do Not: walk_state->Next = NULL;
 		 */
 	}
 
@@ -826,7 +655,9 @@ acpi_ds_pop_walk_state (
  *
  * FUNCTION:    acpi_ds_create_walk_state
  *
- * PARAMETERS:  Origin          - Starting point for this walk
+ * PARAMETERS:  owner_id        - ID for object creation
+ *              Origin          - Starting point for this walk
+ *              mth_desc        - Method object
  *              Thread          - Current thread state
  *
  * RETURN:      Pointer to the new walk state.
@@ -850,7 +681,7 @@ acpi_ds_create_walk_state (
 	ACPI_FUNCTION_TRACE ("ds_create_walk_state");
 
 
-	walk_state = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_WALK);
+	walk_state = ACPI_MEM_CALLOCATE (sizeof (struct acpi_walk_state));
 	if (!walk_state) {
 		return_PTR (NULL);
 	}
@@ -873,7 +704,7 @@ acpi_ds_create_walk_state (
 
 	status = acpi_ds_result_stack_push (walk_state);
 	if (ACPI_FAILURE (status)) {
-		acpi_ut_release_to_cache (ACPI_MEM_LIST_WALK, walk_state);
+		ACPI_MEM_FREE (walk_state);
 		return_PTR (NULL);
 	}
 
@@ -896,8 +727,7 @@ acpi_ds_create_walk_state (
  *              method_node     - Control method NS node, if any
  *              aml_start       - Start of AML
  *              aml_length      - Length of AML
- *              Params          - Method args, if any
- *              return_obj_desc - Where to store a return object, if any
+ *              Info            - Method info block (params, etc.)
  *              pass_number     - 1, 2, or 3
  *
  * RETURN:      Status
@@ -914,7 +744,7 @@ acpi_ds_init_aml_walk (
 	u8                              *aml_start,
 	u32                             aml_length,
 	struct acpi_parameter_info      *info,
-	u32                             pass_number)
+	u8                              pass_number)
 {
 	acpi_status                     status;
 	struct acpi_parse_state         *parser_state = &walk_state->parser_state;
@@ -931,7 +761,8 @@ acpi_ds_init_aml_walk (
 
 	/* The next_op of the next_walk will be the beginning of the method */
 
-	walk_state->next_op             = NULL;
+	walk_state->next_op = NULL;
+	walk_state->pass_number = pass_number;
 
 	if (info) {
 		if (info->parameter_type == ACPI_PARAM_GPE) {
@@ -939,8 +770,8 @@ acpi_ds_init_aml_walk (
 					   info->parameters);
 		}
 		else {
-			walk_state->params              = info->parameters;
-			walk_state->caller_return_desc  = &info->return_object;
+			walk_state->params          = info->parameters;
+			walk_state->caller_return_desc = &info->return_object;
 		}
 	}
 
@@ -964,7 +795,8 @@ acpi_ds_init_aml_walk (
 
 		/* Init the method arguments */
 
-		status = acpi_ds_method_data_init_args (walk_state->params, ACPI_METHOD_NUM_ARGS, walk_state);
+		status = acpi_ds_method_data_init_args (walk_state->params,
+				 ACPI_METHOD_NUM_ARGS, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -1031,12 +863,14 @@ acpi_ds_delete_walk_state (
 	}
 
 	if (walk_state->data_type != ACPI_DESC_TYPE_WALK) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p is not a valid walk state\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p is not a valid walk state\n",
+			walk_state));
 		return;
 	}
 
 	if (walk_state->parser_state.scope) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n", walk_state));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n",
+			walk_state));
 	}
 
 	/* Always must free any linked control states */
@@ -1066,34 +900,204 @@ acpi_ds_delete_walk_state (
 		acpi_ut_delete_generic_state (state);
 	}
 
-	acpi_ut_release_to_cache (ACPI_MEM_LIST_WALK, walk_state);
+	ACPI_MEM_FREE (walk_state);
 	return_VOID;
 }
 
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-/******************************************************************************
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
  *
- * FUNCTION:    acpi_ds_delete_walk_state_cache
+ * FUNCTION:    acpi_ds_result_insert
  *
- * PARAMETERS:  None
+ * PARAMETERS:  Object              - Object to push
+ *              Index               - Where to insert the object
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Purge the global state object cache.  Used during subsystem
- *              termination.
+ * DESCRIPTION: Insert an object onto this walk's result stack
  *
  ******************************************************************************/
 
-void
-acpi_ds_delete_walk_state_cache (
-	void)
+acpi_status
+acpi_ds_result_insert (
+	void                            *object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
-	ACPI_FUNCTION_TRACE ("ds_delete_walk_state_cache");
+	union acpi_generic_state        *state;
 
 
-	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_WALK);
-	return_VOID;
+	ACPI_FUNCTION_NAME ("ds_result_insert");
+
+
+	state = walk_state->results;
+	if (!state) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result object pushed! State=%p\n",
+			walk_state));
+		return (AE_NOT_EXIST);
+	}
+
+	if (index >= ACPI_OBJ_NUM_OPERANDS) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Index out of range: %X Obj=%p State=%p Num=%X\n",
+			index, object, walk_state, state->results.num_results));
+		return (AE_BAD_PARAMETER);
+	}
+
+	if (!object) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null Object! Index=%X Obj=%p State=%p Num=%X\n",
+			index, object, walk_state, state->results.num_results));
+		return (AE_BAD_PARAMETER);
+	}
+
+	state->results.obj_desc [index] = object;
+	state->results.num_results++;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Obj=%p [%s] State=%p Num=%X Cur=%X\n",
+		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
+		walk_state, state->results.num_results, walk_state->current_result));
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_delete_all
+ *
+ * PARAMETERS:  walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear the object stack by deleting all objects that are on it.
+ *              Should be used with great care, if at all!
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_delete_all (
+	struct acpi_walk_state          *walk_state)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_delete_all", walk_state);
+
+
+	/* The stack size is configurable, but fixed */
+
+	for (i = 0; i < ACPI_OBJ_NUM_OPERANDS; i++) {
+		if (walk_state->operands[i]) {
+			acpi_ut_remove_reference (walk_state->operands[i]);
+			walk_state->operands[i] = NULL;
+		}
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_pop_object
+ *
+ * PARAMETERS:  Object              - Where to return the popped object
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
+ *              deleted by this routine.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_pop_object (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state)
+{
+	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_object");
+
+
+	/* Check for stack underflow */
+
+	if (walk_state->num_operands == 0) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Missing operand/stack empty! State=%p #Ops=%X\n",
+			walk_state, walk_state->num_operands));
+		*object = NULL;
+		return (AE_AML_NO_OPERAND);
+	}
+
+	/* Pop the stack */
+
+	walk_state->num_operands--;
+
+	/* Check for a valid operand */
+
+	if (!walk_state->operands [walk_state->num_operands]) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Null operand! State=%p #Ops=%X\n",
+			walk_state, walk_state->num_operands));
+		*object = NULL;
+		return (AE_AML_NO_OPERAND);
+	}
+
+	/* Get operand and set stack entry to null */
+
+	*object = walk_state->operands [walk_state->num_operands];
+	walk_state->operands [walk_state->num_operands] = NULL;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
+			  *object, acpi_ut_get_object_type_name (*object),
+			  walk_state, walk_state->num_operands));
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_get_value
+ *
+ * PARAMETERS:  Index               - Stack index whose value is desired.  Based
+ *                                    on the top of the stack (index=0 == top)
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Pointer to the requested operand
+ *
+ * DESCRIPTION: Retrieve an object from this walk's operand stack.  Index must
+ *              be within the range of the current stack pointer.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ds_obj_stack_get_value (
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
+{
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_get_value", walk_state);
+
+
+	/* Can't do it if the stack is empty */
+
+	if (walk_state->num_operands == 0) {
+		return_PTR (NULL);
+	}
+
+	/* or if the index is past the top of the stack */
+
+	if (index > (walk_state->num_operands - (u32) 1)) {
+		return_PTR (NULL);
+	}
+
+	return_PTR (walk_state->operands[(acpi_native_uint)(walk_state->num_operands - 1) -
+			  index]);
 }
 #endif
 
diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -31,6 +31,7 @@
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -49,60 +50,148 @@ ACPI_MODULE_NAME		("acpi_ec")
 
 #define ACPI_EC_FLAG_OBF	0x01	/* Output buffer full */
 #define ACPI_EC_FLAG_IBF	0x02	/* Input buffer full */
+#define ACPI_EC_FLAG_BURST	0x10	/* burst mode */
 #define ACPI_EC_FLAG_SCI	0x20	/* EC-SCI occurred */
 
 #define ACPI_EC_EVENT_OBF	0x01	/* Output buffer full */
 #define ACPI_EC_EVENT_IBE	0x02	/* Input buffer empty */
 
-#define ACPI_EC_UDELAY		100	/* Poll @ 100us increments */
-#define ACPI_EC_UDELAY_COUNT	1000	/* Wait 10ms max. during EC ops */
+#define ACPI_EC_DELAY		50	/* Wait 50ms max. during EC ops */
 #define ACPI_EC_UDELAY_GLK	1000	/* Wait 1ms max. to get global lock */
 
+#define ACPI_EC_UDELAY         100     /* Poll @ 100us increments */
+#define ACPI_EC_UDELAY_COUNT   1000    /* Wait 10ms max. during EC ops */
+
 #define ACPI_EC_COMMAND_READ	0x80
 #define ACPI_EC_COMMAND_WRITE	0x81
+#define ACPI_EC_BURST_ENABLE	0x82
+#define ACPI_EC_BURST_DISABLE	0x83
 #define ACPI_EC_COMMAND_QUERY	0x84
 
-static int acpi_ec_add (struct acpi_device *device);
+#define EC_POLLING		0xFF
+#define EC_BURST		0x00
+
+
 static int acpi_ec_remove (struct acpi_device *device, int type);
 static int acpi_ec_start (struct acpi_device *device);
 static int acpi_ec_stop (struct acpi_device *device, int type);
+static int acpi_ec_burst_add ( struct acpi_device *device);
 
 static struct acpi_driver acpi_ec_driver = {
 	.name =		ACPI_EC_DRIVER_NAME,
 	.class =	ACPI_EC_CLASS,
 	.ids =		ACPI_EC_HID,
 	.ops =		{
-				.add =		acpi_ec_add,
+				.add =		acpi_ec_burst_add,
 				.remove =	acpi_ec_remove,
 				.start =	acpi_ec_start,
 				.stop =		acpi_ec_stop,
 			},
 };
-
-struct acpi_ec {
-	acpi_handle			handle;
-	unsigned long			uid;
-	unsigned long			gpe_bit;
-	struct acpi_generic_address	status_addr;
-	struct acpi_generic_address	command_addr;
-	struct acpi_generic_address	data_addr;
-	unsigned long			global_lock;
-	spinlock_t			lock;
+union acpi_ec {
+	struct {
+		u32				mode;
+		acpi_handle			handle;
+		unsigned long			uid;
+		unsigned long			gpe_bit;
+		struct acpi_generic_address	status_addr;
+		struct acpi_generic_address	command_addr;
+		struct acpi_generic_address	data_addr;
+		unsigned long			global_lock;
+	} common;
+
+	struct {
+		u32				mode;
+		acpi_handle			handle;
+		unsigned long			uid;
+		unsigned long			gpe_bit;
+		struct acpi_generic_address	status_addr;
+		struct acpi_generic_address	command_addr;
+		struct acpi_generic_address	data_addr;
+		unsigned long			global_lock;
+		unsigned int			expect_event;
+		atomic_t			leaving_burst; /* 0 : No, 1 : Yes, 2: abort*/
+		atomic_t			pending_gpe;
+		struct semaphore		sem;
+		wait_queue_head_t		wait;
+	}burst;
+
+	struct {
+		u32				mode;
+		acpi_handle			handle;
+		unsigned long			uid;
+		unsigned long			gpe_bit;
+		struct acpi_generic_address	status_addr;
+		struct acpi_generic_address	command_addr;
+		struct acpi_generic_address	data_addr;
+		unsigned long			global_lock;
+       		spinlock_t                      lock;
+	}polling;
 };
 
+static int acpi_ec_polling_wait ( union acpi_ec *ec, u8 event); 
+static int acpi_ec_burst_wait(union acpi_ec *ec, unsigned int event);
+static int acpi_ec_polling_read ( union acpi_ec *ec, u8 address, u32 *data);
+static int acpi_ec_burst_read( union acpi_ec *ec, u8 address, u32 *data);
+static int acpi_ec_polling_write ( union acpi_ec *ec, u8 address, u8 data);
+static int acpi_ec_burst_write ( union acpi_ec *ec, u8 address, u8 data);
+static int acpi_ec_polling_query ( union acpi_ec *ec, u32 *data);
+static int acpi_ec_burst_query ( union acpi_ec *ec, u32 *data);
+static void acpi_ec_gpe_polling_query ( void *ec_cxt);
+static void acpi_ec_gpe_burst_query ( void *ec_cxt);
+static u32 acpi_ec_gpe_polling_handler ( void *data);
+static u32 acpi_ec_gpe_burst_handler ( void *data);
+static acpi_status __init
+acpi_fake_ecdt_polling_callback (
+	acpi_handle	handle,
+	u32		Level,
+	void		*context,
+	void		**retval);
+
+static acpi_status __init
+acpi_fake_ecdt_burst_callback (
+	acpi_handle	handle,
+	u32		Level,
+	void		*context,
+	void		**retval);
+
+static int __init
+acpi_ec_polling_get_real_ecdt(void);
+static int __init
+acpi_ec_burst_get_real_ecdt(void);
 /* If we find an EC via the ECDT, we need to keep a ptr to its context */
-static struct acpi_ec	*ec_ecdt;
+static union acpi_ec	*ec_ecdt;
 
 /* External interfaces use first EC only, so remember */
 static struct acpi_device *first_ec;
+static int acpi_ec_polling_mode;
 
 /* --------------------------------------------------------------------------
                              Transaction Management
    -------------------------------------------------------------------------- */
 
+static inline u32 acpi_ec_read_status(union acpi_ec *ec)
+{
+	u32	status = 0;
+
+	acpi_hw_low_level_read(8, &status, &ec->common.status_addr);
+	return status;
+}
+
 static int
 acpi_ec_wait (
-	struct acpi_ec		*ec,
+	union acpi_ec		*ec,
+	u8			event)
+{
+	if (acpi_ec_polling_mode) 
+		return acpi_ec_polling_wait (ec, event);
+	else
+		return acpi_ec_burst_wait (ec, event);
+}
+
+static int
+acpi_ec_polling_wait (
+	union acpi_ec		*ec,
 	u8			event)
 {
 	u32			acpi_ec_status = 0;
@@ -115,7 +204,7 @@ acpi_ec_wait (
 	switch (event) {
 	case ACPI_EC_EVENT_OBF:
 		do {
-			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->status_addr);
+			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->common.status_addr);
 			if (acpi_ec_status & ACPI_EC_FLAG_OBF)
 				return 0;
 			udelay(ACPI_EC_UDELAY);
@@ -123,7 +212,7 @@ acpi_ec_wait (
 		break;
 	case ACPI_EC_EVENT_IBE:
 		do {
-			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->status_addr);
+			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->common.status_addr);
 			if (!(acpi_ec_status & ACPI_EC_FLAG_IBF))
 				return 0;
 			udelay(ACPI_EC_UDELAY);
@@ -135,11 +224,129 @@ acpi_ec_wait (
 
 	return -ETIME;
 }
+static int acpi_ec_burst_wait(union acpi_ec *ec, unsigned int event)
+{
+	int	result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_wait");
+
+	ec->burst.expect_event = event;
+	smp_mb();
+
+	result = wait_event_interruptible_timeout(ec->burst.wait,
+					!ec->burst.expect_event,
+					msecs_to_jiffies(ACPI_EC_DELAY));
+	
+	ec->burst.expect_event = 0;
+	smp_mb();
+
+	if (result < 0){
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR," result  = %d ", result));
+		return_VALUE(result);
+	}
+
+	/*
+	 * Verify that the event in question has actually happened by
+	 * querying EC status. Do the check even if operation timed-out
+	 * to make sure that we did not miss interrupt.
+	 */
+	switch (event) {
+	case ACPI_EC_EVENT_OBF:
+		if (acpi_ec_read_status(ec) & ACPI_EC_FLAG_OBF)
+			return_VALUE(0);
+		break;
+
+	case ACPI_EC_EVENT_IBE:
+		if (~acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF)
+			return_VALUE(0);
+		break;
+	}
+
+	return_VALUE(-ETIME);
+}
+
 
 
 static int
+acpi_ec_enter_burst_mode (
+	union acpi_ec		*ec)
+{
+	u32			tmp = 0;
+	int			status = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_enter_burst_mode");
+
+	status = acpi_ec_read_status(ec);
+	if (status != -EINVAL &&
+		!(status & ACPI_EC_FLAG_BURST)){
+		acpi_hw_low_level_write(8, ACPI_EC_BURST_ENABLE, &ec->common.command_addr);
+		status = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+		if (status){
+			acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+			return_VALUE(-EINVAL);
+		}
+		acpi_hw_low_level_read(8, &tmp, &ec->common.data_addr);
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		if(tmp != 0x90 ) {/* Burst ACK byte*/
+			return_VALUE(-EINVAL);
+		}
+	}
+
+	atomic_set(&ec->burst.leaving_burst , 0);
+	return_VALUE(0);
+}
+
+static int
+acpi_ec_leave_burst_mode (
+	union acpi_ec		*ec)
+{
+	int			status =0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_leave_burst_mode");
+
+	atomic_set(&ec->burst.leaving_burst , 1);
+	status = acpi_ec_read_status(ec);
+	if (status != -EINVAL &&
+		(status & ACPI_EC_FLAG_BURST)){
+		acpi_hw_low_level_write(8, ACPI_EC_BURST_DISABLE, &ec->common.command_addr);
+		status = acpi_ec_wait(ec, ACPI_EC_FLAG_IBF);
+		if (status){
+			acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,"------->wait fail\n"));
+			return_VALUE(-EINVAL);
+		}
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		status = acpi_ec_read_status(ec);
+	}
+
+	return_VALUE(0);
+}
+
+static int
 acpi_ec_read (
-	struct acpi_ec		*ec,
+	union acpi_ec		*ec,
+	u8			address,
+	u32			*data)
+{
+	if (acpi_ec_polling_mode) 
+		return acpi_ec_polling_read(ec, address, data);
+	else
+		return acpi_ec_burst_read(ec, address, data);
+}
+static int
+acpi_ec_write (
+	union acpi_ec		*ec,
+	u8			address,
+	u8			data)
+{
+	if (acpi_ec_polling_mode) 
+		return acpi_ec_polling_write(ec, address, data);
+	else
+		return acpi_ec_burst_write(ec, address, data);
+}
+static int
+acpi_ec_polling_read (
+	union acpi_ec		*ec,
 	u8			address,
 	u32			*data)
 {
@@ -155,34 +362,33 @@ acpi_ec_read (
 
 	*data = 0;
 
-	if (ec->global_lock) {
+	if (ec->common.global_lock) {
 		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
 		if (ACPI_FAILURE(status))
 			return_VALUE(-ENODEV);
 	}
-	
-	spin_lock_irqsave(&ec->lock, flags);
 
-	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_READ, &ec->command_addr);
+	spin_lock_irqsave(&ec->polling.lock, flags);
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_READ, &ec->common.command_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
 	if (result)
 		goto end;
 
-	acpi_hw_low_level_write(8, address, &ec->data_addr);
+	acpi_hw_low_level_write(8, address, &ec->common.data_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
 	if (result)
 		goto end;
 
-
-	acpi_hw_low_level_read(8, data, &ec->data_addr);
+	acpi_hw_low_level_read(8, data, &ec->common.data_addr);
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Read [%02x] from address [%02x]\n",
 		*data, address));
-
+	
 end:
-	spin_unlock_irqrestore(&ec->lock, flags);
+	spin_unlock_irqrestore(&ec->polling.lock, flags);
 
-	if (ec->global_lock)
+	if (ec->common.global_lock)
 		acpi_release_global_lock(glk);
 
 	return_VALUE(result);
@@ -190,8 +396,8 @@ end:
 
 
 static int
-acpi_ec_write (
-	struct acpi_ec		*ec,
+acpi_ec_polling_write (
+	union acpi_ec		*ec,
 	u8			address,
 	u8			data)
 {
@@ -205,25 +411,25 @@ acpi_ec_write (
 	if (!ec)
 		return_VALUE(-EINVAL);
 
-	if (ec->global_lock) {
+	if (ec->common.global_lock) {
 		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
 		if (ACPI_FAILURE(status))
 			return_VALUE(-ENODEV);
 	}
 
-	spin_lock_irqsave(&ec->lock, flags);
+	spin_lock_irqsave(&ec->polling.lock, flags);
 
-	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_WRITE, &ec->command_addr);
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_WRITE, &ec->common.command_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
 	if (result)
 		goto end;
 
-	acpi_hw_low_level_write(8, address, &ec->data_addr);
+	acpi_hw_low_level_write(8, address, &ec->common.data_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
 	if (result)
 		goto end;
 
-	acpi_hw_low_level_write(8, data, &ec->data_addr);
+	acpi_hw_low_level_write(8, data, &ec->common.data_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
 	if (result)
 		goto end;
@@ -232,21 +438,172 @@ acpi_ec_write (
 		data, address));
 
 end:
-	spin_unlock_irqrestore(&ec->lock, flags);
+	spin_unlock_irqrestore(&ec->polling.lock, flags);
 
-	if (ec->global_lock)
+	if (ec->common.global_lock)
 		acpi_release_global_lock(glk);
 
 	return_VALUE(result);
 }
 
+static int
+acpi_ec_burst_read (
+	union acpi_ec		*ec,
+	u8			address,
+	u32			*data)
+{
+	int			status = 0;
+	u32			glk;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_read");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+
+retry:
+	*data = 0;
+
+	if (ec->common.global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	WARN_ON(in_interrupt());
+	down(&ec->burst.sem);
+
+	if(acpi_ec_enter_burst_mode(ec))
+		goto end;
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_READ, &ec->common.command_addr);
+	status = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+	if (status) {
+		goto end;
+	}
+
+	acpi_hw_low_level_write(8, address, &ec->common.data_addr);
+	status= acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (status){
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		goto end;
+	}
+
+	acpi_hw_low_level_read(8, data, &ec->common.data_addr);
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Read [%02x] from address [%02x]\n",
+		*data, address));
+	
+end:
+	acpi_ec_leave_burst_mode(ec);
+	up(&ec->burst.sem);
+
+	if (ec->common.global_lock)
+		acpi_release_global_lock(glk);
+
+	if(atomic_read(&ec->burst.leaving_burst) == 2){
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,"aborted, retry ...\n"));
+		while(atomic_read(&ec->burst.pending_gpe)){
+			msleep(1);	
+		}
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		goto retry;
+	}
+
+	return_VALUE(status);
+}
+
+
+static int
+acpi_ec_burst_write (
+	union acpi_ec		*ec,
+	u8			address,
+	u8			data)
+{
+	int			status = 0;
+	u32			glk;
+	u32			tmp;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_write");
+
+	if (!ec)
+		return_VALUE(-EINVAL);
+retry:
+	if (ec->common.global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	WARN_ON(in_interrupt());
+	down(&ec->burst.sem);
+
+	if(acpi_ec_enter_burst_mode(ec))
+		goto end;
+
+	status = acpi_ec_read_status(ec);
+	if (status != -EINVAL &&
+		!(status & ACPI_EC_FLAG_BURST)){
+		acpi_hw_low_level_write(8, ACPI_EC_BURST_ENABLE, &ec->common.command_addr);
+		status = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+		if (status)
+			goto end;
+		acpi_hw_low_level_read(8, &tmp, &ec->common.data_addr);
+		if(tmp != 0x90 ) /* Burst ACK byte*/
+			goto end;
+	}
+	/*Now we are in burst mode*/
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_WRITE, &ec->common.command_addr);
+	status = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+	if (status){
+		goto end;
+	}
+
+	acpi_hw_low_level_write(8, address, &ec->common.data_addr);
+	status = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (status){
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		goto end;
+	}
+
+	acpi_hw_low_level_write(8, data, &ec->common.data_addr);
+	status = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+	if (status)
+		goto end;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Wrote [%02x] to address [%02x]\n",
+		data, address));
+
+end:
+	acpi_ec_leave_burst_mode(ec);
+	up(&ec->burst.sem);
+
+	if (ec->common.global_lock)
+		acpi_release_global_lock(glk);
+
+	if(atomic_read(&ec->burst.leaving_burst) == 2){
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,"aborted, retry ...\n"));
+		while(atomic_read(&ec->burst.pending_gpe)){
+			msleep(1);	
+		}
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		goto retry;
+	}
+
+	return_VALUE(status);
+}
+
 /*
  * Externally callable EC access functions. For now, assume 1 EC only
  */
 int
 ec_read(u8 addr, u8 *val)
 {
-	struct acpi_ec *ec;
+	union acpi_ec *ec;
 	int err;
 	u32 temp_data;
 
@@ -269,7 +626,7 @@ EXPORT_SYMBOL(ec_read);
 int
 ec_write(u8 addr, u8 val)
 {
-	struct acpi_ec *ec;
+	union acpi_ec *ec;
 	int err;
 
 	if (!first_ec)
@@ -283,10 +640,19 @@ ec_write(u8 addr, u8 val)
 }
 EXPORT_SYMBOL(ec_write);
 
-
 static int
 acpi_ec_query (
-	struct acpi_ec		*ec,
+	union acpi_ec		*ec,
+	u32			*data)
+{
+	if (acpi_ec_polling_mode) 
+		return acpi_ec_polling_query(ec, data);
+	else
+		return acpi_ec_burst_query(ec, data);
+}
+static int
+acpi_ec_polling_query (
+	union acpi_ec		*ec,
 	u32			*data)
 {
 	int			result = 0;
@@ -301,7 +667,7 @@ acpi_ec_query (
 
 	*data = 0;
 
-	if (ec->global_lock) {
+	if (ec->common.global_lock) {
 		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
 		if (ACPI_FAILURE(status))
 			return_VALUE(-ENODEV);
@@ -312,32 +678,86 @@ acpi_ec_query (
 	 * Note that successful completion of the query causes the ACPI_EC_SCI
 	 * bit to be cleared (and thus clearing the interrupt source).
 	 */
-	spin_lock_irqsave(&ec->lock, flags);
+	spin_lock_irqsave(&ec->polling.lock, flags);
 
-	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_QUERY, &ec->command_addr);
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_QUERY, &ec->common.command_addr);
 	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
 	if (result)
 		goto end;
-	
-	acpi_hw_low_level_read(8, data, &ec->data_addr);
+
+	acpi_hw_low_level_read(8, data, &ec->common.data_addr);
 	if (!*data)
 		result = -ENODATA;
 
 end:
-	spin_unlock_irqrestore(&ec->lock, flags);
+	spin_unlock_irqrestore(&ec->polling.lock, flags);
 
-	if (ec->global_lock)
+	if (ec->common.global_lock)
 		acpi_release_global_lock(glk);
 
 	return_VALUE(result);
 }
+static int
+acpi_ec_burst_query (
+	union acpi_ec		*ec,
+	u32			*data)
+{
+	int			status = 0;
+	u32			glk;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_query");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+	*data = 0;
+
+	if (ec->common.global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	down(&ec->burst.sem);
+	if(acpi_ec_enter_burst_mode(ec))
+		goto end;
+	/*
+	 * Query the EC to find out which _Qxx method we need to evaluate.
+	 * Note that successful completion of the query causes the ACPI_EC_SCI
+	 * bit to be cleared (and thus clearing the interrupt source).
+	 */
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_QUERY, &ec->common.command_addr);
+	status = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (status){
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		goto end;
+	}
+
+	acpi_hw_low_level_read(8, data, &ec->common.data_addr);
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+	if (!*data)
+		status = -ENODATA;
+
+end:
+	acpi_ec_leave_burst_mode(ec);
+	up(&ec->burst.sem);
+
+	if (ec->common.global_lock)
+		acpi_release_global_lock(glk);
+
+	if(atomic_read(&ec->burst.leaving_burst) == 2){
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,"aborted, retry ...\n"));
+		acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+		status = -ENODATA;
+	}
+	return_VALUE(status);
+}
 
 
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */
 
-struct acpi_ec_query_data {
+union acpi_ec_query_data {
 	acpi_handle		handle;
 	u8			data;
 };
@@ -346,7 +766,17 @@ static void
 acpi_ec_gpe_query (
 	void			*ec_cxt)
 {
-	struct acpi_ec		*ec = (struct acpi_ec *) ec_cxt;
+	if (acpi_ec_polling_mode) 
+		acpi_ec_gpe_polling_query(ec_cxt);
+	else
+		acpi_ec_gpe_burst_query(ec_cxt);
+}
+
+static void
+acpi_ec_gpe_polling_query (
+	void			*ec_cxt)
+{
+	union acpi_ec		*ec = (union acpi_ec *) ec_cxt;
 	u32			value = 0;
 	unsigned long		flags = 0;
 	static char		object_name[5] = {'_','Q','0','0','\0'};
@@ -356,11 +786,11 @@ acpi_ec_gpe_query (
 	ACPI_FUNCTION_TRACE("acpi_ec_gpe_query");
 
 	if (!ec_cxt)
-		goto end;	
+		goto end;
 
-	spin_lock_irqsave(&ec->lock, flags);
-	acpi_hw_low_level_read(8, &value, &ec->command_addr);
-	spin_unlock_irqrestore(&ec->lock, flags);
+	spin_lock_irqsave(&ec->polling.lock, flags);
+	acpi_hw_low_level_read(8, &value, &ec->common.command_addr);
+	spin_unlock_irqrestore(&ec->polling.lock, flags);
 
 	/* TBD: Implement asynch events!
 	 * NOTE: All we care about are EC-SCI's.  Other EC events are
@@ -373,29 +803,67 @@ acpi_ec_gpe_query (
 
 	if (acpi_ec_query(ec, &value))
 		goto end;
-	
+
 	object_name[2] = hex[((value >> 4) & 0x0F)];
 	object_name[3] = hex[(value & 0x0F)];
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluating %s\n", object_name));
 
-	acpi_evaluate_object(ec->handle, object_name, NULL, NULL);
+	acpi_evaluate_object(ec->common.handle, object_name, NULL, NULL);
 
-end:
-	acpi_enable_gpe(NULL, ec->gpe_bit, ACPI_NOT_ISR);
+end:	
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
+}
+static void
+acpi_ec_gpe_burst_query (
+	void			*ec_cxt)
+{
+	union acpi_ec		*ec = (union acpi_ec *) ec_cxt;
+	u32			value;
+	int			result = -ENODATA;
+	static char		object_name[5] = {'_','Q','0','0','\0'};
+	const char		hex[] = {'0','1','2','3','4','5','6','7',
+				         '8','9','A','B','C','D','E','F'};
+
+	ACPI_FUNCTION_TRACE("acpi_ec_gpe_query");
+
+	if (acpi_ec_read_status(ec) & ACPI_EC_FLAG_SCI)
+		result = acpi_ec_query(ec, &value);
+
+	if (result)
+		goto end;
+
+	object_name[2] = hex[((value >> 4) & 0x0F)];
+	object_name[3] = hex[(value & 0x0F)];
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluating %s\n", object_name));
+
+	acpi_evaluate_object(ec->common.handle, object_name, NULL, NULL);
+end:	
+	atomic_dec(&ec->burst.pending_gpe);
+	return;
 }
 
 static u32
 acpi_ec_gpe_handler (
 	void			*data)
 {
+	if (acpi_ec_polling_mode) 
+		return acpi_ec_gpe_polling_handler(data);
+	else
+		return acpi_ec_gpe_burst_handler(data);	
+}
+static u32
+acpi_ec_gpe_polling_handler (
+	void			*data)
+{
 	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = (struct acpi_ec *) data;
+	union acpi_ec		*ec = (union acpi_ec *) data;
 
 	if (!ec)
 		return ACPI_INTERRUPT_NOT_HANDLED;
 
-	acpi_disable_gpe(NULL, ec->gpe_bit, ACPI_ISR);
+	acpi_disable_gpe(NULL, ec->common.gpe_bit, ACPI_ISR);
 
 	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
 		acpi_ec_gpe_query, ec);
@@ -405,6 +873,55 @@ acpi_ec_gpe_handler (
 	else
 		return ACPI_INTERRUPT_NOT_HANDLED;
 }
+static u32
+acpi_ec_gpe_burst_handler (
+	void			*data)
+{
+	acpi_status		status = AE_OK;
+	u32			value;
+	union acpi_ec		*ec = (union acpi_ec *) data;
+
+	if (!ec)
+		return ACPI_INTERRUPT_NOT_HANDLED;
+
+	acpi_disable_gpe(NULL, ec->common.gpe_bit, ACPI_ISR);
+
+	value = acpi_ec_read_status(ec);
+
+	if((value & ACPI_EC_FLAG_IBF) &&
+		!(value & ACPI_EC_FLAG_BURST) &&
+			(atomic_read(&ec->burst.leaving_burst) == 0)) { 
+	/*
+	 * the embedded controller disables 
+	 * burst mode for any reason other 
+	 * than the burst disable command
+	 * to process critical event.
+	 */
+		atomic_set(&ec->burst.leaving_burst , 2); /* block current pending transaction
+					and retry */
+		wake_up(&ec->burst.wait);
+	}else {
+		if ((ec->burst.expect_event == ACPI_EC_EVENT_OBF &&
+				(value & ACPI_EC_FLAG_OBF)) ||
+	    			(ec->burst.expect_event == ACPI_EC_EVENT_IBE &&
+				!(value & ACPI_EC_FLAG_IBF))) {
+			ec->burst.expect_event = 0;
+			wake_up(&ec->burst.wait);
+			return ACPI_INTERRUPT_HANDLED;
+		}
+	}
+
+	if (value & ACPI_EC_FLAG_SCI){
+		atomic_add(1, &ec->burst.pending_gpe) ;
+		status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
+						acpi_ec_gpe_query, ec);
+		return status == AE_OK ?
+		ACPI_INTERRUPT_HANDLED : ACPI_INTERRUPT_NOT_HANDLED;
+	} 
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_ISR);
+	return status == AE_OK ?
+		ACPI_INTERRUPT_HANDLED : ACPI_INTERRUPT_NOT_HANDLED;
+}
 
 /* --------------------------------------------------------------------------
                              Address Space Management
@@ -421,10 +938,8 @@ acpi_ec_space_setup (
 	 * The EC object is in the handler context and is needed
 	 * when calling the acpi_ec_space_handler.
 	 */
-	if(function == ACPI_REGION_DEACTIVATE) 
-		*return_context = NULL;
-	else 
-		*return_context = handler_context;
+	*return_context  = (function != ACPI_REGION_DEACTIVATE) ?
+						handler_context : NULL;
 
 	return AE_OK;
 }
@@ -440,8 +955,8 @@ acpi_ec_space_handler (
 	void			*region_context)
 {
 	int			result = 0;
-	struct acpi_ec		*ec = NULL;
-	u32			temp = 0;
+	union acpi_ec		*ec = NULL;
+	u64			temp = *value;
 	acpi_integer		f_v = 0;
 	int 			i = 0;
 
@@ -450,22 +965,21 @@ acpi_ec_space_handler (
 	if ((address > 0xFF) || !value || !handler_context)
 		return_VALUE(AE_BAD_PARAMETER);
 
-	if(bit_width != 8) {
+	if (bit_width != 8 && acpi_strict) {
 		printk(KERN_WARNING PREFIX "acpi_ec_space_handler: bit_width should be 8\n");
-		if (acpi_strict)
-			return_VALUE(AE_BAD_PARAMETER);
+		return_VALUE(AE_BAD_PARAMETER);
 	}
 
-	ec = (struct acpi_ec *) handler_context;
+	ec = (union acpi_ec *) handler_context;
 
 next_byte:
 	switch (function) {
 	case ACPI_READ:
-		result = acpi_ec_read(ec, (u8) address, &temp);
-		*value = (acpi_integer) temp;
+		temp = 0;
+		result = acpi_ec_read(ec, (u8) address, (u32 *)&temp);
 		break;
 	case ACPI_WRITE:
-		result = acpi_ec_write(ec, (u8) address, (u8) *value);
+		result = acpi_ec_write(ec, (u8) address, (u8) temp);
 		break;
 	default:
 		result = -EINVAL;
@@ -474,19 +988,18 @@ next_byte:
 	}
 
 	bit_width -= 8;
-	if(bit_width){
-
-		if(function == ACPI_READ)
-			f_v |= (acpi_integer) (*value) << 8*i;
-		if(function == ACPI_WRITE)
-			(*value) >>=8; 
+	if (bit_width) {
+		if (function == ACPI_READ)
+			f_v |= temp << 8 * i;
+		if (function == ACPI_WRITE)
+			temp >>= 8;
 		i++;
+		address++;
 		goto next_byte;
 	}
 
-
-	if(function == ACPI_READ){
-		f_v |= (acpi_integer) (*value) << 8*i;
+	if (function == ACPI_READ) {
+		f_v |= temp << 8 * i;
 		*value = f_v;
 	}
 
@@ -505,8 +1018,6 @@ out:
 	default:
 		return_VALUE(AE_OK);
 	}
-	
-
 }
 
 
@@ -520,7 +1031,7 @@ static struct proc_dir_entry	*acpi_ec_di
 static int
 acpi_ec_read_info (struct seq_file *seq, void *offset)
 {
-	struct acpi_ec		*ec = (struct acpi_ec *) seq->private;
+	union acpi_ec		*ec = (union acpi_ec *) seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_read_info");
 
@@ -528,11 +1039,12 @@ acpi_ec_read_info (struct seq_file *seq,
 		goto end;
 
 	seq_printf(seq, "gpe bit:                 0x%02x\n",
-		(u32) ec->gpe_bit);
+		(u32) ec->common.gpe_bit);
 	seq_printf(seq, "ports:                   0x%02x, 0x%02x\n",
-		(u32) ec->status_addr.address, (u32) ec->data_addr.address);
+		(u32) ec->common.status_addr.address, (u32) ec->common.data_addr.address);
 	seq_printf(seq, "use global lock:         %s\n",
-		ec->global_lock?"yes":"no");
+		ec->common.global_lock?"yes":"no");
+	acpi_enable_gpe(NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
 
 end:
 	return_VALUE(0);
@@ -602,13 +1114,14 @@ acpi_ec_remove_fs (
                                Driver Interface
    -------------------------------------------------------------------------- */
 
+
 static int
-acpi_ec_add (
+acpi_ec_polling_add (
 	struct acpi_device	*device)
 {
 	int			result = 0;
 	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
+	union acpi_ec		*ec = NULL;
 	unsigned long		uid;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_add");
@@ -616,36 +1129,107 @@ acpi_ec_add (
 	if (!device)
 		return_VALUE(-EINVAL);
 
-	ec = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	ec = kmalloc(sizeof(union acpi_ec), GFP_KERNEL);
 	if (!ec)
 		return_VALUE(-ENOMEM);
-	memset(ec, 0, sizeof(struct acpi_ec));
+	memset(ec, 0, sizeof(union acpi_ec));
 
-	ec->handle = device->handle;
-	ec->uid = -1;
-	spin_lock_init(&ec->lock);
+	ec->common.handle = device->handle;
+	ec->common.uid = -1;
+	spin_lock_init(&ec->polling.lock);
 	strcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_EC_CLASS);
 	acpi_driver_data(device) = ec;
 
 	/* Use the global lock for all EC transactions? */
-	acpi_evaluate_integer(ec->handle, "_GLK", NULL, &ec->global_lock);
+	acpi_evaluate_integer(ec->common.handle, "_GLK", NULL, &ec->common.global_lock);
 
 	/* If our UID matches the UID for the ECDT-enumerated EC,
 	   we now have the *real* EC info, so kill the makeshift one.*/
-	acpi_evaluate_integer(ec->handle, "_UID", NULL, &uid);
-	if (ec_ecdt && ec_ecdt->uid == uid) {
+	acpi_evaluate_integer(ec->common.handle, "_UID", NULL, &uid);
+	if (ec_ecdt && ec_ecdt->common.uid == uid) {
 		acpi_remove_address_space_handler(ACPI_ROOT_OBJECT,
 			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
 	
-		acpi_remove_gpe_handler(NULL, ec_ecdt->gpe_bit, &acpi_ec_gpe_handler);
+		acpi_remove_gpe_handler(NULL, ec_ecdt->common.gpe_bit, &acpi_ec_gpe_handler);
+
+		kfree(ec_ecdt);
+	}
+
+	/* Get GPE bit assignment (EC events). */
+	/* TODO: Add support for _GPE returning a package */
+	status = acpi_evaluate_integer(ec->common.handle, "_GPE", NULL, &ec->common.gpe_bit);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error obtaining GPE bit assignment\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	result = acpi_ec_add_fs(device);
+	if (result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (gpe %d)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		(u32) ec->common.gpe_bit);
+
+	if (!first_ec)
+		first_ec = device;
+
+end:
+	if (result)
+		kfree(ec);
+
+	return_VALUE(result);
+}
+static int
+acpi_ec_burst_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	union acpi_ec		*ec = NULL;
+	unsigned long		uid;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = kmalloc(sizeof(union acpi_ec), GFP_KERNEL);
+	if (!ec)
+		return_VALUE(-ENOMEM);
+	memset(ec, 0, sizeof(union acpi_ec));
+
+	ec->common.handle = device->handle;
+	ec->common.uid = -1;
+ 	atomic_set(&ec->burst.pending_gpe, 0);
+ 	atomic_set(&ec->burst.leaving_burst , 1);
+ 	init_MUTEX(&ec->burst.sem);
+ 	init_waitqueue_head(&ec->burst.wait);
+	strcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ACPI_EC_CLASS);
+	acpi_driver_data(device) = ec;
+
+	/* Use the global lock for all EC transactions? */
+	acpi_evaluate_integer(ec->common.handle, "_GLK", NULL, &ec->common.global_lock);
+
+	/* If our UID matches the UID for the ECDT-enumerated EC,
+	   we now have the *real* EC info, so kill the makeshift one.*/
+	acpi_evaluate_integer(ec->common.handle, "_UID", NULL, &uid);
+	if (ec_ecdt && ec_ecdt->common.uid == uid) {
+		acpi_remove_address_space_handler(ACPI_ROOT_OBJECT,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
+
+		acpi_remove_gpe_handler(NULL, ec_ecdt->common.gpe_bit, &acpi_ec_gpe_handler);
 
 		kfree(ec_ecdt);
 	}
 
 	/* Get GPE bit assignment (EC events). */
 	/* TODO: Add support for _GPE returning a package */
-	status = acpi_evaluate_integer(ec->handle, "_GPE", NULL, &ec->gpe_bit);
+	status = acpi_evaluate_integer(ec->common.handle, "_GPE", NULL, &ec->common.gpe_bit);
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 			"Error obtaining GPE bit assignment\n"));
@@ -659,7 +1243,7 @@ acpi_ec_add (
 
 	printk(KERN_INFO PREFIX "%s [%s] (gpe %d)\n",
 		acpi_device_name(device), acpi_device_bid(device),
-		(u32) ec->gpe_bit);
+		(u32) ec->common.gpe_bit);
 
 	if (!first_ec)
 		first_ec = device;
@@ -677,7 +1261,7 @@ acpi_ec_remove (
 	struct acpi_device	*device,
 	int			type)
 {
-	struct acpi_ec		*ec = NULL;
+	union acpi_ec		*ec = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_remove");
 
@@ -699,7 +1283,7 @@ acpi_ec_io_ports (
 	struct acpi_resource	*resource,
 	void			*context)
 {
-	struct acpi_ec		*ec = (struct acpi_ec *) context;
+	union acpi_ec		*ec = (union acpi_ec *) context;
 	struct acpi_generic_address *addr;
 
 	if (resource->id != ACPI_RSTYPE_IO) {
@@ -711,10 +1295,10 @@ acpi_ec_io_ports (
 	 * the second address region returned is the status/command
 	 * port.
 	 */
-	if (ec->data_addr.register_bit_width == 0) {
-		addr = &ec->data_addr;
-	} else if (ec->command_addr.register_bit_width == 0) {
-		addr = &ec->command_addr;
+	if (ec->common.data_addr.register_bit_width == 0) {
+		addr = &ec->common.data_addr;
+	} else if (ec->common.command_addr.register_bit_width == 0) {
+		addr = &ec->common.command_addr;
 	} else {
 		return AE_CTRL_TERMINATE;
 	}
@@ -733,7 +1317,7 @@ acpi_ec_start (
 	struct acpi_device	*device)
 {
 	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
+	union acpi_ec		*ec = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_start");
 
@@ -748,35 +1332,36 @@ acpi_ec_start (
 	/*
 	 * Get I/O port addresses. Convert to GAS format.
 	 */
-	status = acpi_walk_resources(ec->handle, METHOD_NAME__CRS,
+	status = acpi_walk_resources(ec->common.handle, METHOD_NAME__CRS,
 		acpi_ec_io_ports, ec);
-	if (ACPI_FAILURE(status) || ec->command_addr.register_bit_width == 0) {
+	if (ACPI_FAILURE(status) || ec->common.command_addr.register_bit_width == 0) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error getting I/O port addresses"));
 		return_VALUE(-ENODEV);
 	}
 
-	ec->status_addr = ec->command_addr;
+	ec->common.status_addr = ec->common.command_addr;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "gpe=0x%02x, ports=0x%2x,0x%2x\n",
-		(u32) ec->gpe_bit, (u32) ec->command_addr.address,
-		(u32) ec->data_addr.address));
+		(u32) ec->common.gpe_bit, (u32) ec->common.command_addr.address,
+		(u32) ec->common.data_addr.address));
+
 
 	/*
 	 * Install GPE handler
 	 */
-	status = acpi_install_gpe_handler(NULL, ec->gpe_bit,
+	status = acpi_install_gpe_handler(NULL, ec->common.gpe_bit,
 		ACPI_GPE_EDGE_TRIGGERED, &acpi_ec_gpe_handler, ec);
 	if (ACPI_FAILURE(status)) {
 		return_VALUE(-ENODEV);
 	}
-	acpi_set_gpe_type (NULL, ec->gpe_bit, ACPI_GPE_TYPE_RUNTIME);
-	acpi_enable_gpe (NULL, ec->gpe_bit, ACPI_NOT_ISR);
+	acpi_set_gpe_type (NULL, ec->common.gpe_bit, ACPI_GPE_TYPE_RUNTIME);
+	acpi_enable_gpe (NULL, ec->common.gpe_bit, ACPI_NOT_ISR);
 
-	status = acpi_install_address_space_handler (ec->handle,
+	status = acpi_install_address_space_handler (ec->common.handle,
 			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
 			&acpi_ec_space_setup, ec);
 	if (ACPI_FAILURE(status)) {
-		acpi_remove_gpe_handler(NULL, ec->gpe_bit, &acpi_ec_gpe_handler);
+		acpi_remove_gpe_handler(NULL, ec->common.gpe_bit, &acpi_ec_gpe_handler);
 		return_VALUE(-ENODEV);
 	}
 
@@ -790,7 +1375,7 @@ acpi_ec_stop (
 	int			type)
 {
 	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
+	union acpi_ec		*ec = NULL;
 
 	ACPI_FUNCTION_TRACE("acpi_ec_stop");
 
@@ -799,12 +1384,12 @@ acpi_ec_stop (
 
 	ec = acpi_driver_data(device);
 
-	status = acpi_remove_address_space_handler(ec->handle,
+	status = acpi_remove_address_space_handler(ec->common.handle,
 		ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
-	status = acpi_remove_gpe_handler(NULL, ec->gpe_bit, &acpi_ec_gpe_handler);
+	status = acpi_remove_gpe_handler(NULL, ec->common.gpe_bit, &acpi_ec_gpe_handler);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
@@ -818,27 +1403,76 @@ acpi_fake_ecdt_callback (
 	void		*context,
 	void		**retval)
 {
+
+	if (acpi_ec_polling_mode)
+		return acpi_fake_ecdt_polling_callback(handle,
+			Level, context, retval);
+	else
+		return acpi_fake_ecdt_burst_callback(handle,
+			Level, context, retval);
+}
+
+static acpi_status __init
+acpi_fake_ecdt_polling_callback (
+	acpi_handle	handle,
+	u32		Level,
+	void		*context,
+	void		**retval)
+{
 	acpi_status	status;
 
 	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
 		acpi_ec_io_ports, ec_ecdt);
 	if (ACPI_FAILURE(status))
 		return status;
-	ec_ecdt->status_addr = ec_ecdt->command_addr;
+	ec_ecdt->common.status_addr = ec_ecdt->common.command_addr;
 
-	ec_ecdt->uid = -1;
-	acpi_evaluate_integer(handle, "_UID", NULL, &ec_ecdt->uid);
+	ec_ecdt->common.uid = -1;
+	acpi_evaluate_integer(handle, "_UID", NULL, &ec_ecdt->common.uid);
 
-	status = acpi_evaluate_integer(handle, "_GPE", NULL, &ec_ecdt->gpe_bit);
+	status = acpi_evaluate_integer(handle, "_GPE", NULL, &ec_ecdt->common.gpe_bit);
 	if (ACPI_FAILURE(status))
 		return status;
-	spin_lock_init(&ec_ecdt->lock);
-	ec_ecdt->global_lock = TRUE;
-	ec_ecdt->handle = handle;
+	spin_lock_init(&ec_ecdt->polling.lock);
+	ec_ecdt->common.global_lock = TRUE;
+	ec_ecdt->common.handle = handle;
 
 	printk(KERN_INFO PREFIX  "GPE=0x%02x, ports=0x%2x, 0x%2x\n",
-		(u32) ec_ecdt->gpe_bit, (u32) ec_ecdt->command_addr.address,
-		(u32) ec_ecdt->data_addr.address);
+		(u32) ec_ecdt->common.gpe_bit, (u32) ec_ecdt->common.command_addr.address,
+		(u32) ec_ecdt->common.data_addr.address);
+
+	return AE_CTRL_TERMINATE;
+}
+
+static acpi_status __init
+acpi_fake_ecdt_burst_callback (
+	acpi_handle	handle,
+	u32		Level,
+	void		*context,
+	void		**retval)
+{
+	acpi_status	status;
+
+	init_MUTEX(&ec_ecdt->burst.sem);
+	init_waitqueue_head(&ec_ecdt->burst.wait);
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+		acpi_ec_io_ports, ec_ecdt);
+	if (ACPI_FAILURE(status))
+		return status;
+	ec_ecdt->common.status_addr = ec_ecdt->common.command_addr;
+
+	ec_ecdt->common.uid = -1;
+	acpi_evaluate_integer(handle, "_UID", NULL, &ec_ecdt->common.uid);
+
+	status = acpi_evaluate_integer(handle, "_GPE", NULL, &ec_ecdt->common.gpe_bit);
+	if (ACPI_FAILURE(status))
+		return status;
+	ec_ecdt->common.global_lock = TRUE;
+	ec_ecdt->common.handle = handle;
+
+	printk(KERN_INFO PREFIX  "GPE=0x%02x, ports=0x%2x, 0x%2x\n",
+		(u32) ec_ecdt->common.gpe_bit, (u32) ec_ecdt->common.command_addr.address,
+		(u32) ec_ecdt->common.data_addr.address);
 
 	return AE_CTRL_TERMINATE;
 }
@@ -861,12 +1495,12 @@ acpi_ec_fake_ecdt(void)
 
 	printk(KERN_INFO PREFIX "Try to make an fake ECDT\n");
 
-	ec_ecdt = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	ec_ecdt = kmalloc(sizeof(union acpi_ec), GFP_KERNEL);
 	if (!ec_ecdt) {
 		ret = -ENOMEM;
 		goto error;
 	}
-	memset(ec_ecdt, 0, sizeof(struct acpi_ec));
+	memset(ec_ecdt, 0, sizeof(union acpi_ec));
 
 	status = acpi_get_devices (ACPI_EC_HID,
 				acpi_fake_ecdt_callback,
@@ -887,6 +1521,15 @@ error:
 static int __init
 acpi_ec_get_real_ecdt(void)
 {
+	if (acpi_ec_polling_mode)
+		return acpi_ec_polling_get_real_ecdt();
+	else
+		return acpi_ec_burst_get_real_ecdt();
+}
+
+static int __init
+acpi_ec_polling_get_real_ecdt(void)
+{
 	acpi_status		status;
 	struct acpi_table_ecdt 	*ecdt_ptr;
 
@@ -900,21 +1543,67 @@ acpi_ec_get_real_ecdt(void)
 	/*
 	 * Generate a temporary ec context to use until the namespace is scanned
 	 */
-	ec_ecdt = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	ec_ecdt = kmalloc(sizeof(union acpi_ec), GFP_KERNEL);
 	if (!ec_ecdt)
 		return -ENOMEM;
-	memset(ec_ecdt, 0, sizeof(struct acpi_ec));
+	memset(ec_ecdt, 0, sizeof(union acpi_ec));
 
-	ec_ecdt->command_addr = ecdt_ptr->ec_control;
-	ec_ecdt->status_addr = ecdt_ptr->ec_control;
-	ec_ecdt->data_addr = ecdt_ptr->ec_data;
-	ec_ecdt->gpe_bit = ecdt_ptr->gpe_bit;
-	spin_lock_init(&ec_ecdt->lock);
+	ec_ecdt->common.command_addr = ecdt_ptr->ec_control;
+	ec_ecdt->common.status_addr = ecdt_ptr->ec_control;
+	ec_ecdt->common.data_addr = ecdt_ptr->ec_data;
+	ec_ecdt->common.gpe_bit = ecdt_ptr->gpe_bit;
+	spin_lock_init(&ec_ecdt->polling.lock);
 	/* use the GL just to be safe */
-	ec_ecdt->global_lock = TRUE;
-	ec_ecdt->uid = ecdt_ptr->uid;
+	ec_ecdt->common.global_lock = TRUE;
+	ec_ecdt->common.uid = ecdt_ptr->uid;
 
-	status = acpi_get_handle(NULL, ecdt_ptr->ec_id, &ec_ecdt->handle);
+	status = acpi_get_handle(NULL, ecdt_ptr->ec_id, &ec_ecdt->common.handle);
+	if (ACPI_FAILURE(status)) {
+		goto error;
+	}
+
+	return 0;
+error:
+	printk(KERN_ERR PREFIX "Could not use ECDT\n");
+	kfree(ec_ecdt);
+	ec_ecdt = NULL;
+
+	return -ENODEV;
+}
+
+
+static int __init
+acpi_ec_burst_get_real_ecdt(void)
+{
+	acpi_status		status;
+	struct acpi_table_ecdt 	*ecdt_ptr;
+
+	status = acpi_get_firmware_table("ECDT", 1, ACPI_LOGICAL_ADDRESSING,
+		(struct acpi_table_header **) &ecdt_ptr);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	printk(KERN_INFO PREFIX "Found ECDT\n");
+
+	/*
+	 * Generate a temporary ec context to use until the namespace is scanned
+	 */
+	ec_ecdt = kmalloc(sizeof(union acpi_ec), GFP_KERNEL);
+	if (!ec_ecdt)
+		return -ENOMEM;
+	memset(ec_ecdt, 0, sizeof(union acpi_ec));
+
+ 	init_MUTEX(&ec_ecdt->burst.sem);
+ 	init_waitqueue_head(&ec_ecdt->burst.wait);
+	ec_ecdt->common.command_addr = ecdt_ptr->ec_control;
+	ec_ecdt->common.status_addr = ecdt_ptr->ec_control;
+	ec_ecdt->common.data_addr = ecdt_ptr->ec_data;
+	ec_ecdt->common.gpe_bit = ecdt_ptr->gpe_bit;
+	/* use the GL just to be safe */
+	ec_ecdt->common.global_lock = TRUE;
+	ec_ecdt->common.uid = ecdt_ptr->uid;
+
+	status = acpi_get_handle(NULL, ecdt_ptr->ec_id, &ec_ecdt->common.handle);
 	if (ACPI_FAILURE(status)) {
 		goto error;
 	}
@@ -947,20 +1636,20 @@ acpi_ec_ecdt_probe (void)
 	/*
 	 * Install GPE handler
 	 */
-	status = acpi_install_gpe_handler(NULL, ec_ecdt->gpe_bit,
+	status = acpi_install_gpe_handler(NULL, ec_ecdt->common.gpe_bit,
 		ACPI_GPE_EDGE_TRIGGERED, &acpi_ec_gpe_handler,
 		ec_ecdt);
 	if (ACPI_FAILURE(status)) {
 		goto error;
 	}
-	acpi_set_gpe_type (NULL, ec_ecdt->gpe_bit, ACPI_GPE_TYPE_RUNTIME);
-	acpi_enable_gpe (NULL, ec_ecdt->gpe_bit, ACPI_NOT_ISR);
+	acpi_set_gpe_type (NULL, ec_ecdt->common.gpe_bit, ACPI_GPE_TYPE_RUNTIME);
+	acpi_enable_gpe (NULL, ec_ecdt->common.gpe_bit, ACPI_NOT_ISR);
 
 	status = acpi_install_address_space_handler (ACPI_ROOT_OBJECT,
 			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
 			&acpi_ec_space_setup, ec_ecdt);
 	if (ACPI_FAILURE(status)) {
-		acpi_remove_gpe_handler(NULL, ec_ecdt->gpe_bit,
+		acpi_remove_gpe_handler(NULL, ec_ecdt->common.gpe_bit,
 			&acpi_ec_gpe_handler);
 		goto error;
 	}
@@ -1022,3 +1711,10 @@ static int __init acpi_fake_ecdt_setup(c
 	return 0;
 }
 __setup("acpi_fake_ecdt", acpi_fake_ecdt_setup);
+static int __init acpi_ec_set_polling_mode(char *str)
+{
+	acpi_ec_polling_mode = EC_POLLING;
+	acpi_ec_driver.ops.add = acpi_ec_polling_add;
+	return 0;
+}
+__setup("ec_polling", acpi_ec_set_polling_mode);
diff --git a/drivers/acpi/events/evevent.c b/drivers/acpi/events/evevent.c
--- a/drivers/acpi/events/evevent.c
+++ b/drivers/acpi/events/evevent.c
@@ -47,6 +47,16 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evevent")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_fixed_event_initialize (
+	void);
+
+static u32
+acpi_ev_fixed_event_dispatch (
+	u32                             event);
+
 
 /*******************************************************************************
  *
@@ -56,7 +66,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize global data structures for events.
+ * DESCRIPTION: Initialize global data structures for ACPI events (Fixed, GPE)
  *
  ******************************************************************************/
 
@@ -78,9 +88,9 @@ acpi_ev_initialize_events (
 	}
 
 	/*
-	 * Initialize the Fixed and General Purpose Events. This is
-	 * done prior to enabling SCIs to prevent interrupts from
-	 * occurring before handers are installed.
+	 * Initialize the Fixed and General Purpose Events. This is done prior to
+	 * enabling SCIs to prevent interrupts from occurring before the handlers are
+	 * installed.
 	 */
 	status = acpi_ev_fixed_event_initialize ();
 	if (ACPI_FAILURE (status)) {
@@ -161,7 +171,7 @@ acpi_ev_install_xrupt_handlers (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_fixed_event_initialize (
 	void)
 {
@@ -180,7 +190,8 @@ acpi_ev_fixed_event_initialize (
 		/* Enable the fixed event */
 
 		if (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {
-			status = acpi_set_register (acpi_gbl_fixed_event_info[i].enable_register_id,
+			status = acpi_set_register (
+					 acpi_gbl_fixed_event_info[i].enable_register_id,
 					 0, ACPI_MTX_LOCK);
 			if (ACPI_FAILURE (status)) {
 				return (status);
@@ -200,7 +211,7 @@ acpi_ev_fixed_event_initialize (
  *
  * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
  *
- * DESCRIPTION: Checks the PM status register for fixed events
+ * DESCRIPTION: Checks the PM status register for active fixed events
  *
  ******************************************************************************/
 
@@ -221,8 +232,10 @@ acpi_ev_fixed_event_detect (
 	 * Read the fixed feature status and enable registers, as all the cases
 	 * depend on their values.  Ignore errors here.
 	 */
-	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS, &fixed_status);
-	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE, &fixed_enable);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
+			 &fixed_status);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE,
+			 &fixed_enable);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
 		"Fixed Event Block: Enable %08X Status %08X\n",
@@ -259,7 +272,7 @@ acpi_ev_fixed_event_detect (
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ev_fixed_event_dispatch (
 	u32                             event)
 {
diff --git a/drivers/acpi/events/evgpe.c b/drivers/acpi/events/evgpe.c
--- a/drivers/acpi/events/evgpe.c
+++ b/drivers/acpi/events/evgpe.c
@@ -48,6 +48,12 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evgpe")
 
+/* Local prototypes */
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_asynch_execute_gpe_method (
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -335,8 +341,10 @@ acpi_ev_get_gpe_event_info (
 			gpe_block = acpi_gbl_gpe_fadt_blocks[i];
 			if (gpe_block) {
 				if ((gpe_number >= gpe_block->block_base_number) &&
-					(gpe_number < gpe_block->block_base_number + (gpe_block->register_count * 8))) {
-					return (&gpe_block->event_info[gpe_number - gpe_block->block_base_number]);
+					(gpe_number < gpe_block->block_base_number +
+						(gpe_block->register_count * 8))) {
+					return (&gpe_block->event_info[gpe_number -
+						gpe_block->block_base_number]);
 				}
 			}
 		}
@@ -388,6 +396,7 @@ acpi_ev_gpe_detect (
 	struct acpi_gpe_register_info   *gpe_register_info;
 	u32                             status_reg;
 	u32                             enable_reg;
+	u32                             flags;
 	acpi_status                     status;
 	struct acpi_gpe_block_info      *gpe_block;
 	acpi_native_uint                i;
@@ -404,7 +413,7 @@ acpi_ev_gpe_detect (
 
 	/* Examine all GPE blocks attached to this interrupt level */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	gpe_block = gpe_xrupt_list->gpe_block_list_head;
 	while (gpe_block) {
 		/*
@@ -437,7 +446,7 @@ acpi_ev_gpe_detect (
 				"Read GPE Register at GPE%X: Status=%02X, Enable=%02X\n",
 				gpe_register_info->base_gpe_number, status_reg, enable_reg));
 
-			/* First check if there is anything active at all in this register */
+			/* Check if there is anything active at all in this register */
 
 			enabled_status_byte = (u8) (status_reg & enable_reg);
 			if (!enabled_status_byte) {
@@ -457,8 +466,8 @@ acpi_ev_gpe_detect (
 					 * or method.
 					 */
 					int_status |= acpi_ev_gpe_dispatch (
-							  &gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j],
-							  (u32) j + gpe_register_info->base_gpe_number);
+						&gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j],
+						(u32) j + gpe_register_info->base_gpe_number);
 				}
 			}
 		}
@@ -468,7 +477,7 @@ acpi_ev_gpe_detect (
 
 unlock_and_exit:
 
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 	return (int_status);
 }
 
@@ -523,7 +532,8 @@ acpi_ev_asynch_execute_gpe_method (
 	 * Take a snapshot of the GPE info for this level - we copy the
 	 * info to prevent a race condition with remove_handler/remove_block.
 	 */
-	ACPI_MEMCPY (&local_gpe_event_info, gpe_event_info, sizeof (struct acpi_gpe_event_info));
+	ACPI_MEMCPY (&local_gpe_event_info, gpe_event_info,
+		sizeof (struct acpi_gpe_event_info));
 
 	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	if (ACPI_FAILURE (status)) {
@@ -534,7 +544,8 @@ acpi_ev_asynch_execute_gpe_method (
 	 * Must check for control method type dispatch one more
 	 * time to avoid race with ev_gpe_install_handler
 	 */
-	if ((local_gpe_event_info.flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_METHOD) {
+	if ((local_gpe_event_info.flags & ACPI_GPE_DISPATCH_MASK) ==
+			ACPI_GPE_DISPATCH_METHOD) {
 		/*
 		 * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the _Lxx/_Exx
 		 * control method that corresponds to this GPE
@@ -553,7 +564,8 @@ acpi_ev_asynch_execute_gpe_method (
 		}
 	}
 
-	if ((local_gpe_event_info.flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_LEVEL_TRIGGERED) {
+	if ((local_gpe_event_info.flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+			ACPI_GPE_LEVEL_TRIGGERED) {
 		/*
 		 * GPE is level-triggered, we clear the GPE status bit after
 		 * handling the event.
@@ -575,7 +587,7 @@ acpi_ev_asynch_execute_gpe_method (
  *
  * FUNCTION:    acpi_ev_gpe_dispatch
  *
- * PARAMETERS:  gpe_event_info  - info for this GPE
+ * PARAMETERS:  gpe_event_info  - Info for this GPE
  *              gpe_number      - Number relative to the parent GPE block
  *
  * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
@@ -602,10 +614,12 @@ acpi_ev_gpe_dispatch (
 	 * If edge-triggered, clear the GPE status bit now.  Note that
 	 * level-triggered events are cleared after the GPE is serviced.
 	 */
-	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_EDGE_TRIGGERED) {
+	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+			ACPI_GPE_EDGE_TRIGGERED) {
 		status = acpi_hw_clear_gpe (gpe_event_info);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
+			ACPI_REPORT_ERROR ((
+				"acpi_ev_gpe_dispatch: %s, Unable to clear GPE[%2X]\n",
 				acpi_format_exception (status), gpe_number));
 			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
 		}
@@ -639,7 +653,8 @@ acpi_ev_gpe_dispatch (
 
 		/* It is now safe to clear level-triggered events. */
 
-		if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) == ACPI_GPE_LEVEL_TRIGGERED) {
+		if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+				ACPI_GPE_LEVEL_TRIGGERED) {
 			status = acpi_hw_clear_gpe (gpe_event_info);
 			if (ACPI_FAILURE (status)) {
 				ACPI_REPORT_ERROR ((
@@ -704,7 +719,6 @@ acpi_ev_gpe_dispatch (
 
 
 #ifdef ACPI_GPE_NOTIFY_CHECK
-
 /*******************************************************************************
  * TBD: NOT USED, PROTOTYPE ONLY AND WILL PROBABLY BE REMOVED
  *
diff --git a/drivers/acpi/events/evgpeblk.c b/drivers/acpi/events/evgpeblk.c
--- a/drivers/acpi/events/evgpeblk.c
+++ b/drivers/acpi/events/evgpeblk.c
@@ -48,6 +48,39 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evgpeblk")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_save_method_info (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *obj_desc,
+	void                            **return_value);
+
+static acpi_status
+acpi_ev_match_prw_and_gpe (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *info,
+	void                            **return_value);
+
+static struct acpi_gpe_xrupt_info *
+acpi_ev_get_gpe_xrupt_block (
+	u32                             interrupt_number);
+
+static acpi_status
+acpi_ev_delete_gpe_xrupt (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt);
+
+static acpi_status
+acpi_ev_install_gpe_block (
+	struct acpi_gpe_block_info      *gpe_block,
+	u32                             interrupt_number);
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks (
+	struct acpi_gpe_block_info      *gpe_block);
+
 
 /*******************************************************************************
  *
@@ -105,7 +138,6 @@ acpi_ev_valid_gpe_event (
  * FUNCTION:    acpi_ev_walk_gpe_list
  *
  * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block
- *              Flags               - ACPI_NOT_ISR or ACPI_ISR
  *
  * RETURN:      Status
  *
@@ -115,18 +147,18 @@ acpi_ev_valid_gpe_event (
 
 acpi_status
 acpi_ev_walk_gpe_list (
-	ACPI_GPE_CALLBACK       gpe_walk_callback,
-	u32                             flags)
+	ACPI_GPE_CALLBACK       gpe_walk_callback)
 {
 	struct acpi_gpe_block_info      *gpe_block;
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info;
 	acpi_status                     status = AE_OK;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("ev_walk_gpe_list");
 
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, flags);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 
 	/* Walk the interrupt level descriptor list */
 
@@ -155,7 +187,7 @@ unlock_and_exit:
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ev_delete_gpe_handlers
  *
@@ -190,7 +222,8 @@ acpi_ev_delete_gpe_handlers (
 		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
 			gpe_event_info = &gpe_block->event_info[(i * ACPI_GPE_REGISTER_WIDTH) + j];
 
-			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_HANDLER) {
+			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+					ACPI_GPE_DISPATCH_HANDLER) {
 				ACPI_MEM_FREE (gpe_event_info->dispatch.handler);
 				gpe_event_info->dispatch.handler = NULL;
 				gpe_event_info->flags &= ~ACPI_GPE_DISPATCH_MASK;
@@ -448,7 +481,7 @@ cleanup:
  *
  * FUNCTION:    acpi_ev_get_gpe_xrupt_block
  *
- * PARAMETERS:  interrupt_level     - Interrupt for a GPE block
+ * PARAMETERS:  interrupt_number     - Interrupt for a GPE block
  *
  * RETURN:      A GPE interrupt block
  *
@@ -461,21 +494,22 @@ cleanup:
 
 static struct acpi_gpe_xrupt_info *
 acpi_ev_get_gpe_xrupt_block (
-	u32                             interrupt_level)
+	u32                             interrupt_number)
 {
 	struct acpi_gpe_xrupt_info      *next_gpe_xrupt;
 	struct acpi_gpe_xrupt_info      *gpe_xrupt;
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("ev_get_gpe_xrupt_block");
 
 
-	/* No need for spin lock since we are not changing any list elements here */
+	/* No need for lock since we are not changing any list elements here */
 
 	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
 	while (next_gpe_xrupt) {
-		if (next_gpe_xrupt->interrupt_level == interrupt_level) {
+		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
 			return_PTR (next_gpe_xrupt);
 		}
 
@@ -489,11 +523,11 @@ acpi_ev_get_gpe_xrupt_block (
 		return_PTR (NULL);
 	}
 
-	gpe_xrupt->interrupt_level = interrupt_level;
+	gpe_xrupt->interrupt_number = interrupt_number;
 
 	/* Install new interrupt descriptor with spin lock */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	if (acpi_gbl_gpe_xrupt_list_head) {
 		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
 		while (next_gpe_xrupt->next) {
@@ -506,17 +540,17 @@ acpi_ev_get_gpe_xrupt_block (
 	else {
 		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt;
 	}
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 
 	/* Install new interrupt handler if not SCI_INT */
 
-	if (interrupt_level != acpi_gbl_FADT->sci_int) {
-		status = acpi_os_install_interrupt_handler (interrupt_level,
+	if (interrupt_number != acpi_gbl_FADT->sci_int) {
+		status = acpi_os_install_interrupt_handler (interrupt_number,
 				 acpi_ev_gpe_xrupt_handler, gpe_xrupt);
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not install GPE interrupt handler at level 0x%X\n",
-				interrupt_level));
+				interrupt_number));
 			return_PTR (NULL);
 		}
 	}
@@ -543,6 +577,7 @@ acpi_ev_delete_gpe_xrupt (
 	struct acpi_gpe_xrupt_info      *gpe_xrupt)
 {
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("ev_delete_gpe_xrupt");
@@ -550,14 +585,14 @@ acpi_ev_delete_gpe_xrupt (
 
 	/* We never want to remove the SCI interrupt handler */
 
-	if (gpe_xrupt->interrupt_level == acpi_gbl_FADT->sci_int) {
+	if (gpe_xrupt->interrupt_number == acpi_gbl_FADT->sci_int) {
 		gpe_xrupt->gpe_block_list_head = NULL;
 		return_ACPI_STATUS (AE_OK);
 	}
 
 	/* Disable this interrupt */
 
-	status = acpi_os_remove_interrupt_handler (gpe_xrupt->interrupt_level,
+	status = acpi_os_remove_interrupt_handler (gpe_xrupt->interrupt_number,
 			   acpi_ev_gpe_xrupt_handler);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -565,7 +600,7 @@ acpi_ev_delete_gpe_xrupt (
 
 	/* Unlink the interrupt block with lock */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	if (gpe_xrupt->previous) {
 		gpe_xrupt->previous->next = gpe_xrupt->next;
 	}
@@ -573,7 +608,7 @@ acpi_ev_delete_gpe_xrupt (
 	if (gpe_xrupt->next) {
 		gpe_xrupt->next->previous = gpe_xrupt->previous;
 	}
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 
 	/* Free the block */
 
@@ -587,7 +622,7 @@ acpi_ev_delete_gpe_xrupt (
  * FUNCTION:    acpi_ev_install_gpe_block
  *
  * PARAMETERS:  gpe_block       - New GPE block
- *              interrupt_level - Level to be associated with this GPE block
+ *              interrupt_number - Xrupt to be associated with this GPE block
  *
  * RETURN:      Status
  *
@@ -598,11 +633,12 @@ acpi_ev_delete_gpe_xrupt (
 static acpi_status
 acpi_ev_install_gpe_block (
 	struct acpi_gpe_block_info      *gpe_block,
-	u32                             interrupt_level)
+	u32                             interrupt_number)
 {
 	struct acpi_gpe_block_info      *next_gpe_block;
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_block;
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("ev_install_gpe_block");
@@ -613,15 +649,15 @@ acpi_ev_install_gpe_block (
 		return_ACPI_STATUS (status);
 	}
 
-	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block (interrupt_level);
+	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block (interrupt_number);
 	if (!gpe_xrupt_block) {
 		status = AE_NO_MEMORY;
 		goto unlock_and_exit;
 	}
 
-	/* Install the new block at the end of the list for this interrupt with lock */
+	/* Install the new block at the end of the list with lock */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	if (gpe_xrupt_block->gpe_block_list_head) {
 		next_gpe_block = gpe_xrupt_block->gpe_block_list_head;
 		while (next_gpe_block->next) {
@@ -636,7 +672,7 @@ acpi_ev_install_gpe_block (
 	}
 
 	gpe_block->xrupt_block = gpe_xrupt_block;
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 
 unlock_and_exit:
 	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
@@ -661,6 +697,7 @@ acpi_ev_delete_gpe_block (
 	struct acpi_gpe_block_info      *gpe_block)
 {
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("ev_install_gpe_block");
@@ -686,7 +723,7 @@ acpi_ev_delete_gpe_block (
 	else {
 		/* Remove the block on this interrupt with lock */
 
-		acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+		flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 		if (gpe_block->previous) {
 			gpe_block->previous->next = gpe_block->next;
 		}
@@ -697,7 +734,7 @@ acpi_ev_delete_gpe_block (
 		if (gpe_block->next) {
 			gpe_block->next->previous = gpe_block->previous;
 		}
-		acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+		acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 	}
 
 	/* Free the gpe_block */
@@ -756,10 +793,12 @@ acpi_ev_create_gpe_info_blocks (
 	 * per register.  Initialization to zeros is sufficient.
 	 */
 	gpe_event_info = ACPI_MEM_CALLOCATE (
-			   ((acpi_size) gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH) *
+			   ((acpi_size) gpe_block->register_count *
+			   ACPI_GPE_REGISTER_WIDTH) *
 			   sizeof (struct acpi_gpe_event_info));
 	if (!gpe_event_info) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not allocate the gpe_event_info table\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not allocate the gpe_event_info table\n"));
 		status = AE_NO_MEMORY;
 		goto error_exit;
 	}
@@ -851,7 +890,7 @@ error_exit:
  *              gpe_block_address   - Address and space_iD
  *              register_count      - Number of GPE register pairs in the block
  *              gpe_block_base_number - Starting GPE number for the block
- *              interrupt_level     - H/W interrupt for the block
+ *              interrupt_number    - H/W interrupt for the block
  *              return_gpe_block    - Where the new block descriptor is returned
  *
  * RETURN:      Status
@@ -866,7 +905,7 @@ acpi_ev_create_gpe_block (
 	struct acpi_generic_address     *gpe_block_address,
 	u32                             register_count,
 	u8                              gpe_block_base_number,
-	u32                             interrupt_level,
+	u32                             interrupt_number,
 	struct acpi_gpe_block_info      **return_gpe_block)
 {
 	struct acpi_gpe_block_info      *gpe_block;
@@ -899,7 +938,8 @@ acpi_ev_create_gpe_block (
 	gpe_block->block_base_number = gpe_block_base_number;
 	gpe_block->node           = gpe_device;
 
-	ACPI_MEMCPY (&gpe_block->block_address, gpe_block_address, sizeof (struct acpi_generic_address));
+	ACPI_MEMCPY (&gpe_block->block_address, gpe_block_address,
+		sizeof (struct acpi_generic_address));
 
 	/* Create the register_info and event_info sub-structures */
 
@@ -911,7 +951,7 @@ acpi_ev_create_gpe_block (
 
 	/* Install the new block in the global list(s) */
 
-	status = acpi_ev_install_gpe_block (gpe_block, interrupt_level);
+	status = acpi_ev_install_gpe_block (gpe_block, interrupt_number);
 	if (ACPI_FAILURE (status)) {
 		ACPI_MEM_FREE (gpe_block);
 		return_ACPI_STATUS (status);
@@ -976,7 +1016,7 @@ acpi_ev_create_gpe_block (
 				((gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH) -1)),
 		gpe_device->name.ascii,
 		gpe_block->register_count,
-		interrupt_level));
+		interrupt_number));
 
 	/* Enable all valid GPEs found above */
 
@@ -1061,8 +1101,9 @@ acpi_ev_gpe_initialize (
 
 		/* Install GPE Block 0 */
 
-		status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device, &acpi_gbl_FADT->xgpe0_blk,
-				 register_count0, 0, acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[0]);
+		status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device,
+				 &acpi_gbl_FADT->xgpe0_blk, register_count0, 0,
+				 acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[0]);
 
 		if (ACPI_FAILURE (status)) {
 			ACPI_REPORT_ERROR ((
@@ -1094,8 +1135,9 @@ acpi_ev_gpe_initialize (
 		else {
 			/* Install GPE Block 1 */
 
-			status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device, &acpi_gbl_FADT->xgpe1_blk,
-					 register_count1, acpi_gbl_FADT->gpe1_base,
+			status = acpi_ev_create_gpe_block (acpi_gbl_fadt_gpe_device,
+					 &acpi_gbl_FADT->xgpe1_blk, register_count1,
+					 acpi_gbl_FADT->gpe1_base,
 					 acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[1]);
 
 			if (ACPI_FAILURE (status)) {
@@ -1109,7 +1151,7 @@ acpi_ev_gpe_initialize (
 			 * space. However, GPE0 always starts at GPE number zero.
 			 */
 			gpe_number_max = acpi_gbl_FADT->gpe1_base +
-					   ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+					  ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
 		}
 	}
 
diff --git a/drivers/acpi/events/evmisc.c b/drivers/acpi/events/evmisc.c
--- a/drivers/acpi/events/evmisc.c
+++ b/drivers/acpi/events/evmisc.c
@@ -50,6 +50,35 @@
 	 ACPI_MODULE_NAME    ("evmisc")
 
 
+#ifdef ACPI_DEBUG_OUTPUT
+static const char                *acpi_notify_value_names[] =
+{
+	"Bus Check",
+	"Device Check",
+	"Device Wake",
+	"Eject request",
+	"Device Check Light",
+	"Frequency Mismatch",
+	"Bus Mode Mismatch",
+	"Power Fault"
+};
+#endif
+
+/* Local prototypes */
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_notify_dispatch (
+	void                            *context);
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_global_lock_thread (
+	void                            *context);
+
+static u32
+acpi_ev_global_lock_handler (
+	void                            *context);
+
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_is_notify_object
@@ -98,20 +127,6 @@ acpi_ev_is_notify_object (
  *
  ******************************************************************************/
 
-#ifdef ACPI_DEBUG_OUTPUT
-static const char                *acpi_notify_value_names[] =
-{
-	"Bus Check",
-	"Device Check",
-	"Device Wake",
-	"Eject request",
-	"Device Check Light",
-	"Frequency Mismatch",
-	"Bus Mode Mismatch",
-	"Power Fault"
-};
-#endif
-
 acpi_status
 acpi_ev_queue_notify_request (
 	struct acpi_namespace_node      *node,
@@ -128,9 +143,10 @@ acpi_ev_queue_notify_request (
 
 	/*
 	 * For value 3 (Ejection Request), some device method may need to be run.
-	 * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need to be run.
+	 * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need
+	 *   to be run.
 	 * For value 0x80 (Status Change) on the power button or sleep button,
-	 * initiate soft-off or sleep operation?
+	 *   initiate soft-off or sleep operation?
 	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 		"Dispatching Notify(%X) on node %p\n", notify_value, node));
@@ -140,8 +156,9 @@ acpi_ev_queue_notify_request (
 				acpi_notify_value_names[notify_value]));
 	}
 	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Notify value: 0x%2.2X **Device Specific**\n",
-				notify_value));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"Notify value: 0x%2.2X **Device Specific**\n",
+			notify_value));
 	}
 
 	/* Get the notify object attached to the NS Node */
@@ -210,7 +227,7 @@ acpi_ev_queue_notify_request (
  *
  * FUNCTION:    acpi_ev_notify_dispatch
  *
- * PARAMETERS:  Context         - To be passsed to the notify handler
+ * PARAMETERS:  Context         - To be passed to the notify handler
  *
  * RETURN:      None.
  *
@@ -219,7 +236,7 @@ acpi_ev_queue_notify_request (
  *
  ******************************************************************************/
 
-void ACPI_SYSTEM_XFACE
+static void ACPI_SYSTEM_XFACE
 acpi_ev_notify_dispatch (
 	void                            *context)
 {
@@ -234,7 +251,8 @@ acpi_ev_notify_dispatch (
 
 	/*
 	 * We will invoke a global notify handler if installed.
-	 * This is done _before_ we invoke the per-device handler attached to the device.
+	 * This is done _before_ we invoke the per-device handler attached
+	 * to the device.
 	 */
 	if (notify_info->notify.value <= ACPI_MAX_SYS_NOTIFY) {
 		/* Global system notification handler */
@@ -256,15 +274,17 @@ acpi_ev_notify_dispatch (
 	/* Invoke the system handler first, if present */
 
 	if (global_handler) {
-		global_handler (notify_info->notify.node, notify_info->notify.value, global_context);
+		global_handler (notify_info->notify.node, notify_info->notify.value,
+			global_context);
 	}
 
 	/* Now invoke the per-device handler, if present */
 
 	handler_obj = notify_info->notify.handler_obj;
 	if (handler_obj) {
-		handler_obj->notify.handler (notify_info->notify.node, notify_info->notify.value,
-				  handler_obj->notify.context);
+		handler_obj->notify.handler (notify_info->notify.node,
+			notify_info->notify.value,
+			handler_obj->notify.context);
 	}
 
 	/* All done with the info object */
@@ -370,7 +390,8 @@ acpi_ev_global_lock_handler (
  ******************************************************************************/
 
 acpi_status
-acpi_ev_init_global_lock_handler (void)
+acpi_ev_init_global_lock_handler (
+	void)
 {
 	acpi_status                     status;
 
@@ -380,7 +401,7 @@ acpi_ev_init_global_lock_handler (void)
 
 	acpi_gbl_global_lock_present = TRUE;
 	status = acpi_install_fixed_event_handler (ACPI_EVENT_GLOBAL,
-			  acpi_ev_global_lock_handler, NULL);
+			 acpi_ev_global_lock_handler, NULL);
 
 	/*
 	 * If the global lock does not exist on this platform, the attempt
@@ -390,6 +411,9 @@ acpi_ev_init_global_lock_handler (void)
 	 * with an error.
 	 */
 	if (status == AE_NO_HARDWARE_RESPONSE) {
+		ACPI_REPORT_ERROR ((
+			"No response from Global Lock hardware, disabling lock\n"));
+
 		acpi_gbl_global_lock_present = FALSE;
 		status = AE_OK;
 	}
@@ -433,8 +457,10 @@ acpi_ev_acquire_global_lock (
 
 	acpi_gbl_global_lock_thread_count++;
 
-	/* If we (OS side vs. BIOS side) have the hardware lock already, we are done */
-
+	/*
+	 * If we (OS side vs. BIOS side) have the hardware lock already,
+	 * we are done
+	 */
 	if (acpi_gbl_global_lock_acquired) {
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -480,7 +506,8 @@ acpi_ev_acquire_global_lock (
  ******************************************************************************/
 
 acpi_status
-acpi_ev_release_global_lock (void)
+acpi_ev_release_global_lock (
+	void)
 {
 	u8                              pending = FALSE;
 	acpi_status                     status = AE_OK;
@@ -490,7 +517,8 @@ acpi_ev_release_global_lock (void)
 
 
 	if (!acpi_gbl_global_lock_thread_count) {
-		ACPI_REPORT_WARNING(("Cannot release HW Global Lock, it has not been acquired\n"));
+		ACPI_REPORT_WARNING((
+			"Cannot release HW Global Lock, it has not been acquired\n"));
 		return_ACPI_STATUS (AE_NOT_ACQUIRED);
 	}
 
@@ -515,7 +543,8 @@ acpi_ev_release_global_lock (void)
 	 * register
 	 */
 	if (pending) {
-		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE, 1, ACPI_MTX_LOCK);
+		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE,
+				 1, ACPI_MTX_LOCK);
 	}
 
 	return_ACPI_STATUS (status);
@@ -535,7 +564,8 @@ acpi_ev_release_global_lock (void)
  ******************************************************************************/
 
 void
-acpi_ev_terminate (void)
+acpi_ev_terminate (
+	void)
 {
 	acpi_native_uint                i;
 	acpi_status                     status;
@@ -555,25 +585,27 @@ acpi_ev_terminate (void)
 		for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
 			status = acpi_disable_event ((u32) i, 0);
 			if (ACPI_FAILURE (status)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not disable fixed event %d\n", (u32) i));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Could not disable fixed event %d\n", (u32) i));
 			}
 		}
 
 		/* Disable all GPEs in all GPE blocks */
 
-		status = acpi_ev_walk_gpe_list (acpi_hw_disable_gpe_block, ACPI_NOT_ISR);
+		status = acpi_ev_walk_gpe_list (acpi_hw_disable_gpe_block);
 
 		/* Remove SCI handler */
 
 		status = acpi_ev_remove_sci_handler ();
 		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not remove SCI handler\n"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not remove SCI handler\n"));
 		}
 	}
 
 	/* Deallocate all handler objects installed within GPE info structs */
 
-	status = acpi_ev_walk_gpe_list (acpi_ev_delete_gpe_handlers, ACPI_NOT_ISR);
+	status = acpi_ev_walk_gpe_list (acpi_ev_delete_gpe_handlers);
 
 	/* Return to original mode if necessary */
 
diff --git a/drivers/acpi/events/evregion.c b/drivers/acpi/events/evregion.c
--- a/drivers/acpi/events/evregion.c
+++ b/drivers/acpi/events/evregion.c
@@ -58,6 +58,22 @@ static u8                   acpi_gbl_def
 			 ACPI_ADR_SPACE_PCI_CONFIG,
 			 ACPI_ADR_SPACE_DATA_TABLE};
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ev_reg_run (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+static acpi_status
+acpi_ev_install_handler (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
@@ -179,8 +195,8 @@ acpi_ev_initialize_op_regions (
  *
  * FUNCTION:    acpi_ev_execute_reg_method
  *
- * PARAMETERS:  region_obj          - Object structure
- *              Function            - Passed to _REG:  On (1) or Off (0)
+ * PARAMETERS:  region_obj          - Region object
+ *              Function            - Passed to _REG: On (1) or Off (0)
  *
  * RETURN:      Status
  *
@@ -323,14 +339,16 @@ acpi_ev_address_space_dispatch (
 		if (!region_setup) {
 			/* No initialization routine, exit with error */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No init routine for region(%p) [%s]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"No init routine for region(%p) [%s]\n",
 				region_obj, acpi_ut_get_region_name (region_obj->region.space_id)));
 			return_ACPI_STATUS (AE_NOT_EXIST);
 		}
 
 		/*
-		 * We must exit the interpreter because the region setup will potentially
-		 * execute control methods (e.g., _REG method for this region)
+		 * We must exit the interpreter because the region
+		 * setup will potentially execute control methods
+		 * (e.g., _REG method for this region)
 		 */
 		acpi_ex_exit_interpreter ();
 
@@ -621,7 +639,7 @@ acpi_ev_attach_region (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_install_handler (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -848,7 +866,8 @@ acpi_ev_install_space_handler (
 				if (handler_obj->address_space.handler == handler) {
 					/*
 					 * It is (relatively) OK to attempt to install the SAME
-					 * handler twice. This can easily happen with PCI_Config space.
+					 * handler twice. This can easily happen
+					 * with PCI_Config space.
 					 */
 					status = AE_SAME_HANDLER;
 					goto unlock_and_exit;
@@ -1011,7 +1030,7 @@ acpi_ev_execute_reg_methods (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ev_reg_run (
 	acpi_handle                     obj_handle,
 	u32                             level,
diff --git a/drivers/acpi/events/evrgnini.c b/drivers/acpi/events/evrgnini.c
--- a/drivers/acpi/events/evrgnini.c
+++ b/drivers/acpi/events/evrgnini.c
@@ -61,7 +61,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling, a nop for now
+ * DESCRIPTION: Setup a system_memory operation region
  *
  ******************************************************************************/
 
@@ -115,7 +115,7 @@ acpi_ev_system_memory_region_setup (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a IO operation region
  *
  ******************************************************************************/
 
@@ -144,14 +144,14 @@ acpi_ev_io_space_region_setup (
  *
  * FUNCTION:    acpi_ev_pci_config_region_setup
  *
- * PARAMETERS:  Handle             - Region we are interested in
+ * PARAMETERS:  Handle              - Region we are interested in
  *              Function            - Start or stop
  *              handler_context     - Address space handler context
  *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a PCI_Config operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -218,10 +218,14 @@ acpi_ev_pci_config_region_setup (
 		while (pci_root_node != acpi_gbl_root_node) {
 			status = acpi_ut_execute_HID (pci_root_node, &object_hID);
 			if (ACPI_SUCCESS (status)) {
-				/* Got a valid _HID, check if this is a PCI root */
-
+				/*
+				 * Got a valid _HID string, check if this is a PCI root.
+				 * New for ACPI 3.0: check for a PCI Express root also.
+				 */
 				if (!(ACPI_STRNCMP (object_hID.value, PCI_ROOT_HID_STRING,
-						   sizeof (PCI_ROOT_HID_STRING)))) {
+						   sizeof (PCI_ROOT_HID_STRING))           ||
+					!(ACPI_STRNCMP (object_hID.value, PCI_EXPRESS_ROOT_HID_STRING,
+							  sizeof (PCI_EXPRESS_ROOT_HID_STRING))))) {
 					/* Install a handler for this PCI root bridge */
 
 					status = acpi_install_address_space_handler ((acpi_handle) pci_root_node,
@@ -324,7 +328,7 @@ acpi_ev_pci_config_region_setup (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a pci_bAR operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -355,7 +359,7 @@ acpi_ev_pci_bar_region_setup (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Setup a CMOS operation region
  *
  * MUTEX:       Assumes namespace is not locked
  *
@@ -386,7 +390,7 @@ acpi_ev_cmos_region_setup (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Do any prep work for region handling
+ * DESCRIPTION: Default region initialization
  *
  ******************************************************************************/
 
diff --git a/drivers/acpi/events/evsci.c b/drivers/acpi/events/evsci.c
--- a/drivers/acpi/events/evsci.c
+++ b/drivers/acpi/events/evsci.c
@@ -49,6 +49,12 @@
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evsci")
 
+/* Local prototypes */
+
+static u32 ACPI_SYSTEM_XFACE
+acpi_ev_sci_xrupt_handler (
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -146,7 +152,8 @@ acpi_ev_gpe_xrupt_handler (
  ******************************************************************************/
 
 u32
-acpi_ev_install_sci_handler (void)
+acpi_ev_install_sci_handler (
+	void)
 {
 	u32                             status = AE_OK;
 
@@ -180,7 +187,8 @@ acpi_ev_install_sci_handler (void)
  ******************************************************************************/
 
 acpi_status
-acpi_ev_remove_sci_handler (void)
+acpi_ev_remove_sci_handler (
+	void)
 {
 	acpi_status                     status;
 
diff --git a/drivers/acpi/events/evxface.c b/drivers/acpi/events/evxface.c
--- a/drivers/acpi/events/evxface.c
+++ b/drivers/acpi/events/evxface.c
@@ -64,6 +64,7 @@
  * DESCRIPTION: Saves the pointer to the handler function
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_install_exception_handler (
@@ -457,7 +458,8 @@ acpi_remove_notify_handler (
 	/* Root Object */
 
 	if (device == ACPI_ROOT_OBJECT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing notify handler for ROOT object.\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"Removing notify handler for ROOT object.\n"));
 
 		if (((handler_type & ACPI_SYSTEM_NOTIFY) &&
 			  !acpi_gbl_system_notify.handler)      ||
@@ -564,8 +566,9 @@ EXPORT_SYMBOL(acpi_remove_notify_handler
  *
  * FUNCTION:    acpi_install_gpe_handler
  *
- * PARAMETERS:  gpe_number      - The GPE number within the GPE block
- *              gpe_block       - GPE block (NULL == FADT GPEs)
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The GPE number within the GPE block
  *              Type            - Whether this GPE should be treated as an
  *                                edge- or level-triggered interrupt.
  *              Address         - Address of the handler
@@ -588,6 +591,7 @@ acpi_install_gpe_handler (
 	struct acpi_gpe_event_info      *gpe_event_info;
 	struct acpi_handler_info        *handler;
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_install_gpe_handler");
@@ -640,7 +644,7 @@ acpi_install_gpe_handler (
 
 	/* Install the handler */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	gpe_event_info->dispatch.handler = handler;
 
 	/* Setup up dispatch flags to indicate handler (vs. method) */
@@ -648,7 +652,7 @@ acpi_install_gpe_handler (
 	gpe_event_info->flags &= ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK); /* Clear bits */
 	gpe_event_info->flags |= (u8) (type | ACPI_GPE_DISPATCH_HANDLER);
 
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 
 
 unlock_and_exit:
@@ -662,8 +666,9 @@ EXPORT_SYMBOL(acpi_install_gpe_handler);
  *
  * FUNCTION:    acpi_remove_gpe_handler
  *
- * PARAMETERS:  gpe_number      - The event to remove a handler
- *              gpe_block       - GPE block (NULL == FADT GPEs)
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The event to remove a handler
  *              Address         - Address of the handler
  *
  * RETURN:      Status
@@ -681,6 +686,7 @@ acpi_remove_gpe_handler (
 	struct acpi_gpe_event_info      *gpe_event_info;
 	struct acpi_handler_info        *handler;
 	acpi_status                     status;
+	u32                             flags;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_remove_gpe_handler");
@@ -737,7 +743,7 @@ acpi_remove_gpe_handler (
 
 	/* Remove the handler */
 
-	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	flags = acpi_os_acquire_lock (acpi_gbl_gpe_lock);
 	handler = gpe_event_info->dispatch.handler;
 
 	/* Restore Method node (if any), set dispatch flags */
@@ -747,7 +753,7 @@ acpi_remove_gpe_handler (
 	if (handler->method_node) {
 		gpe_event_info->flags |= ACPI_GPE_DISPATCH_METHOD;
 	}
-	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	acpi_os_release_lock (acpi_gbl_gpe_lock, flags);
 
 	/* Now we can free the handler object */
 
@@ -766,7 +772,8 @@ EXPORT_SYMBOL(acpi_remove_gpe_handler);
  * FUNCTION:    acpi_acquire_global_lock
  *
  * PARAMETERS:  Timeout         - How long the caller is willing to wait
- *              out_handle      - A handle to the lock if acquired
+ *              Handle          - Where the handle to the lock is returned
+ *                                (if acquired)
  *
  * RETURN:      Status
  *
@@ -812,7 +819,7 @@ EXPORT_SYMBOL(acpi_acquire_global_lock);
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Release the ACPI Global Lock
+ * DESCRIPTION: Release the ACPI Global Lock. The handle must be valid.
  *
  ******************************************************************************/
 
diff --git a/drivers/acpi/events/evxfevnt.c b/drivers/acpi/events/evxfevnt.c
--- a/drivers/acpi/events/evxfevnt.c
+++ b/drivers/acpi/events/evxfevnt.c
@@ -64,7 +64,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_enable (void)
+acpi_enable (
+	void)
 {
 	acpi_status                     status = AE_OK;
 
@@ -91,7 +92,8 @@ acpi_enable (void)
 			return_ACPI_STATUS (status);
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Transition to ACPI mode successful\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+			"Transition to ACPI mode successful\n"));
 	}
 
 	return_ACPI_STATUS (status);
@@ -106,12 +108,13 @@ acpi_enable (void)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Transfers the system into LEGACY mode.
+ * DESCRIPTION: Transfers the system into LEGACY (non-ACPI) mode.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_disable (void)
+acpi_disable (
+	void)
 {
 	acpi_status                     status = AE_OK;
 
@@ -125,7 +128,8 @@ acpi_disable (void)
 	}
 
 	if (acpi_hw_get_mode() == ACPI_SYS_MODE_LEGACY) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "System is already in legacy (non-ACPI) mode\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+			"System is already in legacy (non-ACPI) mode\n"));
 	}
 	else {
 		/* Transition to LEGACY mode */
@@ -133,7 +137,8 @@ acpi_disable (void)
 		status = acpi_hw_set_mode (ACPI_SYS_MODE_LEGACY);
 
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not exit ACPI mode to legacy mode"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not exit ACPI mode to legacy mode"));
 			return_ACPI_STATUS (status);
 		}
 
@@ -214,7 +219,7 @@ EXPORT_SYMBOL(acpi_enable_event);
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable an ACPI event (general purpose)
+ * DESCRIPTION: Set the type of an individual GPE
  *
  ******************************************************************************/
 
@@ -519,13 +524,12 @@ unlock_and_exit:
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_get_event_status
  *
  * PARAMETERS:  Event           - The fixed event
- *              Event Status    - Where the current status of the event will
+ *              event_status    - Where the current status of the event will
  *                                be returned
  *
  * RETURN:      Status
@@ -571,7 +575,7 @@ acpi_get_event_status (
  * PARAMETERS:  gpe_device      - Parent GPE Device
  *              gpe_number      - GPE level within the GPE block
  *              Flags           - Called from an ISR or not
- *              Event Status    - Where the current status of the event will
+ *              event_status    - Where the current status of the event will
  *                                be returned
  *
  * RETURN:      Status
@@ -631,7 +635,7 @@ unlock_and_exit:
  * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device
  *              gpe_block_address   - Address and space_iD
  *              register_count      - Number of GPE register pairs in the block
- *              interrupt_level     - H/W interrupt for the block
+ *              interrupt_number    - H/W interrupt for the block
  *
  * RETURN:      Status
  *
@@ -644,7 +648,7 @@ acpi_install_gpe_block (
 	acpi_handle                     gpe_device,
 	struct acpi_generic_address     *gpe_block_address,
 	u32                             register_count,
-	u32                             interrupt_level)
+	u32                             interrupt_number)
 {
 	acpi_status                     status;
 	union acpi_operand_object       *obj_desc;
@@ -677,7 +681,7 @@ acpi_install_gpe_block (
 	 * is always zero
 	 */
 	status = acpi_ev_create_gpe_block (node, gpe_block_address, register_count,
-			  0, interrupt_level, &gpe_block);
+			  0, interrupt_number, &gpe_block);
 	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
@@ -775,4 +779,5 @@ unlock_and_exit:
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
+
 EXPORT_SYMBOL(acpi_remove_gpe_block);
diff --git a/drivers/acpi/executer/exconfig.c b/drivers/acpi/executer/exconfig.c
--- a/drivers/acpi/executer/exconfig.c
+++ b/drivers/acpi/executer/exconfig.c
@@ -54,6 +54,14 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exconfig")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_add_table (
+	struct acpi_table_header        *table,
+	struct acpi_namespace_node      *parent_node,
+	union acpi_operand_object       **ddb_handle);
+
 
 /*******************************************************************************
  *
@@ -70,7 +78,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_add_table (
 	struct acpi_table_header        *table,
 	struct acpi_namespace_node      *parent_node,
@@ -91,17 +99,29 @@ acpi_ex_add_table (
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	/* Init the table handle */
+
+	obj_desc->reference.opcode = AML_LOAD_OP;
+	*ddb_handle = obj_desc;
+
 	/* Install the new table into the local data structures */
 
 	ACPI_MEMSET (&table_info, 0, sizeof (struct acpi_table_desc));
 
-	table_info.type        = ACPI_TABLE_SSDT;
-	table_info.pointer     = table;
-	table_info.length      = (acpi_size) table->length;
-	table_info.allocation  = ACPI_MEM_ALLOCATED;
+	table_info.type      = ACPI_TABLE_SSDT;
+	table_info.pointer   = table;
+	table_info.length    = (acpi_size) table->length;
+	table_info.allocation = ACPI_MEM_ALLOCATED;
 
 	status = acpi_tb_install_table (&table_info);
+	obj_desc->reference.object = table_info.installed_desc;
+
 	if (ACPI_FAILURE (status)) {
+		if (status == AE_ALREADY_EXISTS) {
+			/* Table already exists, just return the handle */
+
+			return_ACPI_STATUS (AE_OK);
+		}
 		goto cleanup;
 	}
 
@@ -115,16 +135,12 @@ acpi_ex_add_table (
 		goto cleanup;
 	}
 
-	/* Init the table handle */
-
-	obj_desc->reference.opcode = AML_LOAD_OP;
-	obj_desc->reference.object = table_info.installed_desc;
-	*ddb_handle = obj_desc;
 	return_ACPI_STATUS (AE_OK);
 
 
 cleanup:
 	acpi_ut_remove_reference (obj_desc);
+	*ddb_handle = NULL;
 	return_ACPI_STATUS (status);
 }
 
@@ -226,11 +242,10 @@ acpi_ex_load_table_op (
 			start_node = parent_node;
 		}
 
-		/*
-		 * Find the node referenced by the parameter_path_string
-		 */
+		/* Find the node referenced by the parameter_path_string */
+
 		status = acpi_ns_get_node_by_path (operand[4]->string.pointer, start_node,
-				   ACPI_NS_SEARCH_PARENT, &parameter_node);
+				 ACPI_NS_SEARCH_PARENT, &parameter_node);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -248,7 +263,8 @@ acpi_ex_load_table_op (
 	if (parameter_node) {
 		/* Store the parameter data into the optional parameter object */
 
-		status = acpi_ex_store (operand[5], ACPI_CAST_PTR (union acpi_operand_object, parameter_node),
+		status = acpi_ex_store (operand[5],
+				 ACPI_CAST_PTR (union acpi_operand_object, parameter_node),
 				 walk_state);
 		if (ACPI_FAILURE (status)) {
 			(void) acpi_ex_unload_table (ddb_handle);
@@ -368,15 +384,22 @@ acpi_ex_load_op (
 		 */
 		status = acpi_ex_read_data_from_field (walk_state, obj_desc, &buffer_desc);
 		if (ACPI_FAILURE (status)) {
-			goto cleanup;
+			return_ACPI_STATUS (status);
 		}
 
-		table_ptr = ACPI_CAST_PTR (struct acpi_table_header, buffer_desc->buffer.pointer);
+		table_ptr = ACPI_CAST_PTR (struct acpi_table_header,
+				  buffer_desc->buffer.pointer);
+
+		/* All done with the buffer_desc, delete it */
 
-		 /* Sanity check the table length */
+		buffer_desc->buffer.pointer = NULL;
+		acpi_ut_remove_reference (buffer_desc);
+
+		/* Sanity check the table length */
 
 		if (table_ptr->length < sizeof (struct acpi_table_header)) {
-			return_ACPI_STATUS (AE_BAD_HEADER);
+			status = AE_BAD_HEADER;
+			goto cleanup;
 		}
 		break;
 
@@ -404,7 +427,9 @@ acpi_ex_load_op (
 
 	status = acpi_ex_add_table (table_ptr, acpi_gbl_root_node, &ddb_handle);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup;
+		/* On error, table_ptr was deallocated above */
+
+		return_ACPI_STATUS (status);
 	}
 
 	/* Store the ddb_handle into the Target operand */
@@ -412,17 +437,14 @@ acpi_ex_load_op (
 	status = acpi_ex_store (ddb_handle, target, walk_state);
 	if (ACPI_FAILURE (status)) {
 		(void) acpi_ex_unload_table (ddb_handle);
-	}
 
-	return_ACPI_STATUS (status);
+		/* table_ptr was deallocated above */
 
+		return_ACPI_STATUS (status);
+	}
 
 cleanup:
-
-	if (buffer_desc) {
-		acpi_ut_remove_reference (buffer_desc);
-	}
-	else {
+	if (ACPI_FAILURE (status)) {
 		ACPI_MEM_FREE (table_ptr);
 	}
 	return_ACPI_STATUS (status);
@@ -473,7 +495,8 @@ acpi_ex_unload_table (
 	 * Delete the entire namespace under this table Node
 	 * (Offset contains the table_id)
 	 */
-	acpi_ns_delete_namespace_by_owner (table_info->table_id);
+	acpi_ns_delete_namespace_by_owner (table_info->owner_id);
+	acpi_ut_release_owner_id (&table_info->owner_id);
 
 	/* Delete the table itself */
 
diff --git a/drivers/acpi/executer/exconvrt.c b/drivers/acpi/executer/exconvrt.c
--- a/drivers/acpi/executer/exconvrt.c
+++ b/drivers/acpi/executer/exconvrt.c
@@ -50,6 +50,15 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exconvrt")
 
+/* Local prototypes */
+
+static u32
+acpi_ex_convert_to_ascii (
+	acpi_integer                    integer,
+	u16                             base,
+	u8                              *string,
+	u8                              max_length);
+
 
 /*******************************************************************************
  *
@@ -115,9 +124,8 @@ acpi_ex_convert_to_integer (
 	 */
 	result = 0;
 
-	/*
-	 * String conversion is different than Buffer conversion
-	 */
+	/* String conversion is different than Buffer conversion */
+
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_STRING:
 
@@ -168,9 +176,8 @@ acpi_ex_convert_to_integer (
 		break;
 	}
 
-	/*
-	 * Create a new integer
-	 */
+	/* Create a new integer */
+
 	return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 	if (!return_desc) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
@@ -251,7 +258,8 @@ acpi_ex_convert_to_buffer (
 		 * ASL/AML code that depends on the null being transferred to the new
 		 * buffer.
 		 */
-		return_desc = acpi_ut_create_buffer_object ((acpi_size) obj_desc->string.length + 1);
+		return_desc = acpi_ut_create_buffer_object (
+				  (acpi_size) obj_desc->string.length + 1);
 		if (!return_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -291,7 +299,7 @@ acpi_ex_convert_to_buffer (
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ex_convert_to_ascii (
 	acpi_integer                    integer,
 	u16                             base,
@@ -357,8 +365,9 @@ acpi_ex_convert_to_ascii (
 
 	case 16:
 
-		hex_length = ACPI_MUL_2 (data_width); /* 2 ascii hex chars per data byte */
+		/* hex_length: 2 ascii hex chars per data byte */
 
+		hex_length = (acpi_native_uint) ACPI_MUL_2 (data_width);
 		for (i = 0, j = (hex_length-1); i < hex_length; i++, j--) {
 			/* Get one hex digit, most significant digits first */
 
@@ -475,7 +484,7 @@ acpi_ex_convert_to_string (
 		/* Setup string length, base, and separator */
 
 		switch (type) {
-		case ACPI_EXPLICIT_CONVERT_DECIMAL: /* Used by to_decimal_string operator */
+		case ACPI_EXPLICIT_CONVERT_DECIMAL: /* Used by to_decimal_string */
 			/*
 			 * From ACPI: "If Data is a buffer, it is converted to a string of
 			 * decimal values separated by commas."
@@ -509,7 +518,7 @@ acpi_ex_convert_to_string (
 			string_length = (obj_desc->buffer.length * 3);
 			break;
 
-		case ACPI_EXPLICIT_CONVERT_HEX:     /* Used by to_hex_string operator */
+		case ACPI_EXPLICIT_CONVERT_HEX:     /* Used by to_hex_string */
 			/*
 			 * From ACPI: "If Data is a buffer, it is converted to a string of
 			 * hexadecimal values separated by commas."
@@ -530,9 +539,8 @@ acpi_ex_convert_to_string (
 			return_ACPI_STATUS (AE_AML_STRING_LIMIT);
 		}
 
-		/*
-		 * Create a new string object and string buffer
-		 */
+		/* Create a new string object and string buffer */
+
 		return_desc = acpi_ut_create_string_object ((acpi_size) string_length);
 		if (!return_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
@@ -551,8 +559,10 @@ acpi_ex_convert_to_string (
 			*new_buf++ = separator; /* each separated by a comma or space */
 		}
 
-		/* Null terminate the string (overwrites final comma/space from above) */
-
+		/*
+		 * Null terminate the string
+		 * (overwrites final comma/space from above)
+		 */
 		new_buf--;
 		*new_buf = 0;
 		break;
@@ -645,7 +655,6 @@ acpi_ex_convert_to_target_type (
 
 
 		case ACPI_TYPE_STRING:
-
 			/*
 			 * The operand must be a String.  We can convert an
 			 * Integer or Buffer if necessary
@@ -656,7 +665,6 @@ acpi_ex_convert_to_target_type (
 
 
 		case ACPI_TYPE_BUFFER:
-
 			/*
 			 * The operand must be a Buffer.  We can convert an
 			 * Integer or String if necessary
diff --git a/drivers/acpi/executer/excreate.c b/drivers/acpi/executer/excreate.c
--- a/drivers/acpi/executer/excreate.c
+++ b/drivers/acpi/executer/excreate.c
@@ -55,7 +55,7 @@
 
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_alias
  *
@@ -65,7 +65,7 @@
  *
  * DESCRIPTION: Create a new named alias
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_alias (
@@ -140,8 +140,7 @@ acpi_ex_create_alias (
 		 * target node or the alias Node
 		 */
 		status = acpi_ns_attach_object (alias_node,
-				 acpi_ns_get_attached_object (target_node),
-				 target_node->type);
+				 acpi_ns_get_attached_object (target_node), target_node->type);
 		break;
 	}
 
@@ -151,7 +150,7 @@ acpi_ex_create_alias (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_event
  *
@@ -161,7 +160,7 @@ acpi_ex_create_alias (
  *
  * DESCRIPTION: Create a new event object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_event (
@@ -185,7 +184,7 @@ acpi_ex_create_event (
 	 * that the event is created in an unsignalled state
 	 */
 	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 0,
-			   &obj_desc->event.semaphore);
+			 &obj_desc->event.semaphore);
 	if (ACPI_FAILURE (status)) {
 		goto cleanup;
 	}
@@ -193,7 +192,7 @@ acpi_ex_create_event (
 	/* Attach object to the Node */
 
 	status = acpi_ns_attach_object ((struct acpi_namespace_node *) walk_state->operands[0],
-			   obj_desc, ACPI_TYPE_EVENT);
+			 obj_desc, ACPI_TYPE_EVENT);
 
 cleanup:
 	/*
@@ -205,7 +204,7 @@ cleanup:
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_mutex
  *
@@ -217,7 +216,7 @@ cleanup:
  *
  *              Mutex (Name[0], sync_level[1])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_mutex (
@@ -267,20 +266,20 @@ cleanup:
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_region
  *
  * PARAMETERS:  aml_start           - Pointer to the region declaration AML
  *              aml_length          - Max length of the declaration AML
- *              Operands            - List of operands for the opcode
+ *              region_space        - space_iD for the region
  *              walk_state          - Current state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Create a new operation region object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_region (
@@ -321,7 +320,7 @@ acpi_ex_create_region (
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Region Type - %s (%X)\n",
-			  acpi_ut_get_region_name (region_space), region_space));
+		acpi_ut_get_region_name (region_space), region_space));
 
 	/* Create the region descriptor */
 
@@ -360,7 +359,7 @@ cleanup:
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_table_region
  *
@@ -370,7 +369,7 @@ cleanup:
  *
  * DESCRIPTION: Create a new data_table_region object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_table_region (
@@ -455,7 +454,7 @@ cleanup:
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_processor
  *
@@ -467,7 +466,7 @@ cleanup:
  *
  *              Processor (Name[0], cpu_iD[1], pblock_addr[2], pblock_length[3])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_processor (
@@ -488,9 +487,8 @@ acpi_ex_create_processor (
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Initialize the processor object from the operands
-	 */
+	/* Initialize the processor object from the operands */
+
 	obj_desc->processor.proc_id = (u8)          operand[1]->integer.value;
 	obj_desc->processor.address = (acpi_io_address) operand[2]->integer.value;
 	obj_desc->processor.length = (u8)           operand[3]->integer.value;
@@ -507,7 +505,7 @@ acpi_ex_create_processor (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_power_resource
  *
@@ -519,7 +517,7 @@ acpi_ex_create_processor (
  *
  *              power_resource (Name[0], system_level[1], resource_order[2])
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_power_resource (
@@ -555,10 +553,10 @@ acpi_ex_create_power_resource (
 	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
-
 #endif
 
-/*****************************************************************************
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_create_method
  *
@@ -570,7 +568,7 @@ acpi_ex_create_power_resource (
  *
  * DESCRIPTION: Create a new method object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_create_method (
diff --git a/drivers/acpi/executer/exdump.c b/drivers/acpi/executer/exdump.c
--- a/drivers/acpi/executer/exdump.c
+++ b/drivers/acpi/executer/exdump.c
@@ -51,23 +51,57 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exdump")
 
-
 /*
  * The following routines are used for debug output only
  */
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
-/*****************************************************************************
+/* Local prototypes */
+
+#ifdef ACPI_FUTURE_USAGE
+static void
+acpi_ex_out_string (
+	char                            *title,
+	char                            *value);
+
+static void
+acpi_ex_out_pointer (
+	char                            *title,
+	void                            *value);
+
+static void
+acpi_ex_out_integer (
+	char                            *title,
+	u32                             value);
+
+static void
+acpi_ex_out_address (
+	char                            *title,
+	acpi_physical_address           value);
+
+static void
+acpi_ex_dump_reference (
+	union acpi_operand_object       *obj_desc);
+
+static void
+acpi_ex_dump_package (
+	union acpi_operand_object       *obj_desc,
+	u32                             level,
+	u32                             index);
+#endif	/* ACPI_FUTURE_USAGE */
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_operand
  *
- * PARAMETERS:  *obj_desc         - Pointer to entry to be dumped
+ * PARAMETERS:  *obj_desc       - Pointer to entry to be dumped
+ *              Depth           - Current nesting depth
  *
  * RETURN:      None
  *
  * DESCRIPTION: Dump an operand object
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_operand (
@@ -86,15 +120,14 @@ acpi_ex_dump_operand (
 	}
 
 	if (!obj_desc) {
-		/*
-		 * This could be a null element of a package
-		 */
+		/* This could be a null element of a package */
+
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Null Object Descriptor\n"));
 		return;
 	}
 
 	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p is a NS Node: ", obj_desc));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p Namespace Node: ", obj_desc));
 		ACPI_DUMP_ENTRY (obj_desc, ACPI_LV_EXEC);
 		return;
 	}
@@ -117,6 +150,8 @@ acpi_ex_dump_operand (
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p ", obj_desc));
 	}
 
+	/* Decode object type */
+
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_LOCAL_REFERENCE:
 
@@ -274,7 +309,9 @@ acpi_ex_dump_operand (
 	case ACPI_TYPE_STRING:
 
 		acpi_os_printf ("String length %X @ %p ",
-			obj_desc->string.length, obj_desc->string.pointer);
+			obj_desc->string.length,
+			obj_desc->string.pointer);
+
 		acpi_ut_print_string (obj_desc->string.pointer, ACPI_UINT8_MAX);
 		acpi_os_printf ("\n");
 		break;
@@ -290,10 +327,13 @@ acpi_ex_dump_operand (
 
 		acpi_os_printf (
 			"region_field: Bits=%X acc_width=%X Lock=%X Update=%X at byte=%X bit=%X of below:\n",
-			obj_desc->field.bit_length, obj_desc->field.access_byte_width,
+			obj_desc->field.bit_length,
+			obj_desc->field.access_byte_width,
 			obj_desc->field.field_flags & AML_FIELD_LOCK_RULE_MASK,
 			obj_desc->field.field_flags & AML_FIELD_UPDATE_RULE_MASK,
-			obj_desc->field.base_byte_offset, obj_desc->field.start_field_bit_offset);
+			obj_desc->field.base_byte_offset,
+			obj_desc->field.start_field_bit_offset);
+
 		acpi_ex_dump_operand (obj_desc->field.region_obj, depth+1);
 		break;
 
@@ -308,13 +348,15 @@ acpi_ex_dump_operand (
 
 		acpi_os_printf (
 			"buffer_field: %X bits at byte %X bit %X of \n",
-			obj_desc->buffer_field.bit_length, obj_desc->buffer_field.base_byte_offset,
+			obj_desc->buffer_field.bit_length,
+			obj_desc->buffer_field.base_byte_offset,
 			obj_desc->buffer_field.start_field_bit_offset);
 
 		if (!obj_desc->buffer_field.buffer_obj) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*NULL* \n"));
 		}
-		else if (ACPI_GET_OBJECT_TYPE (obj_desc->buffer_field.buffer_obj) != ACPI_TYPE_BUFFER) {
+		else if (ACPI_GET_OBJECT_TYPE (obj_desc->buffer_field.buffer_obj) !=
+				 ACPI_TYPE_BUFFER) {
 			acpi_os_printf ("*not a Buffer* \n");
 		}
 		else {
@@ -331,10 +373,10 @@ acpi_ex_dump_operand (
 
 	case ACPI_TYPE_METHOD:
 
-		acpi_os_printf (
-			"Method(%X) @ %p:%X\n",
+		acpi_os_printf ("Method(%X) @ %p:%X\n",
 			obj_desc->method.param_count,
-			obj_desc->method.aml_start, obj_desc->method.aml_length);
+			obj_desc->method.aml_start,
+			obj_desc->method.aml_length);
 		break;
 
 
@@ -379,7 +421,7 @@ acpi_ex_dump_operand (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_operands
  *
@@ -393,7 +435,7 @@ acpi_ex_dump_operand (
  *
  * DESCRIPTION: Dump the object stack
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_operands (
@@ -434,17 +476,16 @@ acpi_ex_dump_operands (
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"************* Stack dump from %s(%d), %s\n",
+		"************* Operand Stack dump from %s(%d), %s\n",
 		module_name, line_number, note));
 	return;
 }
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*****************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    acpi_ex_out*
+ * FUNCTION:    acpi_ex_out* functions
  *
  * PARAMETERS:  Title               - Descriptive text
  *              Value               - Value to be displayed
@@ -453,9 +494,9 @@ acpi_ex_dump_operands (
  *              reduce the number of format strings required and keeps them
  *              all in one place for easy modification.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-void
+static void
 acpi_ex_out_string (
 	char                            *title,
 	char                            *value)
@@ -463,7 +504,7 @@ acpi_ex_out_string (
 	acpi_os_printf ("%20s : %s\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_pointer (
 	char                            *title,
 	void                            *value)
@@ -471,15 +512,15 @@ acpi_ex_out_pointer (
 	acpi_os_printf ("%20s : %p\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_integer (
 	char                            *title,
 	u32                             value)
 {
-	acpi_os_printf ("%20s : %X\n", title, value);
+	acpi_os_printf ("%20s : %.2X\n", title, value);
 }
 
-void
+static void
 acpi_ex_out_address (
 	char                            *title,
 	acpi_physical_address           value)
@@ -493,16 +534,16 @@ acpi_ex_out_address (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_node
  *
  * PARAMETERS:  *Node               - Descriptor to dump
- *              Flags               - Force display
+ *              Flags               - Force display if TRUE
  *
  * DESCRIPTION: Dumps the members of the given.Node
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_node (
@@ -531,28 +572,164 @@ acpi_ex_dump_node (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_reference
+ *
+ * PARAMETERS:  Object              - Descriptor to dump
+ *
+ * DESCRIPTION: Dumps a reference object
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_dump_reference (
+	union acpi_operand_object       *obj_desc)
+{
+	struct acpi_buffer              ret_buf;
+	acpi_status                     status;
+
+
+	if (obj_desc->reference.opcode == AML_INT_NAMEPATH_OP) {
+		acpi_os_printf ("Named Object %p ", obj_desc->reference.node);
+		ret_buf.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+		status = acpi_ns_handle_to_pathname (obj_desc->reference.node, &ret_buf);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("Could not convert name to pathname\n");
+		}
+		else {
+		   acpi_os_printf ("%s\n", (char *) ret_buf.pointer);
+		   ACPI_MEM_FREE (ret_buf.pointer);
+		}
+	}
+	else if (obj_desc->reference.object) {
+		acpi_os_printf ("\nReferenced Object: %p\n", obj_desc->reference.object);
+	}
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_package
+ *
+ * PARAMETERS:  Object              - Descriptor to dump
+ *              Level               - Indentation Level
+ *              Index               - Package index for this object
+ *
+ * DESCRIPTION: Dumps the elements of the package
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_dump_package (
+	union acpi_operand_object       *obj_desc,
+	u32                             level,
+	u32                             index)
+{
+	u32                             i;
+
+
+	/* Indentation and index output */
+
+	if (level > 0) {
+		for (i = 0; i < level; i++) {
+			acpi_os_printf (" ");
+		}
+
+		acpi_os_printf ("[%.2d] ", index);
+	}
+
+	acpi_os_printf ("%p ", obj_desc);
+
+	/* Null package elements are allowed */
+
+	if (!obj_desc) {
+		acpi_os_printf ("[Null Object]\n");
+		return;
+	}
+
+	/* Packages may only contain a few object types */
+
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_INTEGER:
+
+		acpi_os_printf ("[Integer] = %8.8X%8.8X\n",
+				 ACPI_FORMAT_UINT64 (obj_desc->integer.value));
+		break;
+
+
+	case ACPI_TYPE_STRING:
+
+		acpi_os_printf ("[String] Value: ");
+		for (i = 0; i < obj_desc->string.length; i++) {
+			acpi_os_printf ("%c", obj_desc->string.pointer[i]);
+		}
+		acpi_os_printf ("\n");
+		break;
+
+
+	case ACPI_TYPE_BUFFER:
+
+		acpi_os_printf ("[Buffer] Length %.2X = ", obj_desc->buffer.length);
+		if (obj_desc->buffer.length) {
+			acpi_ut_dump_buffer ((u8 *) obj_desc->buffer.pointer,
+					obj_desc->buffer.length, DB_DWORD_DISPLAY, _COMPONENT);
+		}
+		else {
+			acpi_os_printf ("\n");
+		}
+		break;
+
+
+	case ACPI_TYPE_PACKAGE:
+
+		acpi_os_printf ("[Package] Contains %d Elements: \n",
+				obj_desc->package.count);
+
+		for (i = 0; i < obj_desc->package.count; i++) {
+			acpi_ex_dump_package (obj_desc->package.elements[i], level+1, i);
+		}
+		break;
+
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		acpi_os_printf ("[Object Reference] ");
+		acpi_ex_dump_reference (obj_desc);
+		break;
+
+
+	default:
+
+		acpi_os_printf ("[Unknown Type] %X\n", ACPI_GET_OBJECT_TYPE (obj_desc));
+		break;
+	}
+}
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ex_dump_object_descriptor
  *
- * PARAMETERS:  *Object             - Descriptor to dump
- *              Flags               - Force display
+ * PARAMETERS:  Object              - Descriptor to dump
+ *              Flags               - Force display if TRUE
  *
  * DESCRIPTION: Dumps the members of the object descriptor given.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ex_dump_object_descriptor (
 	union acpi_operand_object       *obj_desc,
 	u32                             flags)
 {
-	u32                             i;
-
-
 	ACPI_FUNCTION_TRACE ("ex_dump_object_descriptor");
 
 
+	if (!obj_desc) {
+		return_VOID;
+	}
+
 	if (!flags) {
 		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
 			return_VOID;
@@ -612,22 +789,13 @@ acpi_ex_dump_object_descriptor (
 	case ACPI_TYPE_PACKAGE:
 
 		acpi_ex_out_integer ("Flags",       obj_desc->package.flags);
-		acpi_ex_out_integer ("Count",       obj_desc->package.count);
-		acpi_ex_out_pointer ("Elements",    obj_desc->package.elements);
+		acpi_ex_out_integer ("Elements",    obj_desc->package.count);
+		acpi_ex_out_pointer ("Element List", obj_desc->package.elements);
 
 		/* Dump the package contents */
 
-		if (obj_desc->package.count > 0) {
-			acpi_os_printf ("\nPackage Contents:\n");
-			for (i = 0; i < obj_desc->package.count; i++) {
-				acpi_os_printf ("[%.3d] %p", i, obj_desc->package.elements[i]);
-				if (obj_desc->package.elements[i]) {
-					acpi_os_printf (" %s",
-						acpi_ut_get_object_type_name (obj_desc->package.elements[i]));
-				}
-				acpi_os_printf ("\n");
-			}
-		}
+		acpi_os_printf ("\nPackage Contents:\n");
+		acpi_ex_dump_package (obj_desc, 0, 0);
 		break;
 
 
@@ -650,7 +818,7 @@ acpi_ex_dump_object_descriptor (
 		acpi_ex_out_integer ("param_count", obj_desc->method.param_count);
 		acpi_ex_out_integer ("Concurrency", obj_desc->method.concurrency);
 		acpi_ex_out_pointer ("Semaphore",   obj_desc->method.semaphore);
-		acpi_ex_out_integer ("owning_id",   obj_desc->method.owning_id);
+		acpi_ex_out_integer ("owner_id",    obj_desc->method.owner_id);
 		acpi_ex_out_integer ("aml_length",  obj_desc->method.aml_length);
 		acpi_ex_out_pointer ("aml_start",   obj_desc->method.aml_start);
 		break;
@@ -747,11 +915,14 @@ acpi_ex_dump_object_descriptor (
 	case ACPI_TYPE_LOCAL_REFERENCE:
 
 		acpi_ex_out_integer ("target_type", obj_desc->reference.target_type);
-		acpi_ex_out_string ("Opcode",       (acpi_ps_get_opcode_info (obj_desc->reference.opcode))->name);
+		acpi_ex_out_string ("Opcode",       (acpi_ps_get_opcode_info (
+				  obj_desc->reference.opcode))->name);
 		acpi_ex_out_integer ("Offset",      obj_desc->reference.offset);
 		acpi_ex_out_pointer ("obj_desc",    obj_desc->reference.object);
 		acpi_ex_out_pointer ("Node",        obj_desc->reference.node);
 		acpi_ex_out_pointer ("Where",       obj_desc->reference.where);
+
+		acpi_ex_dump_reference (obj_desc);
 		break;
 
 
@@ -788,6 +959,5 @@ acpi_ex_dump_object_descriptor (
 }
 
 #endif  /*  ACPI_FUTURE_USAGE  */
-
 #endif
 
diff --git a/drivers/acpi/executer/exfield.c b/drivers/acpi/executer/exfield.c
--- a/drivers/acpi/executer/exfield.c
+++ b/drivers/acpi/executer/exfield.c
@@ -87,6 +87,9 @@ acpi_ex_read_data_from_field (
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
+	if (!ret_buffer_desc) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
 	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_BUFFER_FIELD) {
 		/*
@@ -120,8 +123,8 @@ acpi_ex_read_data_from_field (
 		 * Note: Smbus protocol value is passed in upper 16-bits of Function
 		 */
 		status = acpi_ex_access_region (obj_desc, 0,
-				  ACPI_CAST_PTR (acpi_integer, buffer_desc->buffer.pointer),
-				  ACPI_READ | (obj_desc->field.attribute << 16));
+				 ACPI_CAST_PTR (acpi_integer, buffer_desc->buffer.pointer),
+				 ACPI_READ | (obj_desc->field.attribute << 16));
 		acpi_ex_release_global_lock (locked);
 		goto exit;
 	}
@@ -182,7 +185,7 @@ exit:
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_remove_reference (buffer_desc);
 	}
-	else if (ret_buffer_desc) {
+	else {
 		*ret_buffer_desc = buffer_desc;
 	}
 
@@ -196,6 +199,7 @@ exit:
  *
  * PARAMETERS:  source_desc         - Contains data to write
  *              obj_desc            - The named field
+ *              result_desc         - Where the return value is returned, if any
  *
  * RETURN:      Status
  *
@@ -250,12 +254,15 @@ acpi_ex_write_data_to_field (
 		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER) {
 			ACPI_REPORT_ERROR (("SMBus write requires Buffer, found type %s\n",
 				acpi_ut_get_object_type_name (source_desc)));
+
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
 		if (source_desc->buffer.length < ACPI_SMBUS_BUFFER_SIZE) {
-			ACPI_REPORT_ERROR (("SMBus write requires Buffer of length %X, found length %X\n",
+			ACPI_REPORT_ERROR ((
+				"SMBus write requires Buffer of length %X, found length %X\n",
 				ACPI_SMBUS_BUFFER_SIZE, source_desc->buffer.length));
+
 			return_ACPI_STATUS (AE_AML_BUFFER_LIMIT);
 		}
 
@@ -265,14 +272,16 @@ acpi_ex_write_data_to_field (
 		}
 
 		buffer = buffer_desc->buffer.pointer;
-		ACPI_MEMCPY (buffer, source_desc->buffer.pointer, ACPI_SMBUS_BUFFER_SIZE);
+		ACPI_MEMCPY (buffer, source_desc->buffer.pointer,
+			ACPI_SMBUS_BUFFER_SIZE);
 
 		/* Lock entire transaction if requested */
 
 		locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
 
 		/*
-		 * Perform the write (returns status and perhaps data in the same buffer)
+		 * Perform the write (returns status and perhaps data in the
+		 * same buffer)
 		 * Note: SMBus protocol type is passed in upper 16-bits of Function.
 		 */
 		status = acpi_ex_access_region (obj_desc, 0,
@@ -284,9 +293,8 @@ acpi_ex_write_data_to_field (
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get a pointer to the data to be written
-	 */
+	/* Get a pointer to the data to be written */
+
 	switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
 	case ACPI_TYPE_INTEGER:
 		buffer = &source_desc->integer.value;
@@ -314,7 +322,8 @@ acpi_ex_write_data_to_field (
 	 * the ACPI specification.
 	 */
 	new_buffer = NULL;
-	required_length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
+	required_length = ACPI_ROUND_BITS_UP_TO_BYTES (
+			   obj_desc->common_field.bit_length);
 
 	if (length < required_length) {
 		/* We need to create a new buffer */
@@ -338,6 +347,7 @@ acpi_ex_write_data_to_field (
 		"field_write [FROM]: Obj %p (%s:%X), Buf %p, byte_len %X\n",
 		source_desc, acpi_ut_get_type_name (ACPI_GET_OBJECT_TYPE (source_desc)),
 		ACPI_GET_OBJECT_TYPE (source_desc), buffer, length));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 		"field_write [TO]:  Obj %p (%s:%X), bit_len %X, bit_off %X, byte_off %X\n",
 		obj_desc, acpi_ut_get_type_name (ACPI_GET_OBJECT_TYPE (obj_desc)),
diff --git a/drivers/acpi/executer/exfldio.c b/drivers/acpi/executer/exfldio.c
--- a/drivers/acpi/executer/exfldio.c
+++ b/drivers/acpi/executer/exfldio.c
@@ -52,12 +52,31 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exfldio")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_field_datum_io (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
+
+static u8
+acpi_ex_register_overflow (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    value);
+
+static acpi_status
+acpi_ex_setup_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_setup_region
  *
- * PARAMETERS:  *obj_desc               - Field to be read or written
+ * PARAMETERS:  obj_desc                - Field to be read or written
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
  *
@@ -69,7 +88,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_setup_region (
 	union acpi_operand_object       *obj_desc,
 	u32                             field_datum_byte_offset)
@@ -127,9 +146,9 @@ acpi_ex_setup_region (
 	 * length of one field datum (access width) must fit within the region.
 	 * (Region length is specified in bytes)
 	 */
-	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset
-			   + field_datum_byte_offset
-			   + obj_desc->common_field.access_byte_width)) {
+	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset +
+			   field_datum_byte_offset +
+			   obj_desc->common_field.access_byte_width)) {
 		if (acpi_gbl_enable_interpreter_slack) {
 			/*
 			 * Slack mode only:  We will go ahead and allow access to this
@@ -155,7 +174,8 @@ acpi_ex_setup_region (
 				"Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)\n",
 				acpi_ut_get_node_name (obj_desc->common_field.node),
 				obj_desc->common_field.access_byte_width,
-				acpi_ut_get_node_name (rgn_desc->region.node), rgn_desc->region.length));
+				acpi_ut_get_node_name (rgn_desc->region.node),
+				rgn_desc->region.length));
 		}
 
 		/*
@@ -167,7 +187,8 @@ acpi_ex_setup_region (
 			acpi_ut_get_node_name (obj_desc->common_field.node),
 			obj_desc->common_field.base_byte_offset,
 			field_datum_byte_offset, obj_desc->common_field.access_byte_width,
-			acpi_ut_get_node_name (rgn_desc->region.node), rgn_desc->region.length));
+			acpi_ut_get_node_name (rgn_desc->region.node),
+			rgn_desc->region.length));
 
 		return_ACPI_STATUS (AE_AML_REGION_LIMIT);
 	}
@@ -180,10 +201,10 @@ acpi_ex_setup_region (
  *
  * FUNCTION:    acpi_ex_access_region
  *
- * PARAMETERS:  *obj_desc               - Field to be read
+ * PARAMETERS:  obj_desc                - Field to be read
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
- *              *Value                  - Where to store value (must at least
+ *              Value                   - Where to store value (must at least
  *                                        the size of acpi_integer)
  *              Function                - Read or Write flag plus other region-
  *                                        dependent flags
@@ -226,9 +247,9 @@ acpi_ex_access_region (
 	 * 3) The current offset into the field
 	 */
 	rgn_desc = obj_desc->common_field.region_obj;
-	address = rgn_desc->region.address
-			 + obj_desc->common_field.base_byte_offset
-			 + field_datum_byte_offset;
+	address = rgn_desc->region.address +
+			 obj_desc->common_field.base_byte_offset +
+			 field_datum_byte_offset;
 
 	if ((function & ACPI_IO_MASK) == ACPI_READ) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "[READ]"));
@@ -249,7 +270,8 @@ acpi_ex_access_region (
 	/* Invoke the appropriate address_space/op_region handler */
 
 	status = acpi_ev_address_space_dispatch (rgn_desc, function,
-			  address, ACPI_MUL_8 (obj_desc->common_field.access_byte_width), value);
+			 address,
+			 ACPI_MUL_8 (obj_desc->common_field.access_byte_width), value);
 
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_IMPLEMENTED) {
@@ -274,7 +296,7 @@ acpi_ex_access_region (
  *
  * FUNCTION:    acpi_ex_register_overflow
  *
- * PARAMETERS:  *obj_desc               - Register(Field) to be written
+ * PARAMETERS:  obj_desc                - Register(Field) to be written
  *              Value                   - Value to be stored
  *
  * RETURN:      TRUE if value overflows the field, FALSE otherwise
@@ -287,7 +309,7 @@ acpi_ex_access_region (
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ex_register_overflow (
 	union acpi_operand_object       *obj_desc,
 	acpi_integer                    value)
@@ -319,10 +341,10 @@ acpi_ex_register_overflow (
  *
  * FUNCTION:    acpi_ex_field_datum_io
  *
- * PARAMETERS:  *obj_desc               - Field to be read
+ * PARAMETERS:  obj_desc                - Field to be read
  *              field_datum_byte_offset - Byte offset of this datum within the
  *                                        parent field
- *              *Value                  - Where to store value (must be 64 bits)
+ *              Value                   - Where to store value (must be 64 bits)
  *              read_write              - Read or Write flag
  *
  * RETURN:      Status
@@ -333,7 +355,7 @@ acpi_ex_register_overflow (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_field_datum_io (
 	union acpi_operand_object       *obj_desc,
 	u32                             field_datum_byte_offset,
@@ -350,7 +372,9 @@ acpi_ex_field_datum_io (
 	if (read_write == ACPI_READ) {
 		if (!value) {
 			local_value = 0;
-			value = &local_value; /* To support reads without saving return value */
+
+			/* To support reads without saving return value */
+			value = &local_value;
 		}
 
 		/* Clear the entire return buffer first, [Very Important!] */
@@ -363,8 +387,10 @@ acpi_ex_field_datum_io (
 	 *
 	 * buffer_field - Read/write from/to a Buffer
 	 * region_field - Read/write from/to a Operation Region.
-	 * bank_field  - Write to a Bank Register, then read/write from/to an op_region
-	 * index_field - Write to an Index Register, then read/write from/to a Data Register
+	 * bank_field  - Write to a Bank Register, then read/write from/to an
+	 *               operation_region
+	 * index_field - Write to an Index Register, then read/write from/to a
+	 *               Data Register
 	 */
 	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_BUFFER_FIELD:
@@ -384,19 +410,20 @@ acpi_ex_field_datum_io (
 			 * Copy the data from the source buffer.
 			 * Length is the field width in bytes.
 			 */
-			ACPI_MEMCPY (value, (obj_desc->buffer_field.buffer_obj)->buffer.pointer
-					  + obj_desc->buffer_field.base_byte_offset
-					  + field_datum_byte_offset,
-					  obj_desc->common_field.access_byte_width);
+			ACPI_MEMCPY (value,
+				(obj_desc->buffer_field.buffer_obj)->buffer.pointer +
+					obj_desc->buffer_field.base_byte_offset +
+					field_datum_byte_offset,
+				obj_desc->common_field.access_byte_width);
 		}
 		else {
 			/*
 			 * Copy the data to the target buffer.
 			 * Length is the field width in bytes.
 			 */
-			ACPI_MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer
-					+ obj_desc->buffer_field.base_byte_offset
-					+ field_datum_byte_offset,
+			ACPI_MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer +
+					obj_desc->buffer_field.base_byte_offset +
+					field_datum_byte_offset,
 					value, obj_desc->common_field.access_byte_width);
 		}
 
@@ -406,8 +433,10 @@ acpi_ex_field_datum_io (
 
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
-		/* Ensure that the bank_value is not beyond the capacity of the register */
-
+		/*
+		 * Ensure that the bank_value is not beyond the capacity of
+		 * the register
+		 */
 		if (acpi_ex_register_overflow (obj_desc->bank_field.bank_obj,
 				  (acpi_integer) obj_desc->bank_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
@@ -445,8 +474,10 @@ acpi_ex_field_datum_io (
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
 
-		/* Ensure that the index_value is not beyond the capacity of the register */
-
+		/*
+		 * Ensure that the index_value is not beyond the capacity of
+		 * the register
+		 */
 		if (acpi_ex_register_overflow (obj_desc->index_field.index_obj,
 				  (acpi_integer) obj_desc->index_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
@@ -496,14 +527,16 @@ acpi_ex_field_datum_io (
 
 	if (ACPI_SUCCESS (status)) {
 		if (read_write == ACPI_READ) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Read %8.8X%8.8X, Width %d\n",
-					   ACPI_FORMAT_UINT64 (*value),
-					   obj_desc->common_field.access_byte_width));
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+				"Value Read %8.8X%8.8X, Width %d\n",
+				ACPI_FORMAT_UINT64 (*value),
+				obj_desc->common_field.access_byte_width));
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Written %8.8X%8.8X, Width %d\n",
-					   ACPI_FORMAT_UINT64 (*value),
-					   obj_desc->common_field.access_byte_width));
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+				"Value Written %8.8X%8.8X, Width %d\n",
+				ACPI_FORMAT_UINT64 (*value),
+				obj_desc->common_field.access_byte_width));
 		}
 	}
 
@@ -515,8 +548,10 @@ acpi_ex_field_datum_io (
  *
  * FUNCTION:    acpi_ex_write_with_update_rule
  *
- * PARAMETERS:  *obj_desc           - Field to be set
- *              Value               - Value to store
+ * PARAMETERS:  obj_desc                - Field to be written
+ *              Mask                    - bitmask within field datum
+ *              field_value             - Value to write
+ *              field_datum_byte_offset - Offset of datum within field
  *
  * RETURN:      Status
  *
@@ -689,7 +724,8 @@ acpi_ex_extract_from_field (
 		/* Merge with previous datum if necessary */
 
 		merged_datum |= raw_datum <<
-			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
+			(obj_desc->common_field.access_bit_width -
+				obj_desc->common_field.start_field_bit_offset);
 
 		if (i == datum_count) {
 			break;
@@ -707,7 +743,8 @@ acpi_ex_extract_from_field (
 
 	/* Mask off any extra bits in the last datum */
 
-	buffer_tail_bits = obj_desc->common_field.bit_length % obj_desc->common_field.access_bit_width;
+	buffer_tail_bits = obj_desc->common_field.bit_length %
+			   obj_desc->common_field.access_bit_width;
 	if (buffer_tail_bits) {
 		merged_datum &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
 	}
@@ -791,7 +828,8 @@ acpi_ex_insert_into_field (
 		/* Write merged datum to the target field */
 
 		merged_datum &= mask;
-		status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
+		status = acpi_ex_write_with_update_rule (obj_desc, mask,
+				 merged_datum, field_offset);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -800,7 +838,8 @@ acpi_ex_insert_into_field (
 
 		field_offset += obj_desc->common_field.access_byte_width;
 		merged_datum = raw_datum >>
-			(obj_desc->common_field.access_bit_width - obj_desc->common_field.start_field_bit_offset);
+			(obj_desc->common_field.access_bit_width -
+				obj_desc->common_field.start_field_bit_offset);
 		mask = ACPI_INTEGER_MAX;
 
 		if (i == datum_count) {
@@ -819,7 +858,8 @@ acpi_ex_insert_into_field (
 	/* Mask off any extra bits in the last datum */
 
 	buffer_tail_bits = (obj_desc->common_field.bit_length +
-			obj_desc->common_field.start_field_bit_offset) % obj_desc->common_field.access_bit_width;
+			obj_desc->common_field.start_field_bit_offset) %
+				obj_desc->common_field.access_bit_width;
 	if (buffer_tail_bits) {
 		mask &= ACPI_MASK_BITS_ABOVE (buffer_tail_bits);
 	}
@@ -827,7 +867,8 @@ acpi_ex_insert_into_field (
 	/* Write the last datum to the field */
 
 	merged_datum &= mask;
-	status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum, field_offset);
+	status = acpi_ex_write_with_update_rule (obj_desc,
+			 mask, merged_datum, field_offset);
 
 	return_ACPI_STATUS (status);
 }
diff --git a/drivers/acpi/executer/exmisc.c b/drivers/acpi/executer/exmisc.c
--- a/drivers/acpi/executer/exmisc.c
+++ b/drivers/acpi/executer/exmisc.c
@@ -139,8 +139,9 @@ acpi_ex_get_object_reference (
 	reference_obj->reference.object = referenced_obj;
 	*return_desc = reference_obj;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Object %p Type [%s], returning Reference %p\n",
-			obj_desc, acpi_ut_get_object_type_name (obj_desc), *return_desc));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Object %p Type [%s], returning Reference %p\n",
+		obj_desc, acpi_ut_get_object_type_name (obj_desc), *return_desc));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -301,7 +302,7 @@ acpi_ex_do_concatenate (
 		/* Result of two Integers is a Buffer */
 		/* Need enough buffer space for two integers */
 
-		return_desc = acpi_ut_create_buffer_object (
+		return_desc = acpi_ut_create_buffer_object ((acpi_size)
 				   ACPI_MUL_2 (acpi_gbl_integer_byte_width));
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
@@ -456,7 +457,7 @@ acpi_ex_do_math_op (
 		return (integer0 * integer1);
 
 
-	case AML_SHIFT_LEFT_OP:         /* shift_left (Operand, shift_count, Result) */
+	case AML_SHIFT_LEFT_OP:         /* shift_left (Operand, shift_count, Result)*/
 
 		return (integer0 << integer1);
 
diff --git a/drivers/acpi/executer/exmutex.c b/drivers/acpi/executer/exmutex.c
--- a/drivers/acpi/executer/exmutex.c
+++ b/drivers/acpi/executer/exmutex.c
@@ -49,6 +49,13 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exmutex")
 
+/* Local prototypes */
+
+static void
+acpi_ex_link_mutex (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_thread_state        *thread);
+
 
 /*******************************************************************************
  *
@@ -56,7 +63,7 @@
  *
  * PARAMETERS:  obj_desc            - The mutex to be unlinked
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Remove a mutex from the "acquired_mutex" list
  *
@@ -92,16 +99,16 @@ acpi_ex_unlink_mutex (
  *
  * FUNCTION:    acpi_ex_link_mutex
  *
- * PARAMETERS:  obj_desc            - The mutex to be linked
- *              list_head           - head of the "acquired_mutex" list
+ * PARAMETERS:  obj_desc        - The mutex to be linked
+ *              Thread          - Current executing thread object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Add a mutex to the "acquired_mutex" list for this walk
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ex_link_mutex (
 	union acpi_operand_object       *obj_desc,
 	struct acpi_thread_state        *thread)
@@ -132,8 +139,9 @@ acpi_ex_link_mutex (
  *
  * FUNCTION:    acpi_ex_acquire_mutex
  *
- * PARAMETERS:  time_desc           - The 'time to delay' object descriptor
- *              obj_desc            - The object descriptor for this op
+ * PARAMETERS:  time_desc           - Timeout integer
+ *              obj_desc            - Mutex object
+ *              walk_state          - Current method execution state
  *
  * RETURN:      Status
  *
@@ -161,7 +169,7 @@ acpi_ex_acquire_mutex (
 
 	if (!walk_state->thread) {
 		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], null thread info\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
@@ -170,8 +178,9 @@ acpi_ex_acquire_mutex (
 	 * mutex.  This mechanism provides some deadlock prevention
 	 */
 	if (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {
-		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+		ACPI_REPORT_ERROR ((
+			"Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
@@ -180,8 +189,10 @@ acpi_ex_acquire_mutex (
 	if (obj_desc->mutex.owner_thread) {
 		/* Special case for Global Lock, allow all threads */
 
-		if ((obj_desc->mutex.owner_thread->thread_id == walk_state->thread->thread_id) ||
-			(obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore)) {
+		if ((obj_desc->mutex.owner_thread->thread_id ==
+				walk_state->thread->thread_id)      ||
+			(obj_desc->mutex.semaphore ==
+				acpi_gbl_global_lock_semaphore)) {
 			/*
 			 * The mutex is already owned by this thread,
 			 * just increment the acquisition depth
@@ -221,6 +232,7 @@ acpi_ex_acquire_mutex (
  * FUNCTION:    acpi_ex_release_mutex
  *
  * PARAMETERS:  obj_desc            - The object descriptor for this op
+ *              walk_state          - Current method execution state
  *
  * RETURN:      Status
  *
@@ -278,8 +290,9 @@ acpi_ex_release_mutex (
 	 * equal to the current sync level
 	 */
 	if (obj_desc->mutex.sync_level > walk_state->thread->current_sync_level) {
-		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], incorrect sync_level\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
+		ACPI_REPORT_ERROR ((
+			"Cannot release Mutex [%4.4s], incorrect sync_level\n",
+			acpi_ut_get_node_name (obj_desc->mutex.node)));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
@@ -313,11 +326,11 @@ acpi_ex_release_mutex (
  *
  * FUNCTION:    acpi_ex_release_all_mutexes
  *
- * PARAMETERS:  mutex_list            - Head of the mutex list
+ * PARAMETERS:  Thread          - Current executing thread object
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Release all mutexes in the list
+ * DESCRIPTION: Release all mutexes held by this thread
  *
  ******************************************************************************/
 
diff --git a/drivers/acpi/executer/exnames.c b/drivers/acpi/executer/exnames.c
--- a/drivers/acpi/executer/exnames.c
+++ b/drivers/acpi/executer/exnames.c
@@ -50,13 +50,17 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exnames")
 
+/* Local prototypes */
 
-/* AML Package Length encodings */
+static char *
+acpi_ex_allocate_name_string (
+	u32                             prefix_count,
+	u32                             num_name_segs);
 
-#define ACPI_AML_PACKAGE_TYPE1   0x40
-#define ACPI_AML_PACKAGE_TYPE2   0x4000
-#define ACPI_AML_PACKAGE_TYPE3   0x400000
-#define ACPI_AML_PACKAGE_TYPE4   0x40000000
+static acpi_status
+acpi_ex_name_segment (
+	u8                              **in_aml_address,
+	char                            *name_string);
 
 
 /*******************************************************************************
@@ -64,7 +68,7 @@
  * FUNCTION:    acpi_ex_allocate_name_string
  *
  * PARAMETERS:  prefix_count        - Count of parent levels. Special cases:
- *                                    (-1) = root,  0 = none
+ *                                    (-1)==root,  0==none
  *              num_name_segs       - count of 4-character name segments
  *
  * RETURN:      A pointer to the allocated string segment.  This segment must
@@ -75,7 +79,7 @@
  *
  ******************************************************************************/
 
-char *
+static char *
 acpi_ex_allocate_name_string (
 	u32                             prefix_count,
 	u32                             num_name_segs)
@@ -88,7 +92,7 @@ acpi_ex_allocate_name_string (
 
 
 	/*
-	 * Allow room for all \ and ^ prefixes, all segments, and a multi_name_prefix.
+	 * Allow room for all \ and ^ prefixes, all segments and a multi_name_prefix.
 	 * Also, one byte for the null terminator.
 	 * This may actually be somewhat longer than needed.
 	 */
@@ -107,7 +111,8 @@ acpi_ex_allocate_name_string (
 	 */
 	name_string = ACPI_MEM_ALLOCATE (size_needed);
 	if (!name_string) {
-		ACPI_REPORT_ERROR (("ex_allocate_name_string: Could not allocate size %d\n", size_needed));
+		ACPI_REPORT_ERROR ((
+			"ex_allocate_name_string: Could not allocate size %d\n", size_needed));
 		return_PTR (NULL);
 	}
 
@@ -152,15 +157,17 @@ acpi_ex_allocate_name_string (
  *
  * FUNCTION:    acpi_ex_name_segment
  *
- * PARAMETERS:  interpreter_mode    - Current running mode (load1/Load2/Exec)
+ * PARAMETERS:  in_aml_address  - Pointer to the name in the AML code
+ *              name_string     - Where to return the name. The name is appended
+ *                                to any existing string to form a namepath
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Execute a name segment (4 bytes)
+ * DESCRIPTION: Extract an ACPI name (4 bytes) from the AML byte stream
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_name_segment (
 	u8                              **in_aml_address,
 	char                            *name_string)
@@ -223,10 +230,13 @@ acpi_ex_name_segment (
 		status = AE_CTRL_PENDING;
 	}
 	else {
-		/* Segment started with one or more valid characters, but fewer than 4 */
-
+		/*
+		 * Segment started with one or more valid characters, but fewer than
+		 * the required 4
+		 */
 		status = AE_AML_BAD_NAME;
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad character %02x in name, at %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Bad character %02x in name, at %p\n",
 			*aml_address, aml_address));
 	}
 
@@ -239,11 +249,16 @@ acpi_ex_name_segment (
  *
  * FUNCTION:    acpi_ex_get_name_string
  *
- * PARAMETERS:  data_type           - Data type to be associated with this name
+ * PARAMETERS:  data_type           - Object type to be associated with this
+ *                                    name
+ *              in_aml_address      - Pointer to the namestring in the AML code
+ *              out_name_string     - Where the namestring is returned
+ *              out_name_length     - Length of the returned string
  *
- * RETURN:      Status
+ * RETURN:      Status, namestring and length
  *
- * DESCRIPTION: Get a name, including any prefixes.
+ * DESCRIPTION: Extract a full namepath from the AML byte stream,
+ *              including any prefixes.
  *
  ******************************************************************************/
 
@@ -286,7 +301,8 @@ acpi_ex_get_name_string (
 		switch (*aml_address) {
 		case AML_ROOT_PREFIX:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "root_prefix(\\) at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "root_prefix(\\) at %p\n",
+				aml_address));
 
 			/*
 			 * Remember that we have a root_prefix --
@@ -303,7 +319,8 @@ acpi_ex_get_name_string (
 			/* Increment past possibly multiple parent prefixes */
 
 			do {
-				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "parent_prefix (^) at %p\n", aml_address));
+				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "parent_prefix (^) at %p\n",
+					aml_address));
 
 				aml_address++;
 				prefix_count++;
@@ -321,13 +338,13 @@ acpi_ex_get_name_string (
 			break;
 		}
 
-
 		/* Examine first character of name for name segment prefix operator */
 
 		switch (*aml_address) {
 		case AML_DUAL_NAME_PREFIX:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "dual_name_prefix at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "dual_name_prefix at %p\n",
+				aml_address));
 
 			aml_address++;
 			name_string = acpi_ex_allocate_name_string (prefix_count, 2);
@@ -349,7 +366,8 @@ acpi_ex_get_name_string (
 
 		case AML_MULTI_NAME_PREFIX_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "multi_name_prefix at %p\n", aml_address));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "multi_name_prefix at %p\n",
+				aml_address));
 
 			/* Fetch count of segments remaining in name path */
 
@@ -368,7 +386,8 @@ acpi_ex_get_name_string (
 			has_prefix = TRUE;
 
 			while (num_segments &&
-					(status = acpi_ex_name_segment (&aml_address, name_string)) == AE_OK) {
+					(status = acpi_ex_name_segment (&aml_address, name_string)) ==
+						AE_OK) {
 				num_segments--;
 			}
 
@@ -380,7 +399,8 @@ acpi_ex_get_name_string (
 			/* null_name valid as of 8-12-98 ASL/AML Grammar Update */
 
 			if (prefix_count == ACPI_UINT32_MAX) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "name_seg is \"\\\" followed by NULL\n"));
+				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+					"name_seg is \"\\\" followed by NULL\n"));
 			}
 
 			/* Consume the NULL byte */
@@ -418,6 +438,13 @@ acpi_ex_get_name_string (
 		status = AE_AML_BAD_NAME;
 	}
 
+	if (ACPI_FAILURE (status)) {
+		if (name_string) {
+			ACPI_MEM_FREE (name_string);
+		}
+		return_ACPI_STATUS (status);
+	}
+
 	*out_name_string = name_string;
 	*out_name_length = (u32) (aml_address - in_aml_address);
 
diff --git a/drivers/acpi/executer/exoparg1.c b/drivers/acpi/executer/exoparg1.c
--- a/drivers/acpi/executer/exoparg1.c
+++ b/drivers/acpi/executer/exoparg1.c
@@ -97,7 +97,8 @@ acpi_ex_opcode_0A_0T_1R (
 	union acpi_operand_object       *return_desc = NULL;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_0A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_0A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -112,8 +113,9 @@ acpi_ex_opcode_0A_0T_1R (
 			status = AE_NO_MEMORY;
 			goto cleanup;
 		}
-
+#if ACPI_MACHINE_WIDTH != 16
 		return_desc->integer.value = acpi_os_get_timer ();
+#endif
 		break;
 
 	default:                /*  Unknown opcode  */
@@ -126,15 +128,16 @@ acpi_ex_opcode_0A_0T_1R (
 
 cleanup:
 
-	if (!walk_state->result_obj) {
-		walk_state->result_obj = return_desc;
-	}
-
 	/* Delete return object on error */
 
-	if (ACPI_FAILURE (status)) {
+	if ((ACPI_FAILURE (status)) || walk_state->result_obj) {
 		acpi_ut_remove_reference (return_desc);
 	}
+	else {
+		/* Save the return value */
+
+		walk_state->result_obj = return_desc;
+	}
 
 	return_ACPI_STATUS (status);
 }
@@ -161,7 +164,8 @@ acpi_ex_opcode_1A_0T_0R (
 	acpi_status                     status = AE_OK;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -236,7 +240,8 @@ acpi_ex_opcode_1A_1T_0R (
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -289,7 +294,8 @@ acpi_ex_opcode_1A_1T_1R (
 	acpi_integer                    digit;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -409,8 +415,10 @@ acpi_ex_opcode_1A_1T_1R (
 			for (i = 0; (i < acpi_gbl_integer_nybble_width) && (digit > 0); i++) {
 				(void) acpi_ut_short_divide (digit, 10, &digit, &temp32);
 
-				/* Insert the BCD digit that resides in the remainder from above */
-
+				/*
+				 * Insert the BCD digit that resides in the
+				 * remainder from above
+				 */
 				return_desc->integer.value |= (((acpi_integer) temp32) <<
 						   ACPI_MUL_4 (i));
 			}
@@ -445,7 +453,8 @@ acpi_ex_opcode_1A_1T_1R (
 
 			/* Get the object reference, store it, and remove our reference */
 
-			status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
+			status = acpi_ex_get_object_reference (operand[0],
+					 &return_desc2, walk_state);
 			if (ACPI_FAILURE (status)) {
 				goto cleanup;
 			}
@@ -482,10 +491,10 @@ acpi_ex_opcode_1A_1T_1R (
 
 		if (!walk_state->result_obj) {
 			/*
-			 * Normally, we would remove a reference on the Operand[0] parameter;
-			 * But since it is being used as the internal return object
-			 * (meaning we would normally increment it), the two cancel out,
-			 * and we simply don't do anything.
+			 * Normally, we would remove a reference on the Operand[0]
+			 * parameter; But since it is being used as the internal return
+			 * object (meaning we would normally increment it), the two
+			 * cancel out, and we simply don't do anything.
 			 */
 			walk_state->result_obj = operand[0];
 			walk_state->operands[0] = NULL; /* Prevent deletion */
@@ -549,9 +558,8 @@ acpi_ex_opcode_1A_1T_1R (
 	case AML_SHIFT_LEFT_BIT_OP:     /* shift_left_bit (Source, bit_num) */
 	case AML_SHIFT_RIGHT_BIT_OP:    /* shift_right_bit (Source, bit_num) */
 
-		/*
-		 * These are two obsolete opcodes
-		 */
+		/* These are two obsolete opcodes */
+
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"%s is obsolete and not implemented\n",
 			acpi_ps_get_opcode_name (walk_state->opcode)));
@@ -568,9 +576,8 @@ acpi_ex_opcode_1A_1T_1R (
 	}
 
 	if (ACPI_SUCCESS (status)) {
-		/*
-		 * Store the return value computed above into the target object
-		 */
+		/* Store the return value computed above into the target object */
+
 		status = acpi_ex_store (return_desc, operand[1], walk_state);
 	}
 
@@ -615,7 +622,8 @@ acpi_ex_opcode_1A_0T_1R (
 	acpi_integer                    value;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the AML opcode */
@@ -706,9 +714,9 @@ acpi_ex_opcode_1A_0T_1R (
 
 		/*
 		 * Note: The operand is not resolved at this point because we want to
-		 * get the associated object, not its value.  For example, we don't want
-		 * to resolve a field_unit to its value, we want the actual field_unit
-		 * object.
+		 * get the associated object, not its value.  For example, we don't
+		 * want to resolve a field_unit to its value, we want the actual
+		 * field_unit object.
 		 */
 
 		/* Get the type of the base object */
@@ -738,7 +746,8 @@ acpi_ex_opcode_1A_0T_1R (
 
 		/* Get the base object */
 
-		status = acpi_ex_resolve_multiple (walk_state, operand[0], &type, &temp_desc);
+		status = acpi_ex_resolve_multiple (walk_state,
+				 operand[0], &type, &temp_desc);
 		if (ACPI_FAILURE (status)) {
 			goto cleanup;
 		}
@@ -818,8 +827,10 @@ acpi_ex_opcode_1A_0T_1R (
 
 					/* Set Operand[0] to the value of the local/arg */
 
-					status = acpi_ds_method_data_get_value (operand[0]->reference.opcode,
-							 operand[0]->reference.offset, walk_state, &temp_desc);
+					status = acpi_ds_method_data_get_value (
+							 operand[0]->reference.opcode,
+							 operand[0]->reference.offset,
+							 walk_state, &temp_desc);
 					if (ACPI_FAILURE (status)) {
 						goto cleanup;
 					}
@@ -852,21 +863,26 @@ acpi_ex_opcode_1A_0T_1R (
 			case ACPI_TYPE_STRING:
 
 				/*
-				 * This is a deref_of (String). The string is a reference to a named ACPI object.
+				 * This is a deref_of (String). The string is a reference
+				 * to a named ACPI object.
 				 *
 				 * 1) Find the owning Node
-				 * 2) Dereference the node to an actual object.  Could be a Field, so we nee
-				 *    to resolve the node to a value.
+				 * 2) Dereference the node to an actual object.  Could be a
+				 *    Field, so we need to resolve the node to a value.
 				 */
 				status = acpi_ns_get_node_by_path (operand[0]->string.pointer,
-						  walk_state->scope_info->scope.node, ACPI_NS_SEARCH_PARENT,
-						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc));
+						 walk_state->scope_info->scope.node,
+						 ACPI_NS_SEARCH_PARENT,
+						 ACPI_CAST_INDIRECT_PTR (
+								struct acpi_namespace_node, &return_desc));
 				if (ACPI_FAILURE (status)) {
 					goto cleanup;
 				}
 
 				status = acpi_ex_resolve_node_to_value (
-						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc), walk_state);
+						  ACPI_CAST_INDIRECT_PTR (
+								 struct acpi_namespace_node, &return_desc),
+								walk_state);
 				goto cleanup;
 
 
@@ -883,14 +899,17 @@ acpi_ex_opcode_1A_0T_1R (
 			/*
 			 * This is a deref_of (object_reference)
 			 * Get the actual object from the Node (This is the dereference).
-			 * -- This case may only happen when a local_x or arg_x is dereferenced above.
+			 * This case may only happen when a local_x or arg_x is
+			 * dereferenced above.
 			 */
-			return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) operand[0]);
+			return_desc = acpi_ns_get_attached_object (
+					  (struct acpi_namespace_node *) operand[0]);
+			acpi_ut_add_reference (return_desc);
 		}
 		else {
 			/*
-			 * This must be a reference object produced by either the Index() or
-			 * ref_of() operator
+			 * This must be a reference object produced by either the
+			 * Index() or ref_of() operator
 			 */
 			switch (operand[0]->reference.opcode) {
 			case AML_INDEX_OP:
@@ -931,24 +950,14 @@ acpi_ex_opcode_1A_0T_1R (
 				case ACPI_TYPE_PACKAGE:
 
 					/*
-					 * Return the referenced element of the package.  We must add
-					 * another reference to the referenced object, however.
+					 * Return the referenced element of the package.  We must
+					 * add another reference to the referenced object, however.
 					 */
 					return_desc = *(operand[0]->reference.where);
-					if (!return_desc) {
-						/*
-						 * We can't return a NULL dereferenced value.  This is
-						 * an uninitialized package element and is thus a
-						 * severe error.
-						 */
-						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-							"NULL package element obj %p\n",
-							operand[0]));
-						status = AE_AML_UNINITIALIZED_ELEMENT;
-						goto cleanup;
+					if (return_desc) {
+						acpi_ut_add_reference (return_desc);
 					}
 
-					acpi_ut_add_reference (return_desc);
 					break;
 
 
@@ -967,9 +976,11 @@ acpi_ex_opcode_1A_0T_1R (
 
 				return_desc = operand[0]->reference.object;
 
-				if (ACPI_GET_DESCRIPTOR_TYPE (return_desc) == ACPI_DESC_TYPE_NAMED) {
+				if (ACPI_GET_DESCRIPTOR_TYPE (return_desc) ==
+						ACPI_DESC_TYPE_NAMED) {
 
-					return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) return_desc);
+					return_desc = acpi_ns_get_attached_object (
+							  (struct acpi_namespace_node *) return_desc);
 				}
 
 				/* Add another reference to the object! */
diff --git a/drivers/acpi/executer/exoparg2.c b/drivers/acpi/executer/exoparg2.c
--- a/drivers/acpi/executer/exoparg2.c
+++ b/drivers/acpi/executer/exoparg2.c
@@ -118,7 +118,7 @@ acpi_ex_opcode_2A_0T_0R (
 
 		value = (u32) operand[1]->integer.value;
 
-		/* Notifies allowed on this object? */
+		/* Are notifies allowed on this object? */
 
 		if (!acpi_ev_is_notify_object (node)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
@@ -203,11 +203,12 @@ acpi_ex_opcode_2A_2T_1R (
 		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/*
-	 * Execute the opcode
-	 */
+	/* Execute the opcode */
+
 	switch (walk_state->opcode) {
-	case AML_DIVIDE_OP:             /* Divide (Dividend, Divisor, remainder_result quotient_result) */
+	case AML_DIVIDE_OP:
+
+		/* Divide (Dividend, Divisor, remainder_result quotient_result) */
 
 		return_desc1 = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc1) {
@@ -241,7 +242,6 @@ acpi_ex_opcode_2A_2T_1R (
 		goto cleanup;
 	}
 
-
 	/* Store the results to the target reference operands */
 
 	status = acpi_ex_store (return_desc2, operand[2], walk_state);
@@ -295,7 +295,7 @@ acpi_ex_opcode_2A_1T_1R (
 {
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 	union acpi_operand_object       *return_desc = NULL;
-	u32                             index;
+	acpi_integer                    index;
 	acpi_status                     status = AE_OK;
 	acpi_size                       length;
 
@@ -304,9 +304,8 @@ acpi_ex_opcode_2A_1T_1R (
 		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/*
-	 * Execute the opcode
-	 */
+	/* Execute the opcode */
+
 	if (walk_state->op_info->flags & AML_MATH) {
 		/* All simple math opcodes (add, etc.) */
 
@@ -322,9 +321,8 @@ acpi_ex_opcode_2A_1T_1R (
 		goto store_result_to_target;
 	}
 
-
 	switch (walk_state->opcode) {
-	case AML_MOD_OP:                /* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
+	case AML_MOD_OP: /* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc) {
@@ -341,18 +339,19 @@ acpi_ex_opcode_2A_1T_1R (
 		break;
 
 
-	case AML_CONCAT_OP:             /* Concatenate (Data1, Data2, Result) */
+	case AML_CONCAT_OP: /* Concatenate (Data1, Data2, Result) */
 
 		status = acpi_ex_do_concatenate (operand[0], operand[1],
 				 &return_desc, walk_state);
 		break;
 
 
-	case AML_TO_STRING_OP:          /* to_string (Buffer, Length, Result) (ACPI 2.0) */
+	case AML_TO_STRING_OP: /* to_string (Buffer, Length, Result) (ACPI 2.0) */
 
 		/*
 		 * Input object is guaranteed to be a buffer at this point (it may have
-		 * been converted.)  Copy the raw buffer data to a new object of type String.
+		 * been converted.)  Copy the raw buffer data to a new object of
+		 * type String.
 		 */
 
 		/*
@@ -383,14 +382,16 @@ acpi_ex_opcode_2A_1T_1R (
 			goto cleanup;
 		}
 
-		/* Copy the raw buffer data with no transform. NULL terminated already. */
+		/* Copy the raw buffer data with no transform. NULL terminated already*/
 
 		ACPI_MEMCPY (return_desc->string.pointer,
 			operand[0]->buffer.pointer, length);
 		break;
 
 
-	case AML_CONCAT_RES_OP:         /* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
+	case AML_CONCAT_RES_OP:
+
+		/* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
 
 		status = acpi_ex_concat_template (operand[0], operand[1],
 				 &return_desc, walk_state);
@@ -407,33 +408,33 @@ acpi_ex_opcode_2A_1T_1R (
 			goto cleanup;
 		}
 
-		index = (u32) operand[1]->integer.value;
+		index = operand[1]->integer.value;
+
+		/* At this point, the Source operand is a Package, Buffer, or String */
 
-		/*
-		 * At this point, the Source operand is a Package, Buffer, or String
-		 */
 		if (ACPI_GET_OBJECT_TYPE (operand[0]) == ACPI_TYPE_PACKAGE) {
 			/* Object to be indexed is a Package */
 
 			if (index >= operand[0]->package.count) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Index value (%X) beyond package end (%X)\n",
-					index, operand[0]->package.count));
+					"Index value (%X%8.8X) beyond package end (%X)\n",
+					ACPI_FORMAT_UINT64 (index), operand[0]->package.count));
 				status = AE_AML_PACKAGE_LIMIT;
 				goto cleanup;
 			}
 
 			return_desc->reference.target_type = ACPI_TYPE_PACKAGE;
 			return_desc->reference.object    = operand[0];
-			return_desc->reference.where     = &operand[0]->package.elements [index];
+			return_desc->reference.where     = &operand[0]->package.elements [
+					  index];
 		}
 		else {
 			/* Object to be indexed is a Buffer/String */
 
 			if (index >= operand[0]->buffer.length) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Index value (%X) beyond end of buffer (%X)\n",
-					index, operand[0]->buffer.length));
+					"Index value (%X%8.8X) beyond end of buffer (%X)\n",
+					ACPI_FORMAT_UINT64 (index), operand[0]->buffer.length));
 				status = AE_AML_BUFFER_LIMIT;
 				goto cleanup;
 			}
@@ -451,7 +452,7 @@ acpi_ex_opcode_2A_1T_1R (
 		/* Complete the Index reference object */
 
 		return_desc->reference.opcode    = AML_INDEX_OP;
-		return_desc->reference.offset    = index;
+		return_desc->reference.offset    = (u32) index;
 
 		/* Store the reference to the Target */
 
@@ -536,22 +537,24 @@ acpi_ex_opcode_2A_0T_1R (
 		goto cleanup;
 	}
 
-	/*
-	 * Execute the Opcode
-	 */
-	if (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) /* logical_op (Operand0, Operand1) */ {
+	/* Execute the Opcode */
+
+	if (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) {
+		/* logical_op (Operand0, Operand1) */
+
 		status = acpi_ex_do_logical_numeric_op (walk_state->opcode,
 				  operand[0]->integer.value, operand[1]->integer.value,
 				  &logical_result);
 		goto store_logical_result;
 	}
-	else if (walk_state->op_info->flags & AML_LOGICAL)  /* logical_op (Operand0, Operand1) */ {
+	else if (walk_state->op_info->flags & AML_LOGICAL) {
+		/* logical_op (Operand0, Operand1) */
+
 		status = acpi_ex_do_logical_op (walk_state->opcode, operand[0],
 				 operand[1], &logical_result);
 		goto store_logical_result;
 	}
 
-
 	switch (walk_state->opcode) {
 	case AML_ACQUIRE_OP:            /* Acquire (mutex_object, Timeout) */
 
diff --git a/drivers/acpi/executer/exoparg3.c b/drivers/acpi/executer/exoparg3.c
--- a/drivers/acpi/executer/exoparg3.c
+++ b/drivers/acpi/executer/exoparg3.c
@@ -97,11 +97,12 @@ acpi_ex_opcode_3A_0T_0R (
 	acpi_status                     status = AE_OK;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_0T_0R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
-	case AML_FATAL_OP:          /* Fatal (fatal_type fatal_code fatal_arg)   */
+	case AML_FATAL_OP:          /* Fatal (fatal_type fatal_code fatal_arg) */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"fatal_op: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
@@ -116,9 +117,8 @@ acpi_ex_opcode_3A_0T_0R (
 			fatal->argument = (u32) operand[2]->integer.value;
 		}
 
-		/*
-		 * Always signal the OS!
-		 */
+		/* Always signal the OS! */
+
 		status = acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
 
 		/* Might return while OS is shutting down, just continue */
@@ -160,23 +160,25 @@ acpi_ex_opcode_3A_1T_1R (
 {
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 	union acpi_operand_object       *return_desc = NULL;
-	char                            *buffer;
+	char                            *buffer = NULL;
 	acpi_status                     status = AE_OK;
-	acpi_native_uint                index;
+	acpi_integer                    index;
 	acpi_size                       length;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_1T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
-	case AML_MID_OP:        /* Mid  (Source[0], Index[1], Length[2], Result[3]) */
+	case AML_MID_OP:    /* Mid (Source[0], Index[1], Length[2], Result[3]) */
 
 		/*
 		 * Create the return object.  The Source operand is guaranteed to be
 		 * either a String or a Buffer, so just use its type.
 		 */
-		return_desc = acpi_ut_create_internal_object (ACPI_GET_OBJECT_TYPE (operand[0]));
+		return_desc = acpi_ut_create_internal_object (
+				  ACPI_GET_OBJECT_TYPE (operand[0]));
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
@@ -184,40 +186,70 @@ acpi_ex_opcode_3A_1T_1R (
 
 		/* Get the Integer values from the objects */
 
-		index = (acpi_native_uint) operand[1]->integer.value;
+		index = operand[1]->integer.value;
 		length = (acpi_size) operand[2]->integer.value;
 
 		/*
 		 * If the index is beyond the length of the String/Buffer, or if the
 		 * requested length is zero, return a zero-length String/Buffer
 		 */
-		if ((index < operand[0]->string.length) &&
-			(length > 0)) {
-			/* Truncate request if larger than the actual String/Buffer */
-
-			if ((index + length) >
-				operand[0]->string.length) {
-				length = (acpi_size) operand[0]->string.length - index;
-			}
+		if (index >= operand[0]->string.length) {
+			length = 0;
+		}
 
-			/* Allocate a new buffer for the String/Buffer */
+		/* Truncate request if larger than the actual String/Buffer */
+
+		else if ((index + length) > operand[0]->string.length) {
+			length = (acpi_size) operand[0]->string.length -
+					 (acpi_size) index;
+		}
+
+		/* Strings always have a sub-pointer, not so for buffers */
+
+		switch (ACPI_GET_OBJECT_TYPE (operand[0])) {
+		case ACPI_TYPE_STRING:
+
+			/* Always allocate a new buffer for the String */
 
 			buffer = ACPI_MEM_CALLOCATE ((acpi_size) length + 1);
 			if (!buffer) {
 				status = AE_NO_MEMORY;
 				goto cleanup;
 			}
+			break;
+
+		case ACPI_TYPE_BUFFER:
 
+			/* If the requested length is zero, don't allocate a buffer */
+
+			if (length > 0) {
+				/* Allocate a new buffer for the Buffer */
+
+				buffer = ACPI_MEM_CALLOCATE (length);
+				if (!buffer) {
+					status = AE_NO_MEMORY;
+					goto cleanup;
+				}
+			}
+			break;
+
+		default:                        /* Should not happen */
+
+			status = AE_AML_OPERAND_TYPE;
+			goto cleanup;
+		}
+
+		if (length > 0) {
 			/* Copy the portion requested */
 
 			ACPI_MEMCPY (buffer, operand[0]->string.pointer + index,
 					  length);
+		}
 
-			/* Set the length of the new String/Buffer */
+		/* Set the length of the new String/Buffer */
 
-			return_desc->string.pointer = buffer;
-			return_desc->string.length = (u32) length;
-		}
+		return_desc->string.pointer = buffer;
+		return_desc->string.length = (u32) length;
 
 		/* Mark buffer initialized */
 
@@ -241,13 +273,13 @@ cleanup:
 
 	/* Delete return object on error */
 
-	if (ACPI_FAILURE (status)) {
+	if (ACPI_FAILURE (status) || walk_state->result_obj) {
 		acpi_ut_remove_reference (return_desc);
 	}
 
 	/* Set the return object and exit */
 
-	if (!walk_state->result_obj) {
+	else {
 		walk_state->result_obj = return_desc;
 	}
 	return_ACPI_STATUS (status);
diff --git a/drivers/acpi/executer/exoparg6.c b/drivers/acpi/executer/exoparg6.c
--- a/drivers/acpi/executer/exoparg6.c
+++ b/drivers/acpi/executer/exoparg6.c
@@ -75,6 +75,14 @@
  * fully resolved operands.
 !*/
 
+/* Local prototypes */
+
+static u8
+acpi_ex_do_match (
+	u32                             match_op,
+	union acpi_operand_object       *package_obj,
+	union acpi_operand_object       *match_obj);
+
 
 /*******************************************************************************
  *
@@ -92,7 +100,7 @@
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ex_do_match (
 	u32                             match_op,
 	union acpi_operand_object       *package_obj,
@@ -216,11 +224,12 @@ acpi_ex_opcode_6A_0T_1R (
 	union acpi_operand_object       **operand = &walk_state->operands[0];
 	union acpi_operand_object       *return_desc = NULL;
 	acpi_status                     status = AE_OK;
-	u32                             index;
+	acpi_integer                    index;
 	union acpi_operand_object       *this_element;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ex_opcode_6A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_6A_0T_1R",
+		acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
@@ -241,9 +250,11 @@ acpi_ex_opcode_6A_0T_1R (
 
 		/* Get the package start_index, validate against the package length */
 
-		index = (u32) operand[5]->integer.value;
-		if (index >= (u32) operand[0]->package.count) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index beyond package end\n"));
+		index = operand[5]->integer.value;
+		if (index >= operand[0]->package.count) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Index (%X%8.8X) beyond package end (%X)\n",
+				ACPI_FORMAT_UINT64 (index), operand[0]->package.count));
 			status = AE_AML_PACKAGE_LIMIT;
 			goto cleanup;
 		}
@@ -314,13 +325,12 @@ acpi_ex_opcode_6A_0T_1R (
 
 	default:
 
-		ACPI_REPORT_ERROR (("acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_6A_0T_1R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
 
-
 	walk_state->result_obj = return_desc;
 
 
diff --git a/drivers/acpi/executer/exprep.c b/drivers/acpi/executer/exprep.c
--- a/drivers/acpi/executer/exprep.c
+++ b/drivers/acpi/executer/exprep.c
@@ -52,8 +52,23 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exprep")
 
+/* Local prototypes */
+
+static u32
+acpi_ex_decode_field_access (
+	union acpi_operand_object       *obj_desc,
+	u8                              field_flags,
+	u32                             *return_byte_alignment);
+
 
 #ifdef ACPI_UNDER_DEVELOPMENT
+
+static u32
+acpi_ex_generate_access (
+	u32                             field_bit_offset,
+	u32                             field_bit_length,
+	u32                             region_length);
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_generate_access
@@ -99,12 +114,14 @@ acpi_ex_generate_access (
 	/* Round Field start offset and length to "minimal" byte boundaries */
 
 	field_byte_offset  = ACPI_DIV_8 (ACPI_ROUND_DOWN (field_bit_offset, 8));
-	field_byte_end_offset = ACPI_DIV_8 (ACPI_ROUND_UP (field_bit_length + field_bit_offset, 8));
+	field_byte_end_offset = ACPI_DIV_8 (ACPI_ROUND_UP (field_bit_length +
+			   field_bit_offset, 8));
 	field_byte_length  = field_byte_end_offset - field_byte_offset;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Bit length %d, Bit offset %d\n",
 			field_bit_length, field_bit_offset));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Byte Length %d, Byte Offset %d, End Offset %d\n",
 			field_byte_length, field_byte_offset, field_byte_end_offset));
@@ -117,20 +134,26 @@ acpi_ex_generate_access (
 	 */
 	for (access_byte_width = 1; access_byte_width <= 8; access_byte_width <<= 1) {
 		/*
-		 * 1) Round end offset up to next access boundary and make sure that this
-		 *    does not go beyond the end of the parent region.
-		 * 2) When the Access width is greater than the field_byte_length, we are done.
-		 *    (This does not optimize for the perfectly aligned case yet).
+		 * 1) Round end offset up to next access boundary and make sure that
+		 *    this does not go beyond the end of the parent region.
+		 * 2) When the Access width is greater than the field_byte_length, we
+		 *    are done. (This does not optimize for the perfectly aligned
+		 *    case yet).
 		 */
 		if (ACPI_ROUND_UP (field_byte_end_offset, access_byte_width) <= region_length) {
-			field_start_offset = ACPI_ROUND_DOWN (field_byte_offset, access_byte_width) /
-					  access_byte_width;
-			field_end_offset = ACPI_ROUND_UP   ((field_byte_length + field_byte_offset),
-					  access_byte_width) / access_byte_width;
-			accesses         = field_end_offset - field_start_offset;
+			field_start_offset =
+				ACPI_ROUND_DOWN (field_byte_offset, access_byte_width) /
+				access_byte_width;
+
+			field_end_offset =
+				ACPI_ROUND_UP ((field_byte_length + field_byte_offset),
+					access_byte_width) / access_byte_width;
+
+			accesses = field_end_offset - field_start_offset;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"access_width %d end is within region\n", access_byte_width));
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"Field Start %d, Field End %d -- requires %d accesses\n",
 					field_start_offset, field_end_offset, accesses));
@@ -139,8 +162,8 @@ acpi_ex_generate_access (
 
 			if (accesses <= 1) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-						"Entire field can be accessed with one operation of size %d\n",
-						access_byte_width));
+					"Entire field can be accessed with one operation of size %d\n",
+					access_byte_width));
 				return_VALUE (access_byte_width);
 			}
 
@@ -155,15 +178,20 @@ acpi_ex_generate_access (
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-					"access_width %d end is NOT within region\n", access_byte_width));
+				"access_width %d end is NOT within region\n", access_byte_width));
 			if (access_byte_width == 1) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 						"Field goes beyond end-of-region!\n"));
-				return_VALUE (0);     /* Field does not fit in the region at all */
-			}
 
-			/* This width goes beyond the end-of-region, back off to previous access */
+				/* Field does not fit in the region at all */
 
+				return_VALUE (0);
+			}
+
+			/*
+			 * This width goes beyond the end-of-region, back off to
+			 * previous access
+			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 					"Backing off to previous optimal access width of %d\n",
 					minimum_access_width));
@@ -171,8 +199,10 @@ acpi_ex_generate_access (
 		}
 	}
 
-	/* Could not read/write field with one operation, just use max access width */
-
+	/*
+	 * Could not read/write field with one operation,
+	 * just use max access width
+	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
 			"Cannot access field in one operation, using width 8\n"));
 	return_VALUE (8);
@@ -184,8 +214,9 @@ acpi_ex_generate_access (
  *
  * FUNCTION:    acpi_ex_decode_field_access
  *
- * PARAMETERS:  Access          - Encoded field access bits
- *              Length          - Field length.
+ * PARAMETERS:  obj_desc            - Field object
+ *              field_flags         - Encoded fieldflags (contains access bits)
+ *              return_byte_alignment - Where the byte alignment is returned
  *
  * RETURN:      Field granularity (8, 16, 32 or 64) and
  *              byte_alignment (1, 2, 3, or 4)
@@ -214,9 +245,10 @@ acpi_ex_decode_field_access (
 	case AML_FIELD_ACCESS_ANY:
 
 #ifdef ACPI_UNDER_DEVELOPMENT
-		byte_alignment = acpi_ex_generate_access (obj_desc->common_field.start_field_bit_offset,
-				 obj_desc->common_field.bit_length,
-				 0xFFFFFFFF /* Temp until we pass region_length as param */);
+		byte_alignment =
+			acpi_ex_generate_access (obj_desc->common_field.start_field_bit_offset,
+				obj_desc->common_field.bit_length,
+				0xFFFFFFFF /* Temp until we pass region_length as parameter */);
 		bit_length = byte_alignment * 8;
 #endif
 
@@ -276,6 +308,7 @@ acpi_ex_decode_field_access (
  *              field_flags         - Access, lock_rule, and update_rule.
  *                                    The format of a field_flag is described
  *                                    in the ACPI specification
+ *              field_attribute     - Special attributes (not used)
  *              field_bit_position  - Field start position
  *              field_bit_length    - Field length in number of bits
  *
@@ -337,7 +370,7 @@ acpi_ex_prep_common_field_object (
 	/* Setup width (access granularity) fields */
 
 	obj_desc->common_field.access_byte_width = (u8)
-			ACPI_DIV_8 (access_bit_width); /* 1, 2, 4,  8 */
+			ACPI_DIV_8 (access_bit_width);          /* 1,  2,  4,  8 */
 
 	obj_desc->common_field.access_bit_width = (u8) access_bit_width;
 
@@ -380,11 +413,7 @@ acpi_ex_prep_common_field_object (
  *
  * FUNCTION:    acpi_ex_prep_field_value
  *
- * PARAMETERS:  Node                - Owning Node
- *              region_node         - Region in which field is being defined
- *              field_flags         - Access, lock_rule, and update_rule.
- *              field_bit_position  - Field start position
- *              field_bit_length    - Field length in number of bits
+ * PARAMETERS:  Info    - Contains all field creation info
  *
  * RETURN:      Status
  *
@@ -445,7 +474,7 @@ acpi_ex_prep_field_value (
 	switch (info->field_type) {
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 
-		obj_desc->field.region_obj   = acpi_ns_get_attached_object (info->region_node);
+		obj_desc->field.region_obj = acpi_ns_get_attached_object (info->region_node);
 
 		/* An additional reference for the container */
 
@@ -461,8 +490,10 @@ acpi_ex_prep_field_value (
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
 		obj_desc->bank_field.value   = info->bank_value;
-		obj_desc->bank_field.region_obj = acpi_ns_get_attached_object (info->region_node);
-		obj_desc->bank_field.bank_obj = acpi_ns_get_attached_object (info->register_node);
+		obj_desc->bank_field.region_obj = acpi_ns_get_attached_object (
+				 info->region_node);
+		obj_desc->bank_field.bank_obj = acpi_ns_get_attached_object (
+				 info->register_node);
 
 		/* An additional reference for the attached objects */
 
@@ -481,10 +512,13 @@ acpi_ex_prep_field_value (
 
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		obj_desc->index_field.index_obj = acpi_ns_get_attached_object (info->register_node);
-		obj_desc->index_field.data_obj = acpi_ns_get_attached_object (info->data_register_node);
+		obj_desc->index_field.index_obj = acpi_ns_get_attached_object (
+				 info->register_node);
+		obj_desc->index_field.data_obj = acpi_ns_get_attached_object (
+				 info->data_register_node);
 		obj_desc->index_field.value  = (u32)
-			(info->field_bit_position / ACPI_MUL_8 (obj_desc->field.access_byte_width));
+			(info->field_bit_position / ACPI_MUL_8 (
+					  obj_desc->field.access_byte_width));
 
 		if (!obj_desc->index_field.data_obj || !obj_desc->index_field.index_obj) {
 			ACPI_REPORT_ERROR (("Null Index Object during field prep\n"));
diff --git a/drivers/acpi/executer/exregion.c b/drivers/acpi/executer/exregion.c
--- a/drivers/acpi/executer/exregion.c
+++ b/drivers/acpi/executer/exregion.c
@@ -115,7 +115,6 @@ acpi_ex_system_memory_space_handler (
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 	}
 
-
 #ifndef ACPI_MISALIGNED_TRANSFERS
 	/*
 	 * Hardware does not support non-aligned data transfers, we must verify
@@ -134,7 +133,8 @@ acpi_ex_system_memory_space_handler (
 	 */
 	if ((address < mem_info->mapped_physical_address) ||
 		(((acpi_integer) address + length) >
-			((acpi_integer) mem_info->mapped_physical_address + mem_info->mapped_length))) {
+			((acpi_integer)
+			mem_info->mapped_physical_address + mem_info->mapped_length))) {
 		/*
 		 * The request cannot be resolved by the current memory mapping;
 		 * Delete the existing mapping and create a new one.
@@ -150,7 +150,9 @@ acpi_ex_system_memory_space_handler (
 		 * Don't attempt to map memory beyond the end of the region, and
 		 * constrain the maximum mapping size to something reasonable.
 		 */
-		window_size = (acpi_size) ((mem_info->address + mem_info->length) - address);
+		window_size = (acpi_size)
+			((mem_info->address + mem_info->length) - address);
+
 		if (window_size > ACPI_SYSMEM_REGION_WINDOW_SIZE) {
 			window_size = ACPI_SYSMEM_REGION_WINDOW_SIZE;
 		}
@@ -160,8 +162,9 @@ acpi_ex_system_memory_space_handler (
 		status = acpi_os_map_memory (address, window_size,
 				  (void **) &mem_info->mapped_logical_address);
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %8.8X%8.8X, size %X\n",
-					ACPI_FORMAT_UINT64 (address), (u32) window_size));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not map memory at %8.8X%8.8X, size %X\n",
+				ACPI_FORMAT_UINT64 (address), (u32) window_size));
 			mem_info->mapped_length = 0;
 			return_ACPI_STATUS (status);
 		}
@@ -177,10 +180,12 @@ acpi_ex_system_memory_space_handler (
 	 * access
 	 */
 	logical_addr_ptr = mem_info->mapped_logical_address +
-			  ((acpi_integer) address - (acpi_integer) mem_info->mapped_physical_address);
+			   ((acpi_integer) address -
+					  (acpi_integer) mem_info->mapped_physical_address);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"system_memory %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
+			"system_memory %d (%d width) Address=%8.8X%8.8X\n",
+			function, bit_width,
 			ACPI_FORMAT_UINT64 (address)));
 
    /*
@@ -298,13 +303,15 @@ acpi_ex_system_io_space_handler (
 	switch (function) {
 	case ACPI_READ:
 
-		status = acpi_os_read_port ((acpi_io_address) address, &value32, bit_width);
+		status = acpi_os_read_port ((acpi_io_address) address,
+				 &value32, bit_width);
 		*value = value32;
 		break;
 
 	case ACPI_WRITE:
 
-		status = acpi_os_write_port ((acpi_io_address) address, (u32) *value, bit_width);
+		status = acpi_os_write_port ((acpi_io_address) address,
+				 (u32) *value, bit_width);
 		break;
 
 	default:
@@ -375,12 +382,14 @@ acpi_ex_pci_config_space_handler (
 	case ACPI_READ:
 
 		*value = 0;
-		status = acpi_os_read_pci_configuration (pci_id, pci_register, value, bit_width);
+		status = acpi_os_read_pci_configuration (pci_id, pci_register,
+				 value, bit_width);
 		break;
 
 	case ACPI_WRITE:
 
-		status = acpi_os_write_pci_configuration (pci_id, pci_register, *value, bit_width);
+		status = acpi_os_write_pci_configuration (pci_id, pci_register,
+				 *value, bit_width);
 		break;
 
 	default:
@@ -505,8 +514,7 @@ acpi_ex_data_table_space_handler (
 
 	logical_addr_ptr = ACPI_PHYSADDR_TO_PTR (address);
 
-
-   /* Perform the memory read or write */
+	/* Perform the memory read or write */
 
 	switch (function) {
 	case ACPI_READ:
diff --git a/drivers/acpi/executer/exresnte.c b/drivers/acpi/executer/exresnte.c
--- a/drivers/acpi/executer/exresnte.c
+++ b/drivers/acpi/executer/exresnte.c
@@ -210,15 +210,15 @@ acpi_ex_resolve_node_to_value (
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "field_read Node=%p source_desc=%p Type=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"field_read Node=%p source_desc=%p Type=%X\n",
 			node, source_desc, entry_type));
 
 		status = acpi_ex_read_data_from_field (walk_state, source_desc, &obj_desc);
 		break;
 
-	/*
-	 * For these objects, just return the object attached to the Node
-	 */
+	/* For these objects, just return the object attached to the Node */
+
 	case ACPI_TYPE_MUTEX:
 	case ACPI_TYPE_METHOD:
 	case ACPI_TYPE_POWER:
@@ -233,12 +233,12 @@ acpi_ex_resolve_node_to_value (
 		acpi_ut_add_reference (obj_desc);
 		break;
 
-
 	/* TYPE_ANY is untyped, and thus there is no object associated with it */
 
 	case ACPI_TYPE_ANY:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Untyped entry %p, no attached object!\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Untyped entry %p, no attached object!\n",
 			node));
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);  /* Cannot be AE_TYPE */
@@ -259,7 +259,8 @@ acpi_ex_resolve_node_to_value (
 		default:
 			/* No named references are allowed here */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported Reference opcode %X (%s)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Unsupported Reference opcode %X (%s)\n",
 				source_desc->reference.opcode,
 				acpi_ps_get_opcode_name (source_desc->reference.opcode)));
 
@@ -268,11 +269,12 @@ acpi_ex_resolve_node_to_value (
 		break;
 
 
-	/* Default case is for unknown types */
-
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Node %p - Unknown object type %X\n",
+		/* Default case is for unknown types */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Node %p - Unknown object type %X\n",
 			node, entry_type));
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
@@ -280,7 +282,7 @@ acpi_ex_resolve_node_to_value (
 	} /* switch (entry_type) */
 
 
-	/* Put the object descriptor on the stack */
+	/* Return the object descriptor */
 
 	*object_ptr = (void *) obj_desc;
 	return_ACPI_STATUS (status);
diff --git a/drivers/acpi/executer/exresolv.c b/drivers/acpi/executer/exresolv.c
--- a/drivers/acpi/executer/exresolv.c
+++ b/drivers/acpi/executer/exresolv.c
@@ -54,6 +54,13 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exresolv")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_resolve_object_to_value (
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
 
 /*******************************************************************************
  *
@@ -96,6 +103,11 @@ acpi_ex_resolve_to_value (
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
+
+		if (!*stack_ptr) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null pointer\n"));
+			return_ACPI_STATUS (AE_AML_NO_OPERAND);
+		}
 	}
 
 	/*
@@ -120,18 +132,17 @@ acpi_ex_resolve_to_value (
  *
  * FUNCTION:    acpi_ex_resolve_object_to_value
  *
- * PARAMETERS:  stack_ptr       - Pointer to a stack location that contains a
- *                                ptr to an internal object.
+ * PARAMETERS:  stack_ptr       - Pointer to an internal object
  *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieve the value from an internal object.  The Reference type
+ * DESCRIPTION: Retrieve the value from an internal object. The Reference type
  *              uses the associated AML opcode to determine the value.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_resolve_object_to_value (
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state)
@@ -159,7 +170,7 @@ acpi_ex_resolve_object_to_value (
 		case AML_NAME_OP:
 
 			/*
-			 * Convert indirect name ptr to a direct name ptr.
+			 * Convert name reference to a namespace node
 			 * Then, acpi_ex_resolve_node_to_value can be used to get the value
 			 */
 			temp_node = stack_desc->reference.object;
@@ -168,7 +179,7 @@ acpi_ex_resolve_object_to_value (
 
 			acpi_ut_remove_reference (stack_desc);
 
-			/* Put direct name pointer onto stack and exit */
+			/* Return the namespace node */
 
 			(*stack_ptr) = temp_node;
 			break;
@@ -255,10 +266,19 @@ acpi_ex_resolve_object_to_value (
 
 			break;
 
+		case AML_INT_NAMEPATH_OP:   /* Reference to a named object */
+
+			/* Get the object pointed to by the namespace node */
+
+			*stack_ptr = (stack_desc->reference.node)->object;
+			acpi_ut_add_reference (*stack_ptr);
+			acpi_ut_remove_reference (stack_desc);
+			break;
 
 		default:
 
-			ACPI_REPORT_ERROR (("During resolve, Unknown Reference opcode %X (%s) in %p\n",
+			ACPI_REPORT_ERROR ((
+				"During resolve, Unknown Reference opcode %X (%s) in %p\n",
 				opcode, acpi_ps_get_opcode_name (opcode), stack_desc));
 			status = AE_AML_INTERNAL;
 			break;
@@ -278,9 +298,8 @@ acpi_ex_resolve_object_to_value (
 		break;
 
 
-	/*
-	 * These cases may never happen here, but just in case..
-	 */
+	/* These cases may never happen here, but just in case.. */
+
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
@@ -333,9 +352,8 @@ acpi_ex_resolve_multiple (
 	ACPI_FUNCTION_TRACE ("acpi_ex_resolve_multiple");
 
 
-	/*
-	 * Operand can be either a namespace node or an operand descriptor
-	 */
+	/* Operand can be either a namespace node or an operand descriptor */
+
 	switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
 	case ACPI_DESC_TYPE_OPERAND:
 		type = obj_desc->common.type;
@@ -357,10 +375,8 @@ acpi_ex_resolve_multiple (
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
 
+	/* If type is anything other than a reference, we are done */
 
-	/*
-	 * If type is anything other than a reference, we are done
-	 */
 	if (type != ACPI_TYPE_LOCAL_REFERENCE) {
 		goto exit;
 	}
@@ -382,8 +398,9 @@ acpi_ex_resolve_multiple (
 			/* All "References" point to a NS node */
 
 			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
-				ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
-						node, acpi_ut_get_descriptor_name (node)));
+				ACPI_REPORT_ERROR ((
+					"acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
+					node, acpi_ut_get_descriptor_name (node)));
 				return_ACPI_STATUS (AE_AML_INTERNAL);
 			}
 
@@ -440,8 +457,9 @@ acpi_ex_resolve_multiple (
 			/* All "References" point to a NS node */
 
 			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
-				ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
-						node, acpi_ut_get_descriptor_name (node)));
+				ACPI_REPORT_ERROR ((
+					"acpi_ex_resolve_multiple: Not a NS node %p [%s]\n",
+					node, acpi_ut_get_descriptor_name (node)));
 			   return_ACPI_STATUS (AE_AML_INTERNAL);
 			}
 
@@ -468,7 +486,7 @@ acpi_ex_resolve_multiple (
 
 			if (return_desc) {
 				status = acpi_ds_method_data_get_value (obj_desc->reference.opcode,
-						  obj_desc->reference.offset, walk_state, &obj_desc);
+						 obj_desc->reference.offset, walk_state, &obj_desc);
 				if (ACPI_FAILURE (status)) {
 					return_ACPI_STATUS (status);
 				}
@@ -500,7 +518,8 @@ acpi_ex_resolve_multiple (
 
 		default:
 
-			ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Unknown Reference subtype %X\n",
+			ACPI_REPORT_ERROR ((
+				"acpi_ex_resolve_multiple: Unknown Reference subtype %X\n",
 				obj_desc->reference.opcode));
 			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
diff --git a/drivers/acpi/executer/exresop.c b/drivers/acpi/executer/exresop.c
--- a/drivers/acpi/executer/exresop.c
+++ b/drivers/acpi/executer/exresop.c
@@ -52,6 +52,14 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exresop")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ex_check_object_type (
+	acpi_object_type                type_needed,
+	acpi_object_type                this_type,
+	void                            *object);
+
 
 /*******************************************************************************
  *
@@ -67,7 +75,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_check_object_type (
 	acpi_object_type                type_needed,
 	acpi_object_type                this_type,
@@ -142,6 +150,7 @@ acpi_ex_resolve_operands (
 	const struct acpi_opcode_info   *op_info;
 	u32                             this_arg_type;
 	acpi_object_type                type_needed;
+	u16                             target_op = 0;
 
 
 	ACPI_FUNCTION_TRACE_U32 ("ex_resolve_operands", opcode);
@@ -160,7 +169,8 @@ acpi_ex_resolve_operands (
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X [%s] required_operand_types=%8.8X \n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"Opcode %X [%s] required_operand_types=%8.8X \n",
 		opcode, op_info->name, arg_types));
 
 	/*
@@ -187,7 +197,7 @@ acpi_ex_resolve_operands (
 		switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
 		case ACPI_DESC_TYPE_NAMED:
 
-			/* Node */
+			/* Namespace Node */
 
 			object_type = ((struct acpi_namespace_node *) obj_desc)->type;
 			break;
@@ -202,16 +212,16 @@ acpi_ex_resolve_operands (
 			/* Check for bad acpi_object_type */
 
 			if (!acpi_ut_valid_object_type (object_type)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad operand object type [%X]\n",
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Bad operand object type [%X]\n",
 					object_type));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 
 			if (object_type == (u8) ACPI_TYPE_LOCAL_REFERENCE) {
-				/*
-				 * Decode the Reference
-				 */
+				/* Decode the Reference */
+
 				op_info = acpi_ps_get_opcode_info (opcode);
 				if (op_info->class == AML_CLASS_UNKNOWN) {
 					return_ACPI_STATUS (AE_AML_BAD_OPCODE);
@@ -219,12 +229,17 @@ acpi_ex_resolve_operands (
 
 				switch (obj_desc->reference.opcode) {
 				case AML_DEBUG_OP:
+					target_op = AML_DEBUG_OP;
+
+					/*lint -fallthrough */
+
 				case AML_NAME_OP:
 				case AML_INDEX_OP:
 				case AML_REF_OF_OP:
 				case AML_ARG_OP:
 				case AML_LOCAL_OP:
-				case AML_LOAD_OP:   /* ddb_handle from LOAD_OP or LOAD_TABLE_OP */
+				case AML_LOAD_OP: /* ddb_handle from LOAD_OP or LOAD_TABLE_OP */
+				case AML_INT_NAMEPATH_OP: /* Reference to a named object */
 
 					ACPI_DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 						"Operand is a Reference, ref_opcode [%s]\n",
@@ -254,10 +269,8 @@ acpi_ex_resolve_operands (
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
+		/* Get one argument type, point to the next */
 
-		/*
-		 * Get one argument type, point to the next
-		 */
 		this_arg_type = GET_CURRENT_ARG_TYPE (arg_types);
 		INCREMENT_ARG_LIST (arg_types);
 
@@ -271,26 +284,31 @@ acpi_ex_resolve_operands (
 			if ((ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) &&
 				(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_STRING)) {
 				/*
-				 * String found - the string references a named object and must be
-				 * resolved to a node
+				 * String found - the string references a named object and
+				 * must be resolved to a node
 				 */
 				goto next_operand;
 			}
 
-			/* Else not a string - fall through to the normal Reference case below */
+			/*
+			 * Else not a string - fall through to the normal Reference
+			 * case below
+			 */
 			/*lint -fallthrough */
 
 		case ARGI_REFERENCE:            /* References: */
 		case ARGI_INTEGER_REF:
 		case ARGI_OBJECT_REF:
 		case ARGI_DEVICE_REF:
-		case ARGI_TARGETREF:            /* Allows implicit conversion rules before store */
-		case ARGI_FIXED_TARGET:         /* No implicit conversion before store to target */
-		case ARGI_SIMPLE_TARGET:        /* Name, Local, or Arg - no implicit conversion  */
-
-			/* Need an operand of type ACPI_TYPE_LOCAL_REFERENCE */
+		case ARGI_TARGETREF:     /* Allows implicit conversion rules before store */
+		case ARGI_FIXED_TARGET:  /* No implicit conversion before store to target */
+		case ARGI_SIMPLE_TARGET: /* Name, Local, or Arg - no implicit conversion  */
 
-			if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) /* Node (name) ptr OK as-is */ {
+			/*
+			 * Need an operand of type ACPI_TYPE_LOCAL_REFERENCE
+			 * A Namespace Node is OK as-is
+			 */
+			if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
 				goto next_operand;
 			}
 
@@ -300,11 +318,9 @@ acpi_ex_resolve_operands (
 				return_ACPI_STATUS (status);
 			}
 
-			if (AML_NAME_OP == obj_desc->reference.opcode) {
-				/*
-				 * Convert an indirect name ptr to direct name ptr and put
-				 * it on the stack
-				 */
+			if (obj_desc->reference.opcode == AML_NAME_OP) {
+				/* Convert a named reference to the actual named object */
+
 				temp_node = obj_desc->reference.object;
 				acpi_ut_remove_reference (obj_desc);
 				(*stack_ptr) = temp_node;
@@ -332,7 +348,6 @@ acpi_ex_resolve_operands (
 			break;
 		}
 
-
 		/*
 		 * Resolve this object to a value
 		 */
@@ -392,7 +407,7 @@ acpi_ex_resolve_operands (
 		/*
 		 * The more complex cases allow multiple resolved object types
 		 */
-		case ARGI_INTEGER:   /* Number */
+		case ARGI_INTEGER:
 
 			/*
 			 * Need an operand of type ACPI_TYPE_INTEGER,
@@ -411,6 +426,10 @@ acpi_ex_resolve_operands (
 
 				return_ACPI_STATUS (status);
 			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference (obj_desc);
+			}
 			goto next_operand;
 
 
@@ -433,6 +452,10 @@ acpi_ex_resolve_operands (
 
 				return_ACPI_STATUS (status);
 			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference (obj_desc);
+			}
 			goto next_operand;
 
 
@@ -456,6 +479,10 @@ acpi_ex_resolve_operands (
 
 				return_ACPI_STATUS (status);
 			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference (obj_desc);
+			}
 			goto next_operand;
 
 
@@ -500,6 +527,10 @@ acpi_ex_resolve_operands (
 				if (ACPI_FAILURE (status)) {
 					return_ACPI_STATUS (status);
 				}
+
+				if (obj_desc != *stack_ptr) {
+					acpi_ut_remove_reference (obj_desc);
+				}
 				break;
 
 			default:
@@ -563,7 +594,7 @@ acpi_ex_resolve_operands (
 
 		case ARGI_REGION_OR_FIELD:
 
-			/* Need an operand of type ACPI_TYPE_REGION or a FIELD in a region */
+			/* Need an operand of type REGION or a FIELD in a region */
 
 			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 			case ACPI_TYPE_REGION:
@@ -614,6 +645,12 @@ acpi_ex_resolve_operands (
 					break;
 				}
 
+				if (target_op == AML_DEBUG_OP) {
+					/* Allow store of any object to the Debug object */
+
+					break;
+				}
+
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 					"Needed Integer/Buffer/String/Package/Ref/Ddb], found [%s] %p\n",
 					acpi_ut_get_object_type_name (obj_desc), obj_desc));
@@ -652,8 +689,7 @@ next_operand:
 		if (GET_CURRENT_ARG_TYPE (arg_types)) {
 			stack_ptr--;
 		}
-
-	}   /* while (*Types) */
+	}
 
 	return_ACPI_STATUS (status);
 }
diff --git a/drivers/acpi/executer/exstore.c b/drivers/acpi/executer/exstore.c
--- a/drivers/acpi/executer/exstore.c
+++ b/drivers/acpi/executer/exstore.c
@@ -48,11 +48,171 @@
 #include <acpi/acinterp.h>
 #include <acpi/amlcode.h>
 #include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exstore")
 
+/* Local prototypes */
+
+static void
+acpi_ex_do_debug_object (
+	union acpi_operand_object       *source_desc,
+	u32                             level,
+	u32                             index);
+
+static acpi_status
+acpi_ex_store_object_to_index (
+	union acpi_operand_object       *val_desc,
+	union acpi_operand_object       *dest_desc,
+	struct acpi_walk_state          *walk_state);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_debug_object
+ *
+ * PARAMETERS:  source_desc         - Value to be stored
+ *              Level               - Indentation level (used for packages)
+ *              Index               - Current package element, zero if not pkg
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Handles stores to the Debug Object.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_do_debug_object (
+	union acpi_operand_object       *source_desc,
+	u32                             level,
+	u32                             index)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ex_do_debug_object", source_desc);
+
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[ACPI Debug] %*s",
+		level, " "));
+
+	/* Display index for package output only */
+
+	if (index > 0) {
+	   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
+		   "(%.2u) ", index -1));
+	}
+
+	if (!source_desc) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "<Null Object>\n"));
+		return_VOID;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE (source_desc) == ACPI_DESC_TYPE_OPERAND) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%s: ",
+			acpi_ut_get_object_type_name (source_desc)));
+
+		if (!acpi_ut_valid_internal_object (source_desc)) {
+		   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
+			   "%p, Invalid Internal Object!\n", source_desc));
+		   return_VOID;
+		}
+	}
+	else if (ACPI_GET_DESCRIPTOR_TYPE (source_desc) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%s: %p\n",
+			acpi_ut_get_type_name (((struct acpi_namespace_node *) source_desc)->type),
+			source_desc));
+		return_VOID;
+	}
+	else {
+		return_VOID;
+	}
+
+	switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
+	case ACPI_TYPE_INTEGER:
+
+		/* Output correct integer width */
+
+		if (acpi_gbl_integer_byte_width == 4) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X\n",
+				(u32) source_desc->integer.value));
+		}
+		else {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X%8.8X\n",
+				ACPI_FORMAT_UINT64 (source_desc->integer.value)));
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X]\n",
+			(u32) source_desc->buffer.length));
+		ACPI_DUMP_BUFFER (source_desc->buffer.pointer,
+			(source_desc->buffer.length < 32) ? source_desc->buffer.length : 32);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] \"%s\"\n",
+			source_desc->string.length, source_desc->string.pointer));
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X Elements]\n",
+			source_desc->package.count));
+
+		/* Output the entire contents of the package */
+
+		for (i = 0; i < source_desc->package.count; i++) {
+			acpi_ex_do_debug_object (source_desc->package.elements[i],
+				level+4, i+1);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		if (source_desc->reference.opcode == AML_INDEX_OP) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[%s, 0x%X]\n",
+				acpi_ps_get_opcode_name (source_desc->reference.opcode),
+				source_desc->reference.offset));
+		}
+		else {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[%s]\n",
+				acpi_ps_get_opcode_name (source_desc->reference.opcode)));
+		}
+
+
+		if (source_desc->reference.object) {
+			if (ACPI_GET_DESCRIPTOR_TYPE (source_desc->reference.object) ==
+					ACPI_DESC_TYPE_NAMED) {
+				acpi_ex_do_debug_object (((struct acpi_namespace_node *)
+					source_desc->reference.object)->object,
+					level+4, 0);
+			}
+			else {
+				acpi_ex_do_debug_object (source_desc->reference.object, level+4, 0);
+			}
+		}
+		else if (source_desc->reference.node) {
+			acpi_ex_do_debug_object ((source_desc->reference.node)->object,
+				level+4, 0);
+		}
+		break;
+
+	default:
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%p %s\n",
+			source_desc, acpi_ut_get_object_type_name (source_desc)));
+		break;
+	}
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "\n"));
+	return_VOID;
+}
+
 
 /*******************************************************************************
  *
@@ -154,8 +314,9 @@ acpi_ex_store (
 
 		/* Storing an object into a Name "container" */
 
-		status = acpi_ex_store_object_to_node (source_desc, ref_desc->reference.object,
-				  walk_state, ACPI_IMPLICIT_CONVERSION);
+		status = acpi_ex_store_object_to_node (source_desc,
+				 ref_desc->reference.object,
+				 walk_state, ACPI_IMPLICIT_CONVERSION);
 		break;
 
 
@@ -173,7 +334,7 @@ acpi_ex_store (
 		/* Store to a method local/arg  */
 
 		status = acpi_ds_store_object_to_local (ref_desc->reference.opcode,
-				  ref_desc->reference.offset, source_desc, walk_state);
+				 ref_desc->reference.offset, source_desc, walk_state);
 		break;
 
 
@@ -187,60 +348,7 @@ acpi_ex_store (
 			"**** Write to Debug Object: Object %p %s ****:\n\n",
 			source_desc, acpi_ut_get_object_type_name (source_desc)));
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[ACPI Debug] %s: ",
-			acpi_ut_get_object_type_name (source_desc)));
-
-		if (!acpi_ut_valid_internal_object (source_desc)) {
-		   ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT,
-			   "%p, Invalid Internal Object!\n", source_desc));
-		   break;
-		}
-
-		switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
-		case ACPI_TYPE_INTEGER:
-
-			if (acpi_gbl_integer_byte_width == 4) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X\n",
-					(u32) source_desc->integer.value));
-			}
-			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%8.8X%8.8X\n",
-					ACPI_FORMAT_UINT64 (source_desc->integer.value)));
-			}
-			break;
-
-
-		case ACPI_TYPE_BUFFER:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X]",
-				(u32) source_desc->buffer.length));
-			ACPI_DUMP_BUFFER (source_desc->buffer.pointer,
-				(source_desc->buffer.length < 32) ? source_desc->buffer.length : 32);
-			break;
-
-
-		case ACPI_TYPE_STRING:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] \"%s\"\n",
-				source_desc->string.length, source_desc->string.pointer));
-			break;
-
-
-		case ACPI_TYPE_PACKAGE:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[0x%.2X] Elements Ptr - %p\n",
-				source_desc->package.count, source_desc->package.elements));
-			break;
-
-
-		default:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%p\n",
-				source_desc));
-			break;
-		}
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "\n"));
+		acpi_ex_do_debug_object (source_desc, 0, 0);
 		break;
 
 
@@ -272,7 +380,7 @@ acpi_ex_store (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ex_store_object_to_index (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *index_desc,
@@ -313,16 +421,22 @@ acpi_ex_store_object_to_index (
 		if (obj_desc) {
 			/* Decrement reference count by the ref count of the parent package */
 
-			for (i = 0; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+			for (i = 0;
+				 i < ((union acpi_operand_object *)
+						index_desc->reference.object)->common.reference_count;
+				 i++) {
 				acpi_ut_remove_reference (obj_desc);
 			}
 		}
 
 		*(index_desc->reference.where) = new_desc;
 
-		/* Increment reference count by the ref count of the parent package -1 */
+		/* Increment ref count by the ref count of the parent package-1 */
 
-		for (i = 1; i < ((union acpi_operand_object *) index_desc->reference.object)->common.reference_count; i++) {
+		for (i = 1;
+			 i < ((union acpi_operand_object *)
+					index_desc->reference.object)->common.reference_count;
+			 i++) {
 			acpi_ut_add_reference (new_desc);
 		}
 
@@ -440,9 +554,8 @@ acpi_ex_store_object_to_node (
 	ACPI_FUNCTION_TRACE_PTR ("ex_store_object_to_node", source_desc);
 
 
-	/*
-	 * Get current type of the node, and object attached to Node
-	 */
+	/* Get current type of the node, and object attached to Node */
+
 	target_type = acpi_ns_get_type (node);
 	target_desc = acpi_ns_get_attached_object (node);
 
@@ -461,25 +574,24 @@ acpi_ex_store_object_to_node (
 
 	/* If no implicit conversion, drop into the default case below */
 
-	if (!implicit_conversion) {
+	if ((!implicit_conversion) || (walk_state->opcode == AML_COPY_OP)) {
 		/* Force execution of default (no implicit conversion) */
 
 		target_type = ACPI_TYPE_ANY;
 	}
 
-	/*
-	 * Do the actual store operation
-	 */
+	/* Do the actual store operation */
+
 	switch (target_type) {
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
 	case ACPI_TYPE_LOCAL_BANK_FIELD:
 	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		/*
-		 * For fields, copy the source data to the target field.
-		 */
-		status = acpi_ex_write_data_to_field (source_desc, target_desc, &walk_state->result_obj);
+		/* For fields, copy the source data to the target field. */
+
+		status = acpi_ex_write_data_to_field (source_desc, target_desc,
+				 &walk_state->result_obj);
 		break;
 
 
@@ -493,7 +605,8 @@ acpi_ex_store_object_to_node (
 		 *
 		 * Copy and/or convert the source object to a new target object
 		 */
-		status = acpi_ex_store_object_to_object (source_desc, target_desc, &new_desc, walk_state);
+		status = acpi_ex_store_object_to_object (source_desc, target_desc,
+				 &new_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -521,12 +634,13 @@ acpi_ex_store_object_to_node (
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Storing %s (%p) directly into node (%p), no implicit conversion\n",
+			"Storing %s (%p) directly into node (%p) with no implicit conversion\n",
 			acpi_ut_get_object_type_name (source_desc), source_desc, node));
 
 		/* No conversions for all other types.  Just attach the source object */
 
-		status = acpi_ns_attach_object (node, source_desc, ACPI_GET_OBJECT_TYPE (source_desc));
+		status = acpi_ns_attach_object (node, source_desc,
+				 ACPI_GET_OBJECT_TYPE (source_desc));
 		break;
 	}
 
diff --git a/drivers/acpi/executer/exstoren.c b/drivers/acpi/executer/exstoren.c
--- a/drivers/acpi/executer/exstoren.c
+++ b/drivers/acpi/executer/exstoren.c
@@ -81,9 +81,8 @@ acpi_ex_resolve_object (
 	ACPI_FUNCTION_TRACE ("ex_resolve_object");
 
 
-	/*
-	 * Ensure we have a Target that can be stored to
-	 */
+	/* Ensure we have a Target that can be stored to */
+
 	switch (target_type) {
 	case ACPI_TYPE_BUFFER_FIELD:
 	case ACPI_TYPE_LOCAL_REGION_FIELD:
@@ -118,16 +117,14 @@ acpi_ex_resolve_object (
 			break;
 		}
 
-		/*
-		 * Must have a Integer, Buffer, or String
-		 */
+		/* Must have a Integer, Buffer, or String */
+
 		if ((ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_INTEGER)   &&
 			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER)    &&
 			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_STRING)    &&
 			!((ACPI_GET_OBJECT_TYPE (source_desc) == ACPI_TYPE_LOCAL_REFERENCE) && (source_desc->reference.opcode == AML_LOAD_OP))) {
-			/*
-			 * Conversion successful but still not a valid type
-			 */
+			/* Conversion successful but still not a valid type */
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Cannot assign type %s to %s (must be type Int/Str/Buf)\n",
 				acpi_ut_get_object_type_name (source_desc),
@@ -140,9 +137,8 @@ acpi_ex_resolve_object (
 	case ACPI_TYPE_LOCAL_ALIAS:
 	case ACPI_TYPE_LOCAL_METHOD_ALIAS:
 
-		/*
-		 * Aliases are resolved by acpi_ex_prep_operands
-		 */
+		/* Aliases are resolved by acpi_ex_prep_operands */
+
 		ACPI_REPORT_ERROR (("Store into Alias - should never happen\n"));
 		status = AE_AML_INTERNAL;
 		break;
@@ -269,10 +265,6 @@ acpi_ex_store_object_to_object (
 
 	case ACPI_TYPE_BUFFER:
 
-		/*
-		 * Note: There is different store behavior depending on the original
-		 * source type
-		 */
 		status = acpi_ex_store_buffer_to_buffer (actual_src_desc, dest_desc);
 		break;
 
diff --git a/drivers/acpi/executer/exstorob.c b/drivers/acpi/executer/exstorob.c
--- a/drivers/acpi/executer/exstorob.c
+++ b/drivers/acpi/executer/exstorob.c
@@ -128,7 +128,8 @@ acpi_ex_store_buffer_to_buffer (
 	else {
 		/* Truncate the source, copy only what will fit */
 
-		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, target_desc->buffer.length);
+		ACPI_MEMCPY (target_desc->buffer.pointer, buffer,
+			target_desc->buffer.length);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"Truncating source buffer from %X to %X\n",
@@ -183,7 +184,8 @@ acpi_ex_store_string_to_string (
 		 * String will fit in existing non-static buffer.
 		 * Clear old string and copy in the new one
 		 */
-		ACPI_MEMSET (target_desc->string.pointer, 0, (acpi_size) target_desc->string.length + 1);
+		ACPI_MEMSET (target_desc->string.pointer, 0,
+			(acpi_size) target_desc->string.length + 1);
 		ACPI_MEMCPY (target_desc->string.pointer, buffer, length);
 	}
 	else {
@@ -198,7 +200,8 @@ acpi_ex_store_string_to_string (
 			ACPI_MEM_FREE (target_desc->string.pointer);
 		}
 
-		target_desc->string.pointer = ACPI_MEM_CALLOCATE ((acpi_size) length + 1);
+		target_desc->string.pointer = ACPI_MEM_CALLOCATE (
+				   (acpi_size) length + 1);
 		if (!target_desc->string.pointer) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
diff --git a/drivers/acpi/executer/exsystem.c b/drivers/acpi/executer/exsystem.c
--- a/drivers/acpi/executer/exsystem.c
+++ b/drivers/acpi/executer/exsystem.c
@@ -55,8 +55,8 @@
  *
  * FUNCTION:    acpi_ex_system_wait_semaphore
  *
- * PARAMETERS:  Semaphore           - OSD semaphore to wait on
- *              Timeout             - Max time to wait
+ * PARAMETERS:  Semaphore       - Semaphore to wait on
+ *              Timeout         - Max time to wait
  *
  * RETURN:      Status
  *
@@ -90,7 +90,8 @@ acpi_ex_system_wait_semaphore (
 
 		status = acpi_os_wait_semaphore (semaphore, 1, timeout);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*** Thread awake after blocking, %s\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"*** Thread awake after blocking, %s\n",
 			acpi_format_exception (status)));
 
 		/* Reacquire the interpreter */
@@ -111,8 +112,8 @@ acpi_ex_system_wait_semaphore (
  *
  * FUNCTION:    acpi_ex_system_do_stall
  *
- * PARAMETERS:  how_long            - The amount of time to stall,
- *                                    in microseconds
+ * PARAMETERS:  how_long        - The amount of time to stall,
+ *                                in microseconds
  *
  * RETURN:      Status
  *
@@ -141,7 +142,8 @@ acpi_ex_system_do_stall (
 		 * (ACPI specifies 100 usec as max, but this gives some slack in
 		 * order to support existing BIOSs)
 		 */
-		ACPI_REPORT_ERROR (("Stall: Time parameter is too large (%d)\n", how_long));
+		ACPI_REPORT_ERROR (("Stall: Time parameter is too large (%d)\n",
+			how_long));
 		status = AE_AML_OPERAND_VALUE;
 	}
 	else {
@@ -156,8 +158,8 @@ acpi_ex_system_do_stall (
  *
  * FUNCTION:    acpi_ex_system_do_suspend
  *
- * PARAMETERS:  how_long            - The amount of time to suspend,
- *                                    in milliseconds
+ * PARAMETERS:  how_long        - The amount of time to suspend,
+ *                                in milliseconds
  *
  * RETURN:      None
  *
@@ -192,8 +194,8 @@ acpi_ex_system_do_suspend (
  *
  * FUNCTION:    acpi_ex_system_acquire_mutex
  *
- * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
- *              *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  time_desc       - The 'time to delay' object descriptor
+ *              obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -218,16 +220,15 @@ acpi_ex_system_acquire_mutex (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Support for the _GL_ Mutex object -- go get the global lock
-	 */
+	/* Support for the _GL_ Mutex object -- go get the global lock */
+
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
 		status = acpi_ev_acquire_global_lock ((u16) time_desc->integer.value);
 		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_ex_system_wait_semaphore (obj_desc->mutex.semaphore,
-			  (u16) time_desc->integer.value);
+			 (u16) time_desc->integer.value);
 	return_ACPI_STATUS (status);
 }
 
@@ -236,7 +237,7 @@ acpi_ex_system_acquire_mutex (
  *
  * FUNCTION:    acpi_ex_system_release_mutex
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -261,9 +262,8 @@ acpi_ex_system_release_mutex (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Support for the _GL_ Mutex object -- release the global lock
-	 */
+	/* Support for the _GL_ Mutex object -- release the global lock */
+
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
 		status = acpi_ev_release_global_lock ();
 		return_ACPI_STATUS (status);
@@ -278,9 +278,9 @@ acpi_ex_system_release_mutex (
  *
  * FUNCTION:    acpi_ex_system_signal_event
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
- * RETURN:      AE_OK
+ * RETURN:      Status
  *
  * DESCRIPTION: Provides an access point to perform synchronization operations
  *              within the AML.
@@ -309,8 +309,8 @@ acpi_ex_system_signal_event (
  *
  * FUNCTION:    acpi_ex_system_wait_event
  *
- * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
- *              *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  time_desc       - The 'time to delay' object descriptor
+ *              obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -333,7 +333,7 @@ acpi_ex_system_wait_event (
 
 	if (obj_desc) {
 		status = acpi_ex_system_wait_semaphore (obj_desc->event.semaphore,
-				  (u16) time_desc->integer.value);
+				 (u16) time_desc->integer.value);
 	}
 
 	return_ACPI_STATUS (status);
@@ -344,7 +344,7 @@ acpi_ex_system_wait_event (
  *
  * FUNCTION:    acpi_ex_system_reset_event
  *
- * PARAMETERS:  *obj_desc           - The object descriptor for this op
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
  *
  * RETURN:      Status
  *
diff --git a/drivers/acpi/executer/exutils.c b/drivers/acpi/executer/exutils.c
--- a/drivers/acpi/executer/exutils.c
+++ b/drivers/acpi/executer/exutils.c
@@ -67,22 +67,31 @@
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exutils")
 
+/* Local prototypes */
 
-#ifndef ACPI_NO_METHOD_EXECUTION
+static u32
+acpi_ex_digits_needed (
+	acpi_integer                    value,
+	u32                             base);
 
+
+#ifndef ACPI_NO_METHOD_EXECUTION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ex_enter_interpreter
  *
  * PARAMETERS:  None
  *
+ * RETURN:      Status
+ *
  * DESCRIPTION: Enter the interpreter execution region.  Failure to enter
  *              the interpreter region is a fatal system error
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ex_enter_interpreter (void)
+acpi_ex_enter_interpreter (
+	void)
 {
 	acpi_status                     status;
 
@@ -104,6 +113,8 @@ acpi_ex_enter_interpreter (void)
  *
  * PARAMETERS:  None
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Exit the interpreter execution region
  *
  * Cases where the interpreter is unlocked:
@@ -119,7 +130,8 @@ acpi_ex_enter_interpreter (void)
  ******************************************************************************/
 
 void
-acpi_ex_exit_interpreter (void)
+acpi_ex_exit_interpreter (
+	void)
 {
 	acpi_status                     status;
 
@@ -212,7 +224,8 @@ acpi_ex_acquire_global_lock (
 			locked = TRUE;
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not acquire Global Lock, %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not acquire Global Lock, %s\n",
 				acpi_format_exception (status)));
 		}
 	}
@@ -228,7 +241,7 @@ acpi_ex_acquire_global_lock (
  * PARAMETERS:  locked_by_me    - Return value from corresponding call to
  *                                acquire_global_lock.
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Release the global lock if it is locked.
  *
@@ -269,11 +282,14 @@ acpi_ex_release_global_lock (
  * PARAMETERS:  Value           - Value to be represented
  *              Base            - Base of representation
  *
- * RETURN:      the number of digits needed to represent Value in Base
+ * RETURN:      The number of digits.
+ *
+ * DESCRIPTION: Calculate the number of digits needed to represent the Value
+ *              in the given Base (Radix)
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ex_digits_needed (
 	acpi_integer                    value,
 	u32                             base)
@@ -312,6 +328,8 @@ acpi_ex_digits_needed (
  * PARAMETERS:  numeric_id      - EISA ID to be converted
  *              out_string      - Where to put the converted string (8 bytes)
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Convert a numeric EISA ID to string representation
  *
  ******************************************************************************/
@@ -349,7 +367,10 @@ acpi_ex_eisa_id_to_string (
  * PARAMETERS:  Value           - Value to be converted
  *              out_string      - Where to put the converted string (8 bytes)
  *
- * RETURN:      Convert a number to string representation
+ * RETURN:      None, string
+ *
+ * DESCRIPTION: Convert a number to string representation. Assumes string
+ *              buffer is large enough to hold the string.
  *
  ******************************************************************************/
 
diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/glue.c
@@ -0,0 +1,360 @@
+/*
+ * Link physical devices with ACPI devices support
+ *
+ * Copyright (c) 2005 David Shaohua Li <shaohua.li@intel.com>
+ * Copyright (c) 2005 Intel Corp.
+ *
+ * This file is released under the GPLv2.
+ */
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/rwsem.h>
+#include <linux/acpi.h>
+
+#define ACPI_GLUE_DEBUG	0
+#if ACPI_GLUE_DEBUG
+#define DBG(x...) printk(PREFIX x)
+#else
+#define DBG(x...)
+#endif
+static LIST_HEAD(bus_type_list);
+static DECLARE_RWSEM(bus_type_sem);
+
+int register_acpi_bus_type(struct acpi_bus_type *type)
+{
+	if (acpi_disabled)
+		return -ENODEV;
+	if (type && type->bus && type->find_device) {
+		down_write(&bus_type_sem);
+		list_add_tail(&type->list, &bus_type_list);
+		up_write(&bus_type_sem);
+		printk(KERN_INFO PREFIX "bus type %s registered\n", type->bus->name);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(register_acpi_bus_type);
+
+int unregister_acpi_bus_type(struct acpi_bus_type *type)
+{
+	if (acpi_disabled)
+		return 0;
+	if (type) {
+		down_write(&bus_type_sem);
+		list_del_init(&type->list);
+		up_write(&bus_type_sem);
+		printk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n", type->bus->name);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(unregister_acpi_bus_type);
+
+static struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)
+{
+	struct acpi_bus_type *tmp, *ret = NULL;
+
+	down_read(&bus_type_sem);
+	list_for_each_entry(tmp, &bus_type_list, list) {
+		if (tmp->bus == type) {
+			ret = tmp;
+			break;
+		}
+	}
+	up_read(&bus_type_sem);
+	return ret;
+}
+
+static int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)
+{
+	struct acpi_bus_type *tmp;
+	int ret = -ENODEV;
+
+	down_read(&bus_type_sem);
+	list_for_each_entry(tmp, &bus_type_list, list) {
+		if (tmp->find_bridge && !tmp->find_bridge(dev, handle)) {
+			ret = 0;
+			break;
+		}
+	}
+	up_read(&bus_type_sem);
+	return ret;
+}
+
+/* Get PCI root bridge's handle from its segment and bus number */
+struct acpi_find_pci_root {
+	unsigned int seg;
+	unsigned int bus;
+	acpi_handle handle;
+};
+
+static acpi_status
+do_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)
+{
+	int *busnr = (int *)data;
+	struct acpi_resource_address64 address;
+
+	if (resource->id != ACPI_RSTYPE_ADDRESS16 &&
+	    resource->id != ACPI_RSTYPE_ADDRESS32 &&
+	    resource->id != ACPI_RSTYPE_ADDRESS64)
+		return AE_OK;
+
+	acpi_resource_to_address64(resource, &address);
+	if ((address.address_length > 0) &&
+	    (address.resource_type == ACPI_BUS_NUMBER_RANGE))
+		*busnr = address.min_address_range;
+
+	return AE_OK;
+}
+
+static int get_root_bridge_busnr(acpi_handle handle)
+{
+	acpi_status status;
+	int bus, bbn;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	status = acpi_evaluate_integer(handle, METHOD_NAME__BBN, NULL,
+				       (unsigned long *)&bbn);
+	if (status == AE_NOT_FOUND) {
+		/* Assume bus = 0 */
+		printk(KERN_INFO PREFIX
+		       "Assume root bridge [%s] bus is 0\n",
+		       (char *)buffer.pointer);
+		status = AE_OK;
+		bbn = 0;
+	}
+	if (ACPI_FAILURE(status)) {
+		bbn = -ENODEV;
+		goto exit;
+	}
+	if (bbn > 0)
+		goto exit;
+
+	/* _BBN in some systems return 0 for all root bridges */
+	bus = -1;
+	status = acpi_walk_resources(handle, METHOD_NAME__CRS,
+				     do_root_bridge_busnr_callback, &bus);
+	/* If _CRS failed, we just use _BBN */
+	if (ACPI_FAILURE(status) || (bus == -1))
+		goto exit;
+	/* We select _CRS */
+	if (bbn != bus) {
+		printk(KERN_INFO PREFIX
+		       "_BBN and _CRS returns different value for %s. Select _CRS\n",
+		       (char *)buffer.pointer);
+		bbn = bus;
+	}
+      exit:
+	acpi_os_free(buffer.pointer);
+	return bbn;
+}
+
+static acpi_status
+find_pci_rootbridge(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	struct acpi_find_pci_root *find = (struct acpi_find_pci_root *)context;
+	unsigned long seg, bus;
+	acpi_status status;
+	int tmp;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL, &seg);
+	if (status == AE_NOT_FOUND) {
+		/* Assume seg = 0 */
+		printk(KERN_INFO PREFIX
+		       "Assume root bridge [%s] segment is 0\n",
+		       (char *)buffer.pointer);
+		status = AE_OK;
+		seg = 0;
+	}
+	if (ACPI_FAILURE(status)) {
+		status = AE_CTRL_DEPTH;
+		goto exit;
+	}
+
+	tmp = get_root_bridge_busnr(handle);
+	if (tmp < 0) {
+		printk(KERN_ERR PREFIX
+		       "Find root bridge failed for %s\n",
+		       (char *)buffer.pointer);
+		status = AE_CTRL_DEPTH;
+		goto exit;
+	}
+	bus = tmp;
+
+	if (seg == find->seg && bus == find->bus)
+		find->handle = handle;
+	status = AE_OK;
+      exit:
+	acpi_os_free(buffer.pointer);
+	return status;
+}
+
+acpi_handle acpi_get_pci_rootbridge_handle(unsigned int seg, unsigned int bus)
+{
+	struct acpi_find_pci_root find = { seg, bus, NULL };
+
+	acpi_get_devices(PCI_ROOT_HID_STRING, find_pci_rootbridge, &find, NULL);
+	return find.handle;
+}
+
+/* Get device's handler per its address under its parent */
+struct acpi_find_child {
+	acpi_handle handle;
+	acpi_integer address;
+};
+
+static acpi_status
+do_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	acpi_status status;
+	struct acpi_device_info *info;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_find_child *find = (struct acpi_find_child *)context;
+
+	status = acpi_get_object_info(handle, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		info = buffer.pointer;
+		if (info->address == find->address)
+			find->handle = handle;
+		acpi_os_free(buffer.pointer);
+	}
+	return AE_OK;
+}
+
+acpi_handle acpi_get_child(acpi_handle parent, acpi_integer address)
+{
+	struct acpi_find_child find = { NULL, address };
+
+	if (!parent)
+		return NULL;
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, parent,
+			    1, do_acpi_find_child, &find, NULL);
+	return find.handle;
+}
+
+EXPORT_SYMBOL(acpi_get_child);
+
+/* Link ACPI devices with physical devices */
+static void acpi_glue_data_handler(acpi_handle handle,
+				   u32 function, void *context)
+{
+	/* we provide an empty handler */
+}
+
+/* Note: a success call will increase reference count by one */
+struct device *acpi_get_physical_device(acpi_handle handle)
+{
+	acpi_status status;
+	struct device *dev;
+
+	status = acpi_get_data(handle, acpi_glue_data_handler, (void **)&dev);
+	if (ACPI_SUCCESS(status))
+		return get_device(dev);
+	return NULL;
+}
+
+EXPORT_SYMBOL(acpi_get_physical_device);
+
+static int acpi_bind_one(struct device *dev, acpi_handle handle)
+{
+	acpi_status status;
+
+	if (dev->firmware_data) {
+		printk(KERN_WARNING PREFIX
+		       "Drivers changed 'firmware_data' for %s\n", dev->bus_id);
+		return -EINVAL;
+	}
+	get_device(dev);
+	status = acpi_attach_data(handle, acpi_glue_data_handler, dev);
+	if (ACPI_FAILURE(status)) {
+		put_device(dev);
+		return -EINVAL;
+	}
+	dev->firmware_data = handle;
+
+	return 0;
+}
+
+static int acpi_unbind_one(struct device *dev)
+{
+	if (!dev->firmware_data)
+		return 0;
+	if (dev == acpi_get_physical_device(dev->firmware_data)) {
+		/* acpi_get_physical_device increase refcnt by one */
+		put_device(dev);
+		acpi_detach_data(dev->firmware_data, acpi_glue_data_handler);
+		dev->firmware_data = NULL;
+		/* acpi_bind_one increase refcnt by one */
+		put_device(dev);
+	} else {
+		printk(KERN_ERR PREFIX
+		       "Oops, 'firmware_data' corrupt for %s\n", dev->bus_id);
+	}
+	return 0;
+}
+
+static int acpi_platform_notify(struct device *dev)
+{
+	struct acpi_bus_type *type;
+	acpi_handle handle;
+	int ret = -EINVAL;
+
+	if (!dev->bus || !dev->parent) {
+		/* bridge devices genernally haven't bus or parent */
+		ret = acpi_find_bridge_device(dev, &handle);
+		goto end;
+	}
+	type = acpi_get_bus_type(dev->bus);
+	if (!type) {
+		DBG("No ACPI bus support for %s\n", dev->bus_id);
+		ret = -EINVAL;
+		goto end;
+	}
+	if ((ret = type->find_device(dev, &handle)) != 0)
+		DBG("Can't get handler for %s\n", dev->bus_id);
+      end:
+	if (!ret)
+		acpi_bind_one(dev, handle);
+
+#if ACPI_GLUE_DEBUG
+	if (!ret) {
+		struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+		acpi_get_name(dev->firmware_data, ACPI_FULL_PATHNAME, &buffer);
+		DBG("Device %s -> %s\n", dev->bus_id, (char *)buffer.pointer);
+		acpi_os_free(buffer.pointer);
+	} else
+		DBG("Device %s -> No ACPI support\n", dev->bus_id);
+#endif
+
+	return ret;
+}
+
+static int acpi_platform_notify_remove(struct device *dev)
+{
+	acpi_unbind_one(dev);
+	return 0;
+}
+
+static int __init init_acpi_device_notify(void)
+{
+	if (acpi_disabled)
+		return 0;
+	if (platform_notify || platform_notify_remove) {
+		printk(KERN_ERR PREFIX "Can't use platform_notify\n");
+		return 0;
+	}
+	platform_notify = acpi_platform_notify;
+	platform_notify_remove = acpi_platform_notify_remove;
+	return 0;
+}
+
+arch_initcall(init_acpi_device_notify);
diff --git a/drivers/acpi/hardware/hwacpi.c b/drivers/acpi/hardware/hwacpi.c
--- a/drivers/acpi/hardware/hwacpi.c
+++ b/drivers/acpi/hardware/hwacpi.c
@@ -58,7 +58,8 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize and validate various ACPI registers
+ * DESCRIPTION: Initialize and validate the various ACPI registers defined in
+ *              the FADT.
  *
  ******************************************************************************/
 
@@ -75,7 +76,7 @@ acpi_hw_initialize (
 	/* We must have the ACPI tables by the time we get here */
 
 	if (!acpi_gbl_FADT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "A FADT is not loaded\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No FADT is present\n"));
 
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
@@ -131,7 +132,8 @@ acpi_hw_set_mode (
 	 * transitions are not supported.
 	 */
 	if (!acpi_gbl_FADT->acpi_enable && !acpi_gbl_FADT->acpi_disable) {
-		ACPI_REPORT_ERROR (("No ACPI mode transition supported in this system (enable/disable both zero)\n"));
+		ACPI_REPORT_ERROR ((
+			"No ACPI mode transition supported in this system (enable/disable both zero)\n"));
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -162,7 +164,8 @@ acpi_hw_set_mode (
 	}
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not write mode change, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Could not write mode change, %s\n",
+			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
@@ -173,7 +176,8 @@ acpi_hw_set_mode (
 	retry = 3000;
 	while (retry) {
 		if (acpi_hw_get_mode() == mode) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n",
+				mode));
 			return_ACPI_STATUS (AE_OK);
 		}
 		acpi_os_stall(1000);
@@ -185,7 +189,7 @@ acpi_hw_set_mode (
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_hw_get_mode
  *
@@ -199,7 +203,8 @@ acpi_hw_set_mode (
  ******************************************************************************/
 
 u32
-acpi_hw_get_mode (void)
+acpi_hw_get_mode (
+	void)
 {
 	acpi_status                     status;
 	u32                             value;
diff --git a/drivers/acpi/hardware/hwgpe.c b/drivers/acpi/hardware/hwgpe.c
--- a/drivers/acpi/hardware/hwgpe.c
+++ b/drivers/acpi/hardware/hwgpe.c
@@ -48,6 +48,13 @@
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwgpe")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_hw_enable_wakeup_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
+
 
 /******************************************************************************
  *
@@ -135,6 +142,7 @@ acpi_hw_clear_gpe (
  * DESCRIPTION: Return the status of a single GPE.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_hw_get_gpe_status (
@@ -206,7 +214,7 @@ unlock_and_exit:
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Disable all GPEs within a GPE block
+ * DESCRIPTION: Disable all GPEs within a single GPE block
  *
  ******************************************************************************/
 
@@ -244,7 +252,7 @@ acpi_hw_disable_gpe_block (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Clear status bits for all GPEs within a GPE block
+ * DESCRIPTION: Clear status bits for all GPEs within a single GPE block
  *
  ******************************************************************************/
 
@@ -282,8 +290,8 @@ acpi_hw_clear_gpe_block (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all "runtime" GPEs within a GPE block. (Includes
- *              combination wake/run GPEs.)
+ * DESCRIPTION: Enable all "runtime" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
  *
  ******************************************************************************/
 
@@ -327,12 +335,12 @@ acpi_hw_enable_runtime_gpe_block (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all "wake" GPEs within a GPE block.  (Includes
- *              combination wake/run GPEs.)
+ * DESCRIPTION: Enable all "wake" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_hw_enable_wakeup_gpe_block (
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block)
@@ -350,7 +358,8 @@ acpi_hw_enable_wakeup_gpe_block (
 
 		/* Enable all "wake" GPEs in this register */
 
-		status = acpi_hw_low_level_write (8, gpe_block->register_info[i].enable_for_wake,
+		status = acpi_hw_low_level_write (8,
+				 gpe_block->register_info[i].enable_for_wake,
 				 &gpe_block->register_info[i].enable_address);
 		if (ACPI_FAILURE (status)) {
 			return (status);
@@ -365,17 +374,17 @@ acpi_hw_enable_wakeup_gpe_block (
  *
  * FUNCTION:    acpi_hw_disable_all_gpes
  *
- * PARAMETERS:  Flags           - ACPI_NOT_ISR or ACPI_ISR
+ * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Disable and clear all GPEs
+ * DESCRIPTION: Disable and clear all GPEs in all GPE blocks
  *
  ******************************************************************************/
 
 acpi_status
 acpi_hw_disable_all_gpes (
-	u32                             flags)
+	void)
 {
 	acpi_status                     status;
 
@@ -383,8 +392,8 @@ acpi_hw_disable_all_gpes (
 	ACPI_FUNCTION_TRACE ("hw_disable_all_gpes");
 
 
-	status = acpi_ev_walk_gpe_list (acpi_hw_disable_gpe_block, flags);
-	status = acpi_ev_walk_gpe_list (acpi_hw_clear_gpe_block, flags);
+	status = acpi_ev_walk_gpe_list (acpi_hw_disable_gpe_block);
+	status = acpi_ev_walk_gpe_list (acpi_hw_clear_gpe_block);
 	return_ACPI_STATUS (status);
 }
 
@@ -393,17 +402,17 @@ acpi_hw_disable_all_gpes (
  *
  * FUNCTION:    acpi_hw_enable_all_runtime_gpes
  *
- * PARAMETERS:  Flags           - ACPI_NOT_ISR or ACPI_ISR
+ * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all GPEs of the given type
+ * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks
  *
  ******************************************************************************/
 
 acpi_status
 acpi_hw_enable_all_runtime_gpes (
-	u32                             flags)
+	void)
 {
 	acpi_status                     status;
 
@@ -411,7 +420,7 @@ acpi_hw_enable_all_runtime_gpes (
 	ACPI_FUNCTION_TRACE ("hw_enable_all_runtime_gpes");
 
 
-	status = acpi_ev_walk_gpe_list (acpi_hw_enable_runtime_gpe_block, flags);
+	status = acpi_ev_walk_gpe_list (acpi_hw_enable_runtime_gpe_block);
 	return_ACPI_STATUS (status);
 }
 
@@ -420,17 +429,17 @@ acpi_hw_enable_all_runtime_gpes (
  *
  * FUNCTION:    acpi_hw_enable_all_wakeup_gpes
  *
- * PARAMETERS:  Flags           - ACPI_NOT_ISR or ACPI_ISR
+ * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable all GPEs of the given type
+ * DESCRIPTION: Enable all "wakeup" GPEs, in all GPE blocks
  *
  ******************************************************************************/
 
 acpi_status
 acpi_hw_enable_all_wakeup_gpes (
-	u32                             flags)
+	void)
 {
 	acpi_status                     status;
 
@@ -438,7 +447,7 @@ acpi_hw_enable_all_wakeup_gpes (
 	ACPI_FUNCTION_TRACE ("hw_enable_all_wakeup_gpes");
 
 
-	status = acpi_ev_walk_gpe_list (acpi_hw_enable_wakeup_gpe_block, flags);
+	status = acpi_ev_walk_gpe_list (acpi_hw_enable_wakeup_gpe_block);
 	return_ACPI_STATUS (status);
 }
 
diff --git a/drivers/acpi/hardware/hwregs.c b/drivers/acpi/hardware/hwregs.c
--- a/drivers/acpi/hardware/hwregs.c
+++ b/drivers/acpi/hardware/hwregs.c
@@ -87,8 +87,9 @@ acpi_hw_clear_acpi_status (
 		}
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
-			  ACPI_BITMASK_ALL_FIXED_STATUS);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1_STATUS,
+			 ACPI_BITMASK_ALL_FIXED_STATUS);
 	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
@@ -105,7 +106,7 @@ acpi_hw_clear_acpi_status (
 
 	/* Clear the GPE Bits in all GPE registers in all GPE blocks */
 
-	status = acpi_ev_walk_gpe_list (acpi_hw_clear_gpe_block, ACPI_ISR);
+	status = acpi_ev_walk_gpe_list (acpi_hw_clear_gpe_block);
 
 unlock_and_exit:
 	if (flags & ACPI_MTX_LOCK) {
@@ -138,28 +139,30 @@ acpi_get_sleep_type_data (
 {
 	acpi_status                     status = AE_OK;
 	struct acpi_parameter_info      info;
+	char                            *sleep_state_name;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_get_sleep_type_data");
 
 
-	/*
-	 * Validate parameters
-	 */
+	/* Validate parameters */
+
 	if ((sleep_state > ACPI_S_STATES_MAX) ||
 		!sleep_type_a || !sleep_type_b) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Evaluate the namespace object containing the values for this state
-	 */
+	/* Evaluate the namespace object containing the values for this state */
+
 	info.parameters = NULL;
-	status = acpi_ns_evaluate_by_name ((char *) acpi_gbl_sleep_state_names[sleep_state],
-			  &info);
+	info.return_object = NULL;
+	sleep_state_name = (char *) acpi_gbl_sleep_state_names[sleep_state];
+
+	status = acpi_ns_evaluate_by_name (sleep_state_name, &info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s while evaluating sleep_state [%s]\n",
-			acpi_format_exception (status), acpi_gbl_sleep_state_names[sleep_state]));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"%s while evaluating sleep_state [%s]\n",
+			acpi_format_exception (status), sleep_state_name));
 
 		return_ACPI_STATUS (status);
 	}
@@ -167,45 +170,57 @@ acpi_get_sleep_type_data (
 	/* Must have a return object */
 
 	if (!info.return_object) {
-		ACPI_REPORT_ERROR (("Missing Sleep State object\n"));
+		ACPI_REPORT_ERROR (("No Sleep State object returned from [%s]\n",
+			sleep_state_name));
 		status = AE_NOT_EXIST;
 	}
 
 	/* It must be of type Package */
 
 	else if (ACPI_GET_OBJECT_TYPE (info.return_object) != ACPI_TYPE_PACKAGE) {
-		ACPI_REPORT_ERROR (("Sleep State object not a Package\n"));
+		ACPI_REPORT_ERROR (("Sleep State return object is not a Package\n"));
 		status = AE_AML_OPERAND_TYPE;
 	}
 
-	/* The package must have at least two elements */
-
+	/*
+	 * The package must have at least two elements.  NOTE (March 2005): This
+	 * goes against the current ACPI spec which defines this object as a
+	 * package with one encoded DWORD element.  However, existing practice
+	 * by BIOS vendors seems to be to have 2 or more elements, at least
+	 * one per sleep type (A/B).
+	 */
 	else if (info.return_object->package.count < 2) {
-		ACPI_REPORT_ERROR (("Sleep State package does not have at least two elements\n"));
+		ACPI_REPORT_ERROR ((
+			"Sleep State return package does not have at least two elements\n"));
 		status = AE_AML_NO_OPERAND;
 	}
 
 	/* The first two elements must both be of type Integer */
 
-	else if ((ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[0]) != ACPI_TYPE_INTEGER) ||
-			 (ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[1]) != ACPI_TYPE_INTEGER)) {
-		ACPI_REPORT_ERROR (("Sleep State package elements are not both Integers (%s, %s)\n",
+	else if ((ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[0])
+			 != ACPI_TYPE_INTEGER) ||
+			 (ACPI_GET_OBJECT_TYPE (info.return_object->package.elements[1])
+				!= ACPI_TYPE_INTEGER)) {
+		ACPI_REPORT_ERROR ((
+			"Sleep State return package elements are not both Integers (%s, %s)\n",
 			acpi_ut_get_object_type_name (info.return_object->package.elements[0]),
 			acpi_ut_get_object_type_name (info.return_object->package.elements[1])));
 		status = AE_AML_OPERAND_TYPE;
 	}
 	else {
-		/*
-		 * Valid _Sx_ package size, type, and value
-		 */
-		*sleep_type_a = (u8) (info.return_object->package.elements[0])->integer.value;
-		*sleep_type_b = (u8) (info.return_object->package.elements[1])->integer.value;
+		/* Valid _Sx_ package size, type, and value */
+
+		*sleep_type_a = (u8)
+			(info.return_object->package.elements[0])->integer.value;
+		*sleep_type_b = (u8)
+			(info.return_object->package.elements[1])->integer.value;
 	}
 
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
-			acpi_gbl_sleep_state_names[sleep_state], info.return_object,
+			"%s While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
+			acpi_format_exception (status),
+			sleep_state_name, info.return_object,
 			acpi_ut_get_object_type_name (info.return_object)));
 	}
 
@@ -221,9 +236,9 @@ EXPORT_SYMBOL(acpi_get_sleep_type_data);
  *
  * PARAMETERS:  register_id         - Index of ACPI Register to access
  *
- * RETURN:      The bit mask to be used when accessing the register
+ * RETURN:      The bitmask to be used when accessing the register
  *
- * DESCRIPTION: Map register_id into a register bit mask.
+ * DESCRIPTION: Map register_id into a register bitmask.
  *
  ******************************************************************************/
 
@@ -359,7 +374,7 @@ acpi_set_register (
 	/* Always do a register read first so we can insert the new bits  */
 
 	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
-			  bit_reg_info->parent_register, &register_value);
+			 bit_reg_info->parent_register, &register_value);
 	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
@@ -396,7 +411,7 @@ acpi_set_register (
 				bit_reg_info->access_bit_mask, value);
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				  ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
+				 ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
 		break;
 
 
@@ -413,7 +428,7 @@ acpi_set_register (
 				bit_reg_info->access_bit_mask, value);
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				  ACPI_REGISTER_PM1_CONTROL, (u16) register_value);
+				 ACPI_REGISTER_PM1_CONTROL, (u16) register_value);
 		break;
 
 
@@ -427,17 +442,19 @@ acpi_set_register (
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM2 control: Read %X from %8.8X%8.8X\n",
 			register_value,
-			ACPI_FORMAT_UINT64 (acpi_gbl_FADT->xpm2_cnt_blk.address)));
+			ACPI_FORMAT_UINT64 (
+				acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
 		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
 				bit_reg_info->access_bit_mask, value);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %4.4X to %8.8X%8.8X\n",
 			register_value,
-			ACPI_FORMAT_UINT64 (acpi_gbl_FADT->xpm2_cnt_blk.address)));
+			ACPI_FORMAT_UINT64 (
+				acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
 		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-				   ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
+				 ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
 		break;
 
 
@@ -454,7 +471,9 @@ unlock_and_exit:
 
 	/* Normalize the value that was read */
 
-	ACPI_DEBUG_EXEC (register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position));
+	ACPI_DEBUG_EXEC (register_value =
+		((register_value & bit_reg_info->access_bit_mask) >>
+			bit_reg_info->bit_position));
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Set bits: %8.8X actual %8.8X register %X\n",
 			value, register_value, bit_reg_info->parent_register));
@@ -469,7 +488,7 @@ EXPORT_SYMBOL(acpi_set_register);
  *
  * PARAMETERS:  use_lock            - Mutex hw access
  *              register_id         - register_iD + Offset
- *              return_value        - Value that was read from the register
+ *              return_value        - Where the register value is returned
  *
  * RETURN:      Status and the value read.
  *
@@ -557,7 +576,8 @@ acpi_hw_register_read (
 		break;
 
 	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n", register_id));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n",
+			register_id));
 		status = AE_BAD_PARAMETER;
 		break;
 	}
@@ -763,10 +783,11 @@ acpi_hw_low_level_read (
 		return (AE_BAD_PARAMETER);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
-			*value, width,
-			ACPI_FORMAT_UINT64 (address),
-			acpi_ut_get_region_name (reg->address_space_id)));
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO,
+		"Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
+		*value, width,
+		ACPI_FORMAT_UINT64 (address),
+		acpi_ut_get_region_name (reg->address_space_id)));
 
 	return (status);
 }
@@ -841,10 +862,11 @@ acpi_hw_low_level_write (
 		return (AE_BAD_PARAMETER);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
-			value, width,
-			ACPI_FORMAT_UINT64 (address),
-			acpi_ut_get_region_name (reg->address_space_id)));
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO,
+		"Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
+		value, width,
+		ACPI_FORMAT_UINT64 (address),
+		acpi_ut_get_region_name (reg->address_space_id)));
 
 	return (status);
 }
diff --git a/drivers/acpi/hardware/hwsleep.c b/drivers/acpi/hardware/hwsleep.c
--- a/drivers/acpi/hardware/hwsleep.c
+++ b/drivers/acpi/hardware/hwsleep.c
@@ -43,27 +43,13 @@
  */
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwsleep")
 
 
-#define METHOD_NAME__BFS        "\\_BFS"
-#define METHOD_NAME__GTS        "\\_GTS"
-#define METHOD_NAME__PTS        "\\_PTS"
-#define METHOD_NAME__SST        "\\_SI._SST"
-#define METHOD_NAME__WAK        "\\_WAK"
-
-#define ACPI_SST_INDICATOR_OFF  0
-#define ACPI_SST_WORKING        1
-#define ACPI_SST_WAKING         2
-#define ACPI_SST_SLEEPING       3
-#define ACPI_SST_SLEEP_CONTEXT  4
-
-
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_set_firmware_waking_vector
  *
@@ -72,7 +58,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: access function for d_firmware_waking_vector field in FACS
+ * DESCRIPTION: Access function for the firmware_waking_vector field in FACS
  *
  ******************************************************************************/
 
@@ -99,19 +85,20 @@ acpi_set_firmware_waking_vector (
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_get_firmware_waking_vector
  *
- * PARAMETERS:  *physical_address   - Output buffer where contents of
+ * PARAMETERS:  *physical_address   - Where the contents of
  *                                    the firmware_waking_vector field of
- *                                    the FACS will be stored.
+ *                                    the FACS will be returned.
  *
- * RETURN:      Status
+ * RETURN:      Status, vector
  *
- * DESCRIPTION: Access function for firmware_waking_vector field in FACS
+ * DESCRIPTION: Access function for the firmware_waking_vector field in FACS
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_get_firmware_waking_vector (
@@ -141,7 +128,7 @@ acpi_get_firmware_waking_vector (
 #endif
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state_prep
  *
@@ -215,7 +202,7 @@ acpi_enter_sleep_state_prep (
 		break;
 
 	default:
-		arg.integer.value = ACPI_SST_INDICATOR_OFF; /* Default is indicator off */
+		arg.integer.value = ACPI_SST_INDICATOR_OFF; /* Default is off */
 		break;
 	}
 
@@ -223,14 +210,15 @@ acpi_enter_sleep_state_prep (
 
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		 ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		 ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	return_ACPI_STATUS (AE_OK);
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state
  *
@@ -286,28 +274,31 @@ acpi_enter_sleep_state (
 	 * 1) Disable/Clear all GPEs
 	 * 2) Enable all wakeup GPEs
 	 */
-	status = acpi_hw_disable_all_gpes (ACPI_ISR);
+	status = acpi_hw_disable_all_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 	acpi_gbl_system_awake_and_running = FALSE;
 
-	status = acpi_hw_enable_all_wakeup_gpes (ACPI_ISR);
+	status = acpi_hw_enable_all_wakeup_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	/* Get current value of PM1A control */
 
-	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
-	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Entering sleep state [S%d]\n", sleep_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+		"Entering sleep state [S%d]\n", sleep_state));
 
 	/* Clear SLP_EN and SLP_TYP fields */
 
-	PM1Acontrol &= ~(sleep_type_reg_info->access_bit_mask | sleep_enable_reg_info->access_bit_mask);
+	PM1Acontrol &= ~(sleep_type_reg_info->access_bit_mask |
+			   sleep_enable_reg_info->access_bit_mask);
 	PM1Bcontrol = PM1Acontrol;
 
 	/* Insert SLP_TYP bits */
@@ -322,12 +313,14 @@ acpi_enter_sleep_state (
 
 	/* Write #1: fill in SLP_TYP data */
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -341,22 +334,25 @@ acpi_enter_sleep_state (
 
 	ACPI_FLUSH_CPU_CACHE ();
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+			 ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	if (sleep_state > ACPI_STATE_S3) {
 		/*
-		 * We wanted to sleep > S3, but it didn't happen (by virtue of the fact that
-		 * we are still executing!)
+		 * We wanted to sleep > S3, but it didn't happen (by virtue of the
+		 * fact that we are still executing!)
 		 *
-		 * Wait ten seconds, then try again. This is to get S4/S5 to work on all machines.
+		 * Wait ten seconds, then try again. This is to get S4/S5 to work on
+		 * all machines.
 		 *
 		 * We wait so long to allow chipsets that poll this reg very slowly to
 		 * still read the right value. Ideally, this block would go
@@ -364,7 +360,8 @@ acpi_enter_sleep_state (
 		 */
 		acpi_os_stall (10000000);
 
-		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL,
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+				 ACPI_REGISTER_PM1_CONTROL,
 				 sleep_enable_reg_info->access_bit_mask);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
@@ -374,7 +371,8 @@ acpi_enter_sleep_state (
 	/* Wait until we enter sleep state */
 
 	do {
-		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value,
+			ACPI_MTX_DO_NOT_LOCK);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -388,7 +386,7 @@ acpi_enter_sleep_state (
 EXPORT_SYMBOL(acpi_enter_sleep_state);
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_enter_sleep_state_s4bios
  *
@@ -426,24 +424,26 @@ acpi_enter_sleep_state_s4bios (
 	 * 1) Disable/Clear all GPEs
 	 * 2) Enable all wakeup GPEs
 	 */
-	status = acpi_hw_disable_all_gpes (ACPI_ISR);
+	status = acpi_hw_disable_all_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 	acpi_gbl_system_awake_and_running = FALSE;
 
-	status = acpi_hw_enable_all_wakeup_gpes (ACPI_ISR);
+	status = acpi_hw_enable_all_wakeup_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	ACPI_FLUSH_CPU_CACHE ();
 
-	status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd, (u32) acpi_gbl_FADT->S4bios_req, 8);
+	status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+			 (u32) acpi_gbl_FADT->S4bios_req, 8);
 
 	do {
 		acpi_os_stall(1000);
-		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value,
+			ACPI_MTX_DO_NOT_LOCK);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -454,7 +454,7 @@ acpi_enter_sleep_state_s4bios (
 EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios);
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_leave_sleep_state
  *
@@ -534,18 +534,21 @@ acpi_leave_sleep_state (
 	arg.integer.value = ACPI_SST_WAKING;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	arg.integer.value = sleep_state;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__BFS, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	status = acpi_evaluate_object (NULL, METHOD_NAME__WAK, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n",
+			acpi_format_exception (status)));
 	}
 	/* TBD: _WAK "sometimes" returns stuff - do we want to look at it? */
 
@@ -554,28 +557,32 @@ acpi_leave_sleep_state (
 	 * 1) Disable/Clear all GPEs
 	 * 2) Enable all runtime GPEs
 	 */
-	status = acpi_hw_disable_all_gpes (ACPI_NOT_ISR);
+	status = acpi_hw_disable_all_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 	acpi_gbl_system_awake_and_running = TRUE;
 
-	status = acpi_hw_enable_all_runtime_gpes (ACPI_NOT_ISR);
+	status = acpi_hw_enable_all_runtime_gpes ();
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	/* Enable power button */
 
-	(void) acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].enable_register_id,
+	(void) acpi_set_register(
+			acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].enable_register_id,
 			1, ACPI_MTX_DO_NOT_LOCK);
-	(void) acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
+
+	(void) acpi_set_register(
+			acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
 			1, ACPI_MTX_DO_NOT_LOCK);
 
 	arg.integer.value = ACPI_SST_WORKING;
 	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
-		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Method _SST failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	return_ACPI_STATUS (status);
diff --git a/drivers/acpi/hardware/hwtimer.c b/drivers/acpi/hardware/hwtimer.c
--- a/drivers/acpi/hardware/hwtimer.c
+++ b/drivers/acpi/hardware/hwtimer.c
@@ -43,7 +43,6 @@
  */
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
@@ -90,7 +89,7 @@ acpi_get_timer_resolution (
  *
  * PARAMETERS:  Ticks               - Where the timer value is returned
  *
- * RETURN:      Status and current ticks
+ * RETURN:      Status and current timer value (ticks)
  *
  * DESCRIPTION: Obtains current value of ACPI PM Timer (in ticks).
  *
@@ -199,5 +198,6 @@ acpi_get_timer_duration (
 	*time_elapsed = (u32) quotient;
 	return_ACPI_STATUS (status);
 }
+
 EXPORT_SYMBOL(acpi_get_timer_duration);
 
diff --git a/drivers/acpi/hotkey.c b/drivers/acpi/hotkey.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/hotkey.c
@@ -0,0 +1,1019 @@
+/* 
+ *  hotkey.c - ACPI Hotkey Driver ($Revision$)
+ *
+ *  Copyright (C) 2004 Luming Yu <luming.yu@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+#include <linux/seq_file.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acpi_bus.h>
+#include <asm/uaccess.h>
+
+#define HOTKEY_ACPI_VERSION "0.1"
+
+#define HOTKEY_PROC "hotkey"
+#define HOTKEY_EV_CONFIG    "event_config"
+#define HOTKEY_PL_CONFIG    "poll_config"
+#define HOTKEY_ACTION   "action"
+#define HOTKEY_INFO "info"
+
+#define ACPI_HOTK_NAME          "Generic Hotkey Driver"
+#define ACPI_HOTK_CLASS         "Hotkey"
+#define ACPI_HOTK_DEVICE_NAME   "Hotkey"
+#define ACPI_HOTK_HID           "Unknown?"
+#define ACPI_HOTKEY_COMPONENT   0x20000000
+
+#define ACPI_HOTKEY_EVENT   0x1
+#define ACPI_HOTKEY_POLLING 0x2
+#define ACPI_UNDEFINED_EVENT    0xf
+
+#define MAX_CONFIG_RECORD_LEN   80
+#define MAX_NAME_PATH_LEN   80
+#define MAX_CALL_PARM       80
+
+#define IS_EVENT(e)       0xff	/* ((e) & 0x40000000)  */
+#define IS_POLL(e)      0xff	/* (~((e) & 0x40000000))  */
+
+#define _COMPONENT              ACPI_HOTKEY_COMPONENT
+ACPI_MODULE_NAME("acpi_hotkey")
+
+    MODULE_AUTHOR("luming.yu@intel.com");
+MODULE_DESCRIPTION(ACPI_HOTK_NAME);
+MODULE_LICENSE("GPL");
+
+/*  standardized internal hotkey number/event  */
+enum {
+	/* Video Extension event */
+	HK_EVENT_CYCLE_OUTPUT_DEVICE = 0x80,
+	HK_EVENT_OUTPUT_DEVICE_STATUS_CHANGE,
+	HK_EVENT_CYCLE_DISPLAY_OUTPUT,
+	HK_EVENT_NEXT_DISPLAY_OUTPUT,
+	HK_EVENT_PREVIOUS_DISPLAY_OUTPUT,
+	HK_EVENT_CYCLE_BRIGHTNESS,
+	HK_EVENT_INCREASE_BRIGHTNESS,
+	HK_EVENT_DECREASE_BRIGHTNESS,
+	HK_EVENT_ZERO_BRIGHTNESS,
+	HK_EVENT_DISPLAY_DEVICE_OFF,
+
+	/* Snd Card event */
+	HK_EVENT_VOLUME_MUTE,
+	HK_EVENT_VOLUME_INCLREASE,
+	HK_EVENT_VOLUME_DECREASE,
+
+	/* running state control */
+	HK_EVENT_ENTERRING_S3,
+	HK_EVENT_ENTERRING_S4,
+	HK_EVENT_ENTERRING_S5,
+};
+
+/*  procdir we use */
+static struct proc_dir_entry *hotkey_proc_dir;
+static struct proc_dir_entry *hotkey_config;
+static struct proc_dir_entry *hotkey_poll_config;
+static struct proc_dir_entry *hotkey_action;
+static struct proc_dir_entry *hotkey_info;
+
+/* linkage for all type of hotkey */
+struct acpi_hotkey_link {
+	struct list_head entries;
+	int hotkey_type;	/* event or polling based hotkey  */
+	int hotkey_standard_num;	/* standardized hotkey(event) number */
+};
+
+/* event based hotkey */
+struct acpi_event_hotkey {
+	struct acpi_hotkey_link hotkey_link;
+	int flag;
+	acpi_handle bus_handle;	/* bus to install notify handler */
+	int external_hotkey_num;	/* external hotkey/event number */
+	acpi_handle action_handle;	/* acpi handle attached aml action method */
+	char *action_method;	/* action method */
+};
+
+/* 
+ * There are two ways to poll status
+ * 1. directy call read_xxx method, without any arguments passed in
+ * 2. call write_xxx method, with arguments passed in, you need
+ * the result is saved in acpi_polling_hotkey.poll_result.
+ * anthoer read command through polling interface.
+ *
+ */
+
+/* polling based hotkey */
+struct acpi_polling_hotkey {
+	struct acpi_hotkey_link hotkey_link;
+	int flag;
+	acpi_handle poll_handle;	/* acpi handle attached polling method */
+	char *poll_method;	/* poll method */
+	acpi_handle action_handle;	/* acpi handle attached action method */
+	char *action_method;	/* action method */
+	void *poll_result;	/* polling_result */
+	struct proc_dir_entry *proc;
+};
+
+/* hotkey object union */
+union acpi_hotkey {
+	struct list_head entries;
+	struct acpi_hotkey_link link;
+	struct acpi_event_hotkey event_hotkey;
+	struct acpi_polling_hotkey poll_hotkey;
+};
+
+/* hotkey object list */
+struct acpi_hotkey_list {
+	struct list_head *entries;
+	int count;
+};
+
+static int auto_hotkey_add(struct acpi_device *device);
+static int auto_hotkey_remove(struct acpi_device *device, int type);
+
+static struct acpi_driver hotkey_driver = {
+	.name = ACPI_HOTK_NAME,
+	.class = ACPI_HOTK_CLASS,
+	.ids = ACPI_HOTK_HID,
+	.ops = {
+		.add = auto_hotkey_add,
+		.remove = auto_hotkey_remove,
+		},
+};
+
+static int hotkey_open_config(struct inode *inode, struct file *file);
+static ssize_t hotkey_write_config(struct file *file,
+				   const char __user * buffer,
+				   size_t count, loff_t * data);
+static ssize_t hotkey_write_poll_config(struct file *file,
+					const char __user * buffer,
+					size_t count, loff_t * data);
+static int hotkey_info_open_fs(struct inode *inode, struct file *file);
+static int hotkey_action_open_fs(struct inode *inode, struct file *file);
+static ssize_t hotkey_execute_aml_method(struct file *file,
+					 const char __user * buffer,
+					 size_t count, loff_t * data);
+static int hotkey_config_seq_show(struct seq_file *seq, void *offset);
+static int hotkey_polling_open_fs(struct inode *inode, struct file *file);
+
+/* event based config */
+static struct file_operations hotkey_config_fops = {
+	.open = hotkey_open_config,
+	.read = seq_read,
+	.write = hotkey_write_config,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/* polling based config */
+static struct file_operations hotkey_poll_config_fops = {
+	.open = hotkey_open_config,
+	.read = seq_read,
+	.write = hotkey_write_poll_config,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/* hotkey driver info */
+static struct file_operations hotkey_info_fops = {
+	.open = hotkey_info_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/* action */
+static struct file_operations hotkey_action_fops = {
+	.open = hotkey_action_open_fs,
+	.read = seq_read,
+	.write = hotkey_execute_aml_method,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/* polling results */
+static struct file_operations hotkey_polling_fops = {
+	.open = hotkey_polling_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+struct acpi_hotkey_list global_hotkey_list;	/* link all ev or pl hotkey  */
+struct list_head hotkey_entries;	/* head of the list of hotkey_list */
+
+static int hotkey_info_seq_show(struct seq_file *seq, void *offset)
+{
+	ACPI_FUNCTION_TRACE("hotkey_info_seq_show");
+
+	seq_printf(seq, "Hotkey generic driver ver: %s", HOTKEY_ACPI_VERSION);
+
+	return_VALUE(0);
+}
+
+static int hotkey_info_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, hotkey_info_seq_show, PDE(inode)->data);
+}
+
+static char *format_result(union acpi_object *object)
+{
+	char *buf = (char *)kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+
+	memset(buf, 0, sizeof(union acpi_object));
+
+	/* Now, just support integer type */
+	if (object->type == ACPI_TYPE_INTEGER)
+		sprintf(buf, "%d", (u32) object->integer.value);
+
+	return buf;
+}
+
+static int hotkey_polling_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_polling_hotkey *poll_hotkey =
+	    (struct acpi_polling_hotkey *)seq->private;
+
+	ACPI_FUNCTION_TRACE("hotkey_polling_seq_show");
+
+	if (poll_hotkey->poll_result)
+		seq_printf(seq, "%s", format_result(poll_hotkey->poll_result));
+
+	return_VALUE(0);
+}
+
+static int hotkey_polling_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, hotkey_polling_seq_show, PDE(inode)->data);
+}
+
+static int hotkey_action_open_fs(struct inode *inode, struct file *file)
+{
+	return single_open(file, hotkey_info_seq_show, PDE(inode)->data);
+}
+
+/* Mapping external hotkey number to standardized hotkey event num */
+static int hotkey_get_internal_event(int event, struct acpi_hotkey_list *list)
+{
+	struct list_head *entries, *next;
+	int val = 0;
+
+	ACPI_FUNCTION_TRACE("hotkey_get_internal_event");
+
+	list_for_each_safe(entries, next, list->entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_type == ACPI_HOTKEY_EVENT
+		    && key->event_hotkey.external_hotkey_num == event)
+			val = key->link.hotkey_standard_num;
+		else
+			val = -1;
+	}
+
+	return_VALUE(val);
+}
+
+static void
+acpi_hotkey_notify_handler(acpi_handle handle, u32 event, void *data)
+{
+	struct acpi_device *device = NULL;
+	u32 internal_event;
+
+	ACPI_FUNCTION_TRACE("acpi_hotkey_notify_handler");
+
+	if (acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	internal_event = hotkey_get_internal_event(event, &global_hotkey_list);
+	acpi_bus_generate_event(device, event, 0);
+
+	return_VOID;
+}
+
+/* Need to invent automatically hotkey add method */
+static int auto_hotkey_add(struct acpi_device *device)
+{
+	/* Implement me */
+	return 0;
+}
+
+/* Need to invent automatically hotkey remove method */
+static int auto_hotkey_remove(struct acpi_device *device, int type)
+{
+	/* Implement me */
+	return 0;
+}
+
+/* Create a proc file for each polling method */
+static int create_polling_proc(union acpi_hotkey *device)
+{
+	struct proc_dir_entry *proc;
+	mode_t mode;
+
+	ACPI_FUNCTION_TRACE("create_polling_proc");
+	mode = S_IFREG | S_IRUGO | S_IWUGO;
+
+	proc = create_proc_entry(device->poll_hotkey.action_method,
+				 mode, hotkey_proc_dir);
+
+	if (!proc) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  device->poll_hotkey.poll_method));
+		return_VALUE(-ENODEV);
+	} else {
+		proc->proc_fops = &hotkey_polling_fops;
+		proc->owner = THIS_MODULE;
+		proc->data = device;
+		proc->uid = 0;
+		proc->gid = 0;
+		device->poll_hotkey.proc = proc;
+	}
+	return_VALUE(0);
+}
+
+static int is_valid_acpi_path(const char *pathname)
+{
+	acpi_handle handle;
+	acpi_status status;
+	ACPI_FUNCTION_TRACE("is_valid_acpi_path");
+
+	status = acpi_get_handle(NULL, (char *)pathname, &handle);
+	return_VALUE(!ACPI_FAILURE(status));
+}
+
+static int is_valid_hotkey(union acpi_hotkey *device)
+{
+	ACPI_FUNCTION_TRACE("is_valid_hotkey");
+	/* Implement valid check */
+	return_VALUE(1);
+}
+
+static int hotkey_add(union acpi_hotkey *device)
+{
+	int status = 0;
+	struct acpi_device *dev = NULL;
+
+	ACPI_FUNCTION_TRACE("hotkey_add");
+
+	if (device->link.hotkey_type == ACPI_HOTKEY_EVENT) {
+		status =
+		    acpi_bus_get_device(device->event_hotkey.bus_handle, &dev);
+		if (status)
+			return_VALUE(status);
+
+		status = acpi_install_notify_handler(dev->handle,
+						     ACPI_SYSTEM_NOTIFY,
+						     acpi_hotkey_notify_handler,
+						     device);
+	} else			/* Add polling hotkey */
+		create_polling_proc(device);
+
+	global_hotkey_list.count++;
+
+	list_add_tail(&device->link.entries, global_hotkey_list.entries);
+
+	return_VALUE(status);
+}
+
+static int hotkey_remove(union acpi_hotkey *device)
+{
+	struct list_head *entries, *next;
+
+	ACPI_FUNCTION_TRACE("hotkey_remove");
+
+	list_for_each_safe(entries, next, global_hotkey_list.entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_standard_num ==
+		    device->link.hotkey_standard_num) {
+			list_del(&key->link.entries);
+			remove_proc_entry(key->poll_hotkey.action_method,
+					  hotkey_proc_dir);
+			global_hotkey_list.count--;
+			break;
+		}
+	}
+	return_VALUE(0);
+}
+
+static void hotkey_update(union acpi_hotkey *key)
+{
+	struct list_head *entries, *next;
+
+	ACPI_FUNCTION_TRACE("hotkey_update");
+
+	list_for_each_safe(entries, next, global_hotkey_list.entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_standard_num ==
+		    key->link.hotkey_standard_num) {
+			key->event_hotkey.bus_handle =
+			    key->event_hotkey.bus_handle;
+			key->event_hotkey.external_hotkey_num =
+			    key->event_hotkey.external_hotkey_num;
+			key->event_hotkey.action_handle =
+			    key->event_hotkey.action_handle;
+			key->event_hotkey.action_method =
+			    key->event_hotkey.action_method;
+			break;
+		}
+	}
+
+	return_VOID;
+}
+
+static void free_hotkey_device(union acpi_hotkey *key)
+{
+	struct acpi_device *dev;
+	int status;
+
+	ACPI_FUNCTION_TRACE("free_hotkey_device");
+
+	if (key->link.hotkey_type == ACPI_HOTKEY_EVENT) {
+		status =
+		    acpi_bus_get_device(key->event_hotkey.bus_handle, &dev);
+		if (dev->handle)
+			acpi_remove_notify_handler(dev->handle,
+						   ACPI_SYSTEM_NOTIFY,
+						   acpi_hotkey_notify_handler);
+	} else
+		remove_proc_entry(key->poll_hotkey.action_method,
+				  hotkey_proc_dir);
+	kfree(key);
+	return_VOID;
+}
+
+static int
+init_hotkey_device(union acpi_hotkey *key, char *bus_str, char *action_str,
+		   char *method, int std_num, int external_num)
+{
+	ACPI_FUNCTION_TRACE("init_hotkey_device");
+
+	key->link.hotkey_type = ACPI_HOTKEY_EVENT;
+	key->link.hotkey_standard_num = std_num;
+	key->event_hotkey.flag = 0;
+	if (is_valid_acpi_path(bus_str))
+		acpi_get_handle((acpi_handle) 0,
+				bus_str, &(key->event_hotkey.bus_handle));
+	else
+		return_VALUE(-ENODEV);
+	key->event_hotkey.external_hotkey_num = external_num;
+	if (is_valid_acpi_path(action_str))
+		acpi_get_handle((acpi_handle) 0,
+				action_str, &(key->event_hotkey.action_handle));
+	key->event_hotkey.action_method = kmalloc(sizeof(method), GFP_KERNEL);
+	strcpy(key->event_hotkey.action_method, method);
+
+	return_VALUE(!is_valid_hotkey(key));
+}
+
+static int
+init_poll_hotkey_device(union acpi_hotkey *key,
+			char *poll_str,
+			char *poll_method,
+			char *action_str, char *action_method, int std_num)
+{
+	ACPI_FUNCTION_TRACE("init_poll_hotkey_device");
+
+	key->link.hotkey_type = ACPI_HOTKEY_POLLING;
+	key->link.hotkey_standard_num = std_num;
+	key->poll_hotkey.flag = 0;
+	if (is_valid_acpi_path(poll_str))
+		acpi_get_handle((acpi_handle) 0,
+				poll_str, &(key->poll_hotkey.poll_handle));
+	else
+		return_VALUE(-ENODEV);
+	key->poll_hotkey.poll_method = poll_method;
+	if (is_valid_acpi_path(action_str))
+		acpi_get_handle((acpi_handle) 0,
+				action_str, &(key->poll_hotkey.action_handle));
+	key->poll_hotkey.action_method =
+	    kmalloc(sizeof(action_method), GFP_KERNEL);
+	strcpy(key->poll_hotkey.action_method, action_method);
+	key->poll_hotkey.poll_result =
+	    (union acpi_object *)kmalloc(sizeof(union acpi_object), GFP_KERNEL);
+	return_VALUE(is_valid_hotkey(key));
+}
+
+static int check_hotkey_valid(union acpi_hotkey *key,
+			      struct acpi_hotkey_list *list)
+{
+	ACPI_FUNCTION_TRACE("check_hotkey_valid");
+	return_VALUE(0);
+}
+
+static int hotkey_open_config(struct inode *inode, struct file *file)
+{
+	ACPI_FUNCTION_TRACE("hotkey_open_config");
+	return_VALUE(single_open
+		     (file, hotkey_config_seq_show, PDE(inode)->data));
+}
+
+static int hotkey_config_seq_show(struct seq_file *seq, void *offset)
+{
+	struct acpi_hotkey_list *hotkey_list = &global_hotkey_list;
+	struct list_head *entries, *next;
+	char bus_name[ACPI_PATHNAME_MAX] = { 0 };
+	char action_name[ACPI_PATHNAME_MAX] = { 0 };
+	struct acpi_buffer bus = { ACPI_PATHNAME_MAX, bus_name };
+	struct acpi_buffer act = { ACPI_PATHNAME_MAX, action_name };
+
+	ACPI_FUNCTION_TRACE(("hotkey_config_seq_show"));
+
+	if (!hotkey_list)
+		goto end;
+
+	list_for_each_safe(entries, next, hotkey_list->entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_type == ACPI_HOTKEY_EVENT) {
+			acpi_get_name(key->event_hotkey.bus_handle,
+				      ACPI_NAME_TYPE_MAX, &bus);
+			acpi_get_name(key->event_hotkey.action_handle,
+				      ACPI_NAME_TYPE_MAX, &act);
+			seq_printf(seq, "%s:%s:%s:%d:%d", bus_name,
+				   action_name,
+				   key->event_hotkey.action_method,
+				   key->link.hotkey_standard_num,
+				   key->event_hotkey.external_hotkey_num);
+		} /* ACPI_HOTKEY_POLLING */
+		else {
+			acpi_get_name(key->poll_hotkey.poll_handle,
+				      ACPI_NAME_TYPE_MAX, &bus);
+			acpi_get_name(key->poll_hotkey.action_handle,
+				      ACPI_NAME_TYPE_MAX, &act);
+			seq_printf(seq, "%s:%s:%s:%s:%d", bus_name,
+				   key->poll_hotkey.poll_method,
+				   action_name,
+				   key->poll_hotkey.action_method,
+				   key->link.hotkey_standard_num);
+		}
+	}
+	seq_puts(seq, "\n");
+      end:
+	return_VALUE(0);
+}
+
+static int
+get_parms(char *config_record,
+	  int *cmd,
+	  char *bus_handle,
+	  char *bus_method,
+	  char *action_handle,
+	  char *method, int *internal_event_num, int *external_event_num)
+{
+	char *tmp, *tmp1;
+	ACPI_FUNCTION_TRACE(("get_parms"));
+
+	sscanf(config_record, "%d", cmd);
+
+	tmp = strchr(config_record, ':');
+	tmp++;
+	tmp1 = strchr(tmp, ':');
+	strncpy(bus_handle, tmp, tmp1 - tmp);
+	bus_handle[tmp1 - tmp] = 0;
+
+	tmp = tmp1;
+	tmp++;
+	tmp1 = strchr(tmp, ':');
+	strncpy(bus_method, tmp, tmp1 - tmp);
+	bus_method[tmp1 - tmp] = 0;
+
+	tmp = tmp1;
+	tmp++;
+	tmp1 = strchr(tmp, ':');
+	strncpy(action_handle, tmp, tmp1 - tmp);
+	action_handle[tmp1 - tmp] = 0;
+
+	tmp = tmp1;
+	tmp++;
+	tmp1 = strchr(tmp, ':');
+	strncpy(method, tmp, tmp1 - tmp);
+	method[tmp1 - tmp] = 0;
+
+	sscanf(tmp1 + 1, "%d:%d", internal_event_num, external_event_num);
+	return_VALUE(6);
+}
+
+/*  count is length for one input record */
+static ssize_t hotkey_write_config(struct file *file,
+				   const char __user * buffer,
+				   size_t count, loff_t * data)
+{
+	struct acpi_hotkey_list *hotkey_list = &global_hotkey_list;
+	char config_record[MAX_CONFIG_RECORD_LEN];
+	char bus_handle[MAX_NAME_PATH_LEN];
+	char bus_method[MAX_NAME_PATH_LEN];
+	char action_handle[MAX_NAME_PATH_LEN];
+	char method[20];
+	int cmd, internal_event_num, external_event_num;
+	int ret = 0;
+	union acpi_hotkey *key = NULL;
+
+	ACPI_FUNCTION_TRACE(("hotkey_write_config"));
+
+	if (!hotkey_list || count > MAX_CONFIG_RECORD_LEN) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid arguments\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (copy_from_user(config_record, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data \n"));
+		return_VALUE(-EINVAL);
+	}
+	config_record[count] = '\0';
+
+	ret = get_parms(config_record,
+			&cmd,
+			bus_handle,
+			bus_method,
+			action_handle,
+			method, &internal_event_num, &external_event_num);
+	if (ret != 6) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Invalid data format ret=%d\n", ret));
+		return_VALUE(-EINVAL);
+	}
+
+	key = kmalloc(sizeof(union acpi_hotkey), GFP_KERNEL);
+	ret = init_hotkey_device(key, bus_handle, action_handle, method,
+				 internal_event_num, external_event_num);
+
+	if (ret || check_hotkey_valid(key, hotkey_list)) {
+		kfree(key);
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid hotkey \n"));
+		return_VALUE(-EINVAL);
+	}
+	switch (cmd) {
+	case 0:
+		hotkey_add(key);
+		break;
+	case 1:
+		hotkey_remove(key);
+		free_hotkey_device(key);
+		break;
+	case 2:
+		hotkey_update(key);
+		break;
+	default:
+		break;
+	}
+	return_VALUE(count);
+}
+
+/*  count is length for one input record */
+static ssize_t hotkey_write_poll_config(struct file *file,
+					const char __user * buffer,
+					size_t count, loff_t * data)
+{
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_hotkey_list *hotkey_list =
+	    (struct acpi_hotkey_list *)m->private;
+
+	char config_record[MAX_CONFIG_RECORD_LEN];
+	char polling_handle[MAX_NAME_PATH_LEN];
+	char action_handle[MAX_NAME_PATH_LEN];
+	char poll_method[20], action_method[20];
+	int ret, internal_event_num, cmd, external_event_num;
+	union acpi_hotkey *key = NULL;
+
+	ACPI_FUNCTION_TRACE("hotkey_write_poll_config");
+
+	if (!hotkey_list || count > MAX_CONFIG_RECORD_LEN) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid arguments\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (copy_from_user(config_record, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data \n"));
+		return_VALUE(-EINVAL);
+	}
+	config_record[count] = '\0';
+
+	ret = get_parms(config_record,
+			&cmd,
+			polling_handle,
+			poll_method,
+			action_handle,
+			action_method,
+			&internal_event_num, &external_event_num);
+
+	if (ret != 6) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	key = kmalloc(sizeof(union acpi_hotkey), GFP_KERNEL);
+	ret = init_poll_hotkey_device(key, polling_handle, poll_method,
+				      action_handle, action_method,
+				      internal_event_num);
+	if (ret || check_hotkey_valid(key, hotkey_list)) {
+		kfree(key);
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid hotkey \n"));
+		return_VALUE(-EINVAL);
+	}
+	switch (cmd) {
+	case 0:
+		hotkey_add(key);
+		break;
+	case 1:
+		hotkey_remove(key);
+		break;
+	case 2:
+		hotkey_update(key);
+		break;
+	default:
+		break;
+	}
+	return_VALUE(count);
+}
+
+/*  
+ * This function evaluates an ACPI method, given an int as parameter, the
+ * method is searched within the scope of the handle, can be NULL. The output
+ * of the method is written is output, which can also be NULL
+ *
+ * returns 1 if write is successful, 0 else.
+ */
+static int write_acpi_int(acpi_handle handle, const char *method, int val,
+			  struct acpi_buffer *output)
+{
+	struct acpi_object_list params;	/* list of input parameters (an int here) */
+	union acpi_object in_obj;	/* the only param we use */
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE("write_acpi_int");
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_INTEGER;
+	in_obj.integer.value = val;
+
+	status = acpi_evaluate_object(handle, (char *)method, &params, output);
+
+	return_VALUE(status == AE_OK);
+}
+
+static int read_acpi_int(acpi_handle handle, const char *method, int *val)
+{
+	struct acpi_buffer output;
+	union acpi_object out_obj;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE("read_acpi_int");
+	output.length = sizeof(out_obj);
+	output.pointer = &out_obj;
+
+	status = acpi_evaluate_object(handle, (char *)method, NULL, &output);
+	*val = out_obj.integer.value;
+	return_VALUE((status == AE_OK)
+		     && (out_obj.type == ACPI_TYPE_INTEGER));
+}
+
+static acpi_handle
+get_handle_from_hotkeylist(struct acpi_hotkey_list *hotkey_list, int event_num)
+{
+	struct list_head *entries, *next;
+
+	list_for_each_safe(entries, next, hotkey_list->entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_type == ACPI_HOTKEY_EVENT
+		    && key->link.hotkey_standard_num == event_num) {
+			return (key->event_hotkey.action_handle);
+		}
+	}
+	return (NULL);
+}
+
+static
+char *get_method_from_hotkeylist(struct acpi_hotkey_list *hotkey_list,
+				 int event_num)
+{
+	struct list_head *entries, *next;
+
+	list_for_each_safe(entries, next, hotkey_list->entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+
+		if (key->link.hotkey_type == ACPI_HOTKEY_EVENT &&
+		    key->link.hotkey_standard_num == event_num)
+			return (key->event_hotkey.action_method);
+	}
+	return (NULL);
+}
+
+static struct acpi_polling_hotkey *get_hotkey_by_event(struct
+						       acpi_hotkey_list
+						       *hotkey_list, int event)
+{
+	struct list_head *entries, *next;
+
+	list_for_each_safe(entries, next, hotkey_list->entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+		if (key->link.hotkey_type == ACPI_HOTKEY_POLLING
+		    && key->link.hotkey_standard_num == event) {
+			return (&key->poll_hotkey);
+		}
+	}
+	return (NULL);
+}
+
+/*  
+ * user call AML method interface:
+ * Call convention:
+ * echo "event_num: arg type : value"
+ * example: echo "1:1:30" > /proc/acpi/action
+ * Just support 1 integer arg passing to AML method
+ */
+
+static ssize_t hotkey_execute_aml_method(struct file *file,
+					 const char __user * buffer,
+					 size_t count, loff_t * data)
+{
+	struct acpi_hotkey_list *hotkey_list = &global_hotkey_list;
+	char arg[MAX_CALL_PARM];
+	int event, type, value;
+
+	char *method;
+	acpi_handle handle;
+
+	ACPI_FUNCTION_TRACE("hotkey_execte_aml_method");
+
+	if (!hotkey_list || count > MAX_CALL_PARM) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument 1"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (copy_from_user(arg, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument 2"));
+		return_VALUE(-EINVAL);
+	}
+
+	arg[count] = '\0';
+
+	if (sscanf(arg, "%d:%d:%d", &event, &type, &value) != 3) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument 3"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (type == ACPI_TYPE_INTEGER) {
+		handle = get_handle_from_hotkeylist(hotkey_list, event);
+		method = (char *)get_method_from_hotkeylist(hotkey_list, event);
+		if (IS_EVENT(event))
+			write_acpi_int(handle, method, value, NULL);
+		else if (IS_POLL(event)) {
+			struct acpi_polling_hotkey *key;
+			key = (struct acpi_polling_hotkey *)
+			    get_hotkey_by_event(hotkey_list, event);
+			read_acpi_int(handle, method, key->poll_result);
+		}
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Not supported"));
+		return_VALUE(-EINVAL);
+	}
+
+	return_VALUE(count);
+}
+
+static int __init hotkey_init(void)
+{
+	int result;
+	mode_t mode = S_IFREG | S_IRUGO | S_IWUGO;
+
+	ACPI_FUNCTION_TRACE("hotkey_init");
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	if (acpi_specific_hotkey_enabled) {
+		printk("Using specific hotkey driver\n");
+		return -ENODEV;
+	}
+
+	hotkey_proc_dir = proc_mkdir(HOTKEY_PROC, acpi_root_dir);
+	if (!hotkey_proc_dir) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  HOTKEY_PROC));
+		return (-ENODEV);
+	}
+	hotkey_proc_dir->owner = THIS_MODULE;
+
+	hotkey_config =
+	    create_proc_entry(HOTKEY_EV_CONFIG, mode, hotkey_proc_dir);
+	if (!hotkey_config) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  HOTKEY_EV_CONFIG));
+		return (-ENODEV);
+	} else {
+		hotkey_config->proc_fops = &hotkey_config_fops;
+		hotkey_config->data = &global_hotkey_list;
+		hotkey_config->owner = THIS_MODULE;
+		hotkey_config->uid = 0;
+		hotkey_config->gid = 0;
+	}
+
+	hotkey_poll_config =
+	    create_proc_entry(HOTKEY_PL_CONFIG, mode, hotkey_proc_dir);
+	if (!hotkey_poll_config) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  HOTKEY_EV_CONFIG));
+		return (-ENODEV);
+	} else {
+		hotkey_poll_config->proc_fops = &hotkey_poll_config_fops;
+		hotkey_poll_config->data = &global_hotkey_list;
+		hotkey_poll_config->owner = THIS_MODULE;
+		hotkey_poll_config->uid = 0;
+		hotkey_poll_config->gid = 0;
+	}
+
+	hotkey_action = create_proc_entry(HOTKEY_ACTION, mode, hotkey_proc_dir);
+	if (!hotkey_action) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  HOTKEY_ACTION));
+		return (-ENODEV);
+	} else {
+		hotkey_action->proc_fops = &hotkey_action_fops;
+		hotkey_action->owner = THIS_MODULE;
+		hotkey_action->uid = 0;
+		hotkey_action->gid = 0;
+	}
+
+	hotkey_info = create_proc_entry(HOTKEY_INFO, mode, hotkey_proc_dir);
+	if (!hotkey_info) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				  "Hotkey: Unable to create %s entry\n",
+				  HOTKEY_INFO));
+		return (-ENODEV);
+	} else {
+		hotkey_info->proc_fops = &hotkey_info_fops;
+		hotkey_info->owner = THIS_MODULE;
+		hotkey_info->uid = 0;
+		hotkey_info->gid = 0;
+	}
+
+	result = acpi_bus_register_driver(&hotkey_driver);
+	if (result < 0) {
+		remove_proc_entry(HOTKEY_PROC, acpi_root_dir);
+		return (-ENODEV);
+	}
+	global_hotkey_list.count = 0;
+	global_hotkey_list.entries = &hotkey_entries;
+
+	INIT_LIST_HEAD(&hotkey_entries);
+
+	return (0);
+}
+
+static void __exit hotkey_exit(void)
+{
+	struct list_head *entries, *next;
+
+	ACPI_FUNCTION_TRACE("hotkey_remove");
+
+	list_for_each_safe(entries, next, global_hotkey_list.entries) {
+		union acpi_hotkey *key =
+		    container_of(entries, union acpi_hotkey, entries);
+
+		acpi_os_wait_events_complete(NULL);
+		list_del(&key->link.entries);
+		global_hotkey_list.count--;
+		free_hotkey_device(key);
+	}
+	acpi_bus_unregister_driver(&hotkey_driver);
+	remove_proc_entry(HOTKEY_EV_CONFIG, hotkey_proc_dir);
+	remove_proc_entry(HOTKEY_PL_CONFIG, hotkey_proc_dir);
+	remove_proc_entry(HOTKEY_ACTION, hotkey_proc_dir);
+	remove_proc_entry(HOTKEY_INFO, hotkey_proc_dir);
+	remove_proc_entry(HOTKEY_PROC, acpi_root_dir);
+	return;
+}
+
+module_init(hotkey_init);
+module_exit(hotkey_exit);
diff --git a/drivers/acpi/ibm_acpi.c b/drivers/acpi/ibm_acpi.c
--- a/drivers/acpi/ibm_acpi.c
+++ b/drivers/acpi/ibm_acpi.c
@@ -1025,7 +1025,7 @@ static int setup_notify(struct ibm_struc
 	return 0;
 }
 
-static int device_add(struct acpi_device *device)
+static int ibmacpi_device_add(struct acpi_device *device)
 {
 	return 0;
 }
@@ -1043,7 +1043,7 @@ static int register_driver(struct ibm_st
 	memset(ibm->driver, 0, sizeof(struct acpi_driver));
 	sprintf(ibm->driver->name, "%s/%s", IBM_NAME, ibm->name);
 	ibm->driver->ids = ibm->hid;
-	ibm->driver->ops.add = &device_add;
+	ibm->driver->ops.add = &ibmacpi_device_add;
 
 	ret = acpi_bus_register_driver(ibm->driver);
 	if (ret < 0) {
@@ -1185,6 +1185,10 @@ static int __init acpi_ibm_init(void)
 	if (acpi_disabled)
 		return -ENODEV;
 
+	if (!acpi_specific_hotkey_enabled){
+		printk(IBM_ERR "Using generic hotkey driver\n");
+		return -ENODEV;	
+	}
 	/* these handles are required */
 	if (IBM_HANDLE_INIT(ec,	  1) < 0 ||
 	    IBM_HANDLE_INIT(hkey, 1) < 0 ||
diff --git a/drivers/acpi/namespace/nsaccess.c b/drivers/acpi/namespace/nsaccess.c
--- a/drivers/acpi/namespace/nsaccess.c
+++ b/drivers/acpi/namespace/nsaccess.c
@@ -67,7 +67,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ns_root_initialize (void)
+acpi_ns_root_initialize (
+	void)
 {
 	acpi_status                         status;
 	const struct acpi_predefined_names *init_val = NULL;
@@ -158,19 +159,20 @@ acpi_ns_root_initialize (void)
 				obj_desc->method.param_count = (u8) ACPI_TO_INTEGER (val);
 				obj_desc->common.flags |= AOPOBJ_DATA_VALID;
 
-#if defined (_ACPI_ASL_COMPILER) || defined (_ACPI_DUMP_App)
+#if defined (ACPI_ASL_COMPILER)
 
-				/*
-				 * i_aSL Compiler cheats by putting parameter count
-				 * in the owner_iD
-				 */
-				new_node->owner_id = obj_desc->method.param_count;
+				/* save the parameter count for the i_aSL compiler */
+
+				new_node->value = obj_desc->method.param_count;
 #else
 				/* Mark this as a very SPECIAL method */
 
 				obj_desc->method.method_flags = AML_METHOD_INTERNAL_ONLY;
+
+#ifndef ACPI_DUMP_APP
 				obj_desc->method.implementation = acpi_ut_osi_implementation;
 #endif
+#endif
 				break;
 
 			case ACPI_TYPE_INTEGER:
@@ -265,7 +267,7 @@ unlock_and_exit:
  *
  * FUNCTION:    acpi_ns_lookup
  *
- * PARAMETERS:  prefix_node     - Search scope if name is not fully qualified
+ * PARAMETERS:  scope_info      - Current scope info block
  *              Pathname        - Search pathname, in internal format
  *                                (as represented in the AML stream)
  *              Type            - Type associated with name
diff --git a/drivers/acpi/namespace/nsalloc.c b/drivers/acpi/namespace/nsalloc.c
--- a/drivers/acpi/namespace/nsalloc.c
+++ b/drivers/acpi/namespace/nsalloc.c
@@ -49,14 +49,20 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsalloc")
 
+/* Local prototypes */
+
+static void
+acpi_ns_remove_reference (
+	struct acpi_namespace_node      *node);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_create_node
  *
- * PARAMETERS:  acpi_name       - Name of the new node
+ * PARAMETERS:  Name            - Name of the new node (4 char ACPI name)
  *
- * RETURN:      None
+ * RETURN:      New namespace node (Null on failure)
  *
  * DESCRIPTION: Create a namespace node
  *
@@ -77,7 +83,7 @@ acpi_ns_create_node (
 		return_PTR (NULL);
 	}
 
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_allocated++);
+	ACPI_MEM_TRACKING (acpi_gbl_ns_node_list->total_allocated++);
 
 	node->name.integer   = name;
 	node->reference_count = 1;
@@ -145,8 +151,7 @@ acpi_ns_delete_node (
 		}
 	}
 
-
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_freed++);
+	ACPI_MEM_TRACKING (acpi_gbl_ns_node_list->total_freed++);
 
 	/*
 	 * Detach an object if there is one then delete the node
@@ -157,57 +162,6 @@ acpi_ns_delete_node (
 }
 
 
-#ifdef ACPI_ALPHABETIC_NAMESPACE
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ns_compare_names
- *
- * PARAMETERS:  Name1           - First name to compare
- *              Name2           - Second name to compare
- *
- * RETURN:      value from strncmp
- *
- * DESCRIPTION: Compare two ACPI names.  Names that are prefixed with an
- *              underscore are forced to be alphabetically first.
- *
- ******************************************************************************/
-
-int
-acpi_ns_compare_names (
-	char                            *name1,
-	char                            *name2)
-{
-	char                            reversed_name1[ACPI_NAME_SIZE];
-	char                            reversed_name2[ACPI_NAME_SIZE];
-	u32                             i;
-	u32                             j;
-
-
-	/*
-	 * Replace all instances of "underscore" with a value that is smaller so
-	 * that all names that are prefixed with underscore(s) are alphabetically
-	 * first.
-	 *
-	 * Reverse the name bytewise so we can just do a 32-bit compare instead
-	 * of a strncmp.
-	 */
-	for (i = 0, j= (ACPI_NAME_SIZE - 1); i < ACPI_NAME_SIZE; i++, j--) {
-		reversed_name1[j] = name1[i];
-		if (name1[i] == '_') {
-			reversed_name1[j] = '*';
-		}
-
-		reversed_name2[j] = name2[i];
-		if (name2[i] == '_') {
-			reversed_name2[j] = '*';
-		}
-	}
-
-	return (*(int *) reversed_name1 - *(int *) reversed_name2);
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_install_node
@@ -222,10 +176,9 @@ acpi_ns_compare_names (
  * DESCRIPTION: Initialize a new namespace node and install it amongst
  *              its peers.
  *
- *              Note: Current namespace lookup is linear search.  However, the
- *              nodes are linked in alphabetical order to 1) put all reserved
- *              names (start with underscore) first, and to 2) make a readable
- *              namespace dump.
+ *              Note: Current namespace lookup is linear search. This appears
+ *              to be sufficient as namespace searches consume only a small
+ *              fraction of the execution time of the ACPI subsystem.
  *
  ******************************************************************************/
 
@@ -236,12 +189,8 @@ acpi_ns_install_node (
 	struct acpi_namespace_node      *node,          /* New Child*/
 	acpi_object_type                type)
 {
-	u16                             owner_id = 0;
+	acpi_owner_id                   owner_id = 0;
 	struct acpi_namespace_node      *child_node;
-#ifdef ACPI_ALPHABETIC_NAMESPACE
-
-	struct acpi_namespace_node      *previous_child_node;
-#endif
 
 
 	ACPI_FUNCTION_TRACE ("ns_install_node");
@@ -265,56 +214,6 @@ acpi_ns_install_node (
 		node->peer = parent_node;
 	}
 	else {
-#ifdef ACPI_ALPHABETIC_NAMESPACE
-		/*
-		 * Walk the list whilst searching for the correct
-		 * alphabetic placement.
-		 */
-		previous_child_node = NULL;
-		while (acpi_ns_compare_names (acpi_ut_get_node_name (child_node), acpi_ut_get_node_name (node)) < 0) {
-			if (child_node->flags & ANOBJ_END_OF_PEER_LIST) {
-				/* Last peer;  Clear end-of-list flag */
-
-				child_node->flags &= ~ANOBJ_END_OF_PEER_LIST;
-
-				/* This node is the new peer to the child node */
-
-				child_node->peer = node;
-
-				/* This node is the new end-of-list */
-
-				node->flags |= ANOBJ_END_OF_PEER_LIST;
-				node->peer = parent_node;
-				break;
-			}
-
-			/* Get next peer */
-
-			previous_child_node = child_node;
-			child_node = child_node->peer;
-		}
-
-		/* Did the node get inserted at the end-of-list? */
-
-		if (!(node->flags & ANOBJ_END_OF_PEER_LIST)) {
-			/*
-			 * Loop above terminated without reaching the end-of-list.
-			 * Insert the new node at the current location
-			 */
-			if (previous_child_node) {
-				/* Insert node alphabetically */
-
-				node->peer = child_node;
-				previous_child_node->peer = node;
-			}
-			else {
-				/* Insert node alphabetically at start of list */
-
-				node->peer = child_node;
-				parent_node->child = node;
-			}
-		}
-#else
 		while (!(child_node->flags & ANOBJ_END_OF_PEER_LIST)) {
 			child_node = child_node->peer;
 		}
@@ -324,9 +223,8 @@ acpi_ns_install_node (
 		/* Clear end-of-list flag */
 
 		child_node->flags &= ~ANOBJ_END_OF_PEER_LIST;
-		node->flags     |= ANOBJ_END_OF_PEER_LIST;
+		node->flags |= ANOBJ_END_OF_PEER_LIST;
 		node->peer = parent_node;
-#endif
 	}
 
 	/* Init the new entry */
@@ -407,7 +305,7 @@ acpi_ns_delete_children (
 
 		/* Now we can free this child object */
 
-		ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_freed++);
+		ACPI_MEM_TRACKING (acpi_gbl_ns_node_list->total_freed++);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Object %p, Remaining %X\n",
 			child_node, acpi_gbl_current_node_count));
@@ -429,7 +327,8 @@ acpi_ns_delete_children (
 		/* There should be only one reference remaining on this node */
 
 		if (child_node->reference_count != 1) {
-			ACPI_REPORT_WARNING (("Existing references (%d) on node being deleted (%p)\n",
+			ACPI_REPORT_WARNING ((
+				"Existing references (%d) on node being deleted (%p)\n",
 				child_node->reference_count, child_node));
 		}
 
@@ -548,7 +447,7 @@ acpi_ns_delete_namespace_subtree (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ns_remove_reference (
 	struct acpi_namespace_node      *node)
 {
@@ -603,7 +502,7 @@ acpi_ns_remove_reference (
 
 void
 acpi_ns_delete_namespace_by_owner (
-	u16                             owner_id)
+	acpi_owner_id                    owner_id)
 {
 	struct acpi_namespace_node      *child_node;
 	struct acpi_namespace_node      *deletion_node;
@@ -614,6 +513,10 @@ acpi_ns_delete_namespace_by_owner (
 	ACPI_FUNCTION_TRACE_U32 ("ns_delete_namespace_by_owner", owner_id);
 
 
+	if (owner_id == 0) {
+		return_VOID;
+	}
+
 	parent_node   = acpi_gbl_root_node;
 	child_node    = NULL;
 	deletion_node = NULL;
diff --git a/drivers/acpi/namespace/nsdump.c b/drivers/acpi/namespace/nsdump.c
--- a/drivers/acpi/namespace/nsdump.c
+++ b/drivers/acpi/namespace/nsdump.c
@@ -50,16 +50,32 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsdump")
 
+/* Local prototypes */
 
-#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+void
+acpi_ns_dump_root_devices (
+	void);
+
+static acpi_status
+acpi_ns_dump_one_device (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+#endif
 
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_print_pathname
  *
- * PARAMETERS:  num_segment         - Number of ACPI name segments
+ * PARAMETERS:  num_segments        - Number of ACPI name segments
  *              Pathname            - The compressed (internal) path
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Print an object's full namespace pathname
  *
  ******************************************************************************/
@@ -69,6 +85,9 @@ acpi_ns_print_pathname (
 	u32                             num_segments,
 	char                            *pathname)
 {
+	acpi_native_uint                i;
+
+
 	ACPI_FUNCTION_NAME ("ns_print_pathname");
 
 
@@ -81,9 +100,13 @@ acpi_ns_print_pathname (
 	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "["));
 
 	while (num_segments) {
-		acpi_os_printf ("%4.4s", pathname);
-		pathname += ACPI_NAME_SIZE;
+		for (i = 0; i < 4; i++) {
+			ACPI_IS_PRINT (pathname[i]) ?
+				acpi_os_printf ("%c", pathname[i]) :
+				acpi_os_printf ("?");
+		}
 
+		pathname += ACPI_NAME_SIZE;
 		num_segments--;
 		if (num_segments) {
 			acpi_os_printf (".");
@@ -103,6 +126,8 @@ acpi_ns_print_pathname (
  *              Level               - Desired debug level
  *              Component           - Caller's component ID
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Print an object's full namespace pathname
  *              Manages allocation/freeing of a pathname buffer
  *
@@ -137,9 +162,12 @@ acpi_ns_dump_pathname (
  *
  * FUNCTION:    acpi_ns_dump_one_object
  *
- * PARAMETERS:  Handle              - Node to be dumped
+ * PARAMETERS:  obj_handle          - Node to be dumped
  *              Level               - Nesting level of the handle
  *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Dump a single Node
  *              This procedure is a user_function called by acpi_ns_walk_namespace.
@@ -182,38 +210,42 @@ acpi_ns_dump_one_object (
 
 	/* Check if the owner matches */
 
-	if ((info->owner_id != ACPI_UINT32_MAX) &&
+	if ((info->owner_id != ACPI_OWNER_ID_MAX) &&
 		(info->owner_id != this_node->owner_id)) {
 		return (AE_OK);
 	}
 
-	/* Indent the object according to the level */
+	if (!(info->display_type & ACPI_DISPLAY_SHORT)) {
+		/* Indent the object according to the level */
 
-	acpi_os_printf ("%2d%*s", (u32) level - 1, (int) level * 2, " ");
+		acpi_os_printf ("%2d%*s", (u32) level - 1, (int) level * 2, " ");
 
-	/* Check the node type and name */
+		/* Check the node type and name */
 
-	if (type > ACPI_TYPE_LOCAL_MAX) {
-		ACPI_REPORT_WARNING (("Invalid ACPI Type %08X\n", type));
-	}
+		if (type > ACPI_TYPE_LOCAL_MAX) {
+			ACPI_REPORT_WARNING (("Invalid ACPI Type %08X\n", type));
+		}
+
+		if (!acpi_ut_valid_acpi_name (this_node->name.integer)) {
+			ACPI_REPORT_WARNING (("Invalid ACPI Name %08X\n",
+				this_node->name.integer));
+		}
 
-	if (!acpi_ut_valid_acpi_name (this_node->name.integer)) {
-		ACPI_REPORT_WARNING (("Invalid ACPI Name %08X\n",
-			this_node->name.integer));
+		acpi_os_printf ("%4.4s", acpi_ut_get_node_name (this_node));
 	}
 
 	/*
 	 * Now we can print out the pertinent information
 	 */
-	acpi_os_printf ("%4.4s %-12s %p ",
-			acpi_ut_get_node_name (this_node), acpi_ut_get_type_name (type), this_node);
+	acpi_os_printf (" %-12s %p ",
+			acpi_ut_get_type_name (type), this_node);
 
 	dbg_level = acpi_dbg_level;
 	acpi_dbg_level = 0;
 	obj_desc = acpi_ns_get_attached_object (this_node);
 	acpi_dbg_level = dbg_level;
 
-	switch (info->display_type) {
+	switch (info->display_type & ACPI_DISPLAY_MASK) {
 	case ACPI_DISPLAY_SUMMARY:
 
 		if (!obj_desc) {
@@ -394,8 +426,7 @@ acpi_ns_dump_one_object (
 			return (AE_OK);
 		}
 
-		acpi_os_printf ("(R%d)",
-				obj_desc->common.reference_count);
+		acpi_os_printf ("(R%d)", obj_desc->common.reference_count);
 
 		switch (type) {
 		case ACPI_TYPE_METHOD:
@@ -455,7 +486,7 @@ acpi_ns_dump_one_object (
 
 	while (obj_desc) {
 		obj_type = ACPI_TYPE_INVALID;
-		acpi_os_printf ("      Attached Object %p: ", obj_desc);
+		acpi_os_printf ("Attached Object %p: ", obj_desc);
 
 		/* Decode the type of attached object and dump the contents */
 
@@ -464,9 +495,9 @@ acpi_ns_dump_one_object (
 
 			acpi_os_printf ("(Ptr to Node)\n");
 			bytes_to_dump = sizeof (struct acpi_namespace_node);
+			ACPI_DUMP_BUFFER (obj_desc, bytes_to_dump);
 			break;
 
-
 		case ACPI_DESC_TYPE_OPERAND:
 
 			obj_type = ACPI_GET_OBJECT_TYPE (obj_desc);
@@ -477,24 +508,19 @@ acpi_ns_dump_one_object (
 				bytes_to_dump = 32;
 			}
 			else {
-				acpi_os_printf ("(Ptr to ACPI Object type %s, %X)\n",
-					acpi_ut_get_type_name (obj_type), obj_type);
+				acpi_os_printf ("(Ptr to ACPI Object type %X [%s])\n",
+					obj_type, acpi_ut_get_type_name (obj_type));
 				bytes_to_dump = sizeof (union acpi_operand_object);
 			}
-			break;
 
+			ACPI_DUMP_BUFFER (obj_desc, bytes_to_dump);
+			break;
 
 		default:
 
-			acpi_os_printf (
-				"(String or Buffer ptr - not an object descriptor) [%s]\n",
-				acpi_ut_get_descriptor_name (obj_desc));
-			bytes_to_dump = 16;
 			break;
 		}
 
-		ACPI_DUMP_BUFFER (obj_desc, bytes_to_dump);
-
 		/* If value is NOT an internal object, we are done */
 
 		if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
@@ -505,13 +531,17 @@ acpi_ns_dump_one_object (
 		 * Valid object, get the pointer to next level, if any
 		 */
 		switch (obj_type) {
+		case ACPI_TYPE_BUFFER:
 		case ACPI_TYPE_STRING:
+			/*
+			 * NOTE: takes advantage of common fields between string/buffer
+			 */
+			bytes_to_dump = obj_desc->string.length;
 			obj_desc = (void *) obj_desc->string.pointer;
-			break;
-
-		case ACPI_TYPE_BUFFER:
-			obj_desc = (void *) obj_desc->buffer.pointer;
-			break;
+			acpi_os_printf ( "(Buffer/String pointer %p length %X)\n",
+				obj_desc, bytes_to_dump);
+			ACPI_DUMP_BUFFER (obj_desc, bytes_to_dump);
+			goto cleanup;
 
 		case ACPI_TYPE_BUFFER_FIELD:
 			obj_desc = (union acpi_operand_object *) obj_desc->buffer_field.buffer_obj;
@@ -551,18 +581,20 @@ cleanup:
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_dump_objects
  *
  * PARAMETERS:  Type                - Object type to be dumped
+ *              display_type        - 0 or ACPI_DISPLAY_SUMMARY
  *              max_depth           - Maximum depth of dump. Use ACPI_UINT32_MAX
  *                                    for an effectively unlimited depth.
  *              owner_id            - Dump only objects owned by this ID.  Use
  *                                    ACPI_UINT32_MAX to match all owners.
  *              start_handle        - Where in namespace to start/end search
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump typed objects within the loaded namespace.
  *              Uses acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object.
  *
@@ -573,7 +605,7 @@ acpi_ns_dump_objects (
 	acpi_object_type                type,
 	u8                              display_type,
 	u32                             max_depth,
-	u32                             owner_id,
+	acpi_owner_id                   owner_id,
 	acpi_handle                     start_handle)
 {
 	struct acpi_walk_info           info;
@@ -590,8 +622,42 @@ acpi_ns_dump_objects (
 			 ACPI_NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
 			 (void *) &info, NULL);
 }
+#endif	/* ACPI_FUTURE_USAGE */
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_entry
+ *
+ * PARAMETERS:  Handle              - Node to be dumped
+ *              debug_level         - Output level
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump a single Node
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_dump_entry (
+	acpi_handle                     handle,
+	u32                             debug_level)
+{
+	struct acpi_walk_info           info;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	info.debug_level = debug_level;
+	info.owner_id = ACPI_OWNER_ID_MAX;
+	info.display_type = ACPI_DISPLAY_SUMMARY;
+
+	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
+}
 
 
+#ifdef ACPI_ASL_COMPILER
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_dump_tables
@@ -601,6 +667,8 @@ acpi_ns_dump_objects (
  *              max_depth           - Maximum depth of dump.  Use INT_MAX
  *                                    for an effectively unlimited depth.
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump the name space, or a portion of it.
  *
  ******************************************************************************/
@@ -626,48 +694,15 @@ acpi_ns_dump_tables (
 	}
 
 	if (ACPI_NS_ALL == search_base) {
-		/*  entire namespace    */
+		/* Entire namespace */
 
 		search_handle = acpi_gbl_root_node;
 		ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "\\\n"));
 	}
 
 	acpi_ns_dump_objects (ACPI_TYPE_ANY, ACPI_DISPLAY_OBJECTS, max_depth,
-			ACPI_UINT32_MAX, search_handle);
+			ACPI_OWNER_ID_MAX, search_handle);
 	return_VOID;
 }
-
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ns_dump_entry
- *
- * PARAMETERS:  Handle              - Node to be dumped
- *              debug_level         - Output level
- *
- * DESCRIPTION: Dump a single Node
- *
- ******************************************************************************/
-
-void
-acpi_ns_dump_entry (
-	acpi_handle                     handle,
-	u32                             debug_level)
-{
-	struct acpi_walk_info           info;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	info.debug_level = debug_level;
-	info.owner_id = ACPI_UINT32_MAX;
-	info.display_type = ACPI_DISPLAY_SUMMARY;
-
-	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
-}
-
-#endif
-
+#endif	/* _ACPI_ASL_COMPILER */
+#endif	/* defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER) */
diff --git a/drivers/acpi/namespace/nsdumpdv.c b/drivers/acpi/namespace/nsdumpdv.c
--- a/drivers/acpi/namespace/nsdumpdv.c
+++ b/drivers/acpi/namespace/nsdumpdv.c
@@ -43,15 +43,18 @@
 
 
 #include <acpi/acpi.h>
-#include <acpi/acnamesp.h>
 
 
+/* TBD: This entire module is apparently obsolete and should be removed */
+
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsdumpdv")
 
-
+#ifdef ACPI_OBSOLETE_FUNCTIONS
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
+#include <acpi/acnamesp.h>
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_dump_one_device
@@ -59,13 +62,16 @@
  * PARAMETERS:  Handle              - Node to be dumped
  *              Level               - Nesting level of the handle
  *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Dump a single Node that represents a device
  *              This procedure is a user_function called by acpi_ns_walk_namespace.
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_dump_one_device (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -108,12 +114,15 @@ acpi_ns_dump_one_device (
  *
  * PARAMETERS:  None
  *
+ * RETURN:      None
+ *
  * DESCRIPTION: Dump all objects of type "device"
  *
  ******************************************************************************/
 
 void
-acpi_ns_dump_root_devices (void)
+acpi_ns_dump_root_devices (
+	void)
 {
 	acpi_handle                     sys_bus_handle;
 	acpi_status                     status;
@@ -142,5 +151,6 @@ acpi_ns_dump_root_devices (void)
 }
 
 #endif
+#endif
 
 
diff --git a/drivers/acpi/namespace/nseval.c b/drivers/acpi/namespace/nseval.c
--- a/drivers/acpi/namespace/nseval.c
+++ b/drivers/acpi/namespace/nseval.c
@@ -52,19 +52,33 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nseval")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_execute_control_method (
+	struct acpi_parameter_info      *info);
+
+static acpi_status
+acpi_ns_get_object_value (
+	struct acpi_parameter_info      *info);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_evaluate_relative
  *
- * PARAMETERS:  Pathname            - Name of method to execute, If NULL, the
- *                                    handle is the object to execute
- *              Info                - Method info block
+ * PARAMETERS:  Pathname        - Name of method to execute, If NULL, the
+ *                                handle is the object to execute
+ *              Info            - Method info block, contains:
+ *                  return_object   - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *                  Params          - List of parameters to pass to the method,
+ *                                    terminated by NULL.  Params itself may be
+ *                                    NULL if no parameters are being passed.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Find and execute the requested method using the handle as a
- *              scope
+ * DESCRIPTION: Evaluate the object or find and execute the requested method
  *
  * MUTEX:       Locks Namespace
  *
@@ -157,8 +171,8 @@ cleanup1:
  *
  * FUNCTION:    acpi_ns_evaluate_by_name
  *
- * PARAMETERS:  Pathname            - Fully qualified pathname to the object
- *              Info                - Contains:
+ * PARAMETERS:  Pathname        - Fully qualified pathname to the object
+ *              Info                - Method info block, contains:
  *                  return_object   - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *                  Params          - List of parameters to pass to the method,
@@ -167,8 +181,8 @@ cleanup1:
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Find and execute the requested method passing the given
- *              parameters
+ * DESCRIPTION: Evaluate the object or rind and execute the requested method
+ *              passing the given parameters
  *
  * MUTEX:       Locks Namespace
  *
@@ -241,17 +255,21 @@ cleanup:
  *
  * FUNCTION:    acpi_ns_evaluate_by_handle
  *
- * PARAMETERS:  Handle              - Method Node to execute
- *              Params              - List of parameters to pass to the method,
- *                                    terminated by NULL.  Params itself may be
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method/Object Node to execute
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *              param_type          - Type of Parameter list
- *              return_object       - Where to put method's return value (if
- *                                    any).  If NULL, no value is returned.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Execute the requested method passing the given parameters
+ * DESCRIPTION: Evaluate object or execute the requested method passing the
+ *              given parameters
  *
  * MUTEX:       Locks Namespace
  *
@@ -345,7 +363,17 @@ acpi_ns_evaluate_by_handle (
  *
  * FUNCTION:    acpi_ns_execute_control_method
  *
- * PARAMETERS:  Info            - Method info block (w/params)
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method Node to execute
+ *                  obj_desc        - Method object
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
+ *                                    NULL if no parameters are being passed.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
@@ -355,12 +383,11 @@ acpi_ns_evaluate_by_handle (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_execute_control_method (
 	struct acpi_parameter_info      *info)
 {
 	acpi_status                     status;
-	union acpi_operand_object       *obj_desc;
 
 
 	ACPI_FUNCTION_TRACE ("ns_execute_control_method");
@@ -368,8 +395,8 @@ acpi_ns_execute_control_method (
 
 	/* Verify that there is a method associated with this object */
 
-	obj_desc = acpi_ns_get_attached_object (info->node);
-	if (!obj_desc) {
+	info->obj_desc = acpi_ns_get_attached_object (info->node);
+	if (!info->obj_desc) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No attached method object\n"));
 
 		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
@@ -380,7 +407,7 @@ acpi_ns_execute_control_method (
 		ACPI_LV_INFO, _COMPONENT);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Method at AML address %p Length %X\n",
-		obj_desc->method.aml_start + 1, obj_desc->method.aml_length - 1));
+		info->obj_desc->method.aml_start + 1, info->obj_desc->method.aml_length - 1));
 
 	/*
 	 * Unlock the namespace before execution.  This allows namespace access
@@ -403,7 +430,7 @@ acpi_ns_execute_control_method (
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_psx_execute (info);
+	status = acpi_ps_execute_method (info);
 	acpi_ex_exit_interpreter ();
 
 	return_ACPI_STATUS (status);
@@ -414,7 +441,10 @@ acpi_ns_execute_control_method (
  *
  * FUNCTION:    acpi_ns_get_object_value
  *
- * PARAMETERS:  Info            - Method info block (w/params)
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Object's NS node
+ *                  return_object   - Where to put object value (if
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
@@ -424,7 +454,7 @@ acpi_ns_execute_control_method (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_get_object_value (
 	struct acpi_parameter_info      *info)
 {
diff --git a/drivers/acpi/namespace/nsinit.c b/drivers/acpi/namespace/nsinit.c
--- a/drivers/acpi/namespace/nsinit.c
+++ b/drivers/acpi/namespace/nsinit.c
@@ -50,6 +50,22 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsinit")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+static acpi_status
+acpi_ns_init_one_device (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
 
 /*******************************************************************************
  *
@@ -191,7 +207,7 @@ acpi_ns_initialize_devices (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_init_one_object (
 	acpi_handle                     obj_handle,
 	u32                             level,
@@ -331,7 +347,7 @@ acpi_ns_init_one_object (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_init_one_device (
 	acpi_handle                     obj_handle,
 	u32                             nesting_level,
@@ -374,7 +390,8 @@ acpi_ns_init_one_device (
 	/*
 	 * Run _STA to determine if we can run _INI on the device.
 	 */
-	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, pinfo.node, "_STA"));
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD,
+			   pinfo.node, METHOD_NAME__STA));
 	status = acpi_ut_execute_STA (pinfo.node, &flags);
 
 	if (ACPI_FAILURE (status)) {
@@ -399,8 +416,9 @@ acpi_ns_init_one_device (
 	/*
 	 * The device is present. Run _INI.
 	 */
-	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, pinfo.node, "_INI"));
-	status = acpi_ns_evaluate_relative ("_INI", &pinfo);
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD,
+			   pinfo.node, METHOD_NAME__INI));
+	status = acpi_ns_evaluate_relative (METHOD_NAME__INI, &pinfo);
 	if (ACPI_FAILURE (status)) {
 		/* No _INI (AE_NOT_FOUND) means device requires no initialization */
 
diff --git a/drivers/acpi/namespace/nsload.c b/drivers/acpi/namespace/nsload.c
--- a/drivers/acpi/namespace/nsload.c
+++ b/drivers/acpi/namespace/nsload.c
@@ -50,9 +50,24 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsload")
 
+/* Local prototypes */
 
-#ifndef ACPI_NO_METHOD_EXECUTION
+static acpi_status
+acpi_ns_load_table_by_type (
+	acpi_table_type                 table_type);
+
+#ifdef ACPI_FUTURE_IMPLEMENTATION
+acpi_status
+acpi_ns_unload_namespace (
+	acpi_handle                     handle);
 
+static acpi_status
+acpi_ns_delete_subtree (
+	acpi_handle                     start_handle);
+#endif
+
+
+#ifndef ACPI_NO_METHOD_EXECUTION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_load_table
@@ -159,7 +174,7 @@ acpi_ns_load_table (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_load_table_by_type (
 	acpi_table_type                 table_type)
 {
@@ -183,7 +198,7 @@ acpi_ns_load_table_by_type (
 	switch (table_type) {
 	case ACPI_TABLE_DSDT:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading DSDT\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Namespace load: DSDT\n"));
 
 		table_desc = acpi_gbl_table_lists[ACPI_TABLE_DSDT].next;
 
@@ -203,17 +218,18 @@ acpi_ns_load_table_by_type (
 
 
 	case ACPI_TABLE_SSDT:
+	case ACPI_TABLE_PSDT:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading %d SSDTs\n",
-			acpi_gbl_table_lists[ACPI_TABLE_SSDT].count));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Namespace load: %d SSDT or PSDTs\n",
+			acpi_gbl_table_lists[table_type].count));
 
 		/*
-		 * Traverse list of SSDT tables
+		 * Traverse list of SSDT or PSDT tables
 		 */
-		table_desc = acpi_gbl_table_lists[ACPI_TABLE_SSDT].next;
-		for (i = 0; i < acpi_gbl_table_lists[ACPI_TABLE_SSDT].count; i++) {
+		table_desc = acpi_gbl_table_lists[table_type].next;
+		for (i = 0; i < acpi_gbl_table_lists[table_type].count; i++) {
 			/*
-			 * Only attempt to load table if it is not
+			 * Only attempt to load table into namespace if it is not
 			 * already loaded!
 			 */
 			if (!table_desc->loaded_into_namespace) {
@@ -230,33 +246,6 @@ acpi_ns_load_table_by_type (
 		break;
 
 
-	case ACPI_TABLE_PSDT:
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading %d PSDTs\n",
-			acpi_gbl_table_lists[ACPI_TABLE_PSDT].count));
-
-		/*
-		 * Traverse list of PSDT tables
-		 */
-		table_desc = acpi_gbl_table_lists[ACPI_TABLE_PSDT].next;
-
-		for (i = 0; i < acpi_gbl_table_lists[ACPI_TABLE_PSDT].count; i++) {
-			/* Only attempt to load table if it is not already loaded! */
-
-			if (!table_desc->loaded_into_namespace) {
-				status = acpi_ns_load_table (table_desc, acpi_gbl_root_node);
-				if (ACPI_FAILURE (status)) {
-					break;
-				}
-
-				table_desc->loaded_into_namespace = TRUE;
-			}
-
-			table_desc = table_desc->next;
-		}
-		break;
-
-
 	default:
 		status = AE_SUPPORT;
 		break;
@@ -321,8 +310,7 @@ acpi_ns_load_namespace (
 }
 
 
-#ifdef ACPI_FUTURE_USAGE
-
+#ifdef ACPI_FUTURE_IMPLEMENTATION
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_delete_subtree
@@ -339,7 +327,7 @@ acpi_ns_load_namespace (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ns_delete_subtree (
 	acpi_handle                     start_handle)
 {
@@ -453,8 +441,6 @@ acpi_ns_unload_namespace (
 
 	return_ACPI_STATUS (status);
 }
-
-#endif  /*  ACPI_FUTURE_USAGE  */
-
+#endif
 #endif
 
diff --git a/drivers/acpi/namespace/nsnames.c b/drivers/acpi/namespace/nsnames.c
--- a/drivers/acpi/namespace/nsnames.c
+++ b/drivers/acpi/namespace/nsnames.c
@@ -50,6 +50,14 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsnames")
 
+/* Local prototypes */
+
+static void
+acpi_ns_build_external_path (
+	struct acpi_namespace_node      *node,
+	acpi_size                       size,
+	char                            *name_buffer);
+
 
 /*******************************************************************************
  *
@@ -66,7 +74,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ns_build_external_path (
 	struct acpi_namespace_node      *node,
 	acpi_size                       size,
@@ -126,7 +134,7 @@ acpi_ns_build_external_path (
  *
  * FUNCTION:    acpi_ns_get_external_pathname
  *
- * PARAMETERS:  Node            - NS node whose pathname is needed
+ * PARAMETERS:  Node            - Namespace node whose pathname is needed
  *
  * RETURN:      Pointer to storage containing the fully qualified name of
  *              the node, In external format (name segments separated by path
diff --git a/drivers/acpi/namespace/nsobject.c b/drivers/acpi/namespace/nsobject.c
--- a/drivers/acpi/namespace/nsobject.c
+++ b/drivers/acpi/namespace/nsobject.c
@@ -60,6 +60,8 @@
  *              Type                - Type of object, or ACPI_TYPE_ANY if not
  *                                    known
  *
+ * RETURN:      Status
+ *
  * DESCRIPTION: Record the given object as the value associated with the
  *              name whose acpi_handle is passed.  If Object is NULL
  *              and Type is ACPI_TYPE_ANY, set the name as having no value.
@@ -97,7 +99,8 @@ acpi_ns_attach_object (
 	if (!object && (ACPI_TYPE_ANY != type)) {
 		/* Null object */
 
-		ACPI_REPORT_ERROR (("ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
+		ACPI_REPORT_ERROR ((
+			"ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
@@ -112,7 +115,8 @@ acpi_ns_attach_object (
 	/* Check if this object is already attached */
 
 	if (node->object == object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj %p already installed in name_obj %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Obj %p already installed in name_obj %p\n",
 			object, node));
 
 		return_ACPI_STATUS (AE_OK);
@@ -192,7 +196,7 @@ acpi_ns_attach_object (
  *
  * FUNCTION:    acpi_ns_detach_object
  *
- * PARAMETERS:  Node           - An node whose object will be detached
+ * PARAMETERS:  Node           - A Namespace node whose object will be detached
  *
  * RETURN:      None.
  *
@@ -248,7 +252,7 @@ acpi_ns_detach_object (
  *
  * FUNCTION:    acpi_ns_get_attached_object
  *
- * PARAMETERS:  Node             - Parent Node to be examined
+ * PARAMETERS:  Node             - Namespace node
  *
  * RETURN:      Current value of the object field from the Node whose
  *              handle is passed
@@ -284,7 +288,7 @@ acpi_ns_get_attached_object (
  *
  * FUNCTION:    acpi_ns_get_secondary_object
  *
- * PARAMETERS:  Node             - Parent Node to be examined
+ * PARAMETERS:  Node             - Namespace node
  *
  * RETURN:      Current value of the object field from the Node whose
  *              handle is passed.
diff --git a/drivers/acpi/namespace/nsparse.c b/drivers/acpi/namespace/nsparse.c
--- a/drivers/acpi/namespace/nsparse.c
+++ b/drivers/acpi/namespace/nsparse.c
@@ -67,7 +67,7 @@
 
 acpi_status
 acpi_ns_one_complete_parse (
-	u32                             pass_number,
+	u8                              pass_number,
 	struct acpi_table_desc          *table_desc)
 {
 	union acpi_parse_object         *parse_root;
@@ -87,7 +87,7 @@ acpi_ns_one_complete_parse (
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (table_desc->table_id,
+	walk_state = acpi_ds_create_walk_state (table_desc->owner_id,
 			   NULL, NULL, NULL);
 	if (!walk_state) {
 		acpi_ps_free_op (parse_root);
@@ -146,6 +146,7 @@ acpi_ns_parse_table (
 	 * to service the entire parse.  The second pass of the parse then
 	 * performs another complete parse of the AML..
 	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Start pass 1\n"));
 	status = acpi_ns_one_complete_parse (1, table_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -160,6 +161,7 @@ acpi_ns_parse_table (
 	 * overhead of this is compensated for by the fact that the
 	 * parse objects are all cached.
 	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Start pass 2\n"));
 	status = acpi_ns_one_complete_parse (2, table_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
diff --git a/drivers/acpi/namespace/nssearch.c b/drivers/acpi/namespace/nssearch.c
--- a/drivers/acpi/namespace/nssearch.c
+++ b/drivers/acpi/namespace/nssearch.c
@@ -49,15 +49,24 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nssearch")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ns_search_parent_tree (
+	u32                             target_name,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_namespace_node      **return_node);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ns_search_node
  *
- * PARAMETERS:  *target_name        - Ascii ACPI name to search for
- *              *Node               - Starting node where search will begin
- *              Type                - Object type to match
- *              **return_node       - Where the matched Named obj is returned
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              Node            - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Named obj is returned
  *
  * RETURN:      Status
  *
@@ -163,10 +172,10 @@ acpi_ns_search_node (
  *
  * FUNCTION:    acpi_ns_search_parent_tree
  *
- * PARAMETERS:  *target_name        - Ascii ACPI name to search for
- *              *Node               - Starting node where search will begin
- *              Type                - Object type to match
- *              **return_node       - Where the matched Node is returned
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              Node            - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Node is returned
  *
  * RETURN:      Status
  *
@@ -257,12 +266,12 @@ acpi_ns_search_parent_tree (
  *
  * PARAMETERS:  target_name         - Ascii ACPI name to search for (4 chars)
  *              walk_state          - Current state of the walk
- *              *Node               - Starting node where search will begin
+ *              Node                - Starting node where search will begin
  *              interpreter_mode    - Add names only in ACPI_MODE_LOAD_PASS_x.
  *                                    Otherwise,search only.
  *              Type                - Object type to match
  *              Flags               - Flags describing the search restrictions
- *              **return_node       - Where the Node is returned
+ *              return_node         - Where the Node is returned
  *
  * RETURN:      Status
  *
diff --git a/drivers/acpi/namespace/nsutils.c b/drivers/acpi/namespace/nsutils.c
--- a/drivers/acpi/namespace/nsutils.c
+++ b/drivers/acpi/namespace/nsutils.c
@@ -51,6 +51,18 @@
 #define _COMPONENT          ACPI_NAMESPACE
 	 ACPI_MODULE_NAME    ("nsutils")
 
+/* Local prototypes */
+
+static u8
+acpi_ns_valid_path_separator (
+	char                            sep);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_name
+acpi_ns_find_parent_name (
+	struct acpi_namespace_node      *node_to_search);
+#endif
+
 
 /*******************************************************************************
  *
@@ -59,7 +71,8 @@
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
+ *              internal_name       - Name or path of the namespace node
+ *              lookup_status       - Exception code from NS lookup
  *
  * RETURN:      None
  *
@@ -121,6 +134,9 @@ acpi_ns_report_error (
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
  *              Message             - Error message to use on failure
+ *              prefix_node         - Prefix relative to the path
+ *              Path                - Path to the node
+ *              method_status       - Execution status
  *
  * RETURN:      None
  *
@@ -161,8 +177,8 @@ acpi_ns_report_method_error (
  *
  * FUNCTION:    acpi_ns_print_node_pathname
  *
- * PARAMETERS:  Node                - Object
- *              Msg                 - Prefix message
+ * PARAMETERS:  Node            - Object
+ *              Message         - Prefix message
  *
  * DESCRIPTION: Print an object's full namespace pathname
  *              Manages allocation/freeing of a pathname buffer
@@ -172,7 +188,7 @@ acpi_ns_report_method_error (
 void
 acpi_ns_print_node_pathname (
 	struct acpi_namespace_node      *node,
-	char                            *msg)
+	char                            *message)
 {
 	struct acpi_buffer              buffer;
 	acpi_status                     status;
@@ -189,8 +205,8 @@ acpi_ns_print_node_pathname (
 
 	status = acpi_ns_handle_to_pathname (node, &buffer);
 	if (ACPI_SUCCESS (status)) {
-		if (msg) {
-			acpi_os_printf ("%s ", msg);
+		if (message) {
+			acpi_os_printf ("%s ", message);
 		}
 
 		acpi_os_printf ("[%s] (Node %p)", (char *) buffer.pointer, node);
@@ -224,7 +240,7 @@ acpi_ns_valid_root_prefix (
  *
  * FUNCTION:    acpi_ns_valid_path_separator
  *
- * PARAMETERS:  Sep              - Character to be checked
+ * PARAMETERS:  Sep         - Character to be checked
  *
  * RETURN:      TRUE if a valid path separator
  *
@@ -232,7 +248,7 @@ acpi_ns_valid_root_prefix (
  *
  ******************************************************************************/
 
-u8
+static u8
 acpi_ns_valid_path_separator (
 	char                            sep)
 {
@@ -245,10 +261,12 @@ acpi_ns_valid_path_separator (
  *
  * FUNCTION:    acpi_ns_get_type
  *
- * PARAMETERS:  Handle              - Parent Node to be examined
+ * PARAMETERS:  Node        - Parent Node to be examined
  *
  * RETURN:      Type field from Node whose handle is passed
  *
+ * DESCRIPTION: Return the type of a Namespace node
+ *
  ******************************************************************************/
 
 acpi_object_type
@@ -271,11 +289,13 @@ acpi_ns_get_type (
  *
  * FUNCTION:    acpi_ns_local
  *
- * PARAMETERS:  Type            - A namespace object type
+ * PARAMETERS:  Type        - A namespace object type
  *
  * RETURN:      LOCAL if names must be found locally in objects of the
  *              passed type, 0 if enclosing scopes should be searched
  *
+ * DESCRIPTION: Returns scope rule for the given object type.
+ *
  ******************************************************************************/
 
 u32
@@ -303,7 +323,7 @@ acpi_ns_local (
  * PARAMETERS:  Info            - Info struct initialized with the
  *                                external name pointer.
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Calculate the length of the internal (AML) namestring
  *              corresponding to the external (ASL) namestring.
@@ -551,14 +571,16 @@ acpi_ns_internalize_name (
  *
  * FUNCTION:    acpi_ns_externalize_name
  *
- * PARAMETERS:  *internal_name         - Internal representation of name
- *              **converted_name       - Where to return the resulting
- *                                       external representation of name
+ * PARAMETERS:  internal_name_length - Lenth of the internal name below
+ *              internal_name       - Internal representation of name
+ *              converted_name_length - Where the length is returned
+ *              converted_name      - Where the resulting external name
+ *                                    is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)
- *              to its external form (e.g. "\_PR_.CPU0")
+ *              to its external (printable) form (e.g. "\_PR_.CPU0")
  *
  ******************************************************************************/
 
@@ -717,8 +739,9 @@ acpi_ns_externalize_name (
  *
  * DESCRIPTION: Convert a namespace handle to a real Node
  *
- * Note: Real integer handles allow for more verification
- *       and keep all pointers within this subsystem.
+ * Note: Real integer handles would allow for more verification
+ *       and keep all pointers within this subsystem - however this introduces
+ *       more (and perhaps unnecessary) overhead.
  *
  ******************************************************************************/
 
@@ -775,7 +798,7 @@ acpi_ns_convert_entry_to_handle (
 	return ((acpi_handle) node);
 
 
-/* ---------------------------------------------------
+/* Example future implementation ---------------------
 
 	if (!Node)
 	{
@@ -801,12 +824,13 @@ acpi_ns_convert_entry_to_handle (
  *
  * RETURN:      none
  *
- * DESCRIPTION: free memory allocated for table storage.
+ * DESCRIPTION: free memory allocated for namespace and ACPI table storage.
  *
  ******************************************************************************/
 
 void
-acpi_ns_terminate (void)
+acpi_ns_terminate (
+	void)
 {
 	union acpi_operand_object       *obj_desc;
 
@@ -940,7 +964,6 @@ acpi_ns_get_node_by_path (
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
 cleanup:
-	/* Cleanup */
 	if (internal_path) {
 		ACPI_MEM_FREE (internal_path);
 	}
@@ -950,55 +973,6 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ns_find_parent_name
- *
- * PARAMETERS:  *child_node            - Named Obj whose name is to be found
- *
- * RETURN:      The ACPI name
- *
- * DESCRIPTION: Search for the given obj in its parent scope and return the
- *              name segment, or "????" if the parent name can't be found
- *              (which "should not happen").
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_name
-acpi_ns_find_parent_name (
-	struct acpi_namespace_node      *child_node)
-{
-	struct acpi_namespace_node      *parent_node;
-
-
-	ACPI_FUNCTION_TRACE ("ns_find_parent_name");
-
-
-	if (child_node) {
-		/* Valid entry.  Get the parent Node */
-
-		parent_node = acpi_ns_get_parent_node (child_node);
-		if (parent_node) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-				"Parent of %p [%4.4s] is %p [%4.4s]\n",
-				child_node, acpi_ut_get_node_name (child_node),
-				parent_node, acpi_ut_get_node_name (parent_node)));
-
-			if (parent_node->name.integer) {
-				return_VALUE ((acpi_name) parent_node->name.integer);
-			}
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Unable to find parent of %p (%4.4s)\n",
-			child_node, acpi_ut_get_node_name (child_node)));
-	}
-
-	return_VALUE (ACPI_UNKNOWN_NAME);
-}
-#endif
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ns_get_parent_node
  *
  * PARAMETERS:  Node       - Current table entry
@@ -1009,7 +983,6 @@ acpi_ns_find_parent_name (
  *
  ******************************************************************************/
 
-
 struct acpi_namespace_node *
 acpi_ns_get_parent_node (
 	struct acpi_namespace_node      *node)
@@ -1030,7 +1003,6 @@ acpi_ns_get_parent_node (
 		node = node->peer;
 	}
 
-
 	return (node->peer);
 }
 
@@ -1049,7 +1021,6 @@ acpi_ns_get_parent_node (
  *
  ******************************************************************************/
 
-
 struct acpi_namespace_node *
 acpi_ns_get_next_valid_node (
 	struct acpi_namespace_node      *node)
@@ -1067,3 +1038,53 @@ acpi_ns_get_next_valid_node (
 }
 
 
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_find_parent_name
+ *
+ * PARAMETERS:  *child_node            - Named Obj whose name is to be found
+ *
+ * RETURN:      The ACPI name
+ *
+ * DESCRIPTION: Search for the given obj in its parent scope and return the
+ *              name segment, or "????" if the parent name can't be found
+ *              (which "should not happen").
+ *
+ ******************************************************************************/
+
+acpi_name
+acpi_ns_find_parent_name (
+	struct acpi_namespace_node      *child_node)
+{
+	struct acpi_namespace_node      *parent_node;
+
+
+	ACPI_FUNCTION_TRACE ("ns_find_parent_name");
+
+
+	if (child_node) {
+		/* Valid entry.  Get the parent Node */
+
+		parent_node = acpi_ns_get_parent_node (child_node);
+		if (parent_node) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Parent of %p [%4.4s] is %p [%4.4s]\n",
+				child_node, acpi_ut_get_node_name (child_node),
+				parent_node, acpi_ut_get_node_name (parent_node)));
+
+			if (parent_node->name.integer) {
+				return_VALUE ((acpi_name) parent_node->name.integer);
+			}
+		}
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Unable to find parent of %p (%4.4s)\n",
+			child_node, acpi_ut_get_node_name (child_node)));
+	}
+
+	return_VALUE (ACPI_UNKNOWN_NAME);
+}
+#endif
+
+
diff --git a/drivers/acpi/namespace/nswalk.c b/drivers/acpi/namespace/nswalk.c
--- a/drivers/acpi/namespace/nswalk.c
+++ b/drivers/acpi/namespace/nswalk.c
@@ -56,7 +56,7 @@
  *
  * PARAMETERS:  Type                - Type of node to be searched for
  *              parent_node         - Parent node whose children we are
- *                                     getting
+ *                                    getting
  *              child_node          - Previous child that was found.
  *                                    The NEXT child will be returned
  *
diff --git a/drivers/acpi/namespace/nsxfeval.c b/drivers/acpi/namespace/nsxfeval.c
--- a/drivers/acpi/namespace/nsxfeval.c
+++ b/drivers/acpi/namespace/nsxfeval.c
@@ -58,11 +58,11 @@
  * FUNCTION:    acpi_evaluate_object_typed
  *
  * PARAMETERS:  Handle              - Object handle (optional)
- *              *Pathname           - Object pathname (optional)
- *              **external_params   - List of parameters to pass to method,
+ *              Pathname            - Object pathname (optional)
+ *              external_params     - List of parameters to pass to method,
  *                                    terminated by NULL.  May be NULL
  *                                    if no parameters are being passed.
- *              *return_buffer      - Where to put method's return value (if
+ *              return_buffer       - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *              return_type         - Expected type of return object
  *
@@ -73,6 +73,7 @@
  *              be valid (non-null)
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_evaluate_object_typed (
@@ -307,7 +308,8 @@ acpi_evaluate_object (
 				if (ACPI_SUCCESS (status)) {
 					/* Validate/Allocate/Clear caller buffer */
 
-					status = acpi_ut_initialize_buffer (return_buffer, buffer_space_needed);
+					status = acpi_ut_initialize_buffer (return_buffer,
+							  buffer_space_needed);
 					if (ACPI_FAILURE (status)) {
 						/*
 						 * Caller's buffer is too small or a new one can't be allocated
@@ -423,7 +425,8 @@ acpi_walk_namespace (
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_ns_walk_namespace (type, start_object, max_depth, ACPI_NS_WALK_UNLOCK,
+	status = acpi_ns_walk_namespace (type, start_object, max_depth,
+			  ACPI_NS_WALK_UNLOCK,
 			  user_function, context, return_value);
 
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
@@ -525,7 +528,8 @@ acpi_ns_get_device_callback (
 		}
 	}
 
-	status = info->user_function (obj_handle, nesting_level, info->context, return_value);
+	status = info->user_function (obj_handle, nesting_level, info->context,
+			 return_value);
 	return (status);
 }
 
diff --git a/drivers/acpi/namespace/nsxfname.c b/drivers/acpi/namespace/nsxfname.c
--- a/drivers/acpi/namespace/nsxfname.c
+++ b/drivers/acpi/namespace/nsxfname.c
@@ -57,9 +57,9 @@
  * FUNCTION:    acpi_get_handle
  *
  * PARAMETERS:  Parent          - Object to search under (search scope).
- *              path_name       - Pointer to an asciiz string containing the
- *                                  name
- *              ret_handle      - Where the return handle is placed
+ *              Pathname        - Pointer to an asciiz string containing the
+ *                                name
+ *              ret_handle      - Where the return handle is returned
  *
  * RETURN:      Status
  *
@@ -220,7 +220,7 @@ EXPORT_SYMBOL(acpi_get_name);
  * FUNCTION:    acpi_get_object_info
  *
  * PARAMETERS:  Handle          - Object Handle
- *              Info            - Where the info is returned
+ *              Buffer          - Where the info is returned
  *
  * RETURN:      Status
  *
diff --git a/drivers/acpi/namespace/nsxfobj.c b/drivers/acpi/namespace/nsxfobj.c
--- a/drivers/acpi/namespace/nsxfobj.c
+++ b/drivers/acpi/namespace/nsxfobj.c
@@ -56,7 +56,7 @@
  * FUNCTION:    acpi_get_type
  *
  * PARAMETERS:  Handle          - Handle of object whose type is desired
- *              *ret_type       - Where the type will be placed
+ *              ret_type        - Where the type will be placed
  *
  * RETURN:      Status
  *
@@ -258,5 +258,5 @@ unlock_and_exit:
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return (status);
 }
-EXPORT_SYMBOL(acpi_get_next_object);
 
+EXPORT_SYMBOL(acpi_get_next_object);
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -71,6 +71,9 @@ EXPORT_SYMBOL(acpi_in_debugger);
 extern char line_buf[80];
 #endif /*ENABLE_DEBUGGER*/
 
+int acpi_specific_hotkey_enabled;
+EXPORT_SYMBOL(acpi_specific_hotkey_enabled);
+
 static unsigned int acpi_irq_irq;
 static acpi_osd_handler acpi_irq_handler;
 static void *acpi_irq_context;
@@ -775,54 +778,6 @@ acpi_os_delete_lock (
 	return_VOID;
 }
 
-/*
- * Acquire a spinlock.
- *
- * handle is a pointer to the spinlock_t.
- * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
- *   that indicates whether we are at interrupt level.
- */
-void
-acpi_os_acquire_lock (
-	acpi_handle	handle,
-	u32		flags)
-{
-	ACPI_FUNCTION_TRACE ("os_acquire_lock");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquiring spinlock[%p] from %s level\n", handle,
-		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
-
-	if (flags & ACPI_NOT_ISR)
-		ACPI_DISABLE_IRQS();
-
-	spin_lock((spinlock_t *)handle);
-
-	return_VOID;
-}
-
-
-/*
- * Release a spinlock. See above.
- */
-void
-acpi_os_release_lock (
-	acpi_handle	handle,
-	u32		flags)
-{
-	ACPI_FUNCTION_TRACE ("os_release_lock");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Releasing spinlock[%p] from %s level\n", handle,
-		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
-
-	spin_unlock((spinlock_t *)handle);
-
-	if (flags & ACPI_NOT_ISR)
-		ACPI_ENABLE_IRQS();
-
-	return_VOID;
-}
-
-
 acpi_status
 acpi_os_create_semaphore(
 	u32		max_units,
@@ -1152,6 +1107,15 @@ acpi_wake_gpes_always_on_setup(char *str
 
 __setup("acpi_wake_gpes_always_on", acpi_wake_gpes_always_on_setup);
 
+int __init
+acpi_hotkey_setup(char *str)
+{
+	acpi_specific_hotkey_enabled = TRUE;
+	return 1;
+}
+
+__setup("acpi_specific_hotkey", acpi_hotkey_setup);
+
 /*
  * max_cstate is defined in the base kernel so modules can
  * change it w/o depending on the state of the processor module.
@@ -1160,3 +1124,151 @@ unsigned int max_cstate = ACPI_PROCESSOR
 
 
 EXPORT_SYMBOL(max_cstate);
+
+/*
+ * Acquire a spinlock.
+ *
+ * handle is a pointer to the spinlock_t.
+ * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
+ *   that indicates whether we are at interrupt level.
+ */
+
+unsigned long
+acpi_os_acquire_lock (
+	acpi_handle	handle)
+{
+	unsigned long flags;
+	spin_lock_irqsave((spinlock_t *)handle, flags);
+	return flags;
+}
+
+/*
+ * Release a spinlock. See above.
+ */
+
+void
+acpi_os_release_lock (
+	acpi_handle	handle,
+	unsigned long	flags)
+{
+	spin_unlock_irqrestore((spinlock_t *)handle, flags);
+}
+
+
+#ifndef ACPI_USE_LOCAL_CACHE
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_create_cache
+ *
+ * PARAMETERS:  CacheName       - Ascii name for the cache
+ *              ObjectSize      - Size of each cached object
+ *              MaxDepth        - Maximum depth of the cache (in objects)
+ *              ReturnCache     - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a cache object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_create_cache (
+    char                    *name,
+    u16                  size,
+    u16                  depth,
+    acpi_cache_t 	    **cache)
+{
+	*cache = kmem_cache_create (name, size, 0, 0, NULL, NULL);
+	return AE_OK;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_purge_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_purge_cache (
+    acpi_cache_t        *cache)
+{
+    (void) kmem_cache_shrink(cache);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_delete_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache and delete the
+ *              cache object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_delete_cache (
+    acpi_cache_t *cache)
+{
+    (void)kmem_cache_destroy(cache);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_release_object
+ *
+ * PARAMETERS:  Cache       - Handle to cache object
+ *              Object      - The object to be released
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release an object to the specified cache.  If cache is full,
+ *              the object is deleted.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_release_object (
+    acpi_cache_t *cache,
+    void *object)
+{
+    kmem_cache_free(cache, object);
+    return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_acquire_object
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *              ReturnObject    - Where the object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
+ *              the object is allocated.
+ *
+ ******************************************************************************/
+
+void *
+acpi_os_acquire_object (
+    acpi_cache_t *cache)
+{
+    void *object = kmem_cache_alloc(cache, GFP_KERNEL);
+    WARN_ON(!object);
+    return object;
+}
+
+#endif
+
diff --git a/drivers/acpi/parser/Makefile b/drivers/acpi/parser/Makefile
--- a/drivers/acpi/parser/Makefile
+++ b/drivers/acpi/parser/Makefile
@@ -2,7 +2,7 @@
 # Makefile for all Linux ACPI interpreter subdirectories
 #
 
-obj-y := psargs.o    psparse.o  pstree.o   pswalk.o  \
+obj-y := psargs.o    psparse.o  psloop.o pstree.o   pswalk.o  \
 	 psopcode.o  psscope.o  psutils.o  psxface.o
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
diff --git a/drivers/acpi/parser/psargs.c b/drivers/acpi/parser/psargs.c
--- a/drivers/acpi/parser/psargs.c
+++ b/drivers/acpi/parser/psargs.c
@@ -50,6 +50,16 @@
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psargs")
 
+/* Local prototypes */
+
+static u32
+acpi_ps_get_next_package_length (
+	struct acpi_parse_state         *parser_state);
+
+static union acpi_parse_object *
+acpi_ps_get_next_field (
+	struct acpi_parse_state         *parser_state);
+
 
 /*******************************************************************************
  *
@@ -64,7 +74,7 @@
  *
  ******************************************************************************/
 
-u32
+static u32
 acpi_ps_get_next_package_length (
 	struct acpi_parse_state         *parser_state)
 {
@@ -78,7 +88,6 @@ acpi_ps_get_next_package_length (
 	encoded_length = (u32) ACPI_GET8 (parser_state->aml);
 	parser_state->aml++;
 
-
 	switch (encoded_length >> 6) /* bits 6-7 contain encoding scheme */ {
 	case 0: /* 1-byte encoding (bits 0-5) */
 
@@ -287,13 +296,14 @@ acpi_ps_get_next_namepath (
 		 * parent tree, but don't open a new scope -- we just want to lookup the
 		 * object  (MUST BE mode EXECUTE to perform upsearch)
 		 */
-		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &node);
+		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY,
+				 ACPI_IMODE_EXECUTE,
+				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+				 NULL, &node);
 		if (ACPI_SUCCESS (status) && method_call) {
 			if (node->type == ACPI_TYPE_METHOD) {
-				/*
-				 * This name is actually a control method invocation
-				 */
+				/* This name is actually a control method invocation */
+
 				method_desc = acpi_ns_get_attached_object (node);
 				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 					"Control Method - %p Desc %p Path=%p\n",
@@ -360,7 +370,7 @@ acpi_ps_get_next_namepath (
 				/*
 				 * We got a NOT_FOUND during table load or we encountered
 				 * a cond_ref_of(x) where the target does not exist.
-				 * -- either case is ok
+				 * Either case is ok
 				 */
 				status = AE_OK;
 			}
@@ -486,12 +496,13 @@ acpi_ps_get_next_simple_arg (
  *
  ******************************************************************************/
 
-union acpi_parse_object *
+static union acpi_parse_object *
 acpi_ps_get_next_field (
 	struct acpi_parse_state         *parser_state)
 {
-	u32                             aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-			 parser_state->aml_start);
+	u32                             aml_offset = (u32)
+			  ACPI_PTR_DIFF (parser_state->aml,
+					   parser_state->aml_start);
 	union acpi_parse_object         *field;
 	u16                             opcode;
 	u32                             name;
@@ -500,7 +511,7 @@ acpi_ps_get_next_field (
 	ACPI_FUNCTION_TRACE ("ps_get_next_field");
 
 
-	/* determine field type */
+	/* Determine field type */
 
 	switch (ACPI_GET8 (parser_state->aml)) {
 	default:
@@ -521,7 +532,6 @@ acpi_ps_get_next_field (
 		break;
 	}
 
-
 	/* Allocate a new field op */
 
 	field = acpi_ps_alloc_op (opcode);
@@ -582,10 +592,10 @@ acpi_ps_get_next_field (
  *
  * FUNCTION:    acpi_ps_get_next_arg
  *
- * PARAMETERS:  parser_state        - Current parser state object
+ * PARAMETERS:  walk_state          - Current state
+ *              parser_state        - Current parser state object
  *              arg_type            - The argument type (AML_*_ARG)
- *              arg_count           - If the argument points to a control method
- *                                    the method's argument is returned here.
+ *              return_arg          - Where the next arg is returned
  *
  * RETURN:      Status, and an op object containing the next argument.
  *
@@ -619,7 +629,7 @@ acpi_ps_get_next_arg (
 	case ARGP_NAME:
 	case ARGP_NAMESTRING:
 
-		/* constants, strings, and namestrings are all the same size */
+		/* Constants, strings, and namestrings are all the same size */
 
 		arg = acpi_ps_alloc_op (AML_BYTE_OP);
 		if (!arg) {
@@ -654,7 +664,6 @@ acpi_ps_get_next_arg (
 				else {
 					arg = field;
 				}
-
 				prev = field;
 			}
 
@@ -677,8 +686,8 @@ acpi_ps_get_next_arg (
 
 			/* Fill in bytelist data */
 
-			arg->common.value.size = (u32) ACPI_PTR_DIFF (parser_state->pkg_end,
-					  parser_state->aml);
+			arg->common.value.size = (u32)
+				ACPI_PTR_DIFF (parser_state->pkg_end, parser_state->aml);
 			arg->named.data = parser_state->aml;
 
 			/* Skip to End of byte data */
@@ -706,7 +715,7 @@ acpi_ps_get_next_arg (
 			status = acpi_ps_get_next_namepath (walk_state, parser_state, arg, 0);
 		}
 		else {
-			/* single complex argument, nothing returned */
+			/* Single complex argument, nothing returned */
 
 			walk_state->arg_count = 1;
 		}
@@ -716,7 +725,7 @@ acpi_ps_get_next_arg (
 	case ARGP_DATAOBJ:
 	case ARGP_TERMARG:
 
-		/* single complex argument, nothing returned */
+		/* Single complex argument, nothing returned */
 
 		walk_state->arg_count = 1;
 		break;
@@ -727,7 +736,7 @@ acpi_ps_get_next_arg (
 	case ARGP_OBJLIST:
 
 		if (parser_state->aml < parser_state->pkg_end) {
-			/* non-empty list of variable arguments, nothing returned */
+			/* Non-empty list of variable arguments, nothing returned */
 
 			walk_state->arg_count = ACPI_VAR_ARGS;
 		}
diff --git a/drivers/acpi/parser/psloop.c b/drivers/acpi/parser/psloop.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/parser/psloop.c
@@ -0,0 +1,781 @@
+/******************************************************************************
+ *
+ * Module Name: psloop - Main AML parse loop
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+/*
+ * Parse the AML and build an operation tree as most interpreters,
+ * like Perl, do.  Parsing is done by hand rather than with a YACC
+ * generated parser to tightly constrain stack and dynamic memory
+ * usage.  At the same time, parsing is kept flexible and the code
+ * fairly compact by parsing based on a list of AML opcode
+ * templates in aml_op_info[]
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/amlcode.h>
+
+#define _COMPONENT          ACPI_PARSER
+	 ACPI_MODULE_NAME    ("psloop")
+
+static u32                          acpi_gbl_depth = 0;
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_parse_loop
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse AML (pointed to by the current parser state) and return
+ *              a tree of ops.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_parse_loop (
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status = AE_OK;
+	acpi_status                     status2;
+	union acpi_parse_object         *op = NULL;     /* current op */
+	union acpi_parse_object         *arg = NULL;
+	union acpi_parse_object         *pre_op = NULL;
+	struct acpi_parse_state         *parser_state;
+	u8                              *aml_op_start = NULL;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ps_parse_loop", walk_state);
+
+	if (walk_state->descending_callback == NULL) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	parser_state = &walk_state->parser_state;
+	walk_state->arg_types = 0;
+
+#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
+
+	if (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {
+		/* We are restarting a preempted control method */
+
+		if (acpi_ps_has_completed_scope (parser_state)) {
+			/*
+			 * We must check if a predicate to an IF or WHILE statement
+			 * was just completed
+			 */
+			if ((parser_state->scope->parse_scope.op) &&
+			   ((parser_state->scope->parse_scope.op->common.aml_opcode == AML_IF_OP) ||
+				(parser_state->scope->parse_scope.op->common.aml_opcode == AML_WHILE_OP)) &&
+				(walk_state->control_state) &&
+				(walk_state->control_state->common.state ==
+					ACPI_CONTROL_PREDICATE_EXECUTING)) {
+				/*
+				 * A predicate was just completed, get the value of the
+				 * predicate and branch based on that value
+				 */
+				walk_state->op = NULL;
+				status = acpi_ds_get_predicate_value (walk_state, ACPI_TO_POINTER (TRUE));
+				if (ACPI_FAILURE (status) &&
+					((status & AE_CODE_MASK) != AE_CODE_CONTROL)) {
+					if (status == AE_AML_NO_RETURN_VALUE) {
+						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+							"Invoked method did not return a value, %s\n",
+							acpi_format_exception (status)));
+
+					}
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"get_predicate Failed, %s\n",
+						acpi_format_exception (status)));
+					return_ACPI_STATUS (status);
+				}
+
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+			}
+
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
+			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
+		}
+		else if (walk_state->prev_op) {
+			/* We were in the middle of an op */
+
+			op = walk_state->prev_op;
+			walk_state->arg_types = walk_state->prev_arg_types;
+		}
+	}
+#endif
+
+	/* Iterative parsing loop, while there is more AML to process: */
+
+	while ((parser_state->aml < parser_state->aml_end) || (op)) {
+		aml_op_start = parser_state->aml;
+		if (!op) {
+			/* Get the next opcode from the AML stream */
+
+			walk_state->aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
+					  parser_state->aml_start);
+			walk_state->opcode   = acpi_ps_peek_opcode (parser_state);
+
+			/*
+			 * First cut to determine what we have found:
+			 * 1) A valid AML opcode
+			 * 2) A name string
+			 * 3) An unknown/invalid opcode
+			 */
+			walk_state->op_info = acpi_ps_get_opcode_info (walk_state->opcode);
+			switch (walk_state->op_info->class) {
+			case AML_CLASS_ASCII:
+			case AML_CLASS_PREFIX:
+				/*
+				 * Starts with a valid prefix or ASCII char, this is a name
+				 * string.  Convert the bare name string to a namepath.
+				 */
+				walk_state->opcode = AML_INT_NAMEPATH_OP;
+				walk_state->arg_types = ARGP_NAMESTRING;
+				break;
+
+			case AML_CLASS_UNKNOWN:
+
+				/* The opcode is unrecognized.  Just skip unknown opcodes */
+
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Found unknown opcode %X at AML address %p offset %X, ignoring\n",
+					walk_state->opcode, parser_state->aml, walk_state->aml_offset));
+
+				ACPI_DUMP_BUFFER (parser_state->aml, 128);
+
+				/* Assume one-byte bad opcode */
+
+				parser_state->aml++;
+				continue;
+
+			default:
+
+				/* Found opcode info, this is a normal opcode */
+
+				parser_state->aml += acpi_ps_get_opcode_size (walk_state->opcode);
+				walk_state->arg_types = walk_state->op_info->parse_args;
+				break;
+			}
+
+			/* Create Op structure and append to parent's argument list */
+
+			if (walk_state->op_info->flags & AML_NAMED) {
+				/* Allocate a new pre_op if necessary */
+
+				if (!pre_op) {
+					pre_op = acpi_ps_alloc_op (walk_state->opcode);
+					if (!pre_op) {
+						status = AE_NO_MEMORY;
+						goto close_this_op;
+					}
+				}
+
+				pre_op->common.value.arg = NULL;
+				pre_op->common.aml_opcode = walk_state->opcode;
+
+				/*
+				 * Get and append arguments until we find the node that contains
+				 * the name (the type ARGP_NAME).
+				 */
+				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
+					  (GET_CURRENT_ARG_TYPE (walk_state->arg_types) != ARGP_NAME)) {
+					status = acpi_ps_get_next_arg (walk_state, parser_state,
+							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
+					if (ACPI_FAILURE (status)) {
+						goto close_this_op;
+					}
+
+					acpi_ps_append_arg (pre_op, arg);
+					INCREMENT_ARG_LIST (walk_state->arg_types);
+				}
+
+				/*
+				 * Make sure that we found a NAME and didn't run out of
+				 * arguments
+				 */
+				if (!GET_CURRENT_ARG_TYPE (walk_state->arg_types)) {
+					status = AE_AML_NO_OPERAND;
+					goto close_this_op;
+				}
+
+				/* We know that this arg is a name, move to next arg */
+
+				INCREMENT_ARG_LIST (walk_state->arg_types);
+
+				/*
+				 * Find the object.  This will either insert the object into
+				 * the namespace or simply look it up
+				 */
+				walk_state->op = NULL;
+
+				status = walk_state->descending_callback (walk_state, &op);
+				if (ACPI_FAILURE (status)) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"During name lookup/catalog, %s\n",
+						acpi_format_exception (status)));
+					goto close_this_op;
+				}
+
+				if (!op) {
+					continue;
+				}
+
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+				if (status == AE_CTRL_PENDING) {
+					status = AE_OK;
+					goto close_this_op;
+				}
+
+				if (ACPI_FAILURE (status)) {
+					goto close_this_op;
+				}
+
+				acpi_ps_append_arg (op, pre_op->common.value.arg);
+				acpi_gbl_depth++;
+
+				if (op->common.aml_opcode == AML_REGION_OP) {
+					/*
+					 * Defer final parsing of an operation_region body,
+					 * because we don't have enough info in the first pass
+					 * to parse it correctly (i.e., there may be method
+					 * calls within the term_arg elements of the body.)
+					 *
+					 * However, we must continue parsing because
+					 * the opregion is not a standalone package --
+					 * we don't know where the end is at this point.
+					 *
+					 * (Length is unknown until parse of the body complete)
+					 */
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
+				}
+			}
+			else {
+				/* Not a named opcode, just allocate Op and append to parent */
+
+				walk_state->op_info = acpi_ps_get_opcode_info (walk_state->opcode);
+				op = acpi_ps_alloc_op (walk_state->opcode);
+				if (!op) {
+					status = AE_NO_MEMORY;
+					goto close_this_op;
+				}
+
+				if (walk_state->op_info->flags & AML_CREATE) {
+					/*
+					 * Backup to beginning of create_xXXfield declaration
+					 * body_length is unknown until we parse the body
+					 */
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
+				}
+
+				acpi_ps_append_arg (acpi_ps_get_parent_scope (parser_state), op);
+
+				if ((walk_state->descending_callback != NULL)) {
+					/*
+					 * Find the object. This will either insert the object into
+					 * the namespace or simply look it up
+					 */
+					walk_state->op = op;
+
+					status = walk_state->descending_callback (walk_state, &op);
+					status = acpi_ps_next_parse_state (walk_state, op, status);
+					if (status == AE_CTRL_PENDING) {
+						status = AE_OK;
+						goto close_this_op;
+					}
+
+					if (ACPI_FAILURE (status)) {
+						goto close_this_op;
+					}
+				}
+			}
+
+			op->common.aml_offset = walk_state->aml_offset;
+
+			if (walk_state->op_info) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+					"Opcode %4.4X [%s] Op %p Aml %p aml_offset %5.5X\n",
+					 (u32) op->common.aml_opcode, walk_state->op_info->name,
+					 op, parser_state->aml, op->common.aml_offset));
+			}
+		}
+
+
+		/*
+		 * Start arg_count at zero because we don't know if there are
+		 * any args yet
+		 */
+		walk_state->arg_count = 0;
+
+		/* Are there any arguments that must be processed? */
+
+		if (walk_state->arg_types) {
+			/* Get arguments */
+
+			switch (op->common.aml_opcode) {
+			case AML_BYTE_OP:       /* AML_BYTEDATA_ARG */
+			case AML_WORD_OP:       /* AML_WORDDATA_ARG */
+			case AML_DWORD_OP:      /* AML_DWORDATA_ARG */
+			case AML_QWORD_OP:      /* AML_QWORDATA_ARG */
+			case AML_STRING_OP:     /* AML_ASCIICHARLIST_ARG */
+
+				/* Fill in constant or string argument directly */
+
+				acpi_ps_get_next_simple_arg (parser_state,
+					GET_CURRENT_ARG_TYPE (walk_state->arg_types), op);
+				break;
+
+			case AML_INT_NAMEPATH_OP:   /* AML_NAMESTRING_ARG */
+
+				status = acpi_ps_get_next_namepath (walk_state, parser_state, op, 1);
+				if (ACPI_FAILURE (status)) {
+					goto close_this_op;
+				}
+
+				walk_state->arg_types = 0;
+				break;
+
+			default:
+				/*
+				 * Op is not a constant or string, append each argument
+				 * to the Op
+				 */
+				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
+						!walk_state->arg_count) {
+					walk_state->aml_offset = (u32)
+						ACPI_PTR_DIFF (parser_state->aml, parser_state->aml_start);
+
+					status = acpi_ps_get_next_arg (walk_state, parser_state,
+							 GET_CURRENT_ARG_TYPE (walk_state->arg_types),
+							 &arg);
+					if (ACPI_FAILURE (status)) {
+						goto close_this_op;
+					}
+
+					if (arg) {
+						arg->common.aml_offset = walk_state->aml_offset;
+						acpi_ps_append_arg (op, arg);
+					}
+					INCREMENT_ARG_LIST (walk_state->arg_types);
+				}
+
+
+				/* Special processing for certain opcodes */
+
+	/* TBD (remove): Temporary mechanism to disable this code if needed */
+
+#ifdef ACPI_ENABLE_MODULE_LEVEL_CODE
+
+			 if ((walk_state->pass_number <= ACPI_IMODE_LOAD_PASS1) &&
+				   ((walk_state->parse_flags & ACPI_PARSE_DISASSEMBLE) == 0)) {
+					/*
+					 * We want to skip If/Else/While constructs during Pass1
+					 * because we want to actually conditionally execute the
+					 * code during Pass2.
+					 *
+					 * Except for disassembly, where we always want to
+					 * walk the If/Else/While packages
+					 */
+					switch (op->common.aml_opcode) {
+					case AML_IF_OP:
+					case AML_ELSE_OP:
+					case AML_WHILE_OP:
+
+						ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+							"Pass1: Skipping an If/Else/While body\n"));
+
+						/* Skip body of if/else/while in pass 1 */
+
+						parser_state->aml   = parser_state->pkg_end;
+						walk_state->arg_count = 0;
+						break;
+
+					default:
+						break;
+					}
+				}
+#endif
+				switch (op->common.aml_opcode) {
+				case AML_METHOD_OP:
+
+					/*
+					 * Skip parsing of control method
+					 * because we don't have enough info in the first pass
+					 * to parse it correctly.
+					 *
+					 * Save the length and address of the body
+					 */
+					op->named.data   = parser_state->aml;
+					op->named.length = (u32) (parser_state->pkg_end -
+							   parser_state->aml);
+
+					/* Skip body of method */
+
+					parser_state->aml   = parser_state->pkg_end;
+					walk_state->arg_count = 0;
+					break;
+
+				case AML_BUFFER_OP:
+				case AML_PACKAGE_OP:
+				case AML_VAR_PACKAGE_OP:
+
+					if ((op->common.parent) &&
+						(op->common.parent->common.aml_opcode == AML_NAME_OP) &&
+						(walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2)) {
+						/*
+						 * Skip parsing of Buffers and Packages
+						 * because we don't have enough info in the first pass
+						 * to parse them correctly.
+						 */
+						op->named.data   = aml_op_start;
+						op->named.length = (u32) (parser_state->pkg_end -
+								   aml_op_start);
+
+						/* Skip body */
+
+						parser_state->aml   = parser_state->pkg_end;
+						walk_state->arg_count = 0;
+					}
+					break;
+
+				case AML_WHILE_OP:
+
+					if (walk_state->control_state) {
+						walk_state->control_state->control.package_end =
+							parser_state->pkg_end;
+					}
+					break;
+
+				default:
+
+					/* No action for all other opcodes */
+					break;
+				}
+				break;
+			}
+		}
+
+		/* Check for arguments that need to be processed */
+
+		if (walk_state->arg_count) {
+			/*
+			 * There are arguments (complex ones), push Op and
+			 * prepare for argument
+			 */
+			status = acpi_ps_push_scope (parser_state, op,
+					 walk_state->arg_types, walk_state->arg_count);
+			if (ACPI_FAILURE (status)) {
+				goto close_this_op;
+			}
+			op = NULL;
+			continue;
+		}
+
+		/*
+		 * All arguments have been processed -- Op is complete,
+		 * prepare for next
+		 */
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+		if (walk_state->op_info->flags & AML_NAMED) {
+			if (acpi_gbl_depth) {
+				acpi_gbl_depth--;
+			}
+
+			if (op->common.aml_opcode == AML_REGION_OP) {
+				/*
+				 * Skip parsing of control method or opregion body,
+				 * because we don't have enough info in the first pass
+				 * to parse them correctly.
+				 *
+				 * Completed parsing an op_region declaration, we now
+				 * know the length.
+				 */
+				op->named.length = (u32) (parser_state->aml - op->named.data);
+			}
+		}
+
+		if (walk_state->op_info->flags & AML_CREATE) {
+			/*
+			 * Backup to beginning of create_xXXfield declaration (1 for
+			 * Opcode)
+			 *
+			 * body_length is unknown until we parse the body
+			 */
+			op->named.length = (u32) (parser_state->aml - op->named.data);
+		}
+
+		/* This op complete, notify the dispatcher */
+
+		if (walk_state->ascending_callback != NULL) {
+			walk_state->op    = op;
+			walk_state->opcode = op->common.aml_opcode;
+
+			status = walk_state->ascending_callback (walk_state);
+			status = acpi_ps_next_parse_state (walk_state, op, status);
+			if (status == AE_CTRL_PENDING) {
+				status = AE_OK;
+				goto close_this_op;
+			}
+		}
+
+
+close_this_op:
+		/*
+		 * Finished one argument of the containing scope
+		 */
+		parser_state->scope->parse_scope.arg_count--;
+
+		/* Finished with pre_op */
+
+		if (pre_op) {
+			acpi_ps_free_op (pre_op);
+			pre_op = NULL;
+		}
+
+		/* Close this Op (will result in parse subtree deletion) */
+
+		status2 = acpi_ps_complete_this_op (walk_state, op);
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
+		op = NULL;
+
+		switch (status) {
+		case AE_OK:
+			break;
+
+
+		case AE_CTRL_TRANSFER:
+
+			/* We are about to transfer to a called method. */
+
+			walk_state->prev_op = op;
+			walk_state->prev_arg_types = walk_state->arg_types;
+			return_ACPI_STATUS (status);
+
+
+		case AE_CTRL_END:
+
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
+
+			if (op) {
+				walk_state->op    = op;
+				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
+
+				status = walk_state->ascending_callback (walk_state);
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+
+				status2 = acpi_ps_complete_this_op (walk_state, op);
+				if (ACPI_FAILURE (status2)) {
+					return_ACPI_STATUS (status2);
+				}
+				op = NULL;
+			}
+			status = AE_OK;
+			break;
+
+
+		case AE_CTRL_BREAK:
+		case AE_CTRL_CONTINUE:
+
+			/* Pop off scopes until we find the While */
+
+			while (!op || (op->common.aml_opcode != AML_WHILE_OP)) {
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+			}
+
+			/* Close this iteration of the While loop */
+
+			walk_state->op    = op;
+			walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+			walk_state->opcode = op->common.aml_opcode;
+
+			status = walk_state->ascending_callback (walk_state);
+			status = acpi_ps_next_parse_state (walk_state, op, status);
+
+			status2 = acpi_ps_complete_this_op (walk_state, op);
+			if (ACPI_FAILURE (status2)) {
+				return_ACPI_STATUS (status2);
+			}
+			op = NULL;
+
+			status = AE_OK;
+			break;
+
+
+		case AE_CTRL_TERMINATE:
+
+			status = AE_OK;
+
+			/* Clean up */
+			do {
+				if (op) {
+					status2 = acpi_ps_complete_this_op (walk_state, op);
+					if (ACPI_FAILURE (status2)) {
+						return_ACPI_STATUS (status2);
+					}
+				}
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+
+			} while (op);
+
+			return_ACPI_STATUS (status);
+
+
+		default:  /* All other non-AE_OK status */
+
+			do {
+				if (op) {
+					status2 = acpi_ps_complete_this_op (walk_state, op);
+					if (ACPI_FAILURE (status2)) {
+						return_ACPI_STATUS (status2);
+					}
+				}
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+
+			} while (op);
+
+
+			/*
+			 * TBD: Cleanup parse ops on error
+			 */
+#if 0
+			if (op == NULL) {
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+			}
+#endif
+			walk_state->prev_op = op;
+			walk_state->prev_arg_types = walk_state->arg_types;
+			return_ACPI_STATUS (status);
+		}
+
+		/* This scope complete? */
+
+		if (acpi_ps_has_completed_scope (parser_state)) {
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
+			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
+		}
+		else {
+			op = NULL;
+		}
+
+	} /* while parser_state->Aml */
+
+
+	/*
+	 * Complete the last Op (if not completed), and clear the scope stack.
+	 * It is easily possible to end an AML "package" with an unbounded number
+	 * of open scopes (such as when several ASL blocks are closed with
+	 * sequential closing braces).  We want to terminate each one cleanly.
+	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "AML package complete at Op %p\n", op));
+	do {
+		if (op) {
+			if (walk_state->ascending_callback != NULL) {
+				walk_state->op    = op;
+				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
+
+				status = walk_state->ascending_callback (walk_state);
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+				if (status == AE_CTRL_PENDING) {
+					status = AE_OK;
+					goto close_this_op;
+				}
+
+				if (status == AE_CTRL_TERMINATE) {
+					status = AE_OK;
+
+					/* Clean up */
+					do {
+						if (op) {
+							status2 = acpi_ps_complete_this_op (walk_state, op);
+							if (ACPI_FAILURE (status2)) {
+								return_ACPI_STATUS (status2);
+							}
+						}
+
+						acpi_ps_pop_scope (parser_state, &op,
+							&walk_state->arg_types, &walk_state->arg_count);
+
+					} while (op);
+
+					return_ACPI_STATUS (status);
+				}
+
+				else if (ACPI_FAILURE (status)) {
+					/* First error is most important */
+
+					(void) acpi_ps_complete_this_op (walk_state, op);
+					return_ACPI_STATUS (status);
+				}
+			}
+
+			status2 = acpi_ps_complete_this_op (walk_state, op);
+			if (ACPI_FAILURE (status2)) {
+				return_ACPI_STATUS (status2);
+			}
+		}
+
+		acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types,
+			&walk_state->arg_count);
+
+	} while (op);
+
+	return_ACPI_STATUS (status);
+}
+
+
diff --git a/drivers/acpi/parser/psopcode.c b/drivers/acpi/parser/psopcode.c
--- a/drivers/acpi/parser/psopcode.c
+++ b/drivers/acpi/parser/psopcode.c
@@ -44,6 +44,7 @@
 
 #include <acpi/acpi.h>
 #include <acpi/acparser.h>
+#include <acpi/acopcode.h>
 #include <acpi/amlcode.h>
 
 
@@ -51,23 +52,6 @@
 	 ACPI_MODULE_NAME    ("psopcode")
 
 
-#define _UNK                        0x6B
-/*
- * Reserved ASCII characters.  Do not use any of these for
- * internal opcodes, since they are used to differentiate
- * name strings from AML opcodes
- */
-#define _ASC                        0x6C
-#define _NAM                        0x6C
-#define _PFX                        0x6D
-#define _UNKNOWN_OPCODE             0x02    /* An example unknown opcode */
-
-#define MAX_EXTENDED_OPCODE         0x88
-#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
-#define MAX_INTERNAL_OPCODE
-#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
-
-
 /*******************************************************************************
  *
  * NAME:        acpi_gbl_aml_op_info
@@ -79,274 +63,9 @@
  *
  ******************************************************************************/
 
-
-/*
- * All AML opcodes and the parse-time arguments for each.  Used by the AML parser  Each list is compressed
- * into a 32-bit number and stored in the master opcode table at the end of this file.
- */
-
-
-#define ARGP_ACCESSFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_ACQUIRE_OP                 ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_WORDDATA)
-#define ARGP_ADD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_ALIAS_OP                   ARGP_LIST2 (ARGP_NAMESTRING, ARGP_NAME)
-#define ARGP_ARG0                       ARG_NONE
-#define ARGP_ARG1                       ARG_NONE
-#define ARGP_ARG2                       ARG_NONE
-#define ARGP_ARG3                       ARG_NONE
-#define ARGP_ARG4                       ARG_NONE
-#define ARGP_ARG5                       ARG_NONE
-#define ARGP_ARG6                       ARG_NONE
-#define ARGP_BANK_FIELD_OP              ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_BIT_AND_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NAND_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_NOT_OP                 ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_BIT_OR_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BIT_XOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_BREAK_OP                   ARG_NONE
-#define ARGP_BREAK_POINT_OP             ARG_NONE
-#define ARGP_BUFFER_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_BYTELIST)
-#define ARGP_BYTE_OP                    ARGP_LIST1 (ARGP_BYTEDATA)
-#define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
-#define ARGP_CONTINUE_OP                ARG_NONE
-#define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SIMPLENAME)
-#define ARGP_CREATE_BIT_FIELD_OP        ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_BYTE_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_DWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_FIELD_OP            ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_NAME)
-#define ARGP_CREATE_QWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_CREATE_WORD_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
-#define ARGP_DATA_REGION_OP             ARGP_LIST4 (ARGP_NAME,       ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_DEBUG_OP                   ARG_NONE
-#define ARGP_DECREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_DEREF_OF_OP                ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_DEVICE_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
-#define ARGP_DIVIDE_OP                  ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET,    ARGP_TARGET)
-#define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
-#define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
-#define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
-#define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
-#define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_FIND_SET_RIGHT_BIT_OP      ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_FROM_BCD_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_IF_OP                      ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
-#define ARGP_INCREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_INDEX_FIELD_OP             ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_BYTEDATA,  ARGP_FIELDLIST)
-#define ARGP_INDEX_OP                   ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_LAND_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LEQUAL_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LGREATER_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LGREATEREQUAL_OP           ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LLESS_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LLESSEQUAL_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LNOT_OP                    ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_LNOTEQUAL_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_LOAD_OP                    ARGP_LIST2 (ARGP_NAMESTRING, ARGP_SUPERNAME)
-#define ARGP_LOAD_TABLE_OP              ARGP_LIST6 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG,  ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_LOCAL0                     ARG_NONE
-#define ARGP_LOCAL1                     ARG_NONE
-#define ARGP_LOCAL2                     ARG_NONE
-#define ARGP_LOCAL3                     ARG_NONE
-#define ARGP_LOCAL4                     ARG_NONE
-#define ARGP_LOCAL5                     ARG_NONE
-#define ARGP_LOCAL6                     ARG_NONE
-#define ARGP_LOCAL7                     ARG_NONE
-#define ARGP_LOR_OP                     ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
-#define ARGP_MATCH_OP                   ARGP_LIST6 (ARGP_TERMARG,    ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_METHOD_OP                  ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_TERMLIST)
-#define ARGP_METHODCALL_OP              ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_MID_OP                     ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TARGET)
-#define ARGP_MOD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_MULTIPLY_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_MUTEX_OP                   ARGP_LIST2 (ARGP_NAME,       ARGP_BYTEDATA)
-#define ARGP_NAME_OP                    ARGP_LIST2 (ARGP_NAME,       ARGP_DATAOBJ)
-#define ARGP_NAMEDFIELD_OP              ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_NOOP_OP                    ARG_NONE
-#define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
-#define ARGP_ONE_OP                     ARG_NONE
-#define ARGP_ONES_OP                    ARG_NONE
-#define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
-#define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
-#define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
-#define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
-#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
-#define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_RESET_OP                   ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_RETURN_OP                  ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_REVISION_OP                ARG_NONE
-#define ARGP_SCOPE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_TERMLIST)
-#define ARGP_SHIFT_LEFT_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_SHIFT_RIGHT_OP             ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_SIGNAL_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_SIZE_OF_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_SLEEP_OP                   ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_STALL_OP                   ARGP_LIST1 (ARGP_TERMARG)
-#define ARGP_STATICSTRING_OP            ARGP_LIST1 (ARGP_NAMESTRING)
-#define ARGP_STORE_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_SUPERNAME)
-#define ARGP_STRING_OP                  ARGP_LIST1 (ARGP_CHARLIST)
-#define ARGP_SUBTRACT_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_THERMAL_ZONE_OP            ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
-#define ARGP_TIMER_OP                   ARG_NONE
-#define ARGP_TO_BCD_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_BUFFER_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_DEC_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
-#define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
-#define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
-#define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
-#define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
-#define ARGP_ZERO_OP                    ARG_NONE
-
-
-/*
- * All AML opcodes and the runtime arguments for each.  Used by the AML interpreter  Each list is compressed
- * into a 32-bit number and stored in the master opcode table at the end of this file.
- *
- * (Used by prep_operands procedure and the ASL Compiler)
- */
-
-
-#define ARGI_ACCESSFIELD_OP             ARGI_INVALID_OPCODE
-#define ARGI_ACQUIRE_OP                 ARGI_LIST2 (ARGI_MUTEX,      ARGI_INTEGER)
-#define ARGI_ADD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_ALIAS_OP                   ARGI_INVALID_OPCODE
-#define ARGI_ARG0                       ARG_NONE
-#define ARGI_ARG1                       ARG_NONE
-#define ARGI_ARG2                       ARG_NONE
-#define ARGI_ARG3                       ARG_NONE
-#define ARGI_ARG4                       ARG_NONE
-#define ARGI_ARG5                       ARG_NONE
-#define ARGI_ARG6                       ARG_NONE
-#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
-#define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_NOT_OP                 ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_BIT_OR_OP                  ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_BREAK_OP                   ARG_NONE
-#define ARGI_BREAK_POINT_OP             ARG_NONE
-#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
-#define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
-#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
-#define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
-#define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
-#define ARGI_CONTINUE_OP                ARGI_INVALID_OPCODE
-#define ARGI_COPY_OP                    ARGI_LIST2 (ARGI_ANYTYPE,    ARGI_SIMPLE_TARGET)
-#define ARGI_CREATE_BIT_FIELD_OP        ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_BYTE_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_DWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_FIELD_OP            ARGI_LIST4 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_INTEGER,      ARGI_REFERENCE)
-#define ARGI_CREATE_QWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_CREATE_WORD_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
-#define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING)
-#define ARGI_DEBUG_OP                   ARG_NONE
-#define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
-#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
-#define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
-#define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
-#define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
-#define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
-#define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
-#define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_FIND_SET_RIGHT_BIT_OP      ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_FROM_BCD_OP                ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
-#define ARGI_IF_OP                      ARGI_INVALID_OPCODE
-#define ARGI_INCREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
-#define ARGI_INDEX_FIELD_OP             ARGI_INVALID_OPCODE
-#define ARGI_INDEX_OP                   ARGI_LIST3 (ARGI_COMPLEXOBJ, ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_LAND_OP                    ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_LEQUAL_OP                  ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LGREATER_OP                ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LGREATEREQUAL_OP           ARGI_INVALID_OPCODE
-#define ARGI_LLESS_OP                   ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
-#define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
-#define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
-#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_FIELD,ARGI_TARGETREF)
-#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
-#define ARGI_LOCAL0                     ARG_NONE
-#define ARGI_LOCAL1                     ARG_NONE
-#define ARGI_LOCAL2                     ARG_NONE
-#define ARGI_LOCAL3                     ARG_NONE
-#define ARGI_LOCAL4                     ARG_NONE
-#define ARGI_LOCAL5                     ARG_NONE
-#define ARGI_LOCAL6                     ARG_NONE
-#define ARGI_LOCAL7                     ARG_NONE
-#define ARGI_LOR_OP                     ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,   ARGI_COMPUTEDATA,      ARGI_INTEGER,ARGI_COMPUTEDATA,ARGI_INTEGER)
-#define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
-#define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
-#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
-#define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
-#define ARGI_NAME_OP                    ARGI_INVALID_OPCODE
-#define ARGI_NAMEDFIELD_OP              ARGI_INVALID_OPCODE
-#define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
-#define ARGI_NOOP_OP                    ARG_NONE
-#define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
-#define ARGI_ONE_OP                     ARG_NONE
-#define ARGI_ONES_OP                    ARG_NONE
-#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
-#define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
-#define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
-#define ARGI_REF_OF_OP                  ARGI_LIST1 (ARGI_OBJECT_REF)
-#define ARGI_REGION_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
-#define ARGI_RELEASE_OP                 ARGI_LIST1 (ARGI_MUTEX)
-#define ARGI_RESERVEDFIELD_OP           ARGI_INVALID_OPCODE
-#define ARGI_RESET_OP                   ARGI_LIST1 (ARGI_EVENT)
-#define ARGI_RETURN_OP                  ARGI_INVALID_OPCODE
-#define ARGI_REVISION_OP                ARG_NONE
-#define ARGI_SCOPE_OP                   ARGI_INVALID_OPCODE
-#define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
-#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
-#define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
-#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
-#define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
-#define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
-#define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
-#define ARGI_TIMER_OP                   ARG_NONE
-#define ARGI_TO_BCD_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
-#define ARGI_TO_BUFFER_OP               ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_DEC_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
-#define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
-#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
-#define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
-#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
-#define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
-#define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
-#define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
-#define ARGI_ZERO_OP                    ARG_NONE
-
-
 /*
  * Summary of opcode types/flags
- */
-
-/******************************************************************************
+ *
 
  Opcodes that have associated namespace objects (AML_NSOBJECT flag)
 
@@ -460,14 +179,13 @@
 	AML_CREATE_DWORD_FIELD_OP
 	AML_CREATE_QWORD_FIELD_OP
 
-******************************************************************************/
+ ******************************************************************************/
 
 
 /*
- * Master Opcode information table.  A summary of everything we know about each opcode, all in one place.
+ * Master Opcode information table.  A summary of everything we know about each
+ * opcode, all in one place.
  */
-
-
 const struct acpi_opcode_info     acpi_gbl_aml_op_info[AML_NUM_OPCODES] =
 {
 /*! [Begin] no source code translation */
@@ -593,7 +311,7 @@ const struct acpi_opcode_info     acpi_g
 /* ACPI 2.0 opcodes */
 
 /* 6E */ ACPI_OP ("QwordConst",         ARGP_QWORD_OP,             ARGI_QWORD_OP,              ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
-/* 6F */ ACPI_OP ("Package /*Var*/",    ARGP_VAR_PACKAGE_OP,       ARGI_VAR_PACKAGE_OP,        ACPI_TYPE_PACKAGE,           AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER),
+/* 6F */ ACPI_OP ("Package", /* Var */  ARGP_VAR_PACKAGE_OP,       ARGI_VAR_PACKAGE_OP,        ACPI_TYPE_PACKAGE,           AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER),
 /* 70 */ ACPI_OP ("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,    ARGI_CONCAT_RES_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
 /* 71 */ ACPI_OP ("Mod",                ARGP_MOD_OP,               ARGI_MOD_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
 /* 72 */ ACPI_OP ("CreateQWordField",   ARGP_CREATE_QWORD_FIELD_OP,ARGI_CREATE_QWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
@@ -693,8 +411,7 @@ static const u8 acpi_gbl_long_op_index[N
  *
  * PARAMETERS:  Opcode              - The AML opcode
  *
- * RETURN:      A pointer to the info about the opcode.  NULL if the opcode was
- *              not found in the table.
+ * RETURN:      A pointer to the info about the opcode.
  *
  * DESCRIPTION: Find AML opcode description based on the opcode.
  *              NOTE: This procedure must ALWAYS return a valid pointer!
@@ -711,32 +428,23 @@ acpi_ps_get_opcode_info (
 	/*
 	 * Detect normal 8-bit opcode or extended 16-bit opcode
 	 */
-	switch ((u8) (opcode >> 8)) {
-	case 0:
-
+	if (!(opcode & 0xFF00)) {
 		/* Simple (8-bit) opcode: 0-255, can't index beyond table  */
 
 		return (&acpi_gbl_aml_op_info [acpi_gbl_short_op_index [(u8) opcode]]);
+	}
 
-	case AML_EXTOP:
-
-		/* Extended (16-bit, prefix+opcode) opcode */
-
-		if (((u8) opcode) <= MAX_EXTENDED_OPCODE) {
-			return (&acpi_gbl_aml_op_info [acpi_gbl_long_op_index [(u8) opcode]]);
-		}
-
-		/* Else fall through to error case below */
-		/*lint -fallthrough */
-
-	default:
+	if (((opcode & 0xFF00) == AML_EXTENDED_OPCODE) &&
+		(((u8) opcode) <= MAX_EXTENDED_OPCODE)) {
+		/* Valid extended (16-bit) opcode */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown AML opcode [%4.4X]\n", opcode));
-		break;
+		return (&acpi_gbl_aml_op_info [acpi_gbl_long_op_index [(u8) opcode]]);
 	}
 
+	/* Unknown AML opcode */
 
-	/* Default is "unknown opcode" */
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+		"Unknown AML opcode [%4.4X]\n", opcode));
 
 	return (&acpi_gbl_aml_op_info [_UNK]);
 }
diff --git a/drivers/acpi/parser/psparse.c b/drivers/acpi/parser/psparse.c
--- a/drivers/acpi/parser/psparse.c
+++ b/drivers/acpi/parser/psparse.c
@@ -62,9 +62,6 @@
 	 ACPI_MODULE_NAME    ("psparse")
 
 
-static u32                          acpi_gbl_depth = 0;
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ps_get_opcode_size
@@ -100,7 +97,7 @@ acpi_ps_get_opcode_size (
  *
  * PARAMETERS:  parser_state        - A parser state object
  *
- * RETURN:      Status
+ * RETURN:      Next AML opcode
  *
  * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)
  *
@@ -117,9 +114,8 @@ acpi_ps_peek_opcode (
 	aml = parser_state->aml;
 	opcode = (u16) ACPI_GET8 (aml);
 
-
-	if (opcode == AML_EXTOP) {
-		/* Extended opcode */
+	if (opcode == AML_EXTENDED_OP_PREFIX) {
+		/* Extended opcode, get the second opcode byte */
 
 		aml++;
 		opcode = (u16) ((opcode << 8) | ACPI_GET8 (aml));
@@ -136,13 +132,13 @@ acpi_ps_peek_opcode (
  * PARAMETERS:  walk_state      - Current State
  *              Op              - Op to complete
  *
- * RETURN:      None.
+ * RETURN:      Status
  *
  * DESCRIPTION: Perform any cleanup at the completion of an Op.
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_ps_complete_this_op (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op)
@@ -159,19 +155,26 @@ acpi_ps_complete_this_op (
 	/* Check for null Op, can happen if AML code is corrupt */
 
 	if (!op) {
-		return_VOID;
+		return_ACPI_STATUS (AE_OK);  /* OK for now */
 	}
 
 	/* Delete this op and the subtree below it if asked to */
 
 	if (((walk_state->parse_flags & ACPI_PARSE_TREE_MASK) != ACPI_PARSE_DELETE_TREE) ||
 		 (walk_state->op_info->class == AML_CLASS_ARGUMENT)) {
-		return_VOID;
+		return_ACPI_STATUS (AE_OK);
 	}
 
 	/* Make sure that we only delete this subtree */
 
 	if (op->common.parent) {
+		prev = op->common.parent->common.value.arg;
+		if (!prev) {
+			/* Nothing more to do */
+
+			goto cleanup;
+		}
+
 		/*
 		 * Check if we need to replace the operator and its subtree
 		 * with a return value op (placeholder op)
@@ -190,7 +193,7 @@ acpi_ps_complete_this_op (
 			 */
 			replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 			if (!replacement_op) {
-				goto cleanup;
+				goto allocate_error;
 			}
 			break;
 
@@ -207,18 +210,17 @@ acpi_ps_complete_this_op (
 				(op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
 				replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 				if (!replacement_op) {
-					goto cleanup;
+					goto allocate_error;
 				}
 			}
-
-			if ((op->common.parent->common.aml_opcode == AML_NAME_OP) &&
-				(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
+			else if ((op->common.parent->common.aml_opcode == AML_NAME_OP) &&
+					 (walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2)) {
 				if ((op->common.aml_opcode == AML_BUFFER_OP) ||
 					(op->common.aml_opcode == AML_PACKAGE_OP) ||
 					(op->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
 					replacement_op = acpi_ps_alloc_op (op->common.aml_opcode);
 					if (!replacement_op) {
-						goto cleanup;
+						goto allocate_error;
 					}
 
 					replacement_op->named.data = op->named.data;
@@ -228,15 +230,15 @@ acpi_ps_complete_this_op (
 			break;
 
 		default:
+
 			replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 			if (!replacement_op) {
-				goto cleanup;
+				goto allocate_error;
 			}
 		}
 
 		/* We must unlink this op from the parent tree */
 
-		prev = op->common.parent->common.value.arg;
 		if (prev == op) {
 			/* This op is the first in the list */
 
@@ -272,7 +274,6 @@ acpi_ps_complete_this_op (
 					next = NULL;
 				}
 			}
-
 			prev = next;
 		}
 	}
@@ -280,10 +281,18 @@ acpi_ps_complete_this_op (
 
 cleanup:
 
-	/* Now we can actually delete the subtree rooted at op */
+	/* Now we can actually delete the subtree rooted at Op */
 
 	acpi_ps_delete_parse_tree (op);
-	return_VOID;
+	return_ACPI_STATUS (AE_OK);
+
+
+allocate_error:
+
+	/* Always delete the subtree, even on error */
+
+	acpi_ps_delete_parse_tree (op);
+	return_ACPI_STATUS (AE_NO_MEMORY);
 }
 
 
@@ -291,7 +300,9 @@ cleanup:
  *
  * FUNCTION:    acpi_ps_next_parse_state
  *
- * PARAMETERS:  parser_state        - Current parser state object
+ * PARAMETERS:  walk_state          - Current state
+ *              Op                  - Current parse op
+ *              callback_status     - Status from previous operation
  *
  * RETURN:      Status
  *
@@ -382,9 +393,8 @@ acpi_ps_next_parse_state (
 
 	case AE_CTRL_TRANSFER:
 
-		/*
-		 * A method call (invocation) -- transfer control
-		 */
+		/* A method call (invocation) -- transfer control */
+
 		status = AE_CTRL_TRANSFER;
 		walk_state->prev_op = op;
 		walk_state->method_call_op = op;
@@ -397,6 +407,7 @@ acpi_ps_next_parse_state (
 
 
 	default:
+
 		status = callback_status;
 		if ((callback_status & AE_CODE_MASK) == AE_CODE_CONTROL) {
 			status = AE_OK;
@@ -410,651 +421,9 @@ acpi_ps_next_parse_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ps_parse_loop
- *
- * PARAMETERS:  parser_state        - Current parser state object
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Parse AML (pointed to by the current parser state) and return
- *              a tree of ops.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ps_parse_loop (
-	struct acpi_walk_state          *walk_state)
-{
-	acpi_status                     status = AE_OK;
-	union acpi_parse_object         *op = NULL;     /* current op */
-	union acpi_parse_object         *arg = NULL;
-	union acpi_parse_object         *pre_op = NULL;
-	struct acpi_parse_state         *parser_state;
-	u8                              *aml_op_start = NULL;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ps_parse_loop", walk_state);
-
-	if (walk_state->descending_callback == NULL) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	parser_state = &walk_state->parser_state;
-	walk_state->arg_types = 0;
-
-#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
-	if (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {
-		/* We are restarting a preempted control method */
-
-		if (acpi_ps_has_completed_scope (parser_state)) {
-			/*
-			 * We must check if a predicate to an IF or WHILE statement
-			 * was just completed
-			 */
-			if ((parser_state->scope->parse_scope.op) &&
-			   ((parser_state->scope->parse_scope.op->common.aml_opcode == AML_IF_OP) ||
-				(parser_state->scope->parse_scope.op->common.aml_opcode == AML_WHILE_OP)) &&
-				(walk_state->control_state) &&
-				(walk_state->control_state->common.state ==
-					ACPI_CONTROL_PREDICATE_EXECUTING)) {
-				/*
-				 * A predicate was just completed, get the value of the
-				 * predicate and branch based on that value
-				 */
-				walk_state->op = NULL;
-				status = acpi_ds_get_predicate_value (walk_state, ACPI_TO_POINTER (TRUE));
-				if (ACPI_FAILURE (status) &&
-					((status & AE_CODE_MASK) != AE_CODE_CONTROL)) {
-					if (status == AE_AML_NO_RETURN_VALUE) {
-						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-							"Invoked method did not return a value, %s\n",
-							acpi_format_exception (status)));
-
-					}
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "get_predicate Failed, %s\n",
-						acpi_format_exception (status)));
-					return_ACPI_STATUS (status);
-				}
-
-				status = acpi_ps_next_parse_state (walk_state, op, status);
-			}
-
-			acpi_ps_pop_scope (parser_state, &op,
-				&walk_state->arg_types, &walk_state->arg_count);
-			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
-		}
-		else if (walk_state->prev_op) {
-			/* We were in the middle of an op */
-
-			op = walk_state->prev_op;
-			walk_state->arg_types = walk_state->prev_arg_types;
-		}
-	}
-#endif
-
-	/*
-	 * Iterative parsing loop, while there is more aml to process:
-	 */
-	while ((parser_state->aml < parser_state->aml_end) || (op)) {
-		aml_op_start = parser_state->aml;
-		if (!op) {
-			/* Get the next opcode from the AML stream */
-
-			walk_state->aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-					   parser_state->aml_start);
-			walk_state->opcode   = acpi_ps_peek_opcode (parser_state);
-
-			/*
-			 * First cut to determine what we have found:
-			 * 1) A valid AML opcode
-			 * 2) A name string
-			 * 3) An unknown/invalid opcode
-			 */
-			walk_state->op_info = acpi_ps_get_opcode_info (walk_state->opcode);
-			switch (walk_state->op_info->class) {
-			case AML_CLASS_ASCII:
-			case AML_CLASS_PREFIX:
-				/*
-				 * Starts with a valid prefix or ASCII char, this is a name
-				 * string.  Convert the bare name string to a namepath.
-				 */
-				walk_state->opcode = AML_INT_NAMEPATH_OP;
-				walk_state->arg_types = ARGP_NAMESTRING;
-				break;
-
-			case AML_CLASS_UNKNOWN:
-
-				/* The opcode is unrecognized.  Just skip unknown opcodes */
-
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Found unknown opcode %X at AML address %p offset %X, ignoring\n",
-					walk_state->opcode, parser_state->aml, walk_state->aml_offset));
-
-				ACPI_DUMP_BUFFER (parser_state->aml, 128);
-
-				/* Assume one-byte bad opcode */
-
-				parser_state->aml++;
-				continue;
-
-			default:
-
-				/* Found opcode info, this is a normal opcode */
-
-				parser_state->aml += acpi_ps_get_opcode_size (walk_state->opcode);
-				walk_state->arg_types = walk_state->op_info->parse_args;
-				break;
-			}
-
-			/* Create Op structure and append to parent's argument list */
-
-			if (walk_state->op_info->flags & AML_NAMED) {
-				/* Allocate a new pre_op if necessary */
-
-				if (!pre_op) {
-					pre_op = acpi_ps_alloc_op (walk_state->opcode);
-					if (!pre_op) {
-						status = AE_NO_MEMORY;
-						goto close_this_op;
-					}
-				}
-
-				pre_op->common.value.arg = NULL;
-				pre_op->common.aml_opcode = walk_state->opcode;
-
-				/*
-				 * Get and append arguments until we find the node that contains
-				 * the name (the type ARGP_NAME).
-				 */
-				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
-					  (GET_CURRENT_ARG_TYPE (walk_state->arg_types) != ARGP_NAME)) {
-					status = acpi_ps_get_next_arg (walk_state, parser_state,
-							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
-					if (ACPI_FAILURE (status)) {
-						goto close_this_op;
-					}
-
-					acpi_ps_append_arg (pre_op, arg);
-					INCREMENT_ARG_LIST (walk_state->arg_types);
-				}
-
-				/* Make sure that we found a NAME and didn't run out of arguments */
-
-				if (!GET_CURRENT_ARG_TYPE (walk_state->arg_types)) {
-					status = AE_AML_NO_OPERAND;
-					goto close_this_op;
-				}
-
-				/* We know that this arg is a name, move to next arg */
-
-				INCREMENT_ARG_LIST (walk_state->arg_types);
-
-				/*
-				 * Find the object.  This will either insert the object into
-				 * the namespace or simply look it up
-				 */
-				walk_state->op = NULL;
-
-				status = walk_state->descending_callback (walk_state, &op);
-				if (ACPI_FAILURE (status)) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
-							acpi_format_exception (status)));
-					goto close_this_op;
-				}
-
-				if (op == NULL) {
-					continue;
-				}
-
-				status = acpi_ps_next_parse_state (walk_state, op, status);
-				if (status == AE_CTRL_PENDING) {
-					status = AE_OK;
-					goto close_this_op;
-				}
-
-				if (ACPI_FAILURE (status)) {
-					goto close_this_op;
-				}
-
-				acpi_ps_append_arg (op, pre_op->common.value.arg);
-				acpi_gbl_depth++;
-
-				if (op->common.aml_opcode == AML_REGION_OP) {
-					/*
-					 * Defer final parsing of an operation_region body,
-					 * because we don't have enough info in the first pass
-					 * to parse it correctly (i.e., there may be method
-					 * calls within the term_arg elements of the body.)
-					 *
-					 * However, we must continue parsing because
-					 * the opregion is not a standalone package --
-					 * we don't know where the end is at this point.
-					 *
-					 * (Length is unknown until parse of the body complete)
-					 */
-					op->named.data    = aml_op_start;
-					op->named.length  = 0;
-				}
-			}
-			else {
-				/* Not a named opcode, just allocate Op and append to parent */
-
-				walk_state->op_info = acpi_ps_get_opcode_info (walk_state->opcode);
-				op = acpi_ps_alloc_op (walk_state->opcode);
-				if (!op) {
-					status = AE_NO_MEMORY;
-					goto close_this_op;
-				}
-
-				if (walk_state->op_info->flags & AML_CREATE) {
-					/*
-					 * Backup to beginning of create_xXXfield declaration
-					 * body_length is unknown until we parse the body
-					 */
-					op->named.data    = aml_op_start;
-					op->named.length  = 0;
-				}
-
-				acpi_ps_append_arg (acpi_ps_get_parent_scope (parser_state), op);
-
-				if ((walk_state->descending_callback != NULL)) {
-					/*
-					 * Find the object.  This will either insert the object into
-					 * the namespace or simply look it up
-					 */
-					walk_state->op = op;
-
-					status = walk_state->descending_callback (walk_state, &op);
-					status = acpi_ps_next_parse_state (walk_state, op, status);
-					if (status == AE_CTRL_PENDING) {
-						status = AE_OK;
-						goto close_this_op;
-					}
-
-					if (ACPI_FAILURE (status)) {
-						goto close_this_op;
-					}
-				}
-			}
-
-			op->common.aml_offset = walk_state->aml_offset;
-
-			if (walk_state->op_info) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-					"Opcode %4.4X [%s] Op %p Aml %p aml_offset %5.5X\n",
-					 (u32) op->common.aml_opcode, walk_state->op_info->name,
-					 op, parser_state->aml, op->common.aml_offset));
-			}
-		}
-
-
-		/* Start arg_count at zero because we don't know if there are any args yet */
-
-		walk_state->arg_count = 0;
-
-		if (walk_state->arg_types) /* Are there any arguments that must be processed? */ {
-			/* Get arguments */
-
-			switch (op->common.aml_opcode) {
-			case AML_BYTE_OP:       /* AML_BYTEDATA_ARG */
-			case AML_WORD_OP:       /* AML_WORDDATA_ARG */
-			case AML_DWORD_OP:      /* AML_DWORDATA_ARG */
-			case AML_QWORD_OP:      /* AML_QWORDATA_ARG */
-			case AML_STRING_OP:     /* AML_ASCIICHARLIST_ARG */
-
-				/* Fill in constant or string argument directly */
-
-				acpi_ps_get_next_simple_arg (parser_state,
-					GET_CURRENT_ARG_TYPE (walk_state->arg_types), op);
-				break;
-
-			case AML_INT_NAMEPATH_OP:   /* AML_NAMESTRING_ARG */
-
-				status = acpi_ps_get_next_namepath (walk_state, parser_state, op, 1);
-				if (ACPI_FAILURE (status)) {
-					goto close_this_op;
-				}
-
-				walk_state->arg_types = 0;
-				break;
-
-			default:
-
-				/* Op is not a constant or string, append each argument to the Op */
-
-				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
-						!walk_state->arg_count) {
-					walk_state->aml_offset = (u32) ACPI_PTR_DIFF (parser_state->aml,
-							   parser_state->aml_start);
-					status = acpi_ps_get_next_arg (walk_state, parser_state,
-							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
-					if (ACPI_FAILURE (status)) {
-						goto close_this_op;
-					}
-
-					if (arg) {
-						arg->common.aml_offset = walk_state->aml_offset;
-						acpi_ps_append_arg (op, arg);
-					}
-					INCREMENT_ARG_LIST (walk_state->arg_types);
-				}
-
-				/* Special processing for certain opcodes */
-
-				switch (op->common.aml_opcode) {
-				case AML_METHOD_OP:
-
-					/*
-					 * Skip parsing of control method
-					 * because we don't have enough info in the first pass
-					 * to parse it correctly.
-					 *
-					 * Save the length and address of the body
-					 */
-					op->named.data   = parser_state->aml;
-					op->named.length = (u32) (parser_state->pkg_end - parser_state->aml);
-
-					/* Skip body of method */
-
-					parser_state->aml   = parser_state->pkg_end;
-					walk_state->arg_count = 0;
-					break;
-
-				case AML_BUFFER_OP:
-				case AML_PACKAGE_OP:
-				case AML_VAR_PACKAGE_OP:
-
-					if ((op->common.parent) &&
-						(op->common.parent->common.aml_opcode == AML_NAME_OP) &&
-						(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
-						/*
-						 * Skip parsing of Buffers and Packages
-						 * because we don't have enough info in the first pass
-						 * to parse them correctly.
-						 */
-						op->named.data   = aml_op_start;
-						op->named.length = (u32) (parser_state->pkg_end - aml_op_start);
-
-						/* Skip body */
-
-						parser_state->aml   = parser_state->pkg_end;
-						walk_state->arg_count = 0;
-					}
-					break;
-
-				case AML_WHILE_OP:
-
-					if (walk_state->control_state) {
-						walk_state->control_state->control.package_end = parser_state->pkg_end;
-					}
-					break;
-
-				default:
-
-					/* No action for all other opcodes */
-					break;
-				}
-				break;
-			}
-		}
-
-		/* Check for arguments that need to be processed */
-
-		if (walk_state->arg_count) {
-			/* There are arguments (complex ones), push Op and prepare for argument */
-
-			status = acpi_ps_push_scope (parser_state, op,
-					 walk_state->arg_types, walk_state->arg_count);
-			if (ACPI_FAILURE (status)) {
-				goto close_this_op;
-			}
-			op = NULL;
-			continue;
-		}
-
-		/* All arguments have been processed -- Op is complete, prepare for next */
-
-		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
-		if (walk_state->op_info->flags & AML_NAMED) {
-			if (acpi_gbl_depth) {
-				acpi_gbl_depth--;
-			}
-
-			if (op->common.aml_opcode == AML_REGION_OP) {
-				/*
-				 * Skip parsing of control method or opregion body,
-				 * because we don't have enough info in the first pass
-				 * to parse them correctly.
-				 *
-				 * Completed parsing an op_region declaration, we now
-				 * know the length.
-				 */
-				op->named.length = (u32) (parser_state->aml - op->named.data);
-			}
-		}
-
-		if (walk_state->op_info->flags & AML_CREATE) {
-			/*
-			 * Backup to beginning of create_xXXfield declaration (1 for
-			 * Opcode)
-			 *
-			 * body_length is unknown until we parse the body
-			 */
-			op->named.length = (u32) (parser_state->aml - op->named.data);
-		}
-
-		/* This op complete, notify the dispatcher */
-
-		if (walk_state->ascending_callback != NULL) {
-			walk_state->op    = op;
-			walk_state->opcode = op->common.aml_opcode;
-
-			status = walk_state->ascending_callback (walk_state);
-			status = acpi_ps_next_parse_state (walk_state, op, status);
-			if (status == AE_CTRL_PENDING) {
-				status = AE_OK;
-				goto close_this_op;
-			}
-		}
-
-
-close_this_op:
-		/*
-		 * Finished one argument of the containing scope
-		 */
-		parser_state->scope->parse_scope.arg_count--;
-
-		/* Close this Op (will result in parse subtree deletion) */
-
-		acpi_ps_complete_this_op (walk_state, op);
-		op = NULL;
-		if (pre_op) {
-			acpi_ps_free_op (pre_op);
-			pre_op = NULL;
-		}
-
-		switch (status) {
-		case AE_OK:
-			break;
-
-
-		case AE_CTRL_TRANSFER:
-
-			/*
-			 * We are about to transfer to a called method.
-			 */
-			walk_state->prev_op = op;
-			walk_state->prev_arg_types = walk_state->arg_types;
-			return_ACPI_STATUS (status);
-
-
-		case AE_CTRL_END:
-
-			acpi_ps_pop_scope (parser_state, &op,
-				&walk_state->arg_types, &walk_state->arg_count);
-
-			if (op) {
-				walk_state->op    = op;
-				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
-				walk_state->opcode = op->common.aml_opcode;
-
-				status = walk_state->ascending_callback (walk_state);
-				status = acpi_ps_next_parse_state (walk_state, op, status);
-
-				acpi_ps_complete_this_op (walk_state, op);
-				op = NULL;
-			}
-			status = AE_OK;
-			break;
-
-
-		case AE_CTRL_BREAK:
-		case AE_CTRL_CONTINUE:
-
-			/* Pop off scopes until we find the While */
-
-			while (!op || (op->common.aml_opcode != AML_WHILE_OP)) {
-				acpi_ps_pop_scope (parser_state, &op,
-					&walk_state->arg_types, &walk_state->arg_count);
-			}
-
-			/* Close this iteration of the While loop */
-
-			walk_state->op    = op;
-			walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
-			walk_state->opcode = op->common.aml_opcode;
-
-			status = walk_state->ascending_callback (walk_state);
-			status = acpi_ps_next_parse_state (walk_state, op, status);
-
-			acpi_ps_complete_this_op (walk_state, op);
-			op = NULL;
-
-			status = AE_OK;
-			break;
-
-
-		case AE_CTRL_TERMINATE:
-
-			status = AE_OK;
-
-			/* Clean up */
-			do {
-				if (op) {
-					acpi_ps_complete_this_op (walk_state, op);
-				}
-				acpi_ps_pop_scope (parser_state, &op,
-					&walk_state->arg_types, &walk_state->arg_count);
-
-			} while (op);
-
-			return_ACPI_STATUS (status);
-
-
-		default:  /* All other non-AE_OK status */
-
-			do {
-				if (op) {
-					acpi_ps_complete_this_op (walk_state, op);
-				}
-				acpi_ps_pop_scope (parser_state, &op,
-					&walk_state->arg_types, &walk_state->arg_count);
-
-			} while (op);
-
-
-			/*
-			 * TBD: Cleanup parse ops on error
-			 */
-#if 0
-			if (op == NULL) {
-				acpi_ps_pop_scope (parser_state, &op,
-					&walk_state->arg_types, &walk_state->arg_count);
-			}
-#endif
-			walk_state->prev_op = op;
-			walk_state->prev_arg_types = walk_state->arg_types;
-			return_ACPI_STATUS (status);
-		}
-
-		/* This scope complete? */
-
-		if (acpi_ps_has_completed_scope (parser_state)) {
-			acpi_ps_pop_scope (parser_state, &op,
-				&walk_state->arg_types, &walk_state->arg_count);
-			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
-		}
-		else {
-			op = NULL;
-		}
-
-	} /* while parser_state->Aml */
-
-
-	/*
-	 * Complete the last Op (if not completed), and clear the scope stack.
-	 * It is easily possible to end an AML "package" with an unbounded number
-	 * of open scopes (such as when several ASL blocks are closed with
-	 * sequential closing braces).  We want to terminate each one cleanly.
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "AML package complete at Op %p\n", op));
-	do {
-		if (op) {
-			if (walk_state->ascending_callback != NULL) {
-				walk_state->op    = op;
-				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
-				walk_state->opcode = op->common.aml_opcode;
-
-				status = walk_state->ascending_callback (walk_state);
-				status = acpi_ps_next_parse_state (walk_state, op, status);
-				if (status == AE_CTRL_PENDING) {
-					status = AE_OK;
-					goto close_this_op;
-				}
-
-				if (status == AE_CTRL_TERMINATE) {
-					status = AE_OK;
-
-					/* Clean up */
-					do {
-						if (op) {
-							acpi_ps_complete_this_op (walk_state, op);
-						}
-
-						acpi_ps_pop_scope (parser_state, &op,
-							&walk_state->arg_types, &walk_state->arg_count);
-
-					} while (op);
-
-					return_ACPI_STATUS (status);
-				}
-
-				else if (ACPI_FAILURE (status)) {
-					acpi_ps_complete_this_op (walk_state, op);
-					return_ACPI_STATUS (status);
-				}
-			}
-
-			acpi_ps_complete_this_op (walk_state, op);
-		}
-
-		acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types,
-			&walk_state->arg_count);
-
-	} while (op);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
  * FUNCTION:    acpi_ps_parse_aml
  *
- * PARAMETERS:  start_scope     - The starting point of the parse.  Becomes the
- *                                root of the parsed op tree.
- *              Aml             - Pointer to the raw AML code to parse
- *              aml_size        - Length of the AML to parse
+ * PARAMETERS:  walk_state      - Current state
  *
  *
  * RETURN:      Status
@@ -1076,8 +445,10 @@ acpi_ps_parse_aml (
 
 	ACPI_FUNCTION_TRACE ("ps_parse_aml");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Entered with walk_state=%p Aml=%p size=%X\n",
-		walk_state, walk_state->parser_state.aml, walk_state->parser_state.aml_size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"Entered with walk_state=%p Aml=%p size=%X\n",
+		walk_state, walk_state->parser_state.aml,
+		walk_state->parser_state.aml_size));
 
 
 	/* Create and initialize a new thread state */
@@ -1142,9 +513,10 @@ acpi_ps_parse_aml (
 			if ((status == AE_ALREADY_EXISTS) &&
 				(!walk_state->method_desc->method.semaphore)) {
 				/*
-				 * This method is marked not_serialized, but it tried to create a named
-				 * object, causing the second thread entrance to fail.  We will workaround
-				 * this by marking the method permanently as Serialized.
+				 * This method is marked not_serialized, but it tried to create
+				 * a named object, causing the second thread entrance to fail.
+				 * We will workaround this by marking the method permanently
+				 * as Serialized.
 				 */
 				walk_state->method_desc->method.method_flags |= AML_METHOD_SERIALIZED;
 				walk_state->method_desc->method.concurrency = 1;
@@ -1187,7 +559,8 @@ acpi_ps_parse_aml (
 
 		previous_walk_state = walk_state;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "return_value=%p, implicit_value=%p State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+			"return_value=%p, implicit_value=%p State=%p\n",
 			walk_state->return_desc, walk_state->implicit_return_obj, walk_state));
 
 		/* Check if we have restarted a preempted walk */
@@ -1231,12 +604,14 @@ acpi_ps_parse_aml (
 		 */
 		else if (previous_walk_state->caller_return_desc) {
 			if (previous_walk_state->implicit_return_obj) {
-				*(previous_walk_state->caller_return_desc) = previous_walk_state->implicit_return_obj;
+				*(previous_walk_state->caller_return_desc) =
+					previous_walk_state->implicit_return_obj;
 			}
 			else {
 				 /* NULL if no return value */
 
-				*(previous_walk_state->caller_return_desc) = previous_walk_state->return_desc;
+				*(previous_walk_state->caller_return_desc) =
+					previous_walk_state->return_desc;
 			}
 		}
 		else {
diff --git a/drivers/acpi/parser/psscope.c b/drivers/acpi/parser/psscope.c
--- a/drivers/acpi/parser/psscope.c
+++ b/drivers/acpi/parser/psscope.c
@@ -65,6 +65,7 @@ union acpi_parse_object *
 acpi_ps_get_parent_scope (
 	struct acpi_parse_state         *parser_state)
 {
+
 	return (parser_state->scope->parse_scope.op);
 }
 
@@ -87,8 +88,10 @@ u8
 acpi_ps_has_completed_scope (
 	struct acpi_parse_state         *parser_state)
 {
-	return ((u8) ((parser_state->aml >= parser_state->scope->parse_scope.arg_end ||
-			   !parser_state->scope->parse_scope.arg_count)));
+
+	return ((u8)
+			((parser_state->aml >= parser_state->scope->parse_scope.arg_end ||
+			 !parser_state->scope->parse_scope.arg_count)));
 }
 
 
@@ -167,23 +170,23 @@ acpi_ps_push_scope (
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	scope->common.data_type        = ACPI_DESC_TYPE_STATE_PSCOPE;
-	scope->parse_scope.op          = op;
-	scope->parse_scope.arg_list    = remaining_args;
-	scope->parse_scope.arg_count   = arg_count;
-	scope->parse_scope.pkg_end     = parser_state->pkg_end;
+	scope->common.data_type    = ACPI_DESC_TYPE_STATE_PSCOPE;
+	scope->parse_scope.op      = op;
+	scope->parse_scope.arg_list = remaining_args;
+	scope->parse_scope.arg_count = arg_count;
+	scope->parse_scope.pkg_end = parser_state->pkg_end;
 
 	/* Push onto scope stack */
 
 	acpi_ut_push_generic_state (&parser_state->scope, scope);
 
 	if (arg_count == ACPI_VAR_ARGS) {
-		/* multiple arguments */
+		/* Multiple arguments */
 
 		scope->parse_scope.arg_end = parser_state->pkg_end;
 	}
 	else {
-		/* single argument */
+		/* Single argument */
 
 		scope->parse_scope.arg_end = ACPI_TO_POINTER (ACPI_MAX_PTR);
 	}
@@ -221,18 +224,17 @@ acpi_ps_pop_scope (
 	ACPI_FUNCTION_TRACE ("ps_pop_scope");
 
 
-	/*
-	 * Only pop the scope if there is in fact a next scope
-	 */
+	/* Only pop the scope if there is in fact a next scope */
+
 	if (scope->common.next) {
 		scope = acpi_ut_pop_generic_state (&parser_state->scope);
 
 		/* return to parsing previous op */
 
-		*op                     = scope->parse_scope.op;
-		*arg_list               = scope->parse_scope.arg_list;
-		*arg_count              = scope->parse_scope.arg_count;
-		parser_state->pkg_end   = scope->parse_scope.pkg_end;
+		*op                 = scope->parse_scope.op;
+		*arg_list           = scope->parse_scope.arg_list;
+		*arg_count          = scope->parse_scope.arg_count;
+		parser_state->pkg_end = scope->parse_scope.pkg_end;
 
 		/* All done with this scope state structure */
 
@@ -241,12 +243,13 @@ acpi_ps_pop_scope (
 	else {
 		/* empty parse stack, prepare to fetch next opcode */
 
-		*op                     = NULL;
-		*arg_list               = 0;
-		*arg_count              = 0;
+		*op       = NULL;
+		*arg_list = 0;
+		*arg_count = 0;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped Op %p Args %X\n", *op, *arg_count));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"Popped Op %p Args %X\n", *op, *arg_count));
 	return_VOID;
 }
 
@@ -257,7 +260,7 @@ acpi_ps_pop_scope (
  *
  * PARAMETERS:  parser_state        - Current parser state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Destroy available list, remaining stack levels, and return
  *              root scope
diff --git a/drivers/acpi/parser/pstree.c b/drivers/acpi/parser/pstree.c
--- a/drivers/acpi/parser/pstree.c
+++ b/drivers/acpi/parser/pstree.c
@@ -49,6 +49,14 @@
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("pstree")
 
+/* Local prototypes */
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+union acpi_parse_object *
+acpi_ps_get_child (
+	union acpi_parse_object         *op);
+#endif
+
 
 /*******************************************************************************
  *
@@ -57,7 +65,7 @@
  * PARAMETERS:  Op              - Get an argument for this op
  *              Argn            - Nth argument to get
  *
- * RETURN:      The argument (as an Op object).  NULL if argument does not exist
+ * RETURN:      The argument (as an Op object). NULL if argument does not exist
  *
  * DESCRIPTION: Get the specified op's argument.
  *
@@ -152,7 +160,6 @@ acpi_ps_append_arg (
 		return;
 	}
 
-
 	/* Append the argument to the linked argument list */
 
 	if (op->common.value.arg) {
@@ -164,14 +171,12 @@ acpi_ps_append_arg (
 		}
 		prev_arg->common.next = arg;
 	}
-
 	else {
 		/* No argument list, this will be the first argument */
 
 		op->common.value.arg = arg;
 	}
 
-
 	/* Set the parent in this arg and any args linked after it */
 
 	while (arg) {
@@ -182,73 +187,6 @@ acpi_ps_append_arg (
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ps_get_child
- *
- * PARAMETERS:  Op              - Get the child of this Op
- *
- * RETURN:      Child Op, Null if none is found.
- *
- * DESCRIPTION: Get op's children or NULL if none
- *
- ******************************************************************************/
-union acpi_parse_object *
-acpi_ps_get_child (
-	union acpi_parse_object         *op)
-{
-	union acpi_parse_object         *child = NULL;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	switch (op->common.aml_opcode) {
-	case AML_SCOPE_OP:
-	case AML_ELSE_OP:
-	case AML_DEVICE_OP:
-	case AML_THERMAL_ZONE_OP:
-	case AML_INT_METHODCALL_OP:
-
-		child = acpi_ps_get_arg (op, 0);
-		break;
-
-
-	case AML_BUFFER_OP:
-	case AML_PACKAGE_OP:
-	case AML_METHOD_OP:
-	case AML_IF_OP:
-	case AML_WHILE_OP:
-	case AML_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 1);
-		break;
-
-
-	case AML_POWER_RES_OP:
-	case AML_INDEX_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 2);
-		break;
-
-
-	case AML_PROCESSOR_OP:
-	case AML_BANK_FIELD_OP:
-
-		child = acpi_ps_get_arg (op, 3);
-		break;
-
-
-	default:
-		/* All others have no children */
-		break;
-	}
-
-	return (child);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ps_get_depth_next
@@ -280,21 +218,21 @@ acpi_ps_get_depth_next (
 		return (NULL);
 	}
 
-	/* look for an argument or child */
+	/* Look for an argument or child */
 
 	next = acpi_ps_get_arg (op, 0);
 	if (next) {
 		return (next);
 	}
 
-	/* look for a sibling */
+	/* Look for a sibling */
 
 	next = op->common.next;
 	if (next) {
 		return (next);
 	}
 
-	/* look for a sibling of parent */
+	/* Look for a sibling of parent */
 
 	parent = op->common.parent;
 
@@ -305,13 +243,13 @@ acpi_ps_get_depth_next (
 		}
 
 		if (arg == origin) {
-			/* reached parent of origin, end search */
+			/* Reached parent of origin, end search */
 
 			return (NULL);
 		}
 
 		if (parent->common.next) {
-			/* found sibling of parent */
+			/* Found sibling of parent */
 
 			return (parent->common.next);
 		}
@@ -323,5 +261,74 @@ acpi_ps_get_depth_next (
 	return (next);
 }
 
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_child
+ *
+ * PARAMETERS:  Op              - Get the child of this Op
+ *
+ * RETURN:      Child Op, Null if none is found.
+ *
+ * DESCRIPTION: Get op's children or NULL if none
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *
+acpi_ps_get_child (
+	union acpi_parse_object         *op)
+{
+	union acpi_parse_object         *child = NULL;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	switch (op->common.aml_opcode) {
+	case AML_SCOPE_OP:
+	case AML_ELSE_OP:
+	case AML_DEVICE_OP:
+	case AML_THERMAL_ZONE_OP:
+	case AML_INT_METHODCALL_OP:
+
+		child = acpi_ps_get_arg (op, 0);
+		break;
+
+
+	case AML_BUFFER_OP:
+	case AML_PACKAGE_OP:
+	case AML_METHOD_OP:
+	case AML_IF_OP:
+	case AML_WHILE_OP:
+	case AML_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 1);
+		break;
+
+
+	case AML_POWER_RES_OP:
+	case AML_INDEX_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 2);
+		break;
+
+
+	case AML_PROCESSOR_OP:
+	case AML_BANK_FIELD_OP:
+
+		child = acpi_ps_get_arg (op, 3);
+		break;
+
+
+	default:
+		/* All others have no children */
+		break;
+	}
+
+	return (child);
+}
+#endif
+
 #endif  /*  ACPI_FUTURE_USAGE  */
 
diff --git a/drivers/acpi/parser/psutils.c b/drivers/acpi/parser/psutils.c
--- a/drivers/acpi/parser/psutils.c
+++ b/drivers/acpi/parser/psutils.c
@@ -45,7 +45,6 @@
 #include <acpi/acpi.h>
 #include <acpi/acparser.h>
 #include <acpi/amlcode.h>
-#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psutils")
@@ -57,7 +56,7 @@
  *
  * PARAMETERS:  None
  *
- * RETURN:      scope_op
+ * RETURN:      A new Scope object, null on failure
  *
  * DESCRIPTION: Create a Scope and associated namepath op with the root name
  *
@@ -75,7 +74,6 @@ acpi_ps_create_scope_op (
 		return (NULL);
 	}
 
-
 	scope_op->named.name = ACPI_ROOT_NAME;
 	return (scope_op);
 }
@@ -88,10 +86,9 @@ acpi_ps_create_scope_op (
  * PARAMETERS:  Op              - A newly allocated Op object
  *              Opcode          - Opcode to store in the Op
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
- *              opcode
+ * DESCRIPTION: Initialize a parse (Op) object
  *
  ******************************************************************************/
 
@@ -107,7 +104,8 @@ acpi_ps_init_op (
 	op->common.aml_opcode = opcode;
 
 	ACPI_DISASM_ONLY_MEMBERS (ACPI_STRNCPY (op->common.aml_op_name,
-			(acpi_ps_get_opcode_info (opcode))->name, sizeof (op->common.aml_op_name)));
+			(acpi_ps_get_opcode_info (opcode))->name,
+				sizeof (op->common.aml_op_name)));
 }
 
 
@@ -117,7 +115,7 @@ acpi_ps_init_op (
  *
  * PARAMETERS:  Opcode          - Opcode that will be stored in the new Op
  *
- * RETURN:      Pointer to the new Op.
+ * RETURN:      Pointer to the new Op, null on failure
  *
  * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
  *              opcode.  A cache of opcodes is available for the pure
@@ -156,12 +154,14 @@ acpi_ps_alloc_op (
 	if (flags == ACPI_PARSEOP_GENERIC) {
 		/* The generic op (default) is by far the most common (16 to 1) */
 
-		op = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_PSNODE);
+		op = acpi_os_acquire_object (acpi_gbl_ps_node_cache);
+		memset(op, 0, sizeof(struct acpi_parse_obj_common));
 	}
 	else {
 		/* Extended parseop */
 
-		op = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_PSNODE_EXT);
+		op = acpi_os_acquire_object (acpi_gbl_ps_node_ext_cache);
+		memset(op, 0, sizeof(struct acpi_parse_obj_named));
 	}
 
 	/* Initialize the Op */
@@ -200,41 +200,14 @@ acpi_ps_free_op (
 	}
 
 	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
-		acpi_ut_release_to_cache (ACPI_MEM_LIST_PSNODE, op);
+		(void) acpi_os_release_object (acpi_gbl_ps_node_cache, op);
 	}
 	else {
-		acpi_ut_release_to_cache (ACPI_MEM_LIST_PSNODE_EXT, op);
+		(void) acpi_os_release_object (acpi_gbl_ps_node_ext_cache, op);
 	}
 }
 
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ps_delete_parse_cache
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Free all objects that are on the parse cache list.
- *
- ******************************************************************************/
-
-void
-acpi_ps_delete_parse_cache (
-	void)
-{
-	ACPI_FUNCTION_TRACE ("ps_delete_parse_cache");
-
-
-	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_PSNODE);
-	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_PSNODE_EXT);
-	return_VOID;
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    Utility functions
@@ -275,7 +248,6 @@ acpi_ps_get_name (
 	union acpi_parse_object         *op)
 {
 
-
 	/* The "generic" object has no name associated with it */
 
 	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
diff --git a/drivers/acpi/parser/pswalk.c b/drivers/acpi/parser/pswalk.c
--- a/drivers/acpi/parser/pswalk.c
+++ b/drivers/acpi/parser/pswalk.c
@@ -90,17 +90,15 @@ acpi_ps_delete_parse_tree (
 			}
 		}
 
-		/*
-		 * No more children, this Op is complete.
-		 */
+		/* No more children, this Op is complete. */
+
 		next = op->common.next;
 		parent = op->common.parent;
 
 		acpi_ps_free_op (op);
 
-		/*
-		 * If we are back to the starting point, the walk is complete.
-		 */
+		/* If we are back to the starting point, the walk is complete. */
+
 		if (op == subtree_root) {
 			return_VOID;
 		}
@@ -111,5 +109,6 @@ acpi_ps_delete_parse_tree (
 			op = parent;
 		}
 	}
+
 	return_VOID;
 }
diff --git a/drivers/acpi/parser/psxface.c b/drivers/acpi/parser/psxface.c
--- a/drivers/acpi/parser/psxface.c
+++ b/drivers/acpi/parser/psxface.c
@@ -46,24 +46,39 @@
 #include <acpi/acparser.h>
 #include <acpi/acdispat.h>
 #include <acpi/acinterp.h>
-#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psxface")
 
+/* Local Prototypes */
+
+static acpi_status
+acpi_ps_execute_pass (
+	struct acpi_parameter_info      *info);
+
+static void
+acpi_ps_update_parameter_list (
+	struct acpi_parameter_info      *info,
+	u16                             action);
+
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_psx_execute
+ * FUNCTION:    acpi_ps_execute_method
  *
- * PARAMETERS:  Info->Node          - A method object containing both the AML
- *                                    address and length.
- *              **Params            - List of parameters to pass to method,
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method Node to execute
+ *                  obj_desc        - Method object
+ *                  Parameters      - List of parameters to pass to the method,
  *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *              **return_obj_desc   - Return object from execution of the
- *                                    method.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  pass_number     - Parse or execute pass
  *
  * RETURN:      Status
  *
@@ -72,171 +87,194 @@
  ******************************************************************************/
 
 acpi_status
-acpi_psx_execute (
+acpi_ps_execute_method (
 	struct acpi_parameter_info      *info)
 {
 	acpi_status                     status;
-	union acpi_operand_object       *obj_desc;
-	u32                             i;
-	union acpi_parse_object         *op;
-	struct acpi_walk_state          *walk_state;
 
 
-	ACPI_FUNCTION_TRACE ("psx_execute");
+	ACPI_FUNCTION_TRACE ("ps_execute_method");
 
 
-	/* Validate the Node and get the attached object */
+	/* Validate the Info and method Node */
 
 	if (!info || !info->node) {
 		return_ACPI_STATUS (AE_NULL_ENTRY);
 	}
 
-	obj_desc = acpi_ns_get_attached_object (info->node);
-	if (!obj_desc) {
-		return_ACPI_STATUS (AE_NULL_OBJECT);
-	}
-
 	/* Init for new method, wait on concurrency semaphore */
 
-	status = acpi_ds_begin_method_execution (info->node, obj_desc, NULL);
+	status = acpi_ds_begin_method_execution (info->node, info->obj_desc, NULL);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	if ((info->parameter_type == ACPI_PARAM_ARGS) &&
-		(info->parameters)) {
-		/*
-		 * The caller "owns" the parameters, so give each one an extra
-		 * reference
-		 */
-		for (i = 0; info->parameters[i]; i++) {
-			acpi_ut_add_reference (info->parameters[i]);
-		}
-	}
-
-	/*
-	 * 1) Perform the first pass parse of the method to enter any
-	 * named objects that it creates into the namespace
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-		"**** Begin Method Parse **** Entry=%p obj=%p\n",
-		info->node, obj_desc));
-
-	/* Create and init a Root Node */
-
-	op = acpi_ps_create_scope_op ();
-	if (!op) {
-		status = AE_NO_MEMORY;
-		goto cleanup1;
-	}
-
 	/*
 	 * Get a new owner_id for objects created by this method. Namespace
 	 * objects (such as Operation Regions) can be created during the
 	 * first pass parse.
 	 */
-	obj_desc->method.owning_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
-
-	/* Create and initialize a new walk state */
-
-	walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
-			   NULL, NULL, NULL);
-	if (!walk_state) {
-		status = AE_NO_MEMORY;
-		goto cleanup2;
-	}
-
-	status = acpi_ds_init_aml_walk (walk_state, op, info->node,
-			  obj_desc->method.aml_start,
-			  obj_desc->method.aml_length, NULL, 1);
+	status = acpi_ut_allocate_owner_id (&info->obj_desc->method.owner_id);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup3;
+		return_ACPI_STATUS (status);
 	}
 
-	/* Parse the AML */
+	/*
+	 * The caller "owns" the parameters, so give each one an extra
+	 * reference
+	 */
+	acpi_ps_update_parameter_list (info, REF_INCREMENT);
 
-	status = acpi_ps_parse_aml (walk_state);
-	acpi_ps_delete_parse_tree (op);
+	/*
+	 * 1) Perform the first pass parse of the method to enter any
+	 *    named objects that it creates into the namespace
+	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"**** Begin Method Parse **** Entry=%p obj=%p\n",
+		info->node, info->obj_desc));
+
+	info->pass_number = 1;
+	status = acpi_ps_execute_pass (info);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup1; /* Walk state is already deleted */
+		goto cleanup;
 	}
 
 	/*
-	 * 2) Execute the method.  Performs second pass parse simultaneously
+	 * 2) Execute the method. Performs second pass parse simultaneously
 	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 		"**** Begin Method Execution **** Entry=%p obj=%p\n",
-		info->node, obj_desc));
+		info->node, info->obj_desc));
 
-	/* Create and init a Root Node */
+	info->pass_number = 3;
+	status = acpi_ps_execute_pass (info);
 
-	op = acpi_ps_create_scope_op ();
-	if (!op) {
-		status = AE_NO_MEMORY;
-		goto cleanup1;
-	}
 
-	/* Init new op with the method name and pointer back to the NS node */
+cleanup:
+	if (info->obj_desc->method.owner_id) {
+		acpi_ut_release_owner_id (&info->obj_desc->method.owner_id);
+	}
 
-	acpi_ps_set_name (op, info->node->name.integer);
-	op->common.node = info->node;
+	/* Take away the extra reference that we gave the parameters above */
 
-	/* Create and initialize a new walk state */
+	acpi_ps_update_parameter_list (info, REF_DECREMENT);
 
-	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
-	if (!walk_state) {
-		status = AE_NO_MEMORY;
-		goto cleanup2;
-	}
+	/* Exit now if error above */
 
-	status = acpi_ds_init_aml_walk (walk_state, op, info->node,
-			  obj_desc->method.aml_start,
-			  obj_desc->method.aml_length, info, 3);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup3;
+		return_ACPI_STATUS (status);
 	}
 
 	/*
-	 * The walk of the parse tree is where we actually execute the method
+	 * If the method has returned an object, signal this to the caller with
+	 * a control exception code
 	 */
-	status = acpi_ps_parse_aml (walk_state);
-	goto cleanup2; /* Walk state already deleted */
+	if (info->return_object) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Method returned obj_desc=%p\n",
+			info->return_object));
+		ACPI_DUMP_STACK_ENTRY (info->return_object);
 
+		status = AE_CTRL_RETURN_VALUE;
+	}
 
-cleanup3:
-	acpi_ds_delete_walk_state (walk_state);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_update_parameter_list
+ *
+ * PARAMETERS:  Info            - See struct acpi_parameter_info
+ *                                (Used: parameter_type and Parameters)
+ *              Action          - Add or Remove reference
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Update reference count on all method parameter objects
+ *
+ ******************************************************************************/
+
+static void
+acpi_ps_update_parameter_list (
+	struct acpi_parameter_info      *info,
+	u16                             action)
+{
+	acpi_native_uint                i;
 
-cleanup2:
-	acpi_ps_delete_parse_tree (op);
 
-cleanup1:
 	if ((info->parameter_type == ACPI_PARAM_ARGS) &&
 		(info->parameters)) {
-		/* Take away the extra reference that we gave the parameters above */
+		/* Update reference count for each parameter */
 
 		for (i = 0; info->parameters[i]; i++) {
 			/* Ignore errors, just do them all */
 
-			(void) acpi_ut_update_object_reference (info->parameters[i], REF_DECREMENT);
+			(void) acpi_ut_update_object_reference (info->parameters[i], action);
 		}
 	}
+}
 
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_execute_pass
+ *
+ * PARAMETERS:  Info            - See struct acpi_parameter_info
+ *                                (Used: pass_number, Node, and obj_desc)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Single AML pass: Parse or Execute a control method
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_execute_pass (
+	struct acpi_parameter_info      *info)
+{
+	acpi_status                     status;
+	union acpi_parse_object         *op;
+	struct acpi_walk_state          *walk_state;
+
+
+	ACPI_FUNCTION_TRACE ("ps_execute_pass");
+
+
+	/* Create and init a Root Node */
+
+	op = acpi_ps_create_scope_op ();
+	if (!op) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * If the method has returned an object, signal this to the caller with
-	 * a control exception code
-	 */
-	if (info->return_object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Method returned obj_desc=%p\n",
-			info->return_object));
-		ACPI_DUMP_STACK_ENTRY (info->return_object);
+	/* Create and initialize a new walk state */
 
-		status = AE_CTRL_RETURN_VALUE;
+	walk_state = acpi_ds_create_walk_state (
+			  info->obj_desc->method.owner_id, NULL, NULL, NULL);
+	if (!walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	status = acpi_ds_init_aml_walk (walk_state, op, info->node,
+			  info->obj_desc->method.aml_start,
+			  info->obj_desc->method.aml_length,
+			  info->pass_number == 1 ? NULL : info,
+			  info->pass_number);
+	if (ACPI_FAILURE (status)) {
+		acpi_ds_delete_walk_state (walk_state);
+		goto cleanup;
 	}
 
+	/* Parse the AML */
+
+	status = acpi_ps_parse_aml (walk_state);
+
+	/* Walk state was deleted by parse_aml */
+
+cleanup:
+	acpi_ps_delete_parse_tree (op);
 	return_ACPI_STATUS (status);
 }
 
diff --git a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c
+++ b/drivers/acpi/pci_irq.c
@@ -269,7 +269,51 @@ acpi_pci_irq_del_prt (int segment, int b
 /* --------------------------------------------------------------------------
                           PCI Interrupt Routing Support
    -------------------------------------------------------------------------- */
+typedef int (*irq_lookup_func)(struct acpi_prt_entry *, int *, int *, char **);
 
+static int
+acpi_pci_allocate_irq(struct acpi_prt_entry *entry,
+	int	*edge_level,
+	int	*active_high_low,
+	char	**link)
+{
+	int	irq;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_allocate_irq");
+
+	if (entry->link.handle) {
+		irq = acpi_pci_link_allocate_irq(entry->link.handle,
+			entry->link.index, edge_level, active_high_low, link);
+		if (irq < 0) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
+			return_VALUE(-1);
+		}
+	} else {
+		irq = entry->link.index;
+		*edge_level = ACPI_LEVEL_SENSITIVE;
+		*active_high_low = ACPI_ACTIVE_LOW;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
+	return_VALUE(irq);
+}
+
+static int
+acpi_pci_free_irq(struct acpi_prt_entry *entry,
+	int	*edge_level,
+	int	*active_high_low,
+	char	**link)
+{
+	int	irq;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_free_irq");
+	if (entry->link.handle) {
+		irq = acpi_pci_link_free_irq(entry->link.handle);
+	} else {
+		irq = entry->link.index;
+	}
+	return_VALUE(irq);
+}
 /*
  * acpi_pci_irq_lookup
  * success: return IRQ >= 0
@@ -282,12 +326,13 @@ acpi_pci_irq_lookup (
 	int			pin,
 	int			*edge_level,
 	int			*active_high_low,
-	char			**link)
+	char			**link,
+	irq_lookup_func		func)
 {
 	struct acpi_prt_entry	*entry = NULL;
 	int segment = pci_domain_nr(bus);
 	int bus_nr = bus->number;
-	int irq;
+	int ret;
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
 
@@ -301,22 +346,8 @@ acpi_pci_irq_lookup (
 		return_VALUE(-1);
 	}
 	
-	if (entry->link.handle) {
-		irq = acpi_pci_link_get_irq(entry->link.handle,
-			entry->link.index, edge_level, active_high_low, link);
-		if (irq < 0) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
-			return_VALUE(-1);
-		}
-	} else {
-		irq = entry->link.index;
-		*edge_level = ACPI_LEVEL_SENSITIVE;
-		*active_high_low = ACPI_ACTIVE_LOW;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", irq));
-
-	return_VALUE(irq);
+	ret = func(entry, edge_level, active_high_low, link);
+	return_VALUE(ret);
 }
 
 /*
@@ -330,7 +361,8 @@ acpi_pci_irq_derive (
 	int			pin,
 	int			*edge_level,
 	int			*active_high_low,
-	char			**link)
+	char			**link,
+	irq_lookup_func		func)
 {
 	struct pci_dev		*bridge = dev;
 	int			irq = -1;
@@ -363,7 +395,7 @@ acpi_pci_irq_derive (
 		}
 
 		irq = acpi_pci_irq_lookup(bridge->bus, PCI_SLOT(bridge->devfn),
-			pin, edge_level, active_high_low, link);
+			pin, edge_level, active_high_low, link, func);
 	}
 
 	if (irq < 0) {
@@ -415,7 +447,7 @@ acpi_pci_irq_enable (
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
  	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-		&edge_level, &active_high_low, &link);
+		&edge_level, &active_high_low, &link, acpi_pci_allocate_irq);
 
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
@@ -423,7 +455,7 @@ acpi_pci_irq_enable (
 	 */
 	if (irq < 0)
  		irq = acpi_pci_irq_derive(dev, pin, &edge_level,
-			&active_high_low, &link);
+			&active_high_low, &link, acpi_pci_allocate_irq);
  
 	/*
 	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
@@ -461,7 +493,9 @@ acpi_pci_irq_enable (
 EXPORT_SYMBOL(acpi_pci_irq_enable);
 
 
-#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
+/* FIXME: implement x86/x86_64 version */
+void __attribute__((weak)) acpi_unregister_gsi(u32 i) {}
+
 void
 acpi_pci_irq_disable (
 	struct pci_dev		*dev)
@@ -488,14 +522,14 @@ acpi_pci_irq_disable (
 	 * First we check the PCI IRQ routing table (PRT) for an IRQ.
 	 */
  	gsi = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin,
-				  &edge_level, &active_high_low, NULL);
+			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
 	 * device's parent bridge.
 	 */
 	if (gsi < 0)
  		gsi = acpi_pci_irq_derive(dev, pin,
-					  &edge_level, &active_high_low, NULL);
+			&edge_level, &active_high_low, NULL, acpi_pci_free_irq);
 	if (gsi < 0)
 		return_VOID;
 
@@ -511,4 +545,3 @@ acpi_pci_irq_disable (
 
 	return_VOID;
 }
-#endif /* CONFIG_ACPI_DEALLOCATE_IRQ */
diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -68,14 +68,19 @@ static struct acpi_driver acpi_pci_link_
 			},
 };
 
+/*
+ * If a link is initialized, we never change its active and initialized
+ * later even the link is disable. Instead, we just repick the active irq
+ */
 struct acpi_pci_link_irq {
 	u8			active;			/* Current IRQ */
 	u8			edge_level;		/* All IRQs */
 	u8			active_high_low;	/* All IRQs */
-	u8			initialized;
 	u8			resource_type;
 	u8			possible_count;
 	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+	u8			initialized:1;
+	u8			reserved:7;
 };
 
 struct acpi_pci_link {
@@ -83,12 +88,14 @@ struct acpi_pci_link {
 	struct acpi_device	*device;
 	acpi_handle		handle;
 	struct acpi_pci_link_irq irq;
+	int			refcnt;
 };
 
 static struct {
 	int			count;
 	struct list_head	entries;
 }				acpi_link;
+DECLARE_MUTEX(acpi_link_lock);
 
 
 /* --------------------------------------------------------------------------
@@ -530,8 +537,12 @@ static int acpi_pci_link_allocate(
 
 	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate");
 
-	if (link->irq.initialized)
+	if (link->irq.initialized) {
+		if (link->refcnt == 0)
+			/* This means the link is disabled but initialized */
+			acpi_pci_link_set(link, link->irq.active);
 		return_VALUE(0);
+	}
 
 	/*
 	 * search for active IRQ in list of possible IRQs.
@@ -590,13 +601,13 @@ static int acpi_pci_link_allocate(
 }
 
 /*
- * acpi_pci_link_get_irq
+ * acpi_pci_link_allocate_irq
  * success: return IRQ >= 0
  * failure: return -1
  */
 
 int
-acpi_pci_link_get_irq (
+acpi_pci_link_allocate_irq (
 	acpi_handle		handle,
 	int			index,
 	int			*edge_level,
@@ -607,7 +618,7 @@ acpi_pci_link_get_irq (
 	struct acpi_device	*device = NULL;
 	struct acpi_pci_link	*link = NULL;
 
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
+	ACPI_FUNCTION_TRACE("acpi_pci_link_allocate_irq");
 
 	result = acpi_bus_get_device(handle, &device);
 	if (result) {
@@ -627,21 +638,70 @@ acpi_pci_link_get_irq (
 		return_VALUE(-1);
 	}
 
-	if (acpi_pci_link_allocate(link))
+	down(&acpi_link_lock);
+	if (acpi_pci_link_allocate(link)) {
+		up(&acpi_link_lock);
 		return_VALUE(-1);
+	}
 	   
 	if (!link->irq.active) {
+		up(&acpi_link_lock);
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link active IRQ is 0!\n"));
 		return_VALUE(-1);
 	}
+	link->refcnt ++;
+	up(&acpi_link_lock);
 
 	if (edge_level) *edge_level = link->irq.edge_level;
 	if (active_high_low) *active_high_low = link->irq.active_high_low;
 	if (name) *name = acpi_device_bid(link->device);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Link %s is referenced\n", acpi_device_bid(link->device)));
 	return_VALUE(link->irq.active);
 }
 
+/*
+ * We don't change link's irq information here.  After it is reenabled, we
+ * continue use the info
+ */
+int
+acpi_pci_link_free_irq(acpi_handle handle)
+{
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_link	*link = NULL;
+	acpi_status		result;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_free_irq");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		return_VALUE(-1);
+	}
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	if (!link) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		return_VALUE(-1);
+	}
 
+	down(&acpi_link_lock);
+	if (!link->irq.initialized) {
+		up(&acpi_link_lock);
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link isn't initialized\n"));
+		return_VALUE(-1);
+	}
+
+	link->refcnt --;
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"Link %s is dereferenced\n", acpi_device_bid(link->device)));
+
+	if (link->refcnt == 0) {
+		acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+	}
+	up(&acpi_link_lock);
+	return_VALUE(link->irq.active);
+}
 /* --------------------------------------------------------------------------
                                  Driver Interface
    -------------------------------------------------------------------------- */
@@ -671,6 +731,7 @@ acpi_pci_link_add (
 	strcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);
 	acpi_driver_data(device) = link;
 
+	down(&acpi_link_lock);
 	result = acpi_pci_link_get_possible(link);
 	if (result)
 		goto end;
@@ -706,6 +767,7 @@ acpi_pci_link_add (
 end:
 	/* disable all links -- to be activated on use */
 	acpi_ut_evaluate_object(link->handle, "_DIS", 0, NULL);
+	up(&acpi_link_lock);
 
 	if (result)
 		kfree(link);
@@ -713,40 +775,39 @@ end:
 	return_VALUE(result);
 }
 
-
 static int
-acpi_pci_link_resume (
-	struct acpi_pci_link	*link)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_link_resume");
-	
-	if (link->irq.active && link->irq.initialized)
-		return_VALUE(acpi_pci_link_set(link, link->irq.active));
-	else
-		return_VALUE(0);
-}
-
-
-static int
-irqrouter_resume(
-	struct sys_device *dev)
+irqrouter_suspend(
+	struct sys_device *dev,
+	u32	state)
 {
 	struct list_head        *node = NULL;
 	struct acpi_pci_link    *link = NULL;
+	int			ret = 0;
 
-	ACPI_FUNCTION_TRACE("irqrouter_resume");
+	ACPI_FUNCTION_TRACE("irqrouter_suspend");
 
 	list_for_each(node, &acpi_link.entries) {
-
 		link = list_entry(node, struct acpi_pci_link, node);
 		if (!link) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Invalid link context\n"));
 			continue;
 		}
-
-		acpi_pci_link_resume(link);
+		if (link->irq.initialized && link->refcnt != 0
+			/* We ignore legacy IDE device irq */
+			&& link->irq.active != 14 && link->irq.active !=15) {
+			printk(KERN_WARNING PREFIX
+				"%d drivers with interrupt %d neglected to call"
+				" pci_disable_device at .suspend\n",
+				link->refcnt,
+				link->irq.active);
+			printk(KERN_WARNING PREFIX
+				"Fix the driver, or rmmod before suspend\n");
+			link->refcnt = 0;
+			ret = -EINVAL;
+		}
 	}
-	return_VALUE(0);
+	return_VALUE(ret);
 }
 
 
@@ -764,8 +825,9 @@ acpi_pci_link_remove (
 
 	link = (struct acpi_pci_link *) acpi_driver_data(device);
 
-	/* TBD: Acquire/release lock */
+	down(&acpi_link_lock);
 	list_del(&link->node);
+	up(&acpi_link_lock);
 
 	kfree(link);
 
@@ -812,9 +874,12 @@ static int __init acpi_irq_penalty_updat
  * There is no ISA_POSSIBLE weight, so we simply use
  * the (small) PCI_USING penalty.
  */
-void acpi_penalize_isa_irq(int irq)
+void acpi_penalize_isa_irq(int irq, int active)
 {
-	acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
+	if (active)
+		acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;
+	else
+		acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;
 }
 
 /*
@@ -854,9 +919,10 @@ int __init acpi_irq_balance_set(char *st
 __setup("acpi_irq_balance", acpi_irq_balance_set);
 
 
+/* FIXME: we will remove this interface after all drivers call pci_disable_device */
 static struct sysdev_class irqrouter_sysdev_class = {
         set_kset_name("irqrouter"),
-        .resume = irqrouter_resume,
+        .suspend = irqrouter_suspend,
 };
 
 
diff --git a/drivers/acpi/processor_core.c b/drivers/acpi/processor_core.c
--- a/drivers/acpi/processor_core.c
+++ b/drivers/acpi/processor_core.c
@@ -256,6 +256,43 @@ acpi_processor_errata (
 
 
 /* --------------------------------------------------------------------------
+                              Common ACPI processor fucntions
+   -------------------------------------------------------------------------- */
+
+/*
+ * _PDC is required for a BIOS-OS handshake for most of the newer
+ * ACPI processor features.
+ */
+
+int acpi_processor_set_pdc(struct acpi_processor *pr,
+				struct acpi_object_list *pdc_in)
+{
+	acpi_status		status = AE_OK;
+	u32			arg0_buf[3];
+	union acpi_object	arg0 = {ACPI_TYPE_BUFFER};
+	struct acpi_object_list	no_object = {1, &arg0};
+	struct acpi_object_list	*pdc;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_pdc");
+
+	arg0.buffer.length = 12;
+	arg0.buffer.pointer = (u8 *) arg0_buf;
+	arg0_buf[0] = ACPI_PDC_REVISION_ID;
+	arg0_buf[1] = 0;
+	arg0_buf[2] = 0;
+
+	pdc = (pdc_in) ? pdc_in : &no_object;
+
+	status = acpi_evaluate_object(pr->handle, "_PDC", pdc, NULL);
+
+	if ((ACPI_FAILURE(status)) && (pdc_in))
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Error evaluating _PDC, using legacy perf. control...\n"));
+
+	return_VALUE(status);
+}
+
+
+/* --------------------------------------------------------------------------
                               FS Interface (/proc)
    -------------------------------------------------------------------------- */
 
diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -6,6 +6,8 @@
  *  Copyright (C) 2004       Dominik Brodowski <linux@brodo.de>
  *  Copyright (C) 2004  Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
  *  			- Added processor hotplug support
+ *  Copyright (C) 2005  Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
+ *  			- Added support for C3 on SMP
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -79,30 +81,33 @@ module_param(bm_history, uint, 0644);
  *
  * To skip this limit, boot/load with a large max_cstate limit.
  */
-static int no_c2c3(struct dmi_system_id *id)
+static int set_max_cstate(struct dmi_system_id *id)
 {
 	if (max_cstate > ACPI_PROCESSOR_MAX_POWER)
 		return 0;
 
-	printk(KERN_NOTICE PREFIX "%s detected - C2,C3 disabled."
+	printk(KERN_NOTICE PREFIX "%s detected - %s disabled."
 		" Override with \"processor.max_cstate=%d\"\n", id->ident,
+		((int)id->driver_data == 1)? "C2,C3":"C3",
 	       ACPI_PROCESSOR_MAX_POWER + 1);
 
-	max_cstate = 1;
+	max_cstate = (int)id->driver_data;
 
 	return 0;
 }
 
 
-
-
 static struct dmi_system_id __initdata processor_power_dmi_table[] = {
-	{ no_c2c3, "IBM ThinkPad R40e", {
+	{ set_max_cstate, "IBM ThinkPad R40e", {
 	  DMI_MATCH(DMI_BIOS_VENDOR,"IBM"),
-	  DMI_MATCH(DMI_BIOS_VERSION,"1SET60WW") }},
-	{ no_c2c3, "Medion 41700", {
+	  DMI_MATCH(DMI_BIOS_VERSION,"1SET60WW") }, (void*)1},
+	{ set_max_cstate, "Medion 41700", {
 	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
-	  DMI_MATCH(DMI_BIOS_VERSION,"R01-A1J") }},
+	  DMI_MATCH(DMI_BIOS_VERSION,"R01-A1J") }, (void*)1},
+	{ set_max_cstate, "Clevo 5600D", {
+	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
+	  DMI_MATCH(DMI_BIOS_VERSION,"SHE845M0.86C.0013.D.0302131307") },
+	  (void*)2},
 	{},
 };
 
@@ -142,7 +147,7 @@ acpi_processor_power_activate (
 		switch (old->type) {
 		case ACPI_STATE_C3:
 			/* Disable bus master reload */
-			if (new->type != ACPI_STATE_C3)
+			if (new->type != ACPI_STATE_C3 && pr->flags.bm_check)
 				acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
 			break;
 		}
@@ -152,7 +157,7 @@ acpi_processor_power_activate (
 	switch (new->type) {
 	case ACPI_STATE_C3:
 		/* Enable bus master reload */
-		if (old->type != ACPI_STATE_C3)
+		if (old->type != ACPI_STATE_C3 && pr->flags.bm_check)
 			acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
 		break;
 	}
@@ -163,6 +168,9 @@ acpi_processor_power_activate (
 }
 
 
+static atomic_t 	c3_cpu_count;
+
+
 static void acpi_processor_idle (void)
 {
 	struct acpi_processor	*pr = NULL;
@@ -297,8 +305,22 @@ static void acpi_processor_idle (void)
 		break;
 
 	case ACPI_STATE_C3:
-		/* Disable bus master arbitration */
-		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+		
+		if (pr->flags.bm_check) {
+			if (atomic_inc_return(&c3_cpu_count) ==
+					num_online_cpus()) {
+				/*
+				 * All CPUs are trying to go to C3
+				 * Disable bus master arbitration
+				 */
+				acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1,
+					ACPI_MTX_DO_NOT_LOCK);
+			}
+		} else {
+			/* SMP with no shared cache... Invalidate cache  */
+			ACPI_FLUSH_CPU_CACHE();
+		}
+		
 		/* Get start time (ticks) */
 		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
 		/* Invoke C3 */
@@ -307,8 +329,12 @@ static void acpi_processor_idle (void)
 		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
 		/* Get end time (ticks) */
 		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
-		/* Enable bus master arbitration */
-		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
+		if (pr->flags.bm_check) {
+			/* Enable bus master arbitration */
+			atomic_dec(&c3_cpu_count);
+			acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
+		}
+
 		/* Re-enable interrupts */
 		local_irq_enable();
 		/* Compute time (ticks) that we were actually asleep */
@@ -519,6 +545,30 @@ static int acpi_processor_get_power_info
 }
 
 
+static int acpi_processor_get_power_info_default_c1 (struct acpi_processor *pr)
+{
+	int i;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info_default_c1");
+
+	for (i = 0; i < ACPI_PROCESSOR_MAX_POWER; i++)
+		memset(&(pr->power.states[i]), 0, 
+		       sizeof(struct acpi_processor_cx));
+
+	/* if info is obtained from pblk/fadt, type equals state */
+	pr->power.states[ACPI_STATE_C1].type = ACPI_STATE_C1;
+	pr->power.states[ACPI_STATE_C2].type = ACPI_STATE_C2;
+	pr->power.states[ACPI_STATE_C3].type = ACPI_STATE_C3;
+
+	/* the C0 state only exists as a filler in our array,
+	 * and all processors need to support C1 */
+	pr->power.states[ACPI_STATE_C0].valid = 1;
+	pr->power.states[ACPI_STATE_C1].valid = 1;
+
+	return_VALUE(0);
+}
+
+
 static int acpi_processor_get_power_info_cst (struct acpi_processor *pr)
 {
 	acpi_status		status = 0;
@@ -529,15 +579,13 @@ static int acpi_processor_get_power_info
 
 	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info_cst");
 
-	if (errata.smp)
-		return_VALUE(-ENODEV);
-
 	if (nocst)
 		return_VALUE(-ENODEV);
 
 	pr->power.count = 0;
 	for (i = 0; i < ACPI_PROCESSOR_MAX_POWER; i++)
-		memset(pr->power.states, 0, sizeof(struct acpi_processor_cx));
+		memset(&(pr->power.states[i]), 0, 
+		       sizeof(struct acpi_processor_cx));
 
 	status = acpi_evaluate_object(pr->handle, "_CST", NULL, &buffer);
 	if (ACPI_FAILURE(status)) {
@@ -664,13 +712,6 @@ static void acpi_processor_power_verify_
 		return_VOID;
 	}
 
-	/* We're (currently) only supporting C2 on UP */
-	else if (errata.smp) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "C2 not supported in SMP mode\n"));
-		return_VOID;
-	}
-
 	/*
 	 * Otherwise we've met all of our C2 requirements.
 	 * Normalize the C2 latency to expidite policy
@@ -686,6 +727,8 @@ static void acpi_processor_power_verify_
 	struct acpi_processor *pr,
 	struct acpi_processor_cx *cx)
 {
+	static int bm_check_flag;
+
 	ACPI_FUNCTION_TRACE("acpi_processor_get_power_verify_c3");
 
 	if (!cx->address)
@@ -702,20 +745,6 @@ static void acpi_processor_power_verify_
 		return_VOID;
 	}
 
-	/* bus mastering control is necessary */
-	else if (!pr->flags.bm_control) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "C3 support requires bus mastering control\n"));
-		return_VOID;
-	}
-
-	/* We're (currently) only supporting C2 on UP */
-	else if (errata.smp) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "C3 not supported in SMP mode\n"));
-		return_VOID;
-	}
-
 	/*
 	 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast)
 	 * DMA transfers are used by any ISA device to avoid livelock.
@@ -729,6 +758,37 @@ static void acpi_processor_power_verify_
 		return_VOID;
 	}
 
+	/* All the logic here assumes flags.bm_check is same across all CPUs */
+	if (!bm_check_flag) {
+		/* Determine whether bm_check is needed based on CPU  */
+		acpi_processor_power_init_bm_check(&(pr->flags), pr->id);
+		bm_check_flag = pr->flags.bm_check;
+	} else {
+		pr->flags.bm_check = bm_check_flag;
+	}
+
+	if (pr->flags.bm_check) {
+		/* bus mastering control is necessary */
+		if (!pr->flags.bm_control) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "C3 support requires bus mastering control\n"));
+			return_VOID;
+		}
+	} else {
+		/*
+		 * WBINVD should be set in fadt, for C3 state to be
+		 * supported on when bm_check is not required.
+		 */
+		if (acpi_fadt.wb_invd != 1) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Cache invalidation should work properly"
+			  " for C3 to be enabled on SMP systems\n"));
+			return_VOID;
+		}
+		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD,
+				0, ACPI_MTX_DO_NOT_LOCK);
+	}
+
 	/*
 	 * Otherwise we've met all of our C3 requirements.
 	 * Normalize the C3 latency to expidite policy.  Enable
@@ -737,7 +797,6 @@ static void acpi_processor_power_verify_
 	 */
 	cx->valid = 1;
 	cx->latency_ticks = US_TO_PM_TIMER_TICKS(cx->latency);
-	pr->flags.bm_check = 1;
 
 	return_VOID;
 }
@@ -786,11 +845,8 @@ static int acpi_processor_get_power_info
 	result = acpi_processor_get_power_info_cst(pr);
 	if ((result) || (acpi_processor_power_verify(pr) < 2)) {
 		result = acpi_processor_get_power_info_fadt(pr);
-		if (result)
-			return_VALUE(result);
-
-		if (acpi_processor_power_verify(pr) < 2)
-			return_VALUE(-ENODEV);
+		if ((result) || (acpi_processor_power_verify(pr) < 2))
+			result = acpi_processor_get_power_info_default_c1(pr);
 	}
 
 	/*
@@ -810,11 +866,10 @@ static int acpi_processor_get_power_info
 	 * CPU as being "idle manageable"
 	 */
 	for (i = 1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
-		if (pr->power.states[i].valid)
+		if (pr->power.states[i].valid) {
 			pr->power.count = i;
-		if ((pr->power.states[i].valid) &&
-		    (pr->power.states[i].type >= ACPI_STATE_C2))
 			pr->flags.power = 1;
+		}
 	}
 
 	return_VALUE(0);
@@ -829,7 +884,7 @@ int acpi_processor_cst_has_changed (stru
 	if (!pr)
  		return_VALUE(-EINVAL);
 
-	if (errata.smp || nocst) {
+	if ( nocst) {
 		return_VALUE(-ENODEV);
 	}
 
@@ -929,7 +984,6 @@ static struct file_operations acpi_proce
 	.release	= single_release,
 };
 
-
 int acpi_processor_power_init(struct acpi_processor *pr, struct acpi_device *device)
 {
 	acpi_status		status = 0;
@@ -946,7 +1000,10 @@ int acpi_processor_power_init(struct acp
 		first_run++;
 	}
 
-	if (!errata.smp && (pr->id == 0) && acpi_fadt.cst_cnt && !nocst) {
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (acpi_fadt.cst_cnt && !nocst) {
 		status = acpi_os_write_port(acpi_fadt.smi_cmd, acpi_fadt.cst_cnt, 8);
 		if (ACPI_FAILURE(status)) {
 			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
@@ -954,6 +1011,8 @@ int acpi_processor_power_init(struct acp
 		}
 	}
 
+	acpi_processor_power_init_pdc(&(pr->power), pr->id);
+	acpi_processor_set_pdc(pr, pr->power.pdc);
 	acpi_processor_get_power_info(pr);
 
 	/*
diff --git a/drivers/acpi/processor_perflib.c b/drivers/acpi/processor_perflib.c
--- a/drivers/acpi/processor_perflib.c
+++ b/drivers/acpi/processor_perflib.c
@@ -165,37 +165,6 @@ void acpi_processor_ppc_exit(void) {
 	acpi_processor_ppc_status &= ~PPC_REGISTERED;
 }
 
-/*
- * when registering a cpufreq driver with this ACPI processor driver, the
- * _PCT and _PSS structures are read out and written into struct
- * acpi_processor_performance.
- */
-static int acpi_processor_set_pdc (struct acpi_processor *pr)
-{
-	acpi_status             status = AE_OK;
-	u32			arg0_buf[3];
-	union acpi_object	arg0 = {ACPI_TYPE_BUFFER};
-	struct acpi_object_list no_object = {1, &arg0};
-	struct acpi_object_list *pdc;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_pdc");
-
-	arg0.buffer.length = 12;
-	arg0.buffer.pointer = (u8 *) arg0_buf;
-	arg0_buf[0] = ACPI_PDC_REVISION_ID;
-	arg0_buf[1] = 0;
-	arg0_buf[2] = 0;
-
-	pdc = (pr->performance->pdc) ? pr->performance->pdc : &no_object;
-
-	status = acpi_evaluate_object(pr->handle, "_PDC", pdc, NULL);
-
-	if ((ACPI_FAILURE(status)) && (pr->performance->pdc))
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Error evaluating _PDC, using legacy perf. control...\n"));
-
-	return_VALUE(status);
-}
-
 
 static int
 acpi_processor_get_performance_control (
@@ -357,7 +326,7 @@ acpi_processor_get_performance_info (
 	if (!pr || !pr->performance || !pr->handle)
 		return_VALUE(-EINVAL);
 
-	acpi_processor_set_pdc(pr);
+	acpi_processor_set_pdc(pr, pr->performance->pdc);
 
 	status = acpi_get_handle(pr->handle, "_PCT", &handle);
 	if (ACPI_FAILURE(status)) {
diff --git a/drivers/acpi/resources/rsaddr.c b/drivers/acpi/resources/rsaddr.c
--- a/drivers/acpi/resources/rsaddr.c
+++ b/drivers/acpi/resources/rsaddr.c
@@ -77,21 +77,21 @@ acpi_rs_address16_resource (
 	u8                              **output_buffer,
 	acpi_size                       *structure_size)
 {
-	u8                              *buffer = byte_stream_buffer;
-	struct acpi_resource            *output_struct = (void *) *output_buffer;
-	u8                              *temp_ptr;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16);
 	u32                             index;
 	u16                             temp16;
 	u8                              temp8;
+	u8                              *temp_ptr;
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_address16);
 
 
 	ACPI_FUNCTION_TRACE ("rs_address16_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -104,9 +104,8 @@ acpi_rs_address16_resource (
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS16;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -118,9 +117,8 @@ acpi_rs_address16_resource (
 
 	output_struct->data.address16.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -140,9 +138,8 @@ acpi_rs_address16_resource (
 
 	output_struct->data.address16.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -165,39 +162,34 @@ acpi_rs_address16_resource (
 		}
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-7)
-	 */
+	/* Get Granularity (Bytes 6-7) */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 8-9)
-	 */
+	/* Get min_address_range (Bytes 8-9) */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 10-11)
-	 */
+	/* Get max_address_range (Bytes 10-11) */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 12-13)
-	 */
+	/* Get address_translation_offset (Bytes 12-13) */
+
 	buffer += 2;
-	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_translation_offset, buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 14-15) */
 
-	/*
-	 * Get address_length (Bytes 14-15)
-	 */
 	buffer += 2;
 	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_length, buffer);
 
-	/*
-	 * Resource Source Index (if present)
-	 */
+	/* Resource Source Index (if present) */
+
 	buffer += 2;
 
 	/*
@@ -225,7 +217,8 @@ acpi_rs_address16_resource (
 		output_struct->data.address16.resource_source.string_ptr =
 				(char *)((u8 * )output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.address16.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.address16.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -239,9 +232,8 @@ acpi_rs_address16_resource (
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 
 		output_struct->data.address16.resource_source.string_length = index + 1;
@@ -260,14 +252,12 @@ acpi_rs_address16_resource (
 		output_struct->data.address16.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -305,28 +295,24 @@ acpi_rs_address16_stream (
 	ACPI_FUNCTION_TRACE ("rs_address16_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x88;
 	buffer += 1;
 
-	/*
-	 * Save a pointer to the Length field - to be filled in later
-	 */
+	/* Save a pointer to the Length field - to be filled in later */
+
 	length_field = buffer;
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address16.resource_type & 0x03);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address16.producer_consumer & 0x01);
 
 	temp8 |= (linked_list->data.address16.decode & 0x01) << 1;
@@ -336,9 +322,8 @@ acpi_rs_address16_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address16.resource_type) {
@@ -362,39 +347,34 @@ acpi_rs_address16_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.granularity);
 	buffer += 2;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.min_address_range);
 	buffer += 2;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.max_address_range);
 	buffer += 2;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_32_TO_16 (buffer,
+		&linked_list->data.address16.address_translation_offset);
 	buffer += 2;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_length);
 	buffer += 2;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address16.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address16.resource_source.index;
 
@@ -403,9 +383,8 @@ acpi_rs_address16_stream (
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 				linked_list->data.address16.resource_source.string_ptr);
 
@@ -413,12 +392,12 @@ acpi_rs_address16_stream (
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address16.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address16.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	actual_bytes = ACPI_PTR_DIFF (buffer, *output_buffer);
 	*bytes_consumed = actual_bytes;
 
@@ -475,9 +454,8 @@ acpi_rs_address32_resource (
 	buffer = byte_stream_buffer;
 	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32);
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -490,9 +468,8 @@ acpi_rs_address32_resource (
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS32;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -504,35 +481,29 @@ acpi_rs_address32_resource (
 
 	output_struct->data.address32.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Producer / Consumer
-	 */
+	/* Producer / Consumer */
+
 	output_struct->data.address32.producer_consumer = temp8 & 0x01;
 
-	/*
-	 * Decode
-	 */
+	/* Decode */
+
 	output_struct->data.address32.decode = (temp8 >> 1) & 0x01;
 
-	/*
-	 * Min Address Fixed
-	 */
+	/* Min Address Fixed */
+
 	output_struct->data.address32.min_address_fixed = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Max Address Fixed
-	 */
+	/* Max Address Fixed */
+
 	output_struct->data.address32.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -556,39 +527,34 @@ acpi_rs_address32_resource (
 		}
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-9)
-	 */
+	/* Get Granularity (Bytes 6-9) */
+
 	buffer += 1;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 10-13)
-	 */
+	/* Get min_address_range (Bytes 10-13) */
+
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 14-17)
-	 */
+	/* Get max_address_range (Bytes 14-17) */
+
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 18-21)
-	 */
+	/* Get address_translation_offset (Bytes 18-21) */
+
 	buffer += 4;
-	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_translation_offset, buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 22-25) */
 
-	/*
-	 * Get address_length (Bytes 22-25)
-	 */
 	buffer += 4;
 	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_length, buffer);
 
-	/*
-	 * Resource Source Index (if present)
-	 */
+	/* Resource Source Index (if present) */
+
 	buffer += 4;
 
 	/*
@@ -615,7 +581,8 @@ acpi_rs_address32_resource (
 		output_struct->data.address32.resource_source.string_ptr =
 				(char *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.address32.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.address32.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -628,9 +595,8 @@ acpi_rs_address32_resource (
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 		output_struct->data.address32.resource_source.string_length = index + 1;
 
@@ -648,14 +614,12 @@ acpi_rs_address32_resource (
 		output_struct->data.address32.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -694,29 +658,25 @@ acpi_rs_address32_stream (
 
 	buffer = *output_buffer;
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x87;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address32.resource_type & 0x03);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address32.producer_consumer & 0x01);
 	temp8 |= (linked_list->data.address32.decode & 0x01) << 1;
 	temp8 |= (linked_list->data.address32.min_address_fixed & 0x01) << 2;
@@ -725,9 +685,8 @@ acpi_rs_address32_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address32.resource_type) {
@@ -751,39 +710,34 @@ acpi_rs_address32_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.granularity);
 	buffer += 4;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.min_address_range);
 	buffer += 4;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.max_address_range);
 	buffer += 4;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_32_TO_32 (buffer,
+		&linked_list->data.address32.address_translation_offset);
 	buffer += 4;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_length);
 	buffer += 4;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address32.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address32.resource_source.index;
 
@@ -792,9 +746,8 @@ acpi_rs_address32_stream (
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 			linked_list->data.address32.resource_source.string_ptr);
 
@@ -802,12 +755,12 @@ acpi_rs_address32_stream (
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address32.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address32.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
@@ -864,9 +817,8 @@ acpi_rs_address64_resource (
 	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64);
 	resource_type = *buffer;
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -879,9 +831,8 @@ acpi_rs_address64_resource (
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS64;
 
-	/*
-	 * Get the Resource Type (Byte3)
-	 */
+	/* Get the Resource Type (Byte3) */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -893,35 +844,29 @@ acpi_rs_address64_resource (
 
 	output_struct->data.address64.resource_type = temp8;
 
-	/*
-	 * Get the General Flags (Byte4)
-	 */
+	/* Get the General Flags (Byte4) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Producer / Consumer
-	 */
+	/* Producer / Consumer */
+
 	output_struct->data.address64.producer_consumer = temp8 & 0x01;
 
-	/*
-	 * Decode
-	 */
+	/* Decode */
+
 	output_struct->data.address64.decode = (temp8 >> 1) & 0x01;
 
-	/*
-	 * Min Address Fixed
-	 */
+	/* Min Address Fixed */
+
 	output_struct->data.address64.min_address_fixed = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Max Address Fixed
-	 */
+	/* Max Address Fixed */
+
 	output_struct->data.address64.max_address_fixed = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Get the Type Specific Flags (Byte5)
-	 */
+	/* Get the Type Specific Flags (Byte5) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -951,33 +896,29 @@ acpi_rs_address64_resource (
 		buffer += 2;
 	}
 
-	/*
-	 * Get Granularity (Bytes 6-13) or (Bytes 8-15)
-	 */
+	/* Get Granularity (Bytes 6-13) or (Bytes 8-15) */
+
 	buffer += 1;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.granularity, buffer);
 
-	/*
-	 * Get min_address_range (Bytes 14-21) or (Bytes 16-23)
-	 */
+	/* Get min_address_range (Bytes 14-21) or (Bytes 16-23) */
+
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.min_address_range, buffer);
 
-	/*
-	 * Get max_address_range (Bytes 22-29) or (Bytes 24-31)
-	 */
+	/* Get max_address_range (Bytes 22-29) or (Bytes 24-31) */
+
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.max_address_range, buffer);
 
-	/*
-	 * Get address_translation_offset (Bytes 30-37) or (Bytes 32-39)
-	 */
+	/* Get address_translation_offset (Bytes 30-37) or (Bytes 32-39) */
+
 	buffer += 8;
-	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_translation_offset, buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_translation_offset,
+		buffer);
+
+	/* Get address_length (Bytes 38-45) or (Bytes 40-47) */
 
-	/*
-	 * Get address_length (Bytes 38-45) or (Bytes 40-47)
-	 */
 	buffer += 8;
 	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_length, buffer);
 
@@ -989,14 +930,15 @@ acpi_rs_address64_resource (
 		/* Get type_specific_attribute (Bytes 48-55) */
 
 		buffer += 8;
-		ACPI_MOVE_64_TO_64 (&output_struct->data.address64.type_specific_attributes, buffer);
+		ACPI_MOVE_64_TO_64 (
+			&output_struct->data.address64.type_specific_attributes,
+			buffer);
 	}
 	else {
 		output_struct->data.address64.type_specific_attributes = 0;
 
-		/*
-		 * Resource Source Index (if present)
-		 */
+		/* Resource Source Index (if present) */
+
 		buffer += 8;
 
 		/*
@@ -1025,7 +967,8 @@ acpi_rs_address64_resource (
 			output_struct->data.address64.resource_source.string_ptr =
 					(char *)((u8 *)output_struct + struct_size);
 
-			temp_ptr = (u8 *) output_struct->data.address64.resource_source.string_ptr;
+			temp_ptr = (u8 *)
+				output_struct->data.address64.resource_source.string_ptr;
 
 			/* Copy the string into the buffer */
 
@@ -1042,7 +985,8 @@ acpi_rs_address64_resource (
 			 * Add the terminating null
 			 */
 			*temp_ptr = 0x00;
-			output_struct->data.address64.resource_source.string_length = index + 1;
+			output_struct->data.address64.resource_source.string_length =
+				index + 1;
 
 			/*
 			 * In order for the struct_size to fall on a 32-bit boundary,
@@ -1054,14 +998,12 @@ acpi_rs_address64_resource (
 		}
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -1100,29 +1042,25 @@ acpi_rs_address64_stream (
 
 	buffer = *output_buffer;
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x8A;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Resource Type (Memory, Io, bus_number)
-	 */
+	/* Set the Resource Type (Memory, Io, bus_number) */
+
 	temp8 = (u8) (linked_list->data.address64.resource_type & 0x03);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the general flags
-	 */
+	/* Set the general flags */
+
 	temp8 = (u8) (linked_list->data.address64.producer_consumer & 0x01);
 	temp8 |= (linked_list->data.address64.decode & 0x01) << 1;
 	temp8 |= (linked_list->data.address64.min_address_fixed & 0x01) << 2;
@@ -1131,9 +1069,8 @@ acpi_rs_address64_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the type specific flags
-	 */
+	/* Set the type specific flags */
+
 	temp8 = 0;
 
 	if (ACPI_MEMORY_RANGE == linked_list->data.address64.resource_type) {
@@ -1157,39 +1094,34 @@ acpi_rs_address64_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the address space granularity
-	 */
+	/* Set the address space granularity */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.granularity);
 	buffer += 8;
 
-	/*
-	 * Set the address range minimum
-	 */
+	/* Set the address range minimum */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.min_address_range);
 	buffer += 8;
 
-	/*
-	 * Set the address range maximum
-	 */
+	/* Set the address range maximum */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.max_address_range);
 	buffer += 8;
 
-	/*
-	 * Set the address translation offset
-	 */
-	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_translation_offset);
+	/* Set the address translation offset */
+
+	ACPI_MOVE_64_TO_64 (buffer,
+		&linked_list->data.address64.address_translation_offset);
 	buffer += 8;
 
-	/*
-	 * Set the address length
-	 */
+	/* Set the address length */
+
 	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_length);
 	buffer += 8;
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.address64.resource_source.string_length) {
 		temp8 = (u8) linked_list->data.address64.resource_source.index;
 
@@ -1198,21 +1130,21 @@ acpi_rs_address64_stream (
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
-		ACPI_STRCPY (temp_pointer, linked_list->data.address64.resource_source.string_ptr);
+		/* Copy the string */
+
+		ACPI_STRCPY (temp_pointer,
+			linked_list->data.address64.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address64.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (
+				 linked_list->data.address64.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
diff --git a/drivers/acpi/resources/rscalc.c b/drivers/acpi/resources/rscalc.c
--- a/drivers/acpi/resources/rscalc.c
+++ b/drivers/acpi/resources/rscalc.c
@@ -81,9 +81,8 @@ acpi_rs_get_byte_stream_length (
 
 
 	while (!done) {
-		/*
-		 * Init the variable that will hold the size to add to the total.
-		 */
+		/* Init the variable that will hold the size to add to the total. */
+
 		segment_size = 0;
 
 		switch (linked_list->id) {
@@ -196,7 +195,8 @@ acpi_rs_get_byte_stream_length (
 			segment_size = 16;
 
 			if (linked_list->data.address16.resource_source.string_ptr) {
-				segment_size += linked_list->data.address16.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address16.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -212,7 +212,8 @@ acpi_rs_get_byte_stream_length (
 			segment_size = 26;
 
 			if (linked_list->data.address32.resource_source.string_ptr) {
-				segment_size += linked_list->data.address32.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address32.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -227,7 +228,8 @@ acpi_rs_get_byte_stream_length (
 			segment_size = 46;
 
 			if (linked_list->data.address64.resource_source.string_ptr) {
-				segment_size += linked_list->data.address64.resource_source.string_length;
+				segment_size +=
+					linked_list->data.address64.resource_source.string_length;
 				segment_size++;
 			}
 			break;
@@ -241,38 +243,36 @@ acpi_rs_get_byte_stream_length (
 			 * Index + the length of the null terminated string
 			 * Resource Source + 1 for the null.
 			 */
-			segment_size = 9 +
-				(((acpi_size) linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
+			segment_size = 9 + (((acpi_size)
+				linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
 
 			if (linked_list->data.extended_irq.resource_source.string_ptr) {
-				segment_size += linked_list->data.extended_irq.resource_source.string_length;
+				segment_size +=
+					linked_list->data.extended_irq.resource_source.string_length;
 				segment_size++;
 			}
 			break;
 
 		default:
-			/*
-			 * If we get here, everything is out of sync, exit with error
-			 */
+
+			/* If we get here, everything is out of sync, exit with error */
+
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 
 		} /* switch (linked_list->Id) */
 
-		/*
-		 * Update the total
-		 */
+		/* Update the total */
+
 		byte_stream_size_needed += segment_size;
 
-		/*
-		 * Point to the next object
-		 */
+		/* Point to the next object */
+
 		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
 
-	/*
-	 * This is the data the caller needs
-	 */
+	/* This is the data the caller needs */
+
 	*size_needed = byte_stream_size_needed;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -320,9 +320,8 @@ acpi_rs_get_list_length (
 
 
 	while (bytes_parsed < byte_stream_buffer_length) {
-		/*
-		 * The next byte in the stream is the resource type
-		 */
+		/* The next byte in the stream is the resource type */
+
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
@@ -346,9 +345,8 @@ acpi_rs_get_list_length (
 			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 			bytes_consumed = temp16 + 3;
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp16 = (u16) ACPI_ROUND_UP_to_32_bITS (temp16);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
@@ -416,9 +414,8 @@ acpi_rs_get_list_length (
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 64-bit boundary for the structure
-			 */
+			/* Ensure a 64-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_64_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64) +
@@ -452,9 +449,8 @@ acpi_rs_get_list_length (
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32) +
@@ -488,9 +484,8 @@ acpi_rs_get_list_length (
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16) +
@@ -537,9 +532,8 @@ acpi_rs_get_list_length (
 				temp8 = 0;
 			}
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq) +
@@ -567,9 +561,8 @@ acpi_rs_get_list_length (
 
 			++buffer;
 
-			/*
-			 * Look at the number of bits set
-			 */
+			/* Look at the number of bits set */
+
 			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			for (index = 0; index < 16; index++) {
@@ -596,9 +589,8 @@ acpi_rs_get_list_length (
 
 			++buffer;
 
-			/*
-			 * Look at the number of bits set
-			 */
+			/* Look at the number of bits set */
+
 			temp8 = *buffer;
 
 			for(index = 0; index < 8; index++) {
@@ -670,9 +662,8 @@ acpi_rs_get_list_length (
 			temp8 = (u8) (temp8 & 0x7);
 			bytes_consumed = temp8 + 1;
 
-			/*
-			 * Ensure a 32-bit boundary for the structure
-			 */
+			/* Ensure a 32-bit boundary for the structure */
+
 			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
 					   (temp8 * sizeof (u8));
@@ -697,21 +688,18 @@ acpi_rs_get_list_length (
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 		}
 
-		/*
-		 * Update the return value and counter
-		 */
+		/* Update the return value and counter */
+
 		buffer_size += (u32) ACPI_ALIGN_RESOURCE_SIZE (structure_size);
 		bytes_parsed += bytes_consumed;
 
-		/*
-		 * Set the byte stream to point to the next resource
-		 */
+		/* Set the byte stream to point to the next resource */
+
 		byte_stream_buffer += bytes_consumed;
 	}
 
-	/*
-	 * This is the data the caller needs
-	 */
+	/* This is the data the caller needs */
+
 	*size_needed = buffer_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -767,9 +755,8 @@ acpi_rs_get_pci_routing_table_length (
 	top_object_list = package_object->package.elements;
 
 	for (index = 0; index < number_of_elements; index++) {
-		/*
-		 * Dereference the sub-package
-		 */
+		/* Dereference the sub-package */
+
 		package_element = *top_object_list;
 
 		/*
@@ -778,37 +765,40 @@ acpi_rs_get_pci_routing_table_length (
 		 */
 		sub_object_list = package_element->package.elements;
 
-		/*
-		 * Scan the irq_table_elements for the Source Name String
-		 */
+		/* Scan the irq_table_elements for the Source Name String */
+
 		name_found = FALSE;
 
 		for (table_index = 0; table_index < 4 && !name_found; table_index++) {
-			if ((ACPI_TYPE_STRING == ACPI_GET_OBJECT_TYPE (*sub_object_list)) ||
-				((ACPI_TYPE_LOCAL_REFERENCE == ACPI_GET_OBJECT_TYPE (*sub_object_list)) &&
-					((*sub_object_list)->reference.opcode == AML_INT_NAMEPATH_OP))) {
+			if ((ACPI_TYPE_STRING ==
+					ACPI_GET_OBJECT_TYPE (*sub_object_list)) ||
+
+				((ACPI_TYPE_LOCAL_REFERENCE ==
+					ACPI_GET_OBJECT_TYPE (*sub_object_list)) &&
+
+					((*sub_object_list)->reference.opcode ==
+						AML_INT_NAMEPATH_OP))) {
 				name_found = TRUE;
 			}
 			else {
-				/*
-				 * Look at the next element
-				 */
+				/* Look at the next element */
+
 				sub_object_list++;
 			}
 		}
 
 		temp_size_needed += (sizeof (struct acpi_pci_routing_table) - 4);
 
-		/*
-		 * Was a String type found?
-		 */
+		/* Was a String type found? */
+
 		if (name_found) {
 			if (ACPI_GET_OBJECT_TYPE (*sub_object_list) == ACPI_TYPE_STRING) {
 				/*
 				 * The length String.Length field does not include the
 				 * terminating NULL, add 1
 				 */
-				temp_size_needed += ((acpi_size) (*sub_object_list)->string.length + 1);
+				temp_size_needed += ((acpi_size)
+					(*sub_object_list)->string.length + 1);
 			}
 			else {
 				temp_size_needed += acpi_ns_get_pathname_length (
@@ -827,14 +817,14 @@ acpi_rs_get_pci_routing_table_length (
 
 		temp_size_needed = ACPI_ROUND_UP_to_64_bITS (temp_size_needed);
 
-		/*
-		 * Point to the next union acpi_operand_object
-		 */
+		/* Point to the next union acpi_operand_object */
+
 		top_object_list++;
 	}
 
 	/*
-	 * Adding an extra element to the end of the list, essentially a NULL terminator
+	 * Adding an extra element to the end of the list, essentially a
+	 * NULL terminator
 	 */
 	*buffer_size_needed = temp_size_needed + sizeof (struct acpi_pci_routing_table);
 	return_ACPI_STATUS (AE_OK);
diff --git a/drivers/acpi/resources/rscreate.c b/drivers/acpi/resources/rscreate.c
--- a/drivers/acpi/resources/rscreate.c
+++ b/drivers/acpi/resources/rscreate.c
@@ -87,9 +87,8 @@ acpi_rs_create_resource_list (
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "byte_stream_buffer = %p\n",
 		byte_stream_buffer));
 
-	/*
-	 * Params already validated, so we don't re-validate here
-	 */
+	/* Params already validated, so we don't re-validate here */
+
 	byte_stream_buffer_length = byte_stream_buffer->buffer.length;
 	byte_stream_start = byte_stream_buffer->buffer.pointer;
 
@@ -171,9 +170,8 @@ acpi_rs_create_pci_routing_table (
 
 	/* Params already validated, so we don't re-validate here */
 
-	/*
-	 * Get the required buffer length
-	 */
+	/* Get the required buffer length */
+
 	status = acpi_rs_get_pci_routing_table_length (package_object,
 			 &buffer_size_needed);
 	if (ACPI_FAILURE (status)) {
@@ -217,9 +215,8 @@ acpi_rs_create_pci_routing_table (
 		 */
 		user_prt->length = (sizeof (struct acpi_pci_routing_table) - 4);
 
-		/*
-		 * Each element of the top-level package must also be a package
-		 */
+		/* Each element of the top-level package must also be a package */
+
 		if (ACPI_GET_OBJECT_TYPE (*top_object_list) != ACPI_TYPE_PACKAGE) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"(PRT[%X]) Need sub-package, found %s\n",
@@ -243,9 +240,8 @@ acpi_rs_create_pci_routing_table (
 		 */
 		sub_object_list = (*top_object_list)->package.elements;
 
-		/*
-		 * 1) First subobject: Dereference the PRT.Address
-		 */
+		/* 1) First subobject: Dereference the PRT.Address */
+
 		obj_desc = sub_object_list[0];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->address = obj_desc->integer.value;
@@ -257,9 +253,8 @@ acpi_rs_create_pci_routing_table (
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * 2) Second subobject: Dereference the PRT.Pin
-		 */
+		/* 2) Second subobject: Dereference the PRT.Pin */
+
 		obj_desc = sub_object_list[1];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->pin = (u32) obj_desc->integer.value;
@@ -271,9 +266,8 @@ acpi_rs_create_pci_routing_table (
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * 3) Third subobject: Dereference the PRT.source_name
-		 */
+		/* 3) Third subobject: Dereference the PRT.source_name */
+
 		obj_desc = sub_object_list[2];
 		switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 		case ACPI_TYPE_LOCAL_REFERENCE:
@@ -296,7 +290,9 @@ acpi_rs_create_pci_routing_table (
 
 			status = acpi_ns_handle_to_pathname ((acpi_handle) node, &path_buffer);
 
-			user_prt->length += (u32) ACPI_STRLEN (user_prt->source) + 1; /* include null terminator */
+			/* +1 to include null terminator */
+
+			user_prt->length += (u32) ACPI_STRLEN (user_prt->source) + 1;
 			break;
 
 
@@ -304,8 +300,10 @@ acpi_rs_create_pci_routing_table (
 
 			ACPI_STRCPY (user_prt->source, obj_desc->string.pointer);
 
-			/* Add to the Length field the length of the string (add 1 for terminator) */
-
+			/*
+			 * Add to the Length field the length of the string
+			 * (add 1 for terminator)
+			 */
 			user_prt->length += obj_desc->string.length + 1;
 			break;
 
@@ -333,9 +331,8 @@ acpi_rs_create_pci_routing_table (
 
 		user_prt->length = (u32) ACPI_ROUND_UP_to_64_bITS (user_prt->length);
 
-		/*
-		 * 4) Fourth subobject: Dereference the PRT.source_index
-		 */
+		/* 4) Fourth subobject: Dereference the PRT.source_index */
+
 		obj_desc = sub_object_list[3];
 		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 			user_prt->source_index = (u32) obj_desc->integer.value;
diff --git a/drivers/acpi/resources/rsdump.c b/drivers/acpi/resources/rsdump.c
--- a/drivers/acpi/resources/rsdump.c
+++ b/drivers/acpi/resources/rsdump.c
@@ -51,6 +51,61 @@
 
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
+/* Local prototypes */
+
+static void
+acpi_rs_dump_irq (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address16 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_address64 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_dma (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_io (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_extended_irq (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_fixed_io (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_fixed_memory32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_memory24 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_memory32 (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_start_depend_fns (
+	union acpi_resource_data        *data);
+
+static void
+acpi_rs_dump_vendor_specific (
+	union acpi_resource_data        *data);
+
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_rs_dump_irq
@@ -63,7 +118,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_irq (
 	union acpi_resource_data        *data)
 {
@@ -77,13 +132,13 @@ acpi_rs_dump_irq (
 	acpi_os_printf ("IRQ Resource\n");
 
 	acpi_os_printf ("  %s Triggered\n",
-			 ACPI_LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
+		ACPI_LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACPI_ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
+		ACPI_ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
+		ACPI_SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
 
 	acpi_os_printf ("  %X Interrupts ( ", irq_data->number_of_interrupts);
 
@@ -108,7 +163,7 @@ acpi_rs_dump_irq (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_dma (
 	union acpi_resource_data        *data)
 {
@@ -144,7 +199,7 @@ acpi_rs_dump_dma (
 	}
 
 	acpi_os_printf ("  %sBus Master\n",
-			 ACPI_BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
+		ACPI_BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
 
 
 	switch (dma_data->transfer) {
@@ -165,7 +220,8 @@ acpi_rs_dump_dma (
 		break;
 	}
 
-	acpi_os_printf ("  Number of Channels: %X ( ", dma_data->number_of_channels);
+	acpi_os_printf ("  Number of Channels: %X ( ",
+		dma_data->number_of_channels);
 
 	for (index = 0; index < dma_data->number_of_channels; index++) {
 		acpi_os_printf ("%X ", dma_data->channels[index]);
@@ -188,7 +244,7 @@ acpi_rs_dump_dma (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_start_depend_fns (
 	union acpi_resource_data        *data)
 {
@@ -232,8 +288,7 @@ acpi_rs_dump_start_depend_fns (
 		break;
 
 	default:
-		acpi_os_printf ("  Invalid performance "
-				  "robustness preference\n");
+		acpi_os_printf ("  Invalid performance robustness preference\n");
 		break;
 	}
 
@@ -253,7 +308,7 @@ acpi_rs_dump_start_depend_fns (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_io (
 	union acpi_resource_data        *data)
 {
@@ -266,19 +321,15 @@ acpi_rs_dump_io (
 	acpi_os_printf ("Io Resource\n");
 
 	acpi_os_printf ("  %d bit decode\n",
-			 ACPI_DECODE_16 == io_data->io_decode ? 16 : 10);
+		ACPI_DECODE_16 == io_data->io_decode ? 16 : 10);
 
-	acpi_os_printf ("  Range minimum base: %08X\n",
-			 io_data->min_base_address);
+	acpi_os_printf ("  Range minimum base: %08X\n", io_data->min_base_address);
 
-	acpi_os_printf ("  Range maximum base: %08X\n",
-			 io_data->max_base_address);
+	acpi_os_printf ("  Range maximum base: %08X\n", io_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 io_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", io_data->alignment);
 
-	acpi_os_printf ("  Range Length: %08X\n",
-			 io_data->range_length);
+	acpi_os_printf ("  Range Length: %08X\n", io_data->range_length);
 
 	return;
 }
@@ -296,7 +347,7 @@ acpi_rs_dump_io (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_fixed_io (
 	union acpi_resource_data        *data)
 {
@@ -307,11 +358,9 @@ acpi_rs_dump_fixed_io (
 
 
 	acpi_os_printf ("Fixed Io Resource\n");
-	acpi_os_printf ("  Range base address: %08X",
-			 fixed_io_data->base_address);
+	acpi_os_printf ("  Range base address: %08X", fixed_io_data->base_address);
 
-	acpi_os_printf ("  Range length: %08X",
-			 fixed_io_data->range_length);
+	acpi_os_printf ("  Range length: %08X", fixed_io_data->range_length);
 
 	return;
 }
@@ -329,7 +378,7 @@ acpi_rs_dump_fixed_io (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_vendor_specific (
 	union acpi_resource_data        *data)
 {
@@ -346,7 +395,7 @@ acpi_rs_dump_vendor_specific (
 
 	for (index = 0; index < vendor_data->length; index++) {
 		acpi_os_printf ("  Byte %X: %08X\n",
-				 index, vendor_data->reserved[index]);
+			index, vendor_data->reserved[index]);
 	}
 
 	return;
@@ -365,7 +414,7 @@ acpi_rs_dump_vendor_specific (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_memory24 (
 	union acpi_resource_data        *data)
 {
@@ -378,21 +427,19 @@ acpi_rs_dump_memory24 (
 	acpi_os_printf ("24-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 memory24_data->read_write_attribute ?
-			 "/Write" : " only");
+		ACPI_READ_WRITE_MEMORY ==
+			memory24_data->read_write_attribute ?
+			"/Write" : " only");
 
 	acpi_os_printf ("  Range minimum base: %08X\n",
-			 memory24_data->min_base_address);
+		memory24_data->min_base_address);
 
 	acpi_os_printf ("  Range maximum base: %08X\n",
-			 memory24_data->max_base_address);
+		memory24_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 memory24_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", memory24_data->alignment);
 
-	acpi_os_printf ("  Range length: %08X\n",
-			 memory24_data->range_length);
+	acpi_os_printf ("  Range length: %08X\n", memory24_data->range_length);
 
 	return;
 }
@@ -410,7 +457,7 @@ acpi_rs_dump_memory24 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_memory32 (
 	union acpi_resource_data        *data)
 {
@@ -423,21 +470,19 @@ acpi_rs_dump_memory32 (
 	acpi_os_printf ("32-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 memory32_data->read_write_attribute ?
-			 "/Write" : " only");
+		ACPI_READ_WRITE_MEMORY ==
+			memory32_data->read_write_attribute ?
+			"/Write" : " only");
 
 	acpi_os_printf ("  Range minimum base: %08X\n",
-			 memory32_data->min_base_address);
+		memory32_data->min_base_address);
 
 	acpi_os_printf ("  Range maximum base: %08X\n",
-			 memory32_data->max_base_address);
+		memory32_data->max_base_address);
 
-	acpi_os_printf ("  Alignment: %08X\n",
-			 memory32_data->alignment);
+	acpi_os_printf ("  Alignment: %08X\n", memory32_data->alignment);
 
-	acpi_os_printf ("  Range length: %08X\n",
-			 memory32_data->range_length);
+	acpi_os_printf ("  Range length: %08X\n", memory32_data->range_length);
 
 	return;
 }
@@ -455,11 +500,12 @@ acpi_rs_dump_memory32 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_fixed_memory32 (
 	union acpi_resource_data            *data)
 {
-	struct acpi_resource_fixed_mem32    *fixed_memory32_data = (struct acpi_resource_fixed_mem32 *) data;
+	struct acpi_resource_fixed_mem32    *fixed_memory32_data =
+			   (struct acpi_resource_fixed_mem32 *) data;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -468,15 +514,14 @@ acpi_rs_dump_fixed_memory32 (
 	acpi_os_printf ("32-Bit Fixed Location Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 ACPI_READ_WRITE_MEMORY ==
-			 fixed_memory32_data->read_write_attribute ?
-			 "/Write" : " Only");
+		ACPI_READ_WRITE_MEMORY ==
+			fixed_memory32_data->read_write_attribute ? "/Write" : " Only");
 
 	acpi_os_printf ("  Range base address: %08X\n",
-			 fixed_memory32_data->range_base_address);
+		fixed_memory32_data->range_base_address);
 
 	acpi_os_printf ("  Range length: %08X\n",
-			 fixed_memory32_data->range_length);
+		fixed_memory32_data->range_length);
 
 	return;
 }
@@ -494,7 +539,7 @@ acpi_rs_dump_fixed_memory32 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address16 (
 	union acpi_resource_data        *data)
 {
@@ -514,35 +559,30 @@ acpi_rs_dump_address16 (
 
 		switch (address16_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address16_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address16_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -551,30 +591,26 @@ acpi_rs_dump_address16 (
 
 		switch (address16_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid range attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid range attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address16_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address16_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -589,41 +625,42 @@ acpi_rs_dump_address16 (
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			ACPI_CONSUMER == address16_data->producer_consumer ?
+		ACPI_CONSUMER == address16_data->producer_consumer ?
 			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address16_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address16_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address16_data->min_address_fixed ?
-			 "" : "not");
+		ACPI_ADDRESS_FIXED == address16_data->min_address_fixed ?
+			"" : "not");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address16_data->max_address_fixed ?
-			 "" : "not");
+		ACPI_ADDRESS_FIXED == address16_data->max_address_fixed ?
+			"" : "not");
 
 	acpi_os_printf ("  Granularity: %08X\n",
-			 address16_data->granularity);
+		address16_data->granularity);
 
 	acpi_os_printf ("  Address range min: %08X\n",
-			 address16_data->min_address_range);
+		address16_data->min_address_range);
 
 	acpi_os_printf ("  Address range max: %08X\n",
-			 address16_data->max_address_range);
+		address16_data->max_address_range);
 
 	acpi_os_printf ("  Address translation offset: %08X\n",
-			 address16_data->address_translation_offset);
+		address16_data->address_translation_offset);
 
 	acpi_os_printf ("  Address Length: %08X\n",
-			 address16_data->address_length);
+		address16_data->address_length);
 
 	if (0xFF != address16_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address16_data->resource_source.index);
+			address16_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address16_data->resource_source.string_ptr);
+			address16_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -642,7 +679,7 @@ acpi_rs_dump_address16 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address32 (
 	union acpi_resource_data        *data)
 {
@@ -661,35 +698,30 @@ acpi_rs_dump_address32 (
 
 		switch (address32_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address32_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address32_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -698,30 +730,26 @@ acpi_rs_dump_address32 (
 
 		switch (address32_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid Range attribute");
+			acpi_os_printf ("  Type Specific: Invalid Range attribute");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address32_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address32_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -731,46 +759,48 @@ acpi_rs_dump_address32 (
 
 	default:
 
-		acpi_os_printf ("  Resource Type: 0x%2.2X\n", address32_data->resource_type);
+		acpi_os_printf ("  Resource Type: 0x%2.2X\n",
+			address32_data->resource_type);
 		break;
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == address32_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == address32_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address32_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address32_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address32_data->min_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address32_data->min_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address32_data->max_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address32_data->max_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Granularity: %08X\n",
-			 address32_data->granularity);
+		address32_data->granularity);
 
 	acpi_os_printf ("  Address range min: %08X\n",
-			 address32_data->min_address_range);
+		address32_data->min_address_range);
 
 	acpi_os_printf ("  Address range max: %08X\n",
-			 address32_data->max_address_range);
+		address32_data->max_address_range);
 
 	acpi_os_printf ("  Address translation offset: %08X\n",
-			 address32_data->address_translation_offset);
+		address32_data->address_translation_offset);
 
 	acpi_os_printf ("  Address Length: %08X\n",
-			 address32_data->address_length);
+		address32_data->address_length);
 
 	if(0xFF != address32_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address32_data->resource_source.index);
+			address32_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address32_data->resource_source.string_ptr);
+			address32_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -789,7 +819,7 @@ acpi_rs_dump_address32 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_address64 (
 	union acpi_resource_data        *data)
 {
@@ -808,35 +838,30 @@ acpi_rs_dump_address64 (
 
 		switch (address64_data->attribute.memory.cache_attribute) {
 		case ACPI_NON_CACHEABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Noncacheable memory\n");
+			acpi_os_printf ("  Type Specific: Noncacheable memory\n");
 			break;
 
 		case ACPI_CACHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Cacheable memory\n");
+			acpi_os_printf ("  Type Specific: Cacheable memory\n");
 			break;
 
 		case ACPI_WRITE_COMBINING_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Write-combining memory\n");
+			acpi_os_printf ("  Type Specific: Write-combining memory\n");
 			break;
 
 		case ACPI_PREFETCHABLE_MEMORY:
-			acpi_os_printf ("  Type Specific: "
-					  "Prefetchable memory\n");
+			acpi_os_printf ("  Type Specific: Prefetchable memory\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid cache attribute\n");
+			acpi_os_printf ("  Type Specific: Invalid cache attribute\n");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
 			ACPI_READ_WRITE_MEMORY ==
-			address64_data->attribute.memory.read_write_attribute ?
-			"/Write" : " Only");
+				address64_data->attribute.memory.read_write_attribute ?
+				"/Write" : " Only");
 		break;
 
 	case ACPI_IO_RANGE:
@@ -845,30 +870,26 @@ acpi_rs_dump_address64 (
 
 		switch (address64_data->attribute.io.range_attribute) {
 		case ACPI_NON_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "Non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: Non-ISA Io Addresses\n");
 			break;
 
 		case ACPI_ISA_ONLY_RANGES:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA Io Addresses\n");
 			break;
 
 		case ACPI_ENTIRE_RANGE:
-			acpi_os_printf ("  Type Specific: "
-					  "ISA and non-ISA Io Addresses\n");
+			acpi_os_printf ("  Type Specific: ISA and non-ISA Io Addresses\n");
 			break;
 
 		default:
-			acpi_os_printf ("  Type Specific: "
-					  "Invalid Range attribute");
+			acpi_os_printf ("  Type Specific: Invalid Range attribute");
 			break;
 		}
 
 		acpi_os_printf ("  Type Specific: %s Translation\n",
 			ACPI_SPARSE_TRANSLATION ==
-			address64_data->attribute.io.translation_attribute ?
-			"Sparse" : "Dense");
+				address64_data->attribute.io.translation_attribute ?
+				"Sparse" : "Dense");
 		break;
 
 	case ACPI_BUS_NUMBER_RANGE:
@@ -878,49 +899,51 @@ acpi_rs_dump_address64 (
 
 	default:
 
-		acpi_os_printf ("  Resource Type: 0x%2.2X\n", address64_data->resource_type);
+		acpi_os_printf ("  Resource Type: 0x%2.2X\n",
+			address64_data->resource_type);
 		break;
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == address64_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == address64_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 ACPI_SUB_DECODE == address64_data->decode ?
-			 "Subtractive" : "Positive");
+		ACPI_SUB_DECODE == address64_data->decode ?
+			"Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address64_data->min_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address64_data->min_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ACPI_ADDRESS_FIXED == address64_data->max_address_fixed ?
-			 "" : "not ");
+		ACPI_ADDRESS_FIXED == address64_data->max_address_fixed ?
+			"" : "not ");
 
 	acpi_os_printf ("  Granularity: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->granularity));
+		ACPI_FORMAT_UINT64 (address64_data->granularity));
 
 	acpi_os_printf ("  Address range min: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->min_address_range));
+		ACPI_FORMAT_UINT64 (address64_data->min_address_range));
 
 	acpi_os_printf ("  Address range max: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->max_address_range));
+		ACPI_FORMAT_UINT64 (address64_data->max_address_range));
 
 	acpi_os_printf ("  Address translation offset: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->address_translation_offset));
+		ACPI_FORMAT_UINT64 (address64_data->address_translation_offset));
 
 	acpi_os_printf ("  Address Length: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->address_length));
+		ACPI_FORMAT_UINT64 (address64_data->address_length));
 
 	acpi_os_printf ("  Type Specific Attributes: %8.8X%8.8X\n",
-			 ACPI_FORMAT_UINT64 (address64_data->type_specific_attributes));
+		ACPI_FORMAT_UINT64 (address64_data->type_specific_attributes));
 
 	if (0xFF != address64_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
-				 address64_data->resource_source.index);
+			address64_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s\n",
-				 address64_data->resource_source.string_ptr);
+			address64_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -939,7 +962,7 @@ acpi_rs_dump_address64 (
  *
  ******************************************************************************/
 
-void
+static void
 acpi_rs_dump_extended_irq (
 	union acpi_resource_data        *data)
 {
@@ -953,23 +976,22 @@ acpi_rs_dump_extended_irq (
 	acpi_os_printf ("Extended IRQ Resource\n");
 
 	acpi_os_printf ("  Resource %s\n",
-			 ACPI_CONSUMER == ext_irq_data->producer_consumer ?
-			 "Consumer" : "Producer");
+		ACPI_CONSUMER == ext_irq_data->producer_consumer ?
+			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_LEVEL_SENSITIVE == ext_irq_data->edge_level ?
-			 "Level" : "Edge");
+		ACPI_LEVEL_SENSITIVE == ext_irq_data->edge_level ?
+			"Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACPI_ACTIVE_LOW == ext_irq_data->active_high_low ?
-			 "low" : "high");
+		ACPI_ACTIVE_LOW == ext_irq_data->active_high_low ?
+			"low" : "high");
 
 	acpi_os_printf ("  %s\n",
-			 ACPI_SHARED == ext_irq_data->shared_exclusive ?
-			 "Shared" : "Exclusive");
+		ACPI_SHARED == ext_irq_data->shared_exclusive ?
+			"Shared" : "Exclusive");
 
-	acpi_os_printf ("  Interrupts : %X ( ",
-			 ext_irq_data->number_of_interrupts);
+	acpi_os_printf ("  Interrupts : %X ( ", ext_irq_data->number_of_interrupts);
 
 	for (index = 0; index < ext_irq_data->number_of_interrupts; index++) {
 		acpi_os_printf ("%X ", ext_irq_data->interrupts[index]);
@@ -979,9 +1001,10 @@ acpi_rs_dump_extended_irq (
 
 	if(0xFF != ext_irq_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X",
-				 ext_irq_data->resource_source.index);
+			ext_irq_data->resource_source.index);
+
 		acpi_os_printf ("  Resource Source: %s",
-				 ext_irq_data->resource_source.string_ptr);
+			ext_irq_data->resource_source.string_ptr);
 	}
 
 	return;
@@ -992,7 +1015,7 @@ acpi_rs_dump_extended_irq (
  *
  * FUNCTION:    acpi_rs_dump_resource_list
  *
- * PARAMETERS:  Data            - pointer to the resource structure to dump.
+ * PARAMETERS:  Resource        - pointer to the resource structure to dump.
  *
  * RETURN:      None
  *
@@ -1096,7 +1119,7 @@ acpi_rs_dump_resource_list (
  *
  * FUNCTION:    acpi_rs_dump_irq_list
  *
- * PARAMETERS:  Data            - pointer to the routing table to dump.
+ * PARAMETERS:  route_table     - pointer to the routing table to dump.
  *
  * RETURN:      None
  *
@@ -1124,20 +1147,17 @@ acpi_rs_dump_irq_list (
 			acpi_os_printf ("PCI IRQ Routing Table structure %X.\n", count++);
 
 			acpi_os_printf ("  Address: %8.8X%8.8X\n",
-					 ACPI_FORMAT_UINT64 (prt_element->address));
+				ACPI_FORMAT_UINT64 (prt_element->address));
 
 			acpi_os_printf ("  Pin: %X\n", prt_element->pin);
 
 			acpi_os_printf ("  Source: %s\n", prt_element->source);
 
-			acpi_os_printf ("  source_index: %X\n",
-					 prt_element->source_index);
+			acpi_os_printf ("  source_index: %X\n", prt_element->source_index);
 
 			buffer += prt_element->length;
-
 			prt_element = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
-
-			if(0 == prt_element->length) {
+			if (0 == prt_element->length) {
 				done = TRUE;
 			}
 		}
diff --git a/drivers/acpi/resources/rsio.c b/drivers/acpi/resources/rsio.c
--- a/drivers/acpi/resources/rsio.c
+++ b/drivers/acpi/resources/rsio.c
@@ -81,67 +81,60 @@ acpi_rs_io_resource (
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_io);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_io);
 
 
 	ACPI_FUNCTION_TRACE ("rs_io_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 8;
 
 	output_struct->id = ACPI_RSTYPE_IO;
 
-	/*
-	 * Check Decode
-	 */
+	/* Check Decode */
+
 	buffer += 1;
 	temp8 = *buffer;
 
 	output_struct->data.io.io_decode = temp8 & 0x01;
 
-	/*
-	 * Check min_base Address
-	 */
+	/* Check min_base Address */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.min_base_address = temp16;
 
-	/*
-	 * Check max_base Address
-	 */
+	/* Check max_base Address */
+
 	buffer += 2;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.max_base_address = temp16;
 
-	/*
-	 * Check Base alignment
-	 */
+	/* Check Base alignment */
+
 	buffer += 2;
 	temp8 = *buffer;
 
 	output_struct->data.io.alignment = temp8;
 
-	/*
-	 * Check range_length
-	 */
+	/* Check range_length */
+
 	buffer += 1;
 	temp8 = *buffer;
 
 	output_struct->data.io.range_length = temp8;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -179,43 +172,39 @@ acpi_rs_fixed_io_resource (
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_io);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_fixed_io);
 
 
 	ACPI_FUNCTION_TRACE ("rs_fixed_io_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 4;
 
 	output_struct->id = ACPI_RSTYPE_FIXED_IO;
 
-	/*
-	 * Check Range Base Address
-	 */
+	/* Check Range Base Address */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.fixed_io.base_address = temp16;
 
-	/*
-	 * Check range_length
-	 */
+	/* Check range_length */
+
 	buffer += 2;
 	temp8 = *buffer;
 
 	output_struct->data.fixed_io.range_length = temp8;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -251,55 +240,48 @@ acpi_rs_io_stream (
 	ACPI_FUNCTION_TRACE ("rs_io_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x47;
 	buffer += 1;
 
-	/*
-	 * Io Information Byte
-	 */
+	/* Io Information Byte */
+
 	temp8 = (u8) (linked_list->data.io.io_decode & 0x01);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	temp16 = (u16) linked_list->data.io.min_base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	temp16 = (u16) linked_list->data.io.max_base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	temp8 = (u8) linked_list->data.io.alignment;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	temp8 = (u8) linked_list->data.io.range_length;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -335,32 +317,28 @@ acpi_rs_fixed_io_stream (
 	ACPI_FUNCTION_TRACE ("rs_fixed_io_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x4B;
 
 	buffer += 1;
 
-	/*
-	 * Set the Range base address
-	 */
+	/* Set the Range base address */
+
 	temp16 = (u16) linked_list->data.fixed_io.base_address;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	temp8 = (u8) linked_list->data.fixed_io.range_length;
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -399,21 +377,20 @@ acpi_rs_dma_resource (
 	u8                              temp8 = 0;
 	u8                              index;
 	u8                              i;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_dma);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_dma);
 
 
 	ACPI_FUNCTION_TRACE ("rs_dma_resource");
 
 
-	/*
-	 * The number of bytes consumed are Constant
-	 */
+	/* The number of bytes consumed are Constant */
+
 	*bytes_consumed = 3;
 	output_struct->id = ACPI_RSTYPE_DMA;
 
-	/*
-	 * Point to the 8-bits of Byte 1
-	 */
+	/* Point to the 8-bits of Byte 1 */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -430,46 +407,40 @@ acpi_rs_dma_resource (
 
 	output_struct->data.dma.number_of_channels = i;
 	if (i > 0) {
-		/*
-		 * Calculate the structure size based upon the number of interrupts
-		 */
+		/* Calculate the structure size based upon the number of interrupts */
+
 		struct_size += ((acpi_size) i - 1) * 4;
 	}
 
-	/*
-	 * Point to Byte 2
-	 */
+	/* Point to Byte 2 */
+
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Check for transfer preference (Bits[1:0])
-	 */
+	/* Check for transfer preference (Bits[1:0]) */
+
 	output_struct->data.dma.transfer = temp8 & 0x03;
 
 	if (0x03 == output_struct->data.dma.transfer) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid DMA.Transfer preference (3)\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Invalid DMA.Transfer preference (3)\n"));
 		return_ACPI_STATUS (AE_BAD_DATA);
 	}
 
-	/*
-	 * Get bus master preference (Bit[2])
-	 */
+	/* Get bus master preference (Bit[2]) */
+
 	output_struct->data.dma.bus_master = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Get channel speed support (Bits[6:5])
-	 */
+	/* Get channel speed support (Bits[6:5]) */
+
 	output_struct->data.dma.type = (temp8 >> 5) & 0x03;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -506,16 +477,14 @@ acpi_rs_dma_stream (
 	ACPI_FUNCTION_TRACE ("rs_dma_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x2A;
 	buffer += 1;
 	temp8 = 0;
 
-	/*
-	 * Loop through all of the Channels and set the mask bits
-	 */
+	/* Loop through all of the Channels and set the mask bits */
+
 	for (index = 0;
 		 index < linked_list->data.dma.number_of_channels;
 		 index++) {
@@ -526,9 +495,8 @@ acpi_rs_dma_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the DMA Info
-	 */
+	/* Set the DMA Info */
+
 	temp8 = (u8) ((linked_list->data.dma.type & 0x03) << 5);
 	temp8 |= ((linked_list->data.dma.bus_master & 0x01) << 2);
 	temp8 |= (linked_list->data.dma.transfer & 0x03);
@@ -536,9 +504,8 @@ acpi_rs_dma_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff --git a/drivers/acpi/resources/rsirq.c b/drivers/acpi/resources/rsirq.c
--- a/drivers/acpi/resources/rsirq.c
+++ b/drivers/acpi/resources/rsirq.c
@@ -83,7 +83,8 @@ acpi_rs_irq_resource (
 	u8                              temp8 = 0;
 	u8                              index;
 	u8                              i;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_irq);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_irq);
 
 
 	ACPI_FUNCTION_TRACE ("rs_irq_resource");
@@ -91,15 +92,14 @@ acpi_rs_irq_resource (
 
 	/*
 	 * The number of bytes consumed are contained in the descriptor
-	 *  (Bits:0-1)
+	 * (Bits:0-1)
 	 */
 	temp8 = *buffer;
 	*bytes_consumed = (temp8 & 0x03) + 1;
 	output_struct->id = ACPI_RSTYPE_IRQ;
 
-	/*
-	 * Point to the 16-bits of Bytes 1 and 2
-	 */
+	/* Point to the 16-bits of Bytes 1 and 2 */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -118,22 +118,19 @@ acpi_rs_irq_resource (
 
 	output_struct->data.irq.number_of_interrupts = i;
 	if (i > 0) {
-		/*
-		 * Calculate the structure size based upon the number of interrupts
-		 */
+		/* Calculate the structure size based upon the number of interrupts */
+
 		struct_size += ((acpi_size) i - 1) * 4;
 	}
 
-	/*
-	 * Point to Byte 3 if it is used
-	 */
+	/* Point to Byte 3 if it is used */
+
 	if (4 == *bytes_consumed) {
 		buffer += 2;
 		temp8 = *buffer;
 
-		/*
-		 * Check for HE, LL interrupts
-		 */
+		/* Check for HE, LL interrupts */
+
 		switch (temp8 & 0x09) {
 		case 0x01: /* HE */
 			output_struct->data.irq.edge_level = ACPI_EDGE_SENSITIVE;
@@ -152,13 +149,13 @@ acpi_rs_irq_resource (
 			 * so 0x00 and 0x09 are illegal.
 			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Invalid interrupt polarity/trigger in resource list, %X\n", temp8));
+				"Invalid interrupt polarity/trigger in resource list, %X\n",
+				temp8));
 			return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		/*
-		 * Check for sharable
-		 */
+		/* Check for sharable */
+
 		output_struct->data.irq.shared_exclusive = (temp8 >> 3) & 0x01;
 	}
 	else {
@@ -171,14 +168,12 @@ acpi_rs_irq_resource (
 		output_struct->data.irq.shared_exclusive = ACPI_EXCLUSIVE;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -234,9 +229,8 @@ acpi_rs_irq_stream (
 	buffer += 1;
 	temp16 = 0;
 
-	/*
-	 * Loop through all of the interrupts and set the mask bits
-	 */
+	/* Loop through all of the interrupts and set the mask bits */
+
 	for(index = 0;
 		index < linked_list->data.irq.number_of_interrupts;
 		index++) {
@@ -247,9 +241,8 @@ acpi_rs_irq_stream (
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the IRQ Info byte if needed.
-	 */
+	/* Set the IRQ Info byte if needed. */
+
 	if (IRqinfo_byte_needed) {
 		temp8 = 0;
 		temp8 = (u8) ((linked_list->data.irq.shared_exclusive &
@@ -267,9 +260,8 @@ acpi_rs_irq_stream (
 		buffer += 1;
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -309,15 +301,15 @@ acpi_rs_extended_irq_resource (
 	u8                              temp8 = 0;
 	u8                              *temp_ptr;
 	u8                              index;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_ext_irq);
 
 
 	ACPI_FUNCTION_TRACE ("rs_extended_irq_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -330,9 +322,8 @@ acpi_rs_extended_irq_resource (
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_EXT_IRQ;
 
-	/*
-	 * Point to the Byte3
-	 */
+	/* Point to the Byte3 */
+
 	buffer += 2;
 	temp8 = *buffer;
 
@@ -347,21 +338,18 @@ acpi_rs_extended_irq_resource (
 	 * - Edge/Level are defined opposite in the table vs the headers
 	 */
 	output_struct->data.extended_irq.edge_level =
-			   (temp8 & 0x2) ? ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
+		(temp8 & 0x2) ? ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
+
+	/* Check Interrupt Polarity */
 
-	/*
-	 * Check Interrupt Polarity
-	 */
 	output_struct->data.extended_irq.active_high_low = (temp8 >> 2) & 0x1;
 
-	/*
-	 * Check for sharable
-	 */
+	/* Check for sharable */
+
 	output_struct->data.extended_irq.shared_exclusive = (temp8 >> 3) & 0x01;
 
-	/*
-	 * Point to Byte4 (IRQ Table length)
-	 */
+	/* Point to Byte4 (IRQ Table length) */
+
 	buffer += 1;
 	temp8 = *buffer;
 
@@ -379,14 +367,12 @@ acpi_rs_extended_irq_resource (
 	 */
 	struct_size += (temp8 - 1) * 4;
 
-	/*
-	 * Point to Byte5 (First IRQ Number)
-	 */
+	/* Point to Byte5 (First IRQ Number) */
+
 	buffer += 1;
 
-	/*
-	 * Cycle through every IRQ in the table
-	 */
+	/* Cycle through every IRQ in the table */
+
 	for (index = 0; index < temp8; index++) {
 		ACPI_MOVE_32_TO_32 (
 			&output_struct->data.extended_irq.interrupts[index], buffer);
@@ -407,7 +393,8 @@ acpi_rs_extended_irq_resource (
 	 * we add 1 to the length.
 	 */
 	if (*bytes_consumed >
-		((acpi_size) output_struct->data.extended_irq.number_of_interrupts * 4) + (5 + 1)) {
+		((acpi_size) output_struct->data.extended_irq.number_of_interrupts * 4) +
+		(5 + 1)) {
 		/* Dereference the Index */
 
 		temp8 = *buffer;
@@ -417,13 +404,13 @@ acpi_rs_extended_irq_resource (
 
 		buffer += 1;
 
-		/*
-		 * Point the String pointer to the end of this structure.
-		 */
+		/* Point the String pointer to the end of this structure. */
+
 		output_struct->data.extended_irq.resource_source.string_ptr =
 				(char *)((char *) output_struct + struct_size);
 
-		temp_ptr = (u8 *) output_struct->data.extended_irq.resource_source.string_ptr;
+		temp_ptr = (u8 *)
+			output_struct->data.extended_irq.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -436,9 +423,8 @@ acpi_rs_extended_irq_resource (
 			index += 1;
 		}
 
-		/*
-		 * Add the terminating null
-		 */
+		/* Add the terminating null */
+
 		*temp_ptr = 0x00;
 		output_struct->data.extended_irq.resource_source.string_length = index + 1;
 
@@ -456,14 +442,12 @@ acpi_rs_extended_irq_resource (
 		output_struct->data.extended_irq.resource_source.string_ptr = NULL;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -501,21 +485,18 @@ acpi_rs_extended_irq_stream (
 	ACPI_FUNCTION_TRACE ("rs_extended_irq_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x89;
 	buffer += 1;
 
-	/*
-	 * Set a pointer to the Length field - to be filled in later
-	 */
+	/* Set a pointer to the Length field - to be filled in later */
+
 	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
-	/*
-	 * Set the Interrupt vector flags
-	 */
+	/* Set the Interrupt vector flags */
+
 	temp8 = (u8)(linked_list->data.extended_irq.producer_consumer & 0x01);
 	temp8 |= ((linked_list->data.extended_irq.shared_exclusive & 0x01) << 3);
 
@@ -532,17 +513,15 @@ acpi_rs_extended_irq_stream (
 		temp8 |= 0x2;
 	}
 
-	/*
-	 * Set the Interrupt Polarity
-	 */
+	/* Set the Interrupt Polarity */
+
 	temp8 |= ((linked_list->data.extended_irq.active_high_low & 0x1) << 2);
 
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Interrupt table length
-	 */
+	/* Set the Interrupt table length */
+
 	temp8 = (u8) linked_list->data.extended_irq.number_of_interrupts;
 
 	*buffer = temp8;
@@ -555,18 +534,16 @@ acpi_rs_extended_irq_stream (
 		buffer += 4;
 	}
 
-	/*
-	 * Resource Source Index and Resource Source are optional
-	 */
+	/* Resource Source Index and Resource Source are optional */
+
 	if (0 != linked_list->data.extended_irq.resource_source.string_length) {
 		*buffer = (u8) linked_list->data.extended_irq.resource_source.index;
 		buffer += 1;
 
 		temp_pointer = (char *) buffer;
 
-		/*
-		 * Copy the string
-		 */
+		/* Copy the string */
+
 		ACPI_STRCPY (temp_pointer,
 			linked_list->data.extended_irq.resource_source.string_ptr);
 
@@ -574,12 +551,12 @@ acpi_rs_extended_irq_stream (
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.extended_irq.resource_source.string_ptr) + 1);
+		buffer += (acpi_size) (ACPI_STRLEN (
+			linked_list->data.extended_irq.resource_source.string_ptr) + 1);
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
diff --git a/drivers/acpi/resources/rslist.c b/drivers/acpi/resources/rslist.c
--- a/drivers/acpi/resources/rslist.c
+++ b/drivers/acpi/resources/rslist.c
@@ -55,7 +55,7 @@
  *
  * PARAMETERS:  resource_start_byte     - Byte 0 of a resource descriptor
  *
- * RETURN:      The Resource Type (Name) with no extraneous bits
+ * RETURN:      The Resource Type with no extraneous bits
  *
  * DESCRIPTION: Extract the Resource Type/Name from the first byte of
  *              a resource descriptor.
@@ -70,28 +70,25 @@ acpi_rs_get_resource_type (
 	ACPI_FUNCTION_ENTRY ();
 
 
-	/*
-	 * Determine if this is a small or large resource
-	 */
+	/* Determine if this is a small or large resource */
+
 	switch (resource_start_byte & ACPI_RDESC_TYPE_MASK) {
 	case ACPI_RDESC_TYPE_SMALL:
 
-		/*
-		 * Small Resource Type -- Only bits 6:3 are valid
-		 */
+		/* Small Resource Type -- Only bits 6:3 are valid */
+
 		return ((u8) (resource_start_byte & ACPI_RDESC_SMALL_MASK));
 
 
 	case ACPI_RDESC_TYPE_LARGE:
 
-		/*
-		 * Large Resource Type -- All bits are valid
-		 */
+		/* Large Resource Type -- All bits are valid */
+
 		return (resource_start_byte);
 
 
 	default:
-		/* No other types of resource descriptor */
+		/* Invalid type */
 		break;
 	}
 
@@ -135,9 +132,8 @@ acpi_rs_byte_stream_to_list (
 
 	while (bytes_parsed < byte_stream_buffer_length &&
 			!end_tag_processed) {
-		/*
-		 * The next byte in the stream is the resource type
-		 */
+		/* The next byte in the stream is the resource type */
+
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
@@ -299,28 +295,23 @@ acpi_rs_byte_stream_to_list (
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Update the return value and counter
-		 */
+		/* Update the return value and counter */
+
 		bytes_parsed += bytes_consumed;
 
-		/*
-		 * Set the byte stream to point to the next resource
-		 */
+		/* Set the byte stream to point to the next resource */
+
 		byte_stream_buffer += bytes_consumed;
 
-		/*
-		 * Set the Buffer to the next structure
-		 */
+		/* Set the Buffer to the next structure */
+
 		resource = ACPI_CAST_PTR (struct acpi_resource, buffer);
 		resource->length = (u32) ACPI_ALIGN_RESOURCE_SIZE (resource->length);
 		buffer += ACPI_ALIGN_RESOURCE_SIZE (structure_size);
+	}
 
-	} /*  end while */
+	/* Check the reason for exiting the while loop */
 
-	/*
-	 * Check the reason for exiting the while loop
-	 */
 	if (!end_tag_processed) {
 		return_ACPI_STATUS (AE_AML_NO_RESOURCE_END_TAG);
 	}
@@ -424,9 +415,8 @@ acpi_rs_list_to_byte_stream (
 			 */
 			status = acpi_rs_end_tag_stream (linked_list, &buffer, &bytes_consumed);
 
-			/*
-			 * An End Tag indicates the end of the Resource Template
-			 */
+			/* An End Tag indicates the end of the Resource Template */
+
 			done = TRUE;
 			break;
 
@@ -488,27 +478,25 @@ acpi_rs_list_to_byte_stream (
 		default:
 			/*
 			 * If we get here, everything is out of sync,
-			 *  so exit with an error
+			 * so exit with an error
 			 */
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid descriptor type (%X) in resource list\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Invalid descriptor type (%X) in resource list\n",
 				linked_list->id));
 			status = AE_BAD_DATA;
 			break;
-
-		} /* switch (linked_list->Id) */
+		}
 
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Set the Buffer to point to the open byte
-		 */
+		/* Set the Buffer to point to the open byte */
+
 		buffer += bytes_consumed;
 
-		/*
-		 * Point to the next object
-		 */
+		/* Point to the next object */
+
 		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
diff --git a/drivers/acpi/resources/rsmemory.c b/drivers/acpi/resources/rsmemory.c
--- a/drivers/acpi/resources/rsmemory.c
+++ b/drivers/acpi/resources/rsmemory.c
@@ -81,15 +81,15 @@ acpi_rs_memory24_resource (
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem24);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_mem24);
 
 
 	ACPI_FUNCTION_TRACE ("rs_memory24_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
@@ -97,48 +97,41 @@ acpi_rs_memory24_resource (
 	*bytes_consumed = (acpi_size) temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_MEM24;
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 	output_struct->data.memory24.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get min_base_address (Bytes 4-5)
-	 */
+	/* Get min_base_address (Bytes 4-5) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.min_base_address = temp16;
 
-	/*
-	 * Get max_base_address (Bytes 6-7)
-	 */
+	/* Get max_base_address (Bytes 6-7) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.max_base_address = temp16;
 
-	/*
-	 * Get Alignment (Bytes 8-9)
-	 */
+	/* Get Alignment (Bytes 8-9) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.alignment = temp16;
 
-	/*
-	 * Get range_length (Bytes 10-11)
-	 */
+	/* Get range_length (Bytes 10-11) */
+
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	output_struct->data.memory24.range_length = temp16;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -174,53 +167,45 @@ acpi_rs_memory24_stream (
 	ACPI_FUNCTION_TRACE ("rs_memory24_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x81;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x09;
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.memory24.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.min_base_address);
 	buffer += 2;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.max_base_address);
 	buffer += 2;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.alignment);
 	buffer += 2;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.range_length);
 	buffer += 2;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -258,15 +243,15 @@ acpi_rs_memory32_range_resource (
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem32);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_mem32);
 
 
 	ACPI_FUNCTION_TRACE ("rs_memory32_range_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
@@ -285,45 +270,38 @@ acpi_rs_memory32_range_resource (
 	 *  4 * sizeof(RESOURCE_DATA) instead of 4 * sizeof(u8)
 	 */
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 
 	output_struct->data.memory32.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get min_base_address (Bytes 4-7)
-	 */
+	/* Get min_base_address (Bytes 4-7) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.min_base_address, buffer);
 	buffer += 4;
 
-	/*
-	 * Get max_base_address (Bytes 8-11)
-	 */
+	/* Get max_base_address (Bytes 8-11) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.max_base_address, buffer);
 	buffer += 4;
 
-	/*
-	 * Get Alignment (Bytes 12-15)
-	 */
+	/* Get Alignment (Bytes 12-15) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.alignment, buffer);
 	buffer += 4;
 
-	/*
-	 * Get range_length (Bytes 16-19)
-	 */
+	/* Get range_length (Bytes 16-19) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.range_length, buffer);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -361,15 +339,15 @@ acpi_rs_fixed_memory32_resource (
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_mem32);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_fixed_mem32);
 
 
 	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_resource");
 
 
-	/*
-	 * Point past the Descriptor to get the number of bytes consumed
-	 */
+	/* Point past the Descriptor to get the number of bytes consumed */
+
 	buffer += 1;
 	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
@@ -378,32 +356,28 @@ acpi_rs_fixed_memory32_resource (
 
 	output_struct->id = ACPI_RSTYPE_FIXED_MEM32;
 
-	/*
-	 * Check Byte 3 the Read/Write bit
-	 */
+	/* Check Byte 3 the Read/Write bit */
+
 	temp8 = *buffer;
 	buffer += 1;
 	output_struct->data.fixed_memory32.read_write_attribute = temp8 & 0x01;
 
-	/*
-	 * Get range_base_address (Bytes 4-7)
-	 */
-	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_base_address, buffer);
+	/* Get range_base_address (Bytes 4-7) */
+
+	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_base_address,
+		buffer);
 	buffer += 4;
 
-	/*
-	 * Get range_length (Bytes 8-11)
-	 */
+	/* Get range_length (Bytes 8-11) */
+
 	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_length, buffer);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -439,54 +413,46 @@ acpi_rs_memory32_range_stream (
 	ACPI_FUNCTION_TRACE ("rs_memory32_range_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x85;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x11;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.memory32.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range minimum base address
-	 */
+	/* Set the Range minimum base address */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.min_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the Range maximum base address
-	 */
+	/* Set the Range maximum base address */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.max_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the base alignment
-	 */
+	/* Set the base alignment */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.alignment);
 	buffer += 4;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.range_length);
 	buffer += 4;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -522,44 +488,38 @@ acpi_rs_fixed_memory32_stream (
 	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x86;
 	buffer += 1;
 
-	/*
-	 * The length field is static
-	 */
+	/* The length field is static */
+
 	temp16 = 0x09;
 
 	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
-	/*
-	 * Set the Information Byte
-	 */
+	/* Set the Information Byte */
+
 	temp8 = (u8) (linked_list->data.fixed_memory32.read_write_attribute & 0x01);
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Set the Range base address
-	 */
+	/* Set the Range base address */
+
 	ACPI_MOVE_32_TO_32 (buffer,
-			 &linked_list->data.fixed_memory32.range_base_address);
+		&linked_list->data.fixed_memory32.range_base_address);
 	buffer += 4;
 
-	/*
-	 * Set the range length
-	 */
+	/* Set the range length */
+
 	ACPI_MOVE_32_TO_32 (buffer,
-			 &linked_list->data.fixed_memory32.range_length);
+		&linked_list->data.fixed_memory32.range_length);
 	buffer += 4;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff --git a/drivers/acpi/resources/rsmisc.c b/drivers/acpi/resources/rsmisc.c
--- a/drivers/acpi/resources/rsmisc.c
+++ b/drivers/acpi/resources/rsmisc.c
@@ -84,24 +84,20 @@ acpi_rs_end_tag_resource (
 	ACPI_FUNCTION_TRACE ("rs_end_tag_resource");
 
 
-	/*
-	 * The number of bytes consumed is static
-	 */
+	/* The number of bytes consumed is static */
+
 	*bytes_consumed = 2;
 
-	/*
-	 *  Fill out the structure
-	 */
+	/*  Fill out the structure */
+
 	output_struct->id = ACPI_RSTYPE_END_TAG;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = 0;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -136,9 +132,8 @@ acpi_rs_end_tag_stream (
 	ACPI_FUNCTION_TRACE ("rs_end_tag_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x79;
 	buffer += 1;
 
@@ -151,9 +146,8 @@ acpi_rs_end_tag_stream (
 	*buffer = temp8;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -192,21 +186,20 @@ acpi_rs_vendor_resource (
 	u16                             temp16 = 0;
 	u8                              temp8 = 0;
 	u8                              index;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_vendor);
 
 
 	ACPI_FUNCTION_TRACE ("rs_vendor_resource");
 
 
-	/*
-	 * Dereference the Descriptor to find if this is a large or small item.
-	 */
+	/* Dereference the Descriptor to find if this is a large or small item. */
+
 	temp8 = *buffer;
 
 	if (temp8 & 0x80) {
-		/*
-		 * Large Item, point to the length field
-		 */
+		/* Large Item, point to the length field */
+
 		buffer += 1;
 
 		/* Dereference */
@@ -222,9 +215,8 @@ acpi_rs_vendor_resource (
 		buffer += 2;
 	}
 	else {
-		/*
-		 * Small Item, dereference the size
-		 */
+		/* Small Item, dereference the size */
+
 		temp16 = (u8)(*buffer & 0x07);
 
 		/* Calculate bytes consumed */
@@ -251,14 +243,12 @@ acpi_rs_vendor_resource (
 	 */
 	struct_size += ACPI_ROUND_UP_to_32_bITS (temp16);
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -295,13 +285,11 @@ acpi_rs_vendor_stream (
 	ACPI_FUNCTION_TRACE ("rs_vendor_stream");
 
 
-	/*
-	 * Dereference the length to find if this is a large or small item.
-	 */
+	/* Dereference the length to find if this is a large or small item. */
+
 	if(linked_list->data.vendor_specific.length > 7) {
-		/*
-		 * Large Item, Set the descriptor field and length bytes
-		 */
+		/* Large Item, Set the descriptor field and length bytes */
+
 		*buffer = 0x84;
 		buffer += 1;
 
@@ -311,9 +299,8 @@ acpi_rs_vendor_stream (
 		buffer += 2;
 	}
 	else {
-		/*
-		 * Small Item, Set the descriptor field
-		 */
+		/* Small Item, Set the descriptor field */
+
 		temp8 = 0x70;
 		temp8 |= (u8) linked_list->data.vendor_specific.length;
 
@@ -321,9 +308,8 @@ acpi_rs_vendor_stream (
 		buffer += 1;
 	}
 
-	/*
-	 * Loop through all of the Vendor Specific fields
-	 */
+	/* Loop through all of the Vendor Specific fields */
+
 	for (index = 0; index < linked_list->data.vendor_specific.length; index++) {
 		temp8 = linked_list->data.vendor_specific.reserved[index];
 
@@ -331,9 +317,8 @@ acpi_rs_vendor_stream (
 		buffer += 1;
 	}
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -370,40 +355,37 @@ acpi_rs_start_depend_fns_resource (
 	u8                              *buffer = byte_stream_buffer;
 	struct acpi_resource            *output_struct = (void *) *output_buffer;
 	u8                              temp8 = 0;
-	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_start_dpf);
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (
+			  struct acpi_resource_start_dpf);
 
 
 	ACPI_FUNCTION_TRACE ("rs_start_depend_fns_resource");
 
 
-	/*
-	 * The number of bytes consumed are contained in the descriptor (Bits:0-1)
-	 */
+	/* The number of bytes consumed are found in the descriptor (Bits:0-1) */
+
 	temp8 = *buffer;
 
 	*bytes_consumed = (temp8 & 0x01) + 1;
 
 	output_struct->id = ACPI_RSTYPE_START_DPF;
 
-	/*
-	 * Point to Byte 1 if it is used
-	 */
+	/* Point to Byte 1 if it is used */
+
 	if (2 == *bytes_consumed) {
 		buffer += 1;
 		temp8 = *buffer;
 
-		/*
-		 * Check Compatibility priority
-		 */
+		/* Check Compatibility priority */
+
 		output_struct->data.start_dpf.compatibility_priority = temp8 & 0x03;
 
 		if (3 == output_struct->data.start_dpf.compatibility_priority) {
 			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 
-		/*
-		 * Check Performance/Robustness preference
-		 */
+		/* Check Performance/Robustness preference */
+
 		output_struct->data.start_dpf.performance_robustness = (temp8 >> 2) & 0x03;
 
 		if (3 == output_struct->data.start_dpf.performance_robustness) {
@@ -412,20 +394,18 @@ acpi_rs_start_depend_fns_resource (
 	}
 	else {
 		output_struct->data.start_dpf.compatibility_priority =
-				ACPI_ACCEPTABLE_CONFIGURATION;
+			ACPI_ACCEPTABLE_CONFIGURATION;
 
 		output_struct->data.start_dpf.performance_robustness =
-				ACPI_ACCEPTABLE_CONFIGURATION;
+			ACPI_ACCEPTABLE_CONFIGURATION;
 	}
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -466,24 +446,20 @@ acpi_rs_end_depend_fns_resource (
 	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_resource");
 
 
-	/*
-	 * The number of bytes consumed is static
-	 */
+	/* The number of bytes consumed is static */
+
 	*bytes_consumed = 1;
 
-	/*
-	 *  Fill out the structure
-	 */
+	/*  Fill out the structure */
+
 	output_struct->id = ACPI_RSTYPE_END_DPF;
 
-	/*
-	 * Set the Length parameter
-	 */
+	/* Set the Length parameter */
+
 	output_struct->length = (u32) struct_size;
 
-	/*
-	 * Return the final size of the structure
-	 */
+	/* Return the final size of the structure */
+
 	*structure_size = struct_size;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -533,9 +509,8 @@ acpi_rs_start_depend_fns_stream (
 		*buffer = 0x31;
 		buffer += 1;
 
-		/*
-		 * Set the Priority Byte Definition
-		 */
+		/* Set the Priority Byte Definition */
+
 		temp8 = 0;
 		temp8 = (u8) ((linked_list->data.start_dpf.performance_robustness &
 				   0x03) << 2);
@@ -546,9 +521,8 @@ acpi_rs_start_depend_fns_stream (
 
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
@@ -582,15 +556,13 @@ acpi_rs_end_depend_fns_stream (
 	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_stream");
 
 
-	/*
-	 * The descriptor field is static
-	 */
+	/* The descriptor field is static */
+
 	*buffer = 0x38;
 	buffer += 1;
 
-	/*
-	 * Return the number of bytes consumed in this operation
-	 */
+	/* Return the number of bytes consumed in this operation */
+
 	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
diff --git a/drivers/acpi/resources/rsutils.c b/drivers/acpi/resources/rsutils.c
--- a/drivers/acpi/resources/rsutils.c
+++ b/drivers/acpi/resources/rsutils.c
@@ -83,10 +83,10 @@ acpi_rs_get_prt_method_data (
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_PRT", ACPI_BTYPE_PACKAGE, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__PRT,
+			 ACPI_BTYPE_PACKAGE, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -136,10 +136,10 @@ acpi_rs_get_crs_method_data (
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_CRS", ACPI_BTYPE_BUFFER, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__CRS,
+			 ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -175,6 +175,7 @@ acpi_rs_get_crs_method_data (
  *              and the contents of the callers buffer is undefined.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_rs_get_prs_method_data (
@@ -190,10 +191,10 @@ acpi_rs_get_prs_method_data (
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
-	status = acpi_ut_evaluate_object (handle, "_PRS", ACPI_BTYPE_BUFFER, &obj_desc);
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object (handle, METHOD_NAME__PRS,
+			 ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -218,6 +219,7 @@ acpi_rs_get_prs_method_data (
  * FUNCTION:    acpi_rs_get_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
+ *              Path            - Path to method, relative to Handle
  *              ret_buffer      - a pointer to a buffer structure for the
  *                                  results
  *
@@ -246,9 +248,8 @@ acpi_rs_get_method_data (
 
 	/* Parameters guaranteed valid by caller */
 
-	/*
-	 * Execute the method, no parameters
-	 */
+	/* Execute the method, no parameters */
+
 	status = acpi_ut_evaluate_object (handle, path, ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -314,18 +315,16 @@ acpi_rs_set_srs_method_data (
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Init the param object
-	 */
+	/* Init the param object */
+
 	params[0] = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 	if (!params[0]) {
 		acpi_os_free (buffer.pointer);
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Set up the parameter object
-	 */
+	/* Set up the parameter object */
+
 	params[0]->buffer.length  = (u32) buffer.length;
 	params[0]->buffer.pointer = buffer.pointer;
 	params[0]->common.flags   = AOPOBJ_DATA_VALID;
@@ -335,10 +334,9 @@ acpi_rs_set_srs_method_data (
 	info.parameters = params;
 	info.parameter_type = ACPI_PARAM_ARGS;
 
-	/*
-	 * Execute the method, no return value
-	 */
-	status = acpi_ns_evaluate_relative ("_SRS", &info);
+	/* Execute the method, no return value */
+
+	status = acpi_ns_evaluate_relative (METHOD_NAME__SRS, &info);
 	if (ACPI_SUCCESS (status)) {
 		/* Delete any return object (especially if implicit_return is enabled) */
 
@@ -347,9 +345,8 @@ acpi_rs_set_srs_method_data (
 		}
 	}
 
-	/*
-	 * Clean up and return the status from acpi_ns_evaluate_relative
-	 */
+	/* Clean up and return the status from acpi_ns_evaluate_relative */
+
 	acpi_ut_remove_reference (params[0]);
 	return_ACPI_STATUS (status);
 }
diff --git a/drivers/acpi/resources/rsxface.c b/drivers/acpi/resources/rsxface.c
--- a/drivers/acpi/resources/rsxface.c
+++ b/drivers/acpi/resources/rsxface.c
@@ -49,6 +49,23 @@
 #define _COMPONENT          ACPI_RESOURCES
 	 ACPI_MODULE_NAME    ("rsxface")
 
+/* Local macros for 16,32-bit to 64-bit conversion */
+
+#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
+#define ACPI_COPY_ADDRESS(out, in)                      \
+	ACPI_COPY_FIELD(out, in, resource_type);             \
+	ACPI_COPY_FIELD(out, in, producer_consumer);         \
+	ACPI_COPY_FIELD(out, in, decode);                    \
+	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, attribute);                 \
+	ACPI_COPY_FIELD(out, in, granularity);               \
+	ACPI_COPY_FIELD(out, in, min_address_range);         \
+	ACPI_COPY_FIELD(out, in, max_address_range);         \
+	ACPI_COPY_FIELD(out, in, address_translation_offset); \
+	ACPI_COPY_FIELD(out, in, address_length);            \
+	ACPI_COPY_FIELD(out, in, resource_source);
+
 
 /*******************************************************************************
  *
@@ -180,6 +197,7 @@ EXPORT_SYMBOL(acpi_get_current_resources
  *              and the value of ret_buffer is undefined.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
 acpi_get_possible_resources (
@@ -346,9 +364,8 @@ acpi_set_current_resources (
 	ACPI_FUNCTION_TRACE ("acpi_set_current_resources");
 
 
-	/*
-	 * Must have a valid handle and buffer
-	 */
+	/* Must have a valid handle and buffer */
+
 	if ((!device_handle)      ||
 		(!in_buffer)          ||
 		(!in_buffer->pointer) ||
@@ -362,21 +379,6 @@ acpi_set_current_resources (
 EXPORT_SYMBOL(acpi_set_current_resources);
 
 
-#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
-#define ACPI_COPY_ADDRESS(out, in)                      \
-	ACPI_COPY_FIELD(out, in, resource_type);             \
-	ACPI_COPY_FIELD(out, in, producer_consumer);         \
-	ACPI_COPY_FIELD(out, in, decode);                    \
-	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
-	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
-	ACPI_COPY_FIELD(out, in, attribute);                 \
-	ACPI_COPY_FIELD(out, in, granularity);               \
-	ACPI_COPY_FIELD(out, in, min_address_range);         \
-	ACPI_COPY_FIELD(out, in, max_address_range);         \
-	ACPI_COPY_FIELD(out, in, address_translation_offset); \
-	ACPI_COPY_FIELD(out, in, address_length);            \
-	ACPI_COPY_FIELD(out, in, resource_source);
-
 /******************************************************************************
  *
  * FUNCTION:    acpi_resource_to_address64
@@ -408,14 +410,14 @@ acpi_resource_to_address64 (
 	case ACPI_RSTYPE_ADDRESS16:
 
 		address16 = (struct acpi_resource_address16 *) &resource->data;
-		ACPI_COPY_ADDRESS(out, address16);
+		ACPI_COPY_ADDRESS (out, address16);
 		break;
 
 
 	case ACPI_RSTYPE_ADDRESS32:
 
 		address32 = (struct acpi_resource_address32 *) &resource->data;
-		ACPI_COPY_ADDRESS(out, address32);
+		ACPI_COPY_ADDRESS (out, address32);
 		break;
 
 
@@ -434,4 +436,3 @@ acpi_resource_to_address64 (
 	return (AE_OK);
 }
 EXPORT_SYMBOL(acpi_resource_to_address64);
-
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1051,13 +1051,15 @@ acpi_bus_add (
 	/*
 	 * Status
 	 * ------
-	 * See if the device is present.  We always assume that non-Device()
-	 * objects (e.g. thermal zones, power resources, processors, etc.) are
-	 * present, functioning, etc. (at least when parent object is present).
-	 * Note that _STA has a different meaning for some objects (e.g.
-	 * power resources) so we need to be careful how we use it.
+	 * See if the device is present.  We always assume that non-Device
+	 * and non-Processor objects (e.g. thermal zones, power resources,
+	 * etc.) are present, functioning, etc. (at least when parent object
+	 * is present).  Note that _STA has a different meaning for some
+	 * objects (e.g. power resources) so we need to be careful how we use
+	 * it.
 	 */
 	switch (type) {
+	case ACPI_BUS_TYPE_PROCESSOR:
 	case ACPI_BUS_TYPE_DEVICE:
 		result = acpi_bus_get_status(device);
 		if (ACPI_FAILURE(result) || !device->status.present) {
diff --git a/drivers/acpi/sleep/main.c b/drivers/acpi/sleep/main.c
--- a/drivers/acpi/sleep/main.c
+++ b/drivers/acpi/sleep/main.c
@@ -1,6 +1,7 @@
 /*
  * sleep.c - ACPI sleep support.
  *
+ * Copyright (c) 2005 Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
  * Copyright (c) 2004 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (c) 2000-2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
@@ -14,7 +15,6 @@
 #include <linux/dmi.h>
 #include <linux/device.h>
 #include <linux/suspend.h>
-#include <asm/io.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 #include "sleep.h"
@@ -27,10 +27,11 @@ extern void do_suspend_lowlevel_s4bios(v
 extern void do_suspend_lowlevel(void);
 
 static u32 acpi_suspend_states[] = {
-	[PM_SUSPEND_ON]		= ACPI_STATE_S0,
-	[PM_SUSPEND_STANDBY]	= ACPI_STATE_S1,
-	[PM_SUSPEND_MEM]	= ACPI_STATE_S3,
-	[PM_SUSPEND_DISK]	= ACPI_STATE_S4,
+	[PM_SUSPEND_ON] = ACPI_STATE_S0,
+	[PM_SUSPEND_STANDBY] = ACPI_STATE_S1,
+	[PM_SUSPEND_MEM] = ACPI_STATE_S3,
+	[PM_SUSPEND_DISK] = ACPI_STATE_S4,
+	[PM_SUSPEND_MAX] = ACPI_STATE_S5
 };
 
 static int init_8259A_after_S1;
@@ -44,30 +45,20 @@ static int init_8259A_after_S1;
  *	wakeup code to the waking vector. 
  */
 
+extern int acpi_sleep_prepare(u32 acpi_state);
+extern void acpi_power_off(void);
+
 static int acpi_pm_prepare(suspend_state_t pm_state)
 {
 	u32 acpi_state = acpi_suspend_states[pm_state];
 
-	if (!sleep_states[acpi_state])
+	if (!sleep_states[acpi_state]) {
+		printk("acpi_pm_prepare does not support %d \n", pm_state);
 		return -EPERM;
-
-	/* do we have a wakeup address for S2 and S3? */
-	/* Here, we support only S4BIOS, those we set the wakeup address */
-	/* S4OS is only supported for now via swsusp.. */
-	if (pm_state == PM_SUSPEND_MEM || pm_state == PM_SUSPEND_DISK) {
-		if (!acpi_wakeup_address)
-			return -EFAULT;
-		acpi_set_firmware_waking_vector(
-			(acpi_physical_address) virt_to_phys(
-				(void *)acpi_wakeup_address));
 	}
-	ACPI_FLUSH_CPU_CACHE();
-	acpi_enable_wakeup_device_prep(acpi_state);
-	acpi_enter_sleep_state_prep(acpi_state);
-	return 0;
+	return acpi_sleep_prepare(acpi_state);
 }
 
-
 /**
  *	acpi_pm_enter - Actually enter a sleep state.
  *	@pm_state:		State we're entering.
@@ -92,11 +83,9 @@ static int acpi_pm_enter(suspend_state_t
 			return error;
 	}
 
-
 	local_irq_save(flags);
 	acpi_enable_wakeup_device(acpi_state);
-	switch (pm_state)
-	{
+	switch (pm_state) {
 	case PM_SUSPEND_STANDBY:
 		barrier();
 		status = acpi_enter_sleep_state(acpi_state);
@@ -112,6 +101,10 @@ static int acpi_pm_enter(suspend_state_t
 		else
 			do_suspend_lowlevel_s4bios();
 		break;
+	case PM_SUSPEND_MAX:
+		acpi_power_off();
+		break;
+
 	default:
 		return -EINVAL;
 	}
@@ -126,11 +119,9 @@ static int acpi_pm_enter(suspend_state_t
 	if (pm_state > PM_SUSPEND_STANDBY)
 		acpi_restore_state_mem();
 
-
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
-
 /**
  *	acpi_pm_finish - Finish up suspend sequence.
  *	@pm_state:		State we're coming out of.
@@ -156,27 +147,26 @@ static int acpi_pm_finish(suspend_state_
 	return 0;
 }
 
-
 int acpi_suspend(u32 acpi_state)
 {
 	suspend_state_t states[] = {
-		[1]	= PM_SUSPEND_STANDBY,
-		[3]	= PM_SUSPEND_MEM,
-		[4]	= PM_SUSPEND_DISK,
+		[1] = PM_SUSPEND_STANDBY,
+		[3] = PM_SUSPEND_MEM,
+		[4] = PM_SUSPEND_DISK,
+		[5] = PM_SUSPEND_MAX
 	};
 
-	if (acpi_state <= 4 && states[acpi_state])
+	if (acpi_state < 6 && states[acpi_state])
 		return pm_suspend(states[acpi_state]);
 	return -EINVAL;
 }
 
 static struct pm_ops acpi_pm_ops = {
-	.prepare	= acpi_pm_prepare,
-	.enter		= acpi_pm_enter,
-	.finish		= acpi_pm_finish,
+	.prepare = acpi_pm_prepare,
+	.enter = acpi_pm_enter,
+	.finish = acpi_pm_finish,
 };
 
-
 /*
  * Toshiba fails to preserve interrupts over S1, reinitialization
  * of 8259 is needed after S1 resume.
@@ -190,16 +180,16 @@ static int __init init_ints_after_s1(str
 
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
-		.callback = init_ints_after_s1,
-		.ident = "Toshiba Satellite 4030cdt",
-		.matches = { DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"), },
-	},
-	{ },
+	 .callback = init_ints_after_s1,
+	 .ident = "Toshiba Satellite 4030cdt",
+	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),},
+	 },
+	{},
 };
 
 static int __init acpi_sleep_init(void)
 {
-	int			i = 0;
+	int i = 0;
 
 	dmi_check_system(acpisleep_dmi_table);
 
@@ -207,7 +197,7 @@ static int __init acpi_sleep_init(void)
 		return 0;
 
 	printk(KERN_INFO PREFIX "(supports");
-	for (i=0; i < ACPI_S_STATE_COUNT; i++) {
+	for (i = 0; i < ACPI_S_STATE_COUNT; i++) {
 		acpi_status status;
 		u8 type_a, type_b;
 		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
diff --git a/drivers/acpi/sleep/poweroff.c b/drivers/acpi/sleep/poweroff.c
--- a/drivers/acpi/sleep/poweroff.c
+++ b/drivers/acpi/sleep/poweroff.c
@@ -3,35 +3,100 @@
  *
  * AKA S5, but it is independent of whether or not the kernel supports
  * any other sleep support in the system.
+ *
+ * Copyright (c) 2005 Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
+ *
+ * This file is released under the GPLv2.
  */
 
 #include <linux/pm.h>
 #include <linux/init.h>
 #include <acpi/acpi_bus.h>
 #include <linux/sched.h>
+#include <linux/sysdev.h>
+#include <asm/io.h>
 #include "sleep.h"
 
-static void
-acpi_power_off (void)
+int acpi_sleep_prepare(u32 acpi_state)
+{
+	/* Flag to do not allow second time invocation for S5 state */
+	static int shutdown_prepared = 0;
+#ifdef CONFIG_ACPI_SLEEP
+	/* do we have a wakeup address for S2 and S3? */
+	/* Here, we support only S4BIOS, those we set the wakeup address */
+	/* S4OS is only supported for now via swsusp.. */
+	if (acpi_state == ACPI_STATE_S3 || acpi_state == ACPI_STATE_S4) {
+		if (!acpi_wakeup_address) {
+			return -EFAULT;
+		}
+		acpi_set_firmware_waking_vector((acpi_physical_address)
+						virt_to_phys((void *)
+							     acpi_wakeup_address));
+
+	}
+	ACPI_FLUSH_CPU_CACHE();
+	acpi_enable_wakeup_device_prep(acpi_state);
+#endif
+	if (acpi_state == ACPI_STATE_S5) {
+		/* Check if we were already called */
+		if (shutdown_prepared)
+			return 0;
+		acpi_wakeup_gpe_poweroff_prepare();
+		shutdown_prepared = 1;
+	}
+	acpi_enter_sleep_state_prep(acpi_state);
+	return 0;
+}
+
+void acpi_power_off(void)
 {
-	printk("%s called\n",__FUNCTION__);
+	printk("%s called\n", __FUNCTION__);
+	acpi_sleep_prepare(ACPI_STATE_S5);
+	local_irq_disable();
 	/* Some SMP machines only can poweroff in boot CPU */
 	set_cpus_allowed(current, cpumask_of_cpu(0));
-	acpi_wakeup_gpe_poweroff_prepare();
-	acpi_enter_sleep_state_prep(ACPI_STATE_S5);
-	ACPI_DISABLE_IRQS();
 	acpi_enter_sleep_state(ACPI_STATE_S5);
 }
 
+#ifdef CONFIG_PM
+
+static int acpi_shutdown(struct sys_device *x)
+{
+	return acpi_sleep_prepare(ACPI_STATE_S5);
+}
+
+static struct sysdev_class acpi_sysclass = {
+	set_kset_name("acpi"),
+	.shutdown = acpi_shutdown
+};
+
+static struct sys_device device_acpi = {
+	.id = 0,
+	.cls = &acpi_sysclass,
+};
+
+#endif
+
 static int acpi_poweroff_init(void)
 {
 	if (!acpi_disabled) {
 		u8 type_a, type_b;
 		acpi_status status;
 
-		status = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
-		if (ACPI_SUCCESS(status))
+		status =
+		    acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);
+		if (ACPI_SUCCESS(status)) {
 			pm_power_off = acpi_power_off;
+#ifdef CONFIG_PM
+			{
+				int error;
+				error = sysdev_class_register(&acpi_sysclass);
+				if (!error)
+					error = sysdev_register(&device_acpi);
+				return error;
+			}
+#endif
+		}
 	}
 	return 0;
 }
diff --git a/drivers/acpi/sleep/proc.c b/drivers/acpi/sleep/proc.c
--- a/drivers/acpi/sleep/proc.c
+++ b/drivers/acpi/sleep/proc.c
@@ -13,13 +13,17 @@
 
 #include "sleep.h"
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 #define ACPI_SYSTEM_FILE_SLEEP		"sleep"
+#endif
+
 #define ACPI_SYSTEM_FILE_ALARM		"alarm"
 #define ACPI_SYSTEM_FILE_WAKEUP_DEVICE   "wakeup"
 
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME		("sleep")
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 
 static int acpi_system_sleep_seq_show(struct seq_file *seq, void *offset)
 {
@@ -78,6 +82,7 @@ acpi_system_write_sleep (
  Done:
 	return error ? error : count;
 }
+#endif	/* CONFIG_ACPI_SLEEP_PROC_SLEEP */
 
 static int acpi_system_alarm_seq_show(struct seq_file *seq, void *offset)
 {
@@ -452,6 +457,7 @@ static struct file_operations acpi_syste
 	.release	= single_release,
 };
 
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 static struct file_operations acpi_system_sleep_fops = {
 	.open		= acpi_system_sleep_open_fs,
 	.read		= seq_read,
@@ -459,6 +465,7 @@ static struct file_operations acpi_syste
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
+#endif	/* CONFIG_ACPI_SLEEP_PROC_SLEEP */
 
 static struct file_operations acpi_system_alarm_fops = {
 	.open		= acpi_system_alarm_open_fs,
@@ -484,11 +491,13 @@ static int acpi_sleep_proc_init(void)
 	if (acpi_disabled)
 		return 0;
  
+#ifdef	CONFIG_ACPI_SLEEP_PROC_SLEEP
 	/* 'sleep' [R/W]*/
 	entry = create_proc_entry(ACPI_SYSTEM_FILE_SLEEP,
 				  S_IFREG|S_IRUGO|S_IWUSR, acpi_root_dir);
 	if (entry)
 		entry->proc_fops = &acpi_system_sleep_fops;
+#endif
 
 	/* 'alarm' [R/W] */
 	entry = create_proc_entry(ACPI_SYSTEM_FILE_ALARM,
diff --git a/drivers/acpi/tables/tbconvrt.c b/drivers/acpi/tables/tbconvrt.c
--- a/drivers/acpi/tables/tbconvrt.c
+++ b/drivers/acpi/tables/tbconvrt.c
@@ -50,6 +50,24 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbconvrt")
 
+/* Local prototypes */
+
+static void
+acpi_tb_init_generic_address (
+	struct acpi_generic_address     *new_gas_struct,
+	u8                              register_bit_width,
+	acpi_physical_address           address);
+
+static void
+acpi_tb_convert_fadt1 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev1    *original_fadt);
+
+static void
+acpi_tb_convert_fadt2 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev2    *original_fadt);
+
 
 u8 acpi_fadt_is_v1;
 EXPORT_SYMBOL(acpi_fadt_is_v1);
@@ -79,7 +97,9 @@ acpi_tb_get_table_count (
 	ACPI_FUNCTION_ENTRY ();
 
 
-	if (RSDP->revision < 2) {
+	/* RSDT pointers are 32 bits, XSDT pointers are 64 bits */
+
+	if (acpi_gbl_root_table_type == ACPI_TABLE_TYPE_RSDT) {
 		pointer_size = sizeof (u32);
 	}
 	else {
@@ -140,13 +160,17 @@ acpi_tb_convert_to_xsdt (
 	/* Copy the table pointers */
 
 	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
-		if (acpi_gbl_RSDP->revision < 2) {
+		/* RSDT pointers are 32 bits, XSDT pointers are 64 bits */
+
+		if (acpi_gbl_root_table_type == ACPI_TABLE_TYPE_RSDT) {
 			ACPI_STORE_ADDRESS (new_table->table_offset_entry[i],
-				(ACPI_CAST_PTR (struct rsdt_descriptor_rev1, table_info->pointer))->table_offset_entry[i]);
+				(ACPI_CAST_PTR (struct rsdt_descriptor_rev1,
+					table_info->pointer))->table_offset_entry[i]);
 		}
 		else {
 			new_table->table_offset_entry[i] =
-				(ACPI_CAST_PTR (XSDT_DESCRIPTOR, table_info->pointer))->table_offset_entry[i];
+				(ACPI_CAST_PTR (XSDT_DESCRIPTOR,
+					table_info->pointer))->table_offset_entry[i];
 		}
 	}
 
@@ -164,7 +188,7 @@ acpi_tb_convert_to_xsdt (
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_tb_init_generic_address
  *
@@ -201,7 +225,7 @@ acpi_tb_init_generic_address (
  * PARAMETERS:  local_fadt      - Pointer to new FADT
  *              original_fadt   - Pointer to old FADT
  *
- * RETURN:      Populates local_fadt
+ * RETURN:      None, populates local_fadt
  *
  * DESCRIPTION: Convert an ACPI 1.0 FADT to common internal format
  *
@@ -213,7 +237,6 @@ acpi_tb_convert_fadt1 (
 	struct fadt_descriptor_rev1    *original_fadt)
 {
 
-
 	/* ACPI 1.0 FACS */
 	/* The BIOS stored FADT should agree with Revision 1.0 */
 	acpi_fadt_is_v1 = 1;
@@ -232,7 +255,8 @@ acpi_tb_convert_fadt1 (
 	ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
 
 	/*
-	 * System Interrupt Model isn't used in ACPI 2.0 (local_fadt->Reserved1 = 0;)
+	 * System Interrupt Model isn't used in ACPI 2.0
+	 * (local_fadt->Reserved1 = 0;)
 	 */
 
 	/*
@@ -269,7 +293,8 @@ acpi_tb_convert_fadt1 (
 		 * that immediately follows.
 		 */
 		ACPI_MEMCPY (&local_fadt->reset_register,
-			&(ACPI_CAST_PTR (struct fadt_descriptor_rev2_minus, original_fadt))->reset_register,
+			&(ACPI_CAST_PTR (struct fadt_descriptor_rev2_minus,
+				original_fadt))->reset_register,
   			sizeof (struct acpi_generic_address) + 1);
 	}
 	else {
@@ -304,7 +329,8 @@ acpi_tb_convert_fadt1 (
 
 	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
 		 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-		 (acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+		 (acpi_physical_address)
+			(local_fadt->xpm1a_evt_blk.address +
 			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
 
 	/* PM1B is optional; leave null if not present */
@@ -312,7 +338,8 @@ acpi_tb_convert_fadt1 (
 	if (local_fadt->xpm1b_evt_blk.address) {
 		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
 			 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-			 (acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+			 (acpi_physical_address)
+				(local_fadt->xpm1b_evt_blk.address +
 				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
 	}
 }
@@ -325,7 +352,7 @@ acpi_tb_convert_fadt1 (
  * PARAMETERS:  local_fadt      - Pointer to new FADT
  *              original_fadt   - Pointer to old FADT
  *
- * RETURN:      Populates local_fadt
+ * RETURN:      None, populates local_fadt
  *
  * DESCRIPTION: Convert an ACPI 2.0 FADT to common internal format.
  *              Handles optional "X" fields.
@@ -348,7 +375,8 @@ acpi_tb_convert_fadt2 (
 	 * is zero.
 	 */
 	if (!(local_fadt->xfirmware_ctrl)) {
-		ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+		ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl,
+			local_fadt->V1_firmware_ctrl);
 	}
 
 	if (!(local_fadt->Xdsdt)) {
@@ -357,32 +385,38 @@ acpi_tb_convert_fadt2 (
 
 	if (!(local_fadt->xpm1a_evt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1a_evt_blk,
-			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1a_evt_blk);
+			local_fadt->pm1_evt_len,
+			(acpi_physical_address) local_fadt->V1_pm1a_evt_blk);
 	}
 
 	if (!(local_fadt->xpm1b_evt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1b_evt_blk,
-			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1b_evt_blk);
+			local_fadt->pm1_evt_len,
+			(acpi_physical_address) local_fadt->V1_pm1b_evt_blk);
 	}
 
 	if (!(local_fadt->xpm1a_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1a_cnt_blk,
-			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1a_cnt_blk);
+			local_fadt->pm1_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm1a_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm1b_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm1b_cnt_blk,
-			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1b_cnt_blk);
+			local_fadt->pm1_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm1b_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm2_cnt_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm2_cnt_blk,
-			local_fadt->pm2_cnt_len, (acpi_physical_address) local_fadt->V1_pm2_cnt_blk);
+			local_fadt->pm2_cnt_len,
+			(acpi_physical_address) local_fadt->V1_pm2_cnt_blk);
 	}
 
 	if (!(local_fadt->xpm_tmr_blk.address)) {
 		acpi_tb_init_generic_address (&local_fadt->xpm_tmr_blk,
-			local_fadt->pm_tm_len, (acpi_physical_address) local_fadt->V1_pm_tmr_blk);
+			local_fadt->pm_tm_len,
+			(acpi_physical_address) local_fadt->V1_pm_tmr_blk);
 	}
 
 	if (!(local_fadt->xgpe0_blk.address)) {
@@ -399,18 +433,24 @@ acpi_tb_convert_fadt2 (
 
 	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
 		(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-		(acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+		(acpi_physical_address)
+			(local_fadt->xpm1a_evt_blk.address +
 			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
-	acpi_gbl_xpm1a_enable.address_space_id = local_fadt->xpm1a_evt_blk.address_space_id;
+
+	acpi_gbl_xpm1a_enable.address_space_id =
+		local_fadt->xpm1a_evt_blk.address_space_id;
 
 	/* PM1B is optional; leave null if not present */
 
 	if (local_fadt->xpm1b_evt_blk.address) {
 		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
 			(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
-			(acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+			(acpi_physical_address)
+				(local_fadt->xpm1b_evt_blk.address +
 				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
-		acpi_gbl_xpm1b_enable.address_space_id = local_fadt->xpm1b_evt_blk.address_space_id;
+
+		acpi_gbl_xpm1b_enable.address_space_id =
+			local_fadt->xpm1b_evt_blk.address_space_id;
 	}
 }
 
@@ -432,7 +472,8 @@ acpi_tb_convert_fadt2 (
  ******************************************************************************/
 
 acpi_status
-acpi_tb_convert_table_fadt (void)
+acpi_tb_convert_table_fadt (
+	void)
 {
 	struct fadt_descriptor_rev2    *local_fadt;
 	struct acpi_table_desc         *table_desc;
@@ -446,7 +487,8 @@ acpi_tb_convert_table_fadt (void)
 	 * at least as long as the version 1.0 FADT
 	 */
 	if (acpi_gbl_FADT->length < sizeof (struct fadt_descriptor_rev1)) {
-		ACPI_REPORT_ERROR (("FADT is invalid, too short: 0x%X\n", acpi_gbl_FADT->length));
+		ACPI_REPORT_ERROR (("FADT is invalid, too short: 0x%X\n",
+			acpi_gbl_FADT->length));
 		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
 	}
 
@@ -461,8 +503,9 @@ acpi_tb_convert_table_fadt (void)
 		if (acpi_gbl_FADT->length < sizeof (struct fadt_descriptor_rev2)) {
 			/* Length is too short to be a V2.0 table */
 
-			ACPI_REPORT_WARNING (("Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
-					 acpi_gbl_FADT->length, acpi_gbl_FADT->revision));
+			ACPI_REPORT_WARNING ((
+				"Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
+				acpi_gbl_FADT->length, acpi_gbl_FADT->revision));
 
 			acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
 		}
@@ -478,9 +521,8 @@ acpi_tb_convert_table_fadt (void)
 		acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
 	}
 
-	/*
-	 * Global FADT pointer will point to the new common V2.0 FADT
-	 */
+	/* Global FADT pointer will point to the new common V2.0 FADT */
+
 	acpi_gbl_FADT = local_fadt;
 	acpi_gbl_FADT->length = sizeof (FADT_DESCRIPTOR);
 
@@ -508,7 +550,7 @@ acpi_tb_convert_table_fadt (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_convert_table_facs
+ * FUNCTION:    acpi_tb_build_common_facs
  *
  * PARAMETERS:  table_info      - Info for currently installed FACS
  *
@@ -530,12 +572,14 @@ acpi_tb_build_common_facs (
 	/* Absolute minimum length is 24, but the ACPI spec says 64 */
 
 	if (acpi_gbl_FACS->length < 24) {
-		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n", acpi_gbl_FACS->length));
+		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n",
+			acpi_gbl_FACS->length));
 		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
 	}
 
 	if (acpi_gbl_FACS->length < 64) {
-		ACPI_REPORT_WARNING (("FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
+		ACPI_REPORT_WARNING ((
+			"FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
 			acpi_gbl_FACS->length));
 	}
 
@@ -548,7 +592,8 @@ acpi_tb_build_common_facs (
 		(!(acpi_gbl_FACS->xfirmware_waking_vector))) {
 		/* ACPI 1.0 FACS or short table or optional X_ field is zero */
 
-		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64, &(acpi_gbl_FACS->firmware_waking_vector));
+		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64,
+				&(acpi_gbl_FACS->firmware_waking_vector));
 		acpi_gbl_common_fACS.vector_width = 32;
 	}
 	else {
diff --git a/drivers/acpi/tables/tbget.c b/drivers/acpi/tables/tbget.c
--- a/drivers/acpi/tables/tbget.c
+++ b/drivers/acpi/tables/tbget.c
@@ -49,6 +49,19 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbget")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_get_this_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
+static acpi_status
+acpi_tb_table_override (
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
 
 /*******************************************************************************
  *
@@ -76,9 +89,8 @@ acpi_tb_get_table (
 	ACPI_FUNCTION_TRACE ("tb_get_table");
 
 
-	/*
-	 * Get the header in order to get signature and table size
-	 */
+	/* Get the header in order to get signature and table size */
+
 	status = acpi_tb_get_table_header (address, &header);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -127,8 +139,8 @@ acpi_tb_get_table_header (
 
 
 	/*
-	 * Flags contains the current processor mode (Virtual or Physical addressing)
-	 * The pointer_type is either Logical or Physical
+	 * Flags contains the current processor mode (Virtual or Physical
+	 * addressing) The pointer_type is either Logical or Physical
 	 */
 	switch (address->pointer_type) {
 	case ACPI_PHYSMODE_PHYSPTR:
@@ -136,7 +148,8 @@ acpi_tb_get_table_header (
 
 		/* Pointer matches processor mode, copy the header */
 
-		ACPI_MEMCPY (return_header, address->pointer.logical, sizeof (struct acpi_table_header));
+		ACPI_MEMCPY (return_header, address->pointer.logical,
+			sizeof (struct acpi_table_header));
 		break;
 
 
@@ -144,10 +157,11 @@ acpi_tb_get_table_header (
 
 		/* Create a logical address for the physical pointer*/
 
-		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct acpi_table_header),
-				  (void *) &header);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 sizeof (struct acpi_table_header), (void *) &header);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("Could not map memory at %8.8X%8.8X for length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not map memory at %8.8X%8.8X for length %X\n",
 				ACPI_FORMAT_UINT64 (address->pointer.physical),
 				sizeof (struct acpi_table_header)));
 			return_ACPI_STATUS (status);
@@ -210,9 +224,8 @@ acpi_tb_get_table_body (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Attempt table override.
-	 */
+	/* Attempt table override. */
+
 	status = acpi_tb_table_override (header, table_info);
 	if (ACPI_SUCCESS (status)) {
 		/* Table was overridden by the host OS */
@@ -241,7 +254,7 @@ acpi_tb_get_table_body (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_table_override (
 	struct acpi_table_header        *header,
 	struct acpi_table_desc          *table_info)
@@ -315,7 +328,7 @@ acpi_tb_table_override (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_this_table (
 	struct acpi_pointer             *address,
 	struct acpi_table_header        *header,
@@ -330,8 +343,8 @@ acpi_tb_get_this_table (
 
 
 	/*
-	 * Flags contains the current processor mode (Virtual or Physical addressing)
-	 * The pointer_type is either Logical or Physical
+	 * Flags contains the current processor mode (Virtual or Physical
+	 * addressing) The pointer_type is either Logical or Physical
 	 */
 	switch (address->pointer_type) {
 	case ACPI_PHYSMODE_PHYSPTR:
@@ -341,7 +354,8 @@ acpi_tb_get_this_table (
 
 		full_table = ACPI_MEM_ALLOCATE (header->length);
 		if (!full_table) {
-			ACPI_REPORT_ERROR (("Could not allocate table memory for [%4.4s] length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not allocate table memory for [%4.4s] length %X\n",
 				header->signature, header->length));
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -362,12 +376,14 @@ acpi_tb_get_this_table (
 		 * Just map the table's physical memory
 		 * into our address space.
 		 */
-		status = acpi_os_map_memory (address->pointer.physical, (acpi_size) header->length,
-				  (void *) &full_table);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 (acpi_size) header->length, (void *) &full_table);
 		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_ERROR (("Could not map memory for table [%4.4s] at %8.8X%8.8X for length %X\n",
+			ACPI_REPORT_ERROR ((
+				"Could not map memory for table [%4.4s] at %8.8X%8.8X for length %X\n",
 				header->signature,
-				ACPI_FORMAT_UINT64 (address->pointer.physical), header->length));
+				ACPI_FORMAT_UINT64 (address->pointer.physical),
+				header->length));
 			return (status);
 		}
 
@@ -465,9 +481,8 @@ acpi_tb_get_table_ptr (
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/*
-	 * Check for instance out of range
-	 */
+	/* Check for instance out of range */
+
 	if (instance > acpi_gbl_table_lists[table_type].count) {
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
diff --git a/drivers/acpi/tables/tbgetall.c b/drivers/acpi/tables/tbgetall.c
--- a/drivers/acpi/tables/tbgetall.c
+++ b/drivers/acpi/tables/tbgetall.c
@@ -49,6 +49,19 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbgetall")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_get_primary_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info);
+
+static acpi_status
+acpi_tb_get_secondary_table (
+	struct acpi_pointer             *address,
+	acpi_string                     signature,
+	struct acpi_table_desc          *table_info);
+
 
 /*******************************************************************************
  *
@@ -63,7 +76,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_primary_table (
 	struct acpi_pointer             *address,
 	struct acpi_table_desc          *table_info)
@@ -81,9 +94,8 @@ acpi_tb_get_primary_table (
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/*
-	 * Get the header in order to get signature and table size
-	 */
+	/* Get the header in order to get signature and table size */
+
 	status = acpi_tb_get_table_header (address, &header);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -130,7 +142,7 @@ acpi_tb_get_primary_table (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_get_secondary_table (
 	struct acpi_pointer             *address,
 	acpi_string                     signature,
@@ -153,7 +165,8 @@ acpi_tb_get_secondary_table (
 	/* Signature must match request */
 
 	if (ACPI_STRNCMP (header.signature, signature, ACPI_NAME_SIZE)) {
-		ACPI_REPORT_ERROR (("Incorrect table signature - wanted [%s] found [%4.4s]\n",
+		ACPI_REPORT_ERROR ((
+			"Incorrect table signature - wanted [%s] found [%4.4s]\n",
 			signature, header.signature));
 		return_ACPI_STATUS (AE_BAD_SIGNATURE);
 	}
@@ -230,7 +243,8 @@ acpi_tb_get_required_tables (
 	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
 		/* Get the table address from the common internal XSDT */
 
-		address.pointer.value = acpi_gbl_XSDT->table_offset_entry[i];
+		address.pointer.value =
+				  acpi_gbl_XSDT->table_offset_entry[i];
 
 		/*
 		 * Get the tables needed by this subsystem (FADT and any SSDTs).
@@ -252,18 +266,18 @@ acpi_tb_get_required_tables (
 	}
 
 	/*
-	 * Convert the FADT to a common format.  This allows earlier revisions of the
-	 * table to coexist with newer versions, using common access code.
+	 * Convert the FADT to a common format.  This allows earlier revisions of
+	 * the table to coexist with newer versions, using common access code.
 	 */
 	status = acpi_tb_convert_table_fadt ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not convert FADT to internal common format\n"));
+		ACPI_REPORT_ERROR ((
+			"Could not convert FADT to internal common format\n"));
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get the FACS (Pointed to by the FADT)
-	 */
+	/* Get the FACS (Pointed to by the FADT) */
+
 	address.pointer.value = acpi_gbl_FADT->xfirmware_ctrl;
 
 	status = acpi_tb_get_secondary_table (&address, FACS_SIG, &table_info);
@@ -282,9 +296,8 @@ acpi_tb_get_required_tables (
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Get/install the DSDT (Pointed to by the FADT)
-	 */
+	/* Get/install the DSDT (Pointed to by the FADT) */
+
 	address.pointer.value = acpi_gbl_FADT->Xdsdt;
 
 	status = acpi_tb_get_secondary_table (&address, DSDT_SIG, &table_info);
diff --git a/drivers/acpi/tables/tbinstal.c b/drivers/acpi/tables/tbinstal.c
--- a/drivers/acpi/tables/tbinstal.c
+++ b/drivers/acpi/tables/tbinstal.c
@@ -49,6 +49,14 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbinstal")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_match_signature (
+	char                            *signature,
+	struct acpi_table_desc          *table_info,
+	u8                              search_type);
+
 
 /*******************************************************************************
  *
@@ -56,6 +64,7 @@
  *
  * PARAMETERS:  Signature           - Table signature to match
  *              table_info          - Return data
+ *              search_type         - Table type to match (primary/secondary)
  *
  * RETURN:      Status
  *
@@ -64,7 +73,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_match_signature (
 	char                            *signature,
 	struct acpi_table_desc          *table_info,
@@ -76,9 +85,8 @@ acpi_tb_match_signature (
 	ACPI_FUNCTION_TRACE ("tb_match_signature");
 
 
-	/*
-	 * Search for a signature match among the known table types
-	 */
+	/* Search for a signature match among the known table types */
+
 	for (i = 0; i < NUM_ACPI_TABLE_TYPES; i++) {
 		if (!(acpi_gbl_table_data[i].flags & search_type)) {
 			continue;
@@ -116,9 +124,7 @@ acpi_tb_match_signature (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Load and validate all tables other than the RSDT.  The RSDT must
- *              already be loaded and validated.
- *              Install the table into the global data structs.
+ * DESCRIPTION: Install the table into the global data structures.
  *
  ******************************************************************************/
 
@@ -128,6 +134,7 @@ acpi_tb_install_table (
 {
 	acpi_status                     status;
 
+
 	ACPI_FUNCTION_TRACE ("tb_install_table");
 
 
@@ -135,22 +142,33 @@ acpi_tb_install_table (
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not acquire table mutex for [%4.4s], %s\n",
-			table_info->pointer->signature, acpi_format_exception (status)));
+		ACPI_REPORT_ERROR (("Could not acquire table mutex, %s\n",
+			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
+	/*
+	 * Ignore a table that is already installed. For example, some BIOS
+	 * ASL code will repeatedly attempt to load the same SSDT.
+	 */
+	status = acpi_tb_is_table_installed (table_info);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
+
 	/* Install the table into the global data structure */
 
 	status = acpi_tb_init_table_descriptor (table_info->type, table_info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not install ACPI table [%4.4s], %s\n",
+		ACPI_REPORT_ERROR (("Could not install table [%4.4s], %s\n",
 			table_info->pointer->signature, acpi_format_exception (status)));
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s located at %p\n",
 		acpi_gbl_table_data[table_info->type].name, table_info->pointer));
 
+
+unlock_and_exit:
 	(void) acpi_ut_release_mutex (ACPI_MTX_TABLES);
 	return_ACPI_STATUS (status);
 }
@@ -161,6 +179,7 @@ acpi_tb_install_table (
  * FUNCTION:    acpi_tb_recognize_table
  *
  * PARAMETERS:  table_info          - Return value from acpi_tb_get_table_body
+ *              search_type         - Table type to match (primary/secondary)
  *
  * RETURN:      Status
  *
@@ -203,7 +222,8 @@ acpi_tb_recognize_table (
 	 * This can be any one of many valid ACPI tables, it just isn't one of
 	 * the tables that is consumed by the core subsystem
 	 */
-	status = acpi_tb_match_signature (table_header->signature, table_info, search_type);
+	status = acpi_tb_match_signature (table_header->signature,
+			 table_info, search_type);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -241,6 +261,7 @@ acpi_tb_init_table_descriptor (
 {
 	struct acpi_table_list          *list_head;
 	struct acpi_table_desc          *table_desc;
+	acpi_status                     status;
 
 
 	ACPI_FUNCTION_TRACE_U32 ("tb_init_table_descriptor", table_type);
@@ -253,9 +274,15 @@ acpi_tb_init_table_descriptor (
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/*
-	 * Install the table into the global data structure
-	 */
+	/* Get a new owner ID for the table */
+
+	status = acpi_ut_allocate_owner_id (&table_desc->owner_id);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Install the table into the global data structure */
+
 	list_head = &acpi_gbl_table_lists[table_type];
 
 	/*
@@ -316,7 +343,6 @@ acpi_tb_init_table_descriptor (
 	table_desc->aml_start           = (u8 *) (table_desc->pointer + 1),
 	table_desc->aml_length          = (u32) (table_desc->length -
 			 (u32) sizeof (struct acpi_table_header));
-	table_desc->table_id            = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_TABLE);
 	table_desc->loaded_into_namespace = FALSE;
 
 	/*
@@ -329,7 +355,7 @@ acpi_tb_init_table_descriptor (
 
 	/* Return Data */
 
-	table_info->table_id        = table_desc->table_id;
+	table_info->owner_id        = table_desc->owner_id;
 	table_info->installed_desc  = table_desc;
 
 	return_ACPI_STATUS (AE_OK);
@@ -349,7 +375,8 @@ acpi_tb_init_table_descriptor (
  ******************************************************************************/
 
 void
-acpi_tb_delete_all_tables (void)
+acpi_tb_delete_all_tables (
+	void)
 {
 	acpi_table_type                 type;
 
diff --git a/drivers/acpi/tables/tbrsdt.c b/drivers/acpi/tables/tbrsdt.c
--- a/drivers/acpi/tables/tbrsdt.c
+++ b/drivers/acpi/tables/tbrsdt.c
@@ -84,8 +84,9 @@ acpi_tb_verify_rsdp (
 		/*
 		 * Obtain access to the RSDP structure
 		 */
-		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct rsdp_descriptor),
-				  (void *) &rsdp);
+		status = acpi_os_map_memory (address->pointer.physical,
+				 sizeof (struct rsdp_descriptor),
+						   (void *) &rsdp);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -95,32 +96,13 @@ acpi_tb_verify_rsdp (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 *  The signature and checksum must both be correct
-	 */
-	if (ACPI_STRNCMP ((char *) rsdp, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
-		/* Nope, BAD Signature */
-
-		status = AE_BAD_SIGNATURE;
-		goto cleanup;
-	}
+	/* Verify RSDP signature and checksum */
 
-	/* Check the standard checksum */
-
-	if (acpi_tb_checksum (rsdp, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
-		status = AE_BAD_CHECKSUM;
+	status = acpi_tb_validate_rsdp (rsdp);
+	if (ACPI_FAILURE (status)) {
 		goto cleanup;
 	}
 
-	/* Check extended checksum if table version >= 2 */
-
-	if (rsdp->revision >= 2) {
-		if (acpi_tb_checksum (rsdp, ACPI_RSDP_XCHECKSUM_LENGTH) != 0) {
-			status = AE_BAD_CHECKSUM;
-			goto cleanup;
-		}
-	}
-
 	/* The RSDP supplied is OK */
 
 	table_info.pointer     = ACPI_CAST_PTR (struct acpi_table_header, rsdp);
@@ -154,12 +136,12 @@ cleanup:
  *
  * FUNCTION:    acpi_tb_get_rsdt_address
  *
- * PARAMETERS:  None
+ * PARAMETERS:  out_address         - Where the address is returned
  *
- * RETURN:      RSDT physical address
+ * RETURN:      None, Address
  *
- * DESCRIPTION: Extract the address of the RSDT or XSDT, depending on the
- *              version of the RSDP
+ * DESCRIPTION: Extract the address of either the RSDT or XSDT, depending on the
+ *              version of the RSDP and whether the XSDT pointer is valid
  *
  ******************************************************************************/
 
@@ -173,15 +155,19 @@ acpi_tb_get_rsdt_address (
 
 	out_address->pointer_type = acpi_gbl_table_flags | ACPI_LOGICAL_ADDRESSING;
 
-	/*
-	 * For RSDP revision 0 or 1, we use the RSDT.
-	 * For RSDP revision 2 (and above), we use the XSDT
-	 */
-	if (acpi_gbl_RSDP->revision < 2) {
-		out_address->pointer.value = acpi_gbl_RSDP->rsdt_physical_address;
+	/* Use XSDT if it is present */
+
+	if ((acpi_gbl_RSDP->revision >= 2) &&
+		acpi_gbl_RSDP->xsdt_physical_address) {
+		out_address->pointer.value =
+			acpi_gbl_RSDP->xsdt_physical_address;
+		acpi_gbl_root_table_type = ACPI_TABLE_TYPE_XSDT;
 	}
 	else {
-		out_address->pointer.value = acpi_gbl_RSDP->xsdt_physical_address;
+		/* No XSDT, use the RSDT */
+
+		out_address->pointer.value = acpi_gbl_RSDP->rsdt_physical_address;
+		acpi_gbl_root_table_type = ACPI_TABLE_TYPE_RSDT;
 	}
 }
 
@@ -209,10 +195,9 @@ acpi_tb_validate_rsdt (
 
 
 	/*
-	 * For RSDP revision 0 or 1, we use the RSDT.
-	 * For RSDP revision 2 and above, we use the XSDT
+	 * Search for appropriate signature, RSDT or XSDT
 	 */
-	if (acpi_gbl_RSDP->revision < 2) {
+	if (acpi_gbl_root_table_type == ACPI_TABLE_TYPE_RSDT) {
 		no_match = ACPI_STRNCMP ((char *) table_ptr, RSDT_SIG,
 				  sizeof (RSDT_SIG) -1);
 	}
@@ -224,7 +209,8 @@ acpi_tb_validate_rsdt (
 	if (no_match) {
 		/* Invalid RSDT or XSDT signature */
 
-		ACPI_REPORT_ERROR (("Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
+		ACPI_REPORT_ERROR ((
+			"Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
 
 		ACPI_DUMP_BUFFER (acpi_gbl_RSDP, 20);
 
@@ -233,11 +219,11 @@ acpi_tb_validate_rsdt (
 			acpi_gbl_RSDP->rsdt_physical_address,
 			(void *) (acpi_native_uint) acpi_gbl_RSDP->rsdt_physical_address));
 
-		if (acpi_gbl_RSDP->revision < 2) {
-			ACPI_REPORT_ERROR (("Looking for RSDT (RSDP->Rev < 2)\n"))
+		if (acpi_gbl_root_table_type == ACPI_TABLE_TYPE_RSDT) {
+			ACPI_REPORT_ERROR (("Looking for RSDT\n"))
 		}
 		else {
-			ACPI_REPORT_ERROR (("Looking for XSDT (RSDP->Rev >= 2)\n"))
+			ACPI_REPORT_ERROR (("Looking for XSDT\n"))
 		}
 
 		ACPI_DUMP_BUFFER ((char *) table_ptr, 48);
@@ -282,6 +268,7 @@ acpi_tb_get_table_rsdt (
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT/XSDT, %s\n",
 			acpi_format_exception (status)));
+
 		return_ACPI_STATUS (status);
 	}
 
@@ -299,7 +286,8 @@ acpi_tb_get_table_rsdt (
 
 	/* Get the number of tables defined in the RSDT or XSDT */
 
-	acpi_gbl_rsdt_table_count = acpi_tb_get_table_count (acpi_gbl_RSDP, table_info.pointer);
+	acpi_gbl_rsdt_table_count = acpi_tb_get_table_count (acpi_gbl_RSDP,
+			  table_info.pointer);
 
 	/* Convert and/or copy to an XSDT structure */
 
diff --git a/drivers/acpi/tables/tbutils.c b/drivers/acpi/tables/tbutils.c
--- a/drivers/acpi/tables/tbutils.c
+++ b/drivers/acpi/tables/tbutils.c
@@ -49,48 +49,75 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbutils")
 
+/* Local prototypes */
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_status
+acpi_tb_handle_to_object (
+	u16                             table_id,
+	struct acpi_table_desc          **table_desc);
+#endif
+
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_handle_to_object
+ * FUNCTION:    acpi_tb_is_table_installed
  *
- * PARAMETERS:  table_id            - Id for which the function is searching
- *              table_desc          - Pointer to return the matching table
- *                                      descriptor.
+ * PARAMETERS:  new_table_desc      - Descriptor for new table being installed
  *
- * RETURN:      Search the tables to find one with a matching table_id and
- *              return a pointer to that table descriptor.
+ * RETURN:      Status - AE_ALREADY_EXISTS if the table is already installed
+ *
+ * DESCRIPTION: Determine if an ACPI table is already installed
+ *
+ * MUTEX:       Table data structures should be locked
  *
  ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
+
 acpi_status
-acpi_tb_handle_to_object (
-	u16                             table_id,
-	struct acpi_table_desc          **return_table_desc)
+acpi_tb_is_table_installed (
+	struct acpi_table_desc          *new_table_desc)
 {
-	u32                             i;
 	struct acpi_table_desc          *table_desc;
 
 
-	ACPI_FUNCTION_NAME ("tb_handle_to_object");
+	ACPI_FUNCTION_TRACE ("tb_is_table_installed");
 
 
-	for (i = 0; i < ACPI_TABLE_MAX; i++) {
-		table_desc = acpi_gbl_table_lists[i].next;
-		while (table_desc) {
-			if (table_desc->table_id == table_id) {
-				*return_table_desc = table_desc;
-				return (AE_OK);
-			}
+	/* Get the list descriptor and first table descriptor */
 
-			table_desc = table_desc->next;
+	table_desc = acpi_gbl_table_lists[new_table_desc->type].next;
+
+	/* Examine all installed tables of this type */
+
+	while (table_desc) {
+		/* Compare Revision and oem_table_id */
+
+		if ((table_desc->loaded_into_namespace) &&
+			(table_desc->pointer->revision ==
+					new_table_desc->pointer->revision) &&
+			(!ACPI_MEMCMP (table_desc->pointer->oem_table_id,
+					new_table_desc->pointer->oem_table_id, 8))) {
+			/* This table is already installed */
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
+				"Table [%4.4s] already installed: Rev %X oem_table_id [%8.8s]\n",
+				new_table_desc->pointer->signature,
+				new_table_desc->pointer->revision,
+				new_table_desc->pointer->oem_table_id));
+
+			new_table_desc->owner_id    = table_desc->owner_id;
+			new_table_desc->installed_desc = table_desc;
+
+			return_ACPI_STATUS (AE_ALREADY_EXISTS);
 		}
+
+		/* Get next table on the list */
+
+		table_desc = table_desc->next;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "table_id=%X does not exist\n", table_id));
-	return (AE_BAD_PARAMETER);
+	return_ACPI_STATUS (AE_OK);
 }
-#endif  /*  ACPI_FUTURE_USAGE  */
 
 
 /*******************************************************************************
@@ -128,6 +155,7 @@ acpi_tb_validate_table_header (
 	if (!acpi_os_readable (table_header, sizeof (struct acpi_table_header))) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Cannot read table header at %p\n", table_header));
+
 		return (AE_BAD_ADDRESS);
 	}
 
@@ -141,6 +169,7 @@ acpi_tb_validate_table_header (
 
 		ACPI_REPORT_WARNING (("Invalid table signature found: [%4.4s]\n",
 			(char *) &signature));
+
 		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_SIGNATURE);
 	}
@@ -154,6 +183,7 @@ acpi_tb_validate_table_header (
 
 		ACPI_REPORT_WARNING (("Invalid table header length (0x%X) found\n",
 			(u32) table_header->length));
+
 		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_HEADER);
 	}
@@ -188,13 +218,15 @@ acpi_tb_verify_table_checksum (
 
 	/* Compute the checksum on the table */
 
-	checksum = acpi_tb_checksum (table_header, table_header->length);
+	checksum = acpi_tb_generate_checksum (table_header, table_header->length);
 
 	/* Return the appropriate exception */
 
 	if (checksum) {
-		ACPI_REPORT_WARNING (("Invalid checksum in table [%4.4s] (%02X, sum %02X is not zero)\n",
-			table_header->signature, (u32) table_header->checksum, (u32) checksum));
+		ACPI_REPORT_WARNING ((
+			"Invalid checksum in table [%4.4s] (%02X, sum %02X is not zero)\n",
+			table_header->signature, (u32) table_header->checksum,
+			(u32) checksum));
 
 		status = AE_BAD_CHECKSUM;
 	}
@@ -204,19 +236,19 @@ acpi_tb_verify_table_checksum (
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_tb_checksum
+ * FUNCTION:    acpi_tb_generate_checksum
  *
  * PARAMETERS:  Buffer              - Buffer to checksum
  *              Length              - Size of the buffer
  *
- * RETURNS      8 bit checksum of buffer
+ * RETURN:      8 bit checksum of buffer
  *
  * DESCRIPTION: Computes an 8 bit checksum of the buffer(length) and returns it.
  *
  ******************************************************************************/
 
 u8
-acpi_tb_checksum (
+acpi_tb_generate_checksum (
 	void                            *buffer,
 	u32                             length)
 {
@@ -238,3 +270,47 @@ acpi_tb_checksum (
 }
 
 
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_handle_to_object
+ *
+ * PARAMETERS:  table_id            - Id for which the function is searching
+ *              table_desc          - Pointer to return the matching table
+ *                                      descriptor.
+ *
+ * RETURN:      Search the tables to find one with a matching table_id and
+ *              return a pointer to that table descriptor.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_handle_to_object (
+	u16                             table_id,
+	struct acpi_table_desc          **return_table_desc)
+{
+	u32                             i;
+	struct acpi_table_desc          *table_desc;
+
+
+	ACPI_FUNCTION_NAME ("tb_handle_to_object");
+
+
+	for (i = 0; i < ACPI_TABLE_MAX; i++) {
+		table_desc = acpi_gbl_table_lists[i].next;
+		while (table_desc) {
+			if (table_desc->table_id == table_id) {
+				*return_table_desc = table_desc;
+				return (AE_OK);
+			}
+
+			table_desc = table_desc->next;
+		}
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "table_id=%X does not exist\n", table_id));
+	return (AE_BAD_PARAMETER);
+}
+#endif
+
+
diff --git a/drivers/acpi/tables/tbxface.c b/drivers/acpi/tables/tbxface.c
--- a/drivers/acpi/tables/tbxface.c
+++ b/drivers/acpi/tables/tbxface.c
@@ -67,7 +67,8 @@
  ******************************************************************************/
 
 acpi_status
-acpi_load_tables (void)
+acpi_load_tables (
+	void)
 {
 	struct acpi_pointer             rsdp_address;
 	acpi_status                     status;
@@ -82,7 +83,7 @@ acpi_load_tables (void)
 			  &rsdp_address);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not get RSDP, %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -93,7 +94,7 @@ acpi_load_tables (void)
 	status = acpi_tb_verify_rsdp (&rsdp_address);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: RSDP Failed validation: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -102,7 +103,7 @@ acpi_load_tables (void)
 	status = acpi_tb_get_table_rsdt ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load RSDT: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -110,20 +111,20 @@ acpi_load_tables (void)
 
 	status = acpi_tb_get_required_tables ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
-				  acpi_format_exception (status)));
+		ACPI_REPORT_ERROR ((
+			"acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI Tables successfully acquired\n"));
 
-
 	/* Load the namespace from the tables */
 
 	status = acpi_ns_load_namespace ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load namespace: %s\n",
-				  acpi_format_exception (status)));
+			acpi_format_exception (status)));
 		goto error_exit;
 	}
 
@@ -139,7 +140,6 @@ error_exit:
 
 
 #ifdef ACPI_FUTURE_USAGE
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_load_table
@@ -182,10 +182,23 @@ acpi_load_table (
 		return_ACPI_STATUS (status);
 	}
 
+	/* Check signature for a valid table type */
+
+	status = acpi_tb_recognize_table (&table_info, ACPI_TABLE_ALL);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	/* Install the new table into the local data structures */
 
 	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
+		if (status == AE_ALREADY_EXISTS) {
+			/* Table already exists, no error */
+
+			status = AE_OK;
+		}
+
 		/* Free table allocated by acpi_tb_get_table_body */
 
 		acpi_tb_delete_single_table (&table_info);
@@ -250,7 +263,6 @@ acpi_unload_table (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Find all tables of the requested type */
 
 	table_desc = acpi_gbl_table_lists[table_type].next;
@@ -261,8 +273,8 @@ acpi_unload_table (
 		 * "Scope" operator.  Thus, we need to track ownership by an ID, not
 		 * simply a position within the hierarchy
 		 */
-		acpi_ns_delete_namespace_by_owner (table_desc->table_id);
-
+		acpi_ns_delete_namespace_by_owner (table_desc->owner_id);
+		acpi_ut_release_owner_id (&table_desc->owner_id);
 		table_desc = table_desc->next;
 	}
 
@@ -321,7 +333,6 @@ acpi_get_table_header (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Get a pointer to the entire table */
 
 	status = acpi_tb_get_table_ptr (table_type, instance, &tbl_ptr);
@@ -329,23 +340,20 @@ acpi_get_table_header (
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * The function will return a NULL pointer if the table is not loaded
-	 */
+	/* The function will return a NULL pointer if the table is not loaded */
+
 	if (tbl_ptr == NULL) {
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	/*
-	 * Copy the header to the caller's buffer
-	 */
+	/* Copy the header to the caller's buffer */
+
 	ACPI_MEMCPY ((void *) out_table_header, (void *) tbl_ptr,
-			 sizeof (struct acpi_table_header));
+		sizeof (struct acpi_table_header));
 
 	return_ACPI_STATUS (status);
 }
 
-
 #endif  /*  ACPI_FUTURE_USAGE  */
 
 /*******************************************************************************
@@ -404,7 +412,6 @@ acpi_get_table (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Get a pointer to the entire table */
 
 	status = acpi_tb_get_table_ptr (table_type, instance, &tbl_ptr);
@@ -423,9 +430,8 @@ acpi_get_table (
 	/* Get the table length */
 
 	if (table_type == ACPI_TABLE_RSDP) {
-		/*
-		 *  RSD PTR is the only "table" without a header
-		 */
+		/* RSD PTR is the only "table" without a header */
+
 		table_length = sizeof (struct rsdp_descriptor);
 	}
 	else {
diff --git a/drivers/acpi/tables/tbxfroot.c b/drivers/acpi/tables/tbxfroot.c
--- a/drivers/acpi/tables/tbxfroot.c
+++ b/drivers/acpi/tables/tbxfroot.c
@@ -50,6 +50,63 @@
 #define _COMPONENT          ACPI_TABLES
 	 ACPI_MODULE_NAME    ("tbxfroot")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_tb_find_rsdp (
+	struct acpi_table_desc          *table_info,
+	u32                             flags);
+
+static u8 *
+acpi_tb_scan_memory_for_rsdp (
+	u8                              *start_address,
+	u32                             length);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_rsdp
+ *
+ * PARAMETERS:  Rsdp        - Pointer to unvalidated RSDP
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate the RSDP (ptr)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_validate_rsdp (
+	struct rsdp_descriptor          *rsdp)
+{
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/*
+	 *  The signature and checksum must both be correct
+	 */
+	if (ACPI_STRNCMP ((char *) rsdp, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+		/* Nope, BAD Signature */
+
+		return (AE_BAD_SIGNATURE);
+	}
+
+	/* Check the standard checksum */
+
+	if (acpi_tb_generate_checksum (rsdp, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
+		return (AE_BAD_CHECKSUM);
+	}
+
+	/* Check extended checksum if table version >= 2 */
+
+	if ((rsdp->revision >= 2) &&
+		(acpi_tb_generate_checksum (rsdp, ACPI_RSDP_XCHECKSUM_LENGTH) != 0)) {
+		return (AE_BAD_CHECKSUM);
+	}
+
+	return (AE_OK);
+}
+
 
 /*******************************************************************************
  *
@@ -57,7 +114,8 @@
  *
  * PARAMETERS:  Signature           - String with ACPI table signature
  *              oem_id              - String with the table OEM ID
- *              oem_table_id        - String with the OEM Table ID.
+ *              oem_table_id        - String with the OEM Table ID
+ *              table_ptr           - Where the table pointer is returned
  *
  * RETURN:      Status
  *
@@ -99,14 +157,13 @@ acpi_tb_find_table (
 		if (!acpi_gbl_DSDT) {
 			return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 		}
-
 		table = acpi_gbl_DSDT;
 	}
 	else {
 		/* Find the table */
 
 		status = acpi_get_firmware_table (signature, 1,
-				   ACPI_LOGICAL_ADDRESSING, &table);
+				 ACPI_LOGICAL_ADDRESSING, &table);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -114,14 +171,19 @@ acpi_tb_find_table (
 
 	/* Check oem_id and oem_table_id */
 
-	if ((oem_id[0]     && ACPI_STRNCMP (
-			 oem_id, table->oem_id, sizeof (table->oem_id))) ||
+	if ((oem_id[0] && ACPI_STRNCMP (
+			   oem_id, table->oem_id,
+			   sizeof (table->oem_id))) ||
+
 		(oem_table_id[0] && ACPI_STRNCMP (
-				   oem_table_id, table->oem_table_id, sizeof (table->oem_table_id)))) {
+				   oem_table_id, table->oem_table_id,
+				   sizeof (table->oem_table_id)))) {
 		return_ACPI_STATUS (AE_AML_NAME_NOT_FOUND);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Found table [%4.4s]\n", table->signature));
+	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Found table [%4.4s]\n",
+		table->signature));
+
 	*table_ptr = table;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -191,8 +253,8 @@ acpi_get_firmware_table (
 		/* Map and validate the RSDP */
 
 		if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-			status = acpi_os_map_memory (address.pointer.physical, sizeof (struct rsdp_descriptor),
-					  (void *) &acpi_gbl_RSDP);
+			status = acpi_os_map_memory (address.pointer.physical,
+					 sizeof (struct rsdp_descriptor), (void *) &acpi_gbl_RSDP);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
@@ -201,18 +263,11 @@ acpi_get_firmware_table (
 			acpi_gbl_RSDP = address.pointer.logical;
 		}
 
-		/* The signature and checksum must both be correct */
-
-		if (ACPI_STRNCMP ((char *) acpi_gbl_RSDP, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
-			/* Nope, BAD Signature */
-
-			return_ACPI_STATUS (AE_BAD_SIGNATURE);
-		}
-
-		if (acpi_tb_checksum (acpi_gbl_RSDP, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
-			/* Nope, BAD Checksum */
+		/* The RDSP signature and checksum must both be correct */
 
-			return_ACPI_STATUS (AE_BAD_CHECKSUM);
+		status = acpi_tb_validate_rsdp (acpi_gbl_RSDP);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
 	}
 
@@ -269,9 +324,11 @@ acpi_get_firmware_table (
 	 * requested table
 	 */
 	for (i = 0, j = 0; i < table_count; i++) {
-		/* Get the next table pointer, handle RSDT vs. XSDT */
-
-		if (acpi_gbl_RSDP->revision < 2) {
+		/*
+		 * Get the next table pointer, handle RSDT vs. XSDT
+		 * RSDT pointers are 32 bits, XSDT pointers are 64 bits
+		 */
+		if (acpi_gbl_root_table_type == ACPI_TABLE_TYPE_RSDT) {
 			address.pointer.value = (ACPI_CAST_PTR (
 				RSDT_DESCRIPTOR, rsdt_info->pointer))->table_offset_entry[i];
 		}
@@ -313,7 +370,10 @@ acpi_get_firmware_table (
 
 
 cleanup:
-	acpi_os_unmap_memory (rsdt_info->pointer, (acpi_size) rsdt_info->pointer->length);
+	if (rsdt_info->pointer) {
+		acpi_os_unmap_memory (rsdt_info->pointer,
+			(acpi_size) rsdt_info->pointer->length);
+	}
 	ACPI_MEM_FREE (rsdt_info);
 
 	if (header) {
@@ -335,8 +395,8 @@ EXPORT_SYMBOL(acpi_get_firmware_table);
  *
  * FUNCTION:    acpi_find_root_pointer
  *
- * PARAMETERS:  **rsdp_address          - Where to place the RSDP address
- *              Flags                   - Logical/Physical addressing
+ * PARAMETERS:  Flags                   - Logical/Physical addressing
+ *              rsdp_address            - Where to place the RSDP address
  *
  * RETURN:      Status, Physical address of the RSDP
  *
@@ -363,6 +423,7 @@ acpi_find_root_pointer (
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"RSDP structure not found, %s Flags=%X\n",
 			acpi_format_exception (status), flags));
+
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
@@ -385,14 +446,14 @@ acpi_find_root_pointer (
  *
  ******************************************************************************/
 
-u8 *
+static u8 *
 acpi_tb_scan_memory_for_rsdp (
 	u8                              *start_address,
 	u32                             length)
 {
+	acpi_status                     status;
 	u8                              *mem_rover;
 	u8                              *end_address;
-	u8                              checksum;
 
 
 	ACPI_FUNCTION_TRACE ("tb_scan_memory_for_rsdp");
@@ -404,44 +465,25 @@ acpi_tb_scan_memory_for_rsdp (
 
 	for (mem_rover = start_address; mem_rover < end_address;
 		 mem_rover += ACPI_RSDP_SCAN_STEP) {
-		/* The signature and checksum must both be correct */
-
-		if (ACPI_STRNCMP ((char *) mem_rover, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
-			/* No signature match, keep looking */
-
-			continue;
-		}
-
-		/* Signature matches, check the appropriate checksum */
-
-		if ((ACPI_CAST_PTR (struct rsdp_descriptor, mem_rover))->revision < 2) {
-			/* ACPI version 1.0 */
-
-			checksum = acpi_tb_checksum (mem_rover, ACPI_RSDP_CHECKSUM_LENGTH);
-		}
-		else {
-			/* Post ACPI 1.0, use extended_checksum */
-
-			checksum = acpi_tb_checksum (mem_rover, ACPI_RSDP_XCHECKSUM_LENGTH);
-		}
+		/* The RSDP signature and checksum must both be correct */
 
-		if (checksum == 0) {
-			/* Checksum valid, we have found a valid RSDP */
+		status = acpi_tb_validate_rsdp (ACPI_CAST_PTR (struct rsdp_descriptor, mem_rover));
+		if (ACPI_SUCCESS (status)) {
+			/* Sig and checksum valid, we have found a real RSDP */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 				"RSDP located at physical address %p\n", mem_rover));
 			return_PTR (mem_rover);
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Found an RSDP at physical address %p, but it has a bad checksum\n",
-			mem_rover));
+		/* No sig match or bad checksum, keep searching */
 	}
 
 	/* Searched entire block, no RSDP was found */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"Searched entire block, no valid RSDP was found.\n"));
+		"Searched entire block from %p, valid RSDP was not found\n",
+		start_address));
 	return_PTR (NULL);
 }
 
@@ -450,7 +492,7 @@ acpi_tb_scan_memory_for_rsdp (
  *
  * FUNCTION:    acpi_tb_find_rsdp
  *
- * PARAMETERS:  *table_info             - Where the table info is returned
+ * PARAMETERS:  table_info              - Where the table info is returned
  *              Flags                   - Current memory mode (logical vs.
  *                                        physical addressing)
  *
@@ -468,7 +510,7 @@ acpi_tb_scan_memory_for_rsdp (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_tb_find_rsdp (
 	struct acpi_table_desc          *table_info,
 	u32                             flags)
@@ -483,51 +525,58 @@ acpi_tb_find_rsdp (
 
 
 	/*
-	 * Scan supports either 1) Logical addressing or 2) Physical addressing
+	 * Scan supports either logical addressing or physical addressing
 	 */
 	if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-		/*
-		 * 1a) Get the location of the EBDA
-		 */
-		status = acpi_os_map_memory ((acpi_physical_address) ACPI_EBDA_PTR_LOCATION,
-				  ACPI_EBDA_PTR_LENGTH,
-				  (void *) &table_ptr);
+		/* 1a) Get the location of the Extended BIOS Data Area (EBDA) */
+
+		status = acpi_os_map_memory (
+				 (acpi_physical_address) ACPI_EBDA_PTR_LOCATION,
+				 ACPI_EBDA_PTR_LENGTH, (void *) &table_ptr);
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not map memory at %8.8X for length %X\n",
 				ACPI_EBDA_PTR_LOCATION, ACPI_EBDA_PTR_LENGTH));
+
 			return_ACPI_STATUS (status);
 		}
 
 		ACPI_MOVE_16_TO_32 (&physical_address, table_ptr);
-		physical_address <<= 4;                 /* Convert segment to physical address */
+
+		/* Convert segment part to physical address */
+
+		physical_address <<= 4;
 		acpi_os_unmap_memory (table_ptr, ACPI_EBDA_PTR_LENGTH);
 
 		/* EBDA present? */
 
 		if (physical_address > 0x400) {
 			/*
-			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of 1_k length)
+			 * 1b) Search EBDA paragraphs (EBDa is required to be a
+			 *     minimum of 1_k length)
 			 */
-			status = acpi_os_map_memory ((acpi_physical_address) physical_address,
-					  ACPI_EBDA_WINDOW_SIZE,
-					  (void *) &table_ptr);
+			status = acpi_os_map_memory (
+					 (acpi_physical_address) physical_address,
+					 ACPI_EBDA_WINDOW_SIZE, (void *) &table_ptr);
 			if (ACPI_FAILURE (status)) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 					"Could not map memory at %8.8X for length %X\n",
 					physical_address, ACPI_EBDA_WINDOW_SIZE));
+
 				return_ACPI_STATUS (status);
 			}
 
-			mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, ACPI_EBDA_WINDOW_SIZE);
+			mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr,
+					  ACPI_EBDA_WINDOW_SIZE);
 			acpi_os_unmap_memory (table_ptr, ACPI_EBDA_WINDOW_SIZE);
 
 			if (mem_rover) {
-				/* Found it, return the physical address */
+				/* Return the physical address */
 
 				physical_address += ACPI_PTR_DIFF (mem_rover, table_ptr);
 
-				table_info->physical_address = (acpi_physical_address) physical_address;
+				table_info->physical_address =
+					(acpi_physical_address) physical_address;
 				return_ACPI_STATUS (AE_OK);
 			}
 		}
@@ -535,13 +584,15 @@ acpi_tb_find_rsdp (
 		/*
 		 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
 		 */
-		status = acpi_os_map_memory ((acpi_physical_address) ACPI_HI_RSDP_WINDOW_BASE,
-				  ACPI_HI_RSDP_WINDOW_SIZE,
-				  (void *) &table_ptr);
+		status = acpi_os_map_memory (
+				 (acpi_physical_address) ACPI_HI_RSDP_WINDOW_BASE,
+				 ACPI_HI_RSDP_WINDOW_SIZE, (void *) &table_ptr);
+
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not map memory at %8.8X for length %X\n",
 				ACPI_HI_RSDP_WINDOW_BASE, ACPI_HI_RSDP_WINDOW_SIZE));
+
 			return_ACPI_STATUS (status);
 		}
 
@@ -549,11 +600,13 @@ acpi_tb_find_rsdp (
 		acpi_os_unmap_memory (table_ptr, ACPI_HI_RSDP_WINDOW_SIZE);
 
 		if (mem_rover) {
-			/* Found it, return the physical address */
+			/* Return the physical address */
 
-			physical_address = ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (mem_rover, table_ptr);
+			physical_address =
+				ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (mem_rover, table_ptr);
 
-			table_info->physical_address = (acpi_physical_address) physical_address;
+			table_info->physical_address =
+				(acpi_physical_address) physical_address;
 			return_ACPI_STATUS (AE_OK);
 		}
 	}
@@ -562,9 +615,8 @@ acpi_tb_find_rsdp (
 	 * Physical addressing
 	 */
 	else {
-		/*
-		 * 1a) Get the location of the EBDA
-		 */
+		/* 1a) Get the location of the EBDA */
+
 		ACPI_MOVE_16_TO_32 (&physical_address, ACPI_EBDA_PTR_LOCATION);
 		physical_address <<= 4;     /* Convert segment to physical address */
 
@@ -572,22 +624,24 @@ acpi_tb_find_rsdp (
 
 		if (physical_address > 0x400) {
 			/*
-			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of 1_k length)
+			 * 1b) Search EBDA paragraphs (EBDa is required to be a minimum of
+			 *     1_k length)
 			 */
-			mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (physical_address),
+			mem_rover = acpi_tb_scan_memory_for_rsdp (
+					  ACPI_PHYSADDR_TO_PTR (physical_address),
 					  ACPI_EBDA_WINDOW_SIZE);
 			if (mem_rover) {
-				/* Found it, return the physical address */
+				/* Return the physical address */
 
 				table_info->physical_address = ACPI_TO_INTEGER (mem_rover);
 				return_ACPI_STATUS (AE_OK);
 			}
 		}
 
-		/*
-		 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
-		 */
-		mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (ACPI_HI_RSDP_WINDOW_BASE),
+		/* 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh */
+
+		mem_rover = acpi_tb_scan_memory_for_rsdp (
+				  ACPI_PHYSADDR_TO_PTR (ACPI_HI_RSDP_WINDOW_BASE),
 				  ACPI_HI_RSDP_WINDOW_SIZE);
 		if (mem_rover) {
 			/* Found it, return the physical address */
@@ -597,8 +651,9 @@ acpi_tb_find_rsdp (
 		}
 	}
 
-	/* RSDP signature was not found */
+	/* A valid RSDP was not found */
 
+	ACPI_REPORT_ERROR (("No valid RSDP was found\n"));
 	return_ACPI_STATUS (AE_NOT_FOUND);
 }
 
diff --git a/drivers/acpi/toshiba_acpi.c b/drivers/acpi/toshiba_acpi.c
--- a/drivers/acpi/toshiba_acpi.c
+++ b/drivers/acpi/toshiba_acpi.c
@@ -263,6 +263,9 @@ dispatch_write(struct file* file, const 
 	 * destination so that sscanf can be used on it safely.
 	 */
 	tmp_buffer = kmalloc(count + 1, GFP_KERNEL);
+	if(!tmp_buffer)
+		return -ENOMEM;
+
 	if (copy_from_user(tmp_buffer, buffer, count)) {
 		result = -EFAULT;
 	}
@@ -529,6 +532,11 @@ toshiba_acpi_init(void)
 
 	if (acpi_disabled)
 		return -ENODEV;
+
+	if (!acpi_specific_hotkey_enabled){
+		printk(MY_INFO "Using generic hotkey driver\n");
+		return -ENODEV;	
+	}
 	/* simple device detection: look for HCI method */
 	if (is_valid_acpi_path(METHOD_HCI_1))
 		method_hci = METHOD_HCI_1;
diff --git a/drivers/acpi/utilities/Makefile b/drivers/acpi/utilities/Makefile
--- a/drivers/acpi/utilities/Makefile
+++ b/drivers/acpi/utilities/Makefile
@@ -3,6 +3,6 @@
 #
 
 obj-y := utalloc.o  utdebug.o   uteval.o    utinit.o  utmisc.o    utxface.o \
-	 utcopy.o   utdelete.o  utglobal.o  utmath.o  utobject.o
+	 utcopy.o   utdelete.o  utglobal.o  utmath.o  utobject.o utstate.o utmutex.o utobject.o utcache.o
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
diff --git a/drivers/acpi/utilities/utalloc.c b/drivers/acpi/utilities/utalloc.c
--- a/drivers/acpi/utilities/utalloc.c
+++ b/drivers/acpi/utilities/utalloc.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Module Name: utalloc - local cache and memory allocation routines
+ * Module Name: utalloc - local memory allocation routines
  *
  *****************************************************************************/
 
@@ -47,196 +47,136 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utalloc")
 
+/* Local prototypes */
 
-/******************************************************************************
- *
- * FUNCTION:    acpi_ut_release_to_cache
- *
- * PARAMETERS:  list_id             - Memory list/cache ID
- *              Object              - The object to be released
- *
- * RETURN:      None
- *
- * DESCRIPTION: Release an object to the specified cache.  If cache is full,
- *              the object is deleted.
- *
- ******************************************************************************/
-
-void
-acpi_ut_release_to_cache (
-	u32                             list_id,
-	void                            *object)
-{
-	struct acpi_memory_list         *cache_info;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	cache_info = &acpi_gbl_memory_lists[list_id];
-
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-
-	/* If walk cache is full, just free this wallkstate object */
-
-	if (cache_info->cache_depth >= cache_info->max_cache_depth) {
-		ACPI_MEM_FREE (object);
-		ACPI_MEM_TRACKING (cache_info->total_freed++);
-	}
-
-	/* Otherwise put this object back into the cache */
-
-	else {
-		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES))) {
-			return;
-		}
-
-		/* Mark the object as cached */
-
-		ACPI_MEMSET (object, 0xCA, cache_info->object_size);
-		ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_CACHED);
-
-		/* Put the object at the head of the cache list */
-
-		* (ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset]))) = cache_info->list_head;
-		cache_info->list_head = object;
-		cache_info->cache_depth++;
-
-		(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
-	}
+#ifdef	ACPI_DBG_TRACK_ALLOCATIONS
+static struct acpi_debug_mem_block *
+acpi_ut_find_allocation (
+	void                            *allocation);
 
-#else
+static acpi_status
+acpi_ut_track_allocation (
+	struct acpi_debug_mem_block     *address,
+	acpi_size                       size,
+	u8                              alloc_type,
+	u32                             component,
+	char                            *module,
+	u32                             line);
 
-	/* Object cache is disabled; just free the object */
+static acpi_status
+acpi_ut_remove_allocation (
+	struct acpi_debug_mem_block     *address,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+#endif	/* ACPI_DBG_TRACK_ALLOCATIONS */
 
-	ACPI_MEM_FREE (object);
-	ACPI_MEM_TRACKING (cache_info->total_freed++);
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+static acpi_status
+acpi_ut_create_list (
+	char                            *list_name,
+	u16                             object_size,
+	struct acpi_memory_list         **return_cache);
 #endif
-}
 
 
-/******************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    acpi_ut_acquire_from_cache
+ * FUNCTION:    acpi_ut_create_caches
  *
- * PARAMETERS:  list_id             - Memory list ID
+ * PARAMETERS:  None
  *
- * RETURN:      A requested object.  NULL if the object could not be
- *              allocated.
+ * RETURN:      Status
  *
- * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
- *              the object is allocated.
+ * DESCRIPTION: Create all local caches
  *
  ******************************************************************************/
 
-void *
-acpi_ut_acquire_from_cache (
-	u32                             list_id)
+acpi_status
+acpi_ut_create_caches (
+	void)
 {
-	struct acpi_memory_list         *cache_info;
-	void                            *object;
-
-
-	ACPI_FUNCTION_NAME ("ut_acquire_from_cache");
+	acpi_status                     status;
 
 
-	cache_info = &acpi_gbl_memory_lists[list_id];
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
+	/* Memory allocation lists */
 
-	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES))) {
-		return (NULL);
+	status = acpi_ut_create_list ("Acpi-Global", 0,
+			 &acpi_gbl_global_list);
+	if (ACPI_FAILURE (status)) {
+		return (status);
 	}
 
-	ACPI_MEM_TRACKING (cache_info->cache_requests++);
-
-	/* Check the cache first */
-
-	if (cache_info->list_head) {
-		/* There is an object available, use it */
-
-		object = cache_info->list_head;
-		cache_info->list_head = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset])));
-
-		ACPI_MEM_TRACKING (cache_info->cache_hits++);
-		cache_info->cache_depth--;
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Object %p from %s\n",
-			object, acpi_gbl_memory_lists[list_id].list_name));
+	status = acpi_ut_create_list ("Acpi-Namespace", sizeof (struct acpi_namespace_node),
+			 &acpi_gbl_ns_node_list);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 #endif
 
-		if (ACPI_FAILURE (acpi_ut_release_mutex (ACPI_MTX_CACHES))) {
-			return (NULL);
-		}
+	/* Object Caches, for frequently used objects */
 
-		/* Clear (zero) the previously used Object */
-
-		ACPI_MEMSET (object, 0, cache_info->object_size);
+	status = acpi_os_create_cache ("acpi_state", sizeof (union acpi_generic_state),
+			 ACPI_MAX_STATE_CACHE_DEPTH, &acpi_gbl_state_cache);
+	if (ACPI_FAILURE (status)) {
+		return (status);
 	}
 
-	else {
-		/* The cache is empty, create a new object */
-
-		/* Avoid deadlock with ACPI_MEM_CALLOCATE */
-
-		if (ACPI_FAILURE (acpi_ut_release_mutex (ACPI_MTX_CACHES))) {
-			return (NULL);
-		}
-
-		object = ACPI_MEM_CALLOCATE (cache_info->object_size);
-		ACPI_MEM_TRACKING (cache_info->total_allocated++);
+	status = acpi_os_create_cache ("acpi_parse", sizeof (struct acpi_parse_obj_common),
+			 ACPI_MAX_PARSE_CACHE_DEPTH, &acpi_gbl_ps_node_cache);
+	if (ACPI_FAILURE (status)) {
+		return (status);
 	}
 
-#else
-
-	/* Object cache is disabled; just allocate the object */
+	status = acpi_os_create_cache ("acpi_parse_ext", sizeof (struct acpi_parse_obj_named),
+			 ACPI_MAX_EXTPARSE_CACHE_DEPTH, &acpi_gbl_ps_node_ext_cache);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
-	object = ACPI_MEM_CALLOCATE (cache_info->object_size);
-	ACPI_MEM_TRACKING (cache_info->total_allocated++);
-#endif
+	status = acpi_os_create_cache ("acpi_operand", sizeof (union acpi_operand_object),
+			 ACPI_MAX_OBJECT_CACHE_DEPTH, &acpi_gbl_operand_cache);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
-	return (object);
+	return (AE_OK);
 }
 
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-/******************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    acpi_ut_delete_generic_cache
+ * FUNCTION:    acpi_ut_delete_caches
  *
- * PARAMETERS:  list_id         - Memory list ID
+ * PARAMETERS:  None
  *
- * RETURN:      None
+ * RETURN:      Status
  *
- * DESCRIPTION: Free all objects within the requested cache.
+ * DESCRIPTION: Purge and delete all local caches
  *
  ******************************************************************************/
 
-void
-acpi_ut_delete_generic_cache (
-	u32                             list_id)
+acpi_status
+acpi_ut_delete_caches (
+	void)
 {
-	struct acpi_memory_list         *cache_info;
-	char                            *next;
 
+	(void) acpi_os_delete_cache (acpi_gbl_state_cache);
+	acpi_gbl_state_cache = NULL;
 
-	ACPI_FUNCTION_ENTRY ();
-
+	(void) acpi_os_delete_cache (acpi_gbl_operand_cache);
+	acpi_gbl_operand_cache = NULL;
 
-	cache_info = &acpi_gbl_memory_lists[list_id];
-	while (cache_info->list_head) {
-		/* Delete one cached state object */
+	(void) acpi_os_delete_cache (acpi_gbl_ps_node_cache);
+	acpi_gbl_ps_node_cache = NULL;
 
-		next = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) cache_info->list_head)[cache_info->link_offset])));
-		ACPI_MEM_FREE (cache_info->list_head);
+	(void) acpi_os_delete_cache (acpi_gbl_ps_node_ext_cache);
+	acpi_gbl_ps_node_ext_cache = NULL;
 
-		cache_info->list_head = next;
-		cache_info->cache_depth--;
-	}
+	return (AE_OK);
 }
-#endif
-
 
 /*******************************************************************************
  *
@@ -470,6 +410,43 @@ acpi_ut_callocate (
  * occurs in the body of acpi_ut_free.
  */
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_list
+ *
+ * PARAMETERS:  cache_name      - Ascii name for the cache
+ *              object_size     - Size of each cached object
+ *              return_cache    - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a local memory list for tracking purposed
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_create_list (
+	char                            *list_name,
+	u16                             object_size,
+	struct acpi_memory_list         **return_cache)
+{
+	struct acpi_memory_list         *cache;
+
+
+	cache = acpi_os_allocate (sizeof (struct acpi_memory_list));
+	if (!cache) {
+		return (AE_NO_MEMORY);
+	}
+
+	ACPI_MEMSET (cache, 0, sizeof (struct acpi_memory_list));
+
+	cache->list_name  = list_name;
+	cache->object_size = object_size;
+
+	*return_cache = cache;
+	return (AE_OK);
+}
+
 
 /*******************************************************************************
  *
@@ -497,21 +474,21 @@ acpi_ut_allocate_and_track (
 	acpi_status                     status;
 
 
-	allocation = acpi_ut_allocate (size + sizeof (struct acpi_debug_mem_header), component,
-			  module, line);
+	allocation = acpi_ut_allocate (size + sizeof (struct acpi_debug_mem_header),
+			  component, module, line);
 	if (!allocation) {
 		return (NULL);
 	}
 
-	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, allocation, size,
+	status = acpi_ut_track_allocation (allocation, size,
 			  ACPI_MEM_MALLOC, component, module, line);
 	if (ACPI_FAILURE (status)) {
 		acpi_os_free (allocation);
 		return (NULL);
 	}
 
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += (u32) size;
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->current_total_size += (u32) size;
 
 	return ((void *) &allocation->user_space);
 }
@@ -543,8 +520,8 @@ acpi_ut_callocate_and_track (
 	acpi_status                     status;
 
 
-	allocation = acpi_ut_callocate (size + sizeof (struct acpi_debug_mem_header), component,
-			  module, line);
+	allocation = acpi_ut_callocate (size + sizeof (struct acpi_debug_mem_header),
+			  component, module, line);
 	if (!allocation) {
 		/* Report allocation error */
 
@@ -553,15 +530,15 @@ acpi_ut_callocate_and_track (
 		return (NULL);
 	}
 
-	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, allocation, size,
+	status = acpi_ut_track_allocation (allocation, size,
 			   ACPI_MEM_CALLOC, component, module, line);
 	if (ACPI_FAILURE (status)) {
 		acpi_os_free (allocation);
 		return (NULL);
 	}
 
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += (u32) size;
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->current_total_size += (u32) size;
 
 	return ((void *) &allocation->user_space);
 }
@@ -606,10 +583,10 @@ acpi_ut_free_and_track (
 	debug_block = ACPI_CAST_PTR (struct acpi_debug_mem_block,
 			  (((char *) allocation) - sizeof (struct acpi_debug_mem_header)));
 
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_freed++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size -= debug_block->size;
+	acpi_gbl_global_list->total_freed++;
+	acpi_gbl_global_list->current_total_size -= debug_block->size;
 
-	status = acpi_ut_remove_allocation (ACPI_MEM_LIST_GLOBAL, debug_block,
+	status = acpi_ut_remove_allocation (debug_block,
 			  component, module, line);
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not free memory, %s\n",
@@ -628,8 +605,7 @@ acpi_ut_free_and_track (
  *
  * FUNCTION:    acpi_ut_find_allocation
  *
- * PARAMETERS:  list_id                 - Memory list to search
- *              Allocation              - Address of allocated memory
+ * PARAMETERS:  Allocation              - Address of allocated memory
  *
  * RETURN:      A list element if found; NULL otherwise.
  *
@@ -637,9 +613,8 @@ acpi_ut_free_and_track (
  *
  ******************************************************************************/
 
-struct acpi_debug_mem_block *
+static struct acpi_debug_mem_block *
 acpi_ut_find_allocation (
-	u32                             list_id,
 	void                            *allocation)
 {
 	struct acpi_debug_mem_block     *element;
@@ -648,11 +623,7 @@ acpi_ut_find_allocation (
 	ACPI_FUNCTION_ENTRY ();
 
 
-	if (list_id > ACPI_MEM_LIST_MAX) {
-		return (NULL);
-	}
-
-	element = acpi_gbl_memory_lists[list_id].list_head;
+	element = acpi_gbl_global_list->list_head;
 
 	/* Search for the address. */
 
@@ -672,8 +643,7 @@ acpi_ut_find_allocation (
  *
  * FUNCTION:    acpi_ut_track_allocation
  *
- * PARAMETERS:  list_id             - Memory list to search
- *              Allocation          - Address of allocated memory
+ * PARAMETERS:  Allocation          - Address of allocated memory
  *              Size                - Size of the allocation
  *              alloc_type          - MEM_MALLOC or MEM_CALLOC
  *              Component           - Component type of caller
@@ -686,9 +656,8 @@ acpi_ut_find_allocation (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_track_allocation (
-	u32                             list_id,
 	struct acpi_debug_mem_block     *allocation,
 	acpi_size                       size,
 	u8                              alloc_type,
@@ -704,11 +673,7 @@ acpi_ut_track_allocation (
 	ACPI_FUNCTION_TRACE_PTR ("ut_track_allocation", allocation);
 
 
-	if (list_id > ACPI_MEM_LIST_MAX) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	mem_list = &acpi_gbl_memory_lists[list_id];
+	mem_list = acpi_gbl_global_list;
 	status = acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -718,13 +683,14 @@ acpi_ut_track_allocation (
 	 * Search list for this address to make sure it is not already on the list.
 	 * This will catch several kinds of problems.
 	 */
-
-	element = acpi_ut_find_allocation (list_id, allocation);
+	element = acpi_ut_find_allocation (allocation);
 	if (element) {
-		ACPI_REPORT_ERROR (("ut_track_allocation: Allocation already present in list! (%p)\n",
+		ACPI_REPORT_ERROR ((
+			"ut_track_allocation: Allocation already present in list! (%p)\n",
 			allocation));
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n", element, allocation));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n",
+			element, allocation));
 
 		goto unlock_and_exit;
 	}
@@ -761,8 +727,7 @@ unlock_and_exit:
  *
  * FUNCTION:    acpi_ut_remove_allocation
  *
- * PARAMETERS:  list_id             - Memory list to search
- *              Allocation          - Address of allocated memory
+ * PARAMETERS:  Allocation          - Address of allocated memory
  *              Component           - Component type of caller
  *              Module              - Source file name of caller
  *              Line                - Line number of caller
@@ -773,9 +738,8 @@ unlock_and_exit:
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_remove_allocation (
-	u32                             list_id,
 	struct acpi_debug_mem_block     *allocation,
 	u32                             component,
 	char                            *module,
@@ -788,16 +752,12 @@ acpi_ut_remove_allocation (
 	ACPI_FUNCTION_TRACE ("ut_remove_allocation");
 
 
-	if (list_id > ACPI_MEM_LIST_MAX) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	mem_list = &acpi_gbl_memory_lists[list_id];
+	mem_list = acpi_gbl_global_list;
 	if (NULL == mem_list->list_head) {
 		/* No allocations! */
 
 		_ACPI_REPORT_ERROR (module, line, component,
-				("ut_remove_allocation: Empty allocation list, nothing to free!\n"));
+			("ut_remove_allocation: Empty allocation list, nothing to free!\n"));
 
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -824,7 +784,8 @@ acpi_ut_remove_allocation (
 
 	ACPI_MEMSET (&allocation->user_space, 0xEA, allocation->size);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n", allocation->size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
+		allocation->size));
 
 	status = acpi_ut_release_mutex (ACPI_MTX_MEMORY);
 	return_ACPI_STATUS (status);
@@ -842,6 +803,7 @@ acpi_ut_remove_allocation (
  * DESCRIPTION: Print some info about the outstanding allocations.
  *
  ******************************************************************************/
+
 #ifdef ACPI_FUTURE_USAGE
 void
 acpi_ut_dump_allocation_info (
@@ -884,7 +846,8 @@ acpi_ut_dump_allocation_info (
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
 			  acpi_gbl_max_concurrent_node_count,
-			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count * sizeof (struct acpi_namespace_node)))));
+			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+					 sizeof (struct acpi_namespace_node)))));
 */
 	return_VOID;
 }
@@ -924,7 +887,7 @@ acpi_ut_dump_allocations (
 		return;
 	}
 
-	element = acpi_gbl_memory_lists[0].list_head;
+	element = acpi_gbl_global_list->list_head;
 	while (element) {
 		if ((element->component & component) &&
 			((module == NULL) || (0 == ACPI_STRCMP (module, element->module)))) {
@@ -933,26 +896,26 @@ acpi_ut_dump_allocations (
 			descriptor = ACPI_CAST_PTR (union acpi_descriptor, &element->user_space);
 			if (descriptor->descriptor_id != ACPI_DESC_TYPE_CACHED) {
 				acpi_os_printf ("%p Len %04X %9.9s-%d [%s] ",
-						 descriptor, element->size, element->module,
-						 element->line, acpi_ut_get_descriptor_name (descriptor));
+					descriptor, element->size, element->module,
+					element->line, acpi_ut_get_descriptor_name (descriptor));
 
 				/* Most of the elements will be Operand objects. */
 
 				switch (ACPI_GET_DESCRIPTOR_TYPE (descriptor)) {
 				case ACPI_DESC_TYPE_OPERAND:
 					acpi_os_printf ("%12.12s R%hd",
-							acpi_ut_get_type_name (descriptor->object.common.type),
-							descriptor->object.common.reference_count);
+						acpi_ut_get_type_name (descriptor->object.common.type),
+						descriptor->object.common.reference_count);
 					break;
 
 				case ACPI_DESC_TYPE_PARSER:
 					acpi_os_printf ("aml_opcode %04hX",
-							descriptor->op.asl.aml_opcode);
+						descriptor->op.asl.aml_opcode);
 					break;
 
 				case ACPI_DESC_TYPE_NAMED:
 					acpi_os_printf ("%4.4s",
-							acpi_ut_get_node_name (&descriptor->node));
+						acpi_ut_get_node_name (&descriptor->node));
 					break;
 
 				default:
@@ -983,6 +946,5 @@ acpi_ut_dump_allocations (
 	return_VOID;
 }
 
-
 #endif  /* #ifdef ACPI_DBG_TRACK_ALLOCATIONS */
 
diff --git a/drivers/acpi/utilities/utcache.c b/drivers/acpi/utilities/utcache.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/utilities/utcache.c
@@ -0,0 +1,328 @@
+/******************************************************************************
+ *
+ * Module Name: utcache - local cache allocation routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+
+#define _COMPONENT          ACPI_UTILITIES
+	 ACPI_MODULE_NAME    ("utcache")
+
+
+#ifdef ACPI_USE_LOCAL_CACHE
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_create_cache
+ *
+ * PARAMETERS:  cache_name      - Ascii name for the cache
+ *              object_size     - Size of each cached object
+ *              max_depth       - Maximum depth of the cache (in objects)
+ *              return_cache    - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a cache object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_create_cache (
+	char                            *cache_name,
+	u16                             object_size,
+	u16                             max_depth,
+	struct acpi_memory_list         **return_cache)
+{
+	struct acpi_memory_list         *cache;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	if (!cache_name || !return_cache || (object_size < 16)) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Create the cache object */
+
+	cache = acpi_os_allocate (sizeof (struct acpi_memory_list));
+	if (!cache) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Populate the cache object and return it */
+
+	ACPI_MEMSET (cache, 0, sizeof (struct acpi_memory_list));
+	cache->link_offset = 8;
+	cache->list_name  = cache_name;
+	cache->object_size = object_size;
+	cache->max_depth  = max_depth;
+
+	*return_cache = cache;
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_purge_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_purge_cache (
+	struct acpi_memory_list         *cache)
+{
+	char                            *next;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	if (!cache) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Walk the list of objects in this cache */
+
+	while (cache->list_head) {
+		/* Delete and unlink one cached state object */
+
+		next = *(ACPI_CAST_INDIRECT_PTR (char,
+				 &(((char *) cache->list_head)[cache->link_offset])));
+		ACPI_MEM_FREE (cache->list_head);
+
+		cache->list_head = next;
+		cache->current_depth--;
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_delete_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache and delete the
+ *              cache object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_delete_cache (
+	struct acpi_memory_list         *cache)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+   /* Purge all objects in the cache */
+
+	status = acpi_os_purge_cache (cache);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Now we can delete the cache object */
+
+	acpi_os_free (cache);
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_release_object
+ *
+ * PARAMETERS:  Cache       - Handle to cache object
+ *              Object      - The object to be released
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release an object to the specified cache.  If cache is full,
+ *              the object is deleted.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_release_object (
+	struct acpi_memory_list         *cache,
+	void                            *object)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	if (!cache || !object) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* If cache is full, just free this object */
+
+	if (cache->current_depth >= cache->max_depth) {
+		ACPI_MEM_FREE (object);
+		ACPI_MEM_TRACKING (cache->total_freed++);
+	}
+
+	/* Otherwise put this object back into the cache */
+
+	else {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
+		/* Mark the object as cached */
+
+		ACPI_MEMSET (object, 0xCA, cache->object_size);
+		ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_CACHED);
+
+		/* Put the object at the head of the cache list */
+
+		* (ACPI_CAST_INDIRECT_PTR (char,
+			&(((char *) object)[cache->link_offset]))) = cache->list_head;
+		cache->list_head = object;
+		cache->current_depth++;
+
+		(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_acquire_object
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      the acquired object.  NULL on error
+ *
+ * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
+ *              the object is allocated.
+ *
+ ******************************************************************************/
+
+void *
+acpi_os_acquire_object (
+	struct acpi_memory_list         *cache)
+{
+	acpi_status                     status;
+	void                            *object;
+
+
+	ACPI_FUNCTION_NAME ("os_acquire_object");
+
+
+	if (!cache) {
+		return (NULL);
+	}
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+	if (ACPI_FAILURE (status)) {
+		return (NULL);
+	}
+
+	ACPI_MEM_TRACKING (cache->requests++);
+
+	/* Check the cache first */
+
+	if (cache->list_head) {
+		/* There is an object available, use it */
+
+		object = cache->list_head;
+		cache->list_head = *(ACPI_CAST_INDIRECT_PTR (char,
+				 &(((char *) object)[cache->link_offset])));
+
+		cache->current_depth--;
+
+		ACPI_MEM_TRACKING (cache->hits++);
+		ACPI_MEM_TRACKING (ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Object %p from %s cache\n", object, cache->list_name)));
+
+		status = acpi_ut_release_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (status)) {
+			return (NULL);
+		}
+
+		/* Clear (zero) the previously used Object */
+
+		ACPI_MEMSET (object, 0, cache->object_size);
+	}
+	else {
+		/* The cache is empty, create a new object */
+
+		ACPI_MEM_TRACKING (cache->total_allocated++);
+
+		/* Avoid deadlock with ACPI_MEM_CALLOCATE */
+
+		status = acpi_ut_release_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (status)) {
+			return (NULL);
+		}
+
+		object = ACPI_MEM_CALLOCATE (cache->object_size);
+		if (!object) {
+			return (NULL);
+		}
+	}
+
+	return (object);
+}
+#endif /* ACPI_USE_LOCAL_CACHE */
+
+
diff --git a/drivers/acpi/utilities/utcopy.c b/drivers/acpi/utilities/utcopy.c
--- a/drivers/acpi/utilities/utcopy.c
+++ b/drivers/acpi/utilities/utcopy.c
@@ -49,21 +49,69 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utcopy")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_copy_isimple_to_esimple (
+	union acpi_operand_object       *internal_object,
+	union acpi_object               *external_object,
+	u8                              *data_space,
+	acpi_size                       *buffer_space_used);
+
+static acpi_status
+acpi_ut_copy_ielement_to_ielement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_epackage (
+	union acpi_operand_object       *internal_object,
+	u8                              *buffer,
+	acpi_size                       *space_used);
+
+static acpi_status
+acpi_ut_copy_esimple_to_isimple(
+	union acpi_object               *user_obj,
+	union acpi_operand_object       **return_obj);
+
+static acpi_status
+acpi_ut_copy_simple_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc);
+
+static acpi_status
+acpi_ut_copy_ielement_to_eelement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_ipackage (
+	union acpi_operand_object       *source_obj,
+	union acpi_operand_object       *dest_obj,
+	struct acpi_walk_state          *walk_state);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_copy_isimple_to_esimple
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *Buffer             - Where the object is returned
- *              *space_used         - Where the data length is returned
+ * PARAMETERS:  internal_object     - Source object to be copied
+ *              external_object     - Where to return the copied object
+ *              data_space          - Where object data is returned (such as
+ *                                    buffer and string data)
+ *              buffer_space_used   - Length of data_space that was used
  *
  * RETURN:      Status
  *
- * DESCRIPTION: This function is called to place a simple object in a user
- *              buffer.
+ * DESCRIPTION: This function is called to copy a simple internal object to
+ *              an external object.
  *
- *              The buffer is assumed to have sufficient space for the object.
+ *              The data_space buffer is assumed to have sufficient space for
+ *              the object.
  *
  ******************************************************************************/
 
@@ -107,10 +155,12 @@ acpi_ut_copy_isimple_to_esimple (
 
 		external_object->string.pointer = (char *) data_space;
 		external_object->string.length = internal_object->string.length;
-		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD ((acpi_size) internal_object->string.length + 1);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (
+				   (acpi_size) internal_object->string.length + 1);
 
-		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->string.pointer,
-				 (acpi_size) internal_object->string.length + 1);
+		ACPI_MEMCPY ((void *) data_space,
+			(void *) internal_object->string.pointer,
+			(acpi_size) internal_object->string.length + 1);
 		break;
 
 
@@ -118,10 +168,12 @@ acpi_ut_copy_isimple_to_esimple (
 
 		external_object->buffer.pointer = data_space;
 		external_object->buffer.length = internal_object->buffer.length;
-		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (internal_object->string.length);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (
+				   internal_object->string.length);
 
-		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->buffer.pointer,
-				 internal_object->buffer.length);
+		ACPI_MEMCPY ((void *) data_space,
+			(void *) internal_object->buffer.pointer,
+			internal_object->buffer.length);
 		break;
 
 
@@ -194,7 +246,7 @@ acpi_ut_copy_isimple_to_esimple (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ielement_to_eelement (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -213,7 +265,7 @@ acpi_ut_copy_ielement_to_eelement (
 
 	this_index   = state->pkg.index;
 	target_object = (union acpi_object *)
-			  &((union acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
+		&((union acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
 
 	switch (object_type) {
 	case ACPI_COPY_TYPE_SIMPLE:
@@ -236,7 +288,8 @@ acpi_ut_copy_ielement_to_eelement (
 		 */
 		target_object->type             = ACPI_TYPE_PACKAGE;
 		target_object->package.count    = source_object->package.count;
-		target_object->package.elements = ACPI_CAST_PTR (union acpi_object, info->free_space);
+		target_object->package.elements =
+			ACPI_CAST_PTR (union acpi_object, info->free_space);
 
 		/*
 		 * Pass the new package object back to the package walk routine
@@ -248,7 +301,8 @@ acpi_ut_copy_ielement_to_eelement (
 		 * update the buffer length counter
 		 */
 		object_space = ACPI_ROUND_UP_TO_NATIVE_WORD (
-				   (acpi_size) target_object->package.count * sizeof (union acpi_object));
+				   (acpi_size) target_object->package.count *
+				   sizeof (union acpi_object));
 		break;
 
 
@@ -266,9 +320,9 @@ acpi_ut_copy_ielement_to_eelement (
  *
  * FUNCTION:    acpi_ut_copy_ipackage_to_epackage
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are returning
- *              *Buffer             - Where the object is returned
- *              *space_used         - Where the object length is returned
+ * PARAMETERS:  internal_object     - Pointer to the object we are returning
+ *              Buffer              - Where the object is returned
+ *              space_used          - Where the object length is returned
  *
  * RETURN:      Status
  *
@@ -304,13 +358,15 @@ acpi_ut_copy_ipackage_to_epackage (
 	 * Free space begins right after the first package
 	 */
 	info.length      = ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
-	info.free_space  = buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
+	info.free_space  = buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (
+			   sizeof (union acpi_object));
 	info.object_space = 0;
 	info.num_packages = 1;
 
 	external_object->type            = ACPI_GET_OBJECT_TYPE (internal_object);
 	external_object->package.count   = internal_object->package.count;
-	external_object->package.elements = ACPI_CAST_PTR (union acpi_object, info.free_space);
+	external_object->package.elements = ACPI_CAST_PTR (union acpi_object,
+			  info.free_space);
 
 	/*
 	 * Leave room for an array of ACPI_OBJECTS in the buffer
@@ -333,8 +389,8 @@ acpi_ut_copy_ipackage_to_epackage (
  *
  * FUNCTION:    acpi_ut_copy_iobject_to_eobject
  *
- * PARAMETERS:  *internal_object    - The internal object to be converted
- *              *buffer_ptr         - Where the object is returned
+ * PARAMETERS:  internal_object     - The internal object to be converted
+ *              buffer_ptr          - Where the object is returned
  *
  * RETURN:      Status
  *
@@ -367,10 +423,10 @@ acpi_ut_copy_iobject_to_eobject (
 		 * Build a simple object (no nested objects)
 		 */
 		status = acpi_ut_copy_isimple_to_esimple (internal_object,
-				  (union acpi_object *) ret_buffer->pointer,
-				  ((u8 *) ret_buffer->pointer +
-				  ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object))),
-				  &ret_buffer->length);
+				 (union acpi_object *) ret_buffer->pointer,
+				 ((u8 *) ret_buffer->pointer +
+				 ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object))),
+				 &ret_buffer->length);
 		/*
 		 * build simple does not include the object size in the length
 		 * so we add it in here
@@ -386,8 +442,8 @@ acpi_ut_copy_iobject_to_eobject (
  *
  * FUNCTION:    acpi_ut_copy_esimple_to_isimple
  *
- * PARAMETERS:  *external_object   - The external object to be converted
- *              *internal_object   - Where the internal object is returned
+ * PARAMETERS:  external_object     - The external object to be converted
+ *              ret_internal_object - Where the internal object is returned
  *
  * RETURN:      Status
  *
@@ -398,7 +454,7 @@ acpi_ut_copy_iobject_to_eobject (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_esimple_to_isimple (
 	union acpi_object               *external_object,
 	union acpi_operand_object       **ret_internal_object)
@@ -417,7 +473,8 @@ acpi_ut_copy_esimple_to_isimple (
 	case ACPI_TYPE_BUFFER:
 	case ACPI_TYPE_INTEGER:
 
-		internal_object = acpi_ut_create_internal_object ((u8) external_object->type);
+		internal_object = acpi_ut_create_internal_object (
+				   (u8) external_object->type);
 		if (!internal_object) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -486,7 +543,6 @@ error_exit:
 
 
 #ifdef ACPI_FUTURE_IMPLEMENTATION
-
 /* Code to convert packages that are parameters to control methods */
 
 /*******************************************************************************
@@ -614,7 +670,7 @@ acpi_ut_copy_eobject_to_iobject (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_simple_object (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *dest_desc)
@@ -638,58 +694,50 @@ acpi_ut_copy_simple_object (
 	dest_desc->common.reference_count = reference_count;
 	dest_desc->common.next_object = next_object;
 
+	/* New object is not static, regardless of source */
+
+	dest_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
+
 	/* Handle the objects with extra data */
 
 	switch (ACPI_GET_OBJECT_TYPE (dest_desc)) {
 	case ACPI_TYPE_BUFFER:
-
-		dest_desc->buffer.node = NULL;
-		dest_desc->common.flags = source_desc->common.flags;
-
 		/*
 		 * Allocate and copy the actual buffer if and only if:
 		 * 1) There is a valid buffer pointer
-		 * 2) The buffer is not static (not in an ACPI table) (in this case,
-		 *    the actual pointer was already copied above)
+		 * 2) The buffer has a length > 0
 		 */
 		if ((source_desc->buffer.pointer) &&
-			(!(source_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
-			dest_desc->buffer.pointer = NULL;
+			(source_desc->buffer.length)) {
+			dest_desc->buffer.pointer =
+				ACPI_MEM_ALLOCATE (source_desc->buffer.length);
+			if (!dest_desc->buffer.pointer) {
+				return (AE_NO_MEMORY);
+			}
 
-			/* Create an actual buffer only if length > 0 */
+			/* Copy the actual buffer data */
 
-			if (source_desc->buffer.length) {
-				dest_desc->buffer.pointer =
-					ACPI_MEM_ALLOCATE (source_desc->buffer.length);
-				if (!dest_desc->buffer.pointer) {
-					return (AE_NO_MEMORY);
-				}
-
-				/* Copy the actual buffer data */
-
-				ACPI_MEMCPY (dest_desc->buffer.pointer,
-						source_desc->buffer.pointer,
-						source_desc->buffer.length);
-			}
+			ACPI_MEMCPY (dest_desc->buffer.pointer,
+					source_desc->buffer.pointer,
+					source_desc->buffer.length);
 		}
 		break;
 
 	case ACPI_TYPE_STRING:
-
 		/*
 		 * Allocate and copy the actual string if and only if:
 		 * 1) There is a valid string pointer
-		 * 2) The string is not static (not in an ACPI table) (in this case,
-		 *    the actual pointer was already copied above)
+		 * (Pointer to a NULL string is allowed)
 		 */
-		if ((source_desc->string.pointer) &&
-			(!(source_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+		if (source_desc->string.pointer) {
 			dest_desc->string.pointer =
 				ACPI_MEM_ALLOCATE ((acpi_size) source_desc->string.length + 1);
 			if (!dest_desc->string.pointer) {
 				return (AE_NO_MEMORY);
 			}
 
+			/* Copy the actual string data */
+
 			ACPI_MEMCPY (dest_desc->string.pointer, source_desc->string.pointer,
 					  (acpi_size) source_desc->string.length + 1);
 		}
@@ -724,7 +772,7 @@ acpi_ut_copy_simple_object (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ielement_to_ielement (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -837,7 +885,7 @@ error_exit:
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_copy_ipackage_to_ipackage (
 	union acpi_operand_object       *source_obj,
 	union acpi_operand_object       *dest_obj,
diff --git a/drivers/acpi/utilities/utdebug.c b/drivers/acpi/utilities/utdebug.c
--- a/drivers/acpi/utilities/utdebug.c
+++ b/drivers/acpi/utilities/utdebug.c
@@ -55,8 +55,14 @@ static u32   acpi_gbl_prev_thread_id = 0
 static char     *acpi_gbl_fn_entry_str = "----Entry";
 static char     *acpi_gbl_fn_exit_str = "----Exit-";
 
+/* Local prototypes */
 
-/*****************************************************************************
+static const char *
+acpi_ut_trim_function_name (
+	const char                      *function_name);
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_init_stack_ptr_trace
  *
@@ -64,22 +70,22 @@ static char     *acpi_gbl_fn_exit_str = 
  *
  * RETURN:      None
  *
- * DESCRIPTION: Save the current stack pointer
+ * DESCRIPTION: Save the current CPU stack pointer at subsystem startup
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_init_stack_ptr_trace (
 	void)
 {
-	u32                         current_sp;
+	u32                             current_sp;
 
 
 	acpi_gbl_entry_stack_pointer = ACPI_PTR_DIFF (&current_sp, NULL);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_track_stack_ptr
  *
@@ -87,15 +93,15 @@ acpi_ut_init_stack_ptr_trace (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Save the current stack pointer
+ * DESCRIPTION: Save the current CPU stack pointer
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_track_stack_ptr (
 	void)
 {
-	acpi_size                   current_sp;
+	acpi_size                       current_sp;
 
 
 	current_sp = ACPI_PTR_DIFF (&current_sp, NULL);
@@ -110,16 +116,52 @@ acpi_ut_track_stack_ptr (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trim_function_name
+ *
+ * PARAMETERS:  function_name       - Ascii string containing a procedure name
+ *
+ * RETURN:      Updated pointer to the function name
+ *
+ * DESCRIPTION: Remove the "Acpi" prefix from the function name, if present.
+ *              This allows compiler macros such as __FUNCTION__ to be used
+ *              with no change to the debug output.
+ *
+ ******************************************************************************/
+
+static const char *
+acpi_ut_trim_function_name (
+	const char                      *function_name)
+{
+
+	/* All Function names are longer than 4 chars, check is safe */
+
+	if (*(ACPI_CAST_PTR (u32, function_name)) == ACPI_FUNCTION_PREFIX1) {
+		/* This is the case where the original source has not been modified */
+
+		return (function_name + 4);
+	}
+
+	if (*(ACPI_CAST_PTR (u32, function_name)) == ACPI_FUNCTION_PREFIX2) {
+		/* This is the case where the source has been 'linuxized' */
+
+		return (function_name + 5);
+	}
+
+	return (function_name);
+}
+
+
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_debug_print
  *
- * PARAMETERS:  debug_level         - Requested debug print level
- *              proc_name           - Caller's procedure name
- *              module_name         - Caller's module name (for error output)
+ * PARAMETERS:  requested_debug_level - Requested debug print level
  *              line_number         - Caller's line number (for error output)
- *              component_id        - Caller's component ID (for error output)
- *
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Format              - Printf format field
  *              ...                 - Optional printf arguments
  *
@@ -128,13 +170,15 @@ acpi_ut_track_stack_ptr (
  * DESCRIPTION: Print error message with prefix consisting of the module name,
  *              line number, and component ID.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print (
 	u32                             requested_debug_level,
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *format,
 	...)
 {
@@ -146,7 +190,7 @@ acpi_ut_debug_print (
 	 * Stay silent if the debug level or component ID is disabled
 	 */
 	if (!(requested_debug_level & acpi_dbg_level) ||
-		!(dbg_info->component_id & acpi_dbg_layer)) {
+		!(component_id & acpi_dbg_layer)) {
 		return;
 	}
 
@@ -157,7 +201,8 @@ acpi_ut_debug_print (
 
 	if (thread_id != acpi_gbl_prev_thread_id) {
 		if (ACPI_LV_THREADS & acpi_dbg_level) {
-			acpi_os_printf ("\n**** Context Switch from TID %X to TID %X ****\n\n",
+			acpi_os_printf (
+				"\n**** Context Switch from TID %X to TID %X ****\n\n",
 				acpi_gbl_prev_thread_id, thread_id);
 		}
 
@@ -168,30 +213,30 @@ acpi_ut_debug_print (
 	 * Display the module name, current line number, thread ID (if requested),
 	 * current procedure nesting level, and the current procedure name
 	 */
-	acpi_os_printf ("%8s-%04ld ", dbg_info->module_name, line_number);
+	acpi_os_printf ("%8s-%04ld ", module_name, line_number);
 
 	if (ACPI_LV_THREADS & acpi_dbg_level) {
 		acpi_os_printf ("[%04lX] ", thread_id);
 	}
 
-	acpi_os_printf ("[%02ld] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
+	acpi_os_printf ("[%02ld] %-22.22s: ",
+		acpi_gbl_nesting_level, acpi_ut_trim_function_name (function_name));
 
 	va_start (args, format);
 	acpi_os_vprintf (format, args);
 }
-EXPORT_SYMBOL(acpi_ut_debug_print);
 
+EXPORT_SYMBOL(acpi_ut_debug_print);
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_debug_print_raw
  *
  * PARAMETERS:  requested_debug_level - Requested debug print level
  *              line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Format              - Printf format field
  *              ...                 - Optional printf arguments
  *
@@ -200,13 +245,15 @@ EXPORT_SYMBOL(acpi_ut_debug_print);
  * DESCRIPTION: Print message with no headers.  Has same interface as
  *              debug_print so that the same macros can be used.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print_raw (
 	u32                             requested_debug_level,
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *format,
 	...)
 {
@@ -214,7 +261,7 @@ acpi_ut_debug_print_raw (
 
 
 	if (!(requested_debug_level & acpi_dbg_level) ||
-		!(dbg_info->component_id & acpi_dbg_layer)) {
+		!(component_id & acpi_dbg_layer)) {
 		return;
 	}
 
@@ -224,47 +271,48 @@ acpi_ut_debug_print_raw (
 EXPORT_SYMBOL(acpi_ut_debug_print_raw);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info)
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id)
 {
 
 	acpi_gbl_nesting_level++;
 	acpi_ut_track_stack_ptr ();
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s\n", acpi_gbl_fn_entry_str);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s\n", acpi_gbl_fn_entry_str);
 }
 EXPORT_SYMBOL(acpi_ut_trace);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_ptr
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Pointer             - Pointer to display
  *
  * RETURN:      None
@@ -272,31 +320,33 @@ EXPORT_SYMBOL(acpi_ut_trace);
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_ptr (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	void                            *pointer)
 {
 	acpi_gbl_nesting_level++;
 	acpi_ut_track_stack_ptr ();
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %p\n", acpi_gbl_fn_entry_str, pointer);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s %p\n", acpi_gbl_fn_entry_str, pointer);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_str
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              String              - Additional string to display
  *
  * RETURN:      None
@@ -304,32 +354,34 @@ acpi_ut_trace_ptr (
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_str (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *string)
 {
 
 	acpi_gbl_nesting_level++;
 	acpi_ut_track_stack_ptr ();
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %s\n", acpi_gbl_fn_entry_str, string);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s %s\n", acpi_gbl_fn_entry_str, string);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_trace_u32
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Integer             - Integer to display
  *
  * RETURN:      None
@@ -337,63 +389,67 @@ acpi_ut_trace_str (
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_trace_u32 (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	u32                             integer)
 {
 
 	acpi_gbl_nesting_level++;
 	acpi_ut_track_stack_ptr ();
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %08X\n", acpi_gbl_fn_entry_str, integer);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s %08X\n", acpi_gbl_fn_entry_str, integer);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_exit
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info)
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id)
 {
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s\n", acpi_gbl_fn_exit_str);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s\n", acpi_gbl_fn_exit_str);
 
 	acpi_gbl_nesting_level--;
 }
 EXPORT_SYMBOL(acpi_ut_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_status_exit
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Status              - Exit status code
  *
  * RETURN:      None
@@ -401,24 +457,28 @@ EXPORT_SYMBOL(acpi_ut_exit);
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit status also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_status_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	acpi_status                     status)
 {
 
 	if (ACPI_SUCCESS (status)) {
-		acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-				"%s %s\n", acpi_gbl_fn_exit_str,
-				acpi_format_exception (status));
+		acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+			line_number, function_name, module_name, component_id,
+			"%s %s\n", acpi_gbl_fn_exit_str,
+			acpi_format_exception (status));
 	}
 	else {
-		acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-				"%s ****Exception****: %s\n", acpi_gbl_fn_exit_str,
-				acpi_format_exception (status));
+		acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+			line_number, function_name, module_name, component_id,
+			"%s ****Exception****: %s\n", acpi_gbl_fn_exit_str,
+			acpi_format_exception (status));
 	}
 
 	acpi_gbl_nesting_level--;
@@ -426,15 +486,14 @@ acpi_ut_status_exit (
 EXPORT_SYMBOL(acpi_ut_status_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_value_exit
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
  *              Value               - Value to be printed with exit msg
  *
  * RETURN:      None
@@ -442,51 +501,56 @@ EXPORT_SYMBOL(acpi_ut_status_exit);
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit value also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_value_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	acpi_integer                    value)
 {
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %8.8X%8.8X\n", acpi_gbl_fn_exit_str,
-			ACPI_FORMAT_UINT64 (value));
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s %8.8X%8.8X\n", acpi_gbl_fn_exit_str,
+		ACPI_FORMAT_UINT64 (value));
 
 	acpi_gbl_nesting_level--;
 }
 EXPORT_SYMBOL(acpi_ut_value_exit);
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_ptr_exit
  *
  * PARAMETERS:  line_number         - Caller's line number
- *              dbg_info            - Contains:
- *                  proc_name           - Caller's procedure name
- *                  module_name         - Caller's module name
- *                  component_id        - Caller's component ID
- *              Value               - Value to be printed with exit msg
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Ptr                 - Pointer to display
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
  *              set in debug_level. Prints exit value also.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_ptr_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	u8                              *ptr)
 {
 
-	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %p\n", acpi_gbl_fn_exit_str, ptr);
+	acpi_ut_debug_print (ACPI_LV_FUNCTIONS,
+		line_number, function_name, module_name, component_id,
+		"%s %p\n", acpi_gbl_fn_exit_str, ptr);
 
 	acpi_gbl_nesting_level--;
 }
@@ -494,7 +558,7 @@ acpi_ut_ptr_exit (
 #endif
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_dump_buffer
  *
@@ -507,7 +571,7 @@ acpi_ut_ptr_exit (
  *
  * DESCRIPTION: Generic dump buffer in both hex and ascii.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_dump_buffer (
@@ -533,34 +597,28 @@ acpi_ut_dump_buffer (
 		display = DB_BYTE_DISPLAY;
 	}
 
-	acpi_os_printf ("\nOffset Value\n");
+	/* Nasty little dump buffer routine! */
 
-	/*
-	 * Nasty little dump buffer routine!
-	 */
 	while (i < count) {
 		/* Print current offset */
 
-		acpi_os_printf ("%05X  ", (u32) i);
+		acpi_os_printf ("%6.4X: ", (u32) i);
 
 		/* Print 16 hex chars */
 
 		for (j = 0; j < 16;) {
 			if (i + j >= count) {
-				acpi_os_printf ("\n");
-				return;
-			}
+				/* Dump fill spaces */
 
-			/* Make sure that the s8 doesn't get sign-extended! */
+				acpi_os_printf ("%*s", ((display * 2) + 1), " ");
+				j += (acpi_native_uint) display;
+				continue;
+			}
 
 			switch (display) {
-			/* Default is BYTE display */
+			default:    /* Default is BYTE display */
 
-			default:
-
-				acpi_os_printf ("%02X ",
-						*((u8 *) &buffer[i + j]));
-				j += 1;
+				acpi_os_printf ("%02X ", buffer[i + j]);
 				break;
 
 
@@ -568,7 +626,6 @@ acpi_ut_dump_buffer (
 
 				ACPI_MOVE_16_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%04X ", temp32);
-				j += 2;
 				break;
 
 
@@ -576,7 +633,6 @@ acpi_ut_dump_buffer (
 
 				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%08X ", temp32);
-				j += 4;
 				break;
 
 
@@ -587,15 +643,17 @@ acpi_ut_dump_buffer (
 
 				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j + 4]);
 				acpi_os_printf ("%08X ", temp32);
-				j += 8;
 				break;
 			}
+
+			j += (acpi_native_uint) display;
 		}
 
 		/*
-		 * Print the ASCII equivalent characters
-		 * But watch out for the bad unprintable ones...
+		 * Print the ASCII equivalent characters but watch out for the bad
+		 * unprintable ones (printable chars are 0x20 through 0x7E)
 		 */
+		acpi_os_printf (" ");
 		for (j = 0; j < 16; j++) {
 			if (i + j >= count) {
 				acpi_os_printf ("\n");
@@ -603,9 +661,7 @@ acpi_ut_dump_buffer (
 			}
 
 			buf_char = buffer[i + j];
-			if ((buf_char > 0x1F && buf_char < 0x2E) ||
-				(buf_char > 0x2F && buf_char < 0x61) ||
-				(buf_char > 0x60 && buf_char < 0x7F)) {
+			if (ACPI_IS_PRINT (buf_char)) {
 				acpi_os_printf ("%c", buf_char);
 			}
 			else {
diff --git a/drivers/acpi/utilities/utdelete.c b/drivers/acpi/utilities/utdelete.c
--- a/drivers/acpi/utilities/utdelete.c
+++ b/drivers/acpi/utilities/utdelete.c
@@ -51,12 +51,23 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utdelete")
 
+/* Local prototypes */
+
+static void
+acpi_ut_delete_internal_obj (
+	union acpi_operand_object       *object);
+
+static void
+acpi_ut_update_ref_count (
+	union acpi_operand_object       *object,
+	u32                             action);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_delete_internal_obj
  *
- * PARAMETERS:  *Object        - Pointer to the list to be deleted
+ * PARAMETERS:  Object         - Object to be deleted
  *
  * RETURN:      None
  *
@@ -65,7 +76,7 @@
  *
  ******************************************************************************/
 
-void
+static void
 acpi_ut_delete_internal_obj (
 	union acpi_operand_object       *object)
 {
@@ -152,7 +163,8 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_MUTEX:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Mutex %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Mutex %p, Semaphore %p\n",
 			object, object->mutex.semaphore));
 
 		acpi_ex_unlink_mutex (object);
@@ -162,7 +174,8 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_EVENT:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Event %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Event %p, Semaphore %p\n",
 			object, object->event.semaphore));
 
 		(void) acpi_os_delete_semaphore (object->event.semaphore);
@@ -172,7 +185,8 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_METHOD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Method %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Method %p\n", object));
 
 		/* Delete the method semaphore if it exists */
 
@@ -185,7 +199,8 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_REGION:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Region %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Region %p\n", object));
 
 		second_desc = acpi_ns_get_secondary_object (object);
 		if (second_desc) {
@@ -212,7 +227,8 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Buffer Field %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"***** Buffer Field %p\n", object));
 
 		second_desc = acpi_ns_get_secondary_object (object);
 		if (second_desc) {
@@ -247,7 +263,7 @@ acpi_ut_delete_internal_obj (
  *
  * FUNCTION:    acpi_ut_delete_internal_object_list
  *
- * PARAMETERS:  *obj_list       - Pointer to the list to be deleted
+ * PARAMETERS:  obj_list        - Pointer to the list to be deleted
  *
  * RETURN:      None
  *
@@ -283,7 +299,7 @@ acpi_ut_delete_internal_object_list (
  *
  * FUNCTION:    acpi_ut_update_ref_count
  *
- * PARAMETERS:  *Object         - Object whose ref count is to be updated
+ * PARAMETERS:  Object          - Object whose ref count is to be updated
  *              Action          - What to do
  *
  * RETURN:      New ref count
@@ -312,7 +328,8 @@ acpi_ut_update_ref_count (
 	new_count = count;
 
 	/*
-	 * Perform the reference count action (increment, decrement, or force delete)
+	 * Perform the reference count action
+	 * (increment, decrement, or force delete)
 	 */
 	switch (action) {
 
@@ -321,7 +338,8 @@ acpi_ut_update_ref_count (
 		new_count++;
 		object->common.reference_count = new_count;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Incremented]\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"Obj %p Refs=%X, [Incremented]\n",
 			object, new_count));
 		break;
 
@@ -329,7 +347,8 @@ acpi_ut_update_ref_count (
 	case REF_DECREMENT:
 
 		if (count < 1) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Obj %p Refs=%X, can't decrement! (Set to 0)\n",
 				object, new_count));
 
 			new_count = 0;
@@ -337,12 +356,14 @@ acpi_ut_update_ref_count (
 		else {
 			new_count--;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Decremented]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
 		if (ACPI_GET_OBJECT_TYPE (object) == ACPI_TYPE_METHOD) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Method Obj %p Refs=%X, [Decremented]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Method Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
@@ -356,7 +377,8 @@ acpi_ut_update_ref_count (
 
 	case REF_FORCE_DELETE:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, Force delete! (Set to 0)\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+			"Obj %p Refs=%X, Force delete! (Set to 0)\n",
 			object, count));
 
 		new_count = 0;
@@ -390,7 +412,7 @@ acpi_ut_update_ref_count (
  *
  * FUNCTION:    acpi_ut_update_object_reference
  *
- * PARAMETERS:  *Object             - Increment ref count for this object
+ * PARAMETERS:  Object              - Increment ref count for this object
  *                                    and all sub-objects
  *              Action              - Either REF_INCREMENT or REF_DECREMENT or
  *                                    REF_FORCE_DELETE
@@ -413,34 +435,24 @@ acpi_ut_update_object_reference (
 	union acpi_operand_object       *object,
 	u16                             action)
 {
-	acpi_status                     status;
-	u32                             i;
-	union acpi_generic_state         *state_list = NULL;
-	union acpi_generic_state         *state;
-	union acpi_operand_object        *tmp;
-
-	ACPI_FUNCTION_TRACE_PTR ("ut_update_object_reference", object);
+	acpi_status                     status = AE_OK;
+	union acpi_generic_state        *state_list = NULL;
+	union acpi_operand_object       *next_object = NULL;
+	union acpi_generic_state        *state;
+	acpi_native_uint                i;
 
 
-	/* Ignore a null object ptr */
-
-	if (!object) {
-		return_ACPI_STATUS (AE_OK);
-	}
-
-	/* Make sure that this isn't a namespace handle */
+	ACPI_FUNCTION_TRACE_PTR ("ut_update_object_reference", object);
 
-	if (ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Object %p is NS handle\n", object));
-		return_ACPI_STATUS (AE_OK);
-	}
 
-	state = acpi_ut_create_update_state (object, action);
+	while (object) {
+		/* Make sure that this isn't a namespace handle */
 
-	while (state) {
-		object = state->update.object;
-		action = state->update.value;
-		acpi_ut_delete_generic_state (state);
+		if (ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+				"Object %p is NS handle\n", object));
+			return_ACPI_STATUS (AE_OK);
+		}
 
 		/*
 		 * All sub-objects must have their reference count incremented also.
@@ -449,24 +461,14 @@ acpi_ut_update_object_reference (
 		switch (ACPI_GET_OBJECT_TYPE (object)) {
 		case ACPI_TYPE_DEVICE:
 
-			tmp = object->device.system_notify;
-			if (tmp && (tmp->common.reference_count <= 1) && action == REF_DECREMENT)
-				object->device.system_notify = NULL;
-			acpi_ut_update_ref_count (tmp, action);
-
-			tmp = object->device.device_notify;
-			if (tmp && (tmp->common.reference_count <= 1) && action == REF_DECREMENT)
-				object->device.device_notify = NULL;
-			acpi_ut_update_ref_count (tmp, action);
-
+			acpi_ut_update_ref_count (object->device.system_notify, action);
+			acpi_ut_update_ref_count (object->device.device_notify, action);
 			break;
 
-
 		case ACPI_TYPE_PACKAGE:
-
 			/*
-			 * We must update all the sub-objects of the package
-			 * (Each of whom may have their own sub-objects, etc.
+			 * We must update all the sub-objects of the package,
+			 * each of whom may have their own sub-objects.
 			 */
 			for (i = 0; i < object->package.count; i++) {
 				/*
@@ -479,111 +481,52 @@ acpi_ut_update_object_reference (
 				if (ACPI_FAILURE (status)) {
 					goto error_exit;
 				}
-
-				tmp = object->package.elements[i];
-				if (tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-					object->package.elements[i] = NULL;
 			}
 			break;
 
-
 		case ACPI_TYPE_BUFFER_FIELD:
 
-			status = acpi_ut_create_update_state_and_push (
-					 object->buffer_field.buffer_obj, action, &state_list);
-			if (ACPI_FAILURE (status)) {
-				goto error_exit;
-			}
-
-			tmp = object->buffer_field.buffer_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->buffer_field.buffer_obj = NULL;
+			next_object = object->buffer_field.buffer_obj;
 			break;
 
-
 		case ACPI_TYPE_LOCAL_REGION_FIELD:
 
-			status = acpi_ut_create_update_state_and_push (
-					 object->field.region_obj, action, &state_list);
-			if (ACPI_FAILURE (status)) {
-				goto error_exit;
-			}
-
-			tmp = object->field.region_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->field.region_obj = NULL;
-		   break;
-
+			next_object = object->field.region_obj;
+			break;
 
 		case ACPI_TYPE_LOCAL_BANK_FIELD:
 
-			status = acpi_ut_create_update_state_and_push (
-					 object->bank_field.bank_obj, action, &state_list);
-			if (ACPI_FAILURE (status)) {
-				goto error_exit;
-			}
-
-			tmp = object->bank_field.bank_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->bank_field.bank_obj = NULL;
-
+			next_object = object->bank_field.bank_obj;
 			status = acpi_ut_create_update_state_and_push (
 					 object->bank_field.region_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
 				goto error_exit;
 			}
-
-			tmp = object->bank_field.region_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->bank_field.region_obj = NULL;
 			break;
 
-
 		case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-			status = acpi_ut_create_update_state_and_push (
-					 object->index_field.index_obj, action, &state_list);
-			if (ACPI_FAILURE (status)) {
-				goto error_exit;
-			}
-
-			tmp = object->index_field.index_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->index_field.index_obj = NULL;
-
+			next_object = object->index_field.index_obj;
 			status = acpi_ut_create_update_state_and_push (
 					 object->index_field.data_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
 				goto error_exit;
 			}
-
-			tmp = object->index_field.data_obj;
-			if ( tmp && (tmp->common.reference_count <= 1)  && action == REF_DECREMENT)
-				object->index_field.data_obj = NULL;
 			break;
 
-
 		case ACPI_TYPE_LOCAL_REFERENCE:
-
 			/*
 			 * The target of an Index (a package, string, or buffer) must track
 			 * changes to the ref count of the index.
 			 */
 			if (object->reference.opcode == AML_INDEX_OP) {
-				status = acpi_ut_create_update_state_and_push (
-						 object->reference.object, action, &state_list);
-				if (ACPI_FAILURE (status)) {
-					goto error_exit;
-				}
+				next_object = object->reference.object;
 			}
 			break;
 
-
 		case ACPI_TYPE_REGION:
 		default:
-
-			/* No subobjects */
-			break;
+			break;/* No subobjects */
 		}
 
 		/*
@@ -592,15 +535,23 @@ acpi_ut_update_object_reference (
 		 * main object to be deleted.
 		 */
 		acpi_ut_update_ref_count (object, action);
+		object = NULL;
 
 		/* Move on to the next object to be updated */
 
-		state = acpi_ut_pop_generic_state (&state_list);
+		if (next_object) {
+			object = next_object;
+			next_object = NULL;
+		}
+		else if (state_list) {
+			state = acpi_ut_pop_generic_state (&state_list);
+			object = state->update.object;
+			acpi_ut_delete_generic_state (state);
+		}
 	}
 
 	return_ACPI_STATUS (AE_OK);
 
-
 error_exit:
 
 	ACPI_REPORT_ERROR (("Could not update object reference count, %s\n",
@@ -614,8 +565,8 @@ error_exit:
  *
  * FUNCTION:    acpi_ut_add_reference
  *
- * PARAMETERS:  *Object        - Object whose reference count is to be
- *                                  incremented
+ * PARAMETERS:  Object          - Object whose reference count is to be
+ *                                incremented
  *
  * RETURN:      None
  *
@@ -652,7 +603,7 @@ acpi_ut_add_reference (
  *
  * FUNCTION:    acpi_ut_remove_reference
  *
- * PARAMETERS:  *Object        - Object whose ref count will be decremented
+ * PARAMETERS:  Object         - Object whose ref count will be decremented
  *
  * RETURN:      None
  *
diff --git a/drivers/acpi/utilities/uteval.c b/drivers/acpi/utilities/uteval.c
--- a/drivers/acpi/utilities/uteval.c
+++ b/drivers/acpi/utilities/uteval.c
@@ -50,6 +50,19 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("uteval")
 
+/* Local prototypes */
+
+static void
+acpi_ut_copy_id_string (
+	char                            *destination,
+	char                            *source,
+	acpi_size                       max_length);
+
+static acpi_status
+acpi_ut_translate_one_cid (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_compatible_id       *one_cid);
+
 
 /*******************************************************************************
  *
@@ -237,9 +250,9 @@ acpi_ut_evaluate_object (
  *
  * FUNCTION:    acpi_ut_evaluate_numeric_object
  *
- * PARAMETERS:  *object_name        - Object name to be evaluated
+ * PARAMETERS:  object_name         - Object name to be evaluated
  *              device_node         - Node for the device
- *              *Address            - Where the value is returned
+ *              Address             - Where the value is returned
  *
  * RETURN:      Status
  *
@@ -303,7 +316,6 @@ acpi_ut_copy_id_string (
 	acpi_size                       max_length)
 {
 
-
 	/*
 	 * Workaround for ID strings that have a leading asterisk. This construct
 	 * is not allowed by the ACPI specification  (ID strings must be
@@ -325,7 +337,7 @@ acpi_ut_copy_id_string (
  * FUNCTION:    acpi_ut_execute_HID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Hid                - Where the HID is returned
+ *              Hid                 - Where the HID is returned
  *
  * RETURN:      Status
  *
@@ -429,7 +441,7 @@ acpi_ut_translate_one_cid (
  * FUNCTION:    acpi_ut_execute_CID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Cid                - Where the CID is returned
+ *              return_cid_list     - Where the CID list is returned
  *
  * RETURN:      Status
  *
@@ -488,10 +500,10 @@ acpi_ut_execute_CID (
 	cid_list->size = size;
 
 	/*
-	 *  A _CID can return either a single compatible ID or a package of compatible
-	 *  IDs.  Each compatible ID can be one of the following:
-	 *  -- Number (32 bit compressed EISA ID) or
-	 *  -- String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss").
+	 *  A _CID can return either a single compatible ID or a package of
+	 *  compatible IDs.  Each compatible ID can be one of the following:
+	 *  1) Integer (32 bit compressed EISA ID) or
+	 *  2) String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss")
 	 */
 
 	/* The _CID object can be either a single CID or a package (list) of CIDs */
@@ -534,7 +546,7 @@ acpi_ut_execute_CID (
  * FUNCTION:    acpi_ut_execute_UID
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Uid                - Where the UID is returned
+ *              Uid                 - Where the UID is returned
  *
  * RETURN:      Status
  *
@@ -587,7 +599,7 @@ acpi_ut_execute_UID (
  * FUNCTION:    acpi_ut_execute_STA
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Flags              - Where the status flags are returned
+ *              Flags               - Where the status flags are returned
  *
  * RETURN:      Status
  *
@@ -641,7 +653,7 @@ acpi_ut_execute_STA (
  * FUNCTION:    acpi_ut_execute_Sxds
  *
  * PARAMETERS:  device_node         - Node for the device
- *              *Flags              - Where the status flags are returned
+ *              Flags               - Where the status flags are returned
  *
  * RETURN:      Status
  *
diff --git a/drivers/acpi/utilities/utglobal.c b/drivers/acpi/utilities/utglobal.c
--- a/drivers/acpi/utilities/utglobal.c
+++ b/drivers/acpi/utilities/utglobal.c
@@ -44,7 +44,6 @@
 #define DEFINE_ACPI_GLOBALS
 
 #include <linux/module.h>
-
 #include <acpi/acpi.h>
 #include <acpi/acnamesp.h>
 
@@ -52,13 +51,14 @@
 	 ACPI_MODULE_NAME    ("utglobal")
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_format_exception
  *
  * PARAMETERS:  Status       - The acpi_status code to be formatted
  *
- * RETURN:      A string containing the exception  text
+ * RETURN:      A string containing the exception text. A valid pointer is
+ *              always returned.
  *
  * DESCRIPTION: This function translates an ACPI exception into an ASCII string.
  *
@@ -68,8 +68,8 @@ const char *
 acpi_format_exception (
 	acpi_status                     status)
 {
-	const char                      *exception = "UNKNOWN_STATUS_CODE";
 	acpi_status                     sub_status;
+	const char                      *exception = NULL;
 
 
 	ACPI_FUNCTION_NAME ("format_exception");
@@ -82,57 +82,55 @@ acpi_format_exception (
 
 		if (sub_status <= AE_CODE_ENV_MAX) {
 			exception = acpi_gbl_exception_names_env [sub_status];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_PROGRAMMER:
 
 		if (sub_status <= AE_CODE_PGM_MAX) {
 			exception = acpi_gbl_exception_names_pgm [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_ACPI_TABLES:
 
 		if (sub_status <= AE_CODE_TBL_MAX) {
 			exception = acpi_gbl_exception_names_tbl [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_AML:
 
 		if (sub_status <= AE_CODE_AML_MAX) {
 			exception = acpi_gbl_exception_names_aml [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	case AE_CODE_CONTROL:
 
 		if (sub_status <= AE_CODE_CTRL_MAX) {
 			exception = acpi_gbl_exception_names_ctrl [sub_status -1];
-			break;
 		}
-		goto unknown;
+		break;
 
 	default:
-		goto unknown;
+		break;
 	}
 
+	if (!exception) {
+		/* Exception code was not recognized */
 
-	return ((const char *) exception);
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown exception code: 0x%8.8X\n", status));
 
-unknown:
+		return ((const char *) "UNKNOWN_STATUS_CODE");
+	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown exception code: 0x%8.8X\n", status));
 	return ((const char *) exception);
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Static global variable initialization.
  *
@@ -212,13 +210,12 @@ const char                          *acp
 };
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Namespace globals
  *
  ******************************************************************************/
 
-
 /*
  * Predefined ACPI Names (Built-in to the Interpreter)
  *
@@ -241,9 +238,11 @@ const struct acpi_predefined_names      
 #if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
 	{"_OSI",    ACPI_TYPE_METHOD,           (char *) 1},
 #endif
-	{NULL,      ACPI_TYPE_ANY,              NULL}              /* Table terminator */
-};
 
+	/* Table terminator */
+
+	{NULL,      ACPI_TYPE_ANY,              NULL}
+};
 
 /*
  * Properties of the ACPI Object Types, both internal and external.
@@ -288,22 +287,25 @@ const u8                                
 /* Hex to ASCII conversion table */
 
 static const char                   acpi_gbl_hex_to_ascii[] =
-			  {'0','1','2','3','4','5','6','7',
-					 '8','9','A','B','C','D','E','F'};
+{
+	'0','1','2','3','4','5','6','7',
+	'8','9','A','B','C','D','E','F'
+};
+
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_hex_to_ascii_char
  *
  * PARAMETERS:  Integer             - Contains the hex digit
  *              Position            - bit position of the digit within the
- *                                    integer
+ *                                    integer (multiple of 4)
  *
- * RETURN:      Ascii character
+ * RETURN:      The converted Ascii character
  *
- * DESCRIPTION: Convert a hex digit to an ascii character
+ * DESCRIPTION: Convert a hex digit to an Ascii character
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char
 acpi_ut_hex_to_ascii_char (
@@ -315,7 +317,7 @@ acpi_ut_hex_to_ascii_char (
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * Table name globals
  *
@@ -324,7 +326,7 @@ acpi_ut_hex_to_ascii_char (
  * that are not used by the subsystem are simply ignored.
  *
  * Do NOT add any table to this list that is not consumed directly by this
- * subsystem.
+ * subsystem (No MADT, ECDT, SBST, etc.)
  *
  ******************************************************************************/
 
@@ -391,7 +393,7 @@ struct acpi_fixed_event_info        acpi
 	/* ACPI_EVENT_RTC           */  {ACPI_BITREG_RT_CLOCK_STATUS,       ACPI_BITREG_RT_CLOCK_ENABLE,     ACPI_BITMASK_RT_CLOCK_STATUS,       ACPI_BITMASK_RT_CLOCK_ENABLE},
 };
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_region_name
  *
@@ -401,7 +403,7 @@ struct acpi_fixed_event_info        acpi
  *
  * DESCRIPTION: Translate a Space ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /* Region type decoding */
 
@@ -429,7 +431,6 @@ acpi_ut_get_region_name (
 	{
 		return ("user_defined_region");
 	}
-
 	else if (space_id >= ACPI_NUM_PREDEFINED_REGIONS)
 	{
 		return ("invalid_space_id");
@@ -439,7 +440,7 @@ acpi_ut_get_region_name (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_event_name
  *
@@ -449,7 +450,7 @@ acpi_ut_get_region_name (
  *
  * DESCRIPTION: Translate a Event ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /* Event type decoding */
 
@@ -477,7 +478,7 @@ acpi_ut_get_event_name (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_type_name
  *
@@ -487,20 +488,21 @@ acpi_ut_get_event_name (
  *
  * DESCRIPTION: Translate a Type ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 /*
  * Elements of acpi_gbl_ns_type_names below must match
  * one-to-one with values of acpi_object_type
  *
- * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching; when
- * stored in a table it really means that we have thus far seen no evidence to
- * indicate what type is actually going to be stored for this entry.
+ * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;
+ * when stored in a table it really means that we have thus far seen no
+ * evidence to indicate what type is actually going to be stored for this entry.
  */
 static const char                   acpi_gbl_bad_type[] = "UNDEFINED";
-#define TYPE_NAME_LENGTH    12                           /* Maximum length of each string */
 
-static const char                   *acpi_gbl_ns_type_names[] = /* printable names of ACPI types */
+/* Printable names of the ACPI object types */
+
+static const char                   *acpi_gbl_ns_type_names[] =
 {
 	/* 00 */ "Untyped",
 	/* 01 */ "Integer",
@@ -564,7 +566,7 @@ acpi_ut_get_object_type_name (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_node_name
  *
@@ -574,7 +576,7 @@ acpi_ut_get_object_type_name (
  *
  * DESCRIPTION: Validate the node and return the node's ACPI name.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char *
 acpi_ut_get_node_name (
@@ -618,7 +620,7 @@ acpi_ut_get_node_name (
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_descriptor_name
  *
@@ -628,9 +630,11 @@ acpi_ut_get_node_name (
  *
  * DESCRIPTION: Validate object and return the descriptor type
  *
- ****************************************************************************/
+ ******************************************************************************/
 
-static const char                   *acpi_gbl_desc_type_names[] = /* printable names of descriptor types */
+/* Printable names of object descriptor types */
+
+static const char                   *acpi_gbl_desc_type_names[] =
 {
 	/* 00 */ "Invalid",
 	/* 01 */ "Cached",
@@ -676,17 +680,18 @@ acpi_ut_get_descriptor_name (
  * Strings and procedures used for debug only
  */
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_mutex_name
  *
- * PARAMETERS:  None.
+ * PARAMETERS:  mutex_id        - The predefined ID for this mutex.
  *
- * RETURN:      Status
+ * RETURN:      String containing the name of the mutex. Always returns a valid
+ *              pointer.
  *
  * DESCRIPTION: Translate a mutex ID into a name string (Debug only)
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 char *
 acpi_ut_get_mutex_name (
@@ -700,21 +705,20 @@ acpi_ut_get_mutex_name (
 
 	return (acpi_gbl_mutex_names[mutex_id]);
 }
-
 #endif
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_valid_object_type
  *
  * PARAMETERS:  Type            - Object type to be validated
  *
- * RETURN:      TRUE if valid object type
+ * RETURN:      TRUE if valid object type, FALSE otherwise
  *
  * DESCRIPTION: Validate an object type
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 u8
 acpi_ut_valid_object_type (
@@ -732,121 +736,37 @@ acpi_ut_valid_object_type (
 }
 
 
-/****************************************************************************
- *
- * FUNCTION:    acpi_ut_allocate_owner_id
- *
- * PARAMETERS:  id_type         - Type of ID (method or table)
- *
- * DESCRIPTION: Allocate a table or method owner id
- *
- ***************************************************************************/
-
-acpi_owner_id
-acpi_ut_allocate_owner_id (
-	u32                             id_type)
-{
-	acpi_owner_id                   owner_id = 0xFFFF;
-
-
-	ACPI_FUNCTION_TRACE ("ut_allocate_owner_id");
-
-
-	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES)))
-	{
-		return (0);
-	}
-
-	switch (id_type)
-	{
-	case ACPI_OWNER_TYPE_TABLE:
-
-		owner_id = acpi_gbl_next_table_owner_id;
-		acpi_gbl_next_table_owner_id++;
-
-		/* Check for wraparound */
-
-		if (acpi_gbl_next_table_owner_id == ACPI_FIRST_METHOD_ID)
-		{
-			acpi_gbl_next_table_owner_id = ACPI_FIRST_TABLE_ID;
-			ACPI_REPORT_WARNING (("Table owner ID wraparound\n"));
-		}
-		break;
-
-
-	case ACPI_OWNER_TYPE_METHOD:
-
-		owner_id = acpi_gbl_next_method_owner_id;
-		acpi_gbl_next_method_owner_id++;
-
-		if (acpi_gbl_next_method_owner_id == ACPI_FIRST_TABLE_ID)
-		{
-			/* Check for wraparound */
-
-			acpi_gbl_next_method_owner_id = ACPI_FIRST_METHOD_ID;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
-	return_VALUE (owner_id);
-}
-
-
-/****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_ut_init_globals
  *
- * PARAMETERS:  none
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
  *
  * DESCRIPTION: Init library globals.  All globals that require specific
  *              initialization should be initialized here!
  *
- ***************************************************************************/
+ ******************************************************************************/
 
 void
 acpi_ut_init_globals (
 	void)
 {
+	acpi_status                     status;
 	u32                             i;
 
 
 	ACPI_FUNCTION_TRACE ("ut_init_globals");
 
 
-	/* Memory allocation and cache lists */
-
-	ACPI_MEMSET (acpi_gbl_memory_lists, 0, sizeof (struct acpi_memory_list) * ACPI_NUM_MEM_LISTS);
+	/* Create all memory caches */
 
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].link_offset      = (u16) ACPI_PTR_DIFF (&(((union acpi_generic_state *) NULL)->common.next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].link_offset     = (u16) ACPI_PTR_DIFF (&(((union acpi_parse_object *) NULL)->common.next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].link_offset = (u16) ACPI_PTR_DIFF (&(((union acpi_parse_object *) NULL)->common.next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].link_offset    = (u16) ACPI_PTR_DIFF (&(((union acpi_operand_object *) NULL)->cache.next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].link_offset       = (u16) ACPI_PTR_DIFF (&(((struct acpi_walk_state *) NULL)->next), NULL);
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].object_size     = sizeof (struct acpi_namespace_node);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].object_size      = sizeof (union acpi_generic_state);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].object_size     = sizeof (struct acpi_parse_obj_common);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].object_size = sizeof (struct acpi_parse_obj_named);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].object_size    = sizeof (union acpi_operand_object);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].object_size       = sizeof (struct acpi_walk_state);
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].max_cache_depth  = ACPI_MAX_STATE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].max_cache_depth = ACPI_MAX_PARSE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].max_cache_depth = ACPI_MAX_EXTPARSE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].max_cache_depth = ACPI_MAX_OBJECT_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].max_cache_depth   = ACPI_MAX_WALK_CACHE_DEPTH;
-
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].list_name    = "Global Memory Allocation");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].list_name    = "Namespace Nodes");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].list_name     = "State Object Cache");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].list_name    = "Parse Node Cache");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].list_name = "Extended Parse Node Cache");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].list_name   = "Operand Object Cache");
-	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].list_name      = "Tree Walk Node Cache");
+	status = acpi_ut_create_caches ();
+	if (ACPI_FAILURE (status))
+	{
+		return;
+	}
 
 	/* ACPI table structure */
 
@@ -861,7 +781,7 @@ acpi_ut_init_globals (
 	for (i = 0; i < NUM_MUTEX; i++)
 	{
 		acpi_gbl_mutex_info[i].mutex        = NULL;
-		acpi_gbl_mutex_info[i].owner_id     = ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[i].thread_id    = ACPI_MUTEX_NOT_ACQUIRED;
 		acpi_gbl_mutex_info[i].use_count    = 0;
 	}
 
@@ -902,8 +822,7 @@ acpi_ut_init_globals (
 	acpi_gbl_ns_lookup_count            = 0;
 	acpi_gbl_ps_find_count              = 0;
 	acpi_gbl_acpi_hardware_present      = TRUE;
-	acpi_gbl_next_table_owner_id        = ACPI_FIRST_TABLE_ID;
-	acpi_gbl_next_method_owner_id       = ACPI_FIRST_METHOD_ID;
+	acpi_gbl_owner_id_mask              = 0;
 	acpi_gbl_debugger_configuration     = DEBUGGER_THREADING;
 	acpi_gbl_db_output_flags            = ACPI_DB_CONSOLE_OUTPUT;
 
diff --git a/drivers/acpi/utilities/utinit.c b/drivers/acpi/utilities/utinit.c
--- a/drivers/acpi/utilities/utinit.c
+++ b/drivers/acpi/utilities/utinit.c
@@ -49,19 +49,29 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utinit")
 
+/* Local prototypes */
+
+static void
+acpi_ut_fadt_register_error (
+	char                            *register_name,
+	u32                             value,
+	acpi_size                       offset);
+
+static void acpi_ut_terminate (
+	void);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_fadt_register_error
  *
- * PARAMETERS:  *register_name          - Pointer to string identifying register
+ * PARAMETERS:  register_name           - Pointer to string identifying register
  *              Value                   - Actual register contents value
- *              acpi_test_spec_section  - TDS section containing assertion
- *              acpi_assertion          - Assertion number being tested
+ *              Offset                  - Byte offset in the FADT
  *
  * RETURN:      AE_BAD_VALUE
  *
- * DESCRIPTION: Display failure message and link failure to TDS assertion
+ * DESCRIPTION: Display failure message
  *
  ******************************************************************************/
 
@@ -166,12 +176,13 @@ acpi_ut_validate_fadt (
  *
  * RETURN:      none
  *
- * DESCRIPTION: free global memory
+ * DESCRIPTION: Free global memory
  *
  ******************************************************************************/
 
-void
-acpi_ut_terminate (void)
+static void
+acpi_ut_terminate (
+	void)
 {
 	struct acpi_gpe_block_info      *gpe_block;
 	struct acpi_gpe_block_info      *next_gpe_block;
@@ -183,8 +194,6 @@ acpi_ut_terminate (void)
 
 
 	/* Free global tables, etc. */
-
-
 	/* Free global GPE blocks and related info structures */
 
 	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
@@ -221,7 +230,8 @@ acpi_ut_terminate (void)
  ******************************************************************************/
 
 void
-acpi_ut_subsystem_shutdown (void)
+acpi_ut_subsystem_shutdown (
+	void)
 {
 
 	ACPI_FUNCTION_TRACE ("ut_subsystem_shutdown");
@@ -229,14 +239,16 @@ acpi_ut_subsystem_shutdown (void)
 	/* Just exit if subsystem is already shutdown */
 
 	if (acpi_gbl_shutdown) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "ACPI Subsystem is already terminated\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"ACPI Subsystem is already terminated\n"));
 		return_VOID;
 	}
 
 	/* Subsystem appears active, go ahead and shut it down */
 
 	acpi_gbl_shutdown = TRUE;
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Shutting down ACPI Subsystem...\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Shutting down ACPI Subsystem...\n"));
 
 	/* Close the acpi_event Handling */
 
@@ -252,7 +264,7 @@ acpi_ut_subsystem_shutdown (void)
 
 	/* Purge the local caches */
 
-	(void) acpi_purge_cached_objects ();
+	(void) acpi_ut_delete_caches ();
 
 	/* Debug only - display leftover memory allocation, if any */
 
diff --git a/drivers/acpi/utilities/utmath.c b/drivers/acpi/utilities/utmath.c
--- a/drivers/acpi/utilities/utmath.c
+++ b/drivers/acpi/utilities/utmath.c
@@ -259,6 +259,8 @@ acpi_ut_divide (
  *
  * FUNCTION:    acpi_ut_short_divide, acpi_ut_divide
  *
+ * PARAMETERS:  See function headers above
+ *
  * DESCRIPTION: Native versions of the ut_divide functions. Use these if either
  *              1) The target is a 64-bit platform and therefore 64-bit
  *                 integer math is supported directly by the machine.
diff --git a/drivers/acpi/utilities/utmisc.c b/drivers/acpi/utilities/utmisc.c
--- a/drivers/acpi/utilities/utmisc.c
+++ b/drivers/acpi/utilities/utmisc.c
@@ -52,9 +52,164 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    acpi_ut_allocate_owner_id
+ *
+ * PARAMETERS:  owner_id        - Where the new owner ID is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to
+ *              track objects created by the table or method, to be deleted
+ *              when the method exits or the table is unloaded.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_allocate_owner_id (
+	acpi_owner_id                   *owner_id)
+{
+	acpi_native_uint                i;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ut_allocate_owner_id");
+
+
+	/* Mutex for the global ID mask */
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Find a free owner ID */
+
+	for (i = 0; i < 32; i++) {
+		if (!(acpi_gbl_owner_id_mask & (1 << i))) {
+			acpi_gbl_owner_id_mask |= (1 << i);
+			*owner_id = (acpi_owner_id) (i + 1);
+			goto exit;
+		}
+	}
+
+	/*
+	 * If we are here, all owner_ids have been allocated. This probably should
+	 * not happen since the IDs are reused after deallocation. The IDs are
+	 * allocated upon table load (one per table) and method execution, and
+	 * they are released when a table is unloaded or a method completes
+	 * execution.
+	 */
+	*owner_id = 0;
+	status = AE_OWNER_ID_LIMIT;
+	ACPI_REPORT_ERROR ((
+		"Could not allocate new owner_id (32 max), AE_OWNER_ID_LIMIT\n"));
+
+exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_release_owner_id
+ *
+ * PARAMETERS:  owner_id_ptr        - Pointer to a previously allocated owner_iD
+ *
+ * RETURN:      None. No error is returned because we are either exiting a
+ *              control method or unloading a table. Either way, we would
+ *              ignore any error anyway.
+ *
+ * DESCRIPTION: Release a table or method owner ID.  Valid IDs are 1 - 32
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_release_owner_id (
+	acpi_owner_id                   *owner_id_ptr)
+{
+	acpi_owner_id                   owner_id = *owner_id_ptr;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ut_release_owner_id");
+
+
+	/* Always clear the input owner_id (zero is an invalid ID) */
+
+	*owner_id_ptr = 0;
+
+	/* Zero is not a valid owner_iD */
+
+	if ((owner_id == 0) || (owner_id > 32)) {
+		ACPI_REPORT_ERROR (("Invalid owner_id: %2.2X\n", owner_id));
+		return_VOID;
+	}
+
+	/* Mutex for the global ID mask */
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+	if (ACPI_FAILURE (status)) {
+		return_VOID;
+	}
+
+	owner_id--; /* Normalize to zero */
+
+	/* Free the owner ID only if it is valid */
+
+	if (acpi_gbl_owner_id_mask & (1 << owner_id)) {
+		acpi_gbl_owner_id_mask ^= (1 << owner_id);
+	}
+
+	(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strupr (strupr)
+ *
+ * PARAMETERS:  src_string      - The source string to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert string to uppercase
+ *
+ * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_strupr (
+	char                            *src_string)
+{
+	char                            *string;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	if (!src_string) {
+		return;
+	}
+
+	/* Walk entire string, uppercasing the letters */
+
+	for (string = src_string; *string; string++) {
+		*string = (char) ACPI_TOUPPER (*string);
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+ *
  * FUNCTION:    acpi_ut_print_string
  *
  * PARAMETERS:  String          - Null terminated ASCII string
+ *              max_length      - Maximum output length
  *
  * RETURN:      None
  *
@@ -148,6 +303,8 @@ acpi_ut_print_string (
  *
  * PARAMETERS:  Value           - Value to be converted
  *
+ * RETURN:      u32 integer with bytes swapped
+ *
  * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
  *
  ******************************************************************************/
@@ -160,7 +317,6 @@ acpi_ut_dword_byte_swap (
 		u32                         value;
 		u8                          bytes[4];
 	} out;
-
 	union {
 		u32                         value;
 		u8                          bytes[4];
@@ -219,7 +375,8 @@ acpi_ut_set_integer_width (
  *
  * FUNCTION:    acpi_ut_display_init_pathname
  *
- * PARAMETERS:  obj_handle          - Handle whose pathname will be displayed
+ * PARAMETERS:  Type                - Object type of the node
+ *              obj_handle          - Handle whose pathname will be displayed
  *              Path                - Additional path string to be appended.
  *                                      (NULL if no extra path)
  *
@@ -270,7 +427,8 @@ acpi_ut_display_init_pathname (
 
 	/* Print the object type and pathname */
 
-	acpi_os_printf ("%-12s %s", acpi_ut_get_type_name (type), (char *) buffer.pointer);
+	acpi_os_printf ("%-12s %s",
+		acpi_ut_get_type_name (type), (char *) buffer.pointer);
 
 	/* Extra path is used to append names like _STA, _INI, etc. */
 
@@ -288,9 +446,9 @@ acpi_ut_display_init_pathname (
  *
  * FUNCTION:    acpi_ut_valid_acpi_name
  *
- * PARAMETERS:  Character           - The character to be examined
+ * PARAMETERS:  Name            - The name to be examined
  *
- * RETURN:      1 if Character may appear in a name, else 0
+ * RETURN:      TRUE if the name is valid, FALSE otherwise
  *
  * DESCRIPTION: Check for a valid ACPI name.  Each character must be one of:
  *              1) Upper case alpha
@@ -495,902 +653,204 @@ error_exit:
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ut_strupr
+ * FUNCTION:    acpi_ut_create_update_state_and_push
  *
- * PARAMETERS:  src_string      - The source string to convert to
+ * PARAMETERS:  Object          - Object to be added to the new state
+ *              Action          - Increment/Decrement
+ *              state_list      - List the state will be added to
  *
- * RETURN:      src_string
+ * RETURN:      Status
  *
- * DESCRIPTION: Convert string to uppercase
+ * DESCRIPTION: Create a new state and push it
  *
  ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-char *
-acpi_ut_strupr (
-	char                            *src_string)
+
+acpi_status
+acpi_ut_create_update_state_and_push (
+	union acpi_operand_object       *object,
+	u16                             action,
+	union acpi_generic_state        **state_list)
 {
-	char                            *string;
+	union acpi_generic_state         *state;
 
 
 	ACPI_FUNCTION_ENTRY ();
 
 
-	/* Walk entire string, uppercasing the letters */
+	/* Ignore null objects; these are expected */
 
-	for (string = src_string; *string; ) {
-		*string = (char) ACPI_TOUPPER (*string);
-		string++;
+	if (!object) {
+		return (AE_OK);
+	}
+
+	state = acpi_ut_create_update_state (object, action);
+	if (!state) {
+		return (AE_NO_MEMORY);
 	}
 
-	return (src_string);
+	acpi_ut_push_generic_state (state_list, state);
+	return (AE_OK);
 }
-#endif  /*  ACPI_FUTURE_USAGE  */
 
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ut_mutex_initialize
+ * FUNCTION:    acpi_ut_walk_package_tree
  *
- * PARAMETERS:  None.
+ * PARAMETERS:  source_object       - The package to walk
+ *              target_object       - Target object (if package is being copied)
+ *              walk_callback       - Called once for each package element
+ *              Context             - Passed to the callback function
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Create the system mutex objects.
+ * DESCRIPTION: Walk through a package
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ut_mutex_initialize (
-	void)
+acpi_ut_walk_package_tree (
+	union acpi_operand_object       *source_object,
+	void                            *target_object,
+	acpi_pkg_callback               walk_callback,
+	void                            *context)
 {
-	u32                             i;
-	acpi_status                     status;
+	acpi_status                     status = AE_OK;
+	union acpi_generic_state        *state_list = NULL;
+	union acpi_generic_state        *state;
+	u32                             this_index;
+	union acpi_operand_object       *this_source_obj;
+
 
+	ACPI_FUNCTION_TRACE ("ut_walk_package_tree");
 
-	ACPI_FUNCTION_TRACE ("ut_mutex_initialize");
 
+	state = acpi_ut_create_pkg_state (source_object, target_object, 0);
+	if (!state) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
-	/*
-	 * Create each of the predefined mutex objects
-	 */
-	for (i = 0; i < NUM_MUTEX; i++) {
-		status = acpi_ut_create_mutex (i);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
+	while (state) {
+		/* Get one element of the package */
+
+		this_index    = state->pkg.index;
+		this_source_obj = (union acpi_operand_object *)
+				  state->pkg.source_object->package.elements[this_index];
+
+		/*
+		 * Check for:
+		 * 1) An uninitialized package element.  It is completely
+		 *    legal to declare a package and leave it uninitialized
+		 * 2) Not an internal object - can be a namespace node instead
+		 * 3) Any type other than a package.  Packages are handled in else
+		 *    case below.
+		 */
+		if ((!this_source_obj) ||
+			(ACPI_GET_DESCRIPTOR_TYPE (this_source_obj) != ACPI_DESC_TYPE_OPERAND) ||
+			(ACPI_GET_OBJECT_TYPE (this_source_obj) != ACPI_TYPE_PACKAGE)) {
+			status = walk_callback (ACPI_COPY_TYPE_SIMPLE, this_source_obj,
+					 state, context);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+
+			state->pkg.index++;
+			while (state->pkg.index >= state->pkg.source_object->package.count) {
+				/*
+				 * We've handled all of the objects at this level,  This means
+				 * that we have just completed a package.  That package may
+				 * have contained one or more packages itself.
+				 *
+				 * Delete this state and pop the previous state (package).
+				 */
+				acpi_ut_delete_generic_state (state);
+				state = acpi_ut_pop_generic_state (&state_list);
+
+				/* Finished when there are no more states */
+
+				if (!state) {
+					/*
+					 * We have handled all of the objects in the top level
+					 * package just add the length of the package objects
+					 * and exit
+					 */
+					return_ACPI_STATUS (AE_OK);
+				}
+
+				/*
+				 * Go back up a level and move the index past the just
+				 * completed package object.
+				 */
+				state->pkg.index++;
+			}
+		}
+		else {
+			/* This is a subobject of type package */
+
+			status = walk_callback (ACPI_COPY_TYPE_PACKAGE, this_source_obj,
+					  state, context);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+
+			/*
+			 * Push the current state and create a new one
+			 * The callback above returned a new target package object.
+			 */
+			acpi_ut_push_generic_state (&state_list, state);
+			state = acpi_ut_create_pkg_state (this_source_obj,
+					   state->pkg.this_target_obj, 0);
+			if (!state) {
+				return_ACPI_STATUS (AE_NO_MEMORY);
+			}
 		}
 	}
 
-	status = acpi_os_create_lock (&acpi_gbl_gpe_lock);
-	return_ACPI_STATUS (status);
+	/* We should never get here */
+
+	return_ACPI_STATUS (AE_AML_INTERNAL);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ut_mutex_terminate
+ * FUNCTION:    acpi_ut_generate_checksum
  *
- * PARAMETERS:  None.
+ * PARAMETERS:  Buffer          - Buffer to be scanned
+ *              Length          - number of bytes to examine
  *
- * RETURN:      None.
+ * RETURN:      The generated checksum
  *
- * DESCRIPTION: Delete all of the system mutex objects.
+ * DESCRIPTION: Generate a checksum on a raw buffer
  *
  ******************************************************************************/
 
-void
-acpi_ut_mutex_terminate (
-	void)
+u8
+acpi_ut_generate_checksum (
+	u8                              *buffer,
+	u32                             length)
 {
 	u32                             i;
+	signed char                     sum = 0;
 
 
-	ACPI_FUNCTION_TRACE ("ut_mutex_terminate");
-
-
-	/*
-	 * Delete each predefined mutex object
-	 */
-	for (i = 0; i < NUM_MUTEX; i++) {
-		(void) acpi_ut_delete_mutex (i);
+	for (i = 0; i < length; i++) {
+		sum = (signed char) (sum + buffer[i]);
 	}
 
-	acpi_os_delete_lock (acpi_gbl_gpe_lock);
-	return_VOID;
+	return ((u8) (0 - sum));
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    acpi_ut_create_mutex
+ * FUNCTION:    acpi_ut_get_resource_end_tag
  *
- * PARAMETERS:  mutex_iD        - ID of the mutex to be created
+ * PARAMETERS:  obj_desc        - The resource template buffer object
  *
- * RETURN:      Status
+ * RETURN:      Pointer to the end tag
  *
- * DESCRIPTION: Create a mutex object.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_create_mutex (
-	acpi_mutex_handle               mutex_id)
-{
-	acpi_status                     status = AE_OK;
-
-
-	ACPI_FUNCTION_TRACE_U32 ("ut_create_mutex", mutex_id);
-
-
-	if (mutex_id > MAX_MUTEX) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	if (!acpi_gbl_mutex_info[mutex_id].mutex) {
-		status = acpi_os_create_semaphore (1, 1,
-				  &acpi_gbl_mutex_info[mutex_id].mutex);
-		acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
-		acpi_gbl_mutex_info[mutex_id].use_count = 0;
-	}
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_delete_mutex
- *
- * PARAMETERS:  mutex_iD        - ID of the mutex to be deleted
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Delete a mutex object.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_delete_mutex (
-	acpi_mutex_handle               mutex_id)
-{
-	acpi_status                     status;
-
-
-	ACPI_FUNCTION_TRACE_U32 ("ut_delete_mutex", mutex_id);
-
-
-	if (mutex_id > MAX_MUTEX) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	status = acpi_os_delete_semaphore (acpi_gbl_mutex_info[mutex_id].mutex);
-
-	acpi_gbl_mutex_info[mutex_id].mutex = NULL;
-	acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_acquire_mutex
- *
- * PARAMETERS:  mutex_iD        - ID of the mutex to be acquired
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Acquire a mutex object.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_acquire_mutex (
-	acpi_mutex_handle               mutex_id)
-{
-	acpi_status                     status;
-	u32                             this_thread_id;
-
-
-	ACPI_FUNCTION_NAME ("ut_acquire_mutex");
-
-
-	if (mutex_id > MAX_MUTEX) {
-		return (AE_BAD_PARAMETER);
-	}
-
-	this_thread_id = acpi_os_get_thread_id ();
-
-#ifdef ACPI_MUTEX_DEBUG
-	{
-		u32                             i;
-		/*
-		 * Mutex debug code, for internal debugging only.
-		 *
-		 * Deadlock prevention.  Check if this thread owns any mutexes of value
-		 * greater than or equal to this one.  If so, the thread has violated
-		 * the mutex ordering rule.  This indicates a coding error somewhere in
-		 * the ACPI subsystem code.
-		 */
-		for (i = mutex_id; i < MAX_MUTEX; i++) {
-			if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
-				if (i == mutex_id) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-							"Mutex [%s] already acquired by this thread [%X]\n",
-							acpi_ut_get_mutex_name (mutex_id), this_thread_id));
-
-					return (AE_ALREADY_ACQUIRED);
-				}
-
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-						"Invalid acquire order: Thread %X owns [%s], wants [%s]\n",
-						this_thread_id, acpi_ut_get_mutex_name (i),
-						acpi_ut_get_mutex_name (mutex_id)));
-
-				return (AE_ACQUIRE_DEADLOCK);
-			}
-		}
-	}
-#endif
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
-			 "Thread %X attempting to acquire Mutex [%s]\n",
-			 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
-
-	status = acpi_os_wait_semaphore (acpi_gbl_mutex_info[mutex_id].mutex,
-			   1, ACPI_WAIT_FOREVER);
-	if (ACPI_SUCCESS (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X acquired Mutex [%s]\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
-
-		acpi_gbl_mutex_info[mutex_id].use_count++;
-		acpi_gbl_mutex_info[mutex_id].owner_id = this_thread_id;
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not acquire Mutex [%s] %s\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id),
-				 acpi_format_exception (status)));
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_release_mutex
- *
- * PARAMETERS:  mutex_iD        - ID of the mutex to be released
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Release a mutex object.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_release_mutex (
-	acpi_mutex_handle               mutex_id)
-{
-	acpi_status                     status;
-	u32                             i;
-	u32                             this_thread_id;
-
-
-	ACPI_FUNCTION_NAME ("ut_release_mutex");
-
-
-	this_thread_id = acpi_os_get_thread_id ();
-	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
-		"Thread %X releasing Mutex [%s]\n", this_thread_id,
-		acpi_ut_get_mutex_name (mutex_id)));
-
-	if (mutex_id > MAX_MUTEX) {
-		return (AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Mutex must be acquired in order to release it!
-	 */
-	if (acpi_gbl_mutex_info[mutex_id].owner_id == ACPI_MUTEX_NOT_ACQUIRED) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Mutex [%s] is not acquired, cannot release\n",
-				acpi_ut_get_mutex_name (mutex_id)));
-
-		return (AE_NOT_ACQUIRED);
-	}
-
-	/*
-	 * Deadlock prevention.  Check if this thread owns any mutexes of value
-	 * greater than this one.  If so, the thread has violated the mutex
-	 * ordering rule.  This indicates a coding error somewhere in
-	 * the ACPI subsystem code.
-	 */
-	for (i = mutex_id; i < MAX_MUTEX; i++) {
-		if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
-			if (i == mutex_id) {
-				continue;
-			}
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Invalid release order: owns [%s], releasing [%s]\n",
-					acpi_ut_get_mutex_name (i), acpi_ut_get_mutex_name (mutex_id)));
-
-			return (AE_RELEASE_DEADLOCK);
-		}
-	}
-
-	/* Mark unlocked FIRST */
-
-	acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
-
-	status = acpi_os_signal_semaphore (acpi_gbl_mutex_info[mutex_id].mutex, 1);
-
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not release Mutex [%s] %s\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id),
-				 acpi_format_exception (status)));
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X released Mutex [%s]\n",
-				 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_update_state_and_push
- *
- * PARAMETERS:  *Object         - Object to be added to the new state
- *              Action          - Increment/Decrement
- *              state_list      - List the state will be added to
- *
- * RETURN:      None
- *
- * DESCRIPTION: Create a new state and push it
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_create_update_state_and_push (
-	union acpi_operand_object       *object,
-	u16                             action,
-	union acpi_generic_state        **state_list)
-{
-	union acpi_generic_state         *state;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	/* Ignore null objects; these are expected */
-
-	if (!object) {
-		return (AE_OK);
-	}
-
-	state = acpi_ut_create_update_state (object, action);
-	if (!state) {
-		return (AE_NO_MEMORY);
-	}
-
-	acpi_ut_push_generic_state (state_list, state);
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_pkg_state_and_push
- *
- * PARAMETERS:  *Object         - Object to be added to the new state
- *              Action          - Increment/Decrement
- *              state_list      - List the state will be added to
- *
- * RETURN:      None
- *
- * DESCRIPTION: Create a new state and push it
- *
- ******************************************************************************/
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ut_create_pkg_state_and_push (
-	void                            *internal_object,
-	void                            *external_object,
-	u16                             index,
-	union acpi_generic_state        **state_list)
-{
-	union acpi_generic_state         *state;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	state = acpi_ut_create_pkg_state (internal_object, external_object, index);
-	if (!state) {
-		return (AE_NO_MEMORY);
-	}
-
-	acpi_ut_push_generic_state (state_list, state);
-	return (AE_OK);
-}
-#endif  /*  ACPI_FUTURE_USAGE  */
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_push_generic_state
- *
- * PARAMETERS:  list_head           - Head of the state stack
- *              State               - State object to push
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Push a state object onto a state stack
- *
- ******************************************************************************/
-
-void
-acpi_ut_push_generic_state (
-	union acpi_generic_state        **list_head,
-	union acpi_generic_state        *state)
-{
-	ACPI_FUNCTION_TRACE ("ut_push_generic_state");
-
-
-	/* Push the state object onto the front of the list (stack) */
-
-	state->common.next = *list_head;
-	*list_head = state;
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_pop_generic_state
- *
- * PARAMETERS:  list_head           - Head of the state stack
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Pop a state object from a state stack
- *
- ******************************************************************************/
-
-union acpi_generic_state *
-acpi_ut_pop_generic_state (
-	union acpi_generic_state        **list_head)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_TRACE ("ut_pop_generic_state");
-
-
-	/* Remove the state object at the head of the list (stack) */
-
-	state = *list_head;
-	if (state) {
-		/* Update the list head */
-
-		*list_head = state->common.next;
-	}
-
-	return_PTR (state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_generic_state
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create a generic state object.  Attempt to obtain one from
- *              the global state cache;  If none available, create a new one.
- *
- ******************************************************************************/
-
-union acpi_generic_state *
-acpi_ut_create_generic_state (void)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	state = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_STATE);
-
-	/* Initialize */
-
-	if (state) {
-		state->common.data_type = ACPI_DESC_TYPE_STATE;
-	}
-
-	return (state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_thread_state
- *
- * PARAMETERS:  None
- *
- * RETURN:      Thread State
- *
- * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used
- *              to track per-thread info during method execution
- *
- ******************************************************************************/
-
-struct acpi_thread_state *
-acpi_ut_create_thread_state (
-	void)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_TRACE ("ut_create_thread_state");
-
-
-	/* Create the generic state object */
-
-	state = acpi_ut_create_generic_state ();
-	if (!state) {
-		return_PTR (NULL);
-	}
-
-	/* Init fields specific to the update struct */
-
-	state->common.data_type = ACPI_DESC_TYPE_STATE_THREAD;
-	state->thread.thread_id = acpi_os_get_thread_id ();
-
-	return_PTR ((struct acpi_thread_state *) state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_update_state
- *
- * PARAMETERS:  Object              - Initial Object to be installed in the
- *                                    state
- *              Action              - Update action to be performed
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create an "Update State" - a flavor of the generic state used
- *              to update reference counts and delete complex objects such
- *              as packages.
- *
- ******************************************************************************/
-
-union acpi_generic_state *
-acpi_ut_create_update_state (
-	union acpi_operand_object       *object,
-	u16                             action)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ut_create_update_state", object);
-
-
-	/* Create the generic state object */
-
-	state = acpi_ut_create_generic_state ();
-	if (!state) {
-		return_PTR (NULL);
-	}
-
-	/* Init fields specific to the update struct */
-
-	state->common.data_type = ACPI_DESC_TYPE_STATE_UPDATE;
-	state->update.object = object;
-	state->update.value  = action;
-
-	return_PTR (state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_pkg_state
- *
- * PARAMETERS:  Object              - Initial Object to be installed in the
- *                                    state
- *              Action              - Update action to be performed
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create a "Package State"
- *
- ******************************************************************************/
-
-union acpi_generic_state *
-acpi_ut_create_pkg_state (
-	void                            *internal_object,
-	void                            *external_object,
-	u16                             index)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ut_create_pkg_state", internal_object);
-
-
-	/* Create the generic state object */
-
-	state = acpi_ut_create_generic_state ();
-	if (!state) {
-		return_PTR (NULL);
-	}
-
-	/* Init fields specific to the update struct */
-
-	state->common.data_type = ACPI_DESC_TYPE_STATE_PACKAGE;
-	state->pkg.source_object = (union acpi_operand_object *) internal_object;
-	state->pkg.dest_object  = external_object;
-	state->pkg.index        = index;
-	state->pkg.num_packages = 1;
-
-	return_PTR (state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_create_control_state
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create a "Control State" - a flavor of the generic state used
- *              to support nested IF/WHILE constructs in the AML.
- *
- ******************************************************************************/
-
-union acpi_generic_state *
-acpi_ut_create_control_state (
-	void)
-{
-	union acpi_generic_state        *state;
-
-
-	ACPI_FUNCTION_TRACE ("ut_create_control_state");
-
-
-	/* Create the generic state object */
-
-	state = acpi_ut_create_generic_state ();
-	if (!state) {
-		return_PTR (NULL);
-	}
-
-	/* Init fields specific to the control struct */
-
-	state->common.data_type = ACPI_DESC_TYPE_STATE_CONTROL;
-	state->common.state     = ACPI_CONTROL_CONDITIONAL_EXECUTING;
-
-	return_PTR (state);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_delete_generic_state
- *
- * PARAMETERS:  State               - The state object to be deleted
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Put a state object back into the global state cache.  The object
- *              is not actually freed at this time.
- *
- ******************************************************************************/
-
-void
-acpi_ut_delete_generic_state (
-	union acpi_generic_state        *state)
-{
-	ACPI_FUNCTION_TRACE ("ut_delete_generic_state");
-
-
-	acpi_ut_release_to_cache (ACPI_MEM_LIST_STATE, state);
-	return_VOID;
-}
-
-
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_delete_generic_state_cache
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Purge the global state object cache.  Used during subsystem
- *              termination.
- *
- ******************************************************************************/
-
-void
-acpi_ut_delete_generic_state_cache (
-	void)
-{
-	ACPI_FUNCTION_TRACE ("ut_delete_generic_state_cache");
-
-
-	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_STATE);
-	return_VOID;
-}
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_walk_package_tree
- *
- * PARAMETERS:  obj_desc        - The Package object on which to resolve refs
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Walk through a package
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_walk_package_tree (
-	union acpi_operand_object       *source_object,
-	void                            *target_object,
-	acpi_pkg_callback               walk_callback,
-	void                            *context)
-{
-	acpi_status                     status = AE_OK;
-	union acpi_generic_state        *state_list = NULL;
-	union acpi_generic_state        *state;
-	u32                             this_index;
-	union acpi_operand_object       *this_source_obj;
-
-
-	ACPI_FUNCTION_TRACE ("ut_walk_package_tree");
-
-
-	state = acpi_ut_create_pkg_state (source_object, target_object, 0);
-	if (!state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	while (state) {
-		/* Get one element of the package */
-
-		this_index    = state->pkg.index;
-		this_source_obj = (union acpi_operand_object *)
-				  state->pkg.source_object->package.elements[this_index];
-
-		/*
-		 * Check for:
-		 * 1) An uninitialized package element.  It is completely
-		 *    legal to declare a package and leave it uninitialized
-		 * 2) Not an internal object - can be a namespace node instead
-		 * 3) Any type other than a package.  Packages are handled in else
-		 *    case below.
-		 */
-		if ((!this_source_obj) ||
-			(ACPI_GET_DESCRIPTOR_TYPE (this_source_obj) != ACPI_DESC_TYPE_OPERAND) ||
-			(ACPI_GET_OBJECT_TYPE (this_source_obj) != ACPI_TYPE_PACKAGE)) {
-			status = walk_callback (ACPI_COPY_TYPE_SIMPLE, this_source_obj,
-					 state, context);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-
-			state->pkg.index++;
-			while (state->pkg.index >= state->pkg.source_object->package.count) {
-				/*
-				 * We've handled all of the objects at this level,  This means
-				 * that we have just completed a package.  That package may
-				 * have contained one or more packages itself.
-				 *
-				 * Delete this state and pop the previous state (package).
-				 */
-				acpi_ut_delete_generic_state (state);
-				state = acpi_ut_pop_generic_state (&state_list);
-
-				/* Finished when there are no more states */
-
-				if (!state) {
-					/*
-					 * We have handled all of the objects in the top level
-					 * package just add the length of the package objects
-					 * and exit
-					 */
-					return_ACPI_STATUS (AE_OK);
-				}
-
-				/*
-				 * Go back up a level and move the index past the just
-				 * completed package object.
-				 */
-				state->pkg.index++;
-			}
-		}
-		else {
-			/* This is a subobject of type package */
-
-			status = walk_callback (ACPI_COPY_TYPE_PACKAGE, this_source_obj,
-					  state, context);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-
-			/*
-			 * Push the current state and create a new one
-			 * The callback above returned a new target package object.
-			 */
-			acpi_ut_push_generic_state (&state_list, state);
-			state = acpi_ut_create_pkg_state (this_source_obj,
-					   state->pkg.this_target_obj, 0);
-			if (!state) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
-		}
-	}
-
-	/* We should never get here */
-
-	return_ACPI_STATUS (AE_AML_INTERNAL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_generate_checksum
- *
- * PARAMETERS:  Buffer          - Buffer to be scanned
- *              Length          - number of bytes to examine
- *
- * RETURN:      checksum
- *
- * DESCRIPTION: Generate a checksum on a raw buffer
- *
- ******************************************************************************/
-
-u8
-acpi_ut_generate_checksum (
-	u8                              *buffer,
-	u32                             length)
-{
-	u32                             i;
-	signed char                     sum = 0;
-
-
-	for (i = 0; i < length; i++) {
-		sum = (signed char) (sum + buffer[i]);
-	}
-
-	return ((u8) (0 - sum));
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_get_resource_end_tag
- *
- * PARAMETERS:  obj_desc        - The resource template buffer object
- *
- * RETURN:      Pointer to the end tag
- *
- * DESCRIPTION: Find the END_TAG resource descriptor in a resource template
+ * DESCRIPTION: Find the END_TAG resource descriptor in a resource template
  *
  ******************************************************************************/
 
@@ -1442,7 +902,6 @@ acpi_ut_get_resource_end_tag (
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
@@ -1457,7 +916,6 @@ acpi_ut_report_error (
 	u32                             component_id)
 {
 
-
 	acpi_os_printf ("%8s-%04d: *** Error: ", module_name, line_number);
 }
 
@@ -1469,7 +927,6 @@ acpi_ut_report_error (
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
@@ -1495,7 +952,6 @@ acpi_ut_report_warning (
  * PARAMETERS:  module_name         - Caller's module name (for error output)
  *              line_number         - Caller's line number (for error output)
  *              component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
  *
  * RETURN:      None
  *
diff --git a/drivers/acpi/utilities/utmutex.c b/drivers/acpi/utilities/utmutex.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/utilities/utmutex.c
@@ -0,0 +1,380 @@
+/*******************************************************************************
+ *
+ * Module Name: utmutex - local mutex support
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+
+#define _COMPONENT          ACPI_UTILITIES
+	 ACPI_MODULE_NAME    ("utmutex")
+
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_create_mutex (
+	acpi_mutex_handle               mutex_id);
+
+static acpi_status
+acpi_ut_delete_mutex (
+	acpi_mutex_handle               mutex_id);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_mutex_initialize
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the system mutex objects.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_mutex_initialize (
+	void)
+{
+	u32                             i;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ut_mutex_initialize");
+
+
+	/*
+	 * Create each of the predefined mutex objects
+	 */
+	for (i = 0; i < NUM_MUTEX; i++) {
+		status = acpi_ut_create_mutex (i);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
+
+	status = acpi_os_create_lock (&acpi_gbl_gpe_lock);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_mutex_terminate
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Delete all of the system mutex objects.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_mutex_terminate (
+	void)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE ("ut_mutex_terminate");
+
+
+	/*
+	 * Delete each predefined mutex object
+	 */
+	for (i = 0; i < NUM_MUTEX; i++) {
+		(void) acpi_ut_delete_mutex (i);
+	}
+
+	acpi_os_delete_lock (acpi_gbl_gpe_lock);
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be created
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a mutex object.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_create_mutex (
+	acpi_mutex_handle               mutex_id)
+{
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ut_create_mutex", mutex_id);
+
+
+	if (mutex_id > MAX_MUTEX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	if (!acpi_gbl_mutex_info[mutex_id].mutex) {
+		status = acpi_os_create_semaphore (1, 1,
+				  &acpi_gbl_mutex_info[mutex_id].mutex);
+		acpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[mutex_id].use_count = 0;
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be deleted
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete a mutex object.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_delete_mutex (
+	acpi_mutex_handle               mutex_id)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ut_delete_mutex", mutex_id);
+
+
+	if (mutex_id > MAX_MUTEX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_os_delete_semaphore (acpi_gbl_mutex_info[mutex_id].mutex);
+
+	acpi_gbl_mutex_info[mutex_id].mutex = NULL;
+	acpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_acquire_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be acquired
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire a mutex object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_acquire_mutex (
+	acpi_mutex_handle               mutex_id)
+{
+	acpi_status                     status;
+	u32                             this_thread_id;
+
+
+	ACPI_FUNCTION_NAME ("ut_acquire_mutex");
+
+
+	if (mutex_id > MAX_MUTEX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	this_thread_id = acpi_os_get_thread_id ();
+
+#ifdef ACPI_MUTEX_DEBUG
+	{
+		u32                             i;
+		/*
+		 * Mutex debug code, for internal debugging only.
+		 *
+		 * Deadlock prevention.  Check if this thread owns any mutexes of value
+		 * greater than or equal to this one.  If so, the thread has violated
+		 * the mutex ordering rule.  This indicates a coding error somewhere in
+		 * the ACPI subsystem code.
+		 */
+		for (i = mutex_id; i < MAX_MUTEX; i++) {
+			if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
+				if (i == mutex_id) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"Mutex [%s] already acquired by this thread [%X]\n",
+						acpi_ut_get_mutex_name (mutex_id), this_thread_id));
+
+					return (AE_ALREADY_ACQUIRED);
+				}
+
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Invalid acquire order: Thread %X owns [%s], wants [%s]\n",
+					this_thread_id, acpi_ut_get_mutex_name (i),
+					acpi_ut_get_mutex_name (mutex_id)));
+
+				return (AE_ACQUIRE_DEADLOCK);
+			}
+		}
+	}
+#endif
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
+		"Thread %X attempting to acquire Mutex [%s]\n",
+		this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+
+	status = acpi_os_wait_semaphore (acpi_gbl_mutex_info[mutex_id].mutex,
+			   1, ACPI_WAIT_FOREVER);
+	if (ACPI_SUCCESS (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X acquired Mutex [%s]\n",
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+
+		acpi_gbl_mutex_info[mutex_id].use_count++;
+		acpi_gbl_mutex_info[mutex_id].thread_id = this_thread_id;
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Thread %X could not acquire Mutex [%s] %s\n",
+				this_thread_id, acpi_ut_get_mutex_name (mutex_id),
+				acpi_format_exception (status)));
+	}
+
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_release_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be released
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release a mutex object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_release_mutex (
+	acpi_mutex_handle               mutex_id)
+{
+	acpi_status                     status;
+	u32                             this_thread_id;
+
+
+	ACPI_FUNCTION_NAME ("ut_release_mutex");
+
+
+	this_thread_id = acpi_os_get_thread_id ();
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
+		"Thread %X releasing Mutex [%s]\n", this_thread_id,
+		acpi_ut_get_mutex_name (mutex_id)));
+
+	if (mutex_id > MAX_MUTEX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Mutex must be acquired in order to release it!
+	 */
+	if (acpi_gbl_mutex_info[mutex_id].thread_id == ACPI_MUTEX_NOT_ACQUIRED) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Mutex [%s] is not acquired, cannot release\n",
+			acpi_ut_get_mutex_name (mutex_id)));
+
+		return (AE_NOT_ACQUIRED);
+	}
+
+#ifdef ACPI_MUTEX_DEBUG
+	{
+		u32                             i;
+		/*
+		 * Mutex debug code, for internal debugging only.
+		 *
+		 * Deadlock prevention.  Check if this thread owns any mutexes of value
+		 * greater than this one.  If so, the thread has violated the mutex
+		 * ordering rule.  This indicates a coding error somewhere in
+		 * the ACPI subsystem code.
+		 */
+		for (i = mutex_id; i < MAX_MUTEX; i++) {
+			if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
+				if (i == mutex_id) {
+					continue;
+				}
+
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Invalid release order: owns [%s], releasing [%s]\n",
+					acpi_ut_get_mutex_name (i), acpi_ut_get_mutex_name (mutex_id)));
+
+				return (AE_RELEASE_DEADLOCK);
+			}
+		}
+	}
+#endif
+
+	/* Mark unlocked FIRST */
+
+	acpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+
+	status = acpi_os_signal_semaphore (acpi_gbl_mutex_info[mutex_id].mutex, 1);
+
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Thread %X could not release Mutex [%s] %s\n",
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id),
+			acpi_format_exception (status)));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X released Mutex [%s]\n",
+			this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
+	}
+
+	return (status);
+}
+
+
diff --git a/drivers/acpi/utilities/utobject.c b/drivers/acpi/utilities/utobject.c
--- a/drivers/acpi/utilities/utobject.c
+++ b/drivers/acpi/utilities/utobject.c
@@ -50,6 +50,25 @@
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utobject")
 
+/* Local prototypes */
+
+static acpi_status
+acpi_ut_get_simple_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+static acpi_status
+acpi_ut_get_package_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+static acpi_status
+acpi_ut_get_element_length (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
 
 /*******************************************************************************
  *
@@ -60,7 +79,7 @@
  *              component_id        - Component type of caller
  *              Type                - ACPI Type of the new object
  *
- * RETURN:      Object              - The new object.  Null on failure
+ * RETURN:      A new internal object, null on failure
  *
  * DESCRIPTION: Create and initialize a new internal object.
  *
@@ -83,7 +102,8 @@ acpi_ut_create_internal_object_dbg (
 	union acpi_operand_object       *second_object;
 
 
-	ACPI_FUNCTION_TRACE_STR ("ut_create_internal_object_dbg", acpi_ut_get_type_name (type));
+	ACPI_FUNCTION_TRACE_STR ("ut_create_internal_object_dbg",
+		acpi_ut_get_type_name (type));
 
 
 	/* Allocate the raw object descriptor */
@@ -99,7 +119,8 @@ acpi_ut_create_internal_object_dbg (
 
 		/* These types require a secondary object */
 
-		second_object = acpi_ut_allocate_object_desc_dbg (module_name, line_number, component_id);
+		second_object = acpi_ut_allocate_object_desc_dbg (module_name,
+				   line_number, component_id);
 		if (!second_object) {
 			acpi_ut_delete_object_desc (object);
 			return_PTR (NULL);
@@ -138,7 +159,7 @@ acpi_ut_create_internal_object_dbg (
  *
  * PARAMETERS:  buffer_size            - Size of buffer to be created
  *
- * RETURN:      Pointer to a new Buffer object
+ * RETURN:      Pointer to a new Buffer object, null on failure
  *
  * DESCRIPTION: Create a fully initialized buffer object
  *
@@ -192,9 +213,9 @@ acpi_ut_create_buffer_object (
  *
  * FUNCTION:    acpi_ut_create_string_object
  *
- * PARAMETERS:  string_size            - Size of string to be created.  Does not
- *                                       include NULL terminator, this is added
- *                                       automatically.
+ * PARAMETERS:  string_size         - Size of string to be created. Does not
+ *                                    include NULL terminator, this is added
+ *                                    automatically.
  *
  * RETURN:      Pointer to a new String object
  *
@@ -249,7 +270,9 @@ acpi_ut_create_string_object (
  *
  * PARAMETERS:  Object              - Object to be validated
  *
- * RETURN:      Validate a pointer to be an union acpi_operand_object
+ * RETURN:      TRUE if object is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Validate a pointer to be an union acpi_operand_object
  *
  ******************************************************************************/
 
@@ -315,7 +338,7 @@ acpi_ut_allocate_object_desc_dbg (
 	ACPI_FUNCTION_TRACE ("ut_allocate_object_desc_dbg");
 
 
-	object = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_OPERAND);
+	object = acpi_os_acquire_object (acpi_gbl_operand_cache);
 	if (!object) {
 		_ACPI_REPORT_ERROR (module_name, line_number, component_id,
 				  ("Could not allocate an object descriptor\n"));
@@ -324,7 +347,7 @@ acpi_ut_allocate_object_desc_dbg (
 	}
 
 	/* Mark the descriptor type */
-
+	memset(object, 0, sizeof(union acpi_operand_object));
 	ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_OPERAND);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n",
@@ -362,45 +385,17 @@ acpi_ut_delete_object_desc (
 		return_VOID;
 	}
 
-	acpi_ut_release_to_cache (ACPI_MEM_LIST_OPERAND, object);
-
+	(void) acpi_os_release_object (acpi_gbl_operand_cache, object);
 	return_VOID;
 }
 
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ut_delete_object_cache
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Purge the global state object cache.  Used during subsystem
- *              termination.
- *
- ******************************************************************************/
-
-void
-acpi_ut_delete_object_cache (
-	void)
-{
-	ACPI_FUNCTION_TRACE ("ut_delete_object_cache");
-
-
-	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_OPERAND);
-	return_VOID;
-}
-#endif
-
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_get_simple_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length is returned
+ * PARAMETERS:  internal_object    - An ACPI operand object
+ *              obj_length         - Where the length is returned
  *
  * RETURN:      Status
  *
@@ -412,7 +407,7 @@ acpi_ut_delete_object_cache (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_simple_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
@@ -424,8 +419,10 @@ acpi_ut_get_simple_object_size (
 	ACPI_FUNCTION_TRACE_PTR ("ut_get_simple_object_size", internal_object);
 
 
-	/* Handle a null object (Could be a uninitialized package element -- which is legal) */
-
+	/*
+	 * Handle a null object (Could be a uninitialized package
+	 * element -- which is legal)
+	 */
 	if (!internal_object) {
 		*obj_length = 0;
 		return_ACPI_STATUS (AE_OK);
@@ -480,7 +477,8 @@ acpi_ut_get_simple_object_size (
 			 * Get the actual length of the full pathname to this object.
 			 * The reference will be converted to the pathname to the object
 			 */
-			length += ACPI_ROUND_UP_TO_NATIVE_WORD (acpi_ns_get_pathname_length (internal_object->reference.node));
+			length += ACPI_ROUND_UP_TO_NATIVE_WORD (
+					 acpi_ns_get_pathname_length (internal_object->reference.node));
 			break;
 
 		default:
@@ -530,7 +528,7 @@ acpi_ut_get_simple_object_size (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_element_length (
 	u8                              object_type,
 	union acpi_operand_object       *source_object,
@@ -582,8 +580,8 @@ acpi_ut_get_element_length (
  *
  * FUNCTION:    acpi_ut_get_package_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length is returned
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length is returned
  *
  * RETURN:      Status
  *
@@ -595,7 +593,7 @@ acpi_ut_get_element_length (
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_ut_get_package_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
@@ -636,8 +634,8 @@ acpi_ut_get_package_object_size (
  *
  * FUNCTION:    acpi_ut_get_object_size
  *
- * PARAMETERS:  *internal_object    - Pointer to the object we are examining
- *              *obj_length         - Where the length will be returned
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length will be returned
  *
  * RETURN:      Status
  *
@@ -647,7 +645,7 @@ acpi_ut_get_package_object_size (
  ******************************************************************************/
 
 acpi_status
-acpi_ut_get_object_size(
+acpi_ut_get_object_size (
 	union acpi_operand_object       *internal_object,
 	acpi_size                       *obj_length)
 {
diff --git a/drivers/acpi/utilities/utstate.c b/drivers/acpi/utilities/utstate.c
new file mode 100644
--- /dev/null
+++ b/drivers/acpi/utilities/utstate.c
@@ -0,0 +1,376 @@
+/*******************************************************************************
+ *
+ * Module Name: utstate - state object support procedures
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+
+#define _COMPONENT          ACPI_UTILITIES
+	 ACPI_MODULE_NAME    ("utstate")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_pkg_state_and_push
+ *
+ * PARAMETERS:  Object          - Object to be added to the new state
+ *              Action          - Increment/Decrement
+ *              state_list      - List the state will be added to
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new state and push it
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_create_pkg_state_and_push (
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index,
+	union acpi_generic_state        **state_list)
+{
+	union acpi_generic_state         *state;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	state = acpi_ut_create_pkg_state (internal_object, external_object, index);
+	if (!state) {
+		return (AE_NO_MEMORY);
+	}
+
+	acpi_ut_push_generic_state (state_list, state);
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_push_generic_state
+ *
+ * PARAMETERS:  list_head           - Head of the state stack
+ *              State               - State object to push
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push a state object onto a state stack
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_push_generic_state (
+	union acpi_generic_state        **list_head,
+	union acpi_generic_state        *state)
+{
+	ACPI_FUNCTION_TRACE ("ut_push_generic_state");
+
+
+	/* Push the state object onto the front of the list (stack) */
+
+	state->common.next = *list_head;
+	*list_head = state;
+
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_pop_generic_state
+ *
+ * PARAMETERS:  list_head           - Head of the state stack
+ *
+ * RETURN:      The popped state object
+ *
+ * DESCRIPTION: Pop a state object from a state stack
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *
+acpi_ut_pop_generic_state (
+	union acpi_generic_state        **list_head)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE ("ut_pop_generic_state");
+
+
+	/* Remove the state object at the head of the list (stack) */
+
+	state = *list_head;
+	if (state) {
+		/* Update the list head */
+
+		*list_head = state->common.next;
+	}
+
+	return_PTR (state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_generic_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      The new state object. NULL on failure.
+ *
+ * DESCRIPTION: Create a generic state object.  Attempt to obtain one from
+ *              the global state cache;  If none available, create a new one.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *
+acpi_ut_create_generic_state (
+	void)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	state = acpi_os_acquire_object (acpi_gbl_state_cache);
+	if (state) {
+		/* Initialize */
+		memset(state, 0, sizeof(union acpi_generic_state));
+		state->common.data_type = ACPI_DESC_TYPE_STATE;
+	}
+
+	return (state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_thread_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      New Thread State. NULL on failure
+ *
+ * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used
+ *              to track per-thread info during method execution
+ *
+ ******************************************************************************/
+
+struct acpi_thread_state *
+acpi_ut_create_thread_state (
+	void)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE ("ut_create_thread_state");
+
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state ();
+	if (!state) {
+		return_PTR (NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.data_type = ACPI_DESC_TYPE_STATE_THREAD;
+	state->thread.thread_id = acpi_os_get_thread_id ();
+
+	return_PTR ((struct acpi_thread_state *) state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_update_state
+ *
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create an "Update State" - a flavor of the generic state used
+ *              to update reference counts and delete complex objects such
+ *              as packages.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *
+acpi_ut_create_update_state (
+	union acpi_operand_object       *object,
+	u16                             action)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ut_create_update_state", object);
+
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state ();
+	if (!state) {
+		return_PTR (NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.data_type = ACPI_DESC_TYPE_STATE_UPDATE;
+	state->update.object = object;
+	state->update.value  = action;
+
+	return_PTR (state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_pkg_state
+ *
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create a "Package State"
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *
+acpi_ut_create_pkg_state (
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ut_create_pkg_state", internal_object);
+
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state ();
+	if (!state) {
+		return_PTR (NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.data_type = ACPI_DESC_TYPE_STATE_PACKAGE;
+	state->pkg.source_object = (union acpi_operand_object *) internal_object;
+	state->pkg.dest_object  = external_object;
+	state->pkg.index        = index;
+	state->pkg.num_packages = 1;
+
+	return_PTR (state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_control_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create a "Control State" - a flavor of the generic state used
+ *              to support nested IF/WHILE constructs in the AML.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *
+acpi_ut_create_control_state (
+	void)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE ("ut_create_control_state");
+
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state ();
+	if (!state) {
+		return_PTR (NULL);
+	}
+
+	/* Init fields specific to the control struct */
+
+	state->common.data_type = ACPI_DESC_TYPE_STATE_CONTROL;
+	state->common.state     = ACPI_CONTROL_CONDITIONAL_EXECUTING;
+
+	return_PTR (state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_generic_state
+ *
+ * PARAMETERS:  State               - The state object to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Put a state object back into the global state cache.  The object
+ *              is not actually freed at this time.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_delete_generic_state (
+	union acpi_generic_state        *state)
+{
+	ACPI_FUNCTION_TRACE ("ut_delete_generic_state");
+
+
+	(void) acpi_os_release_object (acpi_gbl_state_cache, state);
+	return_VOID;
+}
+
+
diff --git a/drivers/acpi/utilities/utxface.c b/drivers/acpi/utilities/utxface.c
--- a/drivers/acpi/utilities/utxface.c
+++ b/drivers/acpi/utilities/utxface.c
@@ -46,8 +46,6 @@
 #include <acpi/acpi.h>
 #include <acpi/acevents.h>
 #include <acpi/acnamesp.h>
-#include <acpi/acparser.h>
-#include <acpi/acdispat.h>
 #include <acpi/acdebug.h>
 
 #define _COMPONENT          ACPI_UTILITIES
@@ -73,16 +71,12 @@ acpi_initialize_subsystem (
 {
 	acpi_status                     status;
 
+
 	ACPI_FUNCTION_TRACE ("acpi_initialize_subsystem");
 
 
 	ACPI_DEBUG_EXEC (acpi_ut_init_stack_ptr_trace ());
 
-
-	/* Initialize all globals used by the subsystem */
-
-	acpi_ut_init_globals ();
-
 	/* Initialize the OS-Dependent layer */
 
 	status = acpi_os_initialize ();
@@ -92,6 +86,10 @@ acpi_initialize_subsystem (
 		return_ACPI_STATUS (status);
 	}
 
+	/* Initialize all globals used by the subsystem */
+
+	acpi_ut_init_globals ();
+
 	/* Create the default mutex objects */
 
 	status = acpi_ut_mutex_initialize ();
@@ -105,7 +103,6 @@ acpi_initialize_subsystem (
 	 * Initialize the namespace manager and
 	 * the root of the namespace tree
 	 */
-
 	status = acpi_ns_root_initialize ();
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("Namespace initialization failure, %s\n",
@@ -113,7 +110,6 @@ acpi_initialize_subsystem (
 		return_ACPI_STATUS (status);
 	}
 
-
 	/* If configured, initialize the AML debugger */
 
 	ACPI_DEBUGGER_EXEC (status = acpi_db_initialize ());
@@ -150,7 +146,8 @@ acpi_enable_subsystem (
 	 * The values from the FADT are validated here.
 	 */
 	if (!(flags & ACPI_NO_HARDWARE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI hardware\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI hardware\n"));
 
 		status = acpi_hw_initialize ();
 		if (ACPI_FAILURE (status)) {
@@ -178,7 +175,8 @@ acpi_enable_subsystem (
 	 * install_address_space_handler interface.
 	 */
 	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing default address space handlers\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Installing default address space handlers\n"));
 
 		status = acpi_ev_install_region_handlers ();
 		if (ACPI_FAILURE (status)) {
@@ -189,12 +187,14 @@ acpi_enable_subsystem (
 	/*
 	 * Initialize ACPI Event handling (Fixed and General Purpose)
 	 *
-	 * NOTE: We must have the hardware AND events initialized before we can execute
-	 * ANY control methods SAFELY.  Any control method can require ACPI hardware
-	 * support, so the hardware MUST be initialized before execution!
+	 * NOTE: We must have the hardware AND events initialized before we can
+	 * execute ANY control methods SAFELY.  Any control method can require
+	 * ACPI hardware support, so the hardware MUST be initialized before
+	 * execution!
 	 */
 	if (!(flags & ACPI_NO_EVENT_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI events\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI events\n"));
 
 		status = acpi_ev_initialize_events ();
 		if (ACPI_FAILURE (status)) {
@@ -205,7 +205,8 @@ acpi_enable_subsystem (
 	/* Install the SCI handler and Global Lock handler */
 
 	if (!(flags & ACPI_NO_HANDLER_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing SCI/GL handlers\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Installing SCI/GL handlers\n"));
 
 		status = acpi_ev_install_xrupt_handlers ();
 		if (ACPI_FAILURE (status)) {
@@ -247,7 +248,8 @@ acpi_initialize_objects (
 	 * contain executable AML (see call to acpi_ns_initialize_objects below).
 	 */
 	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Executing _REG op_region methods\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Executing _REG op_region methods\n"));
 
 		status = acpi_ev_initialize_op_regions ();
 		if (ACPI_FAILURE (status)) {
@@ -261,7 +263,8 @@ acpi_initialize_objects (
 	 * objects: operation_regions, buffer_fields, Buffers, and Packages.
 	 */
 	if (!(flags & ACPI_NO_OBJECT_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Completing Initialization of ACPI Objects\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Completing Initialization of ACPI Objects\n"));
 
 		status = acpi_ns_initialize_objects ();
 		if (ACPI_FAILURE (status)) {
@@ -274,7 +277,8 @@ acpi_initialize_objects (
 	 * This runs the _STA and _INI methods.
 	 */
 	if (!(flags & ACPI_NO_DEVICE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI Devices\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"[Init] Initializing ACPI Devices\n"));
 
 		status = acpi_ns_initialize_devices ();
 		if (ACPI_FAILURE (status)) {
@@ -307,7 +311,8 @@ acpi_initialize_objects (
  ******************************************************************************/
 
 acpi_status
-acpi_terminate (void)
+acpi_terminate (
+	void)
 {
 	acpi_status                 status;
 
@@ -344,8 +349,7 @@ acpi_terminate (void)
 
 
 #ifdef ACPI_FUTURE_USAGE
-
-/*****************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_subsystem_status
  *
@@ -354,14 +358,16 @@ acpi_terminate (void)
  * RETURN:      Status of the ACPI subsystem
  *
  * DESCRIPTION: Other drivers that use the ACPI subsystem should call this
- *              before making any other calls, to ensure the subsystem initial-
- *              ized successfully.
+ *              before making any other calls, to ensure the subsystem
+ *              initialized successfully.
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
-acpi_subsystem_status (void)
+acpi_subsystem_status (
+	void)
 {
+
 	if (acpi_gbl_startup_flags & ACPI_INITIALIZED_OK) {
 		return (AE_OK);
 	}
@@ -371,13 +377,12 @@ acpi_subsystem_status (void)
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
  * FUNCTION:    acpi_get_system_info
  *
- * PARAMETERS:  out_buffer      - a pointer to a buffer to receive the
- *                                resources for the device
- *              buffer_length   - the number of bytes available in the buffer
+ * PARAMETERS:  out_buffer      - A buffer to receive the resources for the
+ *                                device
  *
  * RETURN:      Status          - the status of the call
  *
@@ -395,8 +400,8 @@ acpi_get_system_info (
 	struct acpi_buffer              *out_buffer)
 {
 	struct acpi_system_info         *info_ptr;
-	u32                             i;
 	acpi_status                     status;
+	u32                             i;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_get_system_info");
@@ -466,6 +471,7 @@ EXPORT_SYMBOL(acpi_get_system_info);
  * FUNCTION:    acpi_install_initialization_handler
  *
  * PARAMETERS:  Handler             - Callback procedure
+ *              Function            - Not (currently) used, see below
  *
  * RETURN:      Status
  *
@@ -495,7 +501,6 @@ acpi_install_initialization_handler (
 
 #endif  /*  ACPI_FUTURE_USAGE  */
 
-
 /*****************************************************************************
  *
  * FUNCTION:    acpi_purge_cached_objects
@@ -509,17 +514,14 @@ acpi_install_initialization_handler (
  ****************************************************************************/
 
 acpi_status
-acpi_purge_cached_objects (void)
+acpi_purge_cached_objects (
+	void)
 {
 	ACPI_FUNCTION_TRACE ("acpi_purge_cached_objects");
 
-
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-	acpi_ut_delete_generic_state_cache ();
-	acpi_ut_delete_object_cache ();
-	acpi_ds_delete_walk_state_cache ();
-	acpi_ps_delete_parse_cache ();
-#endif
-
+	(void) acpi_os_purge_cache (acpi_gbl_state_cache);
+	(void) acpi_os_purge_cache (acpi_gbl_operand_cache);
+	(void) acpi_os_purge_cache (acpi_gbl_ps_node_cache);
+	(void) acpi_os_purge_cache (acpi_gbl_ps_node_ext_cache);
 	return_ACPI_STATUS (AE_OK);
 }
diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -564,12 +564,13 @@ acpi_video_device_find_cap (struct acpi_
 		int count = 0;
 		union acpi_object *o;
 		
-		br = kmalloc(sizeof &br, GFP_KERNEL);
+		br = kmalloc(sizeof(*br), GFP_KERNEL);
 		if (!br) {
 			printk(KERN_ERR "can't allocate memory\n");
 		} else {
-			memset(br, 0, sizeof &br);
-			br->levels = kmalloc(obj->package.count * sizeof &br->levels, GFP_KERNEL);
+			memset(br, 0, sizeof(*br));
+			br->levels = kmalloc(obj->package.count *
+					sizeof *(br->levels), GFP_KERNEL);
 			if (!br->levels)
 				goto out;
 
@@ -584,8 +585,7 @@ acpi_video_device_find_cap (struct acpi_
 			}
 out:
 			if (count < 2) {
-				if (br->levels)
-					kfree(br->levels);
+				kfree(br->levels);
 				kfree(br);
 			} else {
 				br->count = count;
@@ -595,8 +595,7 @@ out:
 		}
 	}
 
-	if (obj)
-		kfree(obj);
+	kfree(obj);
 
 	return_VOID;
 }
@@ -1585,7 +1584,7 @@ acpi_video_switch_output(
 	ACPI_FUNCTION_TRACE("acpi_video_switch_output");
 
 	list_for_each_safe(node, next, &video->video_device_list) {
-		struct acpi_video_device * dev = container_of(node, struct acpi_video_device, entry);
+		dev = container_of(node, struct acpi_video_device, entry);
 		status = acpi_video_device_get_state(dev, &state);
 		if (state & 0x2){
 			dev_next = container_of(node->next, struct acpi_video_device, entry);
diff --git a/drivers/base/sys.c b/drivers/base/sys.c
--- a/drivers/base/sys.c
+++ b/drivers/base/sys.c
@@ -22,7 +22,6 @@
 #include <linux/string.h>
 #include <linux/pm.h>
 
-
 extern struct subsystem devices_subsys;
 
 #define to_sysdev(k) container_of(k, struct sys_device, kobj)
diff --git a/drivers/net/b44.c b/drivers/net/b44.c
--- a/drivers/net/b44.c
+++ b/drivers/net/b44.c
@@ -1927,6 +1927,7 @@ static int b44_suspend(struct pci_dev *p
 	b44_free_rings(bp);
 
 	spin_unlock_irq(&bp->lock);
+	pci_disable_device(pdev);
 	return 0;
 }
 
@@ -1936,6 +1937,8 @@ static int b44_resume(struct pci_dev *pd
 	struct b44 *bp = netdev_priv(dev);
 
 	pci_restore_state(pdev);
+	pci_enable_device(pdev);
+	pci_set_master(pdev);
 
 	if (!netif_running(dev))
 		return 0;
diff --git a/drivers/net/ne2k-pci.c b/drivers/net/ne2k-pci.c
--- a/drivers/net/ne2k-pci.c
+++ b/drivers/net/ne2k-pci.c
@@ -660,6 +660,7 @@ static int ne2k_pci_suspend (struct pci_
 
 	netif_device_detach(dev);
 	pci_save_state(pdev);
+	pci_disable_device(pdev);
 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
 
 	return 0;
@@ -671,6 +672,8 @@ static int ne2k_pci_resume (struct pci_d
 
 	pci_set_power_state(pdev, 0);
 	pci_restore_state(pdev);
+	pci_enable_device(pdev);
+	pci_set_master(pdev);
 	NS8390_init(dev, 1);
 	netif_device_attach(dev);
 
diff --git a/drivers/net/sk98lin/skge.c b/drivers/net/sk98lin/skge.c
--- a/drivers/net/sk98lin/skge.c
+++ b/drivers/net/sk98lin/skge.c
@@ -5134,6 +5134,67 @@ static void __devexit skge_remove_one(st
 	kfree(pAC);
 }
 
+#ifdef CONFIG_PM
+static int skge_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	DEV_NET *pNet = netdev_priv(dev);
+	SK_AC *pAC = pNet->pAC;
+	struct net_device *otherdev = pAC->dev[1];
+
+	if (pNet->Up) {
+		pAC->WasIfUp[0] = SK_TRUE;
+		DoPrintInterfaceChange = SK_FALSE;
+		SkDrvDeInitAdapter(pAC, 0);  /* performs SkGeClose */
+	}
+	if (otherdev != dev) {
+		pNet = netdev_priv(otherdev);
+		if (pNet->Up) {
+			pAC->WasIfUp[1] = SK_TRUE;
+			DoPrintInterfaceChange = SK_FALSE;
+			SkDrvDeInitAdapter(pAC, 1);  /* performs SkGeClose */
+		}
+	}
+
+	pci_save_state(pdev);
+	pci_enable_wake(pdev, pci_choose_state(pdev, state), 0);
+	if (pAC->AllocFlag & SK_ALLOC_IRQ) {
+		free_irq(dev->irq, dev);
+	}
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+
+	return 0;
+}
+
+static int skge_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	DEV_NET *pNet = netdev_priv(dev);
+	SK_AC *pAC = pNet->pAC;
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	pci_enable_device(pdev);
+	pci_set_master(pdev);
+	if (pAC->GIni.GIMacsFound == 2)
+		request_irq(dev->irq, SkGeIsr, SA_SHIRQ, pAC->Name, dev);
+	else
+		request_irq(dev->irq, SkGeIsrOnePort, SA_SHIRQ, pAC->Name, dev);
+
+        if (pAC->WasIfUp[0] == SK_TRUE) {
+		DoPrintInterfaceChange = SK_FALSE;
+		SkDrvInitAdapter(pAC, 0);    /* first device  */
+        }
+	if (pAC->dev[1] != dev && pAC->WasIfUp[1] == SK_TRUE) {
+		DoPrintInterfaceChange = SK_FALSE;
+		SkDrvInitAdapter(pAC, 1);    /* first device  */
+	}
+
+	return 0;
+}
+#endif
+
 static struct pci_device_id skge_pci_tbl[] = {
 	{ PCI_VENDOR_ID_3COM, 0x1700, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	{ PCI_VENDOR_ID_3COM, 0x80eb, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
@@ -5159,6 +5220,8 @@ static struct pci_driver skge_driver = {
 	.id_table	= skge_pci_tbl,
 	.probe		= skge_probe_one,
 	.remove		= __devexit_p(skge_remove_one),
+	.suspend	= skge_suspend,
+	.resume		= skge_resume,
 };
 
 static int __init skge_init(void)
diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,9 +1,10 @@
 /*
  * File:	pci-acpi.c
- * Purpose:	Provide PCI supports in ACPI
+ * Purpose:	Provide PCI support in ACPI
  *
- * Copyright (C) 2004 Intel
- * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ * Copyright (C) 2005 David Shaohua Li <shaohua.li@intel.com>
+ * Copyright (C) 2004 Tom Long Nguyen <tom.l.nguyen@intel.com>
+ * Copyright (C) 2004 Intel Corp.
  */
 
 #include <linux/delay.h>
@@ -16,6 +17,7 @@
 #include <acpi/acpi_bus.h>
 
 #include <linux/pci-acpi.h>
+#include "pci.h"
 
 static u32 ctrlset_buf[3] = {0, 0, 0};
 static u32 global_ctrlsets = 0;
@@ -207,3 +209,105 @@ acpi_status pci_osc_control_set(u32 flag
 	return status;
 }
 EXPORT_SYMBOL(pci_osc_control_set);
+
+/*
+ * _SxD returns the D-state with the highest power
+ * (lowest D-state number) supported in the S-state "x".
+ *
+ * If the devices does not have a _PRW
+ * (Power Resources for Wake) supporting system wakeup from "x"
+ * then the OS is free to choose a lower power (higher number
+ * D-state) than the return value from _SxD.
+ *
+ * But if _PRW is enabled at S-state "x", the OS
+ * must not choose a power lower than _SxD --
+ * unless the device has an _SxW method specifying
+ * the lowest power (highest D-state number) the device
+ * may enter while still able to wake the system.
+ *
+ * ie. depending on global OS policy:
+ *
+ * if (_PRW at S-state x)
+ *	choose from highest power _SxD to lowest power _SxW
+ * else // no _PRW at S-state x
+ * 	choose highest power _SxD or any lower power
+ *
+ * currently we simply return _SxD, if present.
+ */
+
+static int acpi_pci_choose_state(struct pci_dev *pdev, pm_message_t state)
+{
+	/* TBD */
+
+	return -ENODEV;
+}
+
+static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	static int state_conv[] = {
+		[0] = 0,
+		[1] = 1,
+		[2] = 2,
+		[3] = 3,
+		[4] = 3
+	};
+	int acpi_state = state_conv[(int __force) state];
+
+	if (!handle)
+		return -ENODEV;
+	return acpi_bus_set_power(handle, acpi_state);
+}
+
+
+/* ACPI bus type */
+static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
+{
+	struct pci_dev * pci_dev;
+	acpi_integer	addr;
+
+	pci_dev = to_pci_dev(dev);
+	/* Please ref to ACPI spec for the syntax of _ADR */
+	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
+	*handle = acpi_get_child(DEVICE_ACPI_HANDLE(dev->parent), addr);
+	if (!*handle)
+		return -ENODEV;
+	return 0;
+}
+
+static int pci_acpi_find_root_bridge(struct device *dev, acpi_handle *handle)
+{
+	int num;
+	unsigned int seg, bus;
+
+	/*
+	 * The string should be the same as root bridge's name
+	 * Please look at 'pci_scan_bus_parented'
+	 */
+	num = sscanf(dev->bus_id, "pci%04x:%02x", &seg, &bus);
+	if (num != 2)
+		return -ENODEV;
+	*handle = acpi_get_pci_rootbridge_handle(seg, bus);
+	if (!*handle)
+		return -ENODEV;
+	return 0;
+}
+
+static struct acpi_bus_type pci_acpi_bus = {
+	.bus = &pci_bus_type,
+	.find_device = pci_acpi_find_device,
+	.find_bridge = pci_acpi_find_root_bridge,
+};
+
+static int __init pci_acpi_init(void)
+{
+	int ret;
+
+	ret = register_acpi_bus_type(&pci_acpi_bus);
+	if (ret)
+		return 0;
+	platform_pci_choose_state = acpi_pci_choose_state;
+	platform_pci_set_power_state = acpi_pci_set_power_state;
+	return 0;
+}
+arch_initcall(pci_acpi_init);
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -235,7 +235,7 @@ pci_find_parent_resource(const struct pc
  * -EIO if device does not support PCI PM.
  * 0 if we can successfully change the power state.
  */
-
+int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -299,11 +299,20 @@ pci_set_power_state(struct pci_dev *dev,
 		msleep(10);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(200);
-	dev->current_state = state;
 
+	/*
+	 * Give firmware a chance to be called, such as ACPI _PRx, _PSx
+	 * Firmware method after natice method ?
+	 */
+	if (platform_pci_set_power_state)
+		platform_pci_set_power_state(dev, state);
+
+	dev->current_state = state;
 	return 0;
 }
 
+int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
+ 
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -316,10 +325,17 @@ pci_set_power_state(struct pci_dev *dev,
 
 pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 {
+	int ret;
+
 	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
 		return PCI_D0;
 
-	switch (state) {
+	if (platform_pci_choose_state) {
+		ret = platform_pci_choose_state(dev, state);
+		if (ret >= 0)
+			state = ret;
+	}
+ 	switch (state) {
 	case 0: return PCI_D0;
 	case 3: return PCI_D3hot;
 	default:
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -11,6 +11,10 @@ extern int pci_bus_alloc_resource(struct
 				  void (*alignf)(void *, struct resource *,
 					  	 unsigned long, unsigned long),
 				  void *alignf_data);
+/* Firmware callbacks */
+extern int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
+extern int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t state);
+
 /* PCI /proc functions */
 #ifdef CONFIG_PROC_FS
 extern int pci_proc_attach_device(struct pci_dev *dev);
diff --git a/drivers/pcmcia/yenta_socket.c b/drivers/pcmcia/yenta_socket.c
--- a/drivers/pcmcia/yenta_socket.c
+++ b/drivers/pcmcia/yenta_socket.c
@@ -1032,6 +1032,9 @@ static int yenta_dev_suspend (struct pci
 		pci_save_state(dev);
 		pci_read_config_dword(dev, 16*4, &socket->saved_state[0]);
 		pci_read_config_dword(dev, 17*4, &socket->saved_state[1]);
+		pci_disable_device(dev);
+
+		free_irq(dev->irq, socket);
 
 		/*
 		 * Some laptops (IBM T22) do not like us putting the Cardbus
@@ -1055,6 +1058,15 @@ static int yenta_dev_resume (struct pci_
 		pci_restore_state(dev);
 		pci_write_config_dword(dev, 16*4, socket->saved_state[0]);
 		pci_write_config_dword(dev, 17*4, socket->saved_state[1]);
+		pci_enable_device(dev);
+		pci_set_master(dev);
+
+		if (socket->cb_irq)
+			if (request_irq(socket->cb_irq, yenta_interrupt,
+			                SA_SHIRQ, "yenta", socket)) {
+				printk(KERN_WARNING "Yenta: request_irq() failed on resume!\n");
+				socket->cb_irq = 0;
+			}
 
 		if (socket->type && socket->type->restore_state)
 			socket->type->restore_state(socket);
diff --git a/drivers/pnp/pnpacpi/rsparser.c b/drivers/pnp/pnpacpi/rsparser.c
--- a/drivers/pnp/pnpacpi/rsparser.c
+++ b/drivers/pnp/pnpacpi/rsparser.c
@@ -160,7 +160,7 @@ static acpi_status pnpacpi_allocated_res
 				acpi_register_gsi(res->data.irq.interrupts[0],
 					res->data.irq.edge_level,
 					res->data.irq.active_high_low));
-			pcibios_penalize_isa_irq(res->data.irq.interrupts[0]);
+			pcibios_penalize_isa_irq(res->data.irq.interrupts[0], 1);
 		}
 		break;
 
@@ -171,7 +171,7 @@ static acpi_status pnpacpi_allocated_res
 				acpi_register_gsi(res->data.extended_irq.interrupts[0],
 					res->data.extended_irq.edge_level,
 					res->data.extended_irq.active_high_low));
-			pcibios_penalize_isa_irq(res->data.extended_irq.interrupts[0]);
+			pcibios_penalize_isa_irq(res->data.extended_irq.interrupts[0], 1);
 		}
 		break;
 	case ACPI_RSTYPE_DMA:
@@ -444,6 +444,7 @@ pnpacpi_parse_fixed_mem32_option(struct 
 
 struct acpipnp_parse_option_s {
 	struct pnp_option *option;
+	struct pnp_option *option_independent;
 	struct pnp_dev *dev;
 };
 
@@ -507,7 +508,14 @@ static acpi_status pnpacpi_option_resour
 			parse_data->option = option;	
 			break;
 		case ACPI_RSTYPE_END_DPF:
-			return AE_CTRL_TERMINATE;
+			/*only one EndDependentFn is allowed*/
+			if (!parse_data->option_independent) {
+				pnp_warn("PnPACPI: more than one EndDependentFn");
+				return AE_ERROR;
+			}
+			parse_data->option = parse_data->option_independent;
+			parse_data->option_independent = NULL;
+			break;
 		default:
 			pnp_warn("PnPACPI: unknown resource type %d", res->id);
 			return AE_ERROR;
@@ -525,6 +533,7 @@ acpi_status pnpacpi_parse_resource_optio
 	parse_data.option = pnp_register_independent_option(dev);
 	if (!parse_data.option)
 		return AE_ERROR;
+	parse_data.option_independent = parse_data.option;
 	parse_data.dev = dev;
 	status = acpi_walk_resources(handle, METHOD_NAME__PRS, 
 		pnpacpi_option_resource, &parse_data);
diff --git a/drivers/pnp/pnpbios/rsparser.c b/drivers/pnp/pnpbios/rsparser.c
--- a/drivers/pnp/pnpbios/rsparser.c
+++ b/drivers/pnp/pnpbios/rsparser.c
@@ -64,7 +64,7 @@ pnpbios_parse_allocated_irqresource(stru
 		}
 		res->irq_resource[i].start =
 		res->irq_resource[i].end = (unsigned long) irq;
-		pcibios_penalize_isa_irq(irq);
+		pcibios_penalize_isa_irq(irq, 1);
 	}
 }
 
diff --git a/drivers/pnp/resource.c b/drivers/pnp/resource.c
--- a/drivers/pnp/resource.c
+++ b/drivers/pnp/resource.c
@@ -102,7 +102,7 @@ int pnp_register_irq_resource(struct pnp
 
 		for (i = 0; i < 16; i++)
 			if (test_bit(i, data->map))
-				pcibios_penalize_isa_irq(i);
+				pcibios_penalize_isa_irq(i, 0);
 	}
 #endif
 	return 0;
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -380,6 +380,7 @@ int usb_hcd_pci_resume (struct pci_dev *
 		usb_hc_died (hcd);
 	}
 
+	pci_enable_device(dev);
 	return retval;
 }
 EXPORT_SYMBOL (usb_hcd_pci_resume);
diff --git a/include/acpi/acconfig.h b/include/acpi/acconfig.h
--- a/include/acpi/acconfig.h
+++ b/include/acpi/acconfig.h
@@ -64,7 +64,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION                 0x20050309
+#define ACPI_CA_VERSION                 0x20050729
 
 /*
  * OS name, used for the _OS object.  The _OS object is essentially obsolete,
@@ -78,11 +78,10 @@
 
 /* Maximum objects in the various object caches */
 
-#define ACPI_MAX_STATE_CACHE_DEPTH      64          /* State objects */
+#define ACPI_MAX_STATE_CACHE_DEPTH      96          /* State objects */
 #define ACPI_MAX_PARSE_CACHE_DEPTH      96          /* Parse tree objects */
-#define ACPI_MAX_EXTPARSE_CACHE_DEPTH   64          /* Parse tree objects */
-#define ACPI_MAX_OBJECT_CACHE_DEPTH     64          /* Interpreter operand objects */
-#define ACPI_MAX_WALK_CACHE_DEPTH       4           /* Objects for parse tree walks */
+#define ACPI_MAX_EXTPARSE_CACHE_DEPTH   96          /* Parse tree objects */
+#define ACPI_MAX_OBJECT_CACHE_DEPTH     96          /* Interpreter operand objects */
 
 /*
  * Should the subystem abort the loading of an ACPI table if the
@@ -130,9 +129,8 @@
 #define ACPI_MAX_GPE_BLOCKS             2
 #define ACPI_GPE_REGISTER_WIDTH         8
 
-/*
- * Method info (in WALK_STATE), containing local variables and argumetns
- */
+/* Method info (in WALK_STATE), containing local variables and argumetns */
+
 #define ACPI_METHOD_NUM_LOCALS          8
 #define ACPI_METHOD_MAX_LOCAL           7
 
diff --git a/include/acpi/acdebug.h b/include/acpi/acdebug.h
--- a/include/acpi/acdebug.h
+++ b/include/acpi/acdebug.h
@@ -61,9 +61,7 @@ struct argument_info
 
 
 #define PARAM_LIST(pl)                  pl
-
 #define DBTEST_OUTPUT_LEVEL(lvl)        if (acpi_gbl_db_opt_verbose)
-
 #define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
 			  acpi_os_printf PARAM_LIST(fp);}
 
@@ -71,13 +69,9 @@ struct argument_info
 #define EX_SINGLE_STEP                  2
 
 
-/* Prototypes */
-
-
 /*
  * dbxface - external debugger interfaces
  */
-
 acpi_status
 acpi_db_initialize (
 	void);
@@ -92,20 +86,10 @@ acpi_db_single_step (
 	union acpi_parse_object         *op,
 	u32                             op_type);
 
-acpi_status
-acpi_db_start_command (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op);
-
-void
-acpi_db_method_end (
-	struct acpi_walk_state          *walk_state);
-
 
 /*
  * dbcmds - debug commands and output routines
  */
-
 acpi_status
 acpi_db_disassemble_method (
 	char                            *name);
@@ -130,6 +114,10 @@ acpi_db_set_method_call_breakpoint (
 	union acpi_parse_object         *op);
 
 void
+acpi_db_get_bus_info (
+	void);
+
+void
 acpi_db_disassemble_aml (
 	char                            *statements,
 	union acpi_parse_object         *op);
@@ -177,57 +165,30 @@ acpi_db_find_references (
 	char                            *object_arg);
 
 void
-acpi_db_display_locks (void);
-
+acpi_db_display_locks (
+	void);
 
 void
 acpi_db_display_resources (
 	char                            *object_arg);
 
 void
-acpi_db_display_gpes (void);
+acpi_db_display_gpes (
+	void);
 
 void
 acpi_db_check_integrity (
 	void);
 
-acpi_status
-acpi_db_integrity_walk (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_and_match_name (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_for_references (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
-acpi_db_walk_for_specific_objects (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
 void
 acpi_db_generate_gpe (
 	char                            *gpe_arg,
 	char                            *block_arg);
 
+
 /*
  * dbdisply - debug display commands
  */
-
 void
 acpi_db_display_method_info (
 	union acpi_parse_object         *op);
@@ -271,19 +232,10 @@ acpi_db_display_argument_object (
 	union acpi_operand_object       *obj_desc,
 	struct acpi_walk_state          *walk_state);
 
-void
-acpi_db_dump_parser_descriptor (
-	union acpi_parse_object         *op);
-
-void *
-acpi_db_get_pointer (
-	void                            *target);
-
 
 /*
  * dbexec - debugger control method execution
  */
-
 void
 acpi_db_execute (
 	char                            *name,
@@ -296,44 +248,15 @@ acpi_db_create_execution_threads (
 	char                            *num_loops_arg,
 	char                            *method_name_arg);
 
-acpi_status
-acpi_db_execute_method (
-	struct acpi_db_method_info      *info,
-	struct acpi_buffer              *return_obj);
-
-void
-acpi_db_execute_setup (
-	struct acpi_db_method_info      *info);
-
-u32
-acpi_db_get_outstanding_allocations (
-	void);
-
-void ACPI_SYSTEM_XFACE
-acpi_db_method_thread (
-	void                            *context);
-
-acpi_status
-acpi_db_execution_walk (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
 
 /*
  * dbfileio - Debugger file I/O commands
  */
-
 acpi_object_type
 acpi_db_match_argument (
 	char                            *user_argument,
 	struct argument_info            *arguments);
 
-acpi_status
-ae_local_load_table (
-	struct acpi_table_header        *table_ptr);
-
 void
 acpi_db_close_debug_file (
 	void);
@@ -356,16 +279,17 @@ acpi_db_read_table_from_file (
 	char                            *filename,
 	struct acpi_table_header        **table);
 
+
 /*
  * dbhistry - debugger HISTORY command
  */
-
 void
 acpi_db_add_to_history (
 	char                            *command_line);
 
 void
-acpi_db_display_history (void);
+acpi_db_display_history (
+	void);
 
 char *
 acpi_db_get_from_history (
@@ -375,7 +299,6 @@ acpi_db_get_from_history (
 /*
  * dbinput - user front-end to the AML debugger
  */
-
 acpi_status
 acpi_db_command_dispatch (
 	char                            *input_buffer,
@@ -386,72 +309,29 @@ void ACPI_SYSTEM_XFACE
 acpi_db_execute_thread (
 	void                            *context);
 
-void
-acpi_db_display_help (
-	char                            *help_type);
-
-char *
-acpi_db_get_next_token (
-	char                            *string,
-	char                            **next);
-
-u32
-acpi_db_get_line (
-	char                            *input_buffer);
-
-u32
-acpi_db_match_command (
-	char                            *user_command);
-
-void
-acpi_db_single_thread (
-	void);
-
 
 /*
  * dbstats - Generation and display of ACPI table statistics
  */
-
 void
 acpi_db_generate_statistics (
 	union acpi_parse_object         *root,
 	u8                              is_method);
 
-
 acpi_status
 acpi_db_display_statistics (
 	char                            *type_arg);
 
-acpi_status
-acpi_db_classify_one_object (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
-
-void
-acpi_db_count_namespace_objects (
-	void);
-
-void
-acpi_db_enumerate_object (
-	union acpi_operand_object       *obj_desc);
-
 
 /*
  * dbutils - AML debugger utilities
  */
-
 void
 acpi_db_set_output_destination (
 	u32                             where);
 
 void
-acpi_db_dump_buffer (
-	u32                             address);
-
-void
-acpi_db_dump_object (
+acpi_db_dump_external_object (
 	union acpi_object               *obj_desc,
 	u32                             level);
 
@@ -459,14 +339,8 @@ void
 acpi_db_prep_namestring (
 	char                            *name);
 
-
-acpi_status
-acpi_db_second_pass_parse (
-	union acpi_parse_object         *root);
-
 struct acpi_namespace_node *
 acpi_db_local_ns_lookup (
 	char                            *name);
 
-
 #endif  /* __ACDEBUG_H__ */
diff --git a/include/acpi/acdisasm.h b/include/acpi/acdisasm.h
--- a/include/acpi/acdisasm.h
+++ b/include/acpi/acdisasm.h
@@ -90,6 +90,7 @@ struct acpi_op_walk_info
 {
 	u32                             level;
 	u32                             bit_offset;
+	struct acpi_walk_state          *walk_state;
 };
 
 typedef
@@ -102,58 +103,16 @@ acpi_status (*asl_walk_callback) (
 /*
  * dmwalk
  */
-
-void
-acpi_dm_walk_parse_tree (
-	union acpi_parse_object         *op,
-	asl_walk_callback               descending_callback,
-	asl_walk_callback               ascending_callback,
-	void                            *context);
-
-acpi_status
-acpi_dm_descending_op (
-	union acpi_parse_object         *op,
-	u32                             level,
-	void                            *context);
-
-acpi_status
-acpi_dm_ascending_op (
-	union acpi_parse_object         *op,
-	u32                             level,
-	void                            *context);
-
-
-/*
- * dmopcode
- */
-
-void
-acpi_dm_validate_name (
-	char                            *name,
-	union acpi_parse_object         *op);
-
-u32
-acpi_dm_dump_name (
-	char                            *name);
-
-void
-acpi_dm_unicode (
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_disassemble (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *origin,
 	u32                             num_opcodes);
 
-void
-acpi_dm_namestring (
-	char                            *name);
-
-void
-acpi_dm_display_path (
-	union acpi_parse_object         *op);
 
+/*
+ * dmopcode
+ */
 void
 acpi_dm_disassemble_one_op (
 	struct acpi_walk_state          *walk_state,
@@ -165,18 +124,9 @@ acpi_dm_decode_internal_object (
 	union acpi_operand_object       *obj_desc);
 
 u32
-acpi_dm_block_type (
-	union acpi_parse_object         *op);
-
-u32
 acpi_dm_list_type (
 	union acpi_parse_object         *op);
 
-acpi_status
-acpi_ps_display_object_pathname (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_method_flags (
 	union acpi_parse_object         *op);
@@ -197,10 +147,6 @@ void
 acpi_dm_match_op (
 	union acpi_parse_object         *op);
 
-void
-acpi_dm_match_keyword (
-	union acpi_parse_object         *op);
-
 u8
 acpi_dm_comma_if_list_member (
 	union acpi_parse_object         *op);
@@ -211,13 +157,25 @@ acpi_dm_comma_if_field_member (
 
 
 /*
- * dmobject
+ * dmnames
  */
+u32
+acpi_dm_dump_name (
+	char                            *name);
+
+acpi_status
+acpi_ps_display_object_pathname (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
 
 void
-acpi_dm_decode_node (
-	struct acpi_namespace_node      *node);
+acpi_dm_namestring (
+	char                            *name);
+
 
+/*
+ * dmobject
+ */
 void
 acpi_dm_display_internal_object (
 	union acpi_operand_object       *obj_desc,
@@ -241,9 +199,19 @@ acpi_dm_dump_method_info (
 /*
  * dmbuffer
  */
+void
+acpi_dm_disasm_byte_list (
+	u32                             level,
+	u8                              *byte_data,
+	u32                             byte_count);
+
+void
+acpi_dm_byte_list (
+	struct acpi_op_walk_info        *info,
+	union acpi_parse_object         *op);
 
 void
-acpi_is_eisa_id (
+acpi_dm_is_eisa_id (
 	union acpi_parse_object         *op);
 
 void
@@ -262,18 +230,6 @@ acpi_dm_is_string_buffer (
 /*
  * dmresrc
  */
-
-void
-acpi_dm_disasm_byte_list (
-	u32                             level,
-	u8                              *byte_data,
-	u32                             byte_count);
-
-void
-acpi_dm_byte_list (
-	struct acpi_op_walk_info        *info,
-	union acpi_parse_object         *op);
-
 void
 acpi_dm_resource_descriptor (
 	struct acpi_op_walk_info        *info,
@@ -296,19 +252,10 @@ void
 acpi_dm_decode_attribute (
 	u8                              attribute);
 
+
 /*
  * dmresrcl
  */
-
-void
-acpi_dm_io_flags (
-		u8                          flags);
-
-void
-acpi_dm_memory_flags (
-	u8                              flags,
-	u8                              specific_flags);
-
 void
 acpi_dm_word_descriptor (
 	struct asl_word_address_desc    *resource,
@@ -373,7 +320,6 @@ acpi_dm_vendor_large_descriptor (
 /*
  * dmresrcs
  */
-
 void
 acpi_dm_irq_descriptor (
 	struct asl_irq_format_desc      *resource,
@@ -420,7 +366,6 @@ acpi_dm_vendor_small_descriptor (
 /*
  * dmutils
  */
-
 void
 acpi_dm_add_to_external_list (
 	char                            *path);
diff --git a/include/acpi/acdispat.h b/include/acpi/acdispat.h
--- a/include/acpi/acdispat.h
+++ b/include/acpi/acdispat.h
@@ -50,40 +50,9 @@
 #define NAMEOF_ARG_NTE      "__A0"
 
 
-/* Common interfaces */
-
-acpi_status
-acpi_ds_obj_stack_push (
-	void                            *object,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ds_obj_stack_pop (
-	u32                             pop_count,
-	struct acpi_walk_state          *walk_state);
-
-#ifdef ACPI_FUTURE_USAGE
-void *
-acpi_ds_obj_stack_get_value (
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-#endif
-
-acpi_status
-acpi_ds_obj_stack_pop_object (
-	union acpi_operand_object       **object,
-	struct acpi_walk_state          *walk_state);
-
-
-/* dsopcode - support for late evaluation */
-
-acpi_status
-acpi_ds_execute_arguments (
-	struct acpi_namespace_node      *node,
-	struct acpi_namespace_node      *scope_node,
-	u32                             aml_length,
-	u8                              *aml_start);
-
+/*
+ * dsopcode - support for late evaluation
+ */
 acpi_status
 acpi_ds_get_buffer_field_arguments (
 	union acpi_operand_object       *obj_desc);
@@ -101,15 +70,6 @@ acpi_ds_get_package_arguments (
 	union acpi_operand_object       *obj_desc);
 
 acpi_status
-acpi_ds_init_buffer_field (
-	u16                             aml_opcode,
-	union acpi_operand_object       *obj_desc,
-	union acpi_operand_object       *buffer_desc,
-	union acpi_operand_object       *offset_desc,
-	union acpi_operand_object       *length_desc,
-	union acpi_operand_object       *result_desc);
-
-acpi_status
 acpi_ds_eval_buffer_field_operands (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op);
@@ -130,9 +90,9 @@ acpi_ds_initialize_region (
 	acpi_handle                     obj_handle);
 
 
-/* dsctrl - Parser/Interpreter interface, control stack routines */
-
-
+/*
+ * dsctrl - Parser/Interpreter interface, control stack routines
+ */
 acpi_status
 acpi_ds_exec_begin_control_op (
 	struct acpi_walk_state          *walk_state,
@@ -144,9 +104,9 @@ acpi_ds_exec_end_control_op (
 	union acpi_parse_object         *op);
 
 
-/* dsexec - Parser/Interpreter interface, method execution callbacks */
-
-
+/*
+ * dsexec - Parser/Interpreter interface, method execution callbacks
+ */
 acpi_status
 acpi_ds_get_predicate_value (
 	struct acpi_walk_state          *walk_state,
@@ -162,14 +122,9 @@ acpi_ds_exec_end_op (
 	struct acpi_walk_state          *state);
 
 
-/* dsfield - Parser/Interpreter interface for AML fields */
-
-acpi_status
-acpi_ds_get_field_names (
-	struct acpi_create_field_info   *info,
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *arg);
-
+/*
+ * dsfield - Parser/Interpreter interface for AML fields
+ */
 acpi_status
 acpi_ds_create_field (
 	union acpi_parse_object         *op,
@@ -199,8 +154,9 @@ acpi_ds_init_field_objects (
 	struct acpi_walk_state          *walk_state);
 
 
-/* dsload - Parser/Interpreter interface, namespace load callbacks */
-
+/*
+ * dsload - Parser/Interpreter interface, namespace load callbacks
+ */
 acpi_status
 acpi_ds_load1_begin_op (
 	struct acpi_walk_state          *walk_state,
@@ -225,9 +181,9 @@ acpi_ds_init_callbacks (
 	u32                             pass_number);
 
 
-/* dsmthdat - method data (locals/args) */
-
-
+/*
+ * dsmthdat - method data (locals/args)
+ */
 acpi_status
 acpi_ds_store_object_to_local (
 	u16                             opcode,
@@ -250,14 +206,6 @@ u8
 acpi_ds_is_method_value (
 	union acpi_operand_object       *obj_desc);
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_object_type
-acpi_ds_method_data_get_type (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-#endif
-
 acpi_status
 acpi_ds_method_data_get_value (
 	u16                             opcode,
@@ -265,12 +213,6 @@ acpi_ds_method_data_get_value (
 	struct acpi_walk_state          *walk_state,
 	union acpi_operand_object       **dest_desc);
 
-void
-acpi_ds_method_data_delete_value (
-	u16                             opcode,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-
 acpi_status
 acpi_ds_method_data_init_args (
 	union acpi_operand_object       **params,
@@ -288,19 +230,13 @@ void
 acpi_ds_method_data_init (
 	struct acpi_walk_state          *walk_state);
 
-acpi_status
-acpi_ds_method_data_set_value (
-	u16                             opcode,
-	u32                             index,
-	union acpi_operand_object       *object,
-	struct acpi_walk_state          *walk_state);
-
-
-/* dsmethod - Parser/Interpreter interface - control method parsing */
 
+/*
+ * dsmethod - Parser/Interpreter interface - control method parsing
+ */
 acpi_status
 acpi_ds_parse_method (
-	acpi_handle                     obj_handle);
+	struct acpi_namespace_node      *node);
 
 acpi_status
 acpi_ds_call_control_method (
@@ -324,20 +260,18 @@ acpi_ds_begin_method_execution (
 	struct acpi_namespace_node      *calling_method_node);
 
 
-/* dsobj - Parser/Interpreter interface - object initialization and conversion */
-
-acpi_status
-acpi_ds_init_one_object (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
+/*
+ * dsinit
+ */
 acpi_status
 acpi_ds_initialize_objects (
 	struct acpi_table_desc          *table_desc,
 	struct acpi_namespace_node      *start_node);
 
+
+/*
+ * dsobject - Parser/Interpreter interface - object initialization and conversion
+ */
 acpi_status
 acpi_ds_build_internal_buffer_obj (
 	struct acpi_walk_state          *walk_state,
@@ -353,12 +287,6 @@ acpi_ds_build_internal_package_obj (
 	union acpi_operand_object       **obj_desc);
 
 acpi_status
-acpi_ds_build_internal_object (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         *op,
-	union acpi_operand_object       **obj_desc_ptr);
-
-acpi_status
 acpi_ds_init_object_from_op (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op,
@@ -372,8 +300,9 @@ acpi_ds_create_node (
 	union acpi_parse_object         *op);
 
 
-/* dsutils - Parser/Interpreter interface utility routines */
-
+/*
+ * dsutils - Parser/Interpreter interface utility routines
+ */
 void
 acpi_ds_clear_implicit_return (
 	struct acpi_walk_state          *walk_state);
@@ -418,7 +347,6 @@ acpi_ds_clear_operands (
 /*
  * dswscope - Scope Stack manipulation
  */
-
 acpi_status
 acpi_ds_scope_stack_push (
 	struct acpi_namespace_node      *node,
@@ -435,7 +363,18 @@ acpi_ds_scope_stack_clear (
 	struct acpi_walk_state          *walk_state);
 
 
-/* dswstate - parser WALK_STATE management routines */
+/*
+ * dswstate - parser WALK_STATE management routines
+ */
+acpi_status
+acpi_ds_obj_stack_push (
+	void                            *object,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop (
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state);
 
 struct acpi_walk_state *
 acpi_ds_create_walk_state (
@@ -452,13 +391,7 @@ acpi_ds_init_aml_walk (
 	u8                              *aml_start,
 	u32                             aml_length,
 	struct acpi_parameter_info      *info,
-	u32                             pass_number);
-
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ds_obj_stack_delete_all (
-	struct acpi_walk_state          *walk_state);
-#endif
+	u8                              pass_number);
 
 acpi_status
 acpi_ds_obj_stack_pop_and_delete (
@@ -494,20 +427,8 @@ struct acpi_walk_state *
 acpi_ds_get_current_walk_state (
 	struct acpi_thread_state        *thread);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ds_delete_walk_state_cache (
-	void);
-#endif
-
 #ifdef ACPI_FUTURE_USAGE
 acpi_status
-acpi_ds_result_insert (
-	void                            *object,
-	u32                             index,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
 acpi_ds_result_remove (
 	union acpi_operand_object       **object,
 	u32                             index,
diff --git a/include/acpi/acevents.h b/include/acpi/acevents.h
--- a/include/acpi/acevents.h
+++ b/include/acpi/acevents.h
@@ -45,6 +45,9 @@
 #define __ACEVENTS_H__
 
 
+/*
+ * evevent
+ */
 acpi_status
 acpi_ev_initialize_events (
 	void);
@@ -53,28 +56,14 @@ acpi_status
 acpi_ev_install_xrupt_handlers (
 	void);
 
-
-/*
- * Evfixed - Fixed event handling
- */
-
-acpi_status
-acpi_ev_fixed_event_initialize (
-	void);
-
 u32
 acpi_ev_fixed_event_detect (
 	void);
 
-u32
-acpi_ev_fixed_event_dispatch (
-	u32                             event);
-
 
 /*
- * Evmisc
+ * evmisc
  */
-
 u8
 acpi_ev_is_notify_object (
 	struct acpi_namespace_node      *node);
@@ -100,24 +89,10 @@ acpi_ev_queue_notify_request (
 	struct acpi_namespace_node      *node,
 	u32                             notify_value);
 
-void ACPI_SYSTEM_XFACE
-acpi_ev_notify_dispatch (
-	void                            *context);
-
 
 /*
- * Evgpe - GPE handling and dispatch
+ * evgpe - GPE handling and dispatch
  */
-
-acpi_status
-acpi_ev_walk_gpe_list (
-	ACPI_GPE_CALLBACK       gpe_walk_callback,
-	u32                             flags);
-
-u8
-acpi_ev_valid_gpe_event (
-	struct acpi_gpe_event_info      *gpe_event_info);
-
 acpi_status
 acpi_ev_update_gpe_enable_masks (
 	struct acpi_gpe_event_info      *gpe_event_info,
@@ -137,9 +112,22 @@ acpi_ev_get_gpe_event_info (
 	acpi_handle                     gpe_device,
 	u32                             gpe_number);
 
+
+/*
+ * evgpeblk
+ */
+u8
+acpi_ev_valid_gpe_event (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
 acpi_status
-acpi_ev_gpe_initialize (
-	void);
+acpi_ev_walk_gpe_list (
+	ACPI_GPE_CALLBACK       gpe_walk_callback);
+
+acpi_status
+acpi_ev_delete_gpe_handlers (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
 
 acpi_status
 acpi_ev_create_gpe_block (
@@ -147,18 +135,13 @@ acpi_ev_create_gpe_block (
 	struct acpi_generic_address     *gpe_block_address,
 	u32                             register_count,
 	u8                              gpe_block_base_number,
-	u32                             interrupt_level,
+	u32                             interrupt_number,
 	struct acpi_gpe_block_info      **return_gpe_block);
 
 acpi_status
 acpi_ev_delete_gpe_block (
 	struct acpi_gpe_block_info      *gpe_block);
 
-acpi_status
-acpi_ev_delete_gpe_handlers (
-	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
-	struct acpi_gpe_block_info      *gpe_block);
-
 u32
 acpi_ev_gpe_dispatch (
 	struct acpi_gpe_event_info      *gpe_event_info,
@@ -177,10 +160,14 @@ acpi_status
 acpi_ev_check_for_wake_only_gpe (
 	struct acpi_gpe_event_info      *gpe_event_info);
 
+acpi_status
+acpi_ev_gpe_initialize (
+	void);
+
+
 /*
- * Evregion - Address Space handling
+ * evregion - Address Space handling
  */
-
 acpi_status
 acpi_ev_install_region_handlers (
 	void);
@@ -198,13 +185,6 @@ acpi_ev_address_space_dispatch (
 	void                            *value);
 
 acpi_status
-acpi_ev_install_handler (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
-acpi_status
 acpi_ev_attach_region (
 	union acpi_operand_object       *handler_obj,
 	union acpi_operand_object       *region_obj,
@@ -233,17 +213,10 @@ acpi_ev_execute_reg_method (
 	union acpi_operand_object      *region_obj,
 	u32                             function);
 
-acpi_status
-acpi_ev_reg_run (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
 
 /*
- * Evregini - Region initialization and setup
+ * evregini - Region initialization and setup
  */
-
 acpi_status
 acpi_ev_system_memory_region_setup (
 	acpi_handle                     handle,
@@ -293,9 +266,8 @@ acpi_ev_initialize_region (
 
 
 /*
- * Evsci - SCI (System Control Interrupt) handling/dispatch
+ * evsci - SCI (System Control Interrupt) handling/dispatch
  */
-
 u32 ACPI_SYSTEM_XFACE
 acpi_ev_gpe_xrupt_handler (
 	void                            *context);
diff --git a/include/acpi/acexcep.h b/include/acpi/acexcep.h
--- a/include/acpi/acexcep.h
+++ b/include/acpi/acexcep.h
@@ -48,7 +48,6 @@
 /*
  * Exceptions returned by external ACPI interfaces
  */
-
 #define AE_CODE_ENVIRONMENTAL           0x0000
 #define AE_CODE_PROGRAMMER              0x1000
 #define AE_CODE_ACPI_TABLES             0x2000
@@ -96,8 +95,10 @@
 #define AE_ABORT_METHOD                 (acpi_status) (0x001C | AE_CODE_ENVIRONMENTAL)
 #define AE_SAME_HANDLER                 (acpi_status) (0x001D | AE_CODE_ENVIRONMENTAL)
 #define AE_WAKE_ONLY_GPE                (acpi_status) (0x001E | AE_CODE_ENVIRONMENTAL)
+#define AE_OWNER_ID_LIMIT               (acpi_status) (0x001F | AE_CODE_ENVIRONMENTAL)
+
+#define AE_CODE_ENV_MAX                 0x001F
 
-#define AE_CODE_ENV_MAX                 0x001E
 
 /*
  * Programmer exceptions
@@ -168,6 +169,7 @@
 
 #define AE_CODE_AML_MAX                 0x0021
 
+
 /*
  * Internal exceptions used for control
  */
@@ -188,6 +190,7 @@
 
 #ifdef DEFINE_ACPI_GLOBALS
 
+
 /*
  * String versions of the exception codes above
  * These strings must match the corresponding defines exactly
@@ -224,7 +227,8 @@ char const   *acpi_gbl_exception_names_e
 	"AE_LOGICAL_ADDRESS",
 	"AE_ABORT_METHOD",
 	"AE_SAME_HANDLER",
-	"AE_WAKE_ONLY_GPE"
+	"AE_WAKE_ONLY_GPE",
+	"AE_OWNER_ID_LIMIT"
 };
 
 char const   *acpi_gbl_exception_names_pgm[] =
@@ -304,5 +308,4 @@ char const   *acpi_gbl_exception_names_c
 
 #endif /* ACPI GLOBALS */
 
-
 #endif /* __ACEXCEP_H__ */
diff --git a/include/acpi/acglobal.h b/include/acpi/acglobal.h
--- a/include/acpi/acglobal.h
+++ b/include/acpi/acglobal.h
@@ -146,15 +146,22 @@ ACPI_EXTERN struct acpi_table_header    
 ACPI_EXTERN FACS_DESCRIPTOR            *acpi_gbl_FACS;
 ACPI_EXTERN struct acpi_common_facs             acpi_gbl_common_fACS;
 /*
- * Since there may be multiple SSDTs and PSDTS, a single pointer is not
+ * Since there may be multiple SSDTs and PSDTs, a single pointer is not
  * sufficient; Therefore, there isn't one!
  */
 
 
+/* The root table can be either an RSDT or an XSDT */
+
+ACPI_EXTERN u8                                  acpi_gbl_root_table_type;
+#define     ACPI_TABLE_TYPE_RSDT        'R'
+#define     ACPI_TABLE_TYPE_XSDT        'X'
+
+
 /*
- * Handle both ACPI 1.0 and ACPI 2.0 Integer widths
- * If we are running a method that exists in a 32-bit ACPI table.
- * Use only 32 bits of the Integer for conversion.
+ * Handle both ACPI 1.0 and ACPI 2.0 Integer widths:
+ * If we are executing a method that exists in a 32-bit ACPI table,
+ * use only the lower 32 bits of the (internal) 64-bit Integer.
  */
 ACPI_EXTERN u8                                  acpi_gbl_integer_bit_width;
 ACPI_EXTERN u8                                  acpi_gbl_integer_byte_width;
@@ -180,8 +187,23 @@ ACPI_EXTERN struct acpi_mutex_info      
  *
  ****************************************************************************/
 
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+/* Lists for tracking memory allocations */
+
+ACPI_EXTERN struct acpi_memory_list            *acpi_gbl_global_list;
+ACPI_EXTERN struct acpi_memory_list            *acpi_gbl_ns_node_list;
+#endif
+
+/* Object caches */
+
+ACPI_EXTERN acpi_cache_t                       *acpi_gbl_state_cache;
+ACPI_EXTERN acpi_cache_t                       *acpi_gbl_ps_node_cache;
+ACPI_EXTERN acpi_cache_t                       *acpi_gbl_ps_node_ext_cache;
+ACPI_EXTERN acpi_cache_t                       *acpi_gbl_operand_cache;
+
+/* Global handlers */
 
-ACPI_EXTERN struct acpi_memory_list             acpi_gbl_memory_lists[ACPI_NUM_MEM_LISTS];
 ACPI_EXTERN struct acpi_object_notify_handler   acpi_gbl_device_notify;
 ACPI_EXTERN struct acpi_object_notify_handler   acpi_gbl_system_notify;
 ACPI_EXTERN acpi_exception_handler              acpi_gbl_exception_handler;
@@ -189,14 +211,15 @@ ACPI_EXTERN acpi_init_handler           
 ACPI_EXTERN struct acpi_walk_state             *acpi_gbl_breakpoint_walk;
 ACPI_EXTERN acpi_handle                         acpi_gbl_global_lock_semaphore;
 
+/* Misc */
+
 ACPI_EXTERN u32                                 acpi_gbl_global_lock_thread_count;
 ACPI_EXTERN u32                                 acpi_gbl_original_mode;
 ACPI_EXTERN u32                                 acpi_gbl_rsdp_original_location;
 ACPI_EXTERN u32                                 acpi_gbl_ns_lookup_count;
 ACPI_EXTERN u32                                 acpi_gbl_ps_find_count;
+ACPI_EXTERN u32                                 acpi_gbl_owner_id_mask;
 ACPI_EXTERN u16                                 acpi_gbl_pm1_enable_register_save;
-ACPI_EXTERN u16                                 acpi_gbl_next_table_owner_id;
-ACPI_EXTERN u16                                 acpi_gbl_next_method_owner_id;
 ACPI_EXTERN u16                                 acpi_gbl_global_lock_handle;
 ACPI_EXTERN u8                                  acpi_gbl_debugger_configuration;
 ACPI_EXTERN u8                                  acpi_gbl_global_lock_acquired;
@@ -246,6 +269,7 @@ ACPI_EXTERN acpi_size                   
 ACPI_EXTERN u32                                 acpi_gbl_deepest_nesting;
 #endif
 
+
 /*****************************************************************************
  *
  * Interpreter globals
@@ -268,6 +292,7 @@ ACPI_EXTERN u8                          
 
 ACPI_EXTERN union acpi_parse_object            *acpi_gbl_parsed_namespace_root;
 
+
 /*****************************************************************************
  *
  * Hardware globals
@@ -298,7 +323,6 @@ ACPI_EXTERN acpi_handle                 
  *
  ****************************************************************************/
 
-
 ACPI_EXTERN u8                                  acpi_gbl_db_output_flags;
 
 #ifdef ACPI_DISASSEMBLER
@@ -353,5 +377,4 @@ ACPI_EXTERN u32                         
 
 #endif /* ACPI_DEBUGGER */
 
-
 #endif /* __ACGLOBAL_H__ */
diff --git a/include/acpi/achware.h b/include/acpi/achware.h
--- a/include/acpi/achware.h
+++ b/include/acpi/achware.h
@@ -46,22 +46,26 @@
 
 
 /* PM Timer ticks per second (HZ) */
+
 #define PM_TIMER_FREQUENCY  3579545
 
+/* Values for the _SST reserved method */
 
-/* Prototypes */
+#define ACPI_SST_INDICATOR_OFF  0
+#define ACPI_SST_WORKING        1
+#define ACPI_SST_WAKING         2
+#define ACPI_SST_SLEEPING       3
+#define ACPI_SST_SLEEP_CONTEXT  4
 
 
-acpi_status
-acpi_hw_initialize (
-	void);
+/* Prototypes */
 
-acpi_status
-acpi_hw_shutdown (
-	void);
 
+/*
+ * hwacpi - high level functions
+ */
 acpi_status
-acpi_hw_initialize_system_info (
+acpi_hw_initialize (
 	void);
 
 acpi_status
@@ -72,12 +76,10 @@ u32
 acpi_hw_get_mode (
 	void);
 
-u32
-acpi_hw_get_mode_capabilities (
-	void);
-
-/* Register I/O Prototypes */
 
+/*
+ * hwregs - ACPI Register I/O
+ */
 struct acpi_bit_register_info *
 acpi_hw_get_bit_register_info (
 	u32                             register_id);
@@ -111,8 +113,9 @@ acpi_hw_clear_acpi_status (
 	u32                             flags);
 
 
-/* GPE support */
-
+/*
+ * hwgpe - GPE support
+ */
 acpi_status
 acpi_hw_write_gpe_enable_reg (
 	struct acpi_gpe_event_info      *gpe_event_info);
@@ -131,39 +134,35 @@ acpi_hw_clear_gpe_block (
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_hw_get_gpe_status (
 	struct acpi_gpe_event_info      *gpe_event_info,
 	acpi_event_status               *event_status);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 acpi_status
 acpi_hw_disable_all_gpes (
-	u32                             flags);
+	void);
 
 acpi_status
 acpi_hw_enable_all_runtime_gpes (
-	u32                             flags);
+	void);
 
 acpi_status
 acpi_hw_enable_all_wakeup_gpes (
-	u32                             flags);
+	void);
 
 acpi_status
 acpi_hw_enable_runtime_gpe_block (
 	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
 	struct acpi_gpe_block_info      *gpe_block);
 
-acpi_status
-acpi_hw_enable_wakeup_gpe_block (
-	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
-	struct acpi_gpe_block_info      *gpe_block);
 
-
-/* ACPI Timer prototypes */
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
+/*
+ * hwtimer - ACPI Timer prototypes
+ */
 acpi_status
 acpi_get_timer_resolution (
 	u32                             *resolution);
@@ -177,6 +176,7 @@ acpi_get_timer_duration (
 	u32                             start_ticks,
 	u32                             end_ticks,
 	u32                             *time_elapsed);
-#endif  /*  ACPI_FUTURE_USAGE  */
+#endif	/* ACPI_FUTURE_USAGE */
+
 
 #endif /* __ACHWARE_H__ */
diff --git a/include/acpi/acinterp.h b/include/acpi/acinterp.h
--- a/include/acpi/acinterp.h
+++ b/include/acpi/acinterp.h
@@ -48,37 +48,9 @@
 #define ACPI_WALK_OPERANDS       (&(walk_state->operands [walk_state->num_operands -1]))
 
 
-acpi_status
-acpi_ex_resolve_operands (
-	u16                             opcode,
-	union acpi_operand_object       **stack_ptr,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ex_check_object_type (
-	acpi_object_type                type_needed,
-	acpi_object_type                this_type,
-	void                            *object);
-
-/*
- * exxface - External interpreter interfaces
- */
-
-acpi_status
-acpi_ex_load_table (
-	acpi_table_type                 table_id);
-
-acpi_status
-acpi_ex_execute_method (
-	struct acpi_namespace_node      *method_node,
-	union acpi_operand_object       **params,
-	union acpi_operand_object       **return_obj_desc);
-
-
 /*
  * exconvrt - object conversion
  */
-
 acpi_status
 acpi_ex_convert_to_integer (
 	union acpi_operand_object       *obj_desc,
@@ -110,17 +82,10 @@ acpi_ex_convert_to_target_type (
 	union acpi_operand_object       **result_desc,
 	struct acpi_walk_state          *walk_state);
 
-u32
-acpi_ex_convert_to_ascii (
-	acpi_integer                    integer,
-	u16                             base,
-	u8                              *string,
-	u8                              max_length);
 
 /*
  * exfield - ACPI AML (p-code) execution - field manipulation
  */
-
 acpi_status
 acpi_ex_common_buffer_setup (
 	union acpi_operand_object       *obj_desc,
@@ -128,42 +93,6 @@ acpi_ex_common_buffer_setup (
 	u32                             *datum_count);
 
 acpi_status
-acpi_ex_extract_from_field (
-	union acpi_operand_object       *obj_desc,
-	void                            *buffer,
-	u32                             buffer_length);
-
-acpi_status
-acpi_ex_insert_into_field (
-	union acpi_operand_object       *obj_desc,
-	void                            *buffer,
-	u32                             buffer_length);
-
-acpi_status
-acpi_ex_setup_region (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset);
-
-acpi_status
-acpi_ex_access_region (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset,
-	acpi_integer                    *value,
-	u32                             read_write);
-
-u8
-acpi_ex_register_overflow (
-	union acpi_operand_object       *obj_desc,
-	acpi_integer                    value);
-
-acpi_status
-acpi_ex_field_datum_io (
-	union acpi_operand_object       *obj_desc,
-	u32                             field_datum_byte_offset,
-	acpi_integer                    *value,
-	u32                             read_write);
-
-acpi_status
 acpi_ex_write_with_update_rule (
 	union acpi_operand_object       *obj_desc,
 	acpi_integer                    mask,
@@ -198,28 +127,33 @@ acpi_ex_write_data_to_field (
 	union acpi_operand_object       *obj_desc,
 	union acpi_operand_object       **result_desc);
 
+
 /*
- * exmisc - ACPI AML (p-code) execution - specific opcodes
+ * exfldio - low level field I/O
  */
-
 acpi_status
-acpi_ex_opcode_3A_0T_0R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_extract_from_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
 
 acpi_status
-acpi_ex_opcode_3A_1T_1R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_insert_into_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
 
 acpi_status
-acpi_ex_opcode_6A_0T_1R (
-	struct acpi_walk_state          *walk_state);
+acpi_ex_access_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
 
-u8
-acpi_ex_do_match (
-	u32                             match_op,
-	union acpi_operand_object       *package_obj,
-	union acpi_operand_object       *match_obj);
 
+/*
+ * exmisc - misc support routines
+ */
 acpi_status
 acpi_ex_get_object_reference (
 	union acpi_operand_object       *obj_desc,
@@ -227,13 +161,6 @@ acpi_ex_get_object_reference (
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
-acpi_ex_resolve_multiple (
-	struct acpi_walk_state          *walk_state,
-	union acpi_operand_object       *operand,
-	acpi_object_type                *return_type,
-	union acpi_operand_object       **return_desc);
-
-acpi_status
 acpi_ex_concat_template (
 	union acpi_operand_object       *obj_desc,
 	union acpi_operand_object       *obj_desc2,
@@ -308,13 +235,6 @@ acpi_ex_create_method (
 /*
  * exconfig - dynamic table load/unload
  */
-
-acpi_status
-acpi_ex_add_table (
-	struct acpi_table_header        *table,
-	struct acpi_namespace_node      *parent_node,
-	union acpi_operand_object       **ddb_handle);
-
 acpi_status
 acpi_ex_load_op (
 	union acpi_operand_object       *obj_desc,
@@ -334,7 +254,6 @@ acpi_ex_unload_table (
 /*
  * exmutex - mutex support
  */
-
 acpi_status
 acpi_ex_acquire_mutex (
 	union acpi_operand_object       *time_desc,
@@ -354,15 +273,10 @@ void
 acpi_ex_unlink_mutex (
 	union acpi_operand_object       *obj_desc);
 
-void
-acpi_ex_link_mutex (
-	union acpi_operand_object       *obj_desc,
-	struct acpi_thread_state        *thread);
 
 /*
- * exprep - ACPI AML (p-code) execution - prep utilities
+ * exprep - ACPI AML execution - prep utilities
  */
-
 acpi_status
 acpi_ex_prep_common_field_object (
 	union acpi_operand_object       *obj_desc,
@@ -375,10 +289,10 @@ acpi_status
 acpi_ex_prep_field_value (
 	struct acpi_create_field_info   *info);
 
+
 /*
  * exsystem - Interface to OS services
  */
-
 acpi_status
 acpi_ex_system_do_notify_op (
 	union acpi_operand_object       *value,
@@ -421,9 +335,8 @@ acpi_ex_system_wait_semaphore (
 
 
 /*
- * exmonadic - ACPI AML (p-code) execution, monadic operators
+ * exoparg1 - ACPI AML execution, 1 operand
  */
-
 acpi_status
 acpi_ex_opcode_0A_0T_1R (
 	struct acpi_walk_state          *walk_state);
@@ -445,9 +358,8 @@ acpi_ex_opcode_1A_1T_0R (
 	struct acpi_walk_state          *walk_state);
 
 /*
- * exdyadic - ACPI AML (p-code) execution, dyadic operators
+ * exoparg2 - ACPI AML execution, 2 operands
  */
-
 acpi_status
 acpi_ex_opcode_2A_0T_0R (
 	struct acpi_walk_state          *walk_state);
@@ -466,21 +378,56 @@ acpi_ex_opcode_2A_2T_1R (
 
 
 /*
- * exresolv  - Object resolution and get value functions
+ * exoparg3 - ACPI AML execution, 3 operands
+ */
+acpi_status
+acpi_ex_opcode_3A_0T_0R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_3A_1T_1R (
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exoparg6 - ACPI AML execution, 6 operands
  */
+acpi_status
+acpi_ex_opcode_6A_0T_1R (
+	struct acpi_walk_state          *walk_state);
+
 
+/*
+ * exresolv - Object resolution and get value functions
+ */
 acpi_status
 acpi_ex_resolve_to_value (
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
+acpi_ex_resolve_multiple (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *operand,
+	acpi_object_type                *return_type,
+	union acpi_operand_object       **return_desc);
+
+
+/*
+ * exresnte - resolve namespace node
+ */
+acpi_status
 acpi_ex_resolve_node_to_value (
 	struct acpi_namespace_node      **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
+
+/*
+ * exresop - resolve operand to value
+ */
 acpi_status
-acpi_ex_resolve_object_to_value (
+acpi_ex_resolve_operands (
+	u16                             opcode,
 	union acpi_operand_object       **stack_ptr,
 	struct acpi_walk_state          *walk_state);
 
@@ -488,7 +435,6 @@ acpi_ex_resolve_object_to_value (
 /*
  * exdump - Interpreter debug output routines
  */
-
 void
 acpi_ex_dump_operand (
 	union acpi_operand_object       *obj_desc,
@@ -504,7 +450,7 @@ acpi_ex_dump_operands (
 	char                            *module_name,
 	u32                             line_number);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ex_dump_object_descriptor (
 	union acpi_operand_object       *object,
@@ -514,46 +460,12 @@ void
 acpi_ex_dump_node (
 	struct acpi_namespace_node      *node,
 	u32                             flags);
+#endif	/* ACPI_FUTURE_USAGE */
 
-void
-acpi_ex_out_string (
-	char                            *title,
-	char                            *value);
-
-void
-acpi_ex_out_pointer (
-	char                            *title,
-	void                            *value);
-
-void
-acpi_ex_out_integer (
-	char                            *title,
-	u32                             value);
-
-void
-acpi_ex_out_address (
-	char                            *title,
-	acpi_physical_address           value);
-#endif  /*  ACPI_FUTURE_USAGE  */
 
 /*
- * exnames - interpreter/scanner name load/execute
+ * exnames - AML namestring support
  */
-
-char *
-acpi_ex_allocate_name_string (
-	u32                             prefix_count,
-	u32                             num_name_segs);
-
-u32
-acpi_ex_good_char (
-	u32                             character);
-
-acpi_status
-acpi_ex_name_segment (
-	u8                              **in_aml_address,
-	char                            *name_string);
-
 acpi_status
 acpi_ex_get_name_string (
 	acpi_object_type                data_type,
@@ -561,16 +473,10 @@ acpi_ex_get_name_string (
 	char                            **out_name_string,
 	u32                             *out_name_length);
 
-acpi_status
-acpi_ex_do_name (
-	acpi_object_type                data_type,
-	acpi_interpreter_mode           load_exec_mode);
-
 
 /*
  * exstore - Object store support
  */
-
 acpi_status
 acpi_ex_store (
 	union acpi_operand_object       *val_desc,
@@ -578,12 +484,6 @@ acpi_ex_store (
 	struct acpi_walk_state          *walk_state);
 
 acpi_status
-acpi_ex_store_object_to_index (
-	union acpi_operand_object       *val_desc,
-	union acpi_operand_object       *dest_desc,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
 acpi_ex_store_object_to_node (
 	union acpi_operand_object       *source_desc,
 	struct acpi_namespace_node      *node,
@@ -593,10 +493,10 @@ acpi_ex_store_object_to_node (
 #define ACPI_IMPLICIT_CONVERSION        TRUE
 #define ACPI_NO_IMPLICIT_CONVERSION     FALSE
 
+
 /*
- * exstoren
+ * exstoren - resolve/store object
  */
-
 acpi_status
 acpi_ex_resolve_object (
 	union acpi_operand_object       **source_desc_ptr,
@@ -612,9 +512,8 @@ acpi_ex_store_object_to_object (
 
 
 /*
- * excopy - object copy
+ * exstorob - store object - buffer/string
  */
-
 acpi_status
 acpi_ex_store_buffer_to_buffer (
 	union acpi_operand_object       *source_desc,
@@ -625,6 +524,10 @@ acpi_ex_store_string_to_string (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *target_desc);
 
+
+/*
+ * excopy - object copy
+ */
 acpi_status
 acpi_ex_copy_integer_to_index_field (
 	union acpi_operand_object       *source_desc,
@@ -645,10 +548,10 @@ acpi_ex_copy_integer_to_buffer_field (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       *target_desc);
 
+
 /*
  * exutils - interpreter/scanner utilities
  */
-
 acpi_status
 acpi_ex_enter_interpreter (
 	void);
@@ -669,11 +572,6 @@ void
 acpi_ex_release_global_lock (
 	u8                              locked);
 
-u32
-acpi_ex_digits_needed (
-	acpi_integer                    value,
-	u32                             base);
-
 void
 acpi_ex_eisa_id_to_string (
 	u32                             numeric_id,
@@ -688,7 +586,6 @@ acpi_ex_unsigned_integer_to_string (
 /*
  * exregion - default op_region handlers
  */
-
 acpi_status
 acpi_ex_system_memory_space_handler (
 	u32                             function,
diff --git a/include/acpi/aclocal.h b/include/acpi/aclocal.h
--- a/include/acpi/aclocal.h
+++ b/include/acpi/aclocal.h
@@ -56,6 +56,13 @@ typedef u32                             
 #define AML_NUM_OPCODES                 0x7F
 
 
+/* Forward declarations */
+
+struct acpi_walk_state        ;
+struct acpi_obj_mutex;
+union acpi_parse_object        ;
+
+
 /*****************************************************************************
  *
  * Mutex typedefs and structs
@@ -72,7 +79,6 @@ typedef u32                             
  *
  * NOTE: any changes here must be reflected in the acpi_gbl_mutex_names table also!
  */
-
 #define ACPI_MTX_EXECUTE                0
 #define ACPI_MTX_INTERPRETER            1
 #define ACPI_MTX_PARSER                 2
@@ -117,19 +123,24 @@ static char                         *acp
 #endif
 
 
+/* Owner IDs are used to track namespace nodes for selective deletion */
+
+typedef u8                                      acpi_owner_id;
+#define ACPI_OWNER_ID_MAX               0xFF
+
+/* This Thread ID means that the mutex is not in use (unlocked) */
+
+#define ACPI_MUTEX_NOT_ACQUIRED         (u32) -1
+
 /* Table for the global mutexes */
 
 struct acpi_mutex_info
 {
 	acpi_mutex                          mutex;
 	u32                                 use_count;
-	u32                                 owner_id;
+	u32                                 thread_id;
 };
 
-/* This owner ID means that the mutex is not in use (unlocked) */
-
-#define ACPI_MUTEX_NOT_ACQUIRED         (u32) (-1)
-
 
 /* Lock flag parameter for various interfaces */
 
@@ -137,13 +148,6 @@ struct acpi_mutex_info
 #define ACPI_MTX_LOCK                   1
 
 
-typedef u16                                     acpi_owner_id;
-#define ACPI_OWNER_TYPE_TABLE           0x0
-#define ACPI_OWNER_TYPE_METHOD          0x1
-#define ACPI_FIRST_METHOD_ID            0x0001
-#define ACPI_FIRST_TABLE_ID             0xF000
-
-
 /* Field access granularities */
 
 #define ACPI_FIELD_BYTE_GRANULARITY     1
@@ -151,13 +155,13 @@ typedef u16                             
 #define ACPI_FIELD_DWORD_GRANULARITY    4
 #define ACPI_FIELD_QWORD_GRANULARITY    8
 
+
 /*****************************************************************************
  *
  * Namespace typedefs and structs
  *
  ****************************************************************************/
 
-
 /* Operational modes of the AML interpreter/scanner */
 
 typedef enum
@@ -176,7 +180,6 @@ typedef enum
  * data_type is used to differentiate between internal descriptors, and MUST
  * be the first byte in this structure.
  */
-
 union acpi_name_union
 {
 	u32                                 integer;
@@ -187,13 +190,20 @@ struct acpi_namespace_node
 {
 	u8                                  descriptor;     /* Used to differentiate object descriptor types */
 	u8                                  type;           /* Type associated with this name */
-	u16                                 owner_id;
+	u16                                 reference_count; /* Current count of references and children */
 	union acpi_name_union               name;           /* ACPI Name, always 4 chars per ACPI spec */
 	union acpi_operand_object           *object;        /* Pointer to attached ACPI object (optional) */
 	struct acpi_namespace_node          *child;         /* First child */
 	struct acpi_namespace_node          *peer;          /* Next peer*/
-	u16                                 reference_count; /* Current count of references and children */
+	u8                                  owner_id;       /* Who created this node */
 	u8                                  flags;
+
+	/* Fields used by the ASL compiler only */
+
+#ifdef ACPI_ASL_COMPILER
+	u32                                 value;
+	union acpi_parse_object             *op;
+#endif
 };
 
 
@@ -224,7 +234,7 @@ struct acpi_table_desc
 	u64                             physical_address;
 	u32                             aml_length;
 	acpi_size                       length;
-	acpi_owner_id                   table_id;
+	acpi_owner_id                   owner_id;
 	u8                              type;
 	u8                              allocation;
 	u8                              loaded_into_namespace;
@@ -367,7 +377,7 @@ struct acpi_gpe_xrupt_info
 	struct acpi_gpe_xrupt_info              *previous;
 	struct acpi_gpe_xrupt_info              *next;
 	struct acpi_gpe_block_info              *gpe_block_list_head; /* List of GPE blocks for this xrupt */
-	u32                                     interrupt_level;    /* System interrupt level */
+	u32                                     interrupt_number;   /* System interrupt number */
 };
 
 
@@ -415,7 +425,6 @@ struct acpi_field_info
  *
  ****************************************************************************/
 
-
 #define ACPI_CONTROL_NORMAL                  0xC0
 #define ACPI_CONTROL_CONDITIONAL_EXECUTING   0xC1
 #define ACPI_CONTROL_PREDICATE_EXECUTING     0xC2
@@ -423,12 +432,6 @@ struct acpi_field_info
 #define ACPI_CONTROL_PREDICATE_TRUE          0xC4
 
 
-/* Forward declarations */
-struct acpi_walk_state        ;
-struct acpi_obj_mutex;
-union acpi_parse_object        ;
-
-
 #define ACPI_STATE_COMMON                  /* Two 32-bit fields and a pointer */\
 	u8                                  data_type;          /* To differentiate various internal objs */\
 	u8                                  flags;      \
@@ -601,7 +604,6 @@ struct acpi_opcode_info
 	u8                                  type;           /* Opcode type */
 };
 
-
 union acpi_parse_value
 {
 	acpi_integer                        integer;        /* Integer constant (Up to 64 bits) */
@@ -613,7 +615,6 @@ union acpi_parse_value
 	union acpi_parse_object             *arg;           /* arguments and contained ops */
 };
 
-
 #define ACPI_PARSE_COMMON \
 	u8                                  data_type;      /* To differentiate various internal objs */\
 	u8                                  flags;          /* Type of Op */\
@@ -691,7 +692,6 @@ struct acpi_parse_obj_asl
 	char                                parse_op_name[12];
 };
 
-
 union acpi_parse_object
 {
 	struct acpi_parse_obj_common        common;
@@ -742,6 +742,7 @@ struct acpi_parse_state
  ****************************************************************************/
 
 #define PCI_ROOT_HID_STRING         "PNP0A03"
+#define PCI_EXPRESS_ROOT_HID_STRING "PNP0A08"
 
 struct acpi_bit_register_info
 {
@@ -834,7 +835,6 @@ struct acpi_bit_register_info
  *
  ****************************************************************************/
 
-
 /* resource_type values */
 
 #define ACPI_RESOURCE_TYPE_MEMORY_RANGE         0
@@ -921,14 +921,6 @@ struct acpi_integrity_info
  *
  ****************************************************************************/
 
-struct acpi_debug_print_info
-{
-	u32                             component_id;
-	char                            *proc_name;
-	char                            *module_name;
-};
-
-
 /* Entry for a memory allocation (debug only) */
 
 #define ACPI_MEM_MALLOC                      0
@@ -958,24 +950,18 @@ struct acpi_debug_mem_block
 
 #define ACPI_MEM_LIST_GLOBAL            0
 #define ACPI_MEM_LIST_NSNODE            1
-
-#define ACPI_MEM_LIST_FIRST_CACHE_LIST  2
-#define ACPI_MEM_LIST_STATE             2
-#define ACPI_MEM_LIST_PSNODE            3
-#define ACPI_MEM_LIST_PSNODE_EXT        4
-#define ACPI_MEM_LIST_OPERAND           5
-#define ACPI_MEM_LIST_WALK              6
-#define ACPI_MEM_LIST_MAX               6
-#define ACPI_NUM_MEM_LISTS              7
+#define ACPI_MEM_LIST_MAX               1
+#define ACPI_NUM_MEM_LISTS              2
 
 
 struct acpi_memory_list
 {
+	char                                *list_name;
 	void                                *list_head;
-	u16                                 link_offset;
-	u16                                 max_cache_depth;
-	u16                                 cache_depth;
 	u16                                 object_size;
+	u16                                 max_depth;
+	u16                                 current_depth;
+	u16                                 link_offset;
 
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 
@@ -984,11 +970,9 @@ struct acpi_memory_list
 	u32                                 total_allocated;
 	u32                                 total_freed;
 	u32                                 current_total_size;
-	u32                                 cache_requests;
-	u32                                 cache_hits;
-	char                                *list_name;
+	u32                                 requests;
+	u32                                 hits;
 #endif
 };
 
-
 #endif /* __ACLOCAL_H__ */
diff --git a/include/acpi/acmacros.h b/include/acpi/acmacros.h
--- a/include/acpi/acmacros.h
+++ b/include/acpi/acmacros.h
@@ -437,21 +437,22 @@
 #define ACPI_PARAM_LIST(pl)                 pl
 
 /*
- * Error reporting.  These versions add callers module and line#.  Since
- * _THIS_MODULE gets compiled out when ACPI_DEBUG_OUTPUT isn't defined, only
- * use it in debug mode.
+ * Error reporting.  These versions add callers module and line#.
+ *
+ * Since _acpi_module_name gets compiled out when ACPI_DEBUG_OUTPUT
+ * isn't defined, only use it in debug mode.
  */
 #ifdef ACPI_DEBUG_OUTPUT
 
-#define ACPI_REPORT_INFO(fp)                {acpi_ut_report_info(_THIS_MODULE,__LINE__,_COMPONENT); \
+#define ACPI_REPORT_INFO(fp)                {acpi_ut_report_info(_acpi_module_name,__LINE__,_COMPONENT); \
 												acpi_os_printf ACPI_PARAM_LIST(fp);}
-#define ACPI_REPORT_ERROR(fp)               {acpi_ut_report_error(_THIS_MODULE,__LINE__,_COMPONENT); \
+#define ACPI_REPORT_ERROR(fp)               {acpi_ut_report_error(_acpi_module_name,__LINE__,_COMPONENT); \
 												acpi_os_printf ACPI_PARAM_LIST(fp);}
-#define ACPI_REPORT_WARNING(fp)             {acpi_ut_report_warning(_THIS_MODULE,__LINE__,_COMPONENT); \
+#define ACPI_REPORT_WARNING(fp)             {acpi_ut_report_warning(_acpi_module_name,__LINE__,_COMPONENT); \
 												acpi_os_printf ACPI_PARAM_LIST(fp);}
-#define ACPI_REPORT_NSERROR(s,e)            acpi_ns_report_error(_THIS_MODULE,__LINE__,_COMPONENT, s, e);
+#define ACPI_REPORT_NSERROR(s,e)            acpi_ns_report_error(_acpi_module_name,__LINE__,_COMPONENT, s, e);
 
-#define ACPI_REPORT_METHOD_ERROR(s,n,p,e)   acpi_ns_report_method_error(_THIS_MODULE,__LINE__,_COMPONENT, s, n, p, e);
+#define ACPI_REPORT_METHOD_ERROR(s,n,p,e)   acpi_ns_report_method_error(_acpi_module_name,__LINE__,_COMPONENT, s, n, p, e);
 
 #else
 
@@ -480,36 +481,58 @@
  * Debug macros that are conditionally compiled
  */
 #ifdef ACPI_DEBUG_OUTPUT
+#define ACPI_MODULE_NAME(name)          static char ACPI_UNUSED_VAR *_acpi_module_name = name;
 
-#define ACPI_MODULE_NAME(name)               static char ACPI_UNUSED_VAR *_THIS_MODULE = name;
+/*
+ * Common parameters used for debug output functions:
+ * line number, function name, module(file) name, component ID
+ */
+#define ACPI_DEBUG_PARAMETERS           __LINE__, ACPI_GET_FUNCTION_NAME, _acpi_module_name, _COMPONENT
+
+/*
+ * Function entry tracing
+ */
 
 /*
- * Function entry tracing.
- * The first parameter should be the procedure name as a quoted string.  This is declared
- * as a local string ("_proc_name) so that it can be also used by the function exit macros below.
- */
-#define ACPI_FUNCTION_NAME(a)               struct acpi_debug_print_info _debug_info; \
-												_debug_info.component_id = _COMPONENT; \
-												_debug_info.proc_name  = a; \
-												_debug_info.module_name = _THIS_MODULE;
-
-#define ACPI_FUNCTION_TRACE(a)              ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace(__LINE__,&_debug_info)
-#define ACPI_FUNCTION_TRACE_PTR(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_ptr(__LINE__,&_debug_info,(void *)b)
-#define ACPI_FUNCTION_TRACE_U32(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_u32(__LINE__,&_debug_info,(u32)b)
-#define ACPI_FUNCTION_TRACE_STR(a,b)        ACPI_FUNCTION_NAME(a) \
-												acpi_ut_trace_str(__LINE__,&_debug_info,(char *)b)
+ * If ACPI_GET_FUNCTION_NAME was not defined in the compiler-dependent header,
+ * define it now. This is the case where there the compiler does not support
+ * a __FUNCTION__ macro or equivalent. We save the function name on the
+ * local stack.
+ */
+#ifndef ACPI_GET_FUNCTION_NAME
+#define ACPI_GET_FUNCTION_NAME          _acpi_function_name
+/*
+ * The Name parameter should be the procedure name as a quoted string.
+ * This is declared as a local string ("my_function_name") so that it can
+ * be also used by the function exit macros below.
+ * Note: (const char) is used to be compatible with the debug interfaces
+ * and macros such as __FUNCTION__.
+ */
+#define ACPI_FUNCTION_NAME(name)        const char *_acpi_function_name = name;
+
+#else
+/* Compiler supports __FUNCTION__ (or equivalent) -- Ignore this macro */
 
-#define ACPI_FUNCTION_ENTRY()               acpi_ut_track_stack_ptr()
+#define ACPI_FUNCTION_NAME(name)
+#endif
+
+#define ACPI_FUNCTION_TRACE(a)          ACPI_FUNCTION_NAME(a) \
+											acpi_ut_trace(ACPI_DEBUG_PARAMETERS)
+#define ACPI_FUNCTION_TRACE_PTR(a,b)    ACPI_FUNCTION_NAME(a) \
+											acpi_ut_trace_ptr(ACPI_DEBUG_PARAMETERS,(void *)b)
+#define ACPI_FUNCTION_TRACE_U32(a,b)    ACPI_FUNCTION_NAME(a) \
+											acpi_ut_trace_u32(ACPI_DEBUG_PARAMETERS,(u32)b)
+#define ACPI_FUNCTION_TRACE_STR(a,b)    ACPI_FUNCTION_NAME(a) \
+											acpi_ut_trace_str(ACPI_DEBUG_PARAMETERS,(char *)b)
+
+#define ACPI_FUNCTION_ENTRY()           acpi_ut_track_stack_ptr()
 
 /*
  * Function exit tracing.
  * WARNING: These macros include a return statement.  This is usually considered
  * bad form, but having a separate exit macro is very ugly and difficult to maintain.
  * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
- * so that "_proc_name" is defined.
+ * so that "_acpi_function_name" is defined.
  */
 #ifdef ACPI_USE_DO_WHILE_0
 #define ACPI_DO_WHILE0(a)               do a while(0)
@@ -517,10 +540,10 @@
 #define ACPI_DO_WHILE0(a)               a
 #endif
 
-#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(__LINE__,&_debug_info);return;})
-#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(__LINE__,&_debug_info,(s));return((s));})
-#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(__LINE__,&_debug_info,(acpi_integer)(s));return((s));})
-#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(__LINE__,&_debug_info,(u8 *)(s));return((s));})
+#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(ACPI_DEBUG_PARAMETERS);return;})
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(ACPI_DEBUG_PARAMETERS,(s));return((s));})
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(ACPI_DEBUG_PARAMETERS,(acpi_integer)(s));return((s));})
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(ACPI_DEBUG_PARAMETERS,(u8 *)(s));return((s));})
 
 /* Conditional execution */
 
@@ -535,15 +558,10 @@
 /* Stack and buffer dumping */
 
 #define ACPI_DUMP_STACK_ENTRY(a)        acpi_ex_dump_operand((a),0)
-#define ACPI_DUMP_OPERANDS(a,b,c,d,e)   acpi_ex_dump_operands(a,b,c,d,e,_THIS_MODULE,__LINE__)
+#define ACPI_DUMP_OPERANDS(a,b,c,d,e)   acpi_ex_dump_operands(a,b,c,d,e,_acpi_module_name,__LINE__)
 
 
 #define ACPI_DUMP_ENTRY(a,b)            acpi_ns_dump_entry (a,b)
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_DUMP_TABLES(a,b)           acpi_ns_dump_tables(a,b)
-#endif
-
 #define ACPI_DUMP_PATHNAME(a,b,c,d)     acpi_ns_dump_pathname(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)      acpi_rs_dump_resource_list(a)
 #define ACPI_DUMP_BUFFER(a,b)           acpi_ut_dump_buffer((u8 *)a,b,DB_BYTE_DISPLAY,_COMPONENT)
@@ -577,7 +595,7 @@
  * leaving no executable debug code!
  */
 #define ACPI_MODULE_NAME(name)
-#define _THIS_MODULE ""
+#define _acpi_module_name ""
 
 #define ACPI_DEBUG_EXEC(a)
 #define ACPI_NORMAL_EXEC(a)             a;
@@ -596,11 +614,6 @@
 #define ACPI_DUMP_STACK_ENTRY(a)
 #define ACPI_DUMP_OPERANDS(a,b,c,d,e)
 #define ACPI_DUMP_ENTRY(a,b)
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_DUMP_TABLES(a,b)
-#endif
-
 #define ACPI_DUMP_PATHNAME(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)
 #define ACPI_DUMP_BUFFER(a,b)
@@ -658,19 +671,18 @@
 
 /* Memory allocation */
 
-#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate((acpi_size)(a),_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate((acpi_size)(a), _COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate((acpi_size)(a),_COMPONENT,_acpi_module_name,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate((acpi_size)(a), _COMPONENT,_acpi_module_name,__LINE__)
 #define ACPI_MEM_FREE(a)                acpi_os_free(a)
 #define ACPI_MEM_TRACKING(a)
 
-
 #else
 
 /* Memory allocation */
 
-#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate_and_track((acpi_size)(a),_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate_and_track((acpi_size)(a), _COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_FREE(a)                acpi_ut_free_and_track(a,_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate_and_track((acpi_size)(a),_COMPONENT,_acpi_module_name,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate_and_track((acpi_size)(a), _COMPONENT,_acpi_module_name,__LINE__)
+#define ACPI_MEM_FREE(a)                acpi_ut_free_and_track(a,_COMPONENT,_acpi_module_name,__LINE__)
 #define ACPI_MEM_TRACKING(a)            a
 
 #endif /* ACPI_DBG_TRACK_ALLOCATIONS */
diff --git a/include/acpi/acnames.h b/include/acpi/acnames.h
new file mode 100644
--- /dev/null
+++ b/include/acpi/acnames.h
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *
+ * Name: acnames.h - Global names and strings
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNAMES_H__
+#define __ACNAMES_H__
+
+/* Method names - these methods can appear anywhere in the namespace */
+
+#define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__CID        "_CID"
+#define METHOD_NAME__UID        "_UID"
+#define METHOD_NAME__ADR        "_ADR"
+#define METHOD_NAME__INI        "_INI"
+#define METHOD_NAME__STA        "_STA"
+#define METHOD_NAME__REG        "_REG"
+#define METHOD_NAME__SEG        "_SEG"
+#define METHOD_NAME__BBN        "_BBN"
+#define METHOD_NAME__PRT        "_PRT"
+#define METHOD_NAME__CRS        "_CRS"
+#define METHOD_NAME__PRS        "_PRS"
+#define METHOD_NAME__PRW        "_PRW"
+#define METHOD_NAME__SRS        "_SRS"
+
+/* Method names - these methods must appear at the namespace root */
+
+#define METHOD_NAME__BFS        "\\_BFS"
+#define METHOD_NAME__GTS        "\\_GTS"
+#define METHOD_NAME__PTS        "\\_PTS"
+#define METHOD_NAME__SST        "\\_SI._SST"
+#define METHOD_NAME__WAK        "\\_WAK"
+
+/* Definitions of the predefined namespace names  */
+
+#define ACPI_UNKNOWN_NAME       (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
+#define ACPI_ROOT_NAME          (u32) 0x5F5F5F5C     /* Root name is     "\___" */
+#define ACPI_SYS_BUS_NAME       (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
+
+#define ACPI_NS_ROOT_PATH       "\\"
+#define ACPI_NS_SYSTEM_BUS      "_SB_"
+
+/*! [Begin] no source code translation (not handled by acpisrc) */
+#define ACPI_FUNCTION_PREFIX1   'ipcA'
+#define ACPI_FUNCTION_PREFIX2   'ipca'
+/*! [End] no source code translation !*/
+
+
+#endif  /* __ACNAMES_H__  */
+
+
diff --git a/include/acpi/acnamesp.h b/include/acpi/acnamesp.h
--- a/include/acpi/acnamesp.h
+++ b/include/acpi/acnamesp.h
@@ -57,17 +57,6 @@
 #define ACPI_NS_NEWSCOPE            1   /* a definition of this type opens a name scope */
 #define ACPI_NS_LOCAL               2   /* suppress search of enclosing scopes */
 
-
-/* Definitions of the predefined namespace names  */
-
-#define ACPI_UNKNOWN_NAME           (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
-#define ACPI_ROOT_NAME              (u32) 0x5F5F5F5C     /* Root name is     "\___" */
-#define ACPI_SYS_BUS_NAME           (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
-
-#define ACPI_NS_ROOT_PATH           "\\"
-#define ACPI_NS_SYSTEM_BUS          "_SB_"
-
-
 /* Flags for acpi_ns_lookup, acpi_ns_search_and_enter */
 
 #define ACPI_NS_NO_UPSEARCH         0
@@ -80,10 +69,9 @@
 #define ACPI_NS_WALK_NO_UNLOCK      FALSE
 
 
-acpi_status
-acpi_ns_load_namespace (
-	void);
-
+/*
+ * nsinit - Namespace initialization
+ */
 acpi_status
 acpi_ns_initialize_objects (
 	void);
@@ -93,23 +81,22 @@ acpi_ns_initialize_devices (
 	void);
 
 
-/* Namespace init - nsxfinit */
-
+/*
+ * nsload -  Namespace loading
+ */
 acpi_status
-acpi_ns_init_one_device (
-	acpi_handle                     obj_handle,
-	u32                             nesting_level,
-	void                            *context,
-	void                            **return_value);
+acpi_ns_load_namespace (
+	void);
 
 acpi_status
-acpi_ns_init_one_object (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
+acpi_ns_load_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *node);
 
 
+/*
+ * nswalk - walk the namespace
+ */
 acpi_status
 acpi_ns_walk_namespace (
 	acpi_object_type                type,
@@ -126,37 +113,24 @@ acpi_ns_get_next_node (
 	struct acpi_namespace_node      *parent,
 	struct acpi_namespace_node      *child);
 
-void
-acpi_ns_delete_namespace_by_owner (
-	u16                             table_id);
-
-
-/* Namespace loading - nsload */
-
-acpi_status
-acpi_ns_one_complete_parse (
-	u32                             pass_number,
-	struct acpi_table_desc          *table_desc);
 
+/*
+ * nsparse - table parsing
+ */
 acpi_status
 acpi_ns_parse_table (
 	struct acpi_table_desc          *table_desc,
 	struct acpi_namespace_node      *scope);
 
 acpi_status
-acpi_ns_load_table (
-	struct acpi_table_desc          *table_desc,
-	struct acpi_namespace_node      *node);
-
-acpi_status
-acpi_ns_load_table_by_type (
-	acpi_table_type                 table_type);
+acpi_ns_one_complete_parse (
+	u8                              pass_number,
+	struct acpi_table_desc          *table_desc);
 
 
 /*
- * Top-level namespace access - nsaccess
+ * nsaccess - Top-level namespace access
  */
-
 acpi_status
 acpi_ns_root_initialize (
 	void);
@@ -173,9 +147,8 @@ acpi_ns_lookup (
 
 
 /*
- * Named object allocation/deallocation - nsalloc
+ * nsalloc - Named object allocation/deallocation
  */
-
 struct acpi_namespace_node *
 acpi_ns_create_node (
 	u32                             name);
@@ -189,6 +162,10 @@ acpi_ns_delete_namespace_subtree (
 	struct acpi_namespace_node      *parent_handle);
 
 void
+acpi_ns_delete_namespace_by_owner (
+	acpi_owner_id                   owner_id);
+
+void
 acpi_ns_detach_object (
 	struct acpi_namespace_node      *node);
 
@@ -201,36 +178,16 @@ acpi_ns_compare_names (
 	char                            *name1,
 	char                            *name2);
 
-void
-acpi_ns_remove_reference (
-	struct acpi_namespace_node      *node);
-
-
-/*
- * Namespace modification - nsmodify
- */
-
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ns_unload_namespace (
-	acpi_handle                     handle);
-
-acpi_status
-acpi_ns_delete_subtree (
-	acpi_handle                     start_handle);
-#endif
-
 
 /*
- * Namespace dump/print utilities - nsdump
+ * nsdump - Namespace dump/print utilities
  */
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ns_dump_tables (
 	acpi_handle                     search_base,
 	u32                             max_depth);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ns_dump_entry (
@@ -249,19 +206,6 @@ acpi_ns_print_pathname (
 	u32                             num_segments,
 	char                            *pathname);
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_ns_dump_one_device (
-	acpi_handle                     obj_handle,
-	u32                             level,
-	void                            *context,
-	void                            **return_value);
-
-void
-acpi_ns_dump_root_devices (
-	void);
-#endif  /*  ACPI_FUTURE_USAGE  */
-
 acpi_status
 acpi_ns_dump_one_object (
 	acpi_handle                     obj_handle,
@@ -269,21 +213,20 @@ acpi_ns_dump_one_object (
 	void                            *context,
 	void                            **return_value);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ns_dump_objects (
 	acpi_object_type                type,
 	u8                              display_type,
 	u32                             max_depth,
-	u32                             ownder_id,
+	acpi_owner_id                   owner_id,
 	acpi_handle                     start_handle);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 
 /*
- * Namespace evaluation functions - nseval
+ * nseval - Namespace evaluation functions
  */
-
 acpi_status
 acpi_ns_evaluate_by_handle (
 	struct acpi_parameter_info      *info);
@@ -298,40 +241,14 @@ acpi_ns_evaluate_relative (
 	char                            *pathname,
 	struct acpi_parameter_info      *info);
 
-acpi_status
-acpi_ns_execute_control_method (
-	struct acpi_parameter_info      *info);
-
-acpi_status
-acpi_ns_get_object_value (
-	struct acpi_parameter_info      *info);
-
 
 /*
- * Parent/Child/Peer utility functions
+ * nsnames - Name and Scope manipulation
  */
-
-#ifdef ACPI_FUTURE_USAGE
-acpi_name
-acpi_ns_find_parent_name (
-	struct acpi_namespace_node      *node_to_search);
-#endif
-
-
-/*
- * Name and Scope manipulation - nsnames
- */
-
 u32
 acpi_ns_opens_scope (
 	acpi_object_type                type);
 
-void
-acpi_ns_build_external_path (
-	struct acpi_namespace_node      *node,
-	acpi_size                       size,
-	char                            *name_buffer);
-
 char *
 acpi_ns_get_external_pathname (
 	struct acpi_namespace_node      *node);
@@ -363,9 +280,8 @@ acpi_ns_get_pathname_length (
 
 
 /*
- * Object management for namespace nodes - nsobject
+ * nsobject - Object management for namespace nodes
  */
-
 acpi_status
 acpi_ns_attach_object (
 	struct acpi_namespace_node      *node,
@@ -399,9 +315,8 @@ acpi_ns_get_attached_data (
 
 
 /*
- * Namespace searching and entry - nssearch
+ * nssearch - Namespace searching and entry
  */
-
 acpi_status
 acpi_ns_search_and_enter (
 	u32                             entry_name,
@@ -428,17 +343,12 @@ acpi_ns_install_node (
 
 
 /*
- * Utility functions - nsutils
+ * nsutils - Utility functions
  */
-
 u8
 acpi_ns_valid_root_prefix (
 	char                            prefix);
 
-u8
-acpi_ns_valid_path_separator (
-	char                            sep);
-
 acpi_object_type
 acpi_ns_get_type (
 	struct acpi_namespace_node      *node);
@@ -511,5 +421,4 @@ struct acpi_namespace_node *
 acpi_ns_get_next_valid_node (
 	struct acpi_namespace_node      *node);
 
-
 #endif /* __ACNAMESP_H__ */
diff --git a/include/acpi/acobject.h b/include/acpi/acobject.h
--- a/include/acpi/acobject.h
+++ b/include/acpi/acobject.h
@@ -133,6 +133,7 @@ struct acpi_object_integer
 	acpi_integer                            value;
 };
 
+
 /*
  * Note: The String and Buffer object must be identical through the Pointer
  * element.  There is code that depends on this.
@@ -198,7 +199,7 @@ struct acpi_object_method
 	ACPI_INTERNAL_METHOD            implementation;
 	u8                                      concurrency;
 	u8                                      thread_count;
-	acpi_owner_id                           owning_id;
+	acpi_owner_id                           owner_id;
 };
 
 
@@ -468,7 +469,6 @@ union acpi_operand_object
  *
  *****************************************************************************/
 
-
 /* Object descriptor types */
 
 #define ACPI_DESC_TYPE_CACHED           0x01        /* Used only when object is cached */
diff --git a/include/acpi/acopcode.h b/include/acpi/acopcode.h
new file mode 100644
--- /dev/null
+++ b/include/acpi/acopcode.h
@@ -0,0 +1,325 @@
+/******************************************************************************
+ *
+ * Name: acopcode.h - AML opcode information for the AML parser and interpreter
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2005, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOPCODE_H__
+#define __ACOPCODE_H__
+
+#define MAX_EXTENDED_OPCODE         0x88
+#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
+#define MAX_INTERNAL_OPCODE
+#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
+
+/* Used for non-assigned opcodes */
+
+#define _UNK                        0x6B
+
+/*
+ * Reserved ASCII characters.  Do not use any of these for
+ * internal opcodes, since they are used to differentiate
+ * name strings from AML opcodes
+ */
+#define _ASC                        0x6C
+#define _NAM                        0x6C
+#define _PFX                        0x6D
+
+
+/*
+ * All AML opcodes and the parse-time arguments for each.  Used by the AML
+ * parser  Each list is compressed into a 32-bit number and stored in the
+ * master opcode table (in psopcode.c).
+ */
+#define ARGP_ACCESSFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_ACQUIRE_OP                 ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_WORDDATA)
+#define ARGP_ADD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_ALIAS_OP                   ARGP_LIST2 (ARGP_NAMESTRING, ARGP_NAME)
+#define ARGP_ARG0                       ARG_NONE
+#define ARGP_ARG1                       ARG_NONE
+#define ARGP_ARG2                       ARG_NONE
+#define ARGP_ARG3                       ARG_NONE
+#define ARGP_ARG4                       ARG_NONE
+#define ARGP_ARG5                       ARG_NONE
+#define ARGP_ARG6                       ARG_NONE
+#define ARGP_BANK_FIELD_OP              ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_BIT_AND_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NAND_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOT_OP                 ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_BIT_OR_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_XOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BREAK_OP                   ARG_NONE
+#define ARGP_BREAK_POINT_OP             ARG_NONE
+#define ARGP_BUFFER_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_BYTELIST)
+#define ARGP_BYTE_OP                    ARGP_LIST1 (ARGP_BYTEDATA)
+#define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
+#define ARGP_CONTINUE_OP                ARG_NONE
+#define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SIMPLENAME)
+#define ARGP_CREATE_BIT_FIELD_OP        ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_BYTE_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_DWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_FIELD_OP            ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_NAME)
+#define ARGP_CREATE_QWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_WORD_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_DATA_REGION_OP             ARGP_LIST4 (ARGP_NAME,       ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_DEBUG_OP                   ARG_NONE
+#define ARGP_DECREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_DEREF_OF_OP                ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_DEVICE_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_DIVIDE_OP                  ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET,    ARGP_TARGET)
+#define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
+#define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
+#define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
+#define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
+#define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FIND_SET_RIGHT_BIT_OP      ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FROM_BCD_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_IF_OP                      ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_INCREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_INDEX_FIELD_OP             ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_INDEX_OP                   ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_LAND_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LEQUAL_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATER_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATEREQUAL_OP           ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESS_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESSEQUAL_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LNOT_OP                    ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_LNOTEQUAL_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LOAD_OP                    ARGP_LIST2 (ARGP_NAMESTRING, ARGP_SUPERNAME)
+#define ARGP_LOAD_TABLE_OP              ARGP_LIST6 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_LOCAL0                     ARG_NONE
+#define ARGP_LOCAL1                     ARG_NONE
+#define ARGP_LOCAL2                     ARG_NONE
+#define ARGP_LOCAL3                     ARG_NONE
+#define ARGP_LOCAL4                     ARG_NONE
+#define ARGP_LOCAL5                     ARG_NONE
+#define ARGP_LOCAL6                     ARG_NONE
+#define ARGP_LOCAL7                     ARG_NONE
+#define ARGP_LOR_OP                     ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_MATCH_OP                   ARGP_LIST6 (ARGP_TERMARG,    ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_METHOD_OP                  ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_TERMLIST)
+#define ARGP_METHODCALL_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_MID_OP                     ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TARGET)
+#define ARGP_MOD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MULTIPLY_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MUTEX_OP                   ARGP_LIST2 (ARGP_NAME,       ARGP_BYTEDATA)
+#define ARGP_NAME_OP                    ARGP_LIST2 (ARGP_NAME,       ARGP_DATAOBJ)
+#define ARGP_NAMEDFIELD_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NOOP_OP                    ARG_NONE
+#define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_ONE_OP                     ARG_NONE
+#define ARGP_ONES_OP                    ARG_NONE
+#define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
+#define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
+#define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
+#define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
+#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_RESET_OP                   ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RETURN_OP                  ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_REVISION_OP                ARG_NONE
+#define ARGP_SCOPE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_TERMLIST)
+#define ARGP_SHIFT_LEFT_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SHIFT_RIGHT_OP             ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SIGNAL_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SIZE_OF_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SLEEP_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STALL_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STATICSTRING_OP            ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_STORE_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_SUPERNAME)
+#define ARGP_STRING_OP                  ARGP_LIST1 (ARGP_CHARLIST)
+#define ARGP_SUBTRACT_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_THERMAL_ZONE_OP            ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_TIMER_OP                   ARG_NONE
+#define ARGP_TO_BCD_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_BUFFER_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_DEC_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
+#define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
+#define ARGP_ZERO_OP                    ARG_NONE
+
+
+/*
+ * All AML opcodes and the runtime arguments for each.  Used by the AML
+ * interpreter  Each list is compressed into a 32-bit number and stored
+ * in the master opcode table (in psopcode.c).
+ *
+ * (Used by prep_operands procedure and the ASL Compiler)
+ */
+#define ARGI_ACCESSFIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_ACQUIRE_OP                 ARGI_LIST2 (ARGI_MUTEX,      ARGI_INTEGER)
+#define ARGI_ADD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_ALIAS_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ARG0                       ARG_NONE
+#define ARGI_ARG1                       ARG_NONE
+#define ARGI_ARG2                       ARG_NONE
+#define ARGI_ARG3                       ARG_NONE
+#define ARGI_ARG4                       ARG_NONE
+#define ARGI_ARG5                       ARG_NONE
+#define ARGI_ARG6                       ARG_NONE
+#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOT_OP                 ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_BIT_OR_OP                  ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BREAK_OP                   ARG_NONE
+#define ARGI_BREAK_POINT_OP             ARG_NONE
+#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
+#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
+#define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
+#define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
+#define ARGI_CONTINUE_OP                ARGI_INVALID_OPCODE
+#define ARGI_COPY_OP                    ARGI_LIST2 (ARGI_ANYTYPE,    ARGI_SIMPLE_TARGET)
+#define ARGI_CREATE_BIT_FIELD_OP        ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_BYTE_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_DWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_FIELD_OP            ARGI_LIST4 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_INTEGER,      ARGI_REFERENCE)
+#define ARGI_CREATE_QWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_WORD_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING)
+#define ARGI_DEBUG_OP                   ARG_NONE
+#define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
+#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
+#define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
+#define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
+#define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
+#define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FIND_SET_RIGHT_BIT_OP      ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FROM_BCD_OP                ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
+#define ARGI_IF_OP                      ARGI_INVALID_OPCODE
+#define ARGI_INCREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
+#define ARGI_INDEX_FIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_INDEX_OP                   ARGI_LIST3 (ARGI_COMPLEXOBJ, ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_LAND_OP                    ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_LEQUAL_OP                  ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATER_OP                ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATEREQUAL_OP           ARGI_INVALID_OPCODE
+#define ARGI_LLESS_OP                   ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
+#define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
+#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_FIELD,ARGI_TARGETREF)
+#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
+#define ARGI_LOCAL0                     ARG_NONE
+#define ARGI_LOCAL1                     ARG_NONE
+#define ARGI_LOCAL2                     ARG_NONE
+#define ARGI_LOCAL3                     ARG_NONE
+#define ARGI_LOCAL4                     ARG_NONE
+#define ARGI_LOCAL5                     ARG_NONE
+#define ARGI_LOCAL6                     ARG_NONE
+#define ARGI_LOCAL7                     ARG_NONE
+#define ARGI_LOR_OP                     ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,   ARGI_COMPUTEDATA,      ARGI_INTEGER,ARGI_COMPUTEDATA,ARGI_INTEGER)
+#define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
+#define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
+#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
+#define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
+#define ARGI_NAME_OP                    ARGI_INVALID_OPCODE
+#define ARGI_NAMEDFIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
+#define ARGI_NOOP_OP                    ARG_NONE
+#define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
+#define ARGI_ONE_OP                     ARG_NONE
+#define ARGI_ONES_OP                    ARG_NONE
+#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
+#define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
+#define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_REF_OF_OP                  ARGI_LIST1 (ARGI_OBJECT_REF)
+#define ARGI_REGION_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_RELEASE_OP                 ARGI_LIST1 (ARGI_MUTEX)
+#define ARGI_RESERVEDFIELD_OP           ARGI_INVALID_OPCODE
+#define ARGI_RESET_OP                   ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_RETURN_OP                  ARGI_INVALID_OPCODE
+#define ARGI_REVISION_OP                ARG_NONE
+#define ARGI_SCOPE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
+#define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
+#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
+#define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
+#define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
+#define ARGI_TIMER_OP                   ARG_NONE
+#define ARGI_TO_BCD_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
+#define ARGI_TO_BUFFER_OP               ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_DEC_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
+#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
+#define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
+#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
+#define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
+#define ARGI_ZERO_OP                    ARG_NONE
+
+#endif /* __ACOPCODE_H__ */
diff --git a/include/acpi/acoutput.h b/include/acpi/acoutput.h
--- a/include/acpi/acoutput.h
+++ b/include/acpi/acoutput.h
@@ -136,7 +136,7 @@
 /*
  * Debug level macros that are used in the DEBUG_PRINT macros
  */
-#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,__LINE__,&_debug_info
+#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,ACPI_DEBUG_PARAMETERS
 
 /* Exception level -- used in the global "debug_level" */
 
diff --git a/include/acpi/acparser.h b/include/acpi/acparser.h
--- a/include/acpi/acparser.h
+++ b/include/acpi/acparser.h
@@ -63,17 +63,7 @@
 #define ACPI_PARSE_MODE_MASK            0x0030
 
 #define ACPI_PARSE_DEFERRED_OP          0x0100
-
-/* Parser external interfaces */
-
-acpi_status
-acpi_psx_load_table (
-	u8                              *pcode_addr,
-	u32                             pcode_length);
-
-acpi_status
-acpi_psx_execute (
-	struct acpi_parameter_info      *info);
+#define ACPI_PARSE_DISASSEMBLE          0x0200
 
 
 /******************************************************************************
@@ -83,16 +73,21 @@ acpi_psx_execute (
  *****************************************************************************/
 
 
-/* psargs - Parse AML opcode arguments */
+/*
+ * psxface - Parser external interfaces
+ */
+acpi_status
+acpi_ps_execute_method (
+	struct acpi_parameter_info      *info);
 
+
+/*
+ * psargs - Parse AML opcode arguments
+ */
 u8 *
 acpi_ps_get_next_package_end (
 	struct acpi_parse_state         *parser_state);
 
-u32
-acpi_ps_get_next_package_length (
-	struct acpi_parse_state         *parser_state);
-
 char *
 acpi_ps_get_next_namestring (
 	struct acpi_parse_state         *parser_state);
@@ -110,10 +105,6 @@ acpi_ps_get_next_namepath (
 	union acpi_parse_object         *arg,
 	u8                              method_call);
 
-union acpi_parse_object *
-acpi_ps_get_next_field (
-	struct acpi_parse_state         *parser_state);
-
 acpi_status
 acpi_ps_get_next_arg (
 	struct acpi_walk_state          *walk_state,
@@ -122,8 +113,9 @@ acpi_ps_get_next_arg (
 	union acpi_parse_object         **return_arg);
 
 
-/* psfind */
-
+/*
+ * psfind
+ */
 union acpi_parse_object *
 acpi_ps_find_name (
 	union acpi_parse_object         *scope,
@@ -135,8 +127,9 @@ acpi_ps_get_parent (
 	union acpi_parse_object         *op);
 
 
-/* psopcode - AML Opcode information */
-
+/*
+ * psopcode - AML Opcode information
+ */
 const struct acpi_opcode_info *
 acpi_ps_get_opcode_info (
 	u16                             opcode);
@@ -146,13 +139,22 @@ acpi_ps_get_opcode_name (
 	u16                             opcode);
 
 
-/* psparse - top level parsing routines */
+/*
+ * psparse - top level parsing routines
+ */
+acpi_status
+acpi_ps_parse_aml (
+	struct acpi_walk_state          *walk_state);
 
 u32
 acpi_ps_get_opcode_size (
 	u32                             opcode);
 
-void
+u16
+acpi_ps_peek_opcode (
+	struct acpi_parse_state         *state);
+
+acpi_status
 acpi_ps_complete_this_op (
 	struct acpi_walk_state          *walk_state,
 	union acpi_parse_object         *op);
@@ -163,39 +165,18 @@ acpi_ps_next_parse_state (
 	union acpi_parse_object         *op,
 	acpi_status                     callback_status);
 
-acpi_status
-acpi_ps_find_object (
-	struct acpi_walk_state          *walk_state,
-	union acpi_parse_object         **out_op);
-
-void
-acpi_ps_delete_parse_tree (
-	union acpi_parse_object         *root);
 
+/*
+ * psloop - main parse loop
+ */
 acpi_status
 acpi_ps_parse_loop (
 	struct acpi_walk_state          *walk_state);
 
-acpi_status
-acpi_ps_parse_aml (
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ps_parse_table (
-	u8                              *aml,
-	u32                             aml_size,
-	acpi_parse_downwards            descending_callback,
-	acpi_parse_upwards              ascending_callback,
-	union acpi_parse_object         **root_object);
-
-u16
-acpi_ps_peek_opcode (
-	struct acpi_parse_state         *state);
-
-
-/* psscope - Scope stack management routines */
-
 
+/*
+ * psscope - Scope stack management routines
+ */
 acpi_status
 acpi_ps_init_scope (
 	struct acpi_parse_state         *parser_state,
@@ -228,8 +209,9 @@ acpi_ps_cleanup_scope (
 	struct acpi_parse_state         *state);
 
 
-/* pstree - parse tree manipulation routines */
-
+/*
+ * pstree - parse tree manipulation routines
+ */
 void
 acpi_ps_append_arg(
 	union acpi_parse_object         *op,
@@ -247,20 +229,17 @@ acpi_ps_get_arg(
 	union acpi_parse_object         *op,
 	u32                              argn);
 
-#ifdef ACPI_FUTURE_USAGE
-union acpi_parse_object *
-acpi_ps_get_child (
-	union acpi_parse_object         *op);
-
+#ifdef	ACPI_FUTURE_USAGE
 union acpi_parse_object *
 acpi_ps_get_depth_next (
 	union acpi_parse_object         *origin,
 	union acpi_parse_object         *op);
-#endif  /*  ACPI_FUTURE_USAGE  */
-
+#endif	/* ACPI_FUTURE_USAGE */
 
-/* pswalk - parse tree walk routines */
 
+/*
+ * pswalk - parse tree walk routines
+ */
 acpi_status
 acpi_ps_walk_parsed_aml (
 	union acpi_parse_object         *start_op,
@@ -283,9 +262,14 @@ acpi_status
 acpi_ps_delete_completed_op (
 	struct acpi_walk_state          *walk_state);
 
+void
+acpi_ps_delete_parse_tree (
+	union acpi_parse_object         *root);
 
-/* psutils - parser utilities */
 
+/*
+ * psutils - parser utilities
+ */
 union acpi_parse_object *
 acpi_ps_create_scope_op (
 	void);
@@ -303,12 +287,6 @@ void
 acpi_ps_free_op (
 	union acpi_parse_object         *op);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ps_delete_parse_cache (
-	void);
-#endif
-
 u8
 acpi_ps_is_leading_char (
 	u32                             c);
@@ -317,11 +295,11 @@ u8
 acpi_ps_is_prefix_char (
 	u32                             c);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 u32
 acpi_ps_get_name(
 	union acpi_parse_object         *op);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ps_set_name(
@@ -329,8 +307,9 @@ acpi_ps_set_name(
 	u32                             name);
 
 
-/* psdump - display parser tree */
-
+/*
+ * psdump - display parser tree
+ */
 u32
 acpi_ps_sprint_path (
 	char                            *buffer_start,
diff --git a/include/acpi/acpi.h b/include/acpi/acpi.h
--- a/include/acpi/acpi.h
+++ b/include/acpi/acpi.h
@@ -49,6 +49,7 @@
  * We put them here because we don't want to duplicate them
  * in the rest of the source code again and again.
  */
+#include "acnames.h"            /* Global ACPI names and strings */
 #include "acconfig.h"           /* Configuration constants */
 #include "platform/acenv.h"     /* Target environment specific items */
 #include "actypes.h"            /* Fundamental common data types */
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -336,6 +336,27 @@ int acpi_match_ids (struct acpi_device	*
 int acpi_create_dir(struct acpi_device *);
 void acpi_remove_dir(struct acpi_device *);
 
+
+/*
+ * Bind physical devices with ACPI devices
+ */
+#include <linux/device.h>
+struct acpi_bus_type {
+	struct list_head	list;
+	struct bus_type		*bus;
+	/* For general devices under the bus*/
+	int (*find_device)(struct device *, acpi_handle*);
+	/* For bridges, such as PCI root bridge, IDE controller */
+	int (*find_bridge)(struct device *, acpi_handle *);
+};
+int register_acpi_bus_type(struct acpi_bus_type *);
+int unregister_acpi_bus_type(struct acpi_bus_type *);
+struct device *acpi_get_physical_device(acpi_handle);
+/* helper */
+acpi_handle acpi_get_child(acpi_handle, acpi_integer);
+acpi_handle acpi_get_pci_rootbridge_handle(unsigned int, unsigned int);
+#define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)((dev)->firmware_data))
+
 #endif /*CONFIG_ACPI_BUS*/
 
 #endif /*__ACPI_BUS_H__*/
diff --git a/include/acpi/acpi_drivers.h b/include/acpi/acpi_drivers.h
--- a/include/acpi/acpi_drivers.h
+++ b/include/acpi/acpi_drivers.h
@@ -56,8 +56,9 @@
 /* ACPI PCI Interrupt Link (pci_link.c) */
 
 int acpi_irq_penalty_init (void);
-int acpi_pci_link_get_irq (acpi_handle handle, int index, int *edge_level,
+int acpi_pci_link_allocate_irq (acpi_handle handle, int index, int *edge_level,
 	int *active_high_low, char **name);
+int acpi_pci_link_free_irq(acpi_handle handle);
 
 /* ACPI PCI Interrupt Routing (pci_irq.c) */
 
@@ -108,5 +109,10 @@ int acpi_ec_ecdt_probe (void);
 
 int acpi_processor_set_thermal_limit(acpi_handle handle, int type);
 
+/* --------------------------------------------------------------------------
+                                    Hot Keys
+   -------------------------------------------------------------------------- */
+
+extern int acpi_specific_hotkey_enabled;
 
 #endif /*__ACPI_DRIVERS_H__*/
diff --git a/include/acpi/acpiosxf.h b/include/acpi/acpiosxf.h
--- a/include/acpi/acpiosxf.h
+++ b/include/acpi/acpiosxf.h
@@ -79,7 +79,6 @@ struct acpi_signal_fatal_info
 /*
  * OSL Initialization and shutdown primitives
  */
-
 acpi_status
 acpi_os_initialize (
 	void);
@@ -92,7 +91,6 @@ acpi_os_terminate (
 /*
  * ACPI Table interfaces
  */
-
 acpi_status
 acpi_os_get_root_pointer (
 	u32                             flags,
@@ -112,7 +110,6 @@ acpi_os_table_override (
 /*
  * Synchronization primitives
  */
-
 acpi_status
 acpi_os_create_semaphore (
 	u32                             max_units,
@@ -142,21 +139,19 @@ void
 acpi_os_delete_lock (
 	acpi_handle                     handle);
 
-void
+unsigned long
 acpi_os_acquire_lock (
-	acpi_handle                     handle,
-	u32                             flags);
+	acpi_handle                     handle);
 
 void
 acpi_os_release_lock (
 	acpi_handle                     handle,
-	u32                             flags);
+	unsigned long                   flags);
 
 
 /*
  * Memory allocation and mapping
  */
-
 void *
 acpi_os_allocate (
 	acpi_size                       size);
@@ -184,10 +179,37 @@ acpi_os_get_physical_address (
 #endif
 
 
+
 /*
- * Interrupt handlers
+ * Memory/Object Cache
  */
+acpi_status
+acpi_os_create_cache (
+	char                            *cache_name,
+	u16                             object_size,
+	u16                             max_depth,
+	acpi_cache_t                    **return_cache);
+
+acpi_status
+acpi_os_delete_cache (
+	acpi_cache_t                    *cache);
+
+acpi_status
+acpi_os_purge_cache (
+	acpi_cache_t                    *cache);
+
+void *
+acpi_os_acquire_object (
+	acpi_cache_t                    *cache);
+
+acpi_status
+acpi_os_release_object (
+	acpi_cache_t                    *cache,
+	void                            *object);
 
+/*
+ * Interrupt handlers
+ */
 acpi_status
 acpi_os_install_interrupt_handler (
 	u32                             gsi,
@@ -203,7 +225,6 @@ acpi_os_remove_interrupt_handler (
 /*
  * Threads and Scheduling
  */
-
 u32
 acpi_os_get_thread_id (
 	void);
@@ -234,7 +255,6 @@ acpi_os_stall (
 /*
  * Platform and hardware-independent I/O interfaces
  */
-
 acpi_status
 acpi_os_read_port (
 	acpi_io_address                 address,
@@ -251,7 +271,6 @@ acpi_os_write_port (
 /*
  * Platform and hardware-independent physical memory interfaces
  */
-
 acpi_status
 acpi_os_read_memory (
 	acpi_physical_address           address,
@@ -270,7 +289,6 @@ acpi_os_write_memory (
  * Note: Can't use "Register" as a parameter, changed to "Reg" --
  * certain compilers complain.
  */
-
 acpi_status
 acpi_os_read_pci_configuration (
 	struct acpi_pci_id              *pci_id,
@@ -288,7 +306,6 @@ acpi_os_write_pci_configuration (
 /*
  * Interim function needed for PCI IRQ routing
  */
-
 void
 acpi_os_derive_pci_id(
 	acpi_handle                     rhandle,
@@ -298,7 +315,6 @@ acpi_os_derive_pci_id(
 /*
  * Miscellaneous
  */
-
 u8
 acpi_os_readable (
 	void                            *pointer,
@@ -323,7 +339,6 @@ acpi_os_signal (
 /*
  * Debug print routines
  */
-
 void ACPI_INTERNAL_VAR_XFACE
 acpi_os_printf (
 	const char                      *format,
@@ -339,11 +354,10 @@ acpi_os_redirect_output (
 	void                            *destination);
 
 
+#ifdef ACPI_FUTURE_USAGE
 /*
  * Debug input
  */
-
-#ifdef ACPI_FUTURE_USAGE
 u32
 acpi_os_get_line (
 	char                            *buffer);
@@ -353,7 +367,6 @@ acpi_os_get_line (
 /*
  * Directory manipulation
  */
-
 void *
 acpi_os_open_directory (
 	char                            *pathname,
@@ -377,7 +390,6 @@ acpi_os_close_directory (
 /*
  * Debug
  */
-
 void
 acpi_os_dbg_assert(
 	void                            *failed_assertion,
@@ -385,5 +397,4 @@ acpi_os_dbg_assert(
 	u32                             line_number,
 	char                            *message);
 
-
 #endif /* __ACPIOSXF_H__ */
diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h
--- a/include/acpi/acpixf.h
+++ b/include/acpi/acpixf.h
@@ -50,10 +50,9 @@
 #include "actbl.h"
 
 
- /*
+/*
  * Global interfaces
  */
-
 acpi_status
 acpi_initialize_subsystem (
 	void);
@@ -106,9 +105,8 @@ acpi_install_initialization_handler (
 #endif
 
 /*
- * ACPI Memory manager
+ * ACPI Memory managment
  */
-
 void *
 acpi_allocate (
 	u32                             size);
@@ -125,7 +123,6 @@ acpi_free (
 /*
  * ACPI table manipulation interfaces
  */
-
 acpi_status
 acpi_find_root_pointer (
 	u32                             flags,
@@ -168,7 +165,6 @@ acpi_get_firmware_table (
 /*
  * Namespace and name interfaces
  */
-
 acpi_status
 acpi_walk_namespace (
 	acpi_object_type                type,
@@ -218,7 +214,6 @@ acpi_get_data (
 /*
  * Object manipulation and enumeration
  */
-
 acpi_status
 acpi_evaluate_object (
 	acpi_handle                     object,
@@ -262,7 +257,6 @@ acpi_get_parent (
 /*
  * Event handler interfaces
  */
-
 acpi_status
 acpi_install_fixed_event_handler (
 	u32                             acpi_event,
@@ -319,7 +313,6 @@ acpi_install_exception_handler (
 /*
  * Event interfaces
  */
-
 acpi_status
 acpi_acquire_global_lock (
 	u16                             timeout,
@@ -394,7 +387,7 @@ acpi_install_gpe_block (
 	acpi_handle                     gpe_device,
 	struct acpi_generic_address     *gpe_block_address,
 	u32                             register_count,
-	u32                             interrupt_level);
+	u32                             interrupt_number);
 
 acpi_status
 acpi_remove_gpe_block (
@@ -404,7 +397,6 @@ acpi_remove_gpe_block (
 /*
  * Resource interfaces
  */
-
 typedef
 acpi_status (*ACPI_WALK_RESOURCE_CALLBACK) (
 	struct acpi_resource            *resource,
@@ -448,7 +440,6 @@ acpi_resource_to_address64 (
 /*
  * Hardware (ACPI device) interfaces
  */
-
 acpi_status
 acpi_get_register (
 	u32                             register_id,
diff --git a/include/acpi/acresrc.h b/include/acpi/acresrc.h
--- a/include/acpi/acresrc.h
+++ b/include/acpi/acresrc.h
@@ -48,7 +48,6 @@
 /*
  *  Function prototypes called from Acpi* APIs
  */
-
 acpi_status
 acpi_rs_get_prt_method_data (
 	acpi_handle                     handle,
@@ -60,12 +59,12 @@ acpi_rs_get_crs_method_data (
 	acpi_handle                     handle,
 	struct acpi_buffer              *ret_buffer);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_rs_get_prs_method_data (
 	acpi_handle                     handle,
 	struct acpi_buffer              *ret_buffer);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 acpi_status
 acpi_rs_get_method_data (
@@ -95,61 +94,9 @@ acpi_rs_create_pci_routing_table (
 
 
 /*
- * Function prototypes called from acpi_rs_create*
+ * rsdump
  */
-#ifdef ACPI_FUTURE_USAGE
-void
-acpi_rs_dump_irq (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address16 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_address64 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_dma (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_io (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_extended_irq (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_fixed_io (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_fixed_memory32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_memory24 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_memory32 (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_start_depend_fns (
-	union acpi_resource_data        *data);
-
-void
-acpi_rs_dump_vendor_specific (
-	union acpi_resource_data        *data);
-
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_rs_dump_resource_list (
 	struct acpi_resource            *resource);
@@ -157,8 +104,12 @@ acpi_rs_dump_resource_list (
 void
 acpi_rs_dump_irq_list (
 	u8                              *route_table);
-#endif  /*  ACPI_FUTURE_USAGE  */
+#endif	/* ACPI_FUTURE_USAGE */
 
+
+/*
+ * rscalc
+ */
 acpi_status
 acpi_rs_get_byte_stream_start (
 	u8                              *byte_stream_buffer,
diff --git a/include/acpi/acstruct.h b/include/acpi/acstruct.h
--- a/include/acpi/acstruct.h
+++ b/include/acpi/acstruct.h
@@ -56,7 +56,6 @@
  * Walk state - current state of a parse tree walk.  Used for both a leisurely stroll through
  * the tree (for whatever reason), and for control method execution.
  */
-
 #define ACPI_NEXT_OP_DOWNWARD       1
 #define ACPI_NEXT_OP_UPWARD         2
 
@@ -72,14 +71,13 @@ struct acpi_walk_state
 	u8                                  walk_type;
 	acpi_owner_id                       owner_id;                           /* Owner of objects created during the walk */
 	u8                                  last_predicate;                     /* Result of last predicate */
-	u8                                  reserved;                           /* For alignment */
 	u8                                  current_result;                     /* */
 	u8                                  next_op_info;                       /* Info about next_op */
 	u8                                  num_operands;                       /* Stack pointer for Operands[] array */
 	u8                                  return_used;
 	u16                                 opcode;                             /* Current AML opcode */
 	u8                                  scope_depth;
-	u8                                  reserved1;
+	u8                                  pass_number;                        /* Parse pass during table load */
 	u32                                 arg_count;                          /* push for fixed or var args */
 	u32                                 aml_offset;
 	u32                                 arg_types;
@@ -155,14 +153,18 @@ struct acpi_device_walk_info
 struct acpi_walk_info
 {
 	u32                             debug_level;
-	u32                             owner_id;
+	u32                             count;
+	acpi_owner_id                   owner_id;
 	u8                              display_type;
 };
 
 /* Display Types */
 
-#define ACPI_DISPLAY_SUMMARY    0
-#define ACPI_DISPLAY_OBJECTS    1
+#define ACPI_DISPLAY_SUMMARY    (u8) 0
+#define ACPI_DISPLAY_OBJECTS    (u8) 1
+#define ACPI_DISPLAY_MASK       (u8) 1
+
+#define ACPI_DISPLAY_SHORT      (u8) 2
 
 struct acpi_get_devices_info
 {
@@ -208,8 +210,10 @@ union acpi_aml_operands
 struct acpi_parameter_info
 {
 	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *obj_desc;
 	union acpi_operand_object       **parameters;
 	union acpi_operand_object       *return_object;
+	u8                              pass_number;
 	u8                              parameter_type;
 	u8                              return_object_type;
 };
diff --git a/include/acpi/actables.h b/include/acpi/actables.h
--- a/include/acpi/actables.h
+++ b/include/acpi/actables.h
@@ -50,17 +50,9 @@
 #define SIZE_IN_HEADER          0
 
 
-#ifdef ACPI_FUTURE_USAGE
-acpi_status
-acpi_tb_handle_to_object (
-	u16                             table_id,
-	struct acpi_table_desc          **table_desc);
-#endif
-
 /*
  * tbconvrt - Table conversion routines
  */
-
 acpi_status
 acpi_tb_convert_to_xsdt (
 	struct acpi_table_desc          *table_info);
@@ -78,10 +70,10 @@ acpi_tb_get_table_count (
 	struct rsdp_descriptor          *RSDP,
 	struct acpi_table_header        *RSDT);
 
+
 /*
  * tbget - Table "get" routines
  */
-
 acpi_status
 acpi_tb_get_table (
 	struct acpi_pointer             *address,
@@ -99,17 +91,6 @@ acpi_tb_get_table_body (
 	struct acpi_table_desc          *table_info);
 
 acpi_status
-acpi_tb_get_this_table (
-	struct acpi_pointer             *address,
-	struct acpi_table_header        *header,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
-acpi_tb_table_override (
-	struct acpi_table_header        *header,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
 acpi_tb_get_table_ptr (
 	acpi_table_type                 table_type,
 	u32                             instance,
@@ -127,36 +108,23 @@ acpi_status
 acpi_tb_validate_rsdt (
 	struct acpi_table_header        *table_ptr);
 
+
+/*
+ * tbgetall - get multiple required tables
+ */
 acpi_status
 acpi_tb_get_required_tables (
 	void);
 
-acpi_status
-acpi_tb_get_primary_table (
-	struct acpi_pointer             *address,
-	struct acpi_table_desc          *table_info);
-
-acpi_status
-acpi_tb_get_secondary_table (
-	struct acpi_pointer             *address,
-	acpi_string                     signature,
-	struct acpi_table_desc          *table_info);
 
 /*
  * tbinstall - Table installation
  */
-
 acpi_status
 acpi_tb_install_table (
 	struct acpi_table_desc          *table_info);
 
 acpi_status
-acpi_tb_match_signature (
-	char                            *signature,
-	struct acpi_table_desc          *table_info,
-	u8                              search_type);
-
-acpi_status
 acpi_tb_recognize_table (
 	struct acpi_table_desc          *table_info,
 	u8                              search_type);
@@ -170,7 +138,6 @@ acpi_tb_init_table_descriptor (
 /*
  * tbremove - Table removal and deletion
  */
-
 void
 acpi_tb_delete_all_tables (
 	void);
@@ -189,41 +156,37 @@ acpi_tb_uninstall_table (
 
 
 /*
- * tbrsd - RSDP, RSDT utilities
+ * tbxfroot - RSDP, RSDT utilities
  */
+acpi_status
+acpi_tb_find_table (
+	char                            *signature,
+	char                            *oem_id,
+	char                            *oem_table_id,
+	struct acpi_table_header        **table_ptr);
 
 acpi_status
 acpi_tb_get_table_rsdt (
 	void);
 
-u8 *
-acpi_tb_scan_memory_for_rsdp (
-	u8                              *start_address,
-	u32                             length);
-
 acpi_status
-acpi_tb_find_rsdp (
-	struct acpi_table_desc          *table_info,
-	u32                             flags);
+acpi_tb_validate_rsdp (
+	struct rsdp_descriptor          *rsdp);
 
 
 /*
  * tbutils - common table utilities
  */
-
 acpi_status
-acpi_tb_find_table (
-	char                            *signature,
-	char                            *oem_id,
-	char                            *oem_table_id,
-	struct acpi_table_header        **table_ptr);
+acpi_tb_is_table_installed (
+	struct acpi_table_desc          *new_table_desc);
 
 acpi_status
 acpi_tb_verify_table_checksum (
 	struct acpi_table_header        *table_header);
 
 u8
-acpi_tb_checksum (
+acpi_tb_generate_checksum (
 	void                            *buffer,
 	u32                             length);
 
@@ -231,5 +194,4 @@ acpi_status
 acpi_tb_validate_table_header (
 	struct acpi_table_header        *table_header);
 
-
 #endif /* __ACTABLES_H__ */
diff --git a/include/acpi/actbl.h b/include/acpi/actbl.h
--- a/include/acpi/actbl.h
+++ b/include/acpi/actbl.h
@@ -86,15 +86,15 @@
  */
 struct rsdp_descriptor         /* Root System Descriptor Pointer */
 {
-	char                            signature [8];          /* ACPI signature, contains "RSD PTR " */
-	u8                              checksum;               /* To make sum of struct == 0 */
-	char                            oem_id [6];             /* OEM identification */
-	u8                              revision;               /* Must be 0 for 1.0, 2 for 2.0 */
-	u32                             rsdt_physical_address;  /* 32-bit physical address of RSDT */
-	u32                             length;                 /* XSDT Length in bytes including hdr */
-	u64                             xsdt_physical_address;  /* 64-bit physical address of XSDT */
-	u8                              extended_checksum;      /* Checksum of entire table */
-	char                            reserved [3];           /* Reserved field must be 0 */
+	char                            signature[8];           /* ACPI signature, contains "RSD PTR " */
+	u8                              checksum;               /* ACPI 1.0 checksum */
+	char                            oem_id[6];              /* OEM identification */
+	u8                              revision;               /* Must be (0) for ACPI 1.0 or (2) for ACPI 2.0+ */
+	u32                             rsdt_physical_address;  /* 32-bit physical address of the RSDT */
+	u32                             length;                 /* XSDT Length in bytes, including header */
+	u64                             xsdt_physical_address;  /* 64-bit physical address of the XSDT */
+	u8                              extended_checksum;      /* Checksum of entire table (ACPI 2.0) */
+	char                            reserved[3];            /* Reserved, must be zero */
 };
 
 
@@ -107,15 +107,15 @@ struct acpi_common_facs          /* Comm
 
 
 #define ACPI_TABLE_HEADER_DEF   /* ACPI common table header */ \
-	char                            signature [4];          /* ACPI signature (4 ASCII characters) */\
-	u32                             length;                 /* Length of table, in bytes, including header */\
+	char                            signature[4];           /* ASCII table signature */\
+	u32                             length;                 /* Length of table in bytes, including this header */\
 	u8                              revision;               /* ACPI Specification minor version # */\
 	u8                              checksum;               /* To make sum of entire table == 0 */\
-	char                            oem_id [6];             /* OEM identification */\
-	char                            oem_table_id [8];       /* OEM table identification */\
+	char                            oem_id[6];              /* ASCII OEM identification */\
+	char                            oem_table_id[8];        /* ASCII OEM table identification */\
 	u32                             oem_revision;           /* OEM revision number */\
-	char                            asl_compiler_id [4];    /* ASL compiler vendor ID */\
-	u32                             asl_compiler_revision;  /* ASL compiler revision number */
+	char                            asl_compiler_id [4];    /* ASCII ASL compiler vendor ID */\
+	u32                             asl_compiler_revision;  /* ASL compiler version */
 
 
 struct acpi_table_header         /* ACPI common table header */
@@ -133,17 +133,19 @@ struct acpi_table_header         /* ACPI
 #define DUAL_PIC                0
 #define MULTIPLE_APIC           1
 
-
 /* Master MADT */
 
 struct multiple_apic_table
 {
 	ACPI_TABLE_HEADER_DEF                           /* ACPI common table header */
 	u32                             local_apic_address;     /* Physical address of local APIC */
-	u32                             PCATcompat      : 1;    /* A one indicates system also has dual 8259s */
-	u32                             reserved1       : 31;
-};
 
+	/* Flags (32 bits) */
+
+	u8                              PCATcompat      : 1;    /* 00:    System also has dual 8259s */
+	u8                                              : 7;    /* 01-07: Reserved, must be zero */
+	u8                              reserved1[3];           /* 08-31: Reserved, must be zero */
+};
 
 /* Values for Type in APIC_HEADER_DEF */
 
@@ -182,16 +184,18 @@ struct apic_header
 #define TRIGGER_RESERVED        2
 #define TRIGGER_LEVEL           3
 
-/* Common flag definitions */
+/* Common flag definitions (16 bits each) */
 
 #define MPS_INTI_FLAGS \
-	u16                             polarity        : 2;    /* Polarity of APIC I/O input signals */\
-	u16                             trigger_mode    : 2;    /* Trigger mode of APIC input signals */\
-	u16                             reserved1       : 12;   /* Reserved, must be zero */
+	u8                              polarity        : 2;    /* 00-01: Polarity of APIC I/O input signals */\
+	u8                              trigger_mode    : 2;    /* 02-03: Trigger mode of APIC input signals */\
+	u8                                              : 4;    /* 04-07: Reserved, must be zero */\
+	u8                              reserved1;              /* 08-15: Reserved, must be zero */
 
 #define LOCAL_APIC_FLAGS \
-	u32                             processor_enabled: 1;   /* Processor is usable if set */\
-	u32                             reserved2       : 31;   /* Reserved, must be zero */
+	u8                              processor_enabled: 1;   /* 00:    Processor is usable if set */\
+	u8                                              : 7;    /* 01-07: Reserved, must be zero */\
+	u8                              reserved2;              /* 08-15: Reserved, must be zero */
 
 /* Sub-structures for MADT */
 
@@ -240,7 +244,7 @@ struct madt_local_apic_nmi
 struct madt_address_override
 {
 	APIC_HEADER_DEF
-	u16                             reserved;               /* Reserved - must be zero */
+	u16                             reserved;               /* Reserved, must be zero */
 	u64                             address;                /* APIC physical address */
 };
 
@@ -248,7 +252,7 @@ struct madt_io_sapic
 {
 	APIC_HEADER_DEF
 	u8                              io_sapic_id;            /* I/O SAPIC ID */
-	u8                              reserved;               /* Reserved - must be zero */
+	u8                              reserved;               /* Reserved, must be zero */
 	u32                             interrupt_base;         /* Glocal interrupt for SAPIC start */
 	u64                             address;                /* SAPIC physical address */
 };
@@ -259,7 +263,7 @@ struct madt_local_sapic
 	u8                              processor_id;           /* ACPI processor id */
 	u8                              local_sapic_id;         /* SAPIC ID */
 	u8                              local_sapic_eid;        /* SAPIC EID */
-	u8                              reserved [3];           /* Reserved - must be zero */
+	u8                              reserved[3];            /* Reserved, must be zero */
 	LOCAL_APIC_FLAGS
 	u32                             processor_uID;          /* Numeric UID - ACPI 3.0 */
 	char                            processor_uIDstring[1]; /* String UID  - ACPI 3.0 */
diff --git a/include/acpi/actbl1.h b/include/acpi/actbl1.h
--- a/include/acpi/actbl1.h
+++ b/include/acpi/actbl1.h
@@ -52,8 +52,7 @@
 struct rsdt_descriptor_rev1
 {
 	ACPI_TABLE_HEADER_DEF                           /* ACPI common table header */
-	u32                             table_offset_entry [1]; /* Array of pointers to other */
-			 /* ACPI tables */
+	u32                             table_offset_entry[1];  /* Array of pointers to ACPI tables */
 };
 
 
@@ -62,14 +61,19 @@ struct rsdt_descriptor_rev1
  */
 struct facs_descriptor_rev1
 {
-	char                            signature[4];           /* ACPI Signature */
-	u32                             length;                 /* Length of structure, in bytes */
+	char                            signature[4];           /* ASCII table signature */
+	u32                             length;                 /* Length of structure in bytes */
 	u32                             hardware_signature;     /* Hardware configuration signature */
 	u32                             firmware_waking_vector; /* ACPI OS waking vector */
 	u32                             global_lock;            /* Global Lock */
-	u32                             S4bios_f        : 1;    /* Indicates if S4BIOS support is present */
-	u32                             reserved1       : 31;   /* Must be 0 */
-	u8                              resverved3 [40];        /* Reserved - must be zero */
+
+	/* Flags (32 bits) */
+
+	u8                              S4bios_f        : 1;    /* 00:    S4BIOS support is present */
+	u8                                              : 7;    /* 01-07: Reserved, must be zero */
+	u8                              reserved1[3];           /* 08-31: Reserved, must be zero */
+
+	u8                              reserved2[40];          /* Reserved, must be zero */
 };
 
 
@@ -82,13 +86,13 @@ struct fadt_descriptor_rev1
 	u32                             firmware_ctrl;          /* Physical address of FACS */
 	u32                             dsdt;                   /* Physical address of DSDT */
 	u8                              model;                  /* System Interrupt Model */
-	u8                              reserved1;              /* Reserved */
+	u8                              reserved1;              /* Reserved, must be zero */
 	u16                             sci_int;                /* System vector of SCI interrupt */
 	u32                             smi_cmd;                /* Port address of SMI command port */
 	u8                              acpi_enable;            /* Value to write to smi_cmd to enable ACPI */
 	u8                              acpi_disable;           /* Value to write to smi_cmd to disable ACPI */
 	u8                              S4bios_req;             /* Value to write to SMI CMD to enter S4BIOS state */
-	u8                              reserved2;              /* Reserved - must be zero */
+	u8                              reserved2;              /* Reserved, must be zero */
 	u32                             pm1a_evt_blk;           /* Port address of Power Mgt 1a acpi_event Reg Blk */
 	u32                             pm1b_evt_blk;           /* Port address of Power Mgt 1b acpi_event Reg Blk */
 	u32                             pm1a_cnt_blk;           /* Port address of Power Mgt 1a Control Reg Blk */
@@ -104,7 +108,7 @@ struct fadt_descriptor_rev1
 	u8                              gpe0_blk_len;           /* Byte Length of ports at gpe0_blk */
 	u8                              gpe1_blk_len;           /* Byte Length of ports at gpe1_blk */
 	u8                              gpe1_base;              /* Offset in gpe model where gpe1 events start */
-	u8                              reserved3;              /* Reserved */
+	u8                              reserved3;              /* Reserved, must be zero */
 	u16                             plvl2_lat;              /* Worst case HW latency to enter/exit C2 state */
 	u16                             plvl3_lat;              /* Worst case HW latency to enter/exit C3 state */
 	u16                             flush_size;             /* Size of area read to flush caches */
@@ -114,19 +118,21 @@ struct fadt_descriptor_rev1
 	u8                              day_alrm;               /* Index to day-of-month alarm in RTC CMOS RAM */
 	u8                              mon_alrm;               /* Index to month-of-year alarm in RTC CMOS RAM */
 	u8                              century;                /* Index to century in RTC CMOS RAM */
-	u8                              reserved4;              /* Reserved */
-	u8                              reserved4a;             /* Reserved */
-	u8                              reserved4b;             /* Reserved */
-	u32                             wb_invd         : 1;    /* The wbinvd instruction works properly */
-	u32                             wb_invd_flush   : 1;    /* The wbinvd flushes but does not invalidate */
-	u32                             proc_c1         : 1;    /* All processors support C1 state */
-	u32                             plvl2_up        : 1;    /* C2 state works on MP system */
-	u32                             pwr_button      : 1;    /* Power button is handled as a generic feature */
-	u32                             sleep_button    : 1;    /* Sleep button is handled as a generic feature, or not present */
-	u32                             fixed_rTC       : 1;    /* RTC wakeup stat not in fixed register space */
-	u32                             rtcs4           : 1;    /* RTC wakeup stat not possible from S4 */
-	u32                             tmr_val_ext     : 1;    /* The tmr_val width is 32 bits (0 = 24 bits) */
-	u32                             reserved5       : 23;   /* Reserved - must be zero */
+	u8                              reserved4[3];           /* Reserved, must be zero */
+
+	/* Flags (32 bits) */
+
+	u8                              wb_invd         : 1;    /* 00:    The wbinvd instruction works properly */
+	u8                              wb_invd_flush   : 1;    /* 01:    The wbinvd flushes but does not invalidate */
+	u8                              proc_c1         : 1;    /* 02:    All processors support C1 state */
+	u8                              plvl2_up        : 1;    /* 03:    C2 state works on MP system */
+	u8                              pwr_button      : 1;    /* 04:    Power button is handled as a generic feature */
+	u8                              sleep_button    : 1;    /* 05:    Sleep button is handled as a generic feature, or not present */
+	u8                              fixed_rTC       : 1;    /* 06:    RTC wakeup stat not in fixed register space */
+	u8                              rtcs4           : 1;    /* 07:    RTC wakeup stat not possible from S4 */
+	u8                              tmr_val_ext     : 1;    /* 08:    tmr_val width is 32 bits (0 = 24 bits) */
+	u8                                              : 7;    /* 09-15: Reserved, must be zero */
+	u8                              reserved5[2];           /* 16-31: Reserved, must be zero */
 };
 
 #pragma pack()
diff --git a/include/acpi/actbl2.h b/include/acpi/actbl2.h
--- a/include/acpi/actbl2.h
+++ b/include/acpi/actbl2.h
@@ -73,8 +73,7 @@
 struct rsdt_descriptor_rev2
 {
 	ACPI_TABLE_HEADER_DEF                           /* ACPI common table header */
-	u32                             table_offset_entry [1]; /* Array of pointers to  */
-			 /* ACPI table headers */
+	u32                             table_offset_entry[1];  /* Array of pointers to ACPI tables */
 };
 
 
@@ -84,8 +83,7 @@ struct rsdt_descriptor_rev2
 struct xsdt_descriptor_rev2
 {
 	ACPI_TABLE_HEADER_DEF                           /* ACPI common table header */
-	u64                             table_offset_entry [1]; /* Array of pointers to  */
-			 /* ACPI table headers */
+	u64                             table_offset_entry[1];  /* Array of pointers to ACPI tables */
 };
 
 
@@ -94,16 +92,21 @@ struct xsdt_descriptor_rev2
  */
 struct facs_descriptor_rev2
 {
-	char                            signature[4];           /* ACPI signature */
+	char                            signature[4];           /* ASCII table signature */
 	u32                             length;                 /* Length of structure, in bytes */
 	u32                             hardware_signature;     /* Hardware configuration signature */
-	u32                             firmware_waking_vector; /* 32bit physical address of the Firmware Waking Vector. */
+	u32                             firmware_waking_vector; /* 32-bit physical address of the Firmware Waking Vector. */
 	u32                             global_lock;            /* Global Lock used to synchronize access to shared hardware resources */
-	u32                             S4bios_f        : 1;    /* S4Bios_f - Indicates if S4BIOS support is present */
-	u32                             reserved1       : 31;   /* Must be 0 */
-	u64                             xfirmware_waking_vector; /* 64bit physical address of the Firmware Waking Vector. */
+
+	/* Flags (32 bits) */
+
+	u8                              S4bios_f        : 1;    /* 00:    S4BIOS support is present */
+	u8                                              : 7;    /* 01-07: Reserved, must be zero */
+	u8                              reserved1[3];           /* 08-31: Reserved, must be zero */
+
+	u64                             xfirmware_waking_vector; /* 64-bit physical address of the Firmware Waking Vector. */
 	u8                              version;                /* Version of this table */
-	u8                              reserved3 [31];         /* Reserved - must be zero */
+	u8                              reserved3[31];          /* Reserved, must be zero */
 };
 
 
@@ -165,35 +168,37 @@ struct fadt_descriptor_rev2
 {
 	ACPI_TABLE_HEADER_DEF                       /* ACPI common table header */
 	FADT_REV2_COMMON
-	u8                              reserved2;          /* Reserved */
-	u32                             wb_invd     : 1;    /* The wbinvd instruction works properly */
-	u32                             wb_invd_flush : 1;  /* The wbinvd flushes but does not invalidate */
-	u32                             proc_c1     : 1;    /* All processors support C1 state */
-	u32                             plvl2_up    : 1;    /* C2 state works on MP system */
-	u32                             pwr_button  : 1;    /* Power button is handled as a generic feature */
-	u32                             sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
-	u32                             fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
-	u32                             rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
-	u32                             tmr_val_ext : 1;    /* Indicates tmr_val is 32 bits 0=24-bits */
-	u32                             dock_cap    : 1;    /* Supports Docking */
-	u32                             reset_reg_sup : 1;  /* Indicates system supports system reset via the FADT RESET_REG */
-	u32                             sealed_case : 1;    /* Indicates system has no internal expansion capabilities and case is sealed */
-	u32                             headless    : 1;    /* Indicates system does not have local video capabilities or local input devices */
-	u32                             cpu_sw_sleep : 1;   /* Indicates to OSPM that a processor native instruction */
-			   /* must be executed after writing the SLP_TYPx register */
-	/* ACPI 3.0 flag bits */
-
-	u32                             pci_exp_wak                         : 1; /* System supports PCIEXP_WAKE (STS/EN) bits */
-	u32                             use_platform_clock                  : 1; /* OSPM should use platform-provided timer */
-	u32                             S4rtc_sts_valid                     : 1; /* Contents of RTC_STS valid after S4 wake */
-	u32                             remote_power_on_capable             : 1; /* System is compatible with remote power on */
-	u32                             force_apic_cluster_model            : 1; /* All local APICs must use cluster model */
-	u32                             force_apic_physical_destination_mode : 1; /* all local x_aPICs must use physical dest mode */
-	u32                             reserved6                           : 12;/* Reserved - must be zero */
+	u8                              reserved2;          /* Reserved, must be zero */
+
+	/* Flags (32 bits) */
+
+	u8                              wb_invd     : 1;    /* 00:    The wbinvd instruction works properly */
+	u8                              wb_invd_flush : 1;  /* 01:    The wbinvd flushes but does not invalidate */
+	u8                              proc_c1     : 1;    /* 02:    All processors support C1 state */
+	u8                              plvl2_up    : 1;    /* 03:    C2 state works on MP system */
+	u8                              pwr_button  : 1;    /* 04:    Power button is handled as a generic feature */
+	u8                              sleep_button : 1;   /* 05:    Sleep button is handled as a generic feature, or not present */
+	u8                              fixed_rTC   : 1;    /* 06:    RTC wakeup stat not in fixed register space */
+	u8                              rtcs4       : 1;    /* 07:    RTC wakeup stat not possible from S4 */
+	u8                              tmr_val_ext : 1;    /* 08:    tmr_val is 32 bits 0=24-bits */
+	u8                              dock_cap    : 1;    /* 09:    Docking supported */
+	u8                              reset_reg_sup : 1;  /* 10:    System reset via the FADT RESET_REG supported */
+	u8                              sealed_case : 1;    /* 11:    No internal expansion capabilities and case is sealed */
+	u8                              headless    : 1;    /* 12:    No local video capabilities or local input devices */
+	u8                              cpu_sw_sleep : 1;   /* 13:    Must execute native instruction after writing SLP_TYPx register */
+
+	u8                              pci_exp_wak                         : 1; /* 14:    System supports PCIEXP_WAKE (STS/EN) bits (ACPI 3.0) */
+	u8                              use_platform_clock                  : 1; /* 15:    OSPM should use platform-provided timer (ACPI 3.0) */
+	u8                              S4rtc_sts_valid                     : 1; /* 16:    Contents of RTC_STS valid after S4 wake (ACPI 3.0) */
+	u8                              remote_power_on_capable             : 1; /* 17:    System is compatible with remote power on (ACPI 3.0) */
+	u8                              force_apic_cluster_model            : 1; /* 18:    All local APICs must use cluster model (ACPI 3.0) */
+	u8                              force_apic_physical_destination_mode : 1; /* 19:   all local x_aPICs must use physical dest mode (ACPI 3.0) */
+	u8                                                                  : 4; /* 20-23: Reserved, must be zero */
+	u8                              reserved3;                               /* 24-31: Reserved, must be zero */
 
 	struct acpi_generic_address     reset_register;     /* Reset register address in GAS format */
 	u8                              reset_value;        /* Value to write to the reset_register port to reset the system */
-	u8                              reserved7[3];       /* These three bytes must be zero */
+	u8                              reserved4[3];       /* These three bytes must be zero */
 	u64                             xfirmware_ctrl;     /* 64-bit physical address of FACS */
 	u64                             Xdsdt;              /* 64-bit physical address of DSDT */
 	struct acpi_generic_address     xpm1a_evt_blk;      /* Extended Power Mgt 1a acpi_event Reg Blk address */
@@ -213,11 +218,11 @@ struct fadt_descriptor_rev2_minus
 {
 	ACPI_TABLE_HEADER_DEF                       /* ACPI common table header */
 	FADT_REV2_COMMON
-	u8                              reserved2;          /* Reserved */
+	u8                              reserved2;          /* Reserved, must be zero */
 	u32                             flags;
 	struct acpi_generic_address     reset_register;     /* Reset register address in GAS format */
 	u8                              reset_value;        /* Value to write to the reset_register port to reset the system. */
-	u8                              reserved7[3];       /* These three bytes must be zero */
+	u8                              reserved7[3];       /* Reserved, must be zero */
 };
 
 
@@ -242,11 +247,16 @@ struct static_resource_alloc
 	u8                              length;
 	u8                              proximity_domain_lo;
 	u8                              apic_id;
-	u32                             enabled         :1;
-	u32                             reserved3       :31;
+
+	/* Flags (32 bits) */
+
+	u8                              enabled         :1; /* 00:    Use affinity structure */
+	u8                                              :7; /* 01-07: Reserved, must be zero */
+	u8                              reserved3[3];       /* 08-31: Reserved, must be zero */
+
 	u8                              local_sapic_eid;
 	u8                              proximity_domain_hi[3];
-	u32                             reserved4;
+	u32                             reserved4;          /* Reserved, must be zero */
 };
 
 struct memory_affinity
@@ -258,18 +268,23 @@ struct memory_affinity
 	u64                             base_address;
 	u64                             address_length;
 	u32                             reserved4;
-	u32                             enabled         :1;
-	u32                             hot_pluggable   :1;
-	u32                             non_volatile    :1;
-	u32                             reserved5       :29;
-	u64                             reserved6;
+
+	/* Flags (32 bits) */
+
+	u8                              enabled         :1; /* 00:    Use affinity structure */
+	u8                              hot_pluggable   :1; /* 01:    Memory region is hot pluggable */
+	u8                              non_volatile    :1; /* 02:    Memory is non-volatile */
+	u8                                              :5; /* 03-07: Reserved, must be zero */
+	u8                              reserved5[3];       /* 08-31: Reserved, must be zero */
+
+	u64                             reserved6;          /* Reserved, must be zero */
 };
 
 struct system_resource_affinity
 {
 	ACPI_TABLE_HEADER_DEF
 	u32                             reserved1;          /* Must be value '1' */
-	u64                             reserved2;
+	u64                             reserved2;          /* Reserved, must be zero */
 };
 
 
diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h
--- a/include/acpi/actypes.h
+++ b/include/acpi/actypes.h
@@ -205,10 +205,11 @@ typedef u32                             
 
 
 /*
- * Miscellaneous common types
+ * This type is used for bitfields in ACPI tables. The only type that is
+ * even remotely portable is u8. Anything else is not portable, so
+ * do not add any more bitfield types.
  */
-typedef u16                                     UINT16_BIT;
-typedef u32                                     UINT32_BIT;
+typedef u8                                      UINT8_BIT;
 typedef acpi_native_uint                        ACPI_PTRDIFF;
 
 /*
@@ -243,6 +244,14 @@ struct acpi_pointer
 #define ACPI_LOGMODE_PHYSPTR            ACPI_LOGICAL_ADDRESSING  | ACPI_PHYSICAL_POINTER
 #define ACPI_LOGMODE_LOGPTR             ACPI_LOGICAL_ADDRESSING  | ACPI_LOGICAL_POINTER
 
+/*
+ * If acpi_cache_t was not defined in the OS-dependent header,
+ * define it now. This is typically the case where the local cache
+ * manager implementation is to be used (ACPI_USE_LOCAL_CACHE)
+ */
+#ifndef acpi_cache_t
+#define acpi_cache_t                            struct acpi_memory_list
+#endif
 
 /*
  * Useful defines
@@ -478,7 +487,6 @@ typedef u32                             
 #define ACPI_TYPE_INVALID               0x1E
 #define ACPI_TYPE_NOT_FOUND             0xFF
 
-
 /*
  * Bitmapped ACPI types.  Used internally only
  */
@@ -803,7 +811,6 @@ struct acpi_system_info
 /*
  * Types specific to the OS service interfaces
  */
-
 typedef u32
 (ACPI_SYSTEM_XFACE *acpi_osd_handler) (
 	void                            *context);
diff --git a/include/acpi/acutils.h b/include/acpi/acutils.h
--- a/include/acpi/acutils.h
+++ b/include/acpi/acutils.h
@@ -52,13 +52,6 @@ acpi_status (*acpi_pkg_callback) (
 	union acpi_generic_state        *state,
 	void                            *context);
 
-acpi_status
-acpi_ut_walk_package_tree (
-	union acpi_operand_object       *source_object,
-	void                            *target_object,
-	acpi_pkg_callback               walk_callback,
-	void                            *context);
-
 struct acpi_pkg_info
 {
 	u8                              *free_space;
@@ -79,37 +72,13 @@ struct acpi_pkg_info
 #define DB_QWORD_DISPLAY    8
 
 
-/* Global initialization interfaces */
-
-void
-acpi_ut_init_globals (
-	void);
-
-void
-acpi_ut_terminate (
-	void);
-
-
 /*
- * ut_init - miscellaneous initialization and shutdown
+ * utglobal - Global data structures and procedures
  */
-
-acpi_status
-acpi_ut_hardware_initialize (
-	void);
-
 void
-acpi_ut_subsystem_shutdown (
-	void);
-
-acpi_status
-acpi_ut_validate_fadt (
+acpi_ut_init_globals (
 	void);
 
-/*
- * ut_global - Global data structures and procedures
- */
-
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
 char *
@@ -151,15 +120,26 @@ u8
 acpi_ut_valid_object_type (
 	acpi_object_type                type);
 
-acpi_owner_id
-acpi_ut_allocate_owner_id (
-	u32                             id_type);
-
 
 /*
- * ut_clib - Local implementations of C library functions
+ * utinit - miscellaneous initialization and shutdown
  */
+acpi_status
+acpi_ut_hardware_initialize (
+	void);
 
+void
+acpi_ut_subsystem_shutdown (
+	void);
+
+acpi_status
+acpi_ut_validate_fadt (
+	void);
+
+
+/*
+ * utclib - Local implementations of C library functions
+ */
 #ifndef ACPI_USE_SYSTEM_CLIBRARY
 
 acpi_size
@@ -260,10 +240,10 @@ extern const u8 _acpi_ctype[];
 
 #endif /* ACPI_USE_SYSTEM_CLIBRARY */
 
+
 /*
- * ut_copy - Object construction and conversion interfaces
+ * utcopy - Object construction and conversion interfaces
  */
-
 acpi_status
 acpi_ut_build_simple_object(
 	union acpi_operand_object       *obj,
@@ -278,30 +258,11 @@ acpi_ut_build_package_object (
 	u32                             *space_used);
 
 acpi_status
-acpi_ut_copy_ielement_to_eelement (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
-acpi_status
-acpi_ut_copy_ielement_to_ielement (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
-acpi_status
 acpi_ut_copy_iobject_to_eobject (
 	union acpi_operand_object       *obj,
 	struct acpi_buffer              *ret_buffer);
 
 acpi_status
-acpi_ut_copy_esimple_to_isimple(
-	union acpi_object               *user_obj,
-	union acpi_operand_object       **return_obj);
-
-acpi_status
 acpi_ut_copy_eobject_to_iobject (
 	union acpi_object               *obj,
 	union acpi_operand_object       **internal_obj);
@@ -312,17 +273,6 @@ acpi_ut_copy_isimple_to_isimple (
 	union acpi_operand_object       *dest_obj);
 
 acpi_status
-acpi_ut_copy_ipackage_to_ipackage (
-	union acpi_operand_object       *source_obj,
-	union acpi_operand_object       *dest_obj,
-	struct acpi_walk_state          *walk_state);
-
-acpi_status
-acpi_ut_copy_simple_object (
-	union acpi_operand_object       *source_desc,
-	union acpi_operand_object       *dest_desc);
-
-acpi_status
 acpi_ut_copy_iobject_to_iobject (
 	union acpi_operand_object       *source_desc,
 	union acpi_operand_object       **dest_desc,
@@ -330,9 +280,8 @@ acpi_ut_copy_iobject_to_iobject (
 
 
 /*
- * ut_create - Object creation
+ * utcreate - Object creation
  */
-
 acpi_status
 acpi_ut_update_object_reference (
 	union acpi_operand_object       *object,
@@ -340,9 +289,8 @@ acpi_ut_update_object_reference (
 
 
 /*
- * ut_debug - Debug interfaces
+ * utdebug - Debug interfaces
  */
-
 void
 acpi_ut_init_stack_ptr_trace (
 	void);
@@ -354,47 +302,63 @@ acpi_ut_track_stack_ptr (
 void
 acpi_ut_trace (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info);
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id);
 
 void
 acpi_ut_trace_ptr (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	void                            *pointer);
 
 void
 acpi_ut_trace_u32 (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	u32                             integer);
 
 void
 acpi_ut_trace_str (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *string);
 
 void
 acpi_ut_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info);
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id);
 
 void
 acpi_ut_status_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	acpi_status                     status);
 
 void
 acpi_ut_value_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	acpi_integer                    value);
 
 void
 acpi_ut_ptr_exit (
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	u8                              *ptr);
 
 void
@@ -426,7 +390,9 @@ void ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print (
 	u32                             requested_debug_level,
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *format,
 	...) ACPI_PRINTF_LIKE_FUNC;
 
@@ -434,17 +400,22 @@ void ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print_raw (
 	u32                             requested_debug_level,
 	u32                             line_number,
-	struct acpi_debug_print_info    *dbg_info,
+	const char                      *function_name,
+	char                            *module_name,
+	u32                             component_id,
 	char                            *format,
 	...) ACPI_PRINTF_LIKE_FUNC;
 
 
 /*
- * ut_delete - Object deletion
+ * utdelete - Object deletion and reference counts
  */
+void
+acpi_ut_add_reference (
+	union acpi_operand_object       *object);
 
 void
-acpi_ut_delete_internal_obj (
+acpi_ut_remove_reference (
 	union acpi_operand_object       *object);
 
 void
@@ -461,25 +432,8 @@ acpi_ut_delete_internal_object_list (
 
 
 /*
- * ut_eval - object evaluation
+ * uteval - object evaluation
  */
-
-/* Method name strings */
-
-#define METHOD_NAME__HID        "_HID"
-#define METHOD_NAME__CID        "_CID"
-#define METHOD_NAME__UID        "_UID"
-#define METHOD_NAME__ADR        "_ADR"
-#define METHOD_NAME__STA        "_STA"
-#define METHOD_NAME__REG        "_REG"
-#define METHOD_NAME__SEG        "_SEG"
-#define METHOD_NAME__BBN        "_BBN"
-#define METHOD_NAME__PRT        "_PRT"
-#define METHOD_NAME__CRS        "_CRS"
-#define METHOD_NAME__PRS        "_PRS"
-#define METHOD_NAME__PRW        "_PRW"
-
-
 acpi_status
 acpi_ut_osi_implementation (
 	struct acpi_walk_state          *walk_state);
@@ -522,39 +476,10 @@ acpi_ut_execute_sxds (
 	struct acpi_namespace_node      *device_node,
 	u8                              *highest);
 
-/*
- * ut_mutex - mutual exclusion interfaces
- */
-
-acpi_status
-acpi_ut_mutex_initialize (
-	void);
-
-void
-acpi_ut_mutex_terminate (
-	void);
-
-acpi_status
-acpi_ut_create_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_delete_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_acquire_mutex (
-	acpi_mutex_handle               mutex_id);
-
-acpi_status
-acpi_ut_release_mutex (
-	acpi_mutex_handle               mutex_id);
-
 
 /*
- * ut_object - internal object create/delete/cache routines
+ * utobject - internal object create/delete/cache routines
  */
-
 union acpi_operand_object    *
 acpi_ut_create_internal_object_dbg (
 	char                            *module_name,
@@ -568,8 +493,8 @@ acpi_ut_allocate_object_desc_dbg (
 	u32                             line_number,
 	u32                             component_id);
 
-#define acpi_ut_create_internal_object(t) acpi_ut_create_internal_object_dbg (_THIS_MODULE,__LINE__,_COMPONENT,t)
-#define acpi_ut_allocate_object_desc()  acpi_ut_allocate_object_desc_dbg (_THIS_MODULE,__LINE__,_COMPONENT)
+#define acpi_ut_create_internal_object(t) acpi_ut_create_internal_object_dbg (_acpi_module_name,__LINE__,_COMPONENT,t)
+#define acpi_ut_allocate_object_desc()  acpi_ut_allocate_object_desc_dbg (_acpi_module_name,__LINE__,_COMPONENT)
 
 void
 acpi_ut_delete_object_desc (
@@ -587,50 +512,15 @@ union acpi_operand_object *
 acpi_ut_create_string_object (
 	acpi_size                       string_size);
 
-
-/*
- * ut_ref_cnt - Object reference count management
- */
-
-void
-acpi_ut_add_reference (
-	union acpi_operand_object       *object);
-
-void
-acpi_ut_remove_reference (
-	union acpi_operand_object       *object);
-
-/*
- * ut_size - Object size routines
- */
-
-acpi_status
-acpi_ut_get_simple_object_size (
-	union acpi_operand_object       *obj,
-	acpi_size                       *obj_length);
-
-acpi_status
-acpi_ut_get_package_object_size (
-	union acpi_operand_object       *obj,
-	acpi_size                       *obj_length);
-
 acpi_status
 acpi_ut_get_object_size(
 	union acpi_operand_object       *obj,
 	acpi_size                       *obj_length);
 
-acpi_status
-acpi_ut_get_element_length (
-	u8                              object_type,
-	union acpi_operand_object       *source_object,
-	union acpi_generic_state        *state,
-	void                            *context);
-
 
 /*
- * ut_state - Generic state creation/cache routines
+ * utstate - Generic state creation/cache routines
  */
-
 void
 acpi_ut_push_generic_state (
 	union acpi_generic_state        **list_head,
@@ -666,14 +556,14 @@ acpi_ut_create_update_state_and_push (
 	u16                             action,
 	union acpi_generic_state        **state_list);
 
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 acpi_status
 acpi_ut_create_pkg_state_and_push (
 	void                            *internal_object,
 	void                            *external_object,
 	u16                             index,
 	union acpi_generic_state        **state_list);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 union acpi_generic_state *
 acpi_ut_create_control_state (
@@ -683,25 +573,10 @@ void
 acpi_ut_delete_generic_state (
 	union acpi_generic_state        *state);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ut_delete_generic_state_cache (
-	void);
-
-void
-acpi_ut_delete_object_cache (
-	void);
-#endif
 
 /*
- * utmisc
+ * utmath
  */
-
-void
-acpi_ut_print_string (
-	char                            *string,
-	u8                              max_length);
-
 acpi_status
 acpi_ut_divide (
 	acpi_integer                    in_dividend,
@@ -716,6 +591,33 @@ acpi_ut_short_divide (
 	acpi_integer                    *out_quotient,
 	u32                             *out_remainder);
 
+/*
+ * utmisc
+ */
+acpi_status
+acpi_ut_allocate_owner_id (
+	acpi_owner_id                   *owner_id);
+
+void
+acpi_ut_release_owner_id (
+	acpi_owner_id                   *owner_id);
+
+acpi_status
+acpi_ut_walk_package_tree (
+	union acpi_operand_object       *source_object,
+	void                            *target_object,
+	acpi_pkg_callback               walk_callback,
+	void                            *context);
+
+void
+acpi_ut_strupr (
+	char                            *src_string);
+
+void
+acpi_ut_print_string (
+	char                            *string,
+	u8                              max_length);
+
 u8
 acpi_ut_valid_acpi_name (
 	u32                             name);
@@ -734,12 +636,6 @@ acpi_ut_strtoul64 (
 
 #define ACPI_ANY_BASE        0
 
-#ifdef ACPI_FUTURE_USAGE
-char *
-acpi_ut_strupr (
-	char                            *src_string);
-#endif
-
 u8 *
 acpi_ut_get_resource_end_tag (
 	union acpi_operand_object       *obj_desc);
@@ -768,23 +664,35 @@ acpi_ut_display_init_pathname (
 
 
 /*
- * Utalloc - memory allocation and object caching
+ * utmutex - mutex support
  */
-
-void *
-acpi_ut_acquire_from_cache (
-	u32                             list_id);
+acpi_status
+acpi_ut_mutex_initialize (
+	void);
 
 void
-acpi_ut_release_to_cache (
-	u32                             list_id,
-	void                            *object);
+acpi_ut_mutex_terminate (
+	void);
+
+acpi_status
+acpi_ut_acquire_mutex (
+	acpi_mutex_handle               mutex_id);
+
+acpi_status
+acpi_ut_release_mutex (
+	acpi_mutex_handle               mutex_id);
 
-#ifdef ACPI_ENABLE_OBJECT_CACHE
-void
-acpi_ut_delete_generic_cache (
-	u32                             list_id);
-#endif
+
+/*
+ * utalloc - memory allocation and object caching
+ */
+acpi_status
+acpi_ut_create_caches (
+	void);
+
+acpi_status
+acpi_ut_delete_caches (
+	void);
 
 acpi_status
 acpi_ut_validate_buffer (
@@ -795,9 +703,6 @@ acpi_ut_initialize_buffer (
 	struct acpi_buffer              *buffer,
 	acpi_size                       required_length);
 
-
-/* Memory allocation functions */
-
 void *
 acpi_ut_allocate (
 	acpi_size                       size,
@@ -812,9 +717,7 @@ acpi_ut_callocate (
 	char                            *module,
 	u32                             line);
 
-
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
-
 void *
 acpi_ut_allocate_and_track (
 	acpi_size                       size,
@@ -836,34 +739,11 @@ acpi_ut_free_and_track (
 	char                            *module,
 	u32                             line);
 
-struct acpi_debug_mem_block *
-acpi_ut_find_allocation (
-	u32                             list_id,
-	void                            *allocation);
-
-acpi_status
-acpi_ut_track_allocation (
-	u32                             list_id,
-	struct acpi_debug_mem_block     *address,
-	acpi_size                       size,
-	u8                              alloc_type,
-	u32                             component,
-	char                            *module,
-	u32                             line);
-
-acpi_status
-acpi_ut_remove_allocation (
-	u32                             list_id,
-	struct acpi_debug_mem_block     *address,
-	u32                             component,
-	char                            *module,
-	u32                             line);
-
-#ifdef ACPI_FUTURE_USAGE
+#ifdef	ACPI_FUTURE_USAGE
 void
 acpi_ut_dump_allocation_info (
 	void);
-#endif
+#endif	/* ACPI_FUTURE_USAGE */
 
 void
 acpi_ut_dump_allocations (
@@ -871,5 +751,4 @@ acpi_ut_dump_allocations (
 	char                            *module);
 #endif
 
-
 #endif /* _ACUTILS_H */
diff --git a/include/acpi/amlcode.h b/include/acpi/amlcode.h
--- a/include/acpi/amlcode.h
+++ b/include/acpi/amlcode.h
@@ -69,7 +69,7 @@
 #define AML_MULTI_NAME_PREFIX_OP    (u16) 0x2f
 #define AML_NAME_CHAR_SUBSEQ        (u16) 0x30
 #define AML_NAME_CHAR_FIRST         (u16) 0x41
-#define AML_OP_PREFIX               (u16) 0x5b
+#define AML_EXTENDED_OP_PREFIX      (u16) 0x5b
 #define AML_ROOT_PREFIX             (u16) 0x5c
 #define AML_PARENT_PREFIX           (u16) 0x5e
 #define AML_LOCAL_OP                (u16) 0x60
@@ -146,8 +146,7 @@
 
 /* prefixed opcodes */
 
-#define AML_EXTOP                   (u16) 0x005b
-
+#define AML_EXTENDED_OPCODE         (u16) 0x5b00     /* prefix for 2-byte opcodes */
 
 #define AML_MUTEX_OP                (u16) 0x5b01
 #define AML_EVENT_OP                (u16) 0x5b02
@@ -194,7 +193,6 @@
  * Use only "Unknown" AML opcodes, don't attempt to use
  * any valid ACPI ASCII values (A-Z, 0-9, '-')
  */
-
 #define AML_INT_NAMEPATH_OP         (u16) 0x002d
 #define AML_INT_NAMEDFIELD_OP       (u16) 0x0030
 #define AML_INT_RESERVEDFIELD_OP    (u16) 0x0031
@@ -214,7 +212,6 @@
  * There can be up to 31 unique argument types
  * Zero is reserved as end-of-list indicator
  */
-
 #define ARGP_BYTEDATA               0x01
 #define ARGP_BYTELIST               0x02
 #define ARGP_CHARLIST               0x03
@@ -295,7 +292,6 @@
 /*
  * opcode groups and types
  */
-
 #define OPGRP_NAMED                 0x01
 #define OPGRP_FIELD                 0x02
 #define OPGRP_BYTELIST              0x04
@@ -381,6 +377,12 @@
 #define AML_TYPE_UNDEFINED          0x19
 #define AML_TYPE_BOGUS              0x1A
 
+/* AML Package Length encodings */
+
+#define ACPI_AML_PACKAGE_TYPE1      0x40
+#define ACPI_AML_PACKAGE_TYPE2      0x4000
+#define ACPI_AML_PACKAGE_TYPE3      0x400000
+#define ACPI_AML_PACKAGE_TYPE4      0x40000000
 
 /*
  * Opcode classes
diff --git a/include/acpi/pdc_intel.h b/include/acpi/pdc_intel.h
new file mode 100644
--- /dev/null
+++ b/include/acpi/pdc_intel.h
@@ -0,0 +1,29 @@
+
+/* _PDC bit definition for Intel processors */
+
+#ifndef __PDC_INTEL_H__
+#define __PDC_INTEL_H__
+
+#define ACPI_PDC_P_FFH			(0x0001)
+#define ACPI_PDC_C_C1_HALT		(0x0002)
+#define ACPI_PDC_T_FFH			(0x0004)
+#define ACPI_PDC_SMP_C1PT		(0x0008)
+#define ACPI_PDC_SMP_C2C3		(0x0010)
+#define ACPI_PDC_SMP_P_SWCOORD		(0x0020)
+#define ACPI_PDC_SMP_C_SWCOORD		(0x0040)
+#define ACPI_PDC_SMP_T_SWCOORD		(0x0080)
+#define ACPI_PDC_C_C1_FFH		(0x0100)
+
+
+#define ACPI_PDC_EST_CAPABILITY_SMP	(ACPI_PDC_SMP_C1PT | \
+					 ACPI_PDC_C_C1_HALT)
+
+#define ACPI_PDC_EST_CAPABILITY_SMP_MSR	(ACPI_PDC_EST_CAPABILITY_SMP | \
+					 ACPI_PDC_P_FFH)
+
+#define ACPI_PDC_C_CAPABILITY_SMP	(ACPI_PDC_SMP_C2C3 | \
+					 ACPI_PDC_SMP_C1PT | \
+					 ACPI_PDC_C_C1_HALT)
+
+#endif /* __PDC_INTEL_H__ */
+
diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h
--- a/include/acpi/platform/acenv.h
+++ b/include/acpi/platform/acenv.h
@@ -49,35 +49,38 @@
  * Configuration for ACPI tools and utilities
  */
 
-#ifdef _ACPI_DUMP_APP
+#ifdef ACPI_LIBRARY
+#define ACPI_USE_LOCAL_CACHE
+#endif
+
+#ifdef ACPI_DUMP_APP
 #ifndef MSDOS
 #define ACPI_DEBUG_OUTPUT
 #endif
 #define ACPI_APPLICATION
 #define ACPI_DISASSEMBLER
 #define ACPI_NO_METHOD_EXECUTION
-#define ACPI_USE_SYSTEM_CLIBRARY
-#define ACPI_ENABLE_OBJECT_CACHE
 #endif
 
-#ifdef _ACPI_EXEC_APP
+#ifdef ACPI_EXEC_APP
 #undef DEBUGGER_THREADING
 #define DEBUGGER_THREADING      DEBUGGER_SINGLE_THREADED
 #define ACPI_DEBUG_OUTPUT
 #define ACPI_APPLICATION
 #define ACPI_DEBUGGER
 #define ACPI_DISASSEMBLER
-#define ACPI_USE_SYSTEM_CLIBRARY
-#define ACPI_ENABLE_OBJECT_CACHE
 #endif
 
-#ifdef _ACPI_ASL_COMPILER
+#ifdef ACPI_ASL_COMPILER
 #define ACPI_DEBUG_OUTPUT
 #define ACPI_APPLICATION
 #define ACPI_DISASSEMBLER
 #define ACPI_CONSTANT_EVAL_ONLY
+#endif
+
+#ifdef ACPI_APPLICATION
 #define ACPI_USE_SYSTEM_CLIBRARY
-#define ACPI_ENABLE_OBJECT_CACHE
+#define ACPI_USE_LOCAL_CACHE
 #endif
 
 /*
@@ -198,6 +201,7 @@
 #endif
 #endif /* !DEBUGGER_THREADING */
 
+
 /******************************************************************************
  *
  * C library configuration
@@ -209,7 +213,6 @@
  * Use the standard C library headers.
  * We want to keep these to a minimum.
  */
-
 #ifdef ACPI_USE_STANDARD_HEADERS
 /*
  * Use the standard headers from the standard locations
@@ -224,14 +227,8 @@
 /*
  * We will be linking to the standard Clib functions
  */
-
 #define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
 #define ACPI_STRCHR(s1,c)       strchr((s1), (c))
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
-#endif
-
 #define ACPI_STRLEN(s)          (acpi_size) strlen((s))
 #define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
 #define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (acpi_size)(n))
@@ -244,24 +241,25 @@
 #define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (acpi_size)(n))
 #define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (acpi_size)(n))
 
-#define ACPI_TOUPPER            toupper
-#define ACPI_TOLOWER            tolower
-#define ACPI_IS_XDIGIT          isxdigit
-#define ACPI_IS_DIGIT           isdigit
-#define ACPI_IS_SPACE           isspace
-#define ACPI_IS_UPPER           isupper
-#define ACPI_IS_PRINT           isprint
-#define ACPI_IS_ALPHA           isalpha
-#define ACPI_IS_ASCII           isascii
+#define ACPI_TOUPPER(i)         toupper((int) (i))
+#define ACPI_TOLOWER(i)         tolower((int) (i))
+#define ACPI_IS_XDIGIT(i)       isxdigit((int) (i))
+#define ACPI_IS_DIGIT(i)        isdigit((int) (i))
+#define ACPI_IS_SPACE(i)        isspace((int) (i))
+#define ACPI_IS_UPPER(i)        isupper((int) (i))
+#define ACPI_IS_PRINT(i)        isprint((int) (i))
+#define ACPI_IS_ALPHA(i)        isalpha((int) (i))
+#define ACPI_IS_ASCII(i)        isascii((int) (i))
+
+#else
 
 /******************************************************************************
  *
  * Not using native C library, use local implementations
  *
  *****************************************************************************/
-#else
 
-/*
+ /*
  * Use local definitions of C library macros and functions
  * NOTE: The function implementations may not be as efficient
  * as an inline or assembly code implementation provided by a
@@ -278,14 +276,12 @@ typedef char *va_list;
 /*
  * Storage alignment properties
  */
-
 #define  _AUPBND                (sizeof (acpi_native_int) - 1)
 #define  _ADNBND                (sizeof (acpi_native_int) - 1)
 
 /*
  * Variable argument list macro definitions
  */
-
 #define _bnd(X, bnd)            (((sizeof (X)) + (bnd)) & (~(bnd)))
 #define va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
 #define va_end(ap)              (void) 0
@@ -296,11 +292,6 @@ typedef char *va_list;
 
 #define ACPI_STRSTR(s1,s2)      acpi_ut_strstr ((s1), (s2))
 #define ACPI_STRCHR(s1,c)       acpi_ut_strchr ((s1), (c))
-
-#ifdef ACPI_FUTURE_USAGE
-#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
-#endif
-
 #define ACPI_STRLEN(s)          (acpi_size) acpi_ut_strlen ((s))
 #define ACPI_STRCPY(d,s)        (void) acpi_ut_strcpy ((d), (s))
 #define ACPI_STRNCPY(d,s,n)     (void) acpi_ut_strncpy ((d), (s), (acpi_size)(n))
diff --git a/include/acpi/platform/acgcc.h b/include/acpi/platform/acgcc.h
--- a/include/acpi/platform/acgcc.h
+++ b/include/acpi/platform/acgcc.h
@@ -44,13 +44,17 @@
 #ifndef __ACGCC_H__
 #define __ACGCC_H__
 
+/* Function name is used for debug output. Non-ANSI, compiler-dependent */
+
+#define ACPI_GET_FUNCTION_NAME          __FUNCTION__
+
 /* This macro is used to tag functions as "printf-like" because
  * some compilers (like GCC) can catch printf format string problems.
  */
-#define ACPI_PRINTF_LIKE_FUNC __attribute__ ((__format__ (__printf__, 4, 5)))
+#define ACPI_PRINTF_LIKE_FUNC __attribute__ ((__format__ (__printf__, 6, 7)))
 
 /* Some compilers complain about unused variables. Sometimes we don't want to
- * use all the variables (most specifically for _THIS_MODULE). This allow us
+ * use all the variables (for example, _acpi_module_name). This allows us
  * to to tell the compiler warning in a per-variable manner that a variable
  * is unused.
  */
diff --git a/include/acpi/platform/aclinux.h b/include/acpi/platform/aclinux.h
--- a/include/acpi/platform/aclinux.h
+++ b/include/acpi/platform/aclinux.h
@@ -62,6 +62,17 @@
 
 #define ACPI_MACHINE_WIDTH  BITS_PER_LONG
 
+/* Type(s) for the OSL */
+
+#ifdef ACPI_USE_LOCAL_CACHE
+#define acpi_cache_t	struct acpi_memory_list
+#else
+#include <linux/slab.h>
+#define acpi_cache_t	kmem_cache_t
+#endif
+
+
+
 #else /* !__KERNEL__ */
 
 #include <stdarg.h>
diff --git a/include/acpi/processor.h b/include/acpi/processor.h
--- a/include/acpi/processor.h
+++ b/include/acpi/processor.h
@@ -4,6 +4,8 @@
 #include <linux/kernel.h>
 #include <linux/config.h>
 
+#include <asm/acpi.h>
+
 #define ACPI_PROCESSOR_BUSY_METRIC	10
 
 #define ACPI_PROCESSOR_MAX_POWER	8
@@ -14,6 +16,8 @@
 #define ACPI_PROCESSOR_MAX_THROTTLE	250	/* 25% */
 #define ACPI_PROCESSOR_MAX_DUTY_WIDTH	4
 
+#define ACPI_PDC_REVISION_ID		0x1
+
 /* Power Management */
 
 struct acpi_processor_cx;
@@ -59,6 +63,9 @@ struct acpi_processor_power {
 	u32			bm_activity;
 	int			count;
 	struct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];
+
+	/* the _PDC objects passed by the driver, if any */
+	struct acpi_object_list *pdc;
 };
 
 /* Performance Management */
@@ -82,8 +89,6 @@ struct acpi_processor_px {
 	acpi_integer		status;			/* success indicator */
 };
 
-#define ACPI_PDC_REVISION_ID                   0x1
-
 struct acpi_processor_performance {
 	unsigned int		 state;
 	unsigned int		 platform_limit;
@@ -179,7 +184,32 @@ int acpi_processor_notify_smm(struct mod
 extern struct acpi_processor	*processors[NR_CPUS];
 extern struct acpi_processor_errata errata;
 
+int acpi_processor_set_pdc(struct acpi_processor *pr,
+		struct acpi_object_list *pdc_in);
+
+#ifdef ARCH_HAS_POWER_PDC_INIT
+void acpi_processor_power_init_pdc(struct acpi_processor_power *pow,
+		unsigned int cpu);
+void acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags,
+		unsigned int cpu);
+#else
+static inline void acpi_processor_power_init_pdc(
+		struct acpi_processor_power *pow, unsigned int cpu)
+{
+	pow->pdc = NULL;
+	return;
+}
+
+static inline void acpi_processor_power_init_bm_check(
+		struct acpi_processor_flags *flags, unsigned int cpu)
+{
+	flags->bm_check = 1;
+	return;
+}
+#endif
+
 /* in processor_perflib.c */
+
 #ifdef CONFIG_CPU_FREQ
 void acpi_processor_ppc_init(void);
 void acpi_processor_ppc_exit(void);
diff --git a/include/asm-alpha/pci.h b/include/asm-alpha/pci.h
--- a/include/asm-alpha/pci.h
+++ b/include/asm-alpha/pci.h
@@ -58,7 +58,7 @@ struct pci_controller {
 
 extern void pcibios_set_master(struct pci_dev *dev);
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+extern inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-arm/pci.h b/include/asm-arm/pci.h
--- a/include/asm-arm/pci.h
+++ b/include/asm-arm/pci.h
@@ -14,7 +14,7 @@ static inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-h8300/pci.h b/include/asm-h8300/pci.h
--- a/include/asm-h8300/pci.h
+++ b/include/asm-h8300/pci.h
@@ -15,7 +15,7 @@ extern inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+extern inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-i386/acpi.h b/include/asm-i386/acpi.h
--- a/include/asm-i386/acpi.h
+++ b/include/asm-i386/acpi.h
@@ -28,6 +28,8 @@
 
 #ifdef __KERNEL__
 
+#include <acpi/pdc_intel.h>
+
 #include <asm/system.h>		/* defines cmpxchg */
 
 #define COMPILER_DEPENDENT_INT64   long long
@@ -101,12 +103,6 @@ __acpi_release_global_lock (unsigned int
         :"=r"(n_hi), "=r"(n_lo)     \
         :"0"(n_hi), "1"(n_lo))
 
-/*
- * Refer Intel ACPI _PDC support document for bit definitions
- */
-#define ACPI_PDC_EST_CAPABILITY_SMP 	0xa
-#define ACPI_PDC_EST_CAPABILITY_MSR	0x1
-
 #ifdef CONFIG_ACPI_BOOT 
 extern int acpi_lapic;
 extern int acpi_ioapic;
@@ -185,6 +181,8 @@ extern void acpi_reserve_bootmem(void);
 
 extern u8 x86_acpiid_to_apicid[];
 
+#define ARCH_HAS_POWER_PDC_INIT	1
+
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
diff --git a/include/asm-i386/apicdef.h b/include/asm-i386/apicdef.h
--- a/include/asm-i386/apicdef.h
+++ b/include/asm-i386/apicdef.h
@@ -108,11 +108,7 @@
 
 #define APIC_BASE (fix_to_virt(FIX_APIC_BASE))
 
-#ifdef CONFIG_NUMA
- #define MAX_IO_APICS 32
-#else
- #define MAX_IO_APICS 8
-#endif
+#define MAX_IO_APICS 64
 
 /*
  * the local APIC register structure, memory mapped. Not terribly well
diff --git a/include/asm-i386/pci.h b/include/asm-i386/pci.h
--- a/include/asm-i386/pci.h
+++ b/include/asm-i386/pci.h
@@ -27,7 +27,7 @@ void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
diff --git a/include/asm-ia64/acpi.h b/include/asm-ia64/acpi.h
--- a/include/asm-ia64/acpi.h
+++ b/include/asm-ia64/acpi.h
@@ -98,6 +98,15 @@ const char *acpi_get_sysname (void);
 int acpi_request_vector (u32 int_type);
 int acpi_gsi_to_irq (u32 gsi, unsigned int *irq);
 
+/*
+ * Record the cpei override flag and current logical cpu. This is
+ * useful for CPU removal.
+ */
+extern unsigned int can_cpei_retarget(void);
+extern unsigned int is_cpu_cpei_target(unsigned int cpu);
+extern void set_cpei_target_cpu(unsigned int cpu);
+extern unsigned int get_cpei_target_cpu(void);
+
 #ifdef CONFIG_ACPI_NUMA
 /* Proximity bitmap length; _PXM is at most 255 (8 bit)*/
 #define MAX_PXM_DOMAINS (256)
diff --git a/include/asm-ia64/pci.h b/include/asm-ia64/pci.h
--- a/include/asm-ia64/pci.h
+++ b/include/asm-ia64/pci.h
@@ -47,7 +47,7 @@ pcibios_set_master (struct pci_dev *dev)
 }
 
 static inline void
-pcibios_penalize_isa_irq (int irq)
+pcibios_penalize_isa_irq (int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-m68k/pci.h b/include/asm-m68k/pci.h
--- a/include/asm-m68k/pci.h
+++ b/include/asm-m68k/pci.h
@@ -43,7 +43,7 @@ static inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-mips/pci.h b/include/asm-mips/pci.h
--- a/include/asm-mips/pci.h
+++ b/include/asm-mips/pci.h
@@ -69,7 +69,7 @@ extern unsigned long PCIBIOS_MIN_MEM;
 
 extern void pcibios_set_master(struct pci_dev *dev);
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-ppc/pci.h b/include/asm-ppc/pci.h
--- a/include/asm-ppc/pci.h
+++ b/include/asm-ppc/pci.h
@@ -37,7 +37,7 @@ extern inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+extern inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-ppc64/pci.h b/include/asm-ppc64/pci.h
--- a/include/asm-ppc64/pci.h
+++ b/include/asm-ppc64/pci.h
@@ -37,7 +37,7 @@ static inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-sh/pci.h b/include/asm-sh/pci.h
--- a/include/asm-sh/pci.h
+++ b/include/asm-sh/pci.h
@@ -36,7 +36,7 @@ struct pci_dev;
 
 extern void pcibios_set_master(struct pci_dev *dev);
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-sh64/pci.h b/include/asm-sh64/pci.h
--- a/include/asm-sh64/pci.h
+++ b/include/asm-sh64/pci.h
@@ -26,7 +26,7 @@ extern void pcibios_set_master(struct pc
 /*
  * Set penalize isa irq function
  */
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-sparc/pci.h b/include/asm-sparc/pci.h
--- a/include/asm-sparc/pci.h
+++ b/include/asm-sparc/pci.h
@@ -20,7 +20,7 @@ extern inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+extern inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-sparc64/pci.h b/include/asm-sparc64/pci.h
--- a/include/asm-sparc64/pci.h
+++ b/include/asm-sparc64/pci.h
@@ -23,7 +23,7 @@ static inline void pcibios_set_master(st
 	/* No special bus mastering setup handling */
 }
 
-static inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq, int active)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff --git a/include/asm-x86_64/acpi.h b/include/asm-x86_64/acpi.h
--- a/include/asm-x86_64/acpi.h
+++ b/include/asm-x86_64/acpi.h
@@ -28,6 +28,8 @@
 
 #ifdef __KERNEL__
 
+#include <acpi/pdc_intel.h>
+
 #define COMPILER_DEPENDENT_INT64   long long
 #define COMPILER_DEPENDENT_UINT64  unsigned long long
 
@@ -99,12 +101,6 @@ __acpi_release_global_lock (unsigned int
         :"=r"(n_hi), "=r"(n_lo)     \
         :"0"(n_hi), "1"(n_lo))
 
-/*
- * Refer Intel ACPI _PDC support document for bit definitions
- */
-#define ACPI_PDC_EST_CAPABILITY_SMP 	0xa
-#define ACPI_PDC_EST_CAPABILITY_MSR	0x1
-
 #ifdef CONFIG_ACPI_BOOT
 extern int acpi_lapic;
 extern int acpi_ioapic;
diff --git a/include/asm-x86_64/pci.h b/include/asm-x86_64/pci.h
--- a/include/asm-x86_64/pci.h
+++ b/include/asm-x86_64/pci.h
@@ -33,7 +33,7 @@ extern int (*pci_config_read)(int seg, i
 extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -206,7 +206,10 @@ struct acpi_table_plat_int_src {
 	u8			eid;
 	u8			iosapic_vector;
 	u32			global_irq;
-	u32			reserved;
+	struct {
+		u32			cpei_override_flag:1;
+		u32			reserved:31;
+	}			plint_flags;
 } __attribute__ ((packed));
 
 enum acpi_interrupt_id {
@@ -437,9 +440,7 @@ int acpi_gsi_to_irq (u32 gsi, unsigned i
  * If this matches the last registration, any IRQ resources for gsi
  * are freed.
  */
-#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
 void acpi_unregister_gsi (u32 gsi);
-#endif
 
 #ifdef CONFIG_ACPI_PCI
 
@@ -462,11 +463,9 @@ struct acpi_prt_list {
 struct pci_dev;
 
 int acpi_pci_irq_enable (struct pci_dev *dev);
-void acpi_penalize_isa_irq(int irq);
+void acpi_penalize_isa_irq(int irq, int active);
 
-#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
 void acpi_pci_irq_disable (struct pci_dev *dev);
-#endif
 
 struct acpi_pci_driver {
 	struct acpi_pci_driver *next;
diff --git a/include/linux/device.h b/include/linux/device.h
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -269,8 +269,10 @@ struct device {
 	struct device_driver *driver;	/* which driver has allocated this
 					   device */
 	void		*driver_data;	/* data private to the driver */
-	void		*platform_data;	/* Platform specific data (e.g. ACPI,
-					   BIOS data relevant to device) */
+	void		*platform_data;	/* Platform specific data, device
+					   core doesn't touch it */
+	void		*firmware_data; /* Firmware specific data (e.g. ACPI,
+					   BIOS data),reserved for device core*/
 	struct dev_pm_info	power;
 
 	u64		*dma_mask;	/* dma mask (if dma'able device) */
diff --git a/include/linux/pm.h b/include/linux/pm.h
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -175,7 +175,7 @@ struct pm_ops {
 };
 
 extern void pm_set_ops(struct pm_ops *);
-
+extern struct pm_ops *pm_ops;
 extern int pm_suspend(suspend_state_t state);
 
 
diff --git a/kernel/power/main.c b/kernel/power/main.c
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -19,6 +19,9 @@
 
 #include "power.h"
 
+/*This is just an arbitrary number */
+#define FREE_PAGE_NUMBER (100)
+
 DECLARE_MUTEX(pm_sem);
 
 struct pm_ops * pm_ops = NULL;
@@ -49,6 +52,7 @@ void pm_set_ops(struct pm_ops * ops)
 static int suspend_prepare(suspend_state_t state)
 {
 	int error = 0;
+	unsigned int free_pages;
 
 	if (!pm_ops || !pm_ops->enter)
 		return -EPERM;
@@ -60,6 +64,16 @@ static int suspend_prepare(suspend_state
 		goto Thaw;
 	}
 
+	if ((free_pages = nr_free_pages()) < FREE_PAGE_NUMBER) {
+		pr_debug("PM: free some memory\n");
+		shrink_all_memory(FREE_PAGE_NUMBER - free_pages);
+		if (nr_free_pages() < FREE_PAGE_NUMBER) {
+			error = -ENOMEM;
+			printk(KERN_ERR "PM: No enough memory\n");
+			goto Thaw;
+		}
+	}
+
 	if (pm_ops->prepare) {
 		if ((error = pm_ops->prepare(state)))
 			goto Thaw;
@@ -190,7 +204,7 @@ int software_suspend(void)
 
 int pm_suspend(suspend_state_t state)
 {
-	if (state > PM_SUSPEND_ON && state < PM_SUSPEND_MAX)
+	if (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX)
 		return enter_state(state);
 	return -EINVAL;
 }
diff --git a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
--- a/sound/pci/intel8x0.c
+++ b/sound/pci/intel8x0.c
@@ -2367,6 +2367,8 @@ static int intel8x0_suspend(snd_card_t *
 	for (i = 0; i < 3; i++)
 		if (chip->ac97[i])
 			snd_ac97_suspend(chip->ac97[i]);
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
 	pci_disable_device(chip->pci);
 	return 0;
 }
@@ -2378,7 +2380,9 @@ static int intel8x0_resume(snd_card_t *c
 
 	pci_enable_device(chip->pci);
 	pci_set_master(chip->pci);
-	snd_intel8x0_chip_init(chip, 0);
+	request_irq(chip->irq, snd_intel8x0_interrupt, SA_INTERRUPT|SA_SHIRQ, card->shortname, (void *)chip);
+	synchronize_irq(chip->irq);
+	snd_intel8x0_chip_init(chip, 1);
 
 	/* refill nocache */
 	if (chip->fix_nocache)
