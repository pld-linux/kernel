diff -Nur linux-2.6.15.6/drivers/input/joystick/iforce/iforce-serio.c linux-2.6.15.6.iforce/drivers/input/joystick/iforce/iforce-serio.c
--- linux-2.6.15.6/drivers/input/joystick/iforce/iforce-serio.c	2006-03-05 19:07:54.000000000 +0000
+++ linux-2.6.15.6.iforce/drivers/input/joystick/iforce/iforce-serio.c	2006-04-29 23:17:59.000000000 +0000
@@ -175,6 +175,12 @@
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
+	{
+		.type	= SERIO_RS232,
+		.proto	= 0x1f, // Trust ForceFeedback Race Master
+		.id	= SERIO_ANY,
+		.extra	= SERIO_ANY,
+	},
 	{ 0 }
 };
 
--- linux-2.6.27/arch/powerpc/include/asm/io.h~	2006-06-18 01:49:35.000000000 +0000
+++ linux-2.6.27/arch/powerpc/include/asm/io.h	2006-06-22 02:44:19.000000000 +0000
@@ -445,6 +445,10 @@
 #define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
 #define page_to_bus(page)	(page_to_phys(page) + PCI_DRAM_OFFSET)
 
+#define isa_virt_to_bus virt_to_phys
+#define isa_page_to_bus page_to_phys
+#define isa_bus_to_virt phys_to_virt
+
 /* Enforce in-order execution of data I/O.
  * No distinction between read/write on PPC; use eieio for all three.
  */
--- linux-2.6.20/drivers/media/common/ir-keymaps.c.orig	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20/drivers/media/common/ir-keymaps.c	2007-02-17 22:22:39.327414970 +0100
@@ -151,10 +151,6 @@
 
 IR_KEYTAB_TYPE ir_codes_pixelview[IR_KEYTAB_SIZE] = {
 
-	[ 0x1e ] = KEY_POWER,       // power
-	[ 0x07 ] = KEY_MEDIA,       // source
-	[ 0x1c ] = KEY_SEARCH,      // scan
-
 /* FIXME: duplicate keycodes?
  *
  * These four keys seem to share the same GPIO as CH+, CH-, <<< and >>>
@@ -175,14 +171,10 @@
  */
 
 	[ 0x03 ] = KEY_TUNER,       // TV/FM
+	[ 0x07 ] = KEY_SEARCH,      // scan
+	[ 0x1c ] = KEY_ZOOM,        // zoom
 
-	[ 0x00 ] = KEY_RECORD,
-	[ 0x08 ] = KEY_STOP,
-	[ 0x11 ] = KEY_PLAY,
-
-	[ 0x1a ] = KEY_PLAYPAUSE,   // freeze
-	[ 0x19 ] = KEY_ZOOM,        // zoom
-	[ 0x0f ] = KEY_TEXT,        // min
+	[ 0x1e ] = KEY_POWER,       // power
 
 	[ 0x01 ] = KEY_1,
 	[ 0x0b ] = KEY_2,
@@ -195,20 +187,22 @@
 	[ 0x12 ] = KEY_9,
 	[ 0x02 ] = KEY_0,
 	[ 0x10 ] = KEY_LAST,        // +100
-	[ 0x13 ] = KEY_LIST,        // recall
+	[ 0x13 ] = KEY_LIST,        // loop
 
-	[ 0x1f ] = KEY_CHANNELUP,   // chn down
-	[ 0x17 ] = KEY_CHANNELDOWN, // chn up
-	[ 0x16 ] = KEY_VOLUMEUP,    // vol down
-	[ 0x14 ] = KEY_VOLUMEDOWN,  // vol up
+	[ 0x1f ] = KEY_VOLUMEUP,    // vol down
+	[ 0x17 ] = KEY_VOLUMEDOWN,  // vol up
+	[ 0x16 ] = KEY_CHANNELUP,   // chn down
+	[ 0x14 ] = KEY_CHANNELDOWN, // chn up
 
-	[ 0x04 ] = KEY_KPMINUS,     // <<<
+	[ 0x00 ] = KEY_MEDIA,       // source
+	[ 0x18 ] = KEY_MUTE,        // mute/unmute
+
+	[ 0x04 ] = KEY_KPMINUS,     // -
 	[ 0x0e ] = KEY_SETUP,       // function
-	[ 0x0c ] = KEY_KPPLUS,      // >>>
+	[ 0x0c ] = KEY_KPPLUS,      // +
 
-	[ 0x0d ] = KEY_GOTO,        // mts
-	[ 0x1d ] = KEY_REFRESH,     // reset
-	[ 0x18 ] = KEY_MUTE         // mute/unmute
+	[ 0x0d ] = KEY_REFRESH,     // reset
+	[ 0x0f ] = KEY_PLAYPAUSE    // freeze
 };
 
 EXPORT_SYMBOL_GPL(ir_codes_pixelview);
--- linux-2.6.22/drivers/sbus/char/cpwatchdog.c~	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22/drivers/sbus/char/cpwatchdog.c	2007-08-12 03:56:02.739993250 +0200
@@ -28,6 +28,7 @@
 #include <asm/ebus.h>
 #include <asm/oplib.h>
 #include <asm/uaccess.h>
+#include <asm/io.h>
 
 #include <asm/watchdog.h>
 
--- linux-2.6.27/arch/powerpc/include/asm/suspend.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.27/arch/powerpc/include/asm/suspend.h	2007-08-28 23:26:16.629658848 +0200
@@ -6,4 +6,7 @@
 void save_processor_state(void);
 void restore_processor_state(void);
 
+#define suspend2_faulted (0)
+#define clear_suspend2_fault() do { } while(0)
+
 #endif /* __ASM_POWERPC_SUSPEND_H */
--- linux-2.6.26/arch/powerpc/kernel/swsusp.c	2008-09-29 00:01:56.000000000 +0200
+++ linux-2.6.26/arch/powerpc/kernel/swsusp.c	2008-09-29 00:01:42.000000000 +0200
@@ -9,6 +9,7 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#include <linux/module.h>
 #include <linux/sched.h>
 #include <asm/suspend.h>
 #include <asm/system.h>
@@ -30,6 +31,7 @@
 #endif
 
 }
+EXPORT_SYMBOL(save_processor_state);
 
 void restore_processor_state(void)
 {
--- linux-2.6.27/security/security.c.orig	2008-10-09 22:13:53.000000000 +0000
+++ linux-2.6.27/security/security.c	2008-10-20 17:27:49.000000000 +0000
@@ -439,6 +439,7 @@
 		return 0;
 	return security_ops->inode_permission(inode, mask);
 }
+EXPORT_SYMBOL_GPL(security_inode_permission);
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
--- a/drivers/net/mv643xx_eth.c
+++ b/drivers/net/mv643xx_eth.c
@@ -38,6 +38,7 @@
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
 #include <linux/in.h>
+#include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <linux/etherdevice.h>
--- linux-2.6.27/fs/squashfs/inode.c~	2008-12-03 21:49:11.000000000 +0100
+++ linux-2.6.27/fs/squashfs/inode.c	2008-12-03 22:15:09.000000000 +0100
@@ -33,6 +33,7 @@
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
 #include <linux/exportfs.h>
+#include <linux/sched.h>
 
 #include "squashfs.h"
 
XFS: Fix hang after disallowed rename across directory quota domains

When project quota is active and is being used for directory tree
quota control, we disallow rename outside the current directory
tree. This requires a check to be made after all the inodes
involved in the rename are locked. We fail to unlock the inodes
correctly if we disallow the rename when the target is outside the
current directory tree. This results in a hang on the next access
to the inodes involved in failed rename.

Reported-by: Arkadiusz Miskiewicz <arekm@maven.pl>
Signed-off-by: Dave Chinner <david@fromorbit.com>
---
 fs/xfs/xfs_rename.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/fs/xfs/xfs_rename.c b/fs/xfs/xfs_rename.c
index d700dac..c903130 100644
--- a/fs/xfs/xfs_rename.c
+++ b/fs/xfs/xfs_rename.c
@@ -212,7 +212,7 @@ xfs_rename(
 	if (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
 		     (target_dp->i_d.di_projid != src_ip->i_d.di_projid))) {
 		error = XFS_ERROR(EXDEV);
-		xfs_rename_unlock4(inodes, XFS_ILOCK_SHARED);
+		xfs_rename_unlock4(inodes, XFS_ILOCK_EXCL);
 		xfs_trans_cancel(tp, cancel_flags);
 		goto std_return;
 	}

