--- linux-2.6.3/drivers/net/wan/tahoe9xx.c.orig	Fri Feb 27 11:58:16 2004
+++ linux-2.6.3/drivers/net/wan/tahoe9xx.c	Fri Feb 27 13:27:08 2004
@@ -265,7 +265,7 @@
 } ds21554_t;
 
 typedef struct port_s {
-	hdlc_device hdlc;	/* HDLC device struct - must be first */
+	struct net_device *dev;
 	struct card_s *card;
 	spinlock_t lock;	/* TX lock */
 	te1_settings settings;
@@ -361,21 +361,20 @@
 
 static int t9xx_open(struct net_device *dev)
 {
-	hdlc_device *hdlc = dev_to_hdlc(dev);
-	port_t *port = hdlc_to_port(hdlc);
+	port_t *port = dev_to_port(dev);
 	int	result;
 
 	if (!try_module_get(THIS_MODULE))
 		return -EFAULT;	/* rmmod in progress */
 
-	result = hdlc_open(hdlc);
+	result = hdlc_open(dev);
 
 	if (result) {
 		module_put(THIS_MODULE);
 		return result;
 	}
 
-	sca_open(hdlc);
+	sca_open(dev);
 	t9xx_set_iface(port);
 	sca_flush(port_to_card(port));
 	return 0;
@@ -385,11 +384,9 @@
 
 static int t9xx_close(struct net_device *dev)
 {
-	hdlc_device *hdlc = dev_to_hdlc(dev);
-
-	sca_close(hdlc);
+	sca_close(dev);
 	sca_flush(port_to_card(dev_to_port(dev)));
-	hdlc_close(hdlc);
+	hdlc_close(dev);
 	module_put(THIS_MODULE);
 	return 0;
 }
@@ -400,12 +397,11 @@
 {
 	const size_t size = sizeof(te1_settings);
 	te1_settings new_line, *line = ifr->ifr_settings.ifs_ifsu.te1;
-	hdlc_device *hdlc = dev_to_hdlc(dev);
-	port_t *port = hdlc_to_port(hdlc);
+	port_t *port = dev_to_port(dev);
 
 #ifdef CONFIG_HDLC_DEBUG_RINGS
 	if (cmd == SIOCDEVPRIVATE) {
-		sca_dump_rings(hdlc);
+		sca_dump_rings(dev);
 		return 0;
 	}
 #endif
@@ -463,8 +459,10 @@
 	else
 		ports = 1;
 	for(i = 0; i < ports; i++)
-		if (card->ports[i].card)
-			unregister_hdlc_device(&card->ports[i].hdlc);
+		if (card->ports[i].card) {
+			unregister_hdlc_device(card->ports[i].dev);
+			free_netdev(card->ports[i].dev);
+		}
 
 	if (card->irq)
 		free_irq(card->irq, card);
@@ -722,6 +720,17 @@
 	p = &card->plxbase->intr_ctrl_stat;
 	writew(readw(p) | 0x0040, p);
 
+	for(i = 0; i < card->no_ports; i++) {
+		card->ports[i].dev = alloc_hdlcdev(card);
+		if(!card->ports[i].dev) {
+			printk(KERN_ERR "tahoe9xx: unable to allocate memory\n");
+			if(i > 0)
+				free_netdev(card->ports[0].dev);
+			kfree(card);
+			return -ENOBUFS;
+		}
+	}
+
 	/* Allocate IRQ */
 	if(request_irq(pdev->irq, sca_intr, SA_SHIRQ, devname, card)) {
 		printk(KERN_WARNING "%s: could not allocate IRQ%d.\n", card->dev_name,
@@ -735,7 +744,8 @@
 
 	for(i = 0; i < card->no_ports; i++) {
 		port_t *port = &card->ports[i];
-		struct net_device *dev = hdlc_to_dev(&port->hdlc);
+		struct net_device *dev = port->dev;
+		hdlc_device *hdlc = dev_to_hdlc(dev);
 		port->phy_node = i;
 
 		spin_lock_init(&port->lock);
@@ -746,10 +756,10 @@
 		dev->do_ioctl = t9xx_ioctl;
 		dev->open = t9xx_open;
 		dev->stop = t9xx_close;
-		port->hdlc.attach = sca_attach;
-		port->hdlc.xmit = sca_xmit;
+		hdlc->attach = sca_attach;
+		hdlc->xmit = sca_xmit;
 		port->settings.clock_type = CLOCK_EXT;
-		if(register_hdlc_device(&port->hdlc)) {
+		if(register_hdlc_device(dev)) {
 			printk(KERN_ERR "%s: unable to register hdlc "
 			       "device\n", card->dev_name);
 			t9xx_pci_remove_one(pdev);
@@ -759,7 +769,7 @@
 		sca_init_sync_port(port);	/* Set up SCA memory */
 
 		printk(KERN_INFO "%s: %s node %d\n",
-		       hdlc_to_name(&port->hdlc), card->dev_name, port->phy_node);
+		       dev->name, card->dev_name, port->phy_node);
 	}
 
 	sca_flush(card);
