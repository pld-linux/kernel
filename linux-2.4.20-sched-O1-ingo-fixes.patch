diff -urN linux-2.4.20/include/linux/sched.h linux-2.4.20-interactive/include/linux/sched.h
--- linux-2.4.20/include/linux/sched.h	Sun Mar 16 23:39:08 2003
+++ linux-2.4.20-interactive/include/linux/sched.h	Sun Mar 16 23:40:18 2003
@@ -335,7 +335,7 @@
 	prio_array_t *array;
 
 	unsigned long sleep_avg;
-	unsigned long sleep_timestamp;
+	unsigned long last_run;
 
 	unsigned long policy;
 	unsigned long cpus_allowed;
diff -urN linux-2.4.20/kernel/fork.c linux-2.4.20-interactive/kernel/fork.c
--- linux-2.4.20/kernel/fork.c	Sun Mar 16 23:38:02 2003
+++ linux-2.4.20-interactive/kernel/fork.c	Sun Mar 16 23:40:18 2003
@@ -724,7 +724,7 @@
 		current->time_slice = 1;
 		scheduler_tick(0,0);
 	}
-	p->sleep_timestamp = jiffies;
+	p->last_run = jiffies;
 	__sti();
 
 	/*
diff -urN linux-2.4.20/kernel/sched.c linux-2.4.20-interactive/kernel/sched.c
--- linux-2.4.20/kernel/sched.c	Sun Mar 16 23:38:57 2003
+++ linux-2.4.20-interactive/kernel/sched.c	Sun Mar 16 23:40:18 2003
@@ -47,18 +47,18 @@
 /*
  * These are the 'tuning knobs' of the scheduler:
  *
- * Minimum timeslice is 10 msecs, default timeslice is 150 msecs,
- * maximum timeslice is 300 msecs. Timeslices get refilled after
+ * Minimum timeslice is 10 msecs, default timeslice is 100 msecs,
+ * maximum timeslice is 200 msecs. Timeslices get refilled after
  * they expire.
  */
 #define MIN_TIMESLICE		( 10 * HZ / 1000)
-#define MAX_TIMESLICE		(300 * HZ / 1000)
+#define MAX_TIMESLICE		(200 * HZ / 1000)
 #define CHILD_PENALTY		50
 #define PARENT_PENALTY		100
 #define PRIO_BONUS_RATIO	25
 #define INTERACTIVE_DELTA	2
-#define MAX_SLEEP_AVG		(2*HZ)
-#define STARVATION_LIMIT	(2*HZ)
+#define MAX_SLEEP_AVG		(10*HZ)
+#define STARVATION_LIMIT	(10*HZ)
 
 /*
  * If a task is 'interactive' then we reinsert it in the active
@@ -239,24 +239,23 @@
 #define activate_task(p, rq) __activate_task(p, rq, NULL)
 static inline void __activate_task(task_t *p, runqueue_t *rq, task_t * parent)
 {
-	unsigned long sleep_time = jiffies - p->sleep_timestamp;
-	prio_array_t *array = rq->active;
+	long sleep_time = jiffies - p->last_run - 1;
 
-	if (!parent && !rt_task(p) && sleep_time) {
+	if (!parent && !rt_task(p) && sleep_time > 0) {
 		/*
 		 * This code gives a bonus to interactive tasks. We update
 		 * an 'average sleep time' value here, based on
-		 * sleep_timestamp. The more time a task spends sleeping,
+		 * ->last_run. The more time a task spends sleeping,
 		 * the higher the average gets - and the higher the priority
 		 * boost gets as well.
 		 */
-		p->sleep_timestamp = jiffies;
+		p->last_run = jiffies;
 		p->sleep_avg += sleep_time;
 		if (p->sleep_avg > MAX_SLEEP_AVG)
 			p->sleep_avg = MAX_SLEEP_AVG;
 		p->prio = effective_prio(p);
 	}
-	__enqueue_task(p, array, parent);
+	__enqueue_task(p, rq->active, parent);
 	rq->nr_running++;
 }
 
@@ -374,9 +373,14 @@
 #endif
 		if (old_state == TASK_UNINTERRUPTIBLE)
 			rq->nr_uninterruptible--;
-		activate_task(p, rq);
-		if (p->prio < rq->curr->prio)
-			resched_task(rq->curr);
+		if (sync) {
+			enqueue_task(p, rq->active);
+			rq->nr_running++;
+		} else {
+			activate_task(p, rq);
+			if (p->prio < rq->curr->prio)
+				resched_task(rq->curr);
+		}
 		success = 1;
 	}
 	p->state = TASK_RUNNING;
@@ -453,7 +457,16 @@
 	}
 
 	p->cpu = smp_processor_id();
-	__activate_task(p, rq, parent);
+	if (unlikely(!current->array)) {
+		__enqueue_task(p, rq->active, parent);
+		rq->nr_running++;
+	} else {
+		p->prio = current->prio;
+		list_add_tail(&p->run_list, &current->run_list);
+		p->array = current->array;
+		p->array->nr_active++;
+		rq->nr_running++;
+	}
 	spin_unlock_irq(&rq->lock);
 }
 
@@ -586,6 +599,11 @@
 	 */
 	if (p->prio < this_rq->curr->prio)
 		resched = 1;
+	else {
+		if (p->prio == this_rq->curr->prio &&
+				p->time_slice > this_rq->curr->time_slice)
+			resched = 1;
+	}
 
 	return resched;
 }
@@ -751,7 +769,7 @@
 	 */
 
 #define CAN_MIGRATE_TASK(p,rq,this_cpu)					\
-	((jiffies - (p)->sleep_timestamp > cache_decay_ticks) &&	\
+	((jiffies - (p)->last_run > cache_decay_ticks) &&	\
 		((p) != (rq)->curr) &&					\
 			((p)->cpus_allowed & (1UL << (this_cpu))))
 
@@ -813,9 +831,9 @@
  * increasing number of running tasks:
  */
 #define EXPIRED_STARVING(rq) \
-		((rq)->expired_timestamp && \
+		(STARVATION_LIMIT && ((rq)->expired_timestamp && \
 		(jiffies - (rq)->expired_timestamp >= \
-			STARVATION_LIMIT * ((rq)->nr_running) + 1))
+			STARVATION_LIMIT * ((rq)->nr_running) + 1)))
 
 /*
  * This function gets called by the timer code, with HZ frequency.
@@ -918,7 +936,7 @@
 	rq = this_rq();
 
 	release_kernel_lock(prev, smp_processor_id());
-	prev->sleep_timestamp = jiffies;
+	prev->last_run = jiffies;
 	spin_lock_irq(&rq->lock);
 
 	switch (prev->state) {
@@ -1299,8 +1317,10 @@
 		p->prio = MAX_USER_RT_PRIO-1 - p->rt_priority;
 	else
 		p->prio = p->static_prio;
-	if (array)
-		activate_task(p, task_rq(p));
+	if (array) {
+		enqueue_task(p, task_rq(p)->active);
+		task_rq(p)->nr_running++;
+	}
 
 out_unlock:
 	task_rq_unlock(rq, &flags);
diff -urN linux-2.4.20/kernel/softirq.c linux-2.4.20-interactive/kernel/softirq.c
--- linux-2.4.20/kernel/softirq.c	Sun Mar 16 23:38:03 2003
+++ linux-2.4.20-interactive/kernel/softirq.c	Sun Mar 16 23:40:18 2003
@@ -99,10 +99,9 @@
 			mask &= ~pending;
 			goto restart;
 		}
-		__local_bh_enable();
-
 		if (pending)
 			wakeup_softirqd(cpu);
+		__local_bh_enable();
 	}
 
 	local_irq_restore(flags);
